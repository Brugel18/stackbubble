{'ViewCount': '14352', 'Title': 'How to convert finite automata to regular expressions?', 'LastEditDate': '2014-03-22T11:29:26.503', 'AnswerCount': '4', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '18', 'Body': '<p>Converting regular expressions into (minimal) NFA that accept the same language is easy with standard algorithms, e.g. <a href="http://en.wikipedia.org/wiki/Thompson%27s_construction_algorithm" rel="nofollow">Thompson\'s algorithm</a>. The other direction seems to be more tedious, though, and sometimes the resulting expressions are messy.</p>\n\n<p>What algorithms are there for converting NFA into equivalent regular expressions? Are there advantages regarding time complexity or result size?</p>\n\n<p><sup>This is supposed to be a reference question. Please include a general decription of your method as well as a non-trivial example.</sup></p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:29:26.503', 'CommentCount': '2', 'AcceptedAnswerId': '2389', 'CreationDate': '2012-05-23T08:19:27.003', 'Id': '2016'}


{'ViewCount': '11911', 'Title': 'How to prove that a language is not regular?', 'LastEditDate': '2013-06-06T13:54:20.203', 'AnswerCount': '5', 'Score': '26', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '21', 'Body': '<p>We learned about the class of regular languages $\\mathrm{REG}$. It is characterised by any one concept among regular expressions, finite automata and left-linear grammars, so it is easy to show that a given language is regular.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for all regular expressions (or for all finite automata, or for all left-linear grammars) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n\n<p><em><sup>This is intended to be a reference question collecting usual proof methods and application examples. See <a href="http://cs.stackexchange.com/q/265/98">here</a> for the same question on context-free languages.</sup></em></p>\n', 'Tags': '<formal-languages><regular-languages><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-07-01T12:50:16.730', 'CommentCount': '4', 'AcceptedAnswerId': '1033', 'CreationDate': '2012-04-04T10:30:32.163', 'Id': '1031'}


{'Body': "<p>Speaking in terms of automata and regular languages, how would it be possible for a string repeating some $w$ twice equal a string repeating that same $w$ thrice? That is, why is the language</p>\n\n<p>$\\qquad L = \\{w \\in \\Sigma^ * \\mid ww = www\\}$</p>\n\n<p>not empty? The only thing I can think of is $w = abab, ww = abababab, www = abababababab$, but I don't think this is correct.</p>\n", 'ViewCount': '5901', 'Title': 'How can $ww = www$ hold for any word $w$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:49:11.747', 'LastEditDate': '2013-02-02T13:49:11.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '9401', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-02-01T16:48:32.013', 'Id': '9396'}


{'Body': "<p>How can we design a regular expressions without particular substrings.\nThe goal of this is to create language <code>L</code> which won't contain a particular substring (i.e. 110)</p>\n\n<p>for the case of a regular expression without substring $110$, I Was thinking of: $\\require{cancel}\\cancel{(101)^*+}(010)^*+(10)^*+(\\cancel{1}1)^*+(\\cancel{0}0)^*+(01)^*$ but is that over excessive?</p>\n\n<p>Then for example, I crossed out (101)* because obviously if you have two of those 101101, a subset of that will be 110, which we don't want.</p>\n\n<h3>Notes:</h3>\n\n<p>Question has been edited since it gained attention in the past few days. Also see comment for justification.</p>\n", 'ViewCount': '3292', 'Title': 'Regular expression for the strings without a particular substring', 'LastEditorUserId': '6980', 'LastActivityDate': '2014-01-31T12:46:01.967', 'LastEditDate': '2014-01-31T12:46:01.967', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '11791', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-05-04T23:46:05.660', 'Id': '11787'}


{'Body': '<p>I\'m unclear about the use of the phrases "infinite" language or "finite" language in computer theory.</p>\n\n<p>I think the root of the trouble is that a language like $L=\\{ab\\}^*$ is <strong>infinite</strong> in the sense that it can generate an infinite (but countable) number of strings. Yet, it can still be recognized by a <strong>finite</strong> state automaton. </p>\n\n<p>It also doesn\'t help that the Sipser book doesn\'t really make this distinction (at least as far as I can tell). A question about infinite/finite languages and their relationship to regular languages came up in a sample exam.</p>\n', 'ViewCount': '3132', 'Title': 'Infinite Language vs. finite language', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-12T16:08:33.073', 'LastEditDate': '2012-11-11T00:49:47.817', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4547', 'Tags': '<formal-languages><terminology><regular-languages>', 'CreationDate': '2012-11-10T23:43:32.613', 'FavoriteCount': '2', 'Id': '6609'}


{'ViewCount': '2459', 'Title': 'Is a push-down automaton with two stacks equivalent to a turing machine?', 'LastEditDate': '2012-08-13T10:22:59.483', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'Lazer', 'PostTypeId': '1', 'OwnerUserId': '1558', 'FavoriteCount': '2', 'Body': '<p>In <a href="http://stackoverflow.com/a/559969/113124">this answer</a> it is mentioned</p>\n\n<blockquote>\n  <p>A regular language can be recognized by a finite automaton. A context-free language requires a stack, and <strong>a context sensitive language requires two stacks (which is equivalent to saying it requires a full Turing machine)</strong>.</p>\n</blockquote>\n\n<p>I wanted to know regarding the truth of the bold part above. Is it in fact true or not? What is a good way to reach at an answer to this?</p>\n', 'Tags': '<computability><automata><turing-machines>', 'LastEditorUserId': '917', 'LastActivityDate': '2012-08-13T10:22:59.483', 'CommentCount': '5', 'AcceptedAnswerId': '2833', 'CreationDate': '2012-07-19T10:50:44.883', 'Id': '2832'}


{'Body': "<blockquote>\n  <ul>\n  <li>System has a two level paging scheme</li>\n  <li>Average CPU time for a instruction = 100ns</li>\n  <li>Average number of memory accesses per instruction = 2</li>\n  <li>Regular memory access = 150 ns</li>\n  <li>Page fault service time = 8ms</li>\n  <li>TLB hit ratio = 0.9</li>\n  <li>Page fault rate = 0.0001 </li>\n  </ul>\n  \n  <p>What is the average instruction time if the time required for address translation is negligible?</p>\n</blockquote>\n\n<p>I worked out the solution as follows</p>\n\n<pre><code>Average instruction execution time = CPU time + Memory access time\n\nMemory access time = No. of memory accesses by the instruction * average memory access time\n\nAverage memory access time = \n [probability of a TLB hit * regular memory access time]\n + [probability of a TLB miss * (Time for accessing the 1st level of the paging tables\n     + Time for accessing the 2nd level of the paging tables\n     + Time for accessing memory which may not be paged in with the translated address)]\n\nTime for accessing the 1st level of the paging tables \n= Time for accessing the 2nd level of the paging tables \n= Time for accessing memory which may not be paged in with the translated address\n    = [probability of a page fault * (page fault service time + regular memory access time) ]\n      + [probability of no page fault * regular memory access time]\n    = [0.0001 * (8 ms + 150ns)]  + [0.9999 * 150 ns]\n    = 950 ns\n\nThus, average time per memory access = [0.9 * 150ns] + [0.1 * 3 * 950ns] = 420ns\n\nAverage instruction execution time = 100ns + (2 * 420ns) = 940ns\n</code></pre>\n\n<p>However the choices for this question are 645ns, 1050ns, 1215ns and 1230 ns.</p>\n\n<p>I can't seem to be able to see where I have reasoned wrong.</p>\n\n<p><strong>EDIT</strong>\n<hr>\nAverage number of memory accesses per instruction is 2</p>\n", 'ViewCount': '2161', 'Title': 'Calculation of effective average instruction execution time in a 2-level paging system', 'LastEditorUserId': '2980', 'LastActivityDate': '2012-11-28T07:53:04.243', 'LastEditDate': '2012-11-26T13:12:10.997', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<operating-systems><virtual-memory><paging>', 'CreationDate': '2012-11-26T10:39:39.307', 'Id': '6913'}


{'Body': u'<p>So I\'ve been trying to crack this for a long time and almost feel like I am going in loops about this question.</p>\n\n<p>Given the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hL3Ps.png" alt="enter image description here"></p>\n\n<p>Using the GNFA algorithm get the regular expression.</p>\n\n<p>I understand that you would have the following for the first step(adding empty states):\n<img src="http://i.stack.imgur.com/6XXjj.png" alt="enter image description here"></p>\n\n<p>The next step would be removing the state [q1] I would get:\n<img src="http://i.stack.imgur.com/cwjUd.png" alt="enter image description here"></p>\n\n<p>Finally removing [q2] would get:\n<img src="http://i.stack.imgur.com/WW3Fj.png" alt="enter image description here"></p>\n\n<p>However the answers others have got is:\n$(a \\cup bb^*a)^*bb^*$\nWhich does not make sense as I got, $a^*b(b \\cup aa^*b)^*$?\nA GNFA(generalised nondeterministic finite automaton) is described as follows:</p>\n\n<p>A GNFA is similar to an NFA but must obey certain rules: </p>\n\n<ul>\n<li>It has only one accept state</li>\n<li>The initial state has no transitions coming into it</li>\n<li>The accept state has no transitions coming out from it</li>\n<li>A transition can denote any regular expression, rather than just a\nsymbol from the alphabet Note that a symbol is a kind of regular\nexpression.</li>\n</ul>\n\n<p>Furthermore, We may convert an NFA into a GNFA as follows: </p>\n\n<ul>\n<li>Add a new start state with an \u03b5-transition to the old start state</li>\n<li>Add a new accept state with \u03b5-transitions from the old accept states</li>\n<li>If arrows have multiple labels, or if there are multiple arrows\nbetween two states, replace them with the union (or) of those labels</li>\n</ul>\n', 'ViewCount': '2097', 'Title': 'Converting an NFA to regex using GNFA algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:23:30.563', 'LastEditDate': '2013-05-12T10:23:30.563', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '11950', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata><regular-expressions><nondeterminism>', 'CreationDate': '2013-05-10T14:50:56.853', 'Id': '11935'}


{'Body': '<blockquote>\n  <p>Let $L_1$ be regular, $L_1 \\cap L_2$ regular, $L_2$ not regular. Show that $L_1 \\cup L_2$ is not regular or give a counterexample.</p>\n</blockquote>\n\n<p>I tried this: Look at $L_1 \\backslash (L_2 \\cap L_1)$. This one is regular. I can construct a finite automata for this ($L_1$ is regular, $L_2 \\cap L_1$ is regular, so remove all the paths (finite amount) for $L_1 \\cap L_2$ from the finite amount of paths for $L_1$. So there is a finite amount of paths left for this whole thing. This thing is disjoint from $L_2$, but how can I prove that the union of $L_1 \\backslash (L_1 \\cap L_2)$ (regular) and $L_2$ (not regular) is not regular?</p>\n', 'ViewCount': '2072', 'Title': 'Proof that union of a regular and a not regular language is not regular', 'LastEditorUserId': '667', 'LastActivityDate': '2014-04-19T06:24:37.110', 'LastEditDate': '2012-07-17T18:05:14.560', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-06-28T20:00:17.477', 'Id': '2537'}


{'Body': u'<p>Consider this example (taken from this document: <a href="http://www.cs.nott.ac.uk/~txa/g51mal/notes-3x.pdf" rel="nofollow">Showing that language is not regular</a>):</p>\n\n<p>$$L = \\{1^n \\mid n\\text{ is even}\\} $$</p>\n\n<p>According to the Pumping Lemma, a language $L$ is regular if :</p>\n\n<ul>\n<li>$y \\ne \u03b5$</li>\n<li>$|xy| \\lt n$</li>\n<li>$\\forall k \\in N, xy^kz \\in L$</li>\n</ul>\n\n<p>In the above example, $n$ must be even. Suppose we have $n = 4$, we can express: $$xy^kz$$ such that: $x = 1$, $z = 1$, and with $k = 2$, we have $y^k = y^2 = 11$, so we get the string $1111$. However, since all $k$ must be satisfied, if $k = 1$, the string is $111$, it does not belong to $L$. Yet, I was told that the above example is a regular language. How can it be?</p>\n', 'ViewCount': '1940', 'Title': 'Why is this example a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T14:46:55.897', 'LastEditDate': '2012-05-10T14:46:55.897', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1707', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<formal-languages><regular-languages><proof-techniques>', 'CreationDate': '2012-05-07T03:45:04.323', 'Id': '1706'}


