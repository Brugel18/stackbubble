{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '191', 'Title': 'Is the type inference here really complicated?', 'LastEditDate': '2012-07-17T06:14:48.490', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1689', 'FavoriteCount': '0', 'Body': '<p>There\'s a <a href="http://stackoverflow.com/questions/9058430/why-doesnt-immutablemap-builder-build-pick-the-correct-type-parameters">question on SO</a> asking why in Java the right type doesn\'t get picked in a concrete case. I know that Java can\'t do it in such "complicated" cases, but I\'m asking myself <em>WHY</em>?</p>\n\n<p>The (for simplicity slightly modified) line failing to compile is</p>\n\n<pre><code>Map&lt;String, Number&gt; m = ImmutableMap.builder().build();\n</code></pre>\n\n<p>and the methods are defined as<sup>1</sup></p>\n\n<pre><code>class ImmutableMap {\n    public static &lt;K1, V1&gt; Builder&lt;K1, V1&gt; builder() {...}\n    ...\n}\n\nclass Builder&lt;K2, V2&gt; {\n    public ImmutableMap&lt;K2, V2&gt; build() {...}\n    ...\n}\n</code></pre>\n\n<p>The solution <code>K1=K2=String</code> and <code>V1=V2=Number</code> is obvious to everyone but the compiler. There are 4 variables here and I can see 4 trivial equations, so what\'s the problem with type inference here?</p>\n\n<p><sup>1</sup>I simplified the <a href="http://guava-libraries.googlecode.com/git/guava/src/com/google/common/collect/ImmutableMap.java" rel="nofollow">code piece from Guava</a> for this example and numbered the type variables to make it (hopefully) clearer.</p>\n', 'Tags': '<programming-languages><typing><java><type-inference>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T06:14:48.490', 'CommentCount': '5', 'AcceptedAnswerId': '2529', 'CreationDate': '2012-06-28T00:23:38.443', 'Id': '2521'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>At work I\u2019ve been tasked with inferring some type information about a dynamic language. I rewrite sequences of statements into nested <code>let</code> expressions, like so:</p>\n\n<pre><code>return x; Z            =&gt;  x\nvar x; Z               =&gt;  let x = undefined in Z\nx = y; Z               =&gt;  let x = y in Z\nif x then T else F; Z  =&gt;  if x then { T; Z } else { F; Z }\n</code></pre>\n\n<p>Since I\u2019m starting from general type information and trying to deduce more specific types, the natural choice is refinement types. For example, the conditional operator returns a union of the types of its true and false branches. In simple cases, it works very well.</p>\n\n<p>I ran into a snag, however, when trying to infer the type of the following:</p>\n\n<pre><code>function g(f) {\n  var x;\n  x = f(3);\n  return f(x);\n}\n</code></pre>\n\n<p>Which is rewritten to:</p>\n\n<pre><code>\\f.\n  let x = undefined in\n    let x = f 3 in\n      f x\n</code></pre>\n\n<p>HM would infer $\\mathtt{f} : \\mathtt{Int} \\to \\mathtt{Int}$ and consequently $\\mathtt{g} : (\\mathtt{Int} \\to \\mathtt{Int}) \\to \\mathtt{Int}$. The actual type I want to be able to infer is:</p>\n\n<p>$$\\mathtt{g} : \\forall \\tau_1 \\tau_2. \\:(\\mathtt{Int} \\to \\tau_1 \\land \\tau_1 \\to \\tau_2) \\to \\tau_2$$</p>\n\n<p>I\u2019m already using functional dependencies to resolve the type of an overloaded <code>+</code> operator, so I figured it was a natural choice to use them to resolve the type of <code>f</code> within <code>g</code>. That is, the types of <code>f</code> in all its applications together uniquely determine the type of <code>g</code>. However, as it turns out, fundeps don\u2019t lend themselves terribly well to variable numbers of source types.</p>\n\n<p>Anyway, the interplay of polymorphism and refinement typing is problematic. So is there a better approach I\u2019m missing? I\u2019m currently digesting \u201cRefinement Types for ML\u201d and would appreciate more literature or other pointers.</p>\n', 'ViewCount': '147', 'Title': 'Inferring refinement types', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-02T06:20:29.877', 'LastEditDate': '2012-08-02T06:20:29.877', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2980', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1821', 'Tags': '<programming-languages><logic><type-theory><type-inference>', 'CreationDate': '2012-07-26T23:18:16.810', 'Id': '2919'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>It was brought to my attention that the cost of type inference in a functional language like OCaml can be very high. The claim is that there is a sequence of expressions such that for each expression the length of the corresponding type is exponential on the length of the expression.</p>\n\n<p>I devised the sequence below. My question is: do you know of a sequence with more concise expressions that achieves the same types?</p>\n\n<pre><code># fun a -&gt; a;;\n- : 'a -&gt; 'a = &lt;fun&gt;\n# fun b a -&gt; b a;;\n- : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;\n# fun c b a -&gt; c b (b a);;\n- : (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'c = &lt;fun&gt;\n# fun d c b a -&gt; d c b (c b (b a));;\n- : ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'd\n= &lt;fun&gt;\n# fun e d c b a -&gt; e d c b (d c b (c b (b a)));;\n- : (((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n   ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'e\n= &lt;fun&gt;\n# fun f e d c b a -&gt; f e d c b (e d c b (d c b (c b (b a))));;\n- : ((((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n     (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n    ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'e -&gt; 'f) -&gt;\n   (((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n   ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'f\n= &lt;fun&gt;\n</code></pre>\n", 'ViewCount': '332', 'Title': 'Concise example of exponential cost of ML type inference', 'LastEditorUserId': '4554', 'LastActivityDate': '2012-11-11T20:23:32.303', 'LastEditDate': '2012-11-11T19:48:39.593', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '8', 'OwnerDisplayName': 'mrrusof', 'PostTypeId': '1', 'OwnerUserId': '4554', 'Tags': '<lambda-calculus><type-theory><functional-programming><type-inference><type-checking>', 'CreationDate': '2012-11-11T14:01:45.770', 'Id': '6617'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '257', 'Title': 'How can SML infer types like this?', 'LastEditDate': '2013-02-02T13:58:58.873', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1590', 'FavoriteCount': '0', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Standard_ML" rel="nofollow">Wikipedia says</a>:</p>\n\n<pre><code>fun factorial n = \n    if n = 0 then 1 else n * factorial (n-1) \n</code></pre>\n\n<blockquote>\n  <p>A Standard ML compiler is required to infer the static type int -> int of this function\n  without user-supplied type annotations. I.e., it has to deduce that n\n  is only used with integer expressions, and must therefore itself be an\n  integer, and that all value-producing expressions within the function\n  return integers.</p>\n</blockquote>\n\n<p>I don\'t understand how a compiler could infer this. It sounds like SML is essentially solving the halting problem for the <code>factorial</code> function, and showing that it only halts on positive integer inputs. </p>\n\n<p>Am I missing something?</p>\n', 'Tags': '<compilers><functional-programming><type-theory><type-inference>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T06:37:00.357', 'CommentCount': '0', 'AcceptedAnswerId': '9411', 'CreationDate': '2013-02-01T23:24:31.383', 'Id': '9407'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>From my recitation class  - </p>\n\n<p><img src="http://i.stack.imgur.com/Zn74M.jpg" alt="enter image description here"></p>\n\n<p>Can you please explain </p>\n\n<ul>\n<li><p>why does operator  $"+"$ signature is  $  int \\rightarrow (int \\rightarrow int)$ ?</p></li>\n<li><p>How does this graph is build  ?</p></li>\n<li><p>And what is mean $t=u \\rightarrow s$  ?</p></li>\n</ul>\n\n<p>Thanks in advance . </p>\n', 'ViewCount': '61', 'Title': 'ML - Type Interface', 'LastActivityDate': '2013-02-27T00:50:30.403', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10132', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4409', 'Tags': '<programming-languages><functional-programming><type-inference><type-checking>', 'CreationDate': '2013-02-26T23:54:27.973', 'FavoriteCount': '1', 'Id': '10131'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m working on a type system with extensible records, similar to ones explained in "<a href="http://web.cecs.pdx.edu/~mpj/pubs/polyrec.html" rel="nofollow">A Polymorphic Type System for Extensible Records and Variants - Benedict R. Gaster and Mark P. Jones</a>" and "<a href="http://research.microsoft.com/pubs/65409/scopedlabels.pdf" rel="nofollow">Extensible records with scoped labels - Daan Leijen</a>",</p>\n\n<p>I already have a working implementation but I followed a completely different path for implementation(for example, I didn\'t use kinds, instead I used different variables with different types, this also helped me add arbitrary properties to variables, like absent label list). Now I want to implement it like explained in this two papers,</p>\n\n<p>And the problem is, I can\'t see how can fields and rows with "absent" specifiers can be implemented. Both papers using a simple type constant for record update operations, but types or kinds are not allowing specifying field labels, or absent field names in row variables.</p>\n\n<p>So can anyone help me understand how can field labels and absent fields can be specified in simple kind/type system explained in these two papers?</p>\n\n<p>Thanks in advance.</p>\n\n<p>EDIT: To clarify things,</p>\n\n<p>Here\'s a language of kinds and types described in papers mentioned above: (in haskell syntax)</p>\n\n<pre><code>data Kind = KStar | KRow | KFun Kind Kind\n\ndata Type = TCon Typeconstant\n          | TVar Typevar\n          | TAp Type Type -- type application\n</code></pre>\n\n<p>What I meant to say was I couldn\'t see a way to encode row types with this language. ie. there is no way to encode type of this function:</p>\n\n<pre><code>row_extend r = r.a = 10\n</code></pre>\n\n<p>Because there is now way to tell in types that this function adds or updates \'a field with label <code>a</code>\'.</p>\n\n<p>I can\'t give types to record operations in this language(given as Haskell code above).</p>\n', 'ViewCount': '108', 'Title': 'Encoding row types', 'LastEditorUserId': '5209', 'LastActivityDate': '2013-04-28T10:44:55.337', 'LastEditDate': '2013-04-28T10:44:55.337', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5209', 'Tags': '<type-theory><type-inference><type-checking>', 'CreationDate': '2013-04-27T21:13:14.737', 'FavoriteCount': '1', 'Id': '11613'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I think of type as a range of values that the variable can take whereas the rest is known constant or does not matter. Variables (instances or objects), which share common properties, are considered to belong to the same type/kind/class. That is, the type properties are constant across the type. The type is actually a common property of a class of objects (variables). The variables have a variable part, which may change, making them flipping from one subtype to the other. However, the same applies to subtypes: subtypes also share a common constant property.</p>\n\n<p>I may describe a class by a circle in Vienn Diagramm. Its subspheres would be types or variables. I think that the variable means that it has some fixed part, its type, and variable part, which make it variable and not constant. The constants or values would be an elementary point in the diagramm. </p>\n\n<p>For instance, integer is a subtype of real. Integer variable means that it can take concrete values within the range of the integer area. Similarly, boolean variables, taking only values 0 and 1, are subtype of integer. But, what is a constant 1? Is it a real or integer or boolean variable or it is a specific type, instances of which have a common property: they have a value of 1? Is it a known treatment?</p>\n\n<p>My interest stems from the practice: how can I save memory fixing the common part of variables in a language processing framework?</p>\n', 'ViewCount': '86', 'Title': 'Is constant a variable or subtype?', 'LastActivityDate': '2013-05-31T10:52:28.827', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<type-theory><type-inference><inductive-datatypes>', 'CreationDate': '2013-05-30T10:01:44.873', 'Id': '12372'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '360', 'Title': 'What makes type inference for dependent types undecidable?', 'LastEditDate': '2013-10-09T18:44:37.213', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '8685', 'FavoriteCount': '1', 'Body': '<p>I have seen it mentioned that dependent type systems are not inferable, but are checkable. I was wondering if there is a simple explanation of why that is so, and whether or not there is there a limit of "dependency" where types can be indexed by values, below which type inference is possible and above which it is not?</p>\n', 'Tags': '<undecidability><type-theory><type-inference><dependent-types>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:37.213', 'CommentCount': '2', 'AcceptedAnswerId': '12957', 'CreationDate': '2013-06-15T15:35:18.983', 'Id': '12691'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am looking into Hindler-Milney type system and I am trying to add support for\nthe pair type. In Pierces book, he introduces special language constructs for creation of pairs and getting their elements.</p>\n\n<p>What I am interested in is the following. What if I don't introduce new constructs, yet use special functions with this signatures: </p>\n\n<p>$$pair: \\alpha \\rightarrow \\beta \\rightarrow \\alpha \\times \\beta $$ </p>\n\n<p>$$proj1: \\alpha \\times \\beta \\rightarrow \\alpha$$ </p>\n\n<p>$$proj2: \\alpha \\times \\beta \\rightarrow \\beta $$</p>\n\n<p>If I use Wand's algorithm for type inference, after collecting all equations between type expressions and solving it a bit, I get the following equation\nfor $((pair\\; 2\\;) 4): \\tau$:</p>\n\n<p>$$\\alpha \\rightarrow \\beta \\rightarrow \\alpha \\times \\beta = Int \\rightarrow Int \\rightarrow \\tau$$</p>\n\n<p>It seems to me that the unification algorithm should infer at the end that $\\tau = Int \\times Int$. Is this true? </p>\n\n<p>Do I really need a special construct for pairs? Is there something conceptually wrong with this? Probably their is, so it would be great if someone could point me out. </p>\n\n<p>Note that I would also prefer using special constructs as that way looks cleaner and easier to program with; this question is just for my complete understanding of the subject.</p>\n", 'ViewCount': '51', 'Title': 'Type inference of pair (product) types', 'LastActivityDate': '2013-10-02T20:49:19.097', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14759', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<type-theory><type-inference><unification>', 'CreationDate': '2013-10-02T15:57:00.007', 'Id': '14754'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m reading about this algorithm while writing an implementation, and see that, as long as every variable is bound, you\'ll always get either atomic types or types where the arguments will determine the final type, such as <code>t1 -&gt; t1</code> or <code>(t1 -&gt; t2) -&gt; (t1 -&gt; t2)</code>. </p>\n\n<p>I cannot think of a way you\'d get something like <code>t1 -&gt; t2</code> or simply <code>t1</code>, which I understand would mean the algorithm is broken since there would be no way to determine the actual type of the expression. How do you know you\'ll never get a type such as these "broken" ones as long as every variable is bound?</p>\n\n<p><strong>EDIT</strong> Seems that you can get these "broken" types in ML, but I\'m asking about lambda calculus.</p>\n', 'ViewCount': '97', 'Title': 'Why will the Hindley-Milner algorithm never yield a type like t1 -> t2?', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-01-01T17:44:44.103', 'LastEditDate': '2014-01-01T17:44:44.103', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '19431', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><type-theory><typing><type-inference>', 'CreationDate': '2014-01-01T03:28:39.107', 'Id': '19430'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '143', 'Title': 'Define a list using only the Hindley-Milner type system', 'LastEditDate': '2014-01-30T20:26:58.877', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10401', 'FavoriteCount': '3', 'Body': u'<p>I\'m working on a small lambda calculus compiler that has a <a href="http://codereview.stackexchange.com/questions/38763/is-this-implementation-of-the-hindley-milner-algorithm-correct">working Hindley-Milner type inference system</a> and now also supports recursive let\'s (not in the linked code), which I understand <a href="http://cs.stackexchange.com/questions/19187/would-adding-recursive-named-functions-to-simply-typed-lambda-calculus-make-it-t">should be enough to make it Turing complete</a>. </p>\n\n<p>The problem now is I have no idea how to make it support lists, or whether it already does support them and I just need to find a way to encode them. I\'d like to be able to define them without having to add new rules to the type system.</p>\n\n<p>The easiest way I can think of a list of <code>x</code> is as something that is either <code>null</code> (or the empty list), or a pair that contains both an <code>x</code> and a list of <code>x</code>. But to do this I need to be able to define pairs and or\'s, which I believe are the product and the sum types.</p>\n\n<p>Seems that I can define pairs this way:</p>\n\n<pre><code>pair = \u03bbabf.fab\nfirst = \u03bbp.p(\u03bbab.a)\nsecond = \u03bbp.p(\u03bbab.b)\n</code></pre>\n\n<p>Since <code>pair</code> would have the type <code>a -&gt; (b -&gt; ((a -&gt; (b -&gt; x)) -&gt; x))</code>, after passing, say, an <code>int</code> and a <code>string</code>, it\'d yield something with type <code>(int -&gt; (string -&gt; x)) -&gt; x</code>, which would be the representation of a pair of <code>int</code> and <code>string</code>. What bothers me here is that if that represents a pair, why is that not logically equivalent to, nor implies the proposition <code>int and string</code>?. However, is equivalent to <code>(((int and string) -&gt; x) -&gt; x)</code>, as if I could only have product types as parameters to functions. <a href="http://mathoverflow.net/a/151319">This answer</a> seem to address this problem, but I have no idea what the symbols he uses mean. Also, if this does not really encode a product type, is there anything I can do with product types I couldn\'t do with my definition of pairs above (considering I can also define n-tuples the same way)? If not, wouldn\'t this contradict the fact that you cannot express (AFAIK) conjunction using only implication?</p>\n\n<p>Also, how about the sum type? Can I somehow encode it using only the function type? If so, would this be enough to define lists? Or else, is there any other way to define lists without having to extend my type system? And if not, what changes would I need to make if I want to keep it as simple as possible?</p>\n\n<p>Please keep in mind that I\'m a computer programmer but not a computer scientist nor a mathematician and pretty bad at reading math notation.</p>\n\n<p><strong>Edit:</strong>  I\'m not sure what\'s the technical name of what I have implemented so far, but all I have is basically the code I\'ve linked above, which is a constraint generation algorithm that uses the rules for applications, abstractions and variables taken from the Hinley-Milner algorithm and then a unification algorithm that gets the principal type. For instance, the expression <code>\\a.a</code> will yield the type <code>a -&gt; a</code>, and the expression <code>\\a.(a a)</code> will throw an occurs check error. On top of this, there is not exactly a <code>let</code> rule but a function that seems to have the same effect that lets you define recursive global functions like this pseudo-code:</p>\n\n<pre><code>GetTypeOfGlobalFunction(term, globalScope, nameOfFunction)\n{\n    // Here \'globalScope\' contains a list of name-value pair where every value is of class \'ClosedType\', \n    // meaning their type will be cloned before unified in the unification algorithm so that they can be used polymorphically \n    tempType = new TypeVariable() // Assign a dummy type to `tempType`, say, type \'x\'.\n    // The next line creates an scope with everything in \'globalScope\' plus the \'nameOfFunction = tempType\' name-value pair\n    tempScope = new Scope(globalScope, nameOfFunction, tempType) \n    type = TypeOfTerm(term, tempScope) // Calculate the type of the term \n    Unify(tempType, type)\n    return type\n    // After returning, the code outside will create a \'ClosedType\' using the returned type and add it to the global scope.\n}\n</code></pre>\n\n<p>The code basically gets the type of the term as usual, but before unifying, it adds the name of the function being defined with a dummy type into the type scope so that it can be used from within itself recursively. </p>\n\n<p><strong>Edit 2:</strong> I just realized that I\'d also need recursive types, which I don\'t have, to define a list like I want.</p>\n', 'Tags': '<lambda-calculus><type-theory><type-inference>', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-02-03T12:07:00.370', 'CommentCount': '4', 'AcceptedAnswerId': '20151', 'CreationDate': '2014-01-29T22:45:04.833', 'Id': '20088'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm wondering if there is a way to extend Hinley-Milner's type system to allow polymorphic types without the need of a let construct, by adding an intersection type (as Dan pointed out) that represents the possible types of a function type.</p>\n\n<p>Say I have this expression:</p>\n\n<p>$\\lambda x.\\lambda y.(x\\ (x\\ y))$</p>\n\n<p>While running the type inference algorithm, I'd normally, after looking at the expression $(x\\ y)$, assign to $x$ some type $Y \\rightarrow A$, where $Y$ is the type of $y$ and $A$ is whatever $x$ returns. Then, since $x$ also takes $(x\\ y)$ which has the type $A$, I replace $Y$ with $A$, such that the type of $x$ becomes $A \\rightarrow A$ and give to the whole thing the type $(A \\rightarrow A) \\rightarrow (A \\rightarrow A)$.</p>\n\n<p>But what if I, instead of replacing $Y$ with $A$ when I see $(x\\ (x\\ y))$, add a new type to $x$, say, $A \\rightarrow B$, such that the final type is $((Y \\rightarrow A) \\wedge (A \\rightarrow B)) \\rightarrow (Y \\rightarrow B)$, which is also a tautology and seems like a better representation of what the function does.</p>\n\n<p>Now say I give to this abstraction the term $\\lambda n.n$ like this:</p>\n\n<p>$(\\lambda x.\\lambda y.(x\\ (x\\ y))\\ \\lambda n.n)$</p>\n\n<p>Since $\\lambda n.n$ has the type $N \\rightarrow N$, I'd need to unify $N \\rightarrow N$ with $((Y \\rightarrow A) \\wedge (A \\rightarrow B))$. So I instantiate two copies of $N \\rightarrow N$, say $N_1 \\rightarrow N_1$ and $N_2 \\rightarrow N_2$, and unify $N_1 \\rightarrow N_1$ with $Y \\rightarrow A$ and $N_2 \\rightarrow N_2$ with $A \\rightarrow B$. Because $A$ would be equal to $N_1$ on one side and equal to $N_2$ on the other side, $N_1$, $Y$, $A$ and $B$ are all equal to $N_2$, so the type $Y \\rightarrow B$ becomes $N_2 \\rightarrow N_2$, which is consistent with the expression you'd get after evaluating the lambda term.</p>\n\n<p>With this type system I should be able to type things like this:</p>\n\n<p>$(\\lambda i.\\lambda x.\\lambda y.((i\\ x)\\ (i\\ y))\\ \\lambda n.n)$</p>\n\n<p>But these examples are simple, and it becomes a pain to type something like:</p>\n\n<p>$(\\lambda x.\\lambda y.(x\\ (x\\ y))\\ \\lambda x.\\lambda y.(x\\ (x\\ y)))$</p>\n\n<p>I'm having trouble trying to figure out what the actual rules of this system would be, like what would you do if you'd have to unify two intersection types (or whether that situation is even possible). </p>\n\n<p>So my question is, am I moving towards a type system that already exists? If yes, which one? If not, is this because my type system wouldn't meet the requirements of a type system (such as being decidable)?</p>\n", 'ViewCount': '33', 'Title': 'Does there exist a type system for a non-let-polymorphic lambda calculus?', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-03-31T16:54:26.607', 'LastEditDate': '2014-03-31T16:54:26.607', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><type-theory><type-inference>', 'CreationDate': '2014-03-30T07:48:34.587', 'Id': '23249'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>I'm looking for a type inference algorithm for a language I'm developing, but I couldn't find one that suits my needs because they usually are either:</p>\n\n<ul>\n<li>\xe0 la Haskell, with polymorphism but no ad-hoc overloading</li>\n<li>\xe0 la C++ (auto) in which you have ad-hoc overloading but functions are monomorphic</li>\n</ul>\n\n<p>In particular my type system is (simplifying) (I'm using Haskellish syntax but this is language agnostic):</p>\n\n<pre><code>data Type = Int | Double | Matrix Type | Function Type Type\n</code></pre>\n\n<p>And I've got an operator * which has got quite some overloads:</p>\n\n<pre><code>Int -&gt; Int -&gt; Int\n(Function Int Int) -&gt; Int -&gt; Int\nInt -&gt; (Function Int Int) -&gt; (Function Int Int)\n(Function Int Int) -&gt; (Function Int Int) -&gt; (Function Int Int)\nInt -&gt; Matrix Int -&gt; Matrix Int\nMatrix Int -&gt; Matrix Int -&gt; Matrix Int\n(Function (Matrix Int) (Matrix Int)) -&gt; Matrix Int -&gt; Matrix Int\n</code></pre>\n\n<p>Etc... </p>\n\n<p>And I want to infer possible types for</p>\n\n<pre><code>(2*(x =&gt; 2*x))*6\n(2*(x =&gt; 2*x))*{{1,2},{3,4}}\n</code></pre>\n\n<p>The first is <code>Int</code>, the second <code>Matrix Int</code>.</p>\n\n<p>Example (that doesn't work):</p>\n\n<pre><code>{-# LANGUAGE OverlappingInstances, MultiParamTypeClasses,\n  FunctionalDependencies, FlexibleContexts,\n  FlexibleInstances, UndecidableInstances #-}\n\nimport qualified Prelude\nimport Prelude hiding ((+), (*))\nimport qualified Prelude\n\nnewtype WInt = WInt { unwrap :: Int }\n\nliftW f a b = WInt $ f (unwrap a) (unwrap b)\n\nclass Times a b c | a b -&gt; c where\n(*) :: a -&gt; b -&gt; c\n\ninstance Times WInt WInt WInt where\n(*) = liftW (Prelude.*)\n\ninstance (Times a b c) =&gt; Times a (r -&gt; b) (r -&gt; c) where\nx * g = \\v -&gt; x * g v\n\ninstance Times (a -&gt; b) a b where\nf * y = f y\n\ntwo = WInt 2\nsix = WInt 6\n\ntest :: WInt\ntest = (two*(\\x -&gt; two*x))*six\n\nmain = undefined\n</code></pre>\n", 'ViewCount': '47', 'Title': 'Type inference + overloading', 'LastEditorUserId': '508', 'LastActivityDate': '2014-04-23T17:59:09.350', 'LastEditDate': '2014-04-23T17:59:09.350', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'OwnerDisplayName': 'miniBill', 'PostTypeId': '1', 'OwnerUserId': '508', 'Tags': '<type-theory><type-inference>', 'CreationDate': '2014-04-19T15:32:41.113', 'Id': '23963'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am trying to extend an existing UTP theory package(Isabelle/UTP) by introducing a new type for use in encoding a custom framework built on UTP. <code>MkName</code> is a type constructor, <code>fset</code> basically restricts <code>VAR</code> to finite sets. The type <code>@{term "UTYPE"}</code> consists of the set of types which, according to the typing relation, have at least one defined value. <code>WF_PREDICATE_OVER</code> calculates all predicates which satisfy the given argument(alphabet). <code>\u03c0 p = snd(WF_ALPHA_PREDICATE)</code> . <code>&lt;_&gt;\u21e9f</code> is <code>Rep</code> function for <code>fset</code>.  <code>\u03b9\u03c0 p = snd(WF_ALPHA_PREDICATE)</code></p>\n\n<pre><code>(*--------- from Isabelle/UTP package -------*)\n\ndefinition fsets :: "\'a set set" where "fsets = Collect finite"\ntypedef \'a fset = "fsets :: \'a set set"  by (auto simp add:fsets_def)\nnotation Rep_fset ("&lt;_&gt;\u21e9f")    \n\nclass DEFINED = fixes Defined   :: "\'a \u21d2 bool" ("D")\ndefinition "UTYPES (x::\'a itself) = {t. \u2203 v :: \'a. v :\u21e9u t \u2227 D v}"\ntypedef \'VALUE UTYPE = "UTYPES TYPE(\'VALUE)"    \n\ndatatype NAME = MkName string nat\n\ntype_synonym \'VALUE VAR = "NAME \xd7 \'VALUE UTYPE \xd7 bool"\ndefinition VAR :: "\'VALUE VAR set" where "VAR = UNIV"\n\ntype_synonym \'VALUE ALPHABET = "(\'VALUE VAR) fset"\ntype_synonym \'VALUE ALPHA_PREDICATE = "(\'VALUE ALPHABET) \xd7 \'VALUE WF_PREDICATE"\n\ntype_synonym \'VALUE BINDING = "(\'VALUE VAR) \u21d2 \'VALUE"\ntypedef \'VALUE WF_BINDING   = "WF_BINDING :: \'VALUE BINDING set"\ntypedef \'VALUE WF_PREDICATE = "UNIV :: \'VALUE WF_BINDING set set"\n\ndefinition WF_ALPHA_PREDICATE :: "\'VALUE ALPHA_PREDICATE set" where\n    "WF_ALPHA_PREDICATE = {(a,p) | a p . p \u2208 WF_PREDICATE_OVER &lt;a&gt;\u21e9f}"\n\ntypedef \'a WF_ALPHA_PREDICATE = "WF_ALPHA_PREDICATE :: \'a ALPHA_PREDICATE set"\n\n\n(*--------- My Code -------*)\ntype_synonym \'VALUE LA_PREDICATE = "(\'VALUE ALPHABET) \xd7 (\'VALUE WF_ALPHA_PREDICATE)"\n\ndefinition WF_LA_PREDICATE :: "\'VALUE LA_PREDICATE set" where\n"WF_LA_PREDICATE = {(a::\'VALUE ALPHABET, p::\'VALUE WF_ALPHA_PREDICATE) | a p . \n       (\u03c0 p) \u2208 WF_PREDICATE_OVER (VAR - &lt;a&gt;\u21e9f) }" \n\ntypedef \'VALUE WF_LA_PREDICATE = "WF_LA_PREDICATE :: \'VALUE LA_PREDICATE set"\n\nlift_definition Exists1 ::\n  "\'VALUE ALPHABET \u21d2 \'VALUE WF_LA_PREDICATE \u21d2 \'VALUE WF_LA_PREDICATE" is\n  "\u03bb a p . ( \u03b1 p, \u2203\u21e9\u03b1 Abs_fset(VAR) -\u21e9f a .  \u03b9\u03c0 p)"\n</code></pre>\n\n<p>The lift definition results in the following error.</p>\n\n<p>Lifting failed for the following types:\nRaw type:  (NAME \xd7 \'a UTYPE \xd7 bool) fset \xd7 \'a WF_ALPHA_PREDICATE\nAbstract type:  \'VALUE WF_LA_PREDICATE</p>\n\n<p>Reason:\n  The <em>quotient type</em> "\'VALUE WF_LA_PREDICATE" and the <em>quotient type pattern</em> "?\'a WF_LA_PREDICATE"  don\'t match.</p>\n\n<p>What would be a valid definition for Exists1???\nWhat is the syntax I\'m writing wrong? </p>\n', 'ViewCount': '25', 'ClosedDate': '2014-04-29T22:32:36.733', 'Title': "Isabelle : quotient type and quotient type pattern don't match", 'LastActivityDate': '2014-04-29T14:15:04.437', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17180', 'Tags': '<formal-languages><type-theory><functional-programming><type-inference><type-checking>', 'CreationDate': '2014-04-29T14:15:04.437', 'Id': '24223'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have seen stated in various places that in order to allow an "increase in polimorphism" functional depency analysis should be performed, and type inference should be used for every declaration group in topological order. It seems like a well-known fact... except that nobody provides any reference or example whatsoever.</p>\n\n<p>In fact I don\'t understand what is really meant by this statement. Does it mean that without doing dependency analysis I wouldn\'t be able to type some programs (i.e. some valid programs would fail type-checking) or only that I would type them with a type that is more specific than what really is?</p>\n\n<p>I\'m particularly interested in consequences in a Haskell-like language/type system. In particular during <em>kind inference</em>, is dependency analysis actually necessary to avoid rejecting valid programs? Can you provide an example that wouldn\'t be well-kinded if typed without performing dependency analysis?</p>\n\n<p>Since kinds are monomorphic I struggle to understand why dependency analysis should matter in this particular case.</p>\n', 'ViewCount': '13', 'Title': 'Is dependency analysis required in order to type a program?', 'LastActivityDate': '2014-05-03T07:29:34.857', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7246', 'Tags': '<functional-programming><typing><type-inference>', 'CreationDate': '2014-05-03T07:29:34.857', 'Id': '24343'}}