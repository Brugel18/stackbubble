{'Body': u'<p>Let $L_1$, $L_2$, $L_3$, $\\dots$ be an in\ufb01nite sequence of context-free languages, each of\nwhich is de\ufb01ned over a common alphabet $\u03a3$. Let $L$ be the in\ufb01nite union of $L_1$, $L_2$, $L_3$, $\\dots $;\ni.e., $L = L_1 \\cup L_2 \\cup L_3 \\cup \\dots $. </p>\n\n<p>Is it always the case that $L$ is a context-free language? </p>\n', 'ViewCount': '676', 'Title': u'Is an in\ufb01nite union of context-free languages always context-free?', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-25T15:12:25.303', 'LastEditDate': '2012-04-25T15:12:25.303', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '208', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2012-03-10T18:10:35.290', 'Id': '206'}{'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a>.</em></p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that the regular languages are closed under a variety of operations (we may limit ourselves to basic operations such as union, intersection, complement, difference, concatenation, Kleene star, and reversal), whereas the context-free languages have different closure properties (these are closed under union, concatenation, Kleene star, and reversal).</p>\n\n<blockquote>\n  <p>Is HAL closed under reversal?</p>\n</blockquote>\n', 'ViewCount': '386', 'Title': 'Proving closure under reversal of languages accepted by min-heap automata', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T04:30:39.730', 'LastEditDate': '2012-04-24T07:15:47.070', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><closure-properties>', 'CreationDate': '2012-03-14T20:17:55.613', 'Id': '390'}{'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a></em>.</p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that the regular languages are closed under a variety of operations (we may limit ourselves to basic operations such as union, intersection, complement, difference, concatenation, Kleene star, and reversal), whereas the context-free languages have different closure properties (these are closed under union, concatenation, Kleene star, and reversal).</p>\n\n<blockquote>\n  <p>Is HAL closed under complementation?</p>\n</blockquote>\n', 'ViewCount': '323', 'Title': 'Proving closure under complementation of languages accepted by min-heap automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-24T07:15:31.283', 'LastEditDate': '2012-04-24T07:15:31.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '415', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><closure-properties>', 'CreationDate': '2012-03-14T21:51:34.593', 'Id': '393'}{'Body': '<p>Let $G$ be a context-free grammar. A string of terminals and nonterminals of $G$ is said to be a <em>sentential form</em> of $G$ if you can obtain it by applying productions of $G$ zero or more times to the start symbol of $S$. Let $\\operatorname{SF}(G)$ be the set of sentential forms of $G$.</p>\n\n<p>Let $\\alpha \\in \\operatorname{SF}(G)$ and let $\\beta$ be a substring of $\\alpha$ - we call $\\beta$ a <em>fragment</em> of $\\operatorname{SF}(G)$. Now let </p>\n\n<p>$\\operatorname{Before}(\\beta) = \\{ \\gamma \\ |\\ \\exists \\delta . \\gamma \\beta \\delta \\in \\operatorname{SF}(G) \\}$ </p>\n\n<p>and </p>\n\n<p>$\\operatorname{After}(\\beta) = \\{ \\delta \\ |\\ \\exists \\gamma . \\gamma \\beta \\delta \\in \\operatorname{SF}(G) \\}$.</p>\n\n<blockquote>\n  <p>Are $\\operatorname{Before}(\\beta)$ and $\\operatorname{After}(\\beta)$ context-free languages? What if $G$ is unambiguous? If $G$ is unambiguous, are $\\operatorname{Before}(\\beta)$ and $\\operatorname{After}(\\beta)$ also describable by an unambiguous context-free language?</p>\n</blockquote>\n\n<p>This is a followup to <a href="http://cs.stackexchange.com/questions/666/is-there-a-string-stack-data-structure-that-supports-these-string-operations">my earlier question</a>, after <a href="http://cs.stackexchange.com/questions/757/does-every-large-enough-string-have-repeats">an earlier attempt</a> to make my question easier to answer failed. A negative answer will make the encompassing question I\'m working on very hard to answer.</p>\n', 'ViewCount': '305', 'Title': 'Are the Before and After sets for context-free grammars always context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:53:00.780', 'LastEditDate': '2014-01-25T16:53:00.780', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '804', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties>', 'CreationDate': '2012-03-26T17:48:12.210', 'Id': '802'}{'ViewCount': '535', 'Title': 'How to prove regular languages are closed under left quotient?', 'LastEditDate': '2012-04-18T05:56:10.247', 'AnswerCount': '1', 'Score': '8', 'OwnerDisplayName': 'corium', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '1', 'Body': '<p>L is a regular language over the alphabet $\\sum = \\{a,b\\}$. The left quotient of L regarding $w \\in \\sum^*$ is the language \n$$w^{-1} L := \\{v: wv \\in L\\}$$</p>\n\n<p>How can I prove that $w^{-1}$ L is regular?</p>\n', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T05:56:10.247', 'CommentCount': '0', 'AcceptedAnswerId': '1327', 'CreationDate': '2012-04-17T20:58:50.560', 'Id': '1326'}{'Body': "<p>I would like your help with the following question:</p>\n\n<blockquote>\n  <p>Let $L$ be a language, and operator $A(L)=\\{\\,ww^Rw \\mid w \\in L\\ \\wedge\\ |w| \\lt 2007\\,\\}$ where $x^R$ is the  reversed string of $x$. Which of the\n  following statements are correct?</p>\n  \n  <ol>\n  <li>If $L$ is regular so $A(L)$ is regular.</li>\n  <li>If $L$ is a CFL which is not regular then $A(L)$ is CFL which is not regular.</li>\n  <li>If $L$ is a CFL which is not regular, then $A(L)$ is a CFL which may or may not be regular.</li>\n  <li>If $L$ is not a CFL then $A(L)$ is not CFL.</li>\n  </ol>\n</blockquote>\n\n<p>What does the fact that $|w|&lt; 2007$ help me with the decision? \nFor (2) I can choose $O^n1^n$ and I get that $0^n1^{2n}0^{2n}1^n$, which is not regular, but for (3),(4) I can't find an examples to refute it. The answer is 3, but I can't understand why, since $A(L)= ww^R \\circ  w$  but $ww^R$ is not regular.</p>\n", 'ViewCount': '180', 'Title': 'Closure against the operator $A(L)=\\{ww^Rw \\mid w \\in L \\wedge |w| \\lt 2007\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-28T09:52:19.380', 'LastEditDate': '2012-04-28T09:52:19.380', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1537', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2012-04-27T18:59:52.513', 'Id': '1536'}{'Body': "<p>I'd really love your help with the following:</p>\n\n<p>For <em>any</em> fixed $L_2$ I need to decide whether there is closure under the following operators:</p>\n\n<ol>\n<li><p>$A_r(L)=\\{x \\mid \\exists  y \\in L_2 : xy \\in L\\}$</p></li>\n<li><p>$A_l(L)=\\{x \\mid \\exists  y \\in L : xy \\in L_2\\}$.</p></li>\n</ol>\n\n<p>The relevant options are:</p>\n\n<ol>\n<li><p>Regular languages are closed under $A_l$ resp. $A_r$, for any language $L_2$ </p></li>\n<li><p>For some languages $L_2$, regular languages are closed under $A_l$ resp. $A_r$, and for some languages $L_2$, regular languages are not closed under $A_l$ resp. $A_r$.</p></li>\n</ol>\n\n<p>I believed that the answer for (1) should be (2), because when I get a word in $w \\in L$ and $w=xy$ I can build an automaton that can guess where $x$ turning to $y$, but then it needs to verify that $y$ belongs to $L_2$ and if it won't be regular, how would it do that?<br>\nThe answer for that is (1).</p>\n\n<p>What should I do in order to analyze those operators correctly and to determine if the regular languages are closed under them or not?</p>\n", 'ViewCount': '517', 'Title': 'Closure against right quotient with a fixed language', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-29T11:50:36.987', 'LastEditDate': '2012-04-29T11:50:36.987', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1554', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-04-28T10:33:42.823', 'Id': '1547'}{'Body': '<p>Do there exist undecidable languages such that their union/intersection/concatenated language is decidable? What is the physical interpretation of such example because in general, undecidable languages are not closed under these operations?</p>\n\n<p>What can we say about the kleene closure? Do we have examples for it too?  I.e. can the closure of an undecidable language be decidable?</p>\n\n<p>Also, can we generalize such undecidable classes?</p>\n', 'ViewCount': '834', 'LastEditorDisplayName': 'user1291', 'Title': "operations that aren't closed for undecidable languages", 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T08:52:26.420', 'LastEditDate': '2012-05-09T08:52:26.420', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'OwnerDisplayName': 'user1284', 'PostTypeId': '1', 'Tags': '<formal-languages><undecidability><closure-properties>', 'CreationDate': '2012-04-28T11:50:33.113', 'Id': '1549'}{'ViewCount': '258', 'Title': 'The operator $A(L)= \\{w \\mid ww \\in L\\}$', 'LastEditDate': '2012-05-04T21:50:54.007', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'FavoriteCount': '1', 'Body': "<p>Consider the operator $A(L)= \\{w \\mid ww \\in L\\}$. Apparently, the class of context free languages is not closed against $A$. Still, after a lot of thinking, I can't find any CFL for which $A(L)$ wouldn't be CFL. </p>\n\n<p>Does anyone have an idea for such a language?</p>\n", 'Tags': '<formal-languages><context-free><closure-properties>', 'LastEditorUserId': '89', 'LastActivityDate': '2012-05-05T12:31:21.947', 'CommentCount': '2', 'AcceptedAnswerId': '1657', 'CreationDate': '2012-05-03T11:55:44.033', 'Id': '1652'}{'Body': "<p>Define $\\mathrm{Prefix}  (L) = \\{x\\mid \\exists y .xy \\in L \\}$. I'd love your help with proving that $\\mathsf{RE}$ languages are closed under $\\mathrm{Prefix}$.</p>\n\n<p>I know that recursively enumerable languages are formal languages for which there exists a Turing machine  that will halt and accept when presented with any string in the language as input, but may either halt and reject or loop forever when presented with a string not in the language.</p>\n\n<p>Any help for how should I approach to this kind of a proof?</p>\n", 'ViewCount': '755', 'Title': 'Proving that recursively enumerable languages are closed against taking prefixes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T09:56:00.747', 'LastEditDate': '2012-05-10T15:21:06.183', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '1732', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><turing-machines><closure-properties>', 'CreationDate': '2012-05-08T15:36:31.447', 'Id': '1731'}{'Body': '<p>I\'m am stuck solving the next exercise:</p>\n\n<p>Argue that if $L$ is context-free and $R$ is regular, then $L / R = \\{ w \\mid \\exists x \\in R \\;\\text{s.t}\\; wx \\in L\\} $ (i.e. the <a href="https://en.wikipedia.org/wiki/Right_quotient" rel="nofollow">right quotient</a>) is context-free.</p>\n\n<p>I know that there should exist a PDA that accepts $L$ and a DFA that accepts $R$. I\'m now trying to combine these automata to a PDA that accepts the right quotient. If I can build that I proved that $L/R$ is context-free. But I\'m stuck building this PDA.</p>\n\n<p>This is how far I\'ve made it:   </p>\n\n<blockquote>\n  <p>In the combined PDA the states are a cartesian product of the states of the seperate automata. And the edges are the edges of the DFA but only the ones for which in the future a final state of the original PDA of L can be reached. But don\'t know how to write it down formally.</p>\n</blockquote>\n', 'ViewCount': '637', 'Title': 'If $L$ is context-free and $R$ is regular, then $L / R$ is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-17T23:12:15.793', 'LastEditDate': '2012-05-17T19:38:52.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1526', 'Tags': '<formal-languages><context-free><finite-automata><closure-properties><pushdown-automata>', 'CreationDate': '2012-05-17T16:19:42.050', 'FavoriteCount': '1', 'Id': '1886'}{'Body': u"<p>For the purpose of proving that they are not regular, what closure properties can I use to transform the languages</p>\n\n<ol>\n<li>$L_a = \\{ a^*cw \\mid  w \\in \\{a,b \\}^* \\land  |w|_a = |w|_b \\}$ and</li>\n<li>$L_b = \\{ab^{i_1}ab^{i_2}\\ldots ab^{i_n} \\mid  i_j\u2208\\mathbb N \\land \\exists j\u2208[1,n]  \\ i_j \\not= j \\}$</li>\n</ol>\n\n<p>to  $L := \\{ a^nb^n \\mid n\\in \\mathbb N \\}$, respectively?</p>\n\n<p>I tried: </p>\n\n<ol>\n<li><p>$L_a = \\{ a^*cw \\mid w \\in \\{a,b \\}^* \\land  |w|_a = |w|_b \\}$ </p>\n\n<p>$L_a' = \\{ \\{a,d\\}^*cw \\mid w \\in \\{a,b,d \\}^* \\land  |w|_a + |w|_d = |w|_b \\}$ (union?)</p>\n\n<p>$L_a'' = \\{ d^*cw \\mid w \\in \\{a,b \\}^* \\land |w|_a = |w|_b \\}$\n(concatenation?)</p>\n\n<p>$L_a''' = \\{ w \\mid w \\in \\{a,b \\}^* \\land |w|_a = |w|_b \\}$\n(homomorphism?)</p></li>\n<li><p>$L_b = \\{ab^{i_1}ab^{i_2}\\ldots ab^{i_n} \\mid i_j\u2208\\mathbb N \\land\\exists j\u2208[1,n] \\ i_j \\not= j \\}$</p>\n\n<p>$L_b' = \\{ab^{i_1}ab^{i_2}\\ldots ab^{i_n} \\mid i_j\u2208\\mathbb N \\land\\forall j\u2208[1,n] \\ i_j = j \\}$  (complement?)</p>\n\n<p>$L_b'' = \\{ac^{i_1}ac^{i_2}\\ldots ac^{i_n} \\mid i_j\u2208\\mathbb N \\land\\forall j\u2208[1,n] \\ i_j = j \\}$ (homomorphism?)</p></li>\n</ol>\n", 'ViewCount': '256', 'Title': 'Use closure properties to transform languages to $L := \\{ a^nb^n : n\\in \\mathbb N \\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-28T22:52:22.653', 'LastEditDate': '2012-05-24T00:03:27.303', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '1952', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2012-05-20T14:26:20.813', 'Id': '1949'}{'ViewCount': '985', 'Title': 'Prove that regular languages are closed under the cycle operator', 'LastEditDate': '2012-05-22T07:23:51.960', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '2', 'Body': u"<p>I've got in a few days an exam and have problems to solve this task.</p>\n\n<p>Let $L$ be a regular language over the alphabet $\\Sigma$. We have the operation \n$\\operatorname{cycle}(L) = \\{ xy \\mid x,y\\in \\Sigma^* \\text{ and } yx\\in L\\}$\nAnd now we should show that $\\operatorname{cycle}(L)$ is also regular.</p>\n\n<p>The reference is that we could construct out of a DFA $D=(Q,\\Sigma,\\delta, q_0, F)$ with $L(D) = L$ a $\\epsilon$-NFA $N$ with $L(N) = \\operatorname{cycle}(L)$ and  $2 \xb7 |Q|^2 + 1$ states. </p>\n", 'Tags': '<formal-languages><regular-languages><finite-automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:35:34.333', 'CommentCount': '2', 'AcceptedAnswerId': '1989', 'CreationDate': '2012-05-22T05:28:58.017', 'Id': '1986'}{'Body': '<p>The complexity class $\\newcommand{\\sharpp}{\\mathsf{\\#P}}\\sharpp$ is defined as </p>\n\n<p>$\\qquad \\displaystyle \\sharpp = \\{f \\mid \\exists \\text{ polynomial-time NTM } M\\ \\forall x.\\, f(x) = \\#\\operatorname{accept}_{M}(x)\\}$. </p>\n\n<p>It is known that $\\sharpp$ is closed under addition, multiplication and binomial coefficient. I was wondering if it is closed under power. For example, we are given a $\\sharpp$ function $f$ and another $\\sharpp$ function $g$. Is it true that $f^{g}$ or $g^{f}$ are $\\sharpp$ functions as well?  </p>\n\n<p>This is edit after the question has been answered.</p>\n\n<p>Is ($f$ modulo $g$) a $\\sharpp$ function? How about when we are given a $\\newcommand{\\FP}{\\mathsf{FP}}\\FP$ function $h$. Then is ($f$ modulo $h$) a $\\sharpp$ function? </p>\n', 'ViewCount': '139', 'Title': 'Is #P closed under exponentiation? modulo?', 'LastEditorUserId': '1093', 'LastActivityDate': '2012-08-12T23:36:10.113', 'LastEditDate': '2012-08-12T23:36:10.113', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3137', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1093', 'Tags': '<complexity-theory><turing-machines><closure-properties>', 'CreationDate': '2012-08-12T12:30:28.490', 'Id': '3134'}{'Body': "<p>I want to prove that the complement of $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties.</p>\n\n<p>I understand pumping lemma can be used to prove that $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not a regular language. I also understand regular languages are closed under complement operation. However, does that also imply that a non-regular language's complement is also non-regular?</p>\n", 'ViewCount': '779', 'Title': 'Prove that the complement of  $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-12T19:48:30.280', 'LastEditDate': '2012-09-28T11:33:15.257', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2978', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-09-26T20:53:42.597', 'FavoriteCount': '1', 'Id': '4752'}{'ViewCount': '702', 'Title': 'Closure of Deterministic context-free languages under prefix', 'LastEditDate': '2012-10-07T17:36:51.877', 'AnswerCount': '3', 'Score': '2', 'OwnerDisplayName': 'Sam Jones', 'PostTypeId': '1', 'OwnerUserId': '769', 'Body': "<p>For a formal language $L \\subseteq \\Sigma^{*}$ I define the set Pref(L) to be:</p>\n\n<p>$\\text{pref}(L) = \\{\\alpha \\in \\Sigma^{*} : \\exists \\beta \\in \\Sigma^{*} \\text{ such that } \\alpha \\beta \\in L\\}$</p>\n\n<p>ie. the set of all (not necessarily proper) prefixes of words in $L$. I know that if $L$ is context-free then pref(L) is context-free but if $L$ is deterministic context-free then is pref(L) deterministic context-free?</p>\n\n<p>I am sure this is known but I cannot find the answer anywhere and it's not in Hopcroft and Ullman.</p>\n", 'Tags': '<formal-languages><context-free><closure-properties>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-18T13:23:08.777', 'CommentCount': '6', 'AcceptedAnswerId': '4925', 'CreationDate': '2012-01-15T21:51:40.653', 'Id': '4924'}{'Body': u'<p>Suppose I have a formula, and a lying witness is attempting to make it evaluate to False.</p>\n\n<blockquote>\n  <p>Given a <a href="http://en.wikipedia.org/wiki/Truth_table" rel="nofollow">truth table</a> $c(F_1,\u2026, F_n)$, how could you force a lying\n   witness to contradict herself?</p>\n</blockquote>\n\n<p>A contradiction is simply when the witness\'s statements are logically impossible; i.e. that $x_1,x_2$ are each True, but $x_1 \\space AND\\space x_2$ is False.</p>\n\n<ul>\n<li>How can I characterize the set of all formula for which I force the witness to contradict herself?</li>\n<li>What complexity class does this problem fall in?</li>\n</ul>\n', 'ViewCount': '252', 'Title': 'Given a truth table, force a contradiction', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-12-26T07:32:37.003', 'LastEditDate': '2012-11-26T07:05:41.493', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4222', 'Tags': '<complexity-theory><computability><np-complete><closure-properties><decision-problem>', 'CreationDate': '2012-10-16T23:32:35.117', 'FavoriteCount': '1', 'Id': '6116'}{'ViewCount': '209', 'Title': 'If $L$ is a regular language, how to prove $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$ is also regular?', 'LastEditDate': '2013-04-07T12:25:29.787', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3146', 'FavoriteCount': '2', 'Body': "<blockquote>\n  <p>If $L$ is a regular language, prove that the language\n  $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$\n  is also regular.</p>\n</blockquote>\n\n<p>My idea: $L$ can be represented as a DFA and then you could add 2 consecutive transitions from every final state for the letters of $v$, creating a new NFA diagram. Is that correct? I'm not sure how to make this a formal proof.</p>\n", 'Tags': '<regular-languages><automata><finite-automata><closure-properties><check-my-answer>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:25:29.787', 'CommentCount': '3', 'AcceptedAnswerId': '6281', 'CreationDate': '2012-10-24T05:09:01.860', 'Id': '6279'}{'Body': '<p>So I\'ve been scratching my head over this problem for a couple of days now.  Given some language $A$ and $B$ that is regular, show that the language $L$ which consists of all strings in $A$ whose length is equal to some string in $B$ is a regular language.</p>\n\n<p>In equation form:</p>\n\n<p>$$L = \\{x \\in A \\mid \\exists y \\in B \\text{ s.t. } |x| = |y| \\}$$</p>\n\n<p>My initial thought was to try and come up with some DFA for both languages $A$ and $B$ and map the two states to each other and hopefully get a 1:1 ratio that way I can generate a new DFA which proves that $L$ is regular.  But then I realized that $A$ and $B$ don\'t have to be over the same set of symbols.  </p>\n\n<p>I think the correct way to solve this is to use the closure properties of regular language, but I\'m not sure of how to begin/use the properties for "lengths" of strings instead of strings themselves.  </p>\n\n<p>Could someone point me in the right direction?</p>\n', 'ViewCount': '255', 'Title': 'Proving the language which consists of all strings in some language is the same length as some string in another language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-08T04:07:41.613', 'LastEditDate': '2012-11-05T08:20:14.120', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4463', 'Tags': '<formal-languages><regular-languages><finite-automata><proof-techniques><closure-properties>', 'CreationDate': '2012-11-05T05:52:51.367', 'Id': '6484'}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/4752/prove-that-the-complement-of-0n1n-mid-n-geq-0-is-not-regular-using">Prove that the complement of  $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties</a>  </p>\n</blockquote>\n\n\n\n<p>Is $L=\\{ a^nb^m \\mid n,m \\ge 0, n\\ne m\\}$ a regular language?  </p>\n\n<p>I think it is but can\'t prove it.</p>\n', 'ViewCount': '324', 'ClosedDate': '2012-11-19T22:15:48.150', 'Title': 'Is $\\{a^nb^m \\mid n,m\\ge 0, n\\ne m\\}$ regular or not?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-14T21:30:01.330', 'LastEditDate': '2012-11-14T14:32:35.997', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4586', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-11-14T06:00:37.603', 'Id': '6656'}{'Body': '<p>So I would like to show that the class of Recursively Enumerable languages are closed under the shrink operation. In other words, $\\text{shrink}_a(L) = \\{\\text{shrink}_a(w)\\mid w\\in L\\}$ and where $\\text{shrink}_a(w)$ is the string formed from $w$ by replacing every maximal substring of two or more $a$\'s by a single a. For example, $\\text{shrink}_a(baaab) = bab$.</p>\n\n<p>So I was browsing around for other examples to study, and I came across the following proof for the <strong>prefix</strong> operation: <a href="http://cs.stackexchange.com/questions/1731/proving-that-recursively-enumerable-languages-are-closed-against-taking-prefixes">Proving that recursively enumerable languages are closed against taking prefixes</a> (the proof given by the user Wu Yin). I thought that this was a very cool way of proving something like this, instead of just directly building an alternate TM. I\'m curious to know, can anyone come up with a proof that is of a similar style and flavor to the one pointed above? I would be very curious to see a similar bijective proof regarding countable/uncountable sets!!</p>\n\n<p>This has reminded me that there can be many ways to prove something, so I wanted to see what kind of flavor other people\'s proofs might have to this sample problem. I find that too often, students (and myself included) get caught up in a single procedure for finding solutions to a particular type of problem and neglect to see other ways of showing the same result.</p>\n', 'ViewCount': '195', 'Title': 'Seeking Alternate Proof Regarding Closure Of Recursively Enumerable Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-28T17:38:40.397', 'LastEditDate': '2012-11-26T11:46:51.627', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '6920', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<formal-languages><computability><proof-techniques><closure-properties>', 'CreationDate': '2012-11-26T06:27:42.250', 'Id': '6907'}{'Body': "<p>In class this week we've been learning about the CFLs and their closure properties. I've seen proofs for union, intersection and compliment but for reversal my lecturer just said its closed. I wanted to see the proof so I've been searching for the past few days but all I've found is most people just say that to reverse the productions is enough to prove it. Those that do go a little more formal just state there is an easy inductive proof you can give. Can anyone provide me with some more information/hints about the inductive proof? Try as I might I can't come up with it.</p>\n", 'ViewCount': '697', 'Title': 'Context-free Languages closed under Reversal', 'LastActivityDate': '2012-11-28T15:05:43.030', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6994', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4786', 'Tags': '<context-free><closure-properties>', 'CreationDate': '2012-11-28T12:31:08.280', 'Id': '6992'}{'Body': '<p>I am looking for a proof for the following problem:</p>\n\n<blockquote>\n  <p>For languages $L$ and $R$, if $L$ is <a href="http://en.wikipedia.org/wiki/Deterministic_context-free_language" rel="nofollow">deterministic context-free</a>\n  and $R$ is regular, then $LR$ is a deterministic context-free\n  language.</p>\n</blockquote>\n\n<p>Note: $RL$ may not satisfy this condition, e.g. if $L=\\{wcw^R\\mid w\\in (a|b)^*\\}$, and $R=\\{a\\}^*$.</p>\n', 'ViewCount': '316', 'Title': 'Deterministic context-free languages are closed under regular right-product', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-30T20:19:21.433', 'LastEditDate': '2012-11-30T20:19:21.433', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4486', 'Tags': '<formal-languages><context-free><closure-properties><pushdown-automata>', 'CreationDate': '2012-11-30T10:53:41.263', 'Id': '7041'}{'Body': '<blockquote>\n  <p>Let $P$ be a regular language and $Q$ be a context-free language such\n  that $Q \\subseteq P$(For example, let $P =  a^*b^*$ and $Q = \\{ a^nb^n | n \\ge 0\\}$). Then which of the following is always regular?</p>\n  \n  <ol>\n  <li>$P \\cap Q$</li>\n  <li>$P - Q$</li>\n  <li>$\\Sigma^* - Q$</li>\n  <li>$\\Sigma^* - P$</li>\n  </ol>\n</blockquote>\n\n<p><strong>Option 1</strong> <br>\n$P \\cap Q = Q$ as $P \\subseteq Q$. Thus $P \\cap Q$ is context-free.</p>\n\n<p><strong>Option 2</strong> <br>\nI was not able to generally reason here. I used the example mentioned in the question.<br>\nLet  $P =  a^*b^* $ and $Q = \\{ a^nb^n | n \\ge 0\\}$. <br>\n$P - Q = \\{a^nb^m | n \\neq m\\}$ which is not regular but only context-free.</p>\n\n<p><strong>Option - 3</strong><br>\nLet $\\Sigma = \\{ a, b\\}$ and $Q = \\{ a^nb^n | n \\ge 0\\}$. <br>\nAgain $\\Sigma^* - Q =  \\{a^nb^m | n \\neq m\\} $ which is not regular but only  context-free.</p>\n\n<p>Thus, the 4th option must be right, $\\Sigma^* - P$ is regular. I am however unable to understand this result intuitively. Could somebody explain?</p>\n', 'ViewCount': '104', 'Title': 'Closure properties of languages', 'LastEditorUserId': '2980', 'LastActivityDate': '2012-12-27T06:01:51.860', 'LastEditDate': '2012-12-27T06:01:51.860', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7119', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2012-12-03T09:28:15.073', 'Id': '7118'}{'Body': "<p>I need to know what class of CFL is closed under i.e. what set is complement of CFL.\nI know CFL is not closed under complement, and I know that P is closed under complement. Since CFL $\\subsetneq$ P I can say that complement of CFL is included in P(right?). There is still a question whether complement of CFL is proper subset of P or the whole P. I would appreciate any ideas on how to show that complement of CFL is the whole P(if that's the case of course). </p>\n", 'ViewCount': '1022', 'Title': 'What is complement of Context-free languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-05T02:26:08.850', 'LastEditDate': '2012-12-04T16:52:22.483', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7146', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4859', 'Tags': '<complexity-theory><formal-languages><context-free><closure-properties><sets>', 'CreationDate': '2012-12-04T01:48:38.370', 'Id': '7144'}{'Body': '<p>Given languages $L_1,L_2$, defines $X(L_1,L_2)$ by</p>\n\n<p>$\\qquad X(L_1,L_2) = \\{w \\mid w \\not\\in L_1 \\cup L_2 \\}$</p>\n\n<p>If $L_1$ and $L_2$ are regular, how can we show that $X(L_1,L2)$ is also regular?</p>\n', 'ViewCount': '140', 'LastEditorDisplayName': 'user3115', 'Title': 'Show that the language of strings not in the union of two regular languages is regular', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T19:17:11.917', 'LastEditDate': '2012-12-12T19:17:11.917', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-12-06T01:56:03.217', 'Id': '7202'}{'Body': '<p>It is well known that regular languages are characterized by the Myhill-Nerode equivalence. For language $L$ over $\\Sigma^*$ define the equivalence $x\\sim_L y$ over $\\Sigma^*$ iff for all $z\\in\\Sigma^*$ we have $xz\\in L \\iff yz\\in L$. Then $L$ is regular iff $\\sim_L$ is of finite index, i.e., has a finite number of equivalence classes.</p>\n\n<p>I know that the relation can be used to show that some languages are <em>not</em> regular, by indicating infinitely many strings that are not equivalent. </p>\n\n<p>My question: can we easily use Myhill-Nerode to show closure properties of regular languages? Or should we use the "syntactic congruence" of languages? </p>\n\n<p>As an example for prefix it is easy, as $x\\sim_L y$ implies $x\\sim_{\\mbox{pref}(L)} y$.  But how do we handle suffix, concatenation, star, mirror?</p>\n', 'ViewCount': '161', 'Title': 'Myhill-Nerode and closure properties', 'LastActivityDate': '2012-12-16T20:08:40.920', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<regular-languages><closure-properties>', 'CreationDate': '2012-12-16T17:09:42.133', 'Id': '7441'}{'Body': '<p>The <em>cyclic shift</em>  (also called <em>rotation</em> or <em>conjugation</em>) of a language $L$ is defined as $\\{ yx \\mid xy \\in L \\}$. According to <a href="http://en.wikipedia.org/wiki/Context-free_language">wikipedia</a> (and <a href="http://en.wikipedia.org/wiki/Cyclic_shift">here</a>) the context-free languages are closed under this operation, with references to papers from Oshiba and from Maslov. Is there an easy proof of this fact? </p>\n\n<p>For regular languages the closure is discussed in this form as "<a href="http://cs.stackexchange.com/questions/1986/prove-that-regular-languages-are-closed-under-the-cycle-operator">Prove that regular languages are closed under the cycle operator</a>".</p>\n', 'ViewCount': '628', 'Title': 'Easy proof for context-free languages being closed under cyclic shift', 'LastEditorUserId': '472', 'LastActivityDate': '2013-01-22T09:07:11.380', 'LastEditDate': '2013-01-16T02:25:42.500', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7857', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2013-01-08T12:59:17.587', 'Id': '7831'}{'ViewCount': '47', 'Title': '"Definition of NP via relations and quantifiers; not via NTMs"', 'LastEditDate': '2013-02-15T02:34:43.813', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6569', 'FavoriteCount': '1', 'Body': "<p>I have the following question on an assignment, and despite asking my prof, I can't get a grasp on it..</p>\n\n<blockquote>\n  <p>Let $L_1, L_2$ be languages in ${\\sf NP}$. Using the definition of ${\\sf NP}$ via relations and quantifiers (not the non-deterministic Turing machines) prove that the following language is in ${\\sf NP}$:  $L=\\{ x | x \\in L_1 \\text{ or } xx  \\in L_2 \\}$, where $xx$ is two concatenated copies of $x$.</p>\n</blockquote>\n\n<p>Her notes say the following on this:</p>\n\n<blockquote>\n  <p>Let $L\\subseteq\\Sigma^{*}$. We say $L\\in{\\sf NP}$ if there is a two-place predicate $R\\subseteq\\Sigma^{*}\\times\\Sigma^{*}$ such that $R$ is computable in polynomial time, and such that for some $c,d\\in\\mathbb{N}$ we have $\\forall x\\in\\Sigma^{*},x\\in L\\iff\\exists y\\in\\Sigma^{*},|y|\\leq c|x|^d$ and $R(x,y)$.</p>\n</blockquote>\n\n<p>I would imagine that this is a well known definition (though possibly worded differently)... but I don't know where else I can get details on it. My textbook has a somewhat similar definition, but it doesn't talk about this $c,d\\in\\mathbb{N}$ stuff..</p>\n\n<blockquote>\n  <p>A <strong><em>verifier</em></strong> for a language $A$ is an algorithm $V$, where\n  $$A=\\{w\\mid V\\text{ accepts }\\langle w,c\\rangle\\text{ for some string c}\\}.$$\n  We measure the time of a verifier only in terms of the length of $w$, so a <strong><em>polynomial time verifier</em></strong> runs in polynomial time in the length of $w$. A language $A$ is <strong><em>polynomially verifiable</em></strong> if it has a polynomial time verifier.</p>\n</blockquote>\n\n<p>The $y$ in the first definition is supposed to be analogous to $c$ in the second; it is a <strong>certificate</strong> or <strong>witness</strong> used by the verifier. But that's all I can understand between the two.</p>\n\n<p>Now... what I <strong><em>think</em></strong> I know about this question is that $R(x,y)$ is supposed to be a verifier for $L$, while $R_1(x,y_1)$ is a verifier for $L_1$ and $R_2(x,y_2)$ is a verifier for $L_2$. She said something about $y=\\langle y_1, y_2\\rangle$ being an encoding of the two certificates for the verifiers $R_1$ and $R_2$. But from there I'm lost. I have no idea how to answer this question even after asking for help two or three times.</p>\n\n<p>Anybody here able to help? Thanks in advance.</p>\n", 'Tags': '<complexity-theory><closure-properties>', 'LastEditorUserId': '6569', 'LastActivityDate': '2013-02-15T02:53:43.503', 'CommentCount': '0', 'AcceptedAnswerId': '9797', 'CreationDate': '2013-02-14T23:48:53.697', 'Id': '9790'}{'ViewCount': '305', 'Title': 'Is $A$ regular if $A^{2}$ is regular?', 'LastEditDate': '2013-02-17T09:57:18.313', 'AnswerCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4752', 'FavoriteCount': '3', 'Body': '<p>If $A^2$ is regular, does it follow that $A$ is regular?</p>\n\n<p>My attempt on a proof:</p>\n\n<blockquote>\n  <p>Yes, for contradiction assume that $A$ is not regular.  Then $A^2 = A \\cdot A$. </p>\n  \n  <p>Since concatenation of two non-regular language is not regular $A^2$ cannot be regular.  This contradicts our assumption.  So $A$ is regular.  So if $A^2$ is regular then $A$ is regular.</p>\n</blockquote>\n\n<p>Is the proof correct?</p>\n\n<p>Can we generalize this to $A^3$, $A^4$, etc...?  And also if $A^*$ is regular then $A$ need not be regular?</p>\n\n<p>Example: $A=\\lbrace 1^{2^i} \\mid i \\geq 0\\rbrace$ is not regular but $A^*$ is regular.</p>\n', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-17T19:46:06.063', 'CommentCount': '4', 'AcceptedAnswerId': '9832', 'CreationDate': '2013-02-16T07:41:52.540', 'Id': '9829'}{'Body': '<p>My question: do the non-regular languages have closure properties? For example, if the reverse of L is non-regular, then L is non-regular ? thank you :-) </p>\n', 'ViewCount': '1305', 'Title': 'Are the non-regular languages closed under reverse, union, concatenation, etc?', 'LastEditorUserId': '4287', 'LastActivityDate': '2013-03-03T01:36:10.540', 'LastEditDate': '2013-03-03T01:36:10.540', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7107', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-03-02T12:03:38.260', 'FavoriteCount': '1', 'Id': '10205'}{'Body': "<p>Given a regular language $L$, can we say anything about its complement $\\overline L$? One thing that is trivial to say is that the DFA's for both languages are equal in size as complementing the language is simply a matter of changing all accepting states into rejecting states and vice-versa. Are there any other things to conclude? Is there anything one can say about the number of states of a (minimal) NFA?</p>\n", 'ViewCount': '272', 'Title': 'Can we say anything about the complement of a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-12T10:28:18.477', 'LastEditDate': '2013-03-12T10:28:18.477', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'FUZxxl', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<regular-languages><finite-automata><closure-properties>', 'CreationDate': '2013-03-11T14:18:52.303', 'Id': '10458'}{'Body': '<p>Let \n$A= \\{L \\mid L \\;\\text{is one-counter and \\(\\bar{L}\\) is also one-counter} \\}$</p>\n\n<p>Clearly, $\\text{Deterministic one-counter} \\subseteq A$</p>\n\n<p>Is it the case that $ A = \\text{Deterministic one-counter}$?</p>\n\n<p>I know that for context-free languages the analogue is not the case. For example,\nlet $P =\\{ ww^r\\}$.\nThen both $P$ and $\\bar{P}$ are context-free but $P$ is not deterministic.\nHence $A$ defines a (strict) subset of the context-free languages.</p>\n\n<p>The question is: can we construct a similar one-counter example for which the same holds?</p>\n', 'ViewCount': '143', 'Title': 'Is there a strictly non-deterministic one-counter language whose complement is one-counter?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-18T15:27:47.923', 'LastEditDate': '2013-03-20T10:50:55.130', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4980', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-03-19T15:44:35.443', 'Id': '10621'}{'Body': '<p>A class of languages $\\mathcal{C}$ is <em>closed under countable union</em> (<em>cucu</em>) if for all series of languages in $\\mathcal{C}$ ($(L_i)_{i\\in\\mathbb{N}} \\in \\mathcal{C}^\\mathbb{N}$) the language $\\bigcup_{i\\in\\mathbb{N}}L_i = \\{x\\mid \\exists i\\in\\mathbb{N}: x \\in L_i\\}$ is an element of $\\mathcal{C}$.</p>\n\n<p>As we know most (if not all but $\\mathsf{ALL} = \\wp(\\Sigma^*)$) interesting complexity classes are not closed under countable union as every Language $L$ is the countable union of some singleton Laguages $\\{w_i\\}$.</p>\n\n<p>However there are some classes of <strong>decidable</strong> languages which are cucu like:</p>\n\n<ul>\n<li>$\\{\\{w\\in\\Sigma^*\\mid |w| \\leq i\\}\\mid i\\in\\mathbb{N}\\}$</li>\n<li>$\\{n\\text{-}\\mathrm{SAT}\\mid n\\in\\mathbb{N}\\}$</li>\n<li>every $\\mathcal{C}$ s.t. every $L \\in \\mathcal{C}$ is cofinite</li>\n</ul>\n\n<hr/>\n\n<p>My questions:</p>\n\n<ol>\n<li>Let $\\mathcal{C},\\mathcal{C\'} \\subset \\mathsf{REC}$ be two classes of decidable languages s.t. both are cucu. Is $\\mathcal{C} \\cup \\mathcal{C\'}$ cucu?</li>\n<li>Is there some "real" complexity class (i.e. defined by some machine model, grammar type, $\\lambda$-calculus restriction etc.) that is cucu? (You may restrict it artificially (e.g. NFA, where each final state has a path to another final state), if it fits otherwise.)</li>\n<li><strong>Edit</strong> (after Yuval Filmus\' answer): Given $\\mathcal{C},\\mathcal{C\'}$, as in (1), does the closure of  $\\mathcal{C} \\cup \\mathcal{C\'}$ under countable union only contain decidable languages?</li>\n</ol>\n\n<p>(1) is the main question, (2+3) only addenda.</p>\n', 'ViewCount': '127', 'Title': 'Does closure against countable union survive union of classes?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T20:53:05.277', 'LastEditDate': '2013-03-20T20:53:05.277', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10649', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6716', 'Tags': '<formal-languages><closure-properties>', 'CreationDate': '2013-03-20T14:20:03.700', 'Id': '10648'}{'Body': '<p>Why is $A(L) = \\{x \\in L \\mid x = x^R \\}$ context-free if $L$ is a regular language? </p>\n\n<p>Trying to understand the approach to determining whether a regular language is context-free.</p>\n', 'ViewCount': '128', 'Title': 'Why is the subset of palindromes of a regular language context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-21T10:30:15.167', 'LastEditDate': '2013-03-21T10:28:57.977', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10677', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2013-03-21T02:15:36.403', 'Id': '10675'}{'Body': "<p>This question is on the GRE Computer Science test booklet (not homework). I tried applying closure properties of regular languages but no success.</p>\n\n<p>Suppose $L$ is a regular language over $\\Sigma = \\{0, 1\\}$. Show that the language </p>\n\n<p>$\\qquad L' = \\{w \\in L \\mid |w| \\in 2\\mathbb{N}\\}$ </p>\n\n<p>is also regular.</p>\n\n<p>What I find surprising is that the booklet mentions that the language $\\{w \\in L \\mid |w| = 2^k, k \\in \\mathbb{N}\\}$ is not necessarily a regular language. </p>\n", 'ViewCount': '460', 'Title': 'Proof that regular languages are closed against taking the even-length subset', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-01T23:26:38.987', 'LastEditDate': '2013-04-02T08:16:56.630', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '5', 'OwnerDisplayName': 'Dmitrii I.', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-03-30T22:49:33.747', 'Id': '10927'}{'Body': "<p>This was given as a homework problem but I have already submitted the assignment.  I'd like to resolve it at this point for my own satisfaction.</p>\n\n<p>Given that $L_1$ is a linear language and $L_2$ is a regular language, show that $L=L_1L_2$ is a linear language.</p>\n\n<p>Recall that a linear grammar $G=(\\Sigma, V, P, \\sigma)$ has productions $A\\to yBz$ for some $y,z \\in \\Sigma^*$ and $A,B \\in V$.</p>\n\n<p>I use the theorem that every regular language can be represented by a right linear grammar.</p>\n\n<p>Then I use the theorem that every right linear grammar is the reverse of a left linear grammar (being a little careful about what I mean by reverse)... $L(rev(G))=rev(L(G))$...</p>\n\n<p>Next each left linear grammar is the reverse of a regular language, but the reverse of a regular language is regular, so left linear grammars also represent regular languages.</p>\n\n<p>So our productions in $L_2$ are of the form $x \\to Ca \\mid a$ for some $C \\in V_{L_2}$ and $a \\in \\Sigma_{L_2}$.</p>\n\n<p>Now on to the show...</p>\n\n<p>What we are looking for is $L = L_1.L_2$, $L$ is linear (to show).</p>\n\n<p>So this has the form $S \\to yBzCa \\mid yBzaa$</p>\n\n<p>So far so good, the second production is linear and within our expectations for set inclusion.</p>\n\n<p>I'm having a devil of a time reducing $yBzCa$ however ...</p>\n\n<p>If I introduce $V\\to BzC$ that linearizes $S$ but $V$ is not linear ... </p>\n\n<p>If I give $T\\to z$ to get $V\\to BTC$ I'm not much better off </p>\n\n<p>If I use $V_1\\to Bz$ (ok linear!) but then $V\\to V_1C$ (not linear)</p>\n\n<p>What is the piece of the puzzle I'm missing?</p>\n\n<p>I have a suspicion that my woes are because I failed to have a production that is $B\\implies^*a$ for some terminal $a \\in \\Sigma_{L_1}$ but I haven't observed that in the definitions thus far... and further unless B only goes to a terminal I'm in the same mess (if $B\\to t$ where $t \\in \\Sigma_{L_2} \\bigcup {\\epsilon} $ then I think I'm finished but how do I justify it?</p>\n", 'ViewCount': '99', 'Title': 'How can I show a linear languages are closed against concatenating with regular ones?', 'LastEditorUserId': '6551', 'LastActivityDate': '2013-04-04T10:55:25.213', 'LastEditDate': '2013-04-03T18:51:26.803', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10988', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Tags': '<formal-languages><context-free><closure-properties><check-my-proof>', 'CreationDate': '2013-04-03T02:16:07.357', 'Id': '10985'}{'Body': '<p>Let $L$ be a regular language.<br>\nIs the language $L_2 = \\{y : \\exists x,z\\ \\ s.t.|x|=|z|\\ and\\ xyz \\in L \\}$ regular?</p>\n\n<p>I know it\'s very similar to the <a href="http://cs.stackexchange.com/questions/7588/regularity-of-middles-of-words-from-regular-language">question here</a>, but the catch is that it\'s not a simple substring of a word in a regular language, but rather an "exact middle" - we have to count the prefix and suffix length.</p>\n\n<p>Therefore, I assume it\'s not regular, but I couldn\'t find a way to prove it. I also couldn\'t think of any way to modify the NFA of $L$ to accept $L_2$.</p>\n', 'ViewCount': '145', 'Title': 'Regularity of the exact middle of words from a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-04T23:21:21.383', 'LastEditDate': '2013-04-04T23:21:21.383', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7577', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-04-04T15:05:08.010', 'FavoriteCount': '1', 'Id': '11018'}{'Body': "<p>I'm studying Turing Machines and I've already showed how Turing-Decidable is closed for the operations of Union, Intersection, Concatenation, Complement and Kleene Star. Next I did some demonstrations to show how T-Recognizable languages are closed for Union, Intersection, Concatenation and Kleene Star.</p>\n\n<p>Now I'm trying to answer a question to show why the classe of T-Recognizable languages are not closed for the operation of Complementation, but I cannot understand it. Could someone please explain this?</p>\n", 'ViewCount': '1166', 'Title': "Why isn't the class of Turing-Recognizable languages closed under Complement?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T19:56:48.270', 'LastEditDate': '2013-04-07T19:01:23.620', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7632', 'Tags': '<computability><undecidability><closure-properties>', 'CreationDate': '2013-04-07T17:52:07.083', 'Id': '11104'}{'Body': '<p>The context-free languages are <em>not</em> closed under complement, we know that.</p>\n\n<p>As far as I understand, context-free languages that are a subset of $a^*b^*$ for some letters $a,b$ are closed under complement(!?)</p>\n\n<p>Here is my argument. Each CF language $L$ has a semi-linear Parikh image $\\pi(L) = \\{ (m,n) \\mid a^mb^n \\in L \\}$. Semilinear sets are closed under complement. The set of vectors that represent the semi-linear set can easily be transformed into a linear grammar.</p>\n\n<p><strong>Question.</strong> Is there an easily accessible reference to this fact?</p>\n\n<p>Technically these languages are called <em>bounded</em>, i.e., a subset of $w_1^* \\dots w_k^*$ for some words $w_1,\\dots,w_k$.</p>\n\n<p>My motivation for this question is from a recent <a href="http://cs.stackexchange.com/questions/11106/why-is-the-following-language-not-context-free">question</a> on the context-freeness of $\\{ a^nb^m \\mid n^2 \\neq m \\}$. Its complement within $a^*b^*$ seems easier to handle.</p>\n', 'ViewCount': '277', 'Title': 'Are context-free languages in $a^*b^*$ closed under complement?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T19:08:24.873', 'LastEditDate': '2013-04-07T20:00:05.160', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11142', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<formal-languages><reference-request><context-free><closure-properties>', 'CreationDate': '2013-04-07T19:05:16.153', 'Id': '11110'}{'Body': '<p>Some sets of ordered binary trees can be represented as a CFG with rules of the form</p>\n\n<pre><code>A -&gt; aBC\nA -&gt; b\n</code></pre>\n\n<p>Where <code>A,B,C</code> are nonterminals and <code>a</code> and <code>b</code> are terminals representing internal nodes and leaf nodes respectively. The tree can be recovered from any word in the language by a preorder traversal.</p>\n\n<p>The set of all such grammars forms a class of languages which is a subset of context free languages but isomorphic to a superset of regular languages (by unary encoding the alphabet and adding a dummy terminal for the second nonterminal in every production). It is obviously closed under union as you can simply concatenate the lists of productions to get a new tree grammar.</p>\n\n<p>My question is whether this class is closed under intersection. I have been unable to prove that is either closed or not closed, and I figured I should see if anyone else can see how to do this. </p>\n', 'ViewCount': '166', 'Title': 'Closure under intersection of context free binary trees', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T22:23:35.630', 'LastEditDate': '2013-04-07T22:05:19.403', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11115', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2511', 'Tags': '<context-free><formal-grammars><closure-properties>', 'CreationDate': '2013-04-07T21:12:07.577', 'Id': '11114'}{'Body': '<p>Given a context-free language $L$, define the language $p(L)$ as containing all permutations of strings in $L$ (i.e. all strings in $L$ such that the order of symbols is not important). Is $p(L)$ context-free?</p>\n\n<p>I found two papers dealing with similar, but not identical, questions:</p>\n\n<ul>\n<li><p><a href="http://www.sciencedirect.com/science/article/pii/S0304397505008571" rel="nofollow">Generating all permutations by context-free grammars in Chomsky normal form</a> by Asveld (2003) deals with finite languages.</p></li>\n<li><p><a href="http://www.sciencedirect.com/science/article/pii/0020019082901090" rel="nofollow">Permutations are not context-free: An application of the interchange lemma</a> by Main (1982) deals with "permutation languages", i.e. sets of strings of the form $w x p(x) z$, where $p(x)$ is a any permutation of $x$. Also, the result is limited to alphabets with 16 symbols.</p></li>\n</ul>\n', 'ViewCount': '240', 'Title': 'Are permutations of context-free languages context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T14:34:16.553', 'LastEditDate': '2013-04-15T12:28:57.093', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11332', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<formal-languages><context-free><closure-properties><permutations>', 'CreationDate': '2013-04-15T12:09:49.237', 'Id': '11329'}{'Body': "<p>Prove that context free languages aren't closed under this operation: $ A(L) = \\{ zyx \\mid x,y,z \\in \\{0,1 \\}^*, xyz \\in L \\} $</p>\n\n<p>Obviously, we need to find a context free language $L$ such that $A(L)$ isn't context free. Here are some of my failed attempts:</p>\n\n<p>Take the language $ L = \\{\\ 0^n1^n \\mid n \\in N \\} $ and then (since the intersection of a context free language with a regular language is context free) we get: $ A(L) \\cap 1^*0^*1^*0^*  = \\{\\ 1^{m}0^{n-k}1^{n-m}0^{k} \\mid n,k,m \\in N, m,k\\le n \\} $ which might look promising at first, but unfortunately this language is context free...</p>\n\n<p>I also tried my luck with the following languages:<br>\n$ L = \\{\\ 0^n1^m0^m1^n \\mid n,m \\in N \\} $<br>\n$ L = \\{\\ ww^R \\mid w \\in \\{0,1 \\}^* \\} $  </p>\n\n<p>but these languages didn't help me either...</p>\n", 'ViewCount': '160', 'Title': 'Prove that context free languages are not closed under swapping prefixes and suffixes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T06:23:56.547', 'LastEditDate': '2013-04-24T06:23:56.547', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11526', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><closure-properties><pumping-lemma>', 'CreationDate': '2013-04-23T18:47:53.523', 'Id': '11525'}{'ViewCount': '173', 'Title': 'Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular', 'LastEditDate': '2013-04-30T15:54:36.220', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7492', 'FavoriteCount': '1', 'Body': "<p>Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular.</p>\n\n<p>These are the things that I would use to start.</p>\n\n<ul>\n<li>As $L_1L_2$ is regular, then the homomorphism $h(L_1L_2)$ is regular.</li>\n<li>Let $h(L_1) = L_2$ and $h(L_2) = L_1$, then $h(L_1L_2) = L_2L_1$ is regular (we already know that) or $h(L_2) = \\epsilon$ and we get $L_1$</li>\n<li>By reflexing, $L_1L_2 = (L_2L_1)^{R}$, same result.</li>\n</ul>\n\n<p>But i don't know how to, for example, intersect something that gives me $L_1$ in order to preserve closure and finally $L_1$ be regular.</p>\n\n<p>Any help?</p>\n", 'Tags': '<regular-languages><finite-automata><proof-techniques><closure-properties>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-30T15:54:36.220', 'CommentCount': '0', 'AcceptedAnswerId': '11596', 'CreationDate': '2013-04-27T03:06:35.000', 'Id': '11592'}{'Body': u'<p>I\'ve been reading some formal language theory papers, and I\'ve come across a term that I don\'t understand.</p>\n\n<p>The paper will often refer to a set being "effectively closed under intersection" or other operations. What does "effectively" mean here? How does this differ from normal closure?</p>\n\n<p>For reference, the paper I\'m seeing these in is:</p>\n\n<p>M. Daley and I. McQuillan. Formal modelling of viral gene compression. International Journal of Foundations of Computer Science, 16(3):453\u2013469, 2005.</p>\n', 'ViewCount': '125', 'Title': 'What does it mean to say that a language is "effectively closed" under an operation?', 'LastActivityDate': '2013-05-09T20:16:49.303', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11922', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><terminology><computability><automata><closure-properties>', 'CreationDate': '2013-05-09T19:51:28.577', 'Id': '11920'}{'Body': '<p>Where can I find a proof of this? Thanks!</p>\n', 'ViewCount': '918', 'Title': 'Proof that the regular languages are closed under string homomorphism', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-10-03T14:16:12.663', 'LastEditDate': '2013-05-16T02:20:15.170', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user16022', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-05-14T01:07:04.453', 'FavoriteCount': '2', 'Id': '12017'}{'Body': '<p>The notion of <a href="http://en.wikipedia.org/wiki/Polynomial-time_reduction" rel="nofollow">polynomial time Turing reductions</a> (Cook reductions) is an abstraction of a very intuitive concept: efficiently solving a problem by using another algorithm as a subroutine. </p>\n\n<p>For example, by stating "$A$ is polynomial time Turing reduced to $B$", we indicate that we can solve the problem $A$ in a polynomial number of steps by making use of an algorithm which can solve the problem $B$.</p>\n\n<p>Then if $B$ is in $\\mathsf{NP}$, why not $A$?</p>\n', 'ViewCount': '314', 'Title': 'Why NP is not closed under Turing reduction', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-08T20:38:39.947', 'LastEditDate': '2013-06-08T20:38:39.947', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'Zhong Yantao', 'PostTypeId': '1', 'Tags': '<complexity-theory><reductions><closure-properties><np>', 'CreationDate': '2013-06-08T09:08:33.743', 'Id': '12541'}{'Body': "<p>Let $L$ be a star-free language over finite alphabet $\\Sigma$.  A <em>substitution</em> will be a map $\\sigma : \\Sigma \\to \\mathcal{P}(\\Sigma^*)$.  It seems obvious that if $\\sigma(a)$ is star-free for every $a \\in \\Sigma$, then $\\sigma(L)$ will be star-free.<br>\n($\\sigma(L) = \\{ w_1 ... w_n | w_i \\in \\sigma(a_i) \\land a_1 \\ldots a_n \\in L \\}$)\nTake a star-free regular expression for $L$, and substitute star-free expressions for $L_i$\nfor each $a_i$ in that expression.  The result will still be a star-free expression.</p>\n\n<p>Now, my question is this: why is the following not a counterexample?\n$\\Sigma = \\{ 0, 1 \\}$. $L = 1^*$ and $\\sigma(1) = 0^* 1 0^* 1 0^*$.\nBoth of these languages are star-free:\n$L = L( (\\emptyset^c 0 \\emptyset^c )^c )$ and similar tricks can be given to show that $\\sigma(1)$ is star-free.</p>\n\n<p>Now, the reason it seems like a counterexample: a word in $L$ contains only 1s. The substitution replaces each 1 with a word from a language whose words contain exactly 2 1s.\nSo won't $\\sigma(L)$ be the set of words with an even number of 1s, which is known to be non-star-free?</p>\n\n<p>(Note: my proof suggestion of closure under substitution is a bit sketchy.  The star-free expression for $1^*$ only has 0s in it.  But I could then substitute \nthe star-free expression for $\\sigma(1)$ under a complement, no?)</p>\n", 'ViewCount': '78', 'Title': 'Closure of Star-Free Languages under Substitution', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:40:43.930', 'LastEditDate': '2013-06-10T09:40:43.930', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12550', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8590', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-06-08T21:54:25.707', 'Id': '12546'}{'Body': '<p>This is a question from <a href="http://cs.anu.edu.au/courses/COMP3630/comp3630exams.pdf" rel="nofollow">a 2007 exam paper for a course I\'m studying</a>, question 2 on page 2.</p>\n\n<blockquote>\n  <p>Theorem: Let $L$ be a context-free language. Let $L_{even}$ be the subset of $L$ consisting of all the strings in $L$ that have even length. Then $L_{even}$ is context-free.</p>\n</blockquote>\n\n<p>The question is to prove this theorem using two of three different methods: using grammars, PDAs, or a theorem about language intersections.</p>\n\n<p>I can very easily find a proof using PDAs (maintain your current odd/even status using the stack), and intersections (intersect with $\\Sigma^*_{even}$, which is regular) - but I can\'t think of how to do it using properties of grammars. I suspect either Chomsky or Greibach Normal Forms comes in handy here but I\'m not sure how.</p>\n', 'ViewCount': '89', 'Title': 'Proving that CFLs are closed under even-ness using grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T10:36:08.340', 'LastEditDate': '2013-06-10T10:33:55.813', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '12557', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8591', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties>', 'CreationDate': '2013-06-09T02:53:21.853', 'Id': '12554'}{'Body': '<p>Let $L$ be a language such that $\\overline{L}^R$ (the reversal of the complement of $L$) is context-free. Is then also $\\overline{(L^R)} \\in \\mathrm{CFL}$?</p>\n', 'ViewCount': '59', 'Title': 'Is CFL closed against exchanging complementation and reversal?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-15T15:22:42.030', 'LastEditDate': '2013-06-15T15:22:42.030', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'Guy', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2013-06-11T18:02:04.590', 'Id': '12631'}{'Body': "<p>In the book on complexity by Arora and Barak, there is an exercise to show $Space(n)\\neq NP$, the proof of which goes by showing that $NP$ is closed under Karp reductions, while $Space(n)$ isn't.</p>\n\n<p>To show that $Space(n)$ isn't closed under Karp reductions, the suggested technique (both in the solutions given at my place of study as well as those given at many other universities) is to assume we have a TM that decides language $L$ in $Space(n^2)$. Now take an encoding $enc(x)$ of some $x$ in $L$ with $|enc(x)| = n$ and blow it up (in quadratic, thus polynomial time) to an encoding $enc'(x)$ of $x$ with $|enc'(x)| = n^2$ by padding the smaller encoding with $n^2-n$ padding symbols. Now we take the same TM, and it can decide $L$ in space linear in $enc'(x)$ by ignoring the padding stuff and just operating on $enc(x)$. This implies that $Space(n^2) \\subseteq Space(n)$, which contradicts the space hierarchy theorem, so $Space(n)$ can't be closed under Karp reductions.</p>\n\n<p>My problem here is that while I realize that we can easily show that $NP$ is closed under Karp reductions, it somewhat confuses me regarding what this says about $NTime(s(n))$. It seems to me that this approach will also work to show that $NTime(s(n))$ isn't closed under Karp reductions for any time-constructible function s(n) using the time hierarchy theorem, or am I mistaken here?</p>\n", 'ViewCount': '95', 'Title': 'Space(n) not closed under Karp reductions - what about NTime(n)?', 'LastEditorUserId': '6689', 'LastActivityDate': '2013-06-16T23:04:50.010', 'LastEditDate': '2013-06-16T19:32:14.977', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12704', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6689', 'Tags': '<complexity-theory><reductions><closure-properties>', 'CreationDate': '2013-06-16T18:31:07.150', 'Id': '12702'}{'Body': "<p>So, it's fairly easy to prove that if $L \\in DCFL$, then $L \\Sigma^* \\in DCFL$. Basically, you take the DPDA accepting $L$. You remove all transitions on final states, and then for each $a \\in \\Sigma$ and each final state $q$, you add a transition looping from $q$ to $q$ on $a$.</p>\n\n<p>I'm using this in a paper, and I'd love to not have to actually prove this construction is valid. It's easy, but it's about a half-page long. Since DPDAs have been studied almost exhaustively, I was wondering, does anybody know of a paper that proves this property?</p>\n", 'ViewCount': '138', 'Title': 'Reference request: proof that if $L \\in DCFL$, then $L \\Sigma^* \\in DCFL$', 'LastActivityDate': '2013-07-10T20:22:04.583', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13215', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><reference-request><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-07-09T17:23:08.623', 'Id': '13179'}{'Body': "<p>It's known that the complement of a DFA can be easily formed. That is, given a machine $M$, we can construct $M'$ such that $L(M') = \\Sigma^* \\setminus L(M)$.</p>\n\n<p>Is it possible to construct such a complement for a non-deterministic finite automation (NFA)? To my knowledge, it isn't.</p>\n", 'ViewCount': '1457', 'Title': 'Complement of Non deterministic Finite Automata', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-16T18:40:12.790', 'LastEditDate': '2013-07-16T10:18:36.350', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9190', 'Tags': '<automata><finite-automata><closure-properties>', 'CreationDate': '2013-07-15T10:40:24.740', 'FavoriteCount': '1', 'Id': '13282'}{'Body': '<p>I am trying to solve the question 6.12 in Arora-Barak (Computational Complexity: A modern approach). The question asks you to show that the\n$\\mathsf{PATH}$ problem (decide whether a graph $G$ has a path from a given node $s$ to another given node $t$) which is complete for $\\mathbf{NL}$ is also contained in $\\mathbf{NC}$ (this is easy). The question then also makes a remark that this implies that $\\mathbf{NL} \\subseteq \\mathbf{NC}$ which is not obvious to me.</p>\n\n<p>I think in order to show this, one has to show that $\\mathbf{NC}$ is closed under logspace reductions, i.e</p>\n\n<p>$$(1): B \\in \\mathbf{NC} \\hbox{ and } A \\le_l B \\Longrightarrow A \\in \\mathbf{NC}$$ </p>\n\n<p>where $\\le_l$ is the logspace reduction defined as</p>\n\n<p>$$A \\le_l B :\\Longleftrightarrow (\\exists M \\hbox{ TM}, \\forall x)[x \\in A \\Longleftrightarrow M(x) \\in B]$$</p>\n\n<p>($M$ is a TM which runs in logarithmic space).</p>\n\n<p>I would appreciate if someone could give a tip for proving the statement $(1)$.</p>\n', 'ViewCount': '105', 'Title': '$\\mathbf{NC}$ is closed under logspace reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-22T15:25:58.423', 'LastEditDate': '2013-07-22T14:17:00.753', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13390', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9293', 'Tags': '<complexity-theory><reductions><closure-properties><complexity-classes><parallel-computing>', 'CreationDate': '2013-07-22T12:55:57.660', 'Id': '13387'}{'Body': "<p>For a language L we define:  </p>\n\n<p>$\\qquad A(L) = \\{ x \\in L \\mid \\text{ no proper prefix of x is in L} \\} $</p>\n\n<p>Are regular / context free languages closed under this operation ?</p>\n\n<p>For regular languages I thought about taking the DFA that accepts the language L and create a new NFA by making all accepting states sinks (so the only way of being accepted by the automata is that when reading the last letter we reach an accepting state for the first time).</p>\n\n<p>Can't we make the same thing with a pushdown automata for context free languages ?</p>\n\n<p>Edit (as Raphael pointed out, the example below is wrong):</p>\n\n<p>But here is a strange language that I think implies the opposite:<br>\n$L = \\{ 0^{i}1^{j}2^{n} \\mid i \\le n \\ \\text{ or }\\ j \\le n \\} $<br>\n$A(L) = \\{ 0^{i}1^{j}2^{n} \\mid n = \\min(i,j) \\} $</p>\n\n<p>$L$ is context free but $A(L)$ isn't. Obviously, at least one of the things I wrote above is wrong. Anyone have any clue what is going on here ?</p>\n", 'ViewCount': '404', 'Title': 'Are regular and context free languages closed against making them prefix-free?', 'LastEditorUserId': '7068', 'LastActivityDate': '2013-07-22T19:55:09.470', 'LastEditDate': '2013-07-22T18:20:01.553', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '13389', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2013-07-22T13:54:58.530', 'Id': '13388'}{'Body': '<p>Given two context-free languages $L_1$ and $L_2$, the language given by the difference of the two languages, $L_1 - L_2$, is (in general) not context-free. Is it possible to prove this without using pumping lemma? </p>\n', 'ViewCount': '426', 'Title': 'Prove Context Free languages not closed under difference?', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-08-14T20:10:39.333', 'LastEditDate': '2013-08-12T06:36:37.980', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8533', 'Tags': '<context-free><closure-properties>', 'CreationDate': '2013-08-10T11:08:36.113', 'Id': '13701'}{'Body': '<p>Suppose I have a DFA recognizing a regular language $L$, how do I prove that \n$$\\text{lefthalf}(L)= \\{ w_1 \\mid \\exists w_2 \\in \\Sigma^* ,w_1w_2 \\in L \\land \\|w_1\\| = \\|w_2\\| \\}$$ is also a regular language?</p>\n', 'ViewCount': '86', 'ClosedDate': '2013-09-18T09:23:28.010', 'Title': 'Proving that a derived language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T09:19:49.913', 'LastEditDate': '2013-09-18T09:19:49.913', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10191', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-09-18T03:02:09.353', 'Id': '14397'}{'Body': "<p>This is the question I am asked and I am currently proving it using proof by contradiction something like this:</p>\n\n<ul>\n<li>Let's take some language <strong>L</strong> which is non regular.</li>\n<li>Let's assume compliment of L i.e. $(L^c)$ is regular.</li>\n<li><p>Since we know that regular languages are closed under complementation, complementation of $(L^c)$, i.e. $(L^c)^c$ must be regular.</p></li>\n<li><p>Now  $(L^c)^c$ is  $L$ means $L$ is regular which contradicts the assumption.</p></li>\n<li>So, our assumption that $L^c$ is regular must be false.</li>\n<li>Hence, we can prove that $L^c$ is not regular.</li>\n</ul>\n\n<p>Is this a correct approach to deduce?</p>\n\n<p>Using same result I have to state true/false for the following two statements and support by giving proof.</p>\n\n<ul>\n<li><p>The class of non regular languages is closed under union.</p></li>\n<li><p>The class of non regular languages is closed under intersection.</p></li>\n</ul>\n\n<p>How do I solve these two statements using the result above? Any hints would be helpful.</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '1158', 'Title': 'Is the class of non regular languages is closed under complementation?', 'LastActivityDate': '2013-09-20T07:45:16.030', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10086', 'Tags': '<regular-languages><closure-properties>', 'CreationDate': '2013-09-20T07:45:16.030', 'Id': '14462'}{'Body': '<p>Let $\\Sigma$ and $\\Delta$ be alphabets. Consider a\nfunction $\\varphi: \\Sigma \\rightarrow \\Delta^*$. Extend $\\varphi$ to\na function from $\\Sigma^* \\rightarrow \\Delta^*$ such that:\n\\begin{eqnarray*}\n\\varphi(\\varepsilon) &amp; = &amp; \\varepsilon \\\\\n\\varphi(w\\sigma ) &amp; = &amp; \\varphi(w)\\varphi(\\sigma ), \\textrm{ for any }\nw \\in  \\Sigma ^*, \\sigma  \\in  \\Sigma\n\\end{eqnarray*}\nAny function $\\varphi:\\Sigma^* \\rightarrow \\Delta^*$ defined in this way\nfrom a function $\\varphi: \\Sigma \\rightarrow \\Delta^*$ is called a\n<strong>homomorphism</strong>. We can extend this definition to languages as follows:\nfor any language $L$ and homomorphism $\\varphi$, let \n$$\\varphi(L)=\\{\\varphi(w) : w\\in L\\}.$$</p>\n\n<p>Are regular languages are closed under inverse homomorphism?</p>\n', 'ViewCount': '381', 'Title': 'Are regular languages closed under inverse homomorphism?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-04T18:57:57.430', 'LastEditDate': '2013-10-04T18:57:57.430', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-10-03T14:21:55.540', 'Id': '14785'}{'Body': '<p>This is a question from the exam of our "Automata and Formal Languages" course. There is a question where asked to prove or disprove that any "relative complement" operation between two context sensitive languages will also produce a context sensitive language. </p>\n\n<p>From the context sensitive closure properties <a href="http://en.wikipedia.org/wiki/Context-sensitive_language" rel="nofollow">Wikipedia</a>, and <a href="http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Context-sensitive_language.html" rel="nofollow">princeton.edu</a>. \nI know that those languages are closed under intersection and complement.   </p>\n\n<p>I have spent too much time on finding the formal prove of those statements. Where / How can I find the proofs? Or how to prove them by myself? Can anyone point me to a reference ? Can any one post here the proofs ? </p>\n', 'ViewCount': '482', 'Title': 'How to prove that context sensitive languages are closed under intersection and complement?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-14T12:05:26.827', 'LastEditDate': '2013-10-14T12:05:26.827', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '15016', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10674', 'Tags': '<formal-languages><closure-properties><context-sensitive>', 'CreationDate': '2013-10-12T11:14:06.500', 'Id': '15014'}{'Body': "<p>In class, it was alluded to that a language: \\begin{equation*}\n\\{s_0 w s_1 : s_0s_1\\in L_1, w\\in L_2 \\}\n\\end{equation*} would be context free, if $L_1$ and $L_2$ are context free.</p>\n\n<p>Intuitively, that doesn't make sense to me. I tried doing my own research and attempted a proof using the pumping lemma, but didn't get anywhere. Maybe I misunderstood? If that is correct, how could I prove it (or convince myself). </p>\n", 'ViewCount': '75', 'Title': 'Is $\\{s_0 w s_1 : s_0s_1\\in L_1, w\\in L_2 \\}$ context free if $L_1$ and $L_2$ are?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-14T22:13:02.620', 'LastEditDate': '2013-10-14T08:53:30.113', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16054', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10410', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2013-10-13T18:47:16.867', 'Id': '16048'}{'Body': "<p>I can't figure out a proof that recursive languages are closed under concatenation. I know this is easy for most of the people but unfortunately my professor is not very good at explaining the material. If anybody can provide any hints on how to do it I would greatly appreciate it.</p>\n", 'ViewCount': '106', 'Title': 'Proof that recursive languages are closed under concatenation', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-19T21:27:20.623', 'LastEditDate': '2014-04-19T21:27:20.623', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<formal-languages><computability><closure-properties>', 'CreationDate': '2013-11-03T22:38:03.393', 'Id': '16680'}{'Body': "<p>How to prove that if a language A is not regular then A* isn't regular either?</p>\n\n<p>I have tried the usual methods with no result.</p>\n", 'ViewCount': '157', 'Title': 'Is the class of non-regular languages closed against Kleene star?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-04T19:22:08.677', 'LastEditDate': '2013-11-04T19:22:08.677', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11166', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-11-04T07:58:34.270', 'Id': '16695'}{'Body': "<p>Is it true that if A is a subset of B, and B is decidable, than A is guaranteed to be decidable?</p>\n\n<p>I believe it would be true because all the subsets of B should also be decidable making A decidable. I'm not sure if my thought process is right or if there's a easier more intuitive way to explain this.</p>\n", 'ViewCount': '362', 'Title': 'Is every subset of a decidable set, also decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:31.597', 'LastEditDate': '2013-11-13T22:08:31.597', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<computability><undecidability><closure-properties><sets>', 'CreationDate': '2013-11-12T18:05:15.880', 'Id': '17966'}{'Body': "<p>Given $A,B$ regular languages with $A \\prec B$. Prove the existence of $C\\in L_{\\text{regular}}$ so that: $A \\prec C \\prec B$.</p>\n\n<p>Here, $A\\prec B$ stands for: $A\\subset B $ and $B\\setminus A $ is infinite.  </p>\n\n<p>I tried to go for: $C=\\overline{B} \\cup A$ and some other options but it didn't work out.</p>\n", 'ViewCount': '93', 'Title': 'Prove the existence of regular $C$ so that: $A \\prec C \\prec B $', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-12-06T00:27:44.990', 'LastEditDate': '2013-12-06T00:27:44.990', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18654', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11841', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-12-05T15:55:23.273', 'Id': '18646'}{'Body': u"<p>I've been trying for quite some extended time to find a construction so that I can formally demonstrate that a deterministic PDA is closed under complementation. However, it happens that every idea I got has something that at the end does not fit. Could you give me a hand?</p>\n\n<p>The main problem happens with the <strong>\u03b5-moves</strong>. A PDA could finish reading its input in a non-final (rejecting state) but can still move to a final (accepting) state through an <strong>\u03b5-move</strong> and end up accepting the string. This means that just adding a dead state and complementing the states does not work. I already solved the problem of possible infinite sequences of <strong>\u03b5-moves</strong>, so that is not a main part of my question.</p>\n\n<p><strong>EDIT:</strong> As far as I understand, if the DPDA reaches <em>end of input</em> and is in an accepting state and moves to a rejecting state through an <strong>\u03b5-move</strong> it would still accept it (as it reached a final state with no input symbol left to read).</p>\n\n<p>Please let me know if I can be more clear.</p>\n", 'ViewCount': '148', 'Title': 'Demonstrate that DPDA is closed under complement by construction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-28T10:53:54.807', 'LastEditDate': '2014-03-26T08:26:09.787', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-12-10T00:34:01.010', 'Id': '18800'}{'Body': "<p>I have a question on my homework causing some confusion.  </p>\n\n<blockquote>\n  <p>If L is a strict subset of L', and L' is a member of Co-NP, is L a member of Co-NP? True of False</p>\n</blockquote>\n\n<p>Now I understand what belonging to Co-NP. Essentially means instead of deciding a yes instance we're deciding a no instance of the decidable problem.  I'm stuck on interpreting L' and what it is.</p>\n\n<p>My guess at this point is that L is a member of Co-NP since it's a subset of L' which we're given is in Co-NP.</p>\n", 'ViewCount': '125', 'Title': 'Is Co-NP closed under taking subset?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-12T10:52:15.023', 'LastEditDate': '2013-12-11T16:14:03.290', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<complexity-theory><closure-properties><np>', 'CreationDate': '2013-12-11T16:01:15.793', 'Id': '18880'}{'Body': u"<p>Are NP or P closed under subtraction? Im having a hard time deciding whether they are or aren't.\n<em>Question was edited</em></p>\n\n<p><strong>Original question</strong>:\nIm having some hard time figuring out what languages are closed under subtraction.\nSay you have 2 languages A, B \u2208 NP. Is A\\B \u2208 NP? what about P?</p>\n\n<p><strong>Commenters</strong>:\nMy original question was extremely not accurate so i rephrased :)</p>\n\n<p>Thanks!</p>\n", 'ViewCount': '97', 'Title': 'Complexity classes that are closed under subtraction', 'LastEditorUserId': '12040', 'LastActivityDate': '2013-12-11T23:21:43.957', 'LastEditDate': '2013-12-11T23:17:20.347', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '18903', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12040', 'Tags': '<complexity-theory><closure-properties><np>', 'CreationDate': '2013-12-11T20:57:30.853', 'Id': '18897'}{'Body': '<p>I read a proof on the closure of decidable languages under kleene star. It begins by saying that the turing machine we want to find would non-determistically split the input string and then use the original decider of the language to approve the partition of each branch.</p>\n\n<p>My question is, I can\'t understand how we can do this non-deterministic split on a word whose length we do not yet know. if the word is very big then there exist more partitions, thus more branches are needed.</p>\n\n<p>So, i don\'t understand how this "non-deterministic split" can be materialized. </p>\n\n<p>Also, if someone has another proof of this closure via turing machines it will be more than welcome!</p>\n', 'ViewCount': '194', 'Title': 'Decidable languages kleene star closure - question on a proof', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T13:59:37.270', 'LastEditDate': '2014-01-18T19:29:21.573', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19813', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12948', 'Tags': '<computability><turing-machines><closure-properties><nondeterminism>', 'CreationDate': '2014-01-18T18:43:45.827', 'Id': '19811'}{'Body': "<p>I'm trying to learn automata theory on my own and I am running into an issue with the second part of the question:</p>\n\n<p>We say B is transitive if $BB\\subseteq B$ and reflexive if $\\epsilon \\in B$</p>\n\n<blockquote>\n  <p>Show that A* is a reflexive and transitive set containing A and if B is any other reflexive and transitive set containing A, then $A^*\\subseteq B$.</p>\n</blockquote>\n\n<p>I've shown that Kleene star satisfies these two conditions. I've tried partitioning B into two sets with $A = B \\cup C $ and trying a constructive proof but this hasn't led any where. I also am considering a proof by contradition but don't know where to start.</p>\n\n<p>Can you help me with a hint on how to approach this problem?</p>\n", 'ViewCount': '45', 'Title': 'Prove that A* is the smallest reflexive and transitive set containing A', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:02:21.973', 'LastEditDate': '2014-01-19T14:55:51.747', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19827', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12955', 'Tags': '<formal-languages><closure-properties>', 'CreationDate': '2014-01-19T05:26:56.603', 'Id': '19820'}{'Body': "<p>I've seen in previous exams that professors marked the theory as correct:</p>\n\n<blockquote>\n  <p>If $L$ is CFL and $\\overline{L}$ is CFL, then L is regular.</p>\n</blockquote>\n\n<p>I just don't see how this would work. How would we prove such a thing? I also can't come up with contradicting languages.</p>\n", 'ViewCount': '102', 'Title': 'If $L$ is CFL and $\\overline{L}$ is CFL, then is L regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:50:22.907', 'LastEditDate': '2014-01-20T08:43:52.727', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '19836', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-01-19T20:00:18.470', 'Id': '19834'}{'Body': '<p>I have this question about closure of a context free grammar, and if someone can check my answer and see if it makes sense, and if not, what is missing, I would be very grateful.</p>\n\n<blockquote>\n  <p>Give an counter-example to show that the following contruction fails in to proof that class of languages free of context is closed under the operation star. By A a language free of context that it is generated by the GLC G = {V,,R,S}. Add the new rule S -> SS e call the resulting grammar G\'. That grammar is expected to generate a*"</p>\n</blockquote>\n\n<p>I have only a superficial comprehension, I believe it is necessary that Rg\', the set of production rules of G\' must be equal to Rg united with {Sg\'->SgSg\'|e} or in another words Rg\': Rg U {Sg\'->SgSg\'|e}. Even if that it is correct I don\'t understand why {Sg\'->SgSg\'|e} is necessary</p>\n', 'ViewCount': '65', 'Title': 'Kleene star closure of a context free grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:26:21.240', 'LastEditDate': '2014-01-25T16:26:21.240', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13113', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-01-24T23:59:34.787', 'Id': '19955'}{'Body': '<p>Let $A$ be some alphabet.</p>\n\n<p>$A$ itself is a regular language.</p>\n\n<p>$E = A^*$ is regular language over $A$. $E$ is a superset of all languages over $A$, regular or otherwise, i.e $E$ contains every possible string from symbols of $A$.</p>\n\n<p>Now let $L$ be some regular language over $A$.</p>\n\n<p>What is $\\tilde{L} = L \\cdot E$ ? More specifically, how $\\tilde{L}$ and $E$ relate to each other? Are they equal? Is one subset of the other? Something else?</p>\n\n<p>Source of the confusion is the following reasoning: closure under concatenation says that $\\tilde{L}$ is a regular language and therefore $\\tilde{L} \\subseteq E$  (according to the above). On the other hand $\\tilde{L}$ seems to contain strings $E$ does not, i.e. those that are formed by concatenating non-empty string from both languages.</p>\n\n<p>Obviously this is wrong. What is going on here?</p>\n', 'ViewCount': '80', 'Title': 'Regular language concatenation with superset', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-29T18:36:17.587', 'LastEditDate': '2014-01-29T17:16:31.227', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '20075', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12837', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-01-29T16:10:18.927', 'Id': '20069'}{'Body': '<blockquote>\n  <p>Let $A/B$ = $\\{ w \\mid wx \\in A$ for some $x \\in B \\}$.  Show that if A is context free and B is regular, then $A/B$ is context free.</p>\n</blockquote>\n\n<p>My interpretation of this is is that we need to show that if a string $wx$ is accepted by a CFG, and we know that $x$ is accepted by a regular language (and therefore is also accepted by a context-free language), then $w$ must also be accepted by a CFG. </p>\n\n<p>My initial thought on how to solve this would be a proof by contradiction in which we assume that $A$ is context free, $B$ is regular, and then assume that $A/B$ is not context-free.  Since $A$ is context free, we can construct an equivalent PDA that accepts $A$.</p>\n\n<p>From here, my thought was to take an arbitrary $wx$ that is accepted by $A$, such that $x \\in B$.  We can then construct another PDA based on the first that only accepts $wx$.  We could then break the PDA into two pieces: one that accepts $w$ and one that accepts $x$ (with the two pieces concatenated together).  Since there then would exist a PDA that accepts just $w$, and $w$ is arbitrary insofar as $wx$ was arbitrary, $A/B$ must therefore be context-free after all (contradiction). </p>\n\n<p>Will this approach work? (Is this a good general approach?)  If so, how would I go about breaking the PDA that accepts $wx$ into chunks formally? </p>\n', 'ViewCount': '160', 'Title': 'Closure of CFL against right-quotient with regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T12:07:40.013', 'LastEditDate': '2014-01-30T11:02:17.620', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '20091', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13232', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-01-29T23:16:32.513', 'Id': '20090'}{'ViewCount': '392', 'Title': 'Why is the class of recursively enumerable languages not closed under complementation?', 'LastEditDate': '2014-02-04T11:38:24.893', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9987', 'FavoriteCount': '1', 'Body': '<p>I am having a hard time understanding closure properties of recrusively enumerable languages. I have read the explanation on <a href="http://www.eecs.wsu.edu/~cook/tcs/l19.html" rel="nofollow">this site</a> but still unable to fully understand why they are not closed under complementation?</p>\n\n<p>Explanation also says,</p>\n\n<blockquote>\n  <p>This fails because $M$ only needs to halt if $w \\in L(M)$ - doesn\'t have to say "no".</p>\n</blockquote>\n\n<p>What does it mean?</p>\n', 'Tags': '<computability><closure-properties><semi-decidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T23:26:26.210', 'CommentCount': '2', 'AcceptedAnswerId': '21285', 'CreationDate': '2014-02-04T11:23:23.813', 'Id': '21284'}{'Body': '<p>I am having hard time solving the following problem.</p>\n\n<blockquote>\n  <p>Are there any languages for which\n  $$\n\\overline{L^*} = (\\overline{L})^*\n$$</p>\n</blockquote>\n\n<p>Assuming $\\emptyset^* = \\emptyset$, if I consider $\\Sigma = \\{a\\}$ and L = $\\Sigma^*$, I get that $L^* = L$ and that $\\overline{L^*} = \\emptyset$. For the right side I get $\\overline{L} = \\emptyset$ and $(\\overline{L})^* = \\emptyset$. Thus, both sides are equal. </p>\n\n<p>Is it true that $\\emptyset^* = \\emptyset$?</p>\n', 'ViewCount': '118', 'Title': 'Do Kleene star and complement commute?', 'LastEditorUserId': '14587', 'LastActivityDate': '2014-02-23T20:11:13.703', 'LastEditDate': '2014-02-23T20:11:13.703', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21549', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14587', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-02-11T23:09:29.767', 'Id': '21544'}{'Body': '<p>Let $L = \\{a^n \\mid n \\ge 0\\}$, where $a^0 = \\epsilon$ and $a^n = a^{n-1}a$ for all $n \\ge 1$.</p>\n\n<p>Thus $L$ consists of sequences of $a$ of all lengths, including a sequence\nof length $0$. Let $L_2$ be any infinite subset of $L$. I need to show there always exists a DFA to recognize $L_2^*$. </p>\n\n<p>If $L_2$ is a finite subset it is very obvious as $L_2$ would be a DFA and hence by Kleene closure $L_2^*$ would be recognized by a DFA. But I am unable to get it for infinite subset as $L_2$ may not be expressed as DFA when, e.g., string lengths are prime.</p>\n', 'ViewCount': '165', 'Title': 'Kleene star of an infinite unary language always yields a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T16:47:56.060', 'LastEditDate': '2014-02-18T16:47:56.060', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21775', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13212', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-02-18T14:05:22.823', 'Id': '21765'}{'Body': '<p>It makes me wonder that despite of (CFL) being a subset of Turing Decidable languages, Turing Decidable is closed under intersection while CFL is not.</p>\n\n<p>Does not Turing Decidable engulf all CFLs?</p>\n', 'ViewCount': '44', 'Title': 'CFL not closed under intersection while Turing Decidable are', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T23:03:12.623', 'LastEditDate': '2014-02-19T23:03:12.623', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9576', 'Tags': '<formal-languages><context-free><turing-machines><closure-properties><decision-problem>', 'CreationDate': '2014-02-19T19:14:27.437', 'Id': '21821'}{'ViewCount': '65', 'Title': 'Proving that context-free languages are closed under inserting symbols', 'LastEditDate': '2014-03-20T15:55:52.117', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14596', 'FavoriteCount': '1', 'Body': '<p>This is a theoretical computer science question, regarding the proof of whether or not context-free languages are closed under an operation.  This means basically that any context-free language which undergoes this operation would still be context-free.</p>\n\n<blockquote>\n  <p>For a language $A$ which is a subset $\\Sigma^*$, define the language $A_+$ as</p>\n  \n  <p>$\\qquad\\displaystyle A_+ = \\{xyz | y\\in \\Sigma \\wedge xz \\in A\\}$.</p>\n  \n  <p>Prove that the set of context-free languages is closed under the $+$ operator.</p>\n</blockquote>\n\n<p>So $A_+$ contains all strings that can be obtained by inserting one symbol into a string in $A$.\nShow that the class of context-free languages is closed under the operation $+$ (i.e.,     show that\nif $A$ is context free, then $A_+$ is also context free).</p>\n\n<p>Note that this is not a homework question.  Examples of closure proofs are sparse online and in my textbook.  </p>\n\n<p>First, let\'s think about the different ways to prove closure of CFLs:  </p>\n\n<ol>\n<li><p>Constructing a "template" Push Down Automata that can incorporate any other Push Down Automata and add on a part to the beginning, middle, or end of the PDA and still be able to accept the language accepted by the original CFL, with the new operation on it.  Basically, if for any given PDA P, if a PDA P\' can be created which accepts the language of P with the new operation (in our case, the "+" operator) performed on it, then that operation must be under closure.  </p>\n\n<p>Solving the problem in this manner is quite simple to think about.  Imagine a PDA P which accepts strings from the CFL L.  In application to our problem, this would be a PDA which can successfully read in the string \'xz\', where x and z are simply any string conforming to our alphabet.  The PDA P\' would similarly have the ability to read xz, but each state of the PDA could have an additional self loop which reads the character in the string y.</p></li>\n</ol>\n\n<p>I have selected the answer which I find to be most appropriate for this question.  It simply involves using the "tempate PDA" strategy which I outline above; however, my construction did not achieve the goals of the new language (think about why before looking at the answer below).</p>\n', 'ClosedDate': '2014-03-20T11:52:14.493', 'Tags': '<formal-languages><context-free><closure-properties>', 'LastEditorUserId': '14596', 'LastActivityDate': '2014-03-20T15:55:52.117', 'CommentCount': '5', 'AcceptedAnswerId': '22844', 'CreationDate': '2014-03-20T00:24:22.407', 'Id': '22834'}{'Body': '<p>Given a language $L\\subseteq \\Sigma^*$ in $P$, is the language</p>\n\n<p>$subwords(L) = \\{v\\in\\Sigma^* : \\text{there exist } u,w\\in \\Sigma^* \\text{ with } uvw\\in L\\}$  </p>\n\n<p>that consists of all subwords of words in $L$ also guaranteed to lie in $P$?</p>\n', 'ViewCount': '29', 'ClosedDate': '2014-03-21T21:13:56.350', 'Title': 'Is P closed under subwords?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-21T21:13:15.440', 'LastEditDate': '2014-03-21T21:13:15.440', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15970', 'Tags': '<complexity-theory><closure-properties><polynomial-time>', 'CreationDate': '2014-03-21T12:41:15.233', 'Id': '22902'}{'Body': "<p>The question is simple: </p>\n\n<blockquote>\n  <p>$\\qquad \\operatorname{DropMiddle}(L)=\\{xy\\in\\Sigma^* \\mid |x|=|y| \\land \\exists a\\in\\Sigma\\colon xay\\in L\\}$. </p>\n  \n  <p>Prove that CFL's aren't closed under $\\operatorname{DropMiddle}$.</p>\n</blockquote>\n\n<p>I should probably be looking for a counter example, but I'm coming up short. I know that the language $ww$ ($w$ is a word in some CFL) isn't a CFL, but I can't figure out if I'm on the right track at all.</p>\n", 'ViewCount': '106', 'Title': "Prove that context free languages aren't closed under DropMiddle", 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-21T22:36:11.570', 'LastEditDate': '2014-03-21T22:16:58.467', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22915', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15977', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-03-21T15:33:06.103', 'Id': '22905'}{'ViewCount': '59', 'Title': 'If $L_1$ is regular and $L_1 \\cap L_2$ context-free, is $L_2$ always context-free?', 'LastEditDate': '2014-03-24T11:49:13.320', 'AnswerCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>If $L_1$ is a regular language and $L_1 \\cap L_2$ is a context-free language, does it mean that $L_2$ is a context-free language too?</p>\n\n<p>I attempted to prove that $L_2$ was not required to be context-free by the following: If $L_1 = \\{ a^n \\}$ and $L_2 = \\{ a^nb^nc^n \\} $ then $L_1 \\cap L_2 = \\{ a^n \\}$ which is context-free. </p>\n\n<p>Is this a counterexample to show that $L_2$ is not required to be context-free? If not, then do you have any suggestions?</p>\n', 'ClosedDate': '2014-03-25T18:31:23.090', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'LastEditorUserId': '31', 'LastActivityDate': '2014-03-24T11:49:13.320', 'CommentCount': '3', 'CreationDate': '2014-03-24T09:23:43.800', 'Id': '22991'}{'Body': "<p>Is there a way to take the interection of two NPDAs?</p>\n\n<p>I can't seem to find anything that can make that happen, but it seems like the type of thing that is should be relatively trival.</p>\n", 'ViewCount': '54', 'Title': 'Intersection of two NPDAs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T13:43:12.540', 'LastEditDate': '2014-03-26T08:50:40.920', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23057', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '863', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-26T02:34:19.813', 'Id': '23056'}{'Body': '<p>Every proof I can find of this result is by way of regular expressions. Is there any "constructive" proof that defines the corresponding DFA (probably NFA)? For instance the proof of concatenation closure is most often presented by demonstrating the NFA. I\'m just curious whether this is out there somewhere</p>\n', 'ViewCount': '162', 'Title': 'Does there exist a proof of closure of regular languages under regular substitution by giving the corresponding DFA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-10T06:27:44.253', 'LastEditDate': '2014-03-31T08:21:05.427', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '23623', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><reference-request><finite-automata><closure-properties>', 'CreationDate': '2014-03-30T17:15:21.897', 'Id': '23265'}{'Body': '<p>Let $P$ be a deterministic PDA recognizing a deterministic CFL with a binary alphabet. Modify $P$ to identify its <em>reading states</em> (denote this subset of states by $R$) in accordance with the construction in Theorem 2.42 in Sipser (3$^{rd}$ edition only) for complementing DPDA. The final states of $P$ are $F\\subset R$, and $\\overline{P}$ recognizing the complement language is given by the same DPDA, but with final states $R-F$. </p>\n\n<p>Combine this with the construction in Lemma 2.59 showing that every DPDA recognizing an end-marked language has an equivalent DCFG. Modify $P$ to have a new accept state $q_\\mbox{accept}$. If $P$ enters a state in $F$ after reading the endmarker, it empties its stack and goes to $q_\\mbox{accept}$. Now do the same with $R-F$ and a new sink state $q_\\mbox{reject}$. </p>\n\n<p>In the grammar $G$ we have a start variable $A_{q_0q_\\mbox{accept}}$ which generates every string that takes $P$ from $q_0$ to $q_\\mbox{accept}$ with empty stack. Let $\\overline{G}$ be a copy of $G$, without renaming the variables, but replace the start state with $A_{q_0q_\\mbox{reject}}$. Then these grammars are both deterministic, and generate complement languages with respect to the portion of the string preceding the endmarker.</p>\n\n<p>Why do this? I think we can show DCFLs with binary alphabets are closed under substitution with an endmarked language and its complement using such a grammar. I think this is not in general the case as otherwise the resulting grammar with substitutions may have a forced handle in the production rules of both substituted grammars. Consider for example the language $\\{w\\mid w\\in\\{0,1\\}^*,\\#_0(w)=\\#_1(w)\\}$. Every string in this language can be extended to one in the complement and vice versa, so there must be strings for which both grammars would be able to match a handle based on just some initial portion of the string. Using the grammar construction described above, there will never be more than one forced handle, and every string will resolve to one of the start symbols. </p>\n\n<p>If this is a legitimate way to construct the complementary grammars, the very restricted closure result follows easily from the determinism of the grammars involved. Can anyone poke some holes in this?   </p>\n', 'ViewCount': '35', 'Title': 'A construction to show a very restricted substitution closure result for DCFLs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T07:42:25.793', 'LastEditDate': '2014-04-01T07:42:25.793', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-31T08:17:43.793', 'Id': '23288'}{'ViewCount': '385', 'Title': 'how to draw a complement of a Turing Machine?', 'LastEditDate': '2014-04-03T06:35:15.050', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '14495', 'FavoriteCount': '1', 'Body': '<p>I am now pretty confident on how I would turn something into a Turing Machine. Now my question is how do you convert TM into a complement of a Turing Machine. From what I can remember in Finite Automata, complementing it you would just turn a start state into a ending state, also if you have an ending state you would make it into a start state..How would you do complement of a Turing Machine ? </p>\n\n<p>For example here I have a simple TM of a Palindrome and I want a Palindrome\'</p>\n\n<p><img src="http://i.stack.imgur.com/x3TEH.png" alt="enter image description here"></p>\n', 'Tags': '<turing-machines><automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-03T17:05:24.023', 'CommentCount': '5', 'AcceptedAnswerId': '23378', 'CreationDate': '2014-04-02T23:50:40.633', 'Id': '23375'}{'Body': "<p>Is the class $\\sf NP$ closed under complement or is it unknown? I have looked online, but I couldn't find anything. </p>\n", 'ViewCount': '55', 'Title': 'Is the class NP closed under complement?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-30T17:43:47.400', 'LastEditDate': '2014-04-30T17:17:57.027', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '24265', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Tags': '<complexity-theory><closure-properties><complexity-classes><np>', 'CreationDate': '2014-04-30T16:23:40.070', 'Id': '24261'}{'Body': "<p>I have tried looking online, but I couldn't find any definitive statements. It would make sense to me that Union and Intersection of two NPC languages would produce a language not necessarily in NPC. Is it also true that NPC languages are not closed under the complement, concatenation, and kleene star operations?</p>\n", 'ViewCount': '78', 'Title': 'are NP Complete languages closed under any regular operations?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-30T22:26:53.000', 'LastEditDate': '2014-04-30T17:19:07.863', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '24271', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Tags': '<complexity-theory><np-complete><closure-properties>', 'CreationDate': '2014-04-30T16:34:39.267', 'Id': '24264'}