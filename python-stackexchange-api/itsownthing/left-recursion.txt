{'ViewCount': '3538', 'Title': 'Left recursion and left factoring -- which one goes first?', 'LastEditDate': '2014-01-23T17:17:37.047', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '2', 'Body': '<p>if I have a grammar having a production that contains both left recursion and left factoring like </p>\n\n<p>$\\qquad \\displaystyle F \\to FBa \\mid cDS \\mid c$ </p>\n\n<p>which one has priority, left recursion or left factoring?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:37.047', 'CommentCount': '3', 'AcceptedAnswerId': '2720', 'CreationDate': '2012-07-11T16:32:10.717', 'Id': '2696'}{'ViewCount': '1273', 'Title': 'Removing Left Recursion from Context-Free Grammars - Ordering of nonterminals', 'LastEditDate': '2014-01-23T17:17:28.390', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'clebert', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': u'<p>I have recently implemented the Paull\'s algorithm for removing left-recursion from context-free grammars:</p>\n\n<blockquote>\n  <p>Assign an ordering $A_1, \\dots, A_n$ to the nonterminals of the grammar.</p>\n  \n  <p>for $i := 1$ to $n$ do begin<br>\n  $\\quad$ for $j:=1$ to $i-1$ do begin<br>\n  $\\quad\\quad$ for each production of the form $A_i \\to A_j\\alpha$ do begin<br>\n  $\\quad\\quad\\quad$ remove $A_i \\to A_j\\alpha$ from the grammar<br>\n  $\\quad\\quad\\quad$ for each production of the form $A_j \\to \\beta$ do begin<br>\n  $\\quad\\quad\\quad\\quad$ add $A_i \\to \\beta\\alpha$ to the grammar<br>\n  $\\quad\\quad\\quad$ end<br>\n  $\\quad\\quad$ end<br>\n  $\\quad$ end<br>\n  $\\quad$ transform the $A_i$-productions to eliminate direct left recursion<br>\n  end</p>\n</blockquote>\n\n<p>According to <a href="http://research.microsoft.com/pubs/68869/naacl2k-proc-rev.pdf" rel="nofollow" title="Removing Left Recursion from Context-Free Grammars">this document</a>, the efficiency of the algorithm crucially depends on the ordering of the nonterminals chosen in the beginning; the paper discusses this issue in detail and suggest optimisations.</p>\n\n<p>Some notation:</p>\n\n<blockquote>\n  <p>We will say that a symbol $X$ is a <em>direct left corner</em> of\n  a nonterminal $A$, if there is an $A$-production with $X$ as the left-most symbol on the right-hand side. We define the <em>left-corner relation</em> to be the reflexive transitive closure of the direct-left-corner relation, and we define the <em>proper-left-corner relation</em> to be the transitive closure of\n  the direct-left-corner relation. A nonterminal is <em>left recursive</em> if it is a proper left corner of itself; a nonterminal is <em>directly left recursive</em> if it is a direct left corner of itself; and a nonterminal is <em>indirectly left recursive</em> if it is left recursive, but not directly left recursive.</p>\n</blockquote>\n\n<p>Here is what the authors propose:</p>\n\n<blockquote>\n  <p>In the inner loop of Paull\u2019s algorithm, for nonterminals $A_i$ and $A_j$, such that $i &gt; j$ and $A_j$ is a direct left corner of $A_i$, we replace all occurrences of $A_j$ as a direct left corner of $A_i$ with all possible expansions of $A_j$.</p>\n  \n  <p>This only contributes to elimination of left recursion from the grammar if $A_i$ is a left-recursive nonterminal, and $A_j$ lies on a path that makes $A_i$ left recursive; that is, if $A_i$ is a left corner of $A_j$ (in addition to $A_j$ being a left corner of $A_i$).</p>\n  \n  <p>We could eliminate replacements that are useless in removing left recursion if we could order the nonterminals of the grammar so that, if $i &gt; j$ and $A_j$ is a direct left corner of $A_i$, then $A_i$ is also a left corner of $A_j$.</p>\n  \n  <p>We can achieve this by ordering the nonterminals in decreasing order of the number of distinct left corners they have.</p>\n  \n  <p>Since the left-corner relation is transitive, if C is a direct left corner of B, every left corner of C is also a left corner of B.</p>\n  \n  <p>In addition, since we defined the left-corner relation to be reflexive, B is a left corner of itself.</p>\n  \n  <p>Hence, if C is a direct left corner of B, it must follow B in decreasing order of number of distinct left corners, unless B is a left corner of C.</p>\n</blockquote>\n\n<p>All I want is to know how to order the nonterminals in the beginning, but I don\'t get it from the paper. Can someone explain it in a simpler way? Pseudocode would help me to understand it better.</p>\n', 'Tags': '<algorithms><context-free><formal-grammars><efficiency><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:28.390', 'CommentCount': '0', 'AcceptedAnswerId': '2793', 'CreationDate': '2012-05-23T12:50:45.647', 'Id': '2792'}{'Body': '<p>In the article <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm" rel="nofollow">Parsing Expressions by Recursive Descent by Theodore Norvell (1999)</a> the author starts with the following grammar for arithmetic expressions:</p>\n\n<pre><code>E --&gt; E "+" E | E "-" E | "-" E | E "*" E | E "/" E | E "^" E | "(" E ")" | v\n</code></pre>\n\n<p>which is quite bad, because it\'s ambiguous and left-recursive. So he starts from removing the left recursion from it, and his result is as such:</p>\n\n<pre><code>E --&gt; P {B P}\nP --&gt; v | "(" E ")" | U P\nB --&gt; "+" | "-" | "*" | "/" | "^"\nU --&gt; "-"\n</code></pre>\n\n<p>But I can\'t figure out how did he get to this result. When I try to remove the left recursion myself, I\'m doing it the following way:</p>\n\n<ol>\n<li><p>Firs, I group together the productions which doesn\'t have left recursion in one group, and other (left-recursive) in another group:</p>\n\n<pre><code>E --> E "+" E | E "-" E | E "*" E | E "/" E | E "^" E     // L-recursive\nE --> v | "(" E ")" | "-" E</code></pre></li>\n<li><p>Next, I name them and factor for easier manipulations:</p>\n\n<pre><code>E --> E B E  // L-recursive; B stands for "Binary operator"\nE --> P  // not L-recursive; P stands for "Primary Expression"\nP --> v | "(" E ")" | U E   // U stands for "Unary operator"\nB --> "+" | "-" | "*" | "/" | "^"\nP --> "-"</code></pre>\n\n<p>Now I need to deal only with the first two productions, which are now easier to deal with.</p></li>\n<li><p>I rewrite those first two productions by starting from the non-L-recursive production (which is simply <code>P</code>, the Primary expression) and following it by the optional Tail <code>T</code>, which I define as the rest of the original production less the first left-recursive nonterminal (that is, just <code>B E</code>) followed by the Tail <code>T</code>, <strong>or</strong> which could be empty:</p>\n\n<pre><code>E --> P T\nT --> B E T |</code></pre>\n\n<p>(note the empty alternative for the tail).</p></li>\n<li><p>These two productions I can now rewrite in EBNF like this:</p>\n\n<pre><code>E --> P {B E}</code></pre>\n\n<p>which is nearly what the author get, but I have <code>E</code> instead of <code>P</code> there inside the zero-or-more repetition pattern (the Tail). The other productions I get quite the same as he have got:</p>\n\n<p><pre><code>P --> v | "(" E ")" | U E\nB -> "+" | "-" | "*" | "/" | "^"\nU -> "-"</pre></code></p>\n\n<p>but here too I have <code>E</code> instead of <code>P</code> in the first production for <code>P</code>.</p></li>\n</ol>\n\n<p>So, my question is: What am I missing? What algebraic transformation on the syntax I need to proceed now to get the same exact form as the autor gets? I tried substitutions for <code>E</code>, but it only leads me into loops. I suspect that I need somehow to substitute <code>P</code> for <code>E</code>, but I don\'t know any legal transformation to justify it. Maybe you know what\'s the last missing step?</p>\n', 'ViewCount': '343', 'Title': 'Arithmetic expressions grammar transformation', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:22:47.697', 'LastEditDate': '2014-01-23T17:22:47.697', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'SasQ', 'PostTypeId': '1', 'OwnerUserId': '2381', 'Tags': '<formal-languages><context-free><formal-grammars><left-recursion>', 'CreationDate': '2012-08-05T20:59:01.593', 'Id': '3053'}{'Body': "<p>I have been taking a compiler course of Stanford on coursera. I have a slight misunderstanding on the parsing table of the following grammar:</p>\n\n<p>S -> Sa | b</p>\n\n<p>According to the professor parsing table looks like this:</p>\n\n<ul>\n<li><p>If the leftmost nonterminal is S and the input is 'a', the production is nothing.</p></li>\n<li><p>If the leftmost nonterminal is S and the input is 'b', the production is both <code>Sa</code> and <code>b</code>.</p></li>\n</ul>\n\n<p>So if input is just <code>b</code>, then it is correct, it will go directly to production <code>b</code>.\nBut how will it go to production <code>Sa</code> for input <code>b</code>?</p>\n", 'ViewCount': '321', 'Title': 'LL(1) parsing table of left-recursive grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:11.390', 'LastEditDate': '2014-01-23T17:17:11.390', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Batman', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing><left-recursion>', 'CreationDate': '2012-08-14T07:11:18.640', 'Id': '3173'}{'Body': u"<p>I have a homework assignment where I need to convert a grammar into LL(1). I've already removed the left recursion, but I'm having trouble doing left-factoring. All of the examples I've found are simple, and look something like this:</p>\n\n<p><code>A -&gt; aX | aY</code><br>\nbecomes:<br>\n<code>A -&gt; aZ</code><br>\n<code>Z -&gt; X | Y</code></p>\n\n<p>I understand that. However, my grammar looks more like this:</p>\n\n<pre><code>X -&gt; aE | IXE | (X)E\nE -&gt; IE | BXE | \u03f5\nI -&gt; ++ | --\nB -&gt; + | - | \u03f5\n</code></pre>\n\n<p>I'm not sure how to apply the simpler example to this. I've been trying for at least a couple of hours and I've lost track of all of the things I've tried. Generally, my attempts have looked something like this:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nE  -&gt; IE | BIX'E | BX'E | \u03f5\n</code></pre>\n\n<p>And I then try to convert the E rules into ones having only one production starting with + or -:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; IE | B'IX'E | IX'E | B'X'E | X'E | \u03f5\n</code></pre>\n\n<p>And then...</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; +P | -M | \u03f5\nP  -&gt; +E | IX'E | +X'E | X'E\nM  -&gt; -E | IX'E | -X'E | X'E\n</code></pre>\n\n<p>And so on. But I continually end up with a lot of extra nonterminals, and some very long productions / chains of productions, without actually having left-factored it. I'm not sure how to approach this - I can't seem to eliminate <i>some</i> nonterminal having multiple productions starting with a + and with a -.</p>\n", 'ViewCount': '2109', 'Title': 'Left-Factoring a grammar into LL(1)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:21:31.690', 'LastEditDate': '2014-01-23T17:21:31.690', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '4873', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3049', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-10-03T19:44:14.687', 'Id': '4862'}{'Body': '<p>Is there any algorithm that tells us how to modify semantic actions associated with a left-recursive grammar? For example, we have the following grammar, and its associated semantic actions:</p>\n\n<p>$ S \\rightarrow id = expr $  { S.s = expr.size }</p>\n\n<p>S $\\rightarrow$ if expr then $S_1$ else $S_2$ { $S_1.t = S.t + 2; $\n$S_2.t = S.t + 2;$ $S.s = expr.size + S_1.size + S_2.size + 2;$ }</p>\n\n<p>S $\\rightarrow$ while expr do $S_1$ { $S_1.t = S.t + 4;$ $S.s = expr.size + S_1.s + 1;$ }</p>\n\n<p>S $\\rightarrow$ $S_1$ ; $S_2$  {$S_1.t = S_2.t = S.t;$ $S.s = S_1.s + S_2.s; $ }</p>\n\n<p>Clearly the non-recursive version of the grammer is:</p>\n\n<p>S $\\rightarrow$ id = expr T </p>\n\n<p>S $\\rightarrow$ if expr then $S_1$ else $S_2$ T</p>\n\n<p>S $\\rightarrow$ while expr do $S_1$ T</p>\n\n<p>T $\\rightarrow$ ; $S_2$ T</p>\n\n<p>T $\\rightarrow$ $\\epsilon$</p>\n\n<p>But we also need to change the semantic actions accordingly. Any ideas how this can be done?</p>\n', 'ViewCount': '78', 'Title': 'How to modify semantic actions when removing left-recursion from a grammer', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:48.393', 'LastEditDate': '2014-01-23T17:17:48.393', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7739', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2596', 'Tags': '<formal-grammars><compilers><semantics><left-recursion>', 'CreationDate': '2012-11-10T16:11:44.337', 'Id': '6604'}{'Body': u"<p>Why LL(k) and LL(\u221e) are incompatible with left-recursion? I understand that a LL(k) language can support left-recursivity provided that with k-overahead tokens can be resolved any ambiguity. But, with a LL(\u221e) grammar, which type of ambiguities can't be solved?</p>\n", 'ViewCount': '101', 'Title': 'LL grammars and left-recursiviity', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:19:48.497', 'LastEditDate': '2014-01-23T17:19:48.497', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6824', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4675', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-11-21T11:41:00.150', 'Id': '6809'}{'Body': '<p>In compiler design, why should left recursion be eliminated in grammars? I am reading that it is because it can cause an infinite recursion, but is it not true for a right recursive grammar as well?</p>\n', 'ViewCount': '1414', 'Title': 'Why is left recursion bad?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T02:23:37.270', 'LastEditDate': '2014-01-23T17:17:55.627', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'OwnerDisplayName': 'user56833', 'PostTypeId': '1', 'Tags': '<formal-grammars><compilers><left-recursion>', 'CreationDate': '2013-02-20T10:06:01.963', 'Id': '9963'}{'Body': '<p>i am new to compiler design, currently studying Ullmans book on this.He says:</p>\n\n<p>Problem with predictive parsing (both recursive and non recursive) is that Left recursive productions can go infinite loop.Thus, to make grammar suitable for predictive parsing we need to eliminate the left recursion by immediately or indirectly.</p>\n\n<pre><code> E -&gt; E+T|t\n</code></pre>\n\n<p>My problem is, same can happen with right recursion also.What is the solution for it?</p>\n\n<pre><code> T -&gt; E+T|t\n</code></pre>\n\n<p>Please correct me if i am wrong! thanks.</p>\n', 'ViewCount': '52', 'Title': 'Need solution for infinite right recursive grammar in Predictive parsing?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T19:25:29.983', 'LastEditDate': '2014-04-12T17:48:36.483', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10564', 'Tags': '<formal-grammars><parsing><left-recursion>', 'CreationDate': '2014-01-11T12:16:06.933', 'Id': '19654'}{'Body': "<p>I'm following the algorithm for left recursion elimination from a grammar. It says remove the epsilon production if there is any.</p>\n\n<p>I have the grammar</p>\n\n<p>$\\qquad S \\to Aa \\mid b$<br>\n$\\qquad A \\to Ac \\mid Sd \\mid \\varepsilon$</p>\n\n<p>I can see after removing the epsilon productions the grammer becomes</p>\n\n<p>$\\qquad S \\to Aa \\mid a \\mid b$<br>\n$\\qquad A \\to Ac \\mid Sd \\mid c \\mid d$ </p>\n\n<p>I'm confused where the $a \\mid b$ for $S$ and $c \\mid d$ for $A$ come from.\nCan someone explain this?</p>\n", 'ViewCount': '38', 'Title': 'Eliminating $\\varepsilon$-productions during elimination of left recursion', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T20:51:58.290', 'LastEditDate': '2014-01-23T17:14:14.097', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<context-free><formal-grammars><compilers><left-recursion>', 'CreationDate': '2014-01-23T15:28:15.480', 'Id': '19913'}{'Body': "<p>I have this grammar and I have to remove direct left recursion and common prefixes. This is the grammar:</p>\n\n<p>$\\qquad\\displaystyle S \\to SSA  \\mid SSB   \\mid SSC   \\mid AS   \\mid A$</p>\n\n<p>this is what I did:</p>\n\n<p>Removing common prefixes: (I think that in English you call this left factoring, right?)</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to SSS' \\mid AS'' \\\\\n  S' &amp;\\to A \\mid B \\mid C  \\\\  \n  S'' &amp;\\to S \\mid E \n\\end{align*}$</p>\n\n<p>Removing direct left recursion:</p>\n\n<p>$\\qquad\\begin{align*}\n S &amp;\\to AS''S'''   \\\\\n S''' &amp;\\to S'''S'S''' \\mid E  \\\\\n S''' &amp;\\to S'''' \\\\\n S'''' &amp;\\to E \\mid S'S'''S''''\n\\end{align*}$</p>\n\n<p>Is this correct?</p>\n\n<p>My doubts are specifically about the removing of the direct left recursion. If I have for example:</p>\n\n<p>$\\qquad\\displaystyle S \\to SSa \\mid b$</p>\n\n<p>and I apply the formula to remove direct left recursion, which of the two solutions is the correct one?</p>\n\n<p>This:</p>\n\n<p>$\\qquad\\begin{align*} \n S &amp;\\to bS' \\\\\n S' &amp;\\to S'aS'\n\\end{align*}$</p>\n\n<p>or this:</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to bS' \\\\\n  S' &amp;\\to SaS'\n\\end{align*} \\qquad$?</p>\n", 'ViewCount': '65', 'Title': 'Remove direct left recursion and common prefixes', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T09:21:14.103', 'LastEditDate': '2014-02-07T09:21:14.103', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14463', 'Tags': '<formal-grammars><left-recursion>', 'CreationDate': '2014-02-07T05:17:35.727', 'Id': '21421'}{'Body': '<p>I was trying to rule out whether this was LL(1) by checking for left-recursion in the following grammar:</p>\n\n<p>$\\qquad  A \\to 0 A 1 \\mid 0 1$</p>\n\n<p>Which produces:</p>\n\n<p>$\\qquad 0 A 1 \\Rightarrow 0 0 A 1 1 \\Rightarrow \\dots$</p>\n\n<p>But I am unsure what type of recursion this is called, since it sorta stays in the middle.</p>\n\n<p>If this is not left-recursive, would you agree that this is not LL(1) because non-terminal A has 0 appear twice in FIRST(A)?</p>\n', 'ViewCount': '51', 'Title': 'What type of recursion is this?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T00:04:23.193', 'LastEditDate': '2014-02-18T08:18:31.617', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21756', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2014-02-18T06:31:22.527', 'Id': '21753'}{'ViewCount': '32', 'Title': 'Left recursion for LL(1)', 'LastEditDate': '2014-03-28T01:43:23.957', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15655', 'Body': u'<p>Hi I am trying to solve a LL(1) form question for first n follow rule The question is</p>\n\n<pre><code>A::=BC|C\nB::=Bd|ef\nC::=gh|j\n</code></pre>\n\n<p>What I have done to eliminate left recursion </p>\n\n<pre><code>A::=CA\u2019\nA\u2019::=CB\u2019\nA\u2019::=\u03f5\nB::=efB\u2019\nB::=dB\u2019\nB\u2019::=\u03f5\nC::=gh\nC::= j\n</code></pre>\n\n<p>Is it correct?</p>\n\n<p>Thanks guys, it has been solved.</p>\n', 'ClosedDate': '2014-03-27T07:54:49.217', 'Tags': '<formal-languages><parsing><left-recursion>', 'LastEditorUserId': '15655', 'LastActivityDate': '2014-03-28T01:43:23.957', 'CommentCount': '1', 'AcceptedAnswerId': '22595', 'CreationDate': '2014-03-13T18:07:01.433', 'Id': '22594'}{'Body': "<p>For example,</p>\n\n<p>Let the Grammar be:</p>\n\n<pre><code>S-&gt;Sa|B\n</code></pre>\n\n<p>Thus, <code>S-&gt;Sa-&gt;Saa-&gt;...-&gt;Saa...aaa-&gt;Baa...aaa</code></p>\n\n<p>What's wrong with this?</p>\n\n<p>Why is right recursion a solution to the problem?</p>\n\n<pre><code>S-&gt;BS'\nS-&gt;aS'|e\n</code></pre>\n", 'ViewCount': '35', 'ClosedDate': '2014-03-29T11:54:23.990', 'Title': 'Why does left recursion have to be eliminated?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T11:54:13.160', 'LastEditDate': '2014-03-29T11:54:13.160', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11684', 'Tags': '<context-free><formal-grammars><compilers><parsing><left-recursion>', 'CreationDate': '2014-03-29T05:06:57.450', 'Id': '23210'}