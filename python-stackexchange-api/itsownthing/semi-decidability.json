{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Consider these 2 languages:</p>\n\n<ul>\n<li><blockquote>\n  <p>$L_{\\ge5} = \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts at least 5 strings} \\right\\} $</p>\n</blockquote></li>\n<li><blockquote>\n  <p>$L_{&lt;5} =  \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts fewer than 5 strings} \\right\\}$</p>\n</blockquote></li>\n</ul>\n\n<p>Are these recursive, R.E., or not R.E. sets (languages)?</p>\n\n<p>I would say that they are not recursive, based on applications of Rice\'s Theorem.</p>\n\n<ul>\n<li><p>For the first case $L_{e}= \\left \\{ \\left&lt; M \\right&gt; :L(M)= \\emptyset \\right \\} \\notin L_{\\ge5} $ and $L_{\\ge5}$ are not empty. For example, I define $L= \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts all palindromes} \\right \\}$, which is not finite set and accepts an infinite number of strings.</p></li>\n<li><p>For the second case I would do the same thing. I have $L_{e}=\\left\\{ \\left&lt; M \\right&gt;: L(M)= \\emptyset \\right\\} \\in L_{&lt;5}$ and $L=\\left\\{ \\left&lt; M \\right&gt;:M \\text{ accepts all palindromes} \\right\\} \\notin L_{&lt;5} $</p></li>\n</ul>\n\n<p>So I would say that both are not recursive. Is my reasoning correct?</p>\n\n<p>Now about the R.E. of the languages I don\'t have an idea of how I can prove it, this should be the beginning (if L is not RE it can\'t be recursive), how can I check if they are RE or not?</p>\n\n<p>From the definition: "$L$ is RE $\\iff$ there exists a TM $M$ that accepts $L$", so I just have to define a TM that accepts each language?</p>\n', 'ViewCount': '224', 'Title': 'Show that a language is RE or recursive', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:21:03.943', 'LastEditDate': '2014-01-18T20:21:03.943', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17891', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<computability><undecidability><semi-decidability>', 'CreationDate': '2013-11-10T22:17:09.953', 'Id': '17889'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>As far as I understand, a <code>semi-decidable (recursively enumerable)</code> problem could be: </p>\n\n<blockquote>\n  <ol>\n  <li>decidable (recursive) or </li>\n  <li>undecidable (nonrecursively enumerable)</li>\n  </ol>\n</blockquote>\n\n<p>This <a href="http://stackoverflow.com/questions/9453916/why-arent-recursively-enumerable-languages-undecidable">post</a> made me wonder if this is not conventionally followed. <a href="http://stackoverflow.com/questions/9453916/why-arent-recursively-enumerable-languages-undecidable/21056763#21056763">This</a> is my answer to it and as far as I understand it is correct:</p>\n\n<blockquote>\n  <p>A semidecidable problem (or equivalently a recursively enumerable\n  problem) could be:</p>\n  \n  <p>Decidable: If the problem and its complement are both semidecidable\n  (or recursively enumerable), then the problem is decidable\n  (recursive).</p>\n  \n  <p>Undecidable: If the problem is semidecidable and its complement is not\n  semidecidable (that is, is not recursively enumerable).</p>\n  \n  <p>Important note: Remember that a decidable (recursive) problem is also\n  semidecidable (recursively enumerable). Conversely, if a problem is\n  not recursively enumerable (semidecidable), then is not recursive\n  (decidable).</p>\n  \n  <p>What the Wikipedia entry says is that:</p>\n  \n  <p>Partially decidable problems THAT ARE NOT DECIDABLE are called\n  undecidable.</p>\n  \n  <p>In general, a semidecidable problem (recursively enumerable) could be\n  decidable (recursive) or undecidable (nonrecursively enumerable).</p>\n  \n  <p>Also note that a problem and its complement could both (or just one of\n  them) be not even semi-decidable (nonrecursively enumerable). Also\n  note that, if a problem is recursive, its complement is also\n  recursive.</p>\n</blockquote>\n\n<p>Is it conventionally (always) understood this way? Is there some literature that presents semi-decidability (partially decidable, recursively enumerable) problem as an equivalent of undecidability?</p>\n', 'ViewCount': '104', 'Title': 'Can a semi-decidable problem be also decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:44.787', 'LastEditDate': '2014-01-18T20:20:44.787', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19642', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<terminology><computability><undecidability><semi-decidability>', 'CreationDate': '2014-01-11T00:45:42.170', 'Id': '19641'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given is the definition of a general problem: $\\{ \\langle M,  S\\rangle \\mid M \\text{ is a } TM, L_M \\in S\\}$. In words: Given a TM M, does M decide a language that is an element of the given set of languages S?</p>\n\n<p>I'm stuck with the following instance of that problem: $L = \\{ \\langle M \\rangle \\mid M \\text{ is a } TM, L_M \\in \\mathrm{REG}\\}$. I have found proof that it is undecidable, however I'm stuck at finding if it's recognizable (synonyms: Turing-acceptable, semidecidable, ...) or not.</p>\n\n<p>The problem in words means: Given a TM M, does the TM decide a language that is an element of REG (the set of regular languages)?</p>\n\n<p>To prove a language is not semi-decidable, I would try to prove that it's complement is semi-decidable and that the language is not decidable (which I did by reduction from the Halting-problem).</p>\n\n<p>To prove it is semi-decidable, I would prove it by reduction to the $A_{TM}$, which is semi-decidable.</p>\n\n<p>I have tried both for this problem, but I get stuck / lose my way of thinking at every try ... Some directions would be greatly appreciated!</p>\n", 'ViewCount': '134', 'Title': 'Is regularity of the language accepted by a given Turing machine a semi-decidable property?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:22.317', 'LastEditDate': '2014-01-18T20:20:22.317', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<formal-languages><computability><turing-machines><semi-decidability>', 'CreationDate': '2014-01-16T18:10:49.223', 'Id': '19769'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've been working on the following exercise:</p>\n\n<blockquote>\n  <p>$S = \\{ x | f_x  \\text{ is constant} \\}$. Is $S$ recursively enumerable?</p>\n</blockquote>\n\n<p>Here, $fx$ is the function computed by the $\\text{x-th TM}$. So it is a computable function.</p>\n\n<hr>\n\n<p><strong>Intuitively</strong>, I think that to check if $S$ is constant, I would have to check if $f_x$ stops for every input. That procedure would run forever. </p>\n\n<p><strong>Important:</strong> Same thing about $\\overline{S}$, if some $f_x$ is undefined for every input $y$ (it would not be constant, as far as I understand, <strong>it is constant if it has the same image for all input values</strong>) then I would not be able to list $f_x$ in an enumeration of $\\overline{S}$.</p>\n\n<p>In fact, suppose $\\forall x,fx$ is undefined. This $f_x$ is computable - a TM can be constructed that loops forever. How can you determine that $f_x$ is not constant? There will be no input for which $f_x$ halts. Therefore, we cannot check for equality of $x_1$ and $x_2$ to determine that is not constant. Then, we can't list this $TM_x$ in the enumeration. </p>\n\n<p>A solution in which this $f_x$ was put at the beginning of the enumeration was suggested. But there are infinitely many $TMs$ that are undefined for all inputs. Consequently, I can't put them at the beginning of the enumeration as other $TMs$ won't be enumerated.</p>\n\n<hr>\n\n<p><strong>I tried to</strong> reduce the <em>Halting Problem</em> to this problem without success. I believe that both $S$ and $\\overline{S}$ are not r.e. (see my intuitive thoughts above).</p>\n\n<p>How would you solve this problem?</p>\n", 'ViewCount': '136', 'Title': u'Is the set of G\xf6del numbers of computable constant functions recursively enumerable?', 'LastEditorUserId': '11974', 'LastActivityDate': '2014-01-19T14:53:34.650', 'LastEditDate': '2014-01-19T14:53:34.650', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19784', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<computability><semi-decidability>', 'CreationDate': '2014-01-17T02:56:45.933', 'Id': '19776'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<blockquote>\n  <p>Let $h$ be a total computable function. Is $S = \\{x \\mid f_x \\neq h\\}$\n  recursively enumerable?</p>\n</blockquote>\n\n<p>Originally this was an exercise that restricted $h$ to: $h(x) = x + 1$ . However, it can be formulated as a more general case.</p>\n\n<p>By Rice's Theorem, it is not recursive. Intuitively, </p>\n\n<ul>\n<li><p>$S$ is not r.e. as if it was, it would mean that we would know that\n$f_x(y)$ halts for some input $y$ in order to check if it has a different image of $h(y)$.</p></li>\n<li><p>$\\overline{S}$ is not r.e. as if it was, we would be able to check if $f_x(y)\n   = h(y)$ for every input $y$ (we would check equality for infinite inputs).</p></li>\n</ul>\n\n<p>How would you solve this problem?</p>\n\n<p><strong>Note:</strong> I tried something, but I'll post it as an answer. Some thoughts would be great and really helpful. Any approach to this problem using reduction or diagonalization methods would be useful.</p>\n", 'ViewCount': '101', 'Title': 'Is the set of programs that compute some function other than $h$ recursively enumerable?', 'LastEditorUserId': '11974', 'LastActivityDate': '2014-02-12T20:54:26.437', 'LastEditDate': '2014-01-19T17:14:35.563', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<computability><reductions><semi-decidability>', 'CreationDate': '2014-01-18T20:07:54.740', 'Id': '19815'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>This is a question from an exam I did today:</p>\n\n<blockquote>\n  <p>Given $M$, a turing machine, we need to decide the following:</p>\n  \n  <p>1) $M$ halts on every input</p>\n  \n  <p>2) The language of $M$ is CFL</p>\n</blockquote>\n\n<p>My question is, can I prove that this problem is not in $RE$ (recursively enumerable) using Rice's theorem? I understand that Rice's theorem works for languages and not machines, and when first looking at it, number 1 is a property of a machine not the language. But what I said, is that actually it <em>is</em> a property of a language: $M$ halts on every input <em>iff</em> $L(M)$ is decidable! (in $R$), so we can use Rice.</p>\n\n<p>What do you think?</p>\n", 'ViewCount': '77', 'Title': "Proving that context-freeness of $L(M)$ is not semi-decidable using Rice's theorem", 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-27T17:52:40.573', 'LastEditDate': '2014-01-26T16:49:27.393', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<computability><semi-decidability>', 'CreationDate': '2014-01-26T15:32:15.463', 'Id': '19997'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '392', 'Title': 'Why is the class of recursively enumerable languages not closed under complementation?', 'LastEditDate': '2014-02-04T11:38:24.893', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9987', 'FavoriteCount': '1', 'Body': '<p>I am having a hard time understanding closure properties of recrusively enumerable languages. I have read the explanation on <a href="http://www.eecs.wsu.edu/~cook/tcs/l19.html" rel="nofollow">this site</a> but still unable to fully understand why they are not closed under complementation?</p>\n\n<p>Explanation also says,</p>\n\n<blockquote>\n  <p>This fails because $M$ only needs to halt if $w \\in L(M)$ - doesn\'t have to say "no".</p>\n</blockquote>\n\n<p>What does it mean?</p>\n', 'Tags': '<computability><closure-properties><semi-decidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T23:26:26.210', 'CommentCount': '2', 'AcceptedAnswerId': '21285', 'CreationDate': '2014-02-04T11:23:23.813', 'Id': '21284'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given some unrecognizable language $L$, is it possible for its complement $\\overline{L}$ to also be unrecognizable?</p>\n\n<p>If some other language $S$ and its complement $\\overline{S}$ are both recognizable, then $S$ and $\\overline{S}$ are decidable. If $\\overline{S}$ is unrecognizable, then then $S$ is undecidable but still recognizable. Why do we ignore the idea that $S$ and $\\overline{S}$ may both be unrecognizable? This implies that $\\exists! s \\in S \\cup \\overline{S} = \\Sigma^*$ on which no machine halts, otherwise I don't see why we cannot have $x,y \\in \\Sigma^*$ and $x \\neq y$ such that no machine halts on $x$ or $y$, where $x \\in S$ and $y \\in \\overline{S}$.</p>\n\n<p>Perhaps I am making a false assumption somewhere?</p>\n", 'ViewCount': '397', 'Title': 'Is it possible for a language and its complement to both be unrecognizable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-19T21:31:45.540', 'LastEditDate': '2014-03-19T21:31:45.540', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '22818', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<computability><semi-decidability>', 'CreationDate': '2014-03-19T17:45:45.283', 'Id': '22814'}}