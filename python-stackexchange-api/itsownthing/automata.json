22_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1377', 'Title': 'What is the significance of context-sensitive (Type 1) languages?', 'LastEditDate': '2012-03-07T16:09:28.450', 'AnswerCount': '9', 'Score': '23', 'PostTypeId': '1', 'OwnerUserId': '26', 'FavoriteCount': '1', 'Body': '<p>Seeing that in the <a href="http://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky Hierarchy</a> Type 3 languages can be recognised by a state machine with no external memory (i.e., a finite automaton), Type 2 by a state machine with a <em>single</em> stack (i.e. a push-down automaton) and Type 0 by a state machine with <em>two</em> stacks (or, equivalently, a tape, as is the case for Turing Machines), how do Type 1 languages fit into this picture? And what advantages does it bring to determine that a language is not only Type 0 but Type 1?</p>\n', 'Tags': '<formal-languages><applied-theory><computability><automata><formal-grammars>', 'LastEditorUserId': '69', 'LastActivityDate': '2012-03-08T02:30:13.020', 'CommentCount': '9', 'AcceptedAnswerId': '31', 'CreationDate': '2012-03-06T20:06:29.977', 'Id': '14'},22_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>It's a known fact that every LTL formula can be expressed by a B\xfcchi $\\omega$-automaton. But, apparently, B\xfcchi automata are a more powerful, expressive model. I've heard somewhere that B\xfcchi automata are equivalent to linear-time $\\mu$-calculus (that is, $\\mu$-calculus with usual fixpoints and only one temporal operator: $\\mathbf{X}$). </p>\n\n<p>Is there an algorithm (constructive proof) of this equality?</p>\n", 'ViewCount': '445', 'Title': u'Equivalence of B\xfcchi automata and linear $\\mu$-calculus', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-14T13:06:54.697', 'LastEditDate': '2012-07-14T13:06:54.697', 'AnswerCount': '2', 'CommentCount': '13', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '147', 'Tags': '<logic><automata><formal-methods><linear-temporal-logic><buchi-automata>', 'CreationDate': '2012-03-07T20:53:40.587', 'FavoriteCount': '4', 'Id': '108'},22_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1455', 'Title': 'Are there inherently ambiguous and deterministic context-free languages?', 'LastEditDate': '2012-03-15T11:35:41.913', 'AnswerCount': '1', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '1', 'Body': '<p>Let us call a context-free language deterministic if and only if it can be accepted by a deterministic push-down automaton, and nondeterministic otherwise.</p>\n\n<p>Let us call a context-free language inherently ambiguous if and only if all context-free grammars which generate the language are ambiguous, and unambiguous otherwise.</p>\n\n<p>An example of a deterministic, unambiguous language is the language: $$\\{a^{n}b^{n} \\in \\{a, b\\}^{*} | n \\ge 0\\}$$\nAn example of a nondeterministic, unambiguous language is the language: \n$$\\{w \\in \\{a, b\\}^{*} | w = w^{R}\\}$$</p>\n\n<p>From <a href="http://en.wikipedia.org/wiki/Ambiguous_grammar#Inherently_ambiguous_languages">Wikipedia</a>, an example of an inherently ambiguous context-free language is the following union of context-free languages, which must also be context-free: \n$$L = \\{a^{n}b^{m}c^{m}d^{n} \\in \\{a, b, c, d\\}^{*} | n, m \\ge 0\\} \\cup \\{a^{n}b^{n}c^{m}d^{m} \\in \\{a, b, c, d\\}^{*} | n, m \\ge 0\\}$$</p>\n\n<p>Now for the questions:</p>\n\n<ol>\n<li>Is it known whether there exists a deterministic, inherently ambiguous context-free language? If so, is there an (easy) example?</li>\n<li>Is it known whether there exists a nondeterministic, inherently ambiguous context-free language? If so, is there an (easy) example?</li>\n</ol>\n\n<p>Clearly, since an inherently ambiguous context-free language exists ($L$ is an example), the answer to one of these questions is easy, if it is known whether $L$ is deterministic or nondeterministic. I also assume that it\'s true that if there\'s a deterministic one, there\'s bound to be a nondeterministic one as well... but I\'ve been surprised before. References are appreciated, and apologies in advance if this is a well-known, celebrated result (in which case, I\'m completely unaware of it).</p>\n', 'Tags': '<formal-languages><automata><formal-grammars><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-15T11:35:41.913', 'CommentCount': '0', 'AcceptedAnswerId': '111', 'CreationDate': '2012-03-07T20:56:08.960', 'Id': '109'},22_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '530', 'Title': 'Determining capabilities of a min-heap (or other exotic) state machines', 'LastEditDate': '2012-04-01T14:08:05.903', 'AnswerCount': '2', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '2', 'Body': '<p><em>See the end of this post for some clarification on the definition(s) of min-heap automata.</em></p>\n\n<p>One can imagine using a variety of data structures for storing information for use by state machines. For instance, push-down automata store information in a stack, and Turing machines use a tape. State machines using queues, and ones using two multiple stacks or tapes, have been shown to be equivalent in power to Turing machines.</p>\n\n<p>Imagine a min-heap machine. It works exactly like a push-down automaton, with the following exceptions:</p>\n\n<ol>\n<li>Instead of getting to look at the last thing you added to the heap, you only get to look at the smallest element (with the ordering defined on a per-machine basis) currently on the heap.</li>\n<li>Instead of getting to remove the last thing you added to the heap, you only get to remove one of the smallest element (with the ordering defined on a per-machine basis) currently on the heap.</li>\n<li>Instead of getting to add an element to the top of the heap, you can only add an element to the heap, with its position being determined according to the other elements in the heap (with the ordering defined on a per-machine basis).</li>\n</ol>\n\n<p>This machine can accept all regular languages, simply by not using the heap. It can also accept the language $\\displaystyle \\{a^{n}b^{n} \\in \\{a, b\\}^{*} \\mid n \\ge 0\\}$ by adding $a$\'s to the heap, and removing $a$\'s from the heap when it reads $b$\'s. It can accept a variety of other context-free languages. However, it cannot accept, for instance, $\\displaystyle \\{w \\in \\{a, b\\}^{*} \\mid w = w^{R}\\}$ (stated without proof). EDIT: or can it? I don\'t think it can, but I\'ve been surprised before, and I\'m sure I\'ll keep being surprised when my assumptions to keep making of me an... well.</p>\n\n<blockquote>\n  <p>Can it accept any context-sensitive or Turing-complete languages?</p>\n</blockquote>\n\n<p>More generally, what research, if any, has been pursued in this direction? What results are there, if any? I am also interested in other varieties of exotic state machines, possibly those using other data structures for storage or various kinds of restrictions on access (e.g., how LBAs are restricted TMs). References are appreciated. I apologize in advance if this question is demonstrating ignorance.</p>\n\n<hr>\n\n<p><strong>Formal Definition:</strong></p>\n\n<p>I provide some more detailed definitions of min-heap automata here in order to clarify further discussion in questions which reference this material.</p>\n\n<p>We define a <em>type-1 nondeterministic min-heap automaton</em> as a 7-tuple $$(Q, q_0, A, \\Sigma, \\Gamma, Z_0, \\delta)$$ where...</p>\n\n<ol>\n<li>$Q$ is a finite, non-empty set of states;</li>\n<li>$q_0 \\in Q$ is the initial state;</li>\n<li>$A \\subseteq Q$ is the set of accepting states;</li>\n<li>$\\Sigma$ is a finite, non-empty input alphabet;</li>\n<li>$\\Gamma$ is a finite, non-empty input alphabet, where the weight of a symbol $\\gamma \\in \\Gamma$, $w(\\gamma) \\in \\mathbb{N}$, is such that $w(\\gamma_1) = w(\\gamma_2) \\iff \\gamma_1 = \\gamma_2$;</li>\n<li>$Z_0 \\notin \\Gamma$ is the special bottom-of-the-heap symbol;</li>\n<li>$\\delta : Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\times (\\Gamma \\cup \\{Z_0\\}) \\rightarrow \\mathcal{P}({Q \\times \\Gamma^*})$ is the transition function.</li>\n</ol>\n\n<p>The transition function works by assuming an initially empty heap consisting of only $Z_0$. The transition function may add to the heap an arbitrary collection (finite, but possibly empty or with repeats) of elements $\\gamma_1, \\gamma_2, ..., \\gamma_k \\in \\Gamma$. Alternatively, the transition function may remove an instance of the element $\\gamma$ with the lowest weight $w(\\gamma)$ of all elements remaining on the heap (i.e., the element on top of the heap). The transition function may only use the top-most (i.e., of minimal weight) symbol instance in determining any given transition.</p>\n\n<p>Further, define a <em>type-1 deterministic min-heap automaton</em> to be a type-1 nondeterministic min-heap automaton which satisfies the following property: for all strings $x{\\sigma}y \\in \\Sigma$ such that $|x| = n$ and $\\sigma \\in \\Sigma$, $|\\delta^{n+1}(q_0, x{\\sigma}y, Z_0)| \\leq 1$.</p>\n\n<p>Define also a <em>type-2 nondeterministic min-heap automaton</em> exactly the same as a type-1 nondeterministic min-heap automaton, except for the following changes:</p>\n\n<ol>\n<li>$\\Gamma$ is a finite, non-empty input alphabet, where the weight of a symbol $\\gamma \\in \\Gamma$, $w(\\gamma) \\in \\mathbb{N}$, is such that $w(\\gamma_1) = w(\\gamma_2)$ does not necessarily imply $\\gamma_1 = \\gamma_2$; in other words, different heap symbols can have the same weight.</li>\n<li>When instances of distinct heap symbols with same weight are added to the heap, their relative order is preserved according to a last-in, first-out (LIFO) stack-like ordering.</li>\n</ol>\n\n<p>Thanks to Raphael for pointing out this more natural definition, which captures (and extends) the context-free languages. </p>\n\n<hr>\n\n<p><strong>Some results demonstrated so far:</strong></p>\n\n<ol>\n<li>Type-1 min-heap automata recognize a set of languages which is neither a subset nor a superset of the context-free languages. [<a href="http://cs.stackexchange.com/a/114/98">1</a>,<a href="http://cs.stackexchange.com/a/115/98">2</a>]</li>\n<li>Type-2 min-heap automata, by their definition, recognize a set of languages which is a proper superset of the context-free languages, as well as a proper superset of the languages accepted by type-1 min-heap automata.</li>\n<li>Languages accepted by type-1 min-heap automata appear to be closed under union, concatenation, and Kleene star, but not under complementation [<a href="http://cs.stackexchange.com/a/415/98">1</a>], intersection, or difference;</li>\n<li>Languages accepted by type-1 nondeterministic min-heap automata appear to be a proper superset of languages accepted by type-1 deterministic min-heap automata.</li>\n</ol>\n\n<p>There may be a few other results I have missed. More results are (possibly) on the way.</p>\n\n<hr>\n\n<p><strong>Follow-up Questions</strong></p>\n\n<ol>\n<li><a href="http://cs.stackexchange.com/q/390/98">Closure under reversal?</a> -- Open</li>\n<li><a href="http://cs.stackexchange.com/q/393/98">Closure under complementation?</a> -- No!</li>\n<li><a href="http://cs.stackexchange.com/q/394/98">Does nondeterminism increase power?</a> -- Yes?</li>\n<li><a href="http://cs.stackexchange.com/q/933/69">Is $HAL \\subsetneq CSL$ for type-2?</a> -- Open</li>\n<li><a href="http://cs.stackexchange.com/q/934/69">Does adding heaps increase power for type-1?</a> -- $HAL^1 \\subsetneq HAL^2 = HAL^k$ for $k &gt; 2$ (?)</li>\n<li><a href="http://cs.stackexchange.com/q/944/69">Does adding a stack increase power for type-1?</a> -- Open</li>\n</ol>\n', 'Tags': '<formal-languages><automata>', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-01T14:08:05.903', 'CommentCount': '3', 'AcceptedAnswerId': '114', 'CreationDate': '2012-03-07T21:23:29.537', 'Id': '110'},22_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '649', 'Title': 'What are the conditions for a NFA for its equivalent DFA to be maximal in size?', 'LastEditDate': '2012-03-15T10:17:50.310', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '1', 'Body': "<p>We know that DFAs are equivalent to NFAs in expressiveness power; there is also a known algorithm for converting NFAs to DFAs (unfortunately I do now know the inventor of that algorithm), which in worst case gives us $2^S$ states, if our NFA had $S$ states.</p>\n\n<p>My question is: what is determining the worst case scenario?</p>\n\n<hr>\n\n<p>Here's a transcription of an algorithm in case of ambiguity:</p>\n\n<p>Let $A = (Q,\\Sigma,\\delta,q_0,F)$ be a NFA. We construct a DFA $A&#39; = (Q&#39;,\\Sigma,\\delta&#39;,q&#39;_0,F&#39;)$ where </p>\n\n<ul>\n<li>$Q&#39; = \\mathcal{P}(Q)$, </li>\n<li>$F&#39; = \\{S \\in Q&#39; | F \\cap S \\neq \\emptyset \\}$,</li>\n<li>$\\delta&#39;(S,a) =\\bigcup_{s \\in S} (\\delta(s,a) \\cup \\hat \\delta(s,\\varepsilon))$, and</li>\n<li>$q&#39;_0 = \\{q_0\\} \\cup \\hat \\delta(q_0, \\varepsilon)$,</li>\n</ul>\n\n<p>where $\\hat\\delta$ is the extended transition function of $A$.</p>\n", 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T10:45:27.090', 'CommentCount': '1', 'AcceptedAnswerId': '131', 'CreationDate': '2012-03-08T10:20:46.940', 'Id': '130'},22_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '539', 'Title': 'What are the possible sets of word lengths in a regular language?', 'LastEditDate': '2012-03-10T15:16:58.000', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Given a language $L$, define the length set of $L$ as the set of lengths of words in $L$:\n$$\\mathrm{LS}(L) = \\{|u| \\mid u \\in L \\}$$</p>\n\n<p>Which sets of integers can be the length set of a regular language?</p>\n', 'Tags': '<formal-languages><computability><regular-languages><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-10T15:16:58.000', 'CommentCount': '2', 'AcceptedAnswerId': '175', 'CreationDate': '2012-03-09T16:46:44.240', 'Id': '164'},22_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '274', 'Title': 'Is there a "natural" undecidable language?', 'LastEditDate': '2012-12-13T02:16:00.593', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '2', 'Body': '<p>Is there any "natural" language which is undecidable?</p>\n\n<p>by "natural" I mean a language defined directly by properties of strings, and not via machines and their equivalent. In other words, if the language looks like\n$$ L = \\{ \\langle M \\rangle \\mid \\ldots \\}$$\nwhere $M$ is a TM, DFA (or regular-exp), PDA (or grammar), etc.., then $L$ <strong>is not</strong> natural. However $L = \\{xy \\ldots \\mid x \\text{ is a prefix of y} \\ldots \\}$ is natural.</p>\n', 'Tags': '<formal-languages><automata><computability><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:16:00.593', 'CommentCount': '0', 'AcceptedAnswerId': '179', 'CreationDate': '2012-03-10T05:08:27.597', 'Id': '178'},22_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Let's take as an example the 3d \u2192 2d reduction: What's the cost of simulating a 3d cellular automaton by a 2d cellular automaton?</p>\n\n<p>Here is a bunch of more specific questions:</p>\n\n<ol>\n<li><p>What kind of algorithms will have their time complexity changed, by how much?</p></li>\n<li><p>What would be the basic idea for the encoding; how is a 3d grid efficiently (or not efficiently\u2026) mapped to a 2d grid? (The challenge seems to achieve communication between two cells that where originally neighbors on the 3d grid, but are not neighbors anymore on the 2d grid). </p></li>\n<li><p>In particular, I'm interested in the complexity drift for exponential complexity algorithms (which I guess remains exponential whatever the dimension, is it the case?)</p></li>\n</ol>\n\n<p>Note: I'm not interested in low complexity classes for which the chosen I/O method has an influence on complexities. (Maybe the best is to assume that the I/O method is dimensionless: done locally on one specific cell during a variable amount of time steps.) </p>\n\n<hr>\n\n<p><em>Some context: I'm interested in parallel local graph rewriting, but those graphs are closer to 3d (or maybe \u03c9d\u2026) grids than to 2d grids, I'd like to know what to expect of a hardware implementation on a 2-dimentional silicon chip.</em></p>\n", 'ViewCount': '84', 'Title': 'Influence of the dimension of cellular automata on complexity classes', 'LastEditorUserId': '31', 'LastActivityDate': '2012-03-12T20:44:04.593', 'LastEditDate': '2012-03-12T17:34:06.217', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '254', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '68', 'Tags': '<complexity-theory><time-complexity><cellular-automata>', 'CreationDate': '2012-03-12T16:49:47.177', 'Id': '245'},22_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I wonder whether the massively parallel computation units provided in graphic cards nowadays (one that is programmable in <a href="http://en.wikipedia.org/wiki/OpenCL" rel="nofollow">OpenCL</a>, for example) are good enough to simulate 1D cellular automata (or maybe 2D cellular automata?) efficiently.</p>\n\n<p>If we choose whatever finite grid would fit inside the memory of the chip, can we expect one transition of a cellular automaton defined on this grid to be computed in (quasi)constant time?</p>\n\n<p>I assume 2D cellular automata would require more bandwidth for communication between the different parts of the chips than 1D automata.</p>\n\n<p>I\'d also be interested by the same question in the case of FPGA programming or custom chips.</p>\n', 'ViewCount': '317', 'Title': "Are today's massive parallel processing units able to run cellular automata efficiently?", 'LastEditorUserId': '68', 'LastActivityDate': '2012-09-28T19:50:44.353', 'LastEditDate': '2012-09-17T14:03:09.767', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '68', 'Tags': '<computer-architecture><parallel-computing><cellular-automata>', 'CreationDate': '2012-03-12T22:02:55.090', 'FavoriteCount': '2', 'Id': '256'},22_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A deterministic finite automaton (DFA) is a state machine model capable of accepting all and only regular languages. DFAs can be (and usually are) defined in such a way that each state must provide some transition for all elements of the input alphabet; in other words, the transition function $\\delta : Q \\times \\Sigma \\rightarrow Q$ should be a (total) function.</p>\n\n<p>Imagine what we will call a doubly deterministic finite automaton (DDFA). It is defined similarly to a DFA, with two exceptions: first, instead of the transition leading from one state to one other state for every possible input symbol, it must lead to two distinct states; second, in order to accept a string, all potential paths must satisfy either one or the other of the following conditions:</p>\n\n<ol>\n<li>All potential paths through the DDFA lead to an accepting state (we will call this a type-1 DDFA).</li>\n<li>All potential paths through the DDFA lead to the same accepting state (we will call this a type-2 DDFA).</li>\n</ol>\n\n<p>Now for my question:</p>\n\n<blockquote>\n  <p>What languages do type-1 and type-2 DDFAs accept? Specifically, is it the case that $L(DFA) \\subsetneq L(DDFA)$, $L(DDFA) = L(DFA)$, or $L(DDFA) \\subsetneq L(DFA)$? In the case that $L(DDFA) \\neq L(DFA)$, is there an easy description of $L(DDFA)$? </p>\n</blockquote>\n\n<p>Proofs (or at least moderately fleshed-out sketches) are appreciated, if they aren't too complicated.</p>\n", 'ViewCount': '133', 'Title': 'Languages accepted by modified versions of finite automata', 'LastActivityDate': '2012-03-14T18:00:07.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '385', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2012-03-14T14:59:22.810', 'Id': '374'},22_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '228', 'Title': 'Is this language defined using twin primes regular?', 'LastEditDate': '2012-03-14T15:49:25.680', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '2', 'Body': '<p>Let</p>\n\n<p>$\\qquad L = \\{a^n \\mid \\exists_{p \\geq n}\\ p\\,,\\ p+2 \\text{ are prime}\\}.$</p>\n\n<p>Is $L$ regular?</p>\n\n<p>This question looked suspicious at the first glance and I\'ve realized that it is connected with the <a href="https://en.wikipedia.org/wiki/Twin_prime">twin prime conjecture</a>. My problem is that the conjecture has not been resolved yet, so I am not sure how can I proceed with deciding that the language is regular. </p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-14T20:25:40.660', 'CommentCount': '2', 'AcceptedAnswerId': '377', 'CreationDate': '2012-03-14T15:42:01.860', 'Id': '376'},22_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a>.</em></p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that the regular languages are closed under a variety of operations (we may limit ourselves to basic operations such as union, intersection, complement, difference, concatenation, Kleene star, and reversal), whereas the context-free languages have different closure properties (these are closed under union, concatenation, Kleene star, and reversal).</p>\n\n<blockquote>\n  <p>Is HAL closed under reversal?</p>\n</blockquote>\n', 'ViewCount': '386', 'Title': 'Proving closure under reversal of languages accepted by min-heap automata', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T04:30:39.730', 'LastEditDate': '2012-04-24T07:15:47.070', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><closure-properties>', 'CreationDate': '2012-03-14T20:17:55.613', 'Id': '390'},22_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a></em>.</p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that the regular languages are closed under a variety of operations (we may limit ourselves to basic operations such as union, intersection, complement, difference, concatenation, Kleene star, and reversal), whereas the context-free languages have different closure properties (these are closed under union, concatenation, Kleene star, and reversal).</p>\n\n<blockquote>\n  <p>Is HAL closed under complementation?</p>\n</blockquote>\n', 'ViewCount': '323', 'Title': 'Proving closure under complementation of languages accepted by min-heap automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-24T07:15:31.283', 'LastEditDate': '2012-04-24T07:15:31.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '415', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><closure-properties>', 'CreationDate': '2012-03-14T21:51:34.593', 'Id': '393'},22_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '724', 'Title': 'Computational power of deterministic versus nondeterministic min-heap automata', 'LastEditDate': '2012-03-16T18:25:40.237', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '0', 'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a>.</em></p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that deterministic and nondeterministic finite automata have equivalent computational capabilities, as do deterministic and nondeterministic Turing machines. However, the computational capabilities of deterministic push-down automata are less than those of nondeterministic push-down automata.</p>\n\n<blockquote>\n  <p>Are the computational capabilities of deterministic min-heap automata less than, or are they equal to, those of nondeterministic min-heap automata?</p>\n</blockquote>\n', 'Tags': '<formal-languages><automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-16T18:25:40.237', 'CommentCount': '0', 'AcceptedAnswerId': '406', 'CreationDate': '2012-03-14T21:52:44.340', 'Id': '394'},22_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The following DFA is a lexical analyzer which is supposed to recognize comments. The lexical analyzer will ignore the comment and goes back to the state one. I\'m told that there\'s something wrong with it but I can\'t figure it out. What\'s the problem?</p>\n\n<p><img src="http://i.stack.imgur.com/EeIdO.png" alt="enter image description here"></p>\n\n<p>FWIW, those tiny signs are stars which are necessary for C-style comment: "/* comment */"<br>\n  The loop in the state three is "except *"</p>\n', 'ViewCount': '489', 'Title': 'A DFA for recognizing comments', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:19.720', 'LastEditDate': '2012-03-25T15:53:37.777', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '398', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><automata><finite-automata><compilers>', 'CreationDate': '2012-03-14T22:46:16.420', 'Id': '396'},22_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2944', 'Title': 'Are Turing machines more powerful than pushdown automata?', 'LastEditDate': '2012-03-25T15:41:43.987', 'AnswerCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': "<p>I've came up with a result while reading some automata books, that Turing machines appear to be more powerful than pushdown automata. Since the tape of a Turing machine can always be made to behave like a stack, it'd seem that we can actually claim that TMs are more powerful. </p>\n\n<p>Is this true?</p>\n", 'Tags': '<formal-languages><computability><automata><turing-machines><pushdown-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-16T18:31:50.493', 'CommentCount': '4', 'AcceptedAnswerId': '670', 'CreationDate': '2012-03-22T20:00:29.897', 'Id': '669'},22_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '658', 'Title': 'How to convert an NFA with overlapping cycles into a regular expression?', 'LastEditDate': '2014-01-25T16:51:44.933', 'AnswerCount': '3', 'Score': '10', 'OwnerDisplayName': 'zell', 'PostTypeId': '1', 'OwnerUserId': '694', 'Body': '<p>If I understand correctly, NFA have the same expressive power as regular expressions. Often, reading off equivalent regular expressions from NFA is easy: you translate cycles to stars, junctions as alternatives and so on. But what to do in this case: </p>\n\n<p><img src="http://i.stack.imgur.com/yCGnv.png" alt="enter image description here"><br>\n<sup>[<a href="https://github.com/akerbos/sesketches/blob/gh-pages/src/cs_689.tikz" rel="nofollow">source</a>]</sup></p>\n\n<p>The overlapping cycles make it hard to see what this automaton accepts (in terms of regular expressions). Is there a trick?</p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:51:44.933', 'CommentCount': '7', 'AcceptedAnswerId': '692', 'CreationDate': '2012-03-23T07:35:51.517', 'Id': '689'},22_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Note that by "two-way pushdown automaton", I mean a pushdown automaton that can move its reading head both ways on the input tape.</p>\n\n<p>I recently had the question of determining the computational power of two-way PDAs in the Chomsky hierarchy. I don\'t entirely understand two-way PDAs, but I can see how with the ability to read in both directions on the input, it could handle languages of the form $L=\\{0^n 1^n 2^n\\}$. I can\'t say that for sure, but it seems that would make it powerful enough to least handle context-sensitive languages. </p>\n\n<p>This is all a guess because I don\'t know exactly how they work. Can someone explain the process of how a two-way PDA operates, maybe even on my example?</p>\n\n<p>UPDATE: </p>\n\n<blockquote>\n  <p>The model is a generalization of a pushdown automaton in that two-way motion is allowed on the input tape which is assumed to have endmarkers. </p>\n</blockquote>\n', 'ViewCount': '1078', 'Title': 'How does a two-way pushdown automaton work?', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-02T15:40:37.177', 'LastEditDate': '2012-04-02T15:40:37.177', 'AnswerCount': '1', 'CommentCount': '12', 'AcceptedAnswerId': '705', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><computability><automata><pushdown-automata>', 'CreationDate': '2012-03-23T15:39:20.283', 'Id': '699'},22_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have asked a series of questions concerning capabilities of a certain class of exotic automata which I have called <em>min-heap automata</em>; the original question, and links to others, can be found <a href="http://cs.stackexchange.com/q/110/69">here</a>.</p>\n\n<p>This question concerns the computational power of type-2 min-heap automata, which were suggested by Raphael as a more natural kind of computing device. The class of languages which can be accepted by such automata is a proper superset of the set of context-free languages; which leads me to my question.</p>\n\n<blockquote>\n  <p>Is $HAL_2$ (the set of languages accepted by nondeterministic type-2 min-heap automata) a proper subset of $CSL$ (the set of context-sensitive languages), or not? Note that it is already known (shown by Raphael in the linked question) that there are $CSL$ languages not in in $HAL_2$.</p>\n</blockquote>\n\n<p>This is one of the last questions I intend to ask about these automata. If a good answer can be found to these (and other) questions, my curiosity will be completely satisfied. Thanks in advance and for all the hard work so far.</p>\n', 'ViewCount': '59', 'Title': 'Computational power of nondeterministic type-2 min-heap automata', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-01T13:42:32.693', 'LastEditDate': '2012-04-01T13:42:32.693', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-04-01T04:01:58.047', 'FavoriteCount': '1', 'Id': '933'},22_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have asked a series of questions concerning capabilities of a certain class of exotic automata which I have called <em>min-heap automata</em>; the original question, and links to others, can be found <a href="http://cs.stackexchange.com/q/110/69">here</a>.</p>\n\n<p>This question concerns the power of type-1 min-heap automata, which represent my initial idea for how these machines would operate. The class of languages which can be accepted by such automata is incomparable (i.e., neither a proper subset nor a proper superset) of the set of context-free languages.</p>\n\n<p>Push down automata, which possess a single stack for data storage, accept the set of context-free languages, in the same way that min-heap automata, which possess a single heap for data storage, accept the set $HAL_1$ of languages accepted by nondeterministic type-1 min-heap automata. Push-down automata with two stacks are equivalent to Turing machines in computational power; they can simulate Turing machines, and vice versa; which leads me to my question:</p>\n\n<blockquote>\n  <p>Does adding another heap to non-deterministic type-1 min-heap automata make them equivalent in terms of computing ability to Turing machines, in the sense that they are able to simulate Turing machines? If not, does it increase their computational power at all, in the sense that nondeterministic type-1 min-heap automata can accept a set of languages which is a proper subset of $HAL_1$? If so, does adding additional heaps increase computational power, i.e., can nondeterministic min-heap automata with $k+1$ heaps accept more languages than automata with $k$ heaps, for any $k$? </p>\n</blockquote>\n\n<p>This is one of the last questions I plan to ask about these automata; if good answers can be had for these (and other) questions, my curiosity will be completely satisfied. Thanks in advance and for all the hard work so far.</p>\n', 'ViewCount': '108', 'Title': 'Computational power of nondeterministic type-1 min-heap automata with multiple heaps', 'LastActivityDate': '2012-12-02T00:05:45.090', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '941', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-04-01T04:04:37.637', 'FavoriteCount': '1', 'Id': '934'},22_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have asked a series of questions concerning capabilities of a certain class of exotic automata which I have called min-heap automata; the original question, and links to others, can be found <a href="http://cs.stackexchange.com/q/110/69">here</a>.</p>\n\n<p>Two of my last questions seem to have been quickly dispatched; one completely, and the other mostly (I have edited it to make it more viable). In either event, I actually had one other question I meant to ask, and would be interested to lay this subject to rest for good and all. So here it is:</p>\n\n<blockquote>\n  <p>A two-stack PDA can simulate a Turing machine. A $k$-heap nondeterministic type-1 min-heap automaton cannot (it seems; see the linked question). What about a $k$-tape nondeterministic type-1 min-heap automaton augmented with a stack (similar to that of a PDA)? Can it simulate a Turing machine? If not, does an augmented $(k+1)$-heap nondeterministic type-1 min-heap automaton accept a class of languages which is a proper superset of languages accepted by augmented automata with only $k$ heaps?</p>\n</blockquote>\n\n<p>Thanks, and I promise this is the last of these questions.</p>\n', 'ViewCount': '91', 'Title': 'Power of nondeterministic type-1 min-heap automaton with both a heap and a stack', 'LastActivityDate': '2012-04-01T14:04:34.520', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-04-01T14:04:34.520', 'Id': '944'},22_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '6747', 'Title': 'How to prove a language is regular?', 'LastEditDate': '2013-06-06T13:56:25.667', 'AnswerCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '4', 'Body': '<p>There are many methods to prove that <a href="http://cs.stackexchange.com/q/1031/157">a language is not regular</a>, but what do I need to do to prove that some language <em>is</em> regular?</p>\n\n<p>For instance, if I am given that $L$ is regular, \nhow can I prove that the following $L&#39;$ is regular, too?</p>\n\n<p>$\\qquad \\displaystyle L&#39; := \\{w \\in L: uv = w \\text{ for } u \\in \\Sigma^* \\setminus L \\text{ and } v \\in \\Sigma^+ \\}$</p>\n\n<p>Can I draw a nondeterministic finite automaton to prove this?</p>\n', 'Tags': '<formal-languages><regular-languages><automata><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-09-20T17:34:26.467', 'CommentCount': '4', 'AcceptedAnswerId': '1333', 'CreationDate': '2012-04-18T05:21:31.750', 'Id': '1331'},22_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am studying different approaches for the definition of computation with continuous dynamical systems. I have been trying to find a nice introduction to the theory of <a href="http://en.wikipedia.org/wiki/State_transition_system">"State transition systems"</a> but failed to do so.</p>\n\n<p>Does anybody know a modern introduction to the topic? \nOf particular interest would be something dealing with computability.</p>\n', 'ViewCount': '186', 'Title': 'What is a good reference to learn about state transition systems?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T18:45:31.160', 'LastEditDate': '2012-04-18T18:45:31.160', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '715', 'Tags': '<computability><automata><reference-request><computation-models>', 'CreationDate': '2012-04-18T09:13:20.920', 'FavoriteCount': '1', 'Id': '1335'},22_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '597', 'Title': 'Words that have the same right- and left-associative product', 'LastEditDate': '2012-04-24T06:17:40.090', 'AnswerCount': '4', 'Score': '7', 'OwnerDisplayName': 'Ismael Mezquino', 'PostTypeId': '1', 'OwnerUserId': '1217', 'FavoriteCount': '1', 'Body': '<p>I have started to study non deterministic automata using the book of <a href="https://en.wikipedia.org/wiki/Introduction_to_Automata_Theory,_Languages,_and_Computation" rel="nofollow">Hopcroft and Ullman</a>. I\'m stuck in a problem that I found very interesting:</p>\n\n<blockquote>\n  <p>Give a non deterministic finite automaton accepting all the strings that\n  have the same value when evaluated left to right as right to left by\n  multiplying according to the following table:</p>\n  \n  <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \r\n    \\times &amp; a &amp; b &amp; c \\\\\r\n    \\hline \r\n    a &amp; a &amp; a &amp; c \\\\\r\n    b &amp; c &amp; a &amp; b \\\\\r\n    c &amp; b &amp; c &amp;a\r\n   \\end{array}$</p>\n</blockquote>\n\n<p>So if we have the string $abc$,<br>\nthe product from left to right is $(a \\times b) \\times c=a \\times c=c$ and<br>\nthe product from right to left is $a \\times (b \\times c)=a \\times b=a$</p>\n\n<p>So $abc$ should not be acceptable for the automata. To me its obvious that any string $aa^*$ or $bb^*$ or $cc^*$ is an aceptable string (their right and left evaluation work on the same partial strings). It is easy to give an NFA that describes the left to right evaluation but the problem is that if the machine try to compute the <em>right to left</em> evaluation I think it needs to know the length of the string (so infinite memory is necessary).</p>\n\n<p>So how can a non deterministic automata evaluate from right to left in order to compare with the left to right evaluation?</p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-25T17:11:22.873', 'CommentCount': '0', 'AcceptedAnswerId': '1479', 'CreationDate': '2012-04-23T18:12:11.180', 'Id': '1467'},22_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Let $A_P = (Q,\\Sigma,\\delta,0,\\{m\\})$ the <em>string matching automaton</em> for pattern $P \\in \\Sigma^m$, that is </p>\n\n<ul>\n<li>$Q = \\{0,1,\\dots,m\\}$</li>\n<li>$\\delta(q,a) = \\sigma_P(P_{0,q}\\cdot a)$ for all $q\\in Q$ and $a\\in \\Sigma$</li>\n</ul>\n\n<p>with $\\sigma_P(w)$ the length of the longest prefix of $P$ that is a Suffix of $w$, that is</p>\n\n<p>$\\qquad \\displaystyle \\sigma_P(w) = \\max \\left\\{k \\in \\mathbb{N}_0 \\mid P_{0,k} \\sqsupset w \\right\\}$.</p>\n\n<p>Now, let $\\pi$ the <em>prefix function</em> from the <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" rel="nofollow">Knuth-Morris-Pratt algorithm</a>, that is</p>\n\n<p>$\\qquad \\displaystyle \\pi_P(q)= \\max \\{k \\mid k &lt; q \\wedge P_{0,k} \\sqsupset P_{0,q}\\}$.</p>\n\n<p>As it turns out, one can use $\\pi_P$ to compute $\\delta$ quickly; the central observation is:</p>\n\n<blockquote>\n  <p>Assume above notions and $a \\in \\Sigma$. For $q \\in \\{0,\\dots,m\\}$ with $q = m$ or $P_{q+1} \\neq a$, it holds that</p>\n  \n  <p>$\\qquad \\displaystyle \\delta(q,a) = \\delta(\\pi_P(q),a)$</p>\n</blockquote>\n\n<p>But how can I prove this?</p>\n\n<hr>\n\n<p>For reference, this is how you compute $\\pi_P$:</p>\n\n<pre><code>m \u2190 length[P ]\n\u03c0[0] \u2190 0\nk \u2190 0\nfor q \u2190 1 to m \u2212 1 do\n  while k &gt; 0 and P [k + 1] =6 P [q] do\n    k \u2190 \u03c0[k]\n    if P [k + 1] = P [q] then\n       k \u2190 k + 1\n    end if\n    \u03c0[q] \u2190 k\n end while\nend for\n\nreturn \u03c0\n</code></pre>\n', 'ViewCount': '1117', 'Title': 'Connection between KMP prefix function and string matching automaton', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:53:30.563', 'LastEditDate': '2012-05-17T23:59:30.850', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '1900', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1378', 'Tags': '<algorithms><finite-automata><strings><searching>', 'CreationDate': '2012-05-05T09:56:27.257', 'Id': '1669'},22_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Are there undecidable properties of linear bounded automata (avoiding the empty set language trick)? What about for a deterministic finite automaton? (put aside intractability). </p>\n\n<p>I would like to get an example (if possible) of an undecidable problem that is defined <em>without using Turing machines</em> explicitly.</p>\n\n<p>Is Turing completeness of a model necessary to support uncomputable problems?</p>\n', 'ViewCount': '506', 'Title': 'Are there undecidable properties of non-turing-complete automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-23T18:22:59.677', 'LastEditDate': '2012-05-10T14:18:02.203', 'AnswerCount': '5', 'CommentCount': '5', 'AcceptedAnswerId': '1699', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<computability><automata><undecidability>', 'CreationDate': '2012-05-06T21:35:14.827', 'Id': '1697'},22_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Lets $L_z \\ := \\{ a^i b^i c^i : 0 \\leq i &lt; z \\}$</p>\n\n<p>$\\{a,b,c\\} \\in \\sum^*$</p>\n\n<p>there is a DFA with $\\frac{z(z+1)}{2}+1$ states - How can I prove this?</p>\n\n<p>And I need largest possible number $n_z$, for which i can prove that every NFA, which accepts $L_z$, have $n_z$ states, at least!</p>\n\n<p>But first I need to show that $n_z = \\frac{z(z+1)}{2}$\n right?</p>\n', 'ViewCount': '249', 'Title': 'DFA with limited states', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-19T15:56:15.823', 'LastEditDate': '2012-05-08T23:09:26.217', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '1743', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-05-08T22:59:08.823', 'Id': '1740'},22_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '309', 'Title': 'Non-regular Languages?', 'LastEditDate': '2012-05-09T14:33:33.083', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Body': u'<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Why $L_a$ and  $L_b$  are not reguluar?</p>\n\n<p>$L_a = \\{ e^i f^{n-i} g^j h^{n-j} : n \\in N, 1 \\leq i, j \\leq n \\}$. </p>\n\n<p>$L_b= \\{nm^{i_1} nm^{i_2}...bn^{i_z}: z \\in N, (i_1,...,i_n) \\in N^z, 1 \\leq j \\leq z, i_j \u2260 j \\}$.</p>\n', 'ClosedDate': '2012-05-09T19:58:17.077', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-10T02:21:47.107', 'CommentCount': '8', 'AcceptedAnswerId': '1756', 'CreationDate': '2012-05-09T13:39:25.267', 'Id': '1753'},22_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '546', 'Title': "Why is a regular language called 'regular'?", 'LastEditDate': '2012-05-14T15:15:21.780', 'AnswerCount': '2', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '1434', 'FavoriteCount': '3', 'Body': '<p>I have just completed the first chapter of the <a href="http://www-math.mit.edu/~sipser/book.html"><em>Introduction to the Theory of Computation</em></a> by <em>Michael Sipser</em> which explains the basics of finite automata. </p>\n\n<p>He defines a regular language as anything that can be described by a finite automata. But I could not find where he explains why a regular language is called "regular?"  What is the origin of the term "regular" in this context?</p>\n\n<p>NOTE: I am a novice so please try to explain in simple terms!</p>\n', 'Tags': '<formal-languages><regular-languages><terminology><finite-automata><history>', 'LastEditorUserId': '1298', 'LastActivityDate': '2012-05-14T15:15:21.780', 'CommentCount': '1', 'AcceptedAnswerId': '1772', 'CreationDate': '2012-05-10T02:07:18.947', 'Id': '1771'},22_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Brzozowski's DFA minimization algorithm builds a minimal DFA for DFA $G$ by:</p>\n\n<ol>\n<li>reversing all the edges in $G$, making the initial state an accept state, and the accept states initial, to get an NFA $N&#39;$ for the reverse language, </li>\n<li>using powerset construction to get $G&#39;$ for the reverse language, </li>\n<li>reversing the edges (and initial-accept swap) in $G&#39;$ to get an NFA $N$ for the original language, and</li>\n<li>doing powerset construction to get $G_{\\min}$.</li>\n</ol>\n\n<p>Of course, since some DFA's have an exponential large reverse DFA, this algorithm runs in exponential time in worst case in terms of the size of the input, so lets keep track of the size of the reverse DFA. </p>\n\n<p>If $N$ is the size of the input DFA, $n$ is the size of the minimal DFA, and $m$ the size of the minimal reverse DFA, then <strong>what is the run time of Brzozowski's algorithm in terms of $N$,$n$, and $m$?</strong></p>\n\n<p>In particular, <strong>under what relationship between $n$ and $m$ does Brzozowski's algorithm outperform Hopcroft's or Moore's algorithms?</strong></p>\n\n<p>I have heard that on typical examples in <em>practice/application</em>, Brzozowski's algorithm outperforms the others. <strong>Informally, what are these typical examples like?</strong></p>\n", 'ViewCount': '1327', 'Title': "Brzozowski's algorithm for DFA minimization", 'LastEditorUserId': '55', 'LastActivityDate': '2012-11-09T13:05:46.000', 'LastEditDate': '2012-05-16T18:52:28.467', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<algorithms><finite-automata><runtime-analysis>', 'CreationDate': '2012-05-16T16:43:10.513', 'FavoriteCount': '2', 'Id': '1872'},22_30:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m am stuck solving the next exercise:</p>\n\n<p>Argue that if $L$ is context-free and $R$ is regular, then $L / R = \\{ w \\mid \\exists x \\in R \\;\\text{s.t}\\; wx \\in L\\} $ (i.e. the <a href="https://en.wikipedia.org/wiki/Right_quotient" rel="nofollow">right quotient</a>) is context-free.</p>\n\n<p>I know that there should exist a PDA that accepts $L$ and a DFA that accepts $R$. I\'m now trying to combine these automata to a PDA that accepts the right quotient. If I can build that I proved that $L/R$ is context-free. But I\'m stuck building this PDA.</p>\n\n<p>This is how far I\'ve made it:   </p>\n\n<blockquote>\n  <p>In the combined PDA the states are a cartesian product of the states of the seperate automata. And the edges are the edges of the DFA but only the ones for which in the future a final state of the original PDA of L can be reached. But don\'t know how to write it down formally.</p>\n</blockquote>\n', 'ViewCount': '637', 'Title': 'If $L$ is context-free and $R$ is regular, then $L / R$ is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-17T23:12:15.793', 'LastEditDate': '2012-05-17T19:38:52.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1526', 'Tags': '<formal-languages><context-free><finite-automata><closure-properties><pushdown-automata>', 'CreationDate': '2012-05-17T16:19:42.050', 'FavoriteCount': '1', 'Id': '1886'},22_31:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to convert a user entered regular expression into an NFA so that I can then run the NFA against a string for matching purposes. What is the minimum machine that can be used to parse regular expresssions? </p>\n\n<p>I assume it must be a push down automaton because the presense of brackets means the need to count and a DFA/NFA cannot perform arbitrary counting. Is this assumption correct? For example, the expression a(bc*)d would require a PDA so that the sub-expression in brackets is handled correctly.</p>\n', 'ViewCount': '549', 'Title': 'Does the language of Regular Expressions need a push down automata to parse it?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-22T07:41:16.970', 'LastEditDate': '2012-05-20T12:32:09.750', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1434', 'Tags': '<formal-languages><parsers><regular-expressions><pushdown-automata>', 'CreationDate': '2012-05-20T03:26:18.503', 'FavoriteCount': '3', 'Id': '1939'},22_32:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '727', 'Title': 'Relation between simple and regular grammars', 'LastEditDate': '2012-05-20T21:41:35.507', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1563', 'FavoriteCount': '1', 'Body': '<p>I am reading "An Introduction to Formal Languages and Automata" written by Peter Linz and after reading the first five chapters I face below problem with\nsimple and regular (especially right linear) grammars which are very similar to each other.</p>\n\n<p>What relation exists between these? What is the difference?\nCan you create (non-deterministic) finite automata for simple grammars (obviously without using a stack)?</p>\n', 'Tags': '<regular-languages><automata><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-21T21:29:04.513', 'CommentCount': '1', 'AcceptedAnswerId': '1968', 'CreationDate': '2012-05-20T21:03:35.607', 'Id': '1958'},22_33:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '471', 'Title': 'Decide whether a context-free languages can be accepted by a deterministic pushdown automaton', 'LastEditDate': '2012-05-21T11:16:20.547', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '1577', 'FavoriteCount': '2', 'Body': '<p>Given a context-free grammar G, there exists a Nondeterministic Pushdown Automaton N that accepts exactly the language G accepts. (and visa versa)</p>\n\n<p>There <strong>may</strong> also exist a Deterministic Pushdown Automaton D that accepts exactly the language G accepts too.  It depends on the grammar.</p>\n\n<p>By what algorithm on the productions of G can we determine if D exists?</p>\n', 'Tags': '<automata><context-free><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T13:37:24.503', 'CommentCount': '1', 'AcceptedAnswerId': '1973', 'CreationDate': '2012-05-21T09:30:46.410', 'Id': '1972'},22_34:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm learning for the exam and have problems with this task:</p>\n\n<blockquote>\n  <p>Describe an algorithm that transforms a given NFA $A = (Q, \\Sigma, \\delta, q_0, F)$ (which may have $\\epsilon$-transitions) into an equivalent NFA without $\\epsilon$-transitions with the same condition number. And then determine the maturity of the algorithm. The algorithm should have a running time $O(|Q| \xb7 |\\delta|)$ where\n  $$|\\delta| := \\sum_{\\substack{q\\in Q\\\\ a\\in\\Sigma\\cup\\{\\epsilon\\}}} |\\delta(q,a)|$$</p>\n</blockquote>\n", 'ViewCount': '710', 'Title': 'Transforming an NFA into an NFA of similar size but without $\\epsilon$-transitions', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T21:24:51.643', 'LastEditDate': '2012-05-22T19:49:52.230', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1593', 'Tags': '<algorithms><automata><finite-automata>', 'CreationDate': '2012-05-21T22:26:40.027', 'Id': '1983'},22_35:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '985', 'Title': 'Prove that regular languages are closed under the cycle operator', 'LastEditDate': '2012-05-22T07:23:51.960', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '2', 'Body': u"<p>I've got in a few days an exam and have problems to solve this task.</p>\n\n<p>Let $L$ be a regular language over the alphabet $\\Sigma$. We have the operation \n$\\operatorname{cycle}(L) = \\{ xy \\mid x,y\\in \\Sigma^* \\text{ and } yx\\in L\\}$\nAnd now we should show that $\\operatorname{cycle}(L)$ is also regular.</p>\n\n<p>The reference is that we could construct out of a DFA $D=(Q,\\Sigma,\\delta, q_0, F)$ with $L(D) = L$ a $\\epsilon$-NFA $N$ with $L(N) = \\operatorname{cycle}(L)$ and  $2 \xb7 |Q|^2 + 1$ states. </p>\n", 'Tags': '<formal-languages><regular-languages><finite-automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:35:34.333', 'CommentCount': '2', 'AcceptedAnswerId': '1989', 'CreationDate': '2012-05-22T05:28:58.017', 'Id': '1986'},22_36:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '14352', 'Title': 'How to convert finite automata to regular expressions?', 'LastEditDate': '2014-03-22T11:29:26.503', 'AnswerCount': '4', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '18', 'Body': '<p>Converting regular expressions into (minimal) NFA that accept the same language is easy with standard algorithms, e.g. <a href="http://en.wikipedia.org/wiki/Thompson%27s_construction_algorithm" rel="nofollow">Thompson\'s algorithm</a>. The other direction seems to be more tedious, though, and sometimes the resulting expressions are messy.</p>\n\n<p>What algorithms are there for converting NFA into equivalent regular expressions? Are there advantages regarding time complexity or result size?</p>\n\n<p><sup>This is supposed to be a reference question. Please include a general decription of your method as well as a non-trivial example.</sup></p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:29:26.503', 'CommentCount': '2', 'AcceptedAnswerId': '2389', 'CreationDate': '2012-05-23T08:19:27.003', 'Id': '2016'},22_37:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need help with the following exercise:</p>\n\n<p>Construct an $\\varepsilon$-NFA for the following regular expression $(a|\\varepsilon)(ba)^*(c^*a|bc)^*$.</p>\n\n<p>i already tried this exercise with nerode but i didnt come to a solution please help me\nthank you guys</p>\n\n<p>Source wiki\nNerode : (Given a language L, and a pair of strings x and y, define a distinguishing extension to be a string z such that exactly one of the two strings xz and yz belongs to L. Define a relation RL on strings by the rule that x RL y if there is no distinguishing extension for x and y. It is easy to show that RL is an equivalence relation on strings, and thus it divides the set of all finite strings into equivalence classes.</p>\n\n<p>The Myhill\u2013Nerode theorem states that L is regular if and only if RL has a finite number of equivalence classes, and moreover that the number of states in the smallest deterministic finite automaton (DFA) recognizing L is equal to the number of equivalence classes in RL. In particular, this implies that there is a unique minimal DFA with minimum number of states.)</p>\n', 'ViewCount': '164', 'Title': 'construct regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T13:19:11.120', 'LastEditDate': '2012-05-23T15:44:05.140', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1424', 'Tags': '<formal-languages><finite-automata><regular-expressions>', 'CreationDate': '2012-05-23T14:54:13.360', 'Id': '2024'},22_38:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '289', 'Title': 'Optimal myopic maze solver', 'LastEditDate': '2012-06-02T18:29:46.523', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '55', 'FavoriteCount': '1', 'Body': '<p>I was fooling around with <a href="http://neil.fraser.name/software/blockly/demos/maze/index.html">Google Blocky\'s Maze demo</a>, and remembered the old rule that if you want to solve a maze, just keep your left hand to the wall. This works for any simple-connected maze and can be implemented by a finite transducer.</p>\n\n<p>Let our robot be represented by a transducer with the following actions, and observables:</p>\n\n<ul>\n<li>Actions: go forward ($\\uparrow$), turn left ($\\leftarrow$), turn right ($\\rightarrow$)</li>\n<li>Observables: wall ahead ($\\bot$), no wall ahead ($\\top$)</li>\n</ul>\n\n<p>Then we can build the left-hand maze solver as (pardon my lazy drawing):</p>\n\n<p><img src="http://i.stack.imgur.com/vAnFO.png" alt="transducer to solve the maze"></p>\n\n<p>Where seeing an observable will make us follow the appropriate edge out of the state while executing the action associated with that edge. This automaton will solve all simply-connected mazes, although it might take its time following dead ends. We call another automaton $B$ <em>better than</em> $A$ if:</p>\n\n<ol>\n<li><p>$B$ takes strictly more steps on only a finite number of mazes, and</p></li>\n<li><p>$B$ takes strictly fewer steps (on average; for probabilistic variants) on an infinite number of mazes.</p></li>\n</ol>\n\n<p>My two questions:</p>\n\n<ol>\n<li><p><strong>Is there a finite automaton <em>better than</em> the one drawn above?</strong> What if we allow probabilistic transducers?</p></li>\n<li><p><strong>Is there a finite automaton for solving mazes that are not necessarily simply-connected?</strong></p></li>\n</ol>\n', 'Tags': '<automata><finite-automata><artificial-intelligence>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-03T08:49:25.447', 'CommentCount': '3', 'AcceptedAnswerId': '2207', 'CreationDate': '2012-06-02T16:18:06.140', 'Id': '2201'},22_39:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '451', 'Title': 'Automata that recognizes Kleene closure of permutations of three symbols', 'LastEditDate': '2012-06-05T20:22:44.813', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1758', 'FavoriteCount': '1', 'Body': u'<p>This is an automata theory homework question.</p>\n\n<p>I need to create DFA that meets the following criteria:  </p>\n\n<ul>\n<li><p>Alphabet $\\Sigma = \\{ a, b, c \\}$</p></li>\n<li><p>Machine accepts empty string and strings of length that is a multiple of three, with every block of three containing one $a$, one $b$ and one $c$.</p></li>\n</ul>\n\n<p>So far, I came up with this machine, it is obvious:</p>\n\n<p><img src="http://i.stack.imgur.com/r3rCz.jpg" alt="the machine"></p>\n\n<p>However, I can\'t get it to accept empty string. Does it mean there is a transition q0 \u2192 q3?</p>\n\n<p><strong>Update1:</strong>  Following corrections by Dave Clarke I made some corrections.</p>\n\n<ol>\n<li>A regular expression for this machine is $(www)^*$ where $w = \\{abc,acb,\u2026\\}$. Therefore to represent multiple of three, I need to copy this (on the picture) machine 3 times. Final state should have arrows pointing to the first copy, for transitions marked \'a\', \'b\',\'c\'.  </li>\n<li>As it was pointed out, since this is DFA, I need to add missing states. This can be accomplished by adding "dead" states.  </li>\n<li>Empty string should correspond to $\\varepsilon$-transition from qStarting \u2192 qFinal.</li>\n</ol>\n\n<p><strong>Update2:</strong> \nAs it was pointed out, my regular expression is wrong ! It should be $(w)^*$. Here is the final machine, that I think should be correct.(I didn\'t include "dead" state)<img src="http://i.stack.imgur.com/L3xZX.jpg" alt="enter image description here"></p>\n', 'Tags': '<formal-languages><automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-06T11:21:21.587', 'CommentCount': '11', 'AcceptedAnswerId': '2234', 'CreationDate': '2012-06-05T17:19:48.020', 'Id': '2233'},22_40:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the context of our investigation of <a href="http://cs.stackexchange.com/questions/110/determining-capabilities-of-a-min-heap-or-other-exotic-state-machines">heap automata</a>, I would like to prove that a particular variant can not accept non-context-sensitive languages. As we have no equivalent grammar model, I need a proof that uses only automata; therefore, I have to show that heap automata can be simulated by <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton">LBA</a>s (or an equivalent model).</p>\n\n<p>I expect the proof to work similarly to showing that pushdown automata accept a subset the context-sensitive languages. However, all proofs I know work by</p>\n\n<ul>\n<li>using grammars -- here the fact is obvious by definition -- or</li>\n<li>are unconvinvingly vague (e.g. <a href="http://www.cs.uky.edu/~lewis/texts/theory/automata/lb-auto.pdf">here</a>).</li>\n</ul>\n\n<p>My problem is that a PDA (resp. HA) can contain cycles of $\\varepsilon$-transitions that may write symbols to the stack (resp. heap). An LBA can not simulate arbitrary iterations of such loops. From the Chomsky hierarchy obtained with grammars, we know that </p>\n\n<ol>\n<li>every context-free language has an $\\varepsilon$-cycle-free PDA or</li>\n<li>the simulating LBA can prevent iterating $\\varepsilon$-cycles too often.</li>\n</ol>\n\n<p>Intuitively, this is clear: such cycles write symbols independently of the input, therefore the stack (heap) content does only hold an amount of information linear in the length of the cycle (disregarding overlapping cycles for now). Also, you don\'t have a way to get rid of the stuff again (if you need to) other than using another $\\varepsilon$-cycle. In essence, such cycles do not contribute to dealing with the input if iterated multiple times, so they are not necessary.</p>\n\n<p>How can this argument be put rigorously/formally, especially considering overlapping $\\varepsilon$-cycles?</p>\n', 'ViewCount': '144', 'Title': u'How to prove that \u03b5-loops are not necessary in PDAs?', 'LastActivityDate': '2012-06-12T13:47:52.250', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<automata><pushdown-automata>', 'CreationDate': '2012-06-12T13:47:52.250', 'Id': '2338'},22_41:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In my class we used a Pushdown Automata to Context Free Grammar conversion algorithm that produces a lot extraneous states.</p>\n\n<p>For example, for two transitions, I am getting the following productions</p>\n\n<blockquote>\n  <p>$$\\begin{gather*}\n  \\delta(q_0,1,Z) = (q_0,XZ) \\\\\n  {}[q_0,Z,q_0] \\to 1[q_0,X,q_0][q_0,Z,q_0] \\\\\n  {}[q_0,Z,q_0] \\to 1[q_0,X,q_1][q_1,Z,q_0] \\\\\n  {}[q_0,Z,q_1] \\to 1[q_0,X,q_0][q_0,Z,q_1] \\\\\n  {}[q_0,Z,q_1] \\to 1[q_0,X,q_1][q_1,Z,q_1] \\\\\n\\end{gather*}$$</p>\n  \n  <p>$$ \\begin{gather*}\n  \\delta(q_1,0,Z) = (q_0,Z) \\\\\n  {}[q_1,Z,q_0 ] \\to 0[q_0,Z,q_0] \\\\\n  {}[q_1,Z,q_1 ] \\to 0[q_0,Z,q_1] \\\\\n\\end{gather*}$$</p>\n</blockquote>\n\n<p>How do I decide which state makes it into final production, and which one will be excluded ?</p>\n', 'ViewCount': '304', 'Title': 'Eliminating useless productions resulting from PDA to CFG converison', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-01T18:57:35.320', 'LastEditDate': '2012-06-27T12:51:15.767', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4834', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1758', 'Tags': '<automata><formal-grammars><context-free><pushdown-automata>', 'CreationDate': '2012-06-26T20:28:39.280', 'Id': '2503'},22_42:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to proof that if $L_1 \\subset L_2$ and $L_1$ is not regular then $L_2$ it not regular. This is my proof. Is it valid? </p>\n\n<p>Since $L_1$ is not regular, there does not exists a finite automata $M_1$ such that $L_1$ is the language of $M_1$. Pick $x\\in L_1$. So $x \\in L_2$ and suppose that $L_2$ is regular. Then there exists a finite automata $M_2$ such that $L_2$ is the language of $M_2$. Since $x \\in L_2$ and $L_2$ is regular, there exists a state $s\\in S$ such that from the initial state in $M_2$ there is a path $x$ to this final state $s$. Since this holds for all $x \\in L_1$, we can construct a finite automata which language is $L_1$, so $L_1$ is regular, so we reached a contradiction, so $L_2$ is not regular.</p>\n\n<p>Can this be done easier?</p>\n', 'ViewCount': '463', 'Title': 'Are supersets of non-regular languages also non-regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-29T12:06:06.380', 'LastEditDate': '2012-06-28T16:53:23.070', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata><check-my-proof>', 'CreationDate': '2012-06-28T16:24:12.253', 'Id': '2528'},22_43:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a problem with the proof for constructing a GNBA (<a href="https://en.wikipedia.org/wiki/Generalized_B%C3%BCchi_automaton" rel="nofollow">generalized nondeterministic B\xfcchi automaton</a>) for a <a href="https://en.wikipedia.org/wiki/Linear_temporal_logic" rel="nofollow">LTL formula</a>:</p>\n\n<p><strong>Theorem:</strong> For any  LTL formula $\\varphi$ there exists a GNBA $G_{\\varphi}$ over alphabet $2^{AP}$ such that:</p>\n\n<ol>\n<li><p>$\\operatorname{Word}(\\varphi)=L_{\\omega}(G_{\\varphi})$.</p></li>\n<li><p>$G_{\\varphi}$ can be costructed in time and space $2^{O(|\\varphi|)}$, where $|\\varphi|$ is the size of $\\varphi$.</p></li>\n<li><p>The number of accepting states of $G_{\\varphi}$ is bounded above by $O(|\\varphi|)$.</p></li>\n</ol>\n\n<p>My problem lies in the proof of (2), that is, in the proof it says that the number of states in $G_{\\varphi}$ is bounded by  $2^{|\\operatorname{subf}(\\varphi)|}$ but since $|\\operatorname{subf}(\\varphi)| \\leq 2\\cdot|\\varphi|$ (where $\\operatorname{subf}(\\varphi)$ is the set of all subformulae) the number of states is bounded by  $2^{O(|\\varphi|)}$. </p>\n\n<p>But why does $|\\operatorname{subf}(\\varphi)| \\leq 2\\cdot|\\varphi|$ hold? </p>\n', 'ViewCount': '75', 'Title': 'Time to construct a GNBA for LTL formula', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-30T12:27:09.250', 'LastEditDate': '2012-06-30T12:27:09.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2533', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1999', 'Tags': '<logic><automata><formal-methods><model-checking><linear-temporal-logic>', 'CreationDate': '2012-06-28T17:27:44.363', 'Id': '2531'},22_44:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>Let $L_1$ be regular, $L_1 \\cap L_2$ regular, $L_2$ not regular. Show that $L_1 \\cup L_2$ is not regular or give a counterexample.</p>\n</blockquote>\n\n<p>I tried this: Look at $L_1 \\backslash (L_2 \\cap L_1)$. This one is regular. I can construct a finite automata for this ($L_1$ is regular, $L_2 \\cap L_1$ is regular, so remove all the paths (finite amount) for $L_1 \\cap L_2$ from the finite amount of paths for $L_1$. So there is a finite amount of paths left for this whole thing. This thing is disjoint from $L_2$, but how can I prove that the union of $L_1 \\backslash (L_1 \\cap L_2)$ (regular) and $L_2$ (not regular) is not regular?</p>\n', 'ViewCount': '2072', 'Title': 'Proof that union of a regular and a not regular language is not regular', 'LastEditorUserId': '667', 'LastActivityDate': '2014-04-19T06:24:37.110', 'LastEditDate': '2012-07-17T18:05:14.560', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-06-28T20:00:17.477', 'Id': '2537'},22_45:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '528', 'Title': 'How to simulate backreferences, lookaheads, and lookbehinds in finite state automata?', 'LastEditDate': '2012-06-30T11:18:42.317', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'Aadit M Shah', 'PostTypeId': '1', 'OwnerUserId': '2023', 'Body': "<p>I created a simple regular expression lexer and parser to take a regular expression and generate its parse tree. Creating a non-deterministic finite state automaton from this parse tree is relatively simple for basic regular expressions. However I can't seem to wrap my head around how to simulate backreferences, lookaheads, and lookbehinds.</p>\n\n<p>From what I read in the purple dragon book I understood that to simulate a lookahead $r/s$ where the regular expression $r$ is matched if and only if the match is followed by a match of the regular expression $s$, you create a non-deterministic finite state automaton in which $/$ is replaced by $\\varepsilon$. Is it possible to create a deterministic finite state automaton that does the same?</p>\n\n<p>What about simulating negative lookaheads and lookbehinds? I would really appreciate it if you would link me to a resource which describes how to do this in detail.</p>\n", 'Tags': '<automata><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:41:59.937', 'CommentCount': '0', 'AcceptedAnswerId': '2560', 'CreationDate': '2012-06-29T05:27:14.677', 'Id': '2557'},22_46:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $\\Sigma$ be a given alphabet. Is there a way to code up Deterministic Finite state Automata (DFA) over $\\Sigma$ as strings of $\\Sigma$ in such a way that the corresponding subset of $\\Sigma^*$ is a regular language?</p>\n\n<p>For example for Turing machines, the set of codes of Turing machines over a fixed alphabet is decidable, and we can speak of decidable sets of Turing machines (through their codes).</p>\n\n<p>Of course we can also speak of regular sets of DFA's (through their codes). Is the set of all DFA's regular in this sense?</p>\n", 'ViewCount': '143', 'Title': 'Is the set of codes of Deterministic Finite-State Automata a regular language?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-06-13T13:23:28.980', 'LastEditDate': '2012-07-17T05:57:31.880', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'OwnerDisplayName': 'user1491069', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-07-09T16:26:02.807', 'Id': '2682'},22_47:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '903', 'Title': 'Context-free grammar to a pushdown automaton', 'LastEditDate': '2012-07-29T14:15:47.920', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2125', 'FavoriteCount': '1', 'Body': "<p>I'm trying to convert a context free grammar to a pushdown automaton (PDA); I'm not sure how I'm gonna get an answer or show you my progress as it's a diagram... Anyway this is the last problem I have on a homework that's due later today, so I'd appreciate some kind of help, even if it's just an explanation of the correct answers diagram. I need a PDA corresponding to this CFG:</p>\n\n<p>$$S \\rightarrow aSa | bSb | B$$\n$$B \\rightarrow bB | \\epsilon$$</p>\n\n<p>I know it will have to push X every time 'a' is read before a 'b', and pop X every time 'a' is read after a 'b'. But I'm not sure how to arrange the PDA in order to tell which a's came after b's. Also, I'm unsure of how to deal with the b's in terms of the stack, as there can be as many in the middle of the string as you want. Help appreciated.</p>\n\n<p>Thanks, Pachun</p>\n", 'Tags': '<formal-grammars><context-free><pushdown-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-07-29T14:15:47.920', 'CommentCount': '2', 'AcceptedAnswerId': '2736', 'CreationDate': '2012-07-13T18:08:44.950', 'Id': '2735'},22_48:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': u'Algorithm to translate a deterministic B\xfcchi automaton to LTL (when possible)', 'LastEditDate': '2012-07-14T13:05:53.293', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'Ayrat', 'PostTypeId': '1', 'OwnerUserId': '2260', 'Body': u'<p><a href="http://en.wikipedia.org/wiki/Linear_temporal_logic" rel="nofollow">Linear temporal logic</a> and deterministic <a href="http://en.wikipedia.org/wiki/B%C3%BCchi_automaton" rel="nofollow">B\xfcchi automata</a> are incomparable: DBA cannot express $FGa$, and LTL cannot express <em>"at least each odd letter is \'a\'"</em>. But sometimes it is interesting to know whether the language of a DBA can be expressed in LTL.</p>\n\n<p>I need an algorithm that decides whether a language of a given DBA is describable in LTL. Do you know algorithms for that?</p>\n', 'Tags': '<logic><automata><linear-temporal-logic><buchi-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-14T13:05:53.293', 'CommentCount': '5', 'AcceptedAnswerId': '2740', 'CreationDate': '2012-03-02T13:16:26.227', 'Id': '2739'},22_49:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this finite-state process with the corresponding labeled transition system: </p>\n\n<p><img src="http://i.stack.imgur.com/mxLLU.png" alt="enter image description here"></p>\n\n<p>The FSP is: </p>\n\n<pre><code>MAKER = (kochen -&gt; fertig -&gt; MAKER).\nUSER = (fertig -&gt; essen -&gt; USER). \n\n||MAKER_USER = (USER||MAKER).\n</code></pre>\n\n<p>Why is <code>essen</code> possible after the second <code>kochen</code>? <code>USER</code> needs to have <code>fertig</code> in order to able to <code>essen</code> right? </p>\n', 'ViewCount': '168', 'Title': 'LTS of this simple FSP', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-27T15:36:33.043', 'LastEditDate': '2012-07-16T23:31:50.067', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1877', 'Tags': '<automata><finite-automata><process-algebras>', 'CreationDate': '2012-07-15T00:33:08.300', 'Id': '2744'},22_50:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '139', 'Title': 'Building a finite state transducer', 'LastEditDate': '2012-07-16T23:33:18.050', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'madflame991', 'PostTypeId': '1', 'OwnerUserId': '2170', 'Body': "<p>I know it's possible to build a Finite State Transducer for converting numbers from base 2 to base 4 or 8 or other powers of 2 (translating from base N to base N^M is easy). However I've never seen a FST that can convert numbers from base 1 to base 2 or viceversa. Can a FST even do this? If so, can you please give some hints on building such a FST?</p>\n", 'Tags': '<automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:33:18.050', 'CommentCount': '2', 'AcceptedAnswerId': '2747', 'CreationDate': '2012-07-14T19:48:07.230', 'Id': '2745'},22_51:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I cannot understand decidability really well. I have been reading from books and internet, but I am little bit confused. \nAccording to the book (as I understood), we can decide on decidability of a problem by constructing Turing Machines. Let us say that we want to decide whether an NFA is a decidable language. First, we need to construct a Turing Machine that accepts if the run on w in NFA ends in accept state, otherwise Turing Machine rejects. \nAccording to this definition, I can construct any Turing Machine that can decide every NFA. As a result, I can say that every NFA that can be constructed is decidable. Is this true ?</p>\n\n<p>Additionally, I realized that we cannot decide whether two Context Free Grammars produce same languages. However, we can decide whether two NFA produce same language. Therefore, can we conclude that as our machines get complicated, some of the problems get harder to decide ? </p>\n\n<p>I mean lets take an example. Let us say that there is an NFA that accepts some string w whose length is a composite number. I think that this is a decidable problem.</p>\n\n<p>As you can see that I am little bit confused with these concepts. It will be a lot better for me to go over an example, because it is difficult for me to understand only from conceptual explanations.</p>\n', 'ViewCount': '90', 'Title': 'Decidability of Machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:04:31.740', 'LastEditDate': '2012-07-17T22:04:31.740', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Marigi Maskere', 'PostTypeId': '1', 'Tags': '<computability><automata><finite-automata><turing-machines>', 'CreationDate': '2009-12-06T15:47:36.283', 'Id': '2797'},22_52:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2459', 'Title': 'Is a push-down automaton with two stacks equivalent to a turing machine?', 'LastEditDate': '2012-08-13T10:22:59.483', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'Lazer', 'PostTypeId': '1', 'OwnerUserId': '1558', 'FavoriteCount': '2', 'Body': '<p>In <a href="http://stackoverflow.com/a/559969/113124">this answer</a> it is mentioned</p>\n\n<blockquote>\n  <p>A regular language can be recognized by a finite automaton. A context-free language requires a stack, and <strong>a context sensitive language requires two stacks (which is equivalent to saying it requires a full Turing machine)</strong>.</p>\n</blockquote>\n\n<p>I wanted to know regarding the truth of the bold part above. Is it in fact true or not? What is a good way to reach at an answer to this?</p>\n', 'Tags': '<computability><automata><turing-machines>', 'LastEditorUserId': '917', 'LastActivityDate': '2012-08-13T10:22:59.483', 'CommentCount': '5', 'AcceptedAnswerId': '2833', 'CreationDate': '2012-07-19T10:50:44.883', 'Id': '2832'},22_53:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I just came across an exercise which is to find a regular expression for the following automata, such that the regular expression and the automata generate the same language.</p>\n\n<p><img src="http://i.stack.imgur.com/4Zk9t.png" alt="NFA"></p>\n\n<p>One solution presents the following expression:</p>\n\n<p>$\\qquad \\displaystyle r_A = a^+b^+(c\\mid ca^*b^+)^*$</p>\n\n<p>However, can this be true? I think not, because the all words created from the regular expression will have at least one $b$ in it, whereas the automata accepts words without $b$, such as $aaa$.</p>\n\n<p>What is your opinion?</p>\n', 'ViewCount': '214', 'Title': 'Does this regular expression equal this automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-23T07:39:49.723', 'LastEditDate': '2012-07-23T07:39:49.723', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1413', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-07-21T13:37:50.370', 'Id': '2851'},22_54:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The problem, coming from an interview question, is:</p>\n\n<blockquote>\n  <p>You have a stream of incoming numbers in range 0 to 60000 and you have\n  a function which will take a number from that range and return the\n  count of occurrence of that number till that moment. Give a suitable\n  Data structure/algorithm to implement this system.</p>\n</blockquote>\n\n<p>The stream is infinite, so if fixed size data structures re used, i.e. primitive types in Java or C, they will overflow. So there is the need to use data structures that have a size that grows over time. As pointed by the interviewer, the memory occupied by those data structures will diverge.</p>\n\n<p>The model of computation is a Turing machine with three tapes:</p>\n\n<ul>\n<li>infinite read-only one-way input tape;</li>\n<li>constant space bounded read-write two way work tape;</li>\n<li>infinite write-only one-way output tape.</li>\n</ul>\n\n<p>The main reason to choose the model above is that in the real world there is virtually no limit to the quantity of input that can be acquired using a keyboard or a network connection. Also, there is virtually no limit to the quantity of information that can be displayed on amonitor over time. But memory is limited and expensive.</p>\n\n<p>I modeled the problem as the problem to recognize the language L of all couples (number,number of occurrences so far).</p>\n\n<p>As a corollary of the Theorem 3.13 in Hopcroft-Ullman I know that every language recognized by a constant space bounded machine is regular.</p>\n\n<p>But, in any given moment, the language L is a finite language, because the number of couples to be recognized is finite: 60001. So I can\'t use the pumping lemma for regular languages to prove that such language is not regular.</p>\n\n<p>Is there a way I can complete my proof?</p>\n\n<p>The original question is <a href="http://stackoverflow.com/questions/11708957/find-the-count-of-a-particular-number-in-an-infinite-stream-of-numbers-at-a-part">here</a>.</p>\n', 'ViewCount': '198', 'Title': 'Counting with constant space bounded TMs', 'LastEditorUserId': '851', 'LastActivityDate': '2012-07-30T11:41:01.430', 'LastEditDate': '2012-07-30T11:41:01.430', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '2951', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<regular-languages><turing-machines><finite-automata><space-complexity><streaming-algorithm>', 'CreationDate': '2012-07-29T16:44:46.170', 'Id': '2948'},22_55:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Does any one know how to implement the simulation relation on two <a href="https://en.wikipedia.org/wiki/State_transition_system" rel="nofollow">labelled transition systems</a> (LTS)? </p>\n\n<p>I know how to do it for branching bi-simulation. The signature refinement theorem is used for that purpose which has the time complexity of $O(n^3)$ on cyclic LTSs. Is the signature refinement technique useful for simulation also?</p>\n\n<p>Is there any binary relation called branching simulation? Any idea how to implement it?</p>\n\n<p>What I would like to do is to write a program such that:</p>\n\n<ul>\n<li>Input: Given two labelled transition systems with silent steps</li>\n<li>Output1: Does one simulates the other one?</li>\n<li>Output2: Are they bisimilar?</li>\n<li>Output3: Are they branching bisimilar?</li>\n<li>Output4: Does one branching simulate the other one?</li>\n</ul>\n\n<p>The following illustrates the definitions of the above relations:</p>\n\n<ol>\n<li><p>simulate: An LTS ($L_1$) simulates another LTS ($L_2$) if there exists a binary relation $R$ over the states of the two transition systems such that every transition of $L_2$ can be matched by a transition of $L_1$. Note that simulation is not an equivalence relation.</p></li>\n<li><p>bisimilar: An LTS ($L_1$) and an LTS ($L_2$) are said to be bisimular if there exists a relation $R$ between the states of these transition systems such that both $R$ and $R^{-1}$ are simulations. Note that bisimularity is an equivalence relation.  </p></li>\n<li><p>branching bisimilarity: is same as bisimilarity but transition systems may have silent steps. Those silent steps ($\\tau$ actions) that do not change the behavior of the process are eliminated. Note that branching bisimilarity is an equivalence relation.</p></li>\n<li><p>branching similarity: I actually have never seen the definition of branching similarity in any context, but it should be the same as similarity. However, the transition systems may have the silent steps.</p></li>\n</ol>\n\n<p>The paper <a href="http://dx.doi.org/10.1016/S1571-0661%2805%2980099-4" rel="nofollow">Distributed Branching Bisimulation Reduction of State Spaces</a> by S. Blom and S. Orzan explains an algorithm to reduce the size of an LTS with respect to branching bisimilarity. The signature refinement theorem is used for that purpose. How it works is roughly as follows: </p>\n\n<p>the algorithm starts by constructing a partition (a set of blocks) of states and terminates once the partition is stable. In a stable partition, two states are branching bisimilar if they belong to the same block. </p>\n\n<p>The above algorithm can also be used to verify whether two LTSs are branching bisimilar or bisimilar. How it works is as follows:</p>\n\n<p>Let LTS, $L_3 = L_1 \\cup L_2$, then if after branching reduction, using the above algorithm, the initial states of $L_1$ and $L_2$ both belong to the same block then they are branching bisimular. The above algorithm has time complexity $O(n^3)$ and space complexity $O(n^2)$.</p>\n\n<p>Question: How can I do the same with branching simulate and simulate relations? </p>\n', 'ViewCount': '132', 'Title': 'How to implement simulation on two LTSs?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-03T21:55:49.257', 'LastEditDate': '2012-08-02T06:34:09.370', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2333', 'Tags': '<automata><formal-methods><process-algebras>', 'CreationDate': '2012-07-31T23:51:35.737', 'FavoriteCount': '1', 'Id': '2976'},22_56:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $\\mathrm{MIN}_{\\mathrm{DFA}}$ collection of all the codings of DFAs such that they are minimal regarding their states number. I mean if $\\langle A \\rangle \\in \\mathrm{MIN}_{\\mathrm{DFA}}$ then for every other DFA $B$ with less states than $A$, $L(A)\\ne L(B)$ holds. I'm trying to figure out how come that $\\mathrm{MIN}_{\\mathrm{DFA}} \\in R$? How come it is decidable?</p>\n\n<p>What is about this kind of DFAs that is easy to decide?</p>\n", 'ViewCount': '131', 'Title': 'Is the set of minimal DFA decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T14:43:53.250', 'LastEditDate': '2012-08-05T14:43:53.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3046', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-08-05T13:05:39.717', 'Id': '3044'},22_57:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Repost from Stack Overflow:</p>\n\n<p>I'm going through past exams and keep coming across questions that I can't find an answer for in textbooks or on google, so any help would be much appreciated.</p>\n\n<p>The question I'm having problems with at the moment is as follows:  </p>\n\n<blockquote>\n  <p>Given a regular expression (a|bb)*, derive an estimate of the cost in time for \n  converting it to a corresponding NFA and a DFA. Your answer should refer to\n  the size of the regular expression.</p>\n</blockquote>\n\n<p>A similar question from another year is:</p>\n\n<blockquote>\n  <p>Given that, for the above example, you know the size of the original regular\n  expression, |r| and the size of the input string |x|, explain how you would calculate the cost in time for constructing and running the NFA versus constructing\n  and running an equivalent DFA.</p>\n</blockquote>\n\n<p>The resulting NFA for (a|bb)* has 9 states, while the DFA has 4. Even knowing this, I have no idea how to approach the question.</p>\n", 'ViewCount': '819', 'Title': 'Cost in time of constructing and running an NFA vs DFA for a given regex', 'LastActivityDate': '2012-08-09T21:15:55.073', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3094', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2386', 'Tags': '<regular-languages><automata><finite-automata><compilers>', 'CreationDate': '2012-08-07T09:36:46.857', 'Id': '3071'},22_58:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2623/is-this-language-context-free">Is this language Context-Free?</a>  </p>\n</blockquote>\n\n\n\n<p>The language is defined by\n$$(a+b)^*-\\{(a^nb^n)^n\\mid n \\geq1 \\}$$</p>\n\n<p>is Context-Free Language? I believe that the answer is that it is not a CFL\'s, but I can\'t prove it by Ogden lemma or pumping lemma.</p>\n\n<p>chazisop, (a+b)* means {a,b}*. That\'s all strings that you can form with the symbols a or b or both.</p>\n', 'ViewCount': '78', 'ClosedDate': '2012-08-15T06:10:52.610', 'Title': 'Is this language Context-Free?', 'LastActivityDate': '2012-08-15T02:56:42.430', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '9', 'OwnerDisplayName': 'Frank Duque', 'PostTypeId': '1', 'OwnerUserId': '2077', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-07-03T22:02:38.647', 'Id': '3193'},22_59:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Thw <a href="http://en.wikipedia.org/wiki/Pushdown_automaton" rel="nofollow">Wikipedia article on Pushdown automata</a> doesn\'t explain what the receiving state is for the generated PDA it just states that there is but one state.   </p>\n', 'ViewCount': '473', 'Title': 'When generating a PDA from a CFG do I have a receiving state?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-05T18:28:35.937', 'LastEditDate': '2012-08-16T07:19:01.497', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'user10392', 'PostTypeId': '1', 'Tags': '<terminology><automata><pushdown-automata>', 'CreationDate': '2012-08-15T12:40:36.717', 'Id': '3205'},22_60:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '5374', 'Title': 'How to show that a "reversed" regular language is regular', 'LastEditDate': '2013-03-06T13:33:29.817', 'AnswerCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2576', 'FavoriteCount': '2', 'Body': '<p>I\'m stuck on the following question:</p>\n\n<p>"Regular languages are precisely those accepted by finite automata. Given this fact, show that if the language $L$ is accepted by some finite automaton, then $L^{R}$ is also accepted by some finite; $L^{R}$ consists of all words of $L$ reversed."</p>\n', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'LastEditorUserId': '2100', 'LastActivityDate': '2013-10-03T14:07:16.580', 'CommentCount': '13', 'AcceptedAnswerId': '3253', 'CreationDate': '2012-08-18T15:54:03.993', 'Id': '3251'},22_61:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$$L=\\{a^n \\mid \\text{\\(n\\) is even}\\}$$</p>\n\n<p>This is regular but fails in the pumping Lemma.</p>\n\n<p>Assuming $m=4$, $w=aaaaaa$, $|w|=6$ (even).\nLet $w=xyz$,\n$x=a$,\n$y=aaa$.\nWe have $|y|&gt;0$ and $|xy| \\le m$.</p>\n\n<p>Let $w_i=xy^iz$.\nFor $i=2$,\n$w_2=xy^2z=aaaaaaaaa$.\n$|w_2|=9$ therefore it is not regular.</p>\n\n<p>Where am I going wrong?</p>\n', 'ViewCount': '668', 'Title': 'Pumping Lemma for regular language for $a^n$ where $n$ is even fails', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-18T12:56:53.010', 'LastEditDate': '2012-08-30T04:59:09.197', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '2', 'OwnerDisplayName': 'Raj', 'PostTypeId': '1', 'Tags': '<regular-languages><automata><finite-automata><pumping-lemma>', 'CreationDate': '2012-08-24T05:02:20.050', 'Id': '3330'},22_62:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Construct an NFA over $\\{0, 1\\}$ whose language contains only words that do not end with $10$.</p>\n</blockquote>\n\n<p>This is one of the first problems in the book, so it's supposedly easy. I just can't figure it out. It's easy using a DFA, but I'm not so sure using an NFA. Maybe I'm not understanding a particular concept in the NFA.</p>\n", 'ViewCount': '398', 'Title': 'NFA for binary words that do not end in 10', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-30T16:21:24.157', 'LastEditDate': '2012-08-30T15:48:21.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user10537', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-08-30T01:16:20.547', 'FavoriteCount': '0', 'Id': '3368'},22_63:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can I build an example of a DFA that has $2^n$ states where the equivalent NFA has $n$ states. Obviously the DFA's state-set should contain all subsets of the the NFA's state-set, but I don't know how to start. Any suggestions to put me on the right track?</p>\n", 'ViewCount': '905', 'Title': 'NFA with exponential number of states when deteminized', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-21T13:32:00.343', 'LastEditDate': '2012-09-01T11:01:36.277', 'AnswerCount': '4', 'CommentCount': '9', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-08-31T19:54:57.733', 'FavoriteCount': '1', 'Id': '3381'},22_64:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When converting a DFA to a regular expression using the <a href="http://cs.stackexchange.com/a/2395">transitive closure method</a>, what is the significance of state $k$ and what values $k$ takes? If $k$ represents the intermediate states then what are the values for $k$? That is while applying the method, for which value of $k$ should we stop finding the regular expressions?</p>\n', 'ViewCount': '162', 'Title': 'What is the purpose of k in the transitive closure method?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T07:51:30.237', 'LastEditDate': '2012-09-03T07:51:30.237', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2699', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2012-09-01T07:18:00.917', 'Id': '3384'},22_65:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '129', 'Title': "Compute 'insertable' letters in a regular language", 'LastEditDate': '2012-09-03T19:54:55.990', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2714', 'FavoriteCount': '1', 'Body': '<p>Let $L$ a regular language and define the <em><a href="https://en.wikipedia.org/wiki/Subsequence" rel="nofollow">subsequence</a> closure</em> of $L$ as</p>\n\n<p>$\\qquad \\displaystyle S(L) = \\{ w \\mid \\exists w\' \\in L.\\ w \\text{ subsequence of } w\'\\}$.</p>\n\n<p>The problem I want to solve is to find for such subsequences $w \\in S(L)$ which letters can be inserted into them so that the result is also in $S(L)$. Formally:</p>\n\n<blockquote>\n  <p>Given $w_1\\dots w_n \\in S(L)$, output all pairs $(i,a) \\in \\{0,\\dots,n\\} \\times \\Sigma$ for which $w_1 \\dots w_{i} a w_{i+1} \\dots w_n \\in S(L)$.</p>\n</blockquote>\n\n<p>Consider, for instance, the language$\\{ab, abc, abcc\\}$. The string $b$ is in $S(L)$ and inserting $a$ at the beginning -- corresponding to $(0,a)$ -- yields $ab \\in S(L)$. On the other hand, the string $cb$ is not in $S(L)$; there is no way to convert it to a language string by insertion.</p>\n\n<p>Using this language, if the input string is $b$ the possible insertions I am looking for are $(0,a)$ and $(1,c)$ at the end. If the input string is $bc$ the possible insertions are $(0,a), (1,c)$ and $(2,c)$.</p>\n\n<p>The use of this algorithm is in a user interface: the user builds strings belonging to the language starting from an empty string and adding one character at a time in different positions. At each step the UI prompts the user with all the possible valid letters in all the possible insertion positions.</p>\n\n<p>I have a working naive algorithm that involves a lot of back-tracking, and it is way too slow even in relatively simple cases. I was wondering if there is something better, or -- failing that -- if there are any available studies of this problem.</p>\n', 'Tags': '<algorithms><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-04T20:40:39.843', 'CommentCount': '5', 'AcceptedAnswerId': '3424', 'CreationDate': '2012-09-02T19:55:58.830', 'Id': '3404'},22_66:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm looking for a major in Theoretical Computer Science; specifically, I'm interested on complexity theory and probabilistic automata theory. As I'm graduating in one year, what advanced courses in math (like Galois theory or Harmonic analysis, for example) do you think would be useful to take over the next two semesters? Why?</p>\n", 'ViewCount': '264', 'Title': 'Math for TCS major', 'LastEditorUserId': '69', 'LastActivityDate': '2012-10-04T19:33:12.617', 'LastEditDate': '2012-09-07T16:02:18.477', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2753', 'Tags': '<complexity-theory><automata><education>', 'CreationDate': '2012-09-07T04:23:50.113', 'FavoriteCount': '2', 'Id': '3457'},22_67:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>is the following true \n$ (L^R)^* = (L^*)^R $ </p>\n\n<p>I tried the following to prove it true.\nlet u,v belong to L then $ L^* = \\{ u,v, uu, vv, uv, vu ... \\} $\nand $ (L^*)^R = \\{ u^R, v^R, u^Ru^R, v^Rv^R, v^Ru^R, u^Rv^R ... \\} $</p>\n\n<p>now $ L^R = \\{ u^R, v^R \\} $ so \n$(L^R)^* = \\{ u^R, v^R, u^Ru^R, v^Rv^R, u^Rv^R, v^Ru^R ... \\} $</p>\n', 'ViewCount': '156', 'Title': 'Is star closure of reverse of language equivalent to reverse of closure of that language', 'LastEditorUserId': '2667', 'LastActivityDate': '2012-09-15T12:04:45.153', 'LastEditDate': '2012-09-15T11:00:47.203', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '3561', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2667', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-09-15T08:08:09.913', 'Id': '3559'},22_68:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '215', 'Title': "Why isn't converting from an NFA to a DFA working?", 'LastEditDate': '2012-09-16T06:08:00.687', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'John Hoffman', 'PostTypeId': '1', 'OwnerUserId': '3003', 'Body': '<p>I am just beginning to learn computation theory. I wrote up a non-deterministic finite automata that accepts strings that contain the substring "abba":</p>\n\n<p><img src="http://i.stack.imgur.com/jZx92.jpg" alt="My NFA"></p>\n\n<p>I tried to convert it to a DFA by putting together sets of states in the NFA to be states of the DFA:<img src="http://i.stack.imgur.com/yHRck.jpg" alt="My DFA"></p>\n\n<p>However, I just realized that my DFA doesn\'t accept strings such as "abbaa" that do not end in "abba." That means that my methodology was wrong. Why? I thought it would make sense to combine states of the NFA to make states of the DFA.</p>\n', 'Tags': '<automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-10-22T12:01:57.383', 'CommentCount': '1', 'AcceptedAnswerId': '4581', 'CreationDate': '2012-09-15T19:52:53.927', 'Id': '4572'},22_69:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '527', 'Title': 'What piece am I missing to turn this idea into a programming language?', 'LastEditDate': '2013-07-20T09:50:34.237', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2161', 'FavoriteCount': '2', 'Body': '<p>I\'ve been doing some reading (I\'ll name drop along the way) and have selected a few scattered ideas that I think could be cobbled together into a nifty esoteric programming language. But I\'m having some difficulty assembling the parts.</p>\n\n<p>Kleene\'s Theorem states: Any Regular Set can be recognized by some Finite-State Machine (Minsky 4.3).</p>\n\n<p>Minsky\'s Theorem 3.5: Every Finite-State machine is equivalent to, and can be "simulated by", some neural net.</p>\n\n<p>"There is a natural way to represent any forest as a binary tree." (Knuth, v1, 333).</p>\n\n<p>And according to Bentley (Programming Pearls, p.126) a binary tree can be encoded as a flat array.</p>\n\n<p>So I\'m imagining an array of bit-fields (say 4 bits so it can easily be worked with in hexadecimal). Each field indicates a type of automaton, and the positions of the array encode (via an intermediary binary tree representation) a forest which approximates (? missing piece ?) the power of a graph.</p>\n\n<p>I\'m somewhat bewildered by the possibilities of automaton sets to try, and of course the fun Universal Automata require three inputs (I worked up an algorithm inspired by Bentley to encode a ternary tree implicitly in a flat array, but it feels like the wrong direction). So I\'d appreciate any side-bar guidance on that. Current best idea: the normal set: and or xor not nand nor, with remaining bits used for threshold weights on the inputs.</p>\n\n<p>So the big piece I\'m missing is a formalism for applying one of these nibble-strings to a datum. Any ideas or related research I should look into?</p>\n\n<hr>\n\n<p><em>Edit:</em> My theoretical support suggests that the type of computations will probably be limited to RL acceptors (and maybe generators, but I haven\'t thought that through).</p>\n\n<p>So, I tried to find an example to flesh this out. The C <code>int isdigit(int c)</code> function performs a logical computation on (in effect) a bit-string. Assuming ASCII, where the valid digits are <code>0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39</code>, so bit 7 must be off, bit 6 must be off, bit 5 must be on, and bit 4 must be on: these giving us the 0x30 prefix; then bit 3 must be off (0-7) or if bit 3 is on, bit 2 must be off and bit 1 must be off (suppressing A-F), and don\'t care about bit 0 (allowing 8 and 9). If you represent the input <em>c</em> as a bit-array (<code>c[0]</code>..<code>c[7]</code>), this becomes</p>\n\n<pre><code>~c[7] &amp; (~c[6] &amp; (c[5] &amp; (c[4] &amp; (~c[3] | (~c[2] &amp; ~c[1])))))\n</code></pre>\n\n<p>Arranging the operators into a tree (colon (:) represents a wire since pipe (|) is logical or),</p>\n\n<pre><code>c[7]  6   5   4   3   2   1   0\n ~    ~   :   :   ~   ~   ~   :\n    &amp;     :   :   :     &amp;\n       &amp;      :      |\n           &amp;        :  \n                &amp;\n</code></pre>\n\n<p>My thought based on this is to insert "input lead" tokens into the tree which receive the values of the input bit assigned in a left-to-right manner. And I also need a <em>ground</em> or <em>sink</em> to explicitly ignore certain inputs (like c[0] above).</p>\n\n<p>This leads me to make NOT (~) a binary operator which negates the left input and simply absorbs right input. And in the course of trying this, I also realized the necessity for a ZERO token to build masks (and to provide dummy input for NOTs).</p>\n\n<p>So the new set is: &amp;(and) |(or) ^(xor) ~(not x, sink y) 0(zero) I(input)</p>\n\n<p>So the tree becomes (flipping up for down)</p>\n\n<pre><code>                 ^\n           &amp;           &amp;\n       &amp;       |      I 0\n     &amp;   I  ~     &amp;\n   &amp;   I   I 0  ~   ~\n ~   ~         I 0 I 0\nI 0 I 0\n=   =  = = =   =   =  =\n7   6  5 4 3   2   1  0 \n</code></pre>\n\n<p>Which encodes into the array (skipping the "forest&lt;=>tree" part, "_" represents a blank)</p>\n\n<pre><code>_ ^ &amp; &amp; &amp; | I 0 &amp; I ~ &amp; _ _ _ _ &amp; I _ _ I 0 ~ ~ _\n  _ _ _ _ _ _ _ ~ ~ _ _ _ _ _ _ _ _ _ _ I 0 I 0 _\n  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ I 0 I 0 \n</code></pre>\n\n<p>The tree->array encoding always put the root in array(1) so with zero-indexed array, there\'s a convenient blank at the beginning that could be used for linkage, I think.</p>\n\n<p>With only 6 operators, I suppose it could be encoded in octal.</p>\n\n<p>By packing a forest of trees, we could represent a chain of acceptors each applied on the next input depending on the result of the previous.</p>\n', 'Tags': '<programming-languages><finite-automata><arrays><neural-networks><machine-models>', 'LastEditorUserId': '2161', 'LastActivityDate': '2013-11-29T03:20:30.750', 'CommentCount': '6', 'AcceptedAnswerId': '4623', 'CreationDate': '2012-09-19T19:58:45.397', 'Id': '4618'},22_70:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m reviewing for my midterm and wanted to post this to see if anyone can spot any errors. Im supposed to make a PDA that recognizes this CFG:</p>\n\n<p>$\\qquad\\begin{align}\n  S &amp;\\to R1R1R1 \\\\\n  R &amp;\\to 0R \\mid 1R \\mid \\varepsilon\n\\end{align}$</p>\n\n<p>Here is my solution; I\'m aware that I forgot to draw the second circle around my accepting state.</p>\n\n<p><img src="http://i.stack.imgur.com/vNLh0.png" alt="enter image description here"></p>\n', 'ViewCount': '447', 'Title': 'Converting a context free grammar to a PDA -- is my solution correct?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-22T19:14:08.240', 'LastEditDate': '2012-09-21T21:12:00.730', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'jfisk', 'PostTypeId': '1', 'Tags': '<formal-languages><automata><context-free><pushdown-automata>', 'CreationDate': '2011-11-05T19:34:40.697', 'Id': '4654'},22_71:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '61', 'Title': u'B\xfcchi automaton with modified acceptance condition', 'LastEditDate': '2012-09-22T20:45:12.463', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'vh4x0r', 'PostTypeId': '1', 'OwnerUserId': '2935', 'Body': u'<p>Consider a B\xfcchi automaton $\\mathcal{A}$ with the modified acceptance condition, that an $\\omega$-word $\\mathcal{w}$ is accepted by $\\mathcal{A}$ iff every run $\\rho$ of $\\mathcal{A}$ on $\\mathcal{w}$ is accepting (rather than at least one run being accepting). I need to show that this automaton also accepts only $\\omega$-regular languages. How do I go about doing that?</p>\n', 'Tags': '<formal-languages><automata><buchi-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-23T21:47:02.687', 'CommentCount': '2', 'AcceptedAnswerId': '4697', 'CreationDate': '2012-09-20T15:44:40.677', 'Id': '4672'},22_72:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '717', 'Title': 'How is the rule 110 Turing complete?', 'LastEditDate': '2012-09-30T00:59:44.817', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Pureferret', 'PostTypeId': '1', 'OwnerUserId': '2952', 'FavoriteCount': '3', 'Body': '<p>I\'ve read the wikipedia page for <a href="http://en.wikipedia.org/wiki/Rule_110" rel="nofollow">rule 110</a> in cellular automata, and I more or less know how they work (a set of rules decides where to draw the next 1 or 0).</p>\n\n<p>I\'ve just read they\'re Turing complete, but I can\'t even fathom how would you  \'program\' in \'rule 110\'? </p>\n', 'Tags': '<computability><automata><turing-completeness><cellular-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-09-30T00:59:44.817', 'CommentCount': '11', 'CreationDate': '2012-09-21T23:44:56.810', 'Id': '4779'},22_73:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can you show that the Language accepted by an NFA and the reverse NFA is the same?</p>\n\n<p>For a language $L$, there is an $L^R=\\{ w^R \\mid w \\in L\\}$</p>\n\n<p>Let's say that $w^R$ is the string obtained by reversing the string $w$.</p>\n\n<p>I know that it involves using induction on the length of the input, but I would really appreciate some help.</p>\n", 'ViewCount': '339', 'Title': 'How do you prove that two languages are equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T22:29:06.833', 'LastEditDate': '2012-10-02T20:02:27.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3040', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-10-02T18:37:35.743', 'Id': '4845'},22_74:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In my Computing Theory course, a lot of our problems involve using induction on the length of the input string to prove statements about finite automata.  I understand mathematical induction, however when strings come into play I get real tripped up.  I\'d really appreciate it if someone would go through the process of making such a proof step by step.</p>\n\n<p>Here\'s an example problem (Exercise 2.2.10 from Hopcroft and Ullman 3rd Edition):</p>\n\n<blockquote>\n  <p>Consider the DFA with the following transition table:</p>\n\n<pre>\n        0    1\n       ________\n-> A |  A    B\n  *B |  B    A\n</pre>\n  \n  <p>Informally describe the language accepted by this DFA, and prove by induction on the length of an input string that your description is correct.</p>\n</blockquote>\n\n<p>This is an answered problem in the book, so I\'m not looking for someone to do my homework.  I just need someone to explain it to me straight.</p>\n\n<p><strong>Book\'s Answer:</strong>\n(taken from <a href="http://infolab.stanford.edu/~ullman/ialcsols/sol2.html" rel="nofollow">here</a>)</p>\n\n<blockquote>\n  <p>The automaton tells whether the number of 1\'s seen is even (state A) or odd (state B), accepting in the latter case. It is an easy induction on |w| to show that dh(A,w) = A if and only if w has an even number of 1\'s.\n  Basis: |w| = 0. Then w, the empty string surely has an even number of 1\'s, namely zero 1\'s, and \u03b4-hat(A,w) = A.</p>\n  \n  <p>Induction: Assume the statement for strings shorter than w. Then w = za, where a is either 0 or 1.</p>\n  \n  <ul>\n  <li><p><strong>Case 1:</strong> a = 0. If w has an even number of 1\'s, so does z. By the inductive hypothesis, \u03b4-hat(A,z) = A. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then so does z. By the inductive hypothesis, \u03b4-hat(A,z) = B, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  <li><p><strong>Case 2:</strong> a = 1. If w has an even number of 1\'s, then z has an odd number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = B. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then z has an even number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = A, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case as well, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  </ul>\n</blockquote>\n\n<p>I understand how to prove things like $\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}$ using induction.  I\'m just confused by how this works with building strings.  I\'m confused by the bolded parts.  I don\'t understand how they are come up with/how it actually proves what is accepted/how it is inductive.</p>\n\n<p>\u03b4-hat is the extended transition function, by the way.</p>\n', 'ViewCount': '1544', 'Title': 'How do I write a proof using induction on the length of the input string?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T17:30:34.120', 'LastEditDate': '2014-02-02T17:30:34.120', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4907', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3082', 'Tags': '<automata><finite-automata><proof-techniques><reference-question><induction>', 'CreationDate': '2012-10-06T19:00:18.360', 'Id': '4905'},22_75:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p><sup>(edit: the question was ambiguous. The following is it's non-trivial interpretation) </sup></p>\n\n<p>I need to <code>Find a regular grammar that generates the set of all real numbers in C (programming Language)</code></p>\n\n<ol>\n<li>How do I know how the C programming language defines a real number?</li>\n<li>How can I find a <em>regular</em> grammar for such numbers?</li>\n</ol>\n", 'ViewCount': '587', 'ClosedDate': '2012-10-10T20:09:06.560', 'Title': 'Find a regular grammar that generates the set of all real numbers in C', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-19T17:26:29.650', 'LastEditDate': '2012-10-09T07:14:53.170', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3095', 'Tags': '<regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2012-10-08T03:12:37.733', 'Id': '4939'},22_76:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Im trying to figure out how to describe fifty-six strings to test if a three state FA over the alphabet $\\{a,b\\}$ has a finite language.</p>\n\n<p>The number fifty-six comes from a theorem that states if a machine has $N$ states and an alphabet has $m$ letters, then in total there are $m^N + m^{N + 1} + m^{N + 2} +\\ldots+ m^{2N-1}$ different input strings in the range $N \\leq \\text{length of string} &lt; 2N$. Thus $2^3 2^4 2^5 = 56$ strings.</p>\n\n<p>I know that we can test them all by running them on the machine and if any are accepted, the language is infinite, if none are accepted, the language is finite. I'm just not sure how to describe the strings.</p>\n", 'ViewCount': '98', 'LastEditorDisplayName': 'user3115', 'Title': 'Describing Strings', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T19:15:19.750', 'LastEditDate': '2012-12-12T19:15:19.750', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-10-08T23:02:02.093', 'Id': '4962'},22_77:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im trying to prove that the following language is not regular.\n$$\\text{Notprime} = \\{a^n \\text{where \\(n\\) isn\'t prime}\\}\n  = \\{\\epsilon, a, aaaa, aaaaaa, aaaaaaaa, \\ldots\\}$$</p>\n\n<p>Heres what I have:</p>\n\n<p>"If Notprime were regular, then its complement would be regular also. However, the complement of Notprime is the language Prime, hence Notprime is non-regular." </p>\n\n<p>Is this the right way of proving it? Any help is appreciated!</p>\n', 'ViewCount': '499', 'Title': 'Prove that the language of non-prime numbers written in unary is not regular', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-09T22:46:52.467', 'LastEditDate': '2012-10-09T22:35:33.397', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '4986', 'Score': '4', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2012-10-09T22:26:18.387', 'Id': '4984'},22_78:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a>  </p>\n</blockquote>\n\n\n\n<p>Im curious if anyone knows if its possible to write a program to generate a regular expression given a finite automation.  </p>\n\n<p>To make things less complicated I want to limit the number of states to about 4, assume the FA is in minimal form and that the FA has only one FinalState and only one StartState. </p>\n\n<p>Ive been thinking about it for a while now and I think the first obvious thing to do would be to create a transition table for the FA. </p>\n\n<p>So an FA could look like this:</p>\n\n<pre><code>NumberOfStates 4 \nStartState   1 \nFinalState   4 \nStateNumber  NextStateA   NextStateB\n1            2            4\n2            3            2\n3            4            4\n</code></pre>\n\n<p>And would generate the regular expression: b + (ab*a(a + b))</p>\n\n<p>Ive been racking my brain for hours but am stumped on how to go about this. Any ideas is greatly appreciated. </p>\n', 'ViewCount': '142', 'LastEditorDisplayName': 'user3115', 'ClosedDate': '2012-10-10T06:38:21.657', 'Title': 'Program that generates a regular expression from an FA', 'LastActivityDate': '2012-10-10T06:25:59.247', 'LastEditDate': '2012-10-10T05:17:02.773', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2012-10-10T04:58:04.090', 'Id': '4987'},22_79:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im having trouble figuring out how to determine if two finite automata are the same apart from renumbered states.  </p>\n\n<p>More specifically, heres an example:\n<img src="http://i.stack.imgur.com/EPdpg.jpg" alt="example"> </p>\n\n<p>It\'s easy to generate a regular expression by hand and see that both FA produce: \nb + (ab*a(a+b)), though their states are renumbered, they are identical.</p>\n\n<p>What I\'m trying to do is figure out a way to check if the two states are the same apart from state renumbering without generating a regular expression. </p>\n\n<p>Since the states are just renumbered, I\'m thinking it has something to do with permutations of the states(1 2 3 4) but am not seeing how to determine if they are equivalent. I\'m thinking it has something to do with input like this and relating it to the 24 permutations of the states:</p>\n\n<pre><code>Left       Right\n1 a 2      4 a 3\n1 b 4      4 b 1\n2 a 3      3 a 2\n2 b 2      3 b 3\n3 a 4      2 a 1\n3 b 4      2 b 1\n</code></pre>\n\n<p>Im more so trying to figure out the algorithm to renumber the states Any ideas or help is greatly appreciated! </p>\n', 'ViewCount': '201', 'Title': 'Finding an isomorphism between finite automata', 'LastEditorUserId': '630', 'LastActivityDate': '2014-01-21T06:55:28.640', 'LastEditDate': '2014-01-21T06:55:28.640', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '5012', 'Score': '1', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-10-11T05:37:04.637', 'Id': '5010'},22_80:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '348', 'Title': 'How to prove that DFAs from NFAs can have exponential number of states?', 'LastEditDate': '2012-10-14T14:49:28.763', 'AnswerCount': '3', 'Score': '12', 'OwnerDisplayName': 'John Hoffman', 'PostTypeId': '1', 'OwnerUserId': '3003', 'Body': '<p>All non-deterministic finite automata can be turned into equivalent deterministic finite automata. However, a deterministic finite automata only allows a single arrow per symbol pointing from a state. Therefore, its states should be members of the power set of states of the NFA. This seems to indicate that the number of states of the DFA could scale exponentially in terms of the number of states of the NFA. However, I was wondering how to actually prove this.</p>\n', 'Tags': '<automata><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-14T14:49:28.763', 'CommentCount': '2', 'AcceptedAnswerId': '6065', 'CreationDate': '2012-09-15T21:10:09.980', 'Id': '6063'},22_81:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to design an NFA that will take the strings <code>"token"</code> and <code>token</code>.</p>\n\n<p>I can use $\\lambda$ or <code>"</code> to the first state, but then how do I know on the final state if it should have end quotes or not?</p>\n', 'ViewCount': '107', 'Title': 'How to make NFA remember its first step?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-16T17:59:41.573', 'LastEditDate': '2012-10-16T07:23:36.440', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3095', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-10-16T06:03:14.447', 'Id': '6103'},22_82:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been trying to implement Brzozowski's algorithm but I've just discovered that it creates suboptimal automata for a certain class of inputs, having one more state than what is really needed in the result. I can show it on a trivial automaton:</p>\n\n<pre><code>   a b           a   b           a b            a     b            a b\n&gt;0 0 1  rev  *0 0,2  -   det  &gt;0 - 1  rev  *0   -     -    det  &gt;0 1 2\n 1 1 2  --&gt;   1  1   0   --&gt;   1 2 5  --&gt;   1   -    0,4   --&gt;   1 1 2\n*2 0 2       &gt;2  -  1,2        2 2 3        2  1,2    -          2 2 3\n                              *3 4 -        3   -     2         *3 1 3\n                              *4 4 1        4  3,4    -          \n                              *5 5 5        5   5    1,5         \n                                           &gt;6 3,4,5 1,2,5        \n</code></pre>\n\n<p>Here <em>rev</em> is the edge reversal part, where I'd already removed the transitions on epsilon, and <em>det</em> is determinization through powerset construction, creating new states as soon as it discovers them, recursively.</p>\n\n<p>The problem here is this: once I add the extra state to make up for the three different start states after the first edge reversal and powerset construction, nothing ever returns to that state and thus I can't get rid of it later for being equivalent to the original start state.</p>\n\n<p>Is there something wrong with the way I'm doing it? Am I missing something?</p>\n", 'ViewCount': '136', 'Title': "Problem with implementing Brzozowski's algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-18T15:29:53.410', 'LastEditDate': '2012-10-18T06:29:58.037', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6152', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4237', 'Tags': '<algorithms><automata><finite-automata>', 'CreationDate': '2012-10-17T22:23:04.570', 'Id': '6138'},22_83:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Let the input alphabet be $\\Sigma = \\{a,b,c\\}$ and <em>L</em> be the language of all words in which all of the <em>a</em>\u2019s come before all of the <em>b</em>\u2019s and there are the same number of <em>a</em>\u2019s as <em>b</em>\'s and arbitrarily many <em>c</em>\u2019s that can be in front, behind or among the <em>a</em>\u2019s and <em>b</em>\u2019s. \nSome words in <em>L</em> are: <em>abc ccacaabcccbccbc</em></p>\n\n<p>I know that the language is not regular but how can I find a deterministic PDA (in a drawing fashion) that accepts <em>L</em>?</p>\n\n<p>Edit: So far I\'ve ended up with this which takes care of having the same number of a\'s as b\'s and all a\'s come before all b\'s. However I cannot figure out how to account for the arbitrary amount of c\'s in-between b\'s. Any ideas? <img src="http://i.stack.imgur.com/Daoc6.png" alt="enter image description here"></p>\n\n<p>Sorry for the horrible drawing in advance.</p>\n', 'ViewCount': '375', 'LastEditorDisplayName': 'user3115', 'Title': 'Constructing deterministic PDA for not regular language', 'LastActivityDate': '2012-10-23T08:29:47.877', 'LastEditDate': '2012-10-23T06:42:33.347', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '6240', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><pushdown-automata>', 'CreationDate': '2012-10-22T19:53:24.143', 'Id': '6239'},22_84:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '209', 'Title': 'If $L$ is a regular language, how to prove $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$ is also regular?', 'LastEditDate': '2013-04-07T12:25:29.787', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3146', 'FavoriteCount': '2', 'Body': "<blockquote>\n  <p>If $L$ is a regular language, prove that the language\n  $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$\n  is also regular.</p>\n</blockquote>\n\n<p>My idea: $L$ can be represented as a DFA and then you could add 2 consecutive transitions from every final state for the letters of $v$, creating a new NFA diagram. Is that correct? I'm not sure how to make this a formal proof.</p>\n", 'Tags': '<regular-languages><automata><finite-automata><closure-properties><check-my-answer>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:25:29.787', 'CommentCount': '3', 'AcceptedAnswerId': '6281', 'CreationDate': '2012-10-24T05:09:01.860', 'Id': '6279'},22_85:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/454/list-of-intro-tcs-books-for-those-who-dont-know-much-about-tcs">List of intro TCS books for those who don\u2019t know much about TCS</a>  </p>\n</blockquote>\n\n\n\n<p>Im taking a course on Theoretical  computer Science. and I use Sipser\'s <code>Introduction to Theory of Computation</code> as my reference manual. However, many times I find myself lost in the proofs. Ive tried following Shai Simpson\'s online lectures ,but would prefer something more watered down and easier to understand. Im open to any pointers/strategies or resources.</p>\n', 'ViewCount': '26', 'ClosedDate': '2012-10-28T11:21:15.400', 'Title': 'Supporting material for theory of computation', 'LastActivityDate': '2012-10-28T10:24:58.260', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1510', 'Tags': '<automata>', 'CreationDate': '2012-10-28T10:24:58.260', 'Id': '6353'},22_86:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Show that $L_2=\\{a^nb^k|n\\not= k-1\\}$ is not regular by Pumping Lemma.</p>\n', 'ViewCount': '38', 'ClosedDate': '2012-10-31T06:35:19.720', 'Title': 'Show that a language is not regular by Pumping Lemma', 'LastActivityDate': '2012-10-31T05:13:17.603', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3146', 'Tags': '<formal-languages><automata><regular-languages><pumping-lemma>', 'CreationDate': '2012-10-31T05:13:17.603', 'Id': '6400'},22_87:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am doing self study from <a href="http://www.myoops.org/twocw/mit/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-042JFall-2005/3970D151-BFD3-4181-81CD-804F109B3AC2/0/ln7.pdf" rel="nofollow">MIT OCW exercises</a> and I could not understand this question.</p>\n\n<blockquote>\n  <p>The following rules define the <em>binary-GCD state machine</em> working on states in $\\mathbb{N}^3$ with start state $(a,b,1)$ for $a&gt;b&gt;0$. If multiple rules apply, smaller numbers have precedence.</p>\n  \n  <p>Provided $\\min(x,y) &gt;0$, then $(x,y,e) \\to $</p>\n  \n  <ol>\n  <li>$(1,0,ex)$ if $x=y$</li>\n  <li>$(1,0,e)$ if $y=1$</li>\n  <li>$(x/2,y/2,2e)$ if $2|x \\land 2|y$</li>\n  <li>$(y,x,e)$ if $y&gt;x$</li>\n  <li>$(x,y/2,e)$ if $2|y$</li>\n  <li>$(x/2,y,e)$ if $2|x$</li>\n  <li>$(x-y,y,e)$ otherwise</li>\n  </ol>\n</blockquote>\n\n<p>The binary-GCD state machine computes the GCD of $a$ and $b$ using only division by $2$ and subtraction, which makes it run very efficiently on hardware that uses binary representation of numbers. In practice, it runs more quickly than the Euclidean algorithm state machine.</p>\n\n<p>Each execution of a command (one of rules 1-7 according to algorithm) is a transition and the current state $(x,y,e)$ is stored in registers $A,B,E$. At first the values in the registers $a,b,1$</p>\n\n<p>Here is the question I am having trouble with:</p>\n\n<blockquote>\n  <p>Prove that the machine reaches a final state in at most $3+2\\log(\\max(a,b))$\n  transitions.</p>\n  \n  <p><strong>Hint:</strong> Strong induction on $\\max(a,b)$ </p>\n</blockquote>\n\n<ul>\n<li><p>First, why does this state machine assume it halves the $\\max(a,b)$ at every two transitions beacuse we can apply rule 4 and 7 and one extra rule to halve the $\\max(a,b)$, which is more than two transitions/steps. I know it is not a common case but a case is a case unless proved.</p></li>\n<li><p>Next I don\'t see where an extra 3 comes from in $3+2\\log(\\max(a,b))$.  </p></li>\n</ul>\n', 'ViewCount': '129', 'Title': 'Runtime of the binary-GCD state machine', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T04:01:55.783', 'LastEditDate': '2012-10-31T23:35:29.357', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4413', 'Tags': '<algorithms><finite-automata><proof-techniques>', 'CreationDate': '2012-10-31T17:37:32.330', 'FavoriteCount': '0', 'Id': '6404'},22_88:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a beginners question. I and reading the book "Introduction to Computer Theory" by Daniel Cohen. But I end up with confusion regarding simplification of regular expressions and finite automata. I want to create an FA for the regular expression</p>\n\n<p>$\\qquad \\displaystyle (a+b)^* (ab+ba)^+a^+\\;.$</p>\n\n<p>My first question is that how we can simplify this expression? Can we we write the middle part as $(ab+ba)(ab+ba)^*$? will this simplify the expression?</p>\n\n<p>My second question is whether the automaton given below is equivalent to this regular expression? If not, what is the mistake?</p>\n\n<p><img src="http://i.stack.imgur.com/m4Agi.png" alt="enter image description here"></p>\n\n<p>This is not a homework but i want to learn this basic example. And please bear me as a beginner.</p>\n', 'ViewCount': '996', 'Title': 'Simplification of regular expression and conversion into finite automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T17:25:30.637', 'LastEditDate': '2012-11-02T10:10:37.237', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '6450', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<formal-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-11-02T08:12:01.797', 'Id': '6443'},22_89:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I\'ve been scratching my head over this problem for a couple of days now.  Given some language $A$ and $B$ that is regular, show that the language $L$ which consists of all strings in $A$ whose length is equal to some string in $B$ is a regular language.</p>\n\n<p>In equation form:</p>\n\n<p>$$L = \\{x \\in A \\mid \\exists y \\in B \\text{ s.t. } |x| = |y| \\}$$</p>\n\n<p>My initial thought was to try and come up with some DFA for both languages $A$ and $B$ and map the two states to each other and hopefully get a 1:1 ratio that way I can generate a new DFA which proves that $L$ is regular.  But then I realized that $A$ and $B$ don\'t have to be over the same set of symbols.  </p>\n\n<p>I think the correct way to solve this is to use the closure properties of regular language, but I\'m not sure of how to begin/use the properties for "lengths" of strings instead of strings themselves.  </p>\n\n<p>Could someone point me in the right direction?</p>\n', 'ViewCount': '255', 'Title': 'Proving the language which consists of all strings in some language is the same length as some string in another language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-08T04:07:41.613', 'LastEditDate': '2012-11-05T08:20:14.120', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4463', 'Tags': '<formal-languages><regular-languages><finite-automata><proof-techniques><closure-properties>', 'CreationDate': '2012-11-05T05:52:51.367', 'Id': '6484'},22_90:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have some questions regarding acceptance of a language by DFA</p>\n\n<ol>\n<li>Whether more that one dfa accept a language  </li>\n<li>Whether a dfa can accept more than one language</li>\n</ol>\n', 'ViewCount': '305', 'Title': 'Language acceptance by DFA', 'LastActivityDate': '2012-11-10T02:32:03.653', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '6594', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><regular-languages><finite-automata>', 'CreationDate': '2012-11-10T01:29:26.060', 'Id': '6590'},22_91:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '533', 'Title': 'How do I show that whether a PDA accepts some string $\\{ w!w \\mid w \\in \\{ 0, 1 \\}^*\\}$ is undecidable?', 'LastEditDate': '2012-11-12T11:36:31.860', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2860', 'FavoriteCount': '1', 'Body': "<p>How do I show that the problem of deciding whether a PDA accepts some string of the form $\\{ w!w \\mid w \\in \\{ 0, 1 \\}^*\\}$ is undecidable?</p>\n\n<p>I have tried to reduce this problem to another undecidable one such as whether two context-free grammars accept the same language. However, I'm not sure how to use it as a subroutine.</p>\n", 'Tags': '<formal-languages><automata><context-free><undecidability><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-23T22:02:29.330', 'CommentCount': '0', 'AcceptedAnswerId': '6630', 'CreationDate': '2012-11-12T05:00:51.627', 'Id': '6626'},22_92:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m currently working on this question as part of some homework, it has me stumped.</p>\n\n<p><img src="http://i.stack.imgur.com/taFpH.png" alt="FSA Question"></p>\n\n<p>I\'m familiar with finite state automata (FSA), I know how they work and I\'ve read everything I can find on Google, but nothing\'s helped me come any closer to a solution.</p>\n\n<p>If I don\'t know the length of the input string, or I\'m not searching for a particular pattern, how can I design a machine that will always land on the final state? </p>\n\n<p>I\'ve tried drawing some, but that always end up being a little off. </p>\n', 'ViewCount': '71', 'Title': 'Finite State Automata for recognising consecutive characters', 'LastEditorUserId': '1636', 'LastActivityDate': '2012-11-17T09:02:53.670', 'LastEditDate': '2012-11-17T09:02:53.670', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6709', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4623', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2012-11-17T05:05:50.290', 'Id': '6704'},22_93:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I gotta make a CFG and PDA for the grammar that has perfectly nested parentheses and brackets.</p>\n\n<p>$\\qquad\\begin{align}\n S &amp;\\to [S] \\\\\n S &amp;\\to (S) \\\\\n S &amp;\\to SS \\\\\n S &amp;\\to \\varepsilon\n\\end{align}$</p>\n\n<p>Not sure if this is correct, or how to make the PDA from it?</p>\n', 'ViewCount': '219', 'Title': 'CFG and PDA for the grammar that has perfectly nested parentheses and brackets', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T18:12:47.330', 'LastEditDate': '2012-11-19T18:12:47.330', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4632', 'Tags': '<formal-languages><automata><formal-grammars><context-free><pushdown-automata>', 'CreationDate': '2012-11-17T18:39:11.147', 'Id': '6719'},22_94:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m constructing a <a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton" rel="nofollow">deterministic finite automata</a> (DFA) for a language of all strings defined over $\\{0,1\\}$ whose length is even and number of $1$s is odd. I constructed each DFA separately and then combined:</p>\n\n<p><img src="http://i.stack.imgur.com/rKHhw.png" alt="dfas and their union"></p>\n\n<ul>\n<li>Is the given procedure for combining DFAs correct?<br>\n<strong>EDIT:</strong> Originally wrote union; actually taking the intersection.</li>\n<li>Would someone suggest material on constructing DFAs<br>\ngiven restrictions on length and number of $0$s or $1$s?</li>\n</ul>\n\n<p>According to link given by Merbs, I have developed this FA. <img src="http://i.stack.imgur.com/ZMnEl.png" alt="enter image description here"> <br/> This FA does not accept a language of even length.</p>\n', 'ViewCount': '1097', 'Title': 'Is this intersection of DFAs correct?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:12:19.483', 'LastEditDate': '2013-05-24T03:12:19.483', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '7108', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<automata><regular-languages><finite-automata>', 'CreationDate': '2012-11-25T19:04:26.350', 'Id': '6893'},22_95:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m currently studying for an exam for a course where some of the material covered included finite state automata, I\'ve completed a question and I\'m not sure about my answer.</p>\n\n<p><strong>Question</strong>\n<a href="http://i.stack.imgur.com/vDFax.png" rel="nofollow">http://i.stack.imgur.com/vDFax.png</a></p>\n\n<p><strong>My Answer</strong>\n<a href="http://i.stack.imgur.com/rSnEv.png" rel="nofollow">http://i.stack.imgur.com/rSnEv.png</a></p>\n\n<p>Are multiple completion states allowed?</p>\n', 'ViewCount': '186', 'Title': 'Finite state automata, multiple completion states?', 'LastActivityDate': '2012-11-27T00:06:05.017', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6935', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4623', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-11-26T23:33:22.737', 'Id': '6934'},22_96:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to figure out how a pushdown automata (PDA), which we know uses a stack (LIFO) can be simulated by a queue (FIFO). I understand that in a regular PDA, we only have access to the top most element which can be popped. When we push something, it goes to the top of the stack. </p>\n\n<p>In a queue, as I understand, elements get "pushed" to the top, but pop from the bottom. Thus, first in first out. </p>\n\n<p>In a stack (LIFO) PDA, let\'s say we push \'a\'. It\'s at the top of the stack, and when we pop, we pop \'a\' since it is at the top. </p>\n\n<p>In a queue (FIFO) PDA, when we push \'a\', it is at the top, but when we pop, it will be from the bottom of the queue and thus it will not be \'a\' (assuming the size is greater than 2).</p>\n\n<p>So how can we simulate a regular PDA which uses a stack, with a FIFO (queue) PDA?</p>\n', 'ViewCount': '401', 'Title': 'How can one simulate a PDA with a FIFO queue PDA?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-29T16:46:40.480', 'LastEditDate': '2012-11-29T16:46:40.480', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7004', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4767', 'Tags': '<automata><pushdown-automata><machine-models>', 'CreationDate': '2012-11-29T00:21:40.543', 'Id': '7003'},22_97:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for a proof for the following problem:</p>\n\n<blockquote>\n  <p>For languages $L$ and $R$, if $L$ is <a href="http://en.wikipedia.org/wiki/Deterministic_context-free_language" rel="nofollow">deterministic context-free</a>\n  and $R$ is regular, then $LR$ is a deterministic context-free\n  language.</p>\n</blockquote>\n\n<p>Note: $RL$ may not satisfy this condition, e.g. if $L=\\{wcw^R\\mid w\\in (a|b)^*\\}$, and $R=\\{a\\}^*$.</p>\n', 'ViewCount': '316', 'Title': 'Deterministic context-free languages are closed under regular right-product', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-30T20:19:21.433', 'LastEditDate': '2012-11-30T20:19:21.433', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4486', 'Tags': '<formal-languages><context-free><closure-properties><pushdown-automata>', 'CreationDate': '2012-11-30T10:53:41.263', 'Id': '7041'},22_98:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In my studies in computability I have come across the notion of the "machine", an abstract representation of a device that essentially computes. I have read about Turing Machines and Wolfram\'s binary cellular automata and I understand them.ie. the rules, states, colours, etc. and how they work. They begin in some state and run forever(unless a terminating state is specified). The point I\'m trying to make here is that they receive no external input and are essentially functions of themselves:their current state is some function of its starting state, unlike realistic computers.</p>\n\n<p>For the above reasons I\'d like to know why automata are used to represent computers. More generally how can a machine be used to represent a computation?</p>\n', 'ViewCount': '81', 'Title': 'How does an automaton actually "compute"?', 'LastActivityDate': '2012-11-30T13:51:34.223', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '802', 'Tags': '<computability><automata><cellular-automata>', 'CreationDate': '2012-11-30T11:26:36.597', 'Id': '7042'},22_99:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1168', 'Title': 'Construct a PDA for the complement of $a^nb^nc^n$', 'LastEditDate': '2013-11-20T12:31:53.400', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4886', 'FavoriteCount': '1', 'Body': "<p>I am wondering if this is even possible, since $\\{a^n b^n c^n  \\mid n \\geq 0\\} \\not\\in \\mathrm{CFL}$. Therefore a PDA that can distinguish a word $w\\in\\{a^n b^n c^n  \\mid n \\geq 0\\}$ from the rest of $\\{a^*b^*c^*\\}$ might as well accept it, which sounds contradictory to me.</p>\n\n<p>I guess I need to take advantage of the non-deterministic nature of PDAs but I'm out of ideas. If you could offer some advice I would very much appreciate it.</p>\n", 'Tags': '<formal-languages><automata><context-free><pushdown-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-20T12:31:53.400', 'CommentCount': '3', 'AcceptedAnswerId': '7191', 'CreationDate': '2012-12-05T18:20:04.433', 'Id': '7190'},22_100:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Do there exist robust structures in <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life" rel="nofollow">Conway\'s Game of Life</a>?  For instance, has anyone constructed a spaceship with a shield that absorbs all small oscillators and gliders it collides with? </p>\n', 'ViewCount': '166', 'Title': "Cell walls in Conway's Game of Life?", 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-07T21:12:06.567', 'LastEditDate': '2012-12-07T21:12:06.567', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4909', 'Tags': '<cellular-automata>', 'CreationDate': '2012-12-07T02:45:18.350', 'Id': '7222'},22_101:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This language I think is not accepted by a deterministic one counter but accepted by a non-deterministic one counter :</p>\n\n<p>$L = \\{a^{i}b^{j}c^{k} \\mid (i=j) \\vee (j=k) \\text{ such that } i\\geq0, j\\geq0, k\\geq0\\}$</p>\n\n<p>But how to prove this claim?</p>\n\n<p>Or is it the case that they are equivalent?</p>\n', 'ViewCount': '246', 'Title': 'is determinism = non determinism for one counter automata?', 'LastEditorUserId': '3011', 'LastActivityDate': '2012-12-11T21:43:14.437', 'LastEditDate': '2012-12-10T10:38:24.243', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7295', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4980', 'Tags': '<automata>', 'CreationDate': '2012-12-10T04:59:00.853', 'Id': '7286'},22_102:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I can understand that they are not closed under concatenation because without non determinism, PDA cannot decide whether to loop in the first PDA or jump to the next one.\nBut can someone prove this with an example. Also prove that the resulting language cannot be accepted by DPDA</p>\n', 'ViewCount': '324', 'Title': 'why are deterministic PDAs not closed under concatenation?', 'LastActivityDate': '2013-06-04T15:56:26.980', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7326', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4980', 'Tags': '<automata><pushdown-automata>', 'CreationDate': '2012-12-11T12:49:25.547', 'Id': '7325'},22_103:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two regular languages $L_1$ and $L_2$, we define a new language </p>\n\n<p>$$L=\\{w_1w_2\\mid \\text{ there exist two words } x,y \\text{ such that } xw_1\\in L_1, w_2y\\in L2\\}$$</p>\n\n<p>How do I show that $L$ is regular with equivalence classes?</p>\n\n<p>My assignment allows the use of closure properties that all regular languages hold, but I cannot use $\\text{rank} (L)$, as in show a limit to the number of equivalence class.</p>\n\n<p>Can someone lead me in the right direction? </p>\n', 'ViewCount': '214', 'Title': 'Proving regularity via equivalence classes', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-19T05:17:59.307', 'LastEditDate': '2012-12-15T21:16:08.037', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5074', 'Tags': '<automata><regular-languages><finite-automata><proof-techniques>', 'CreationDate': '2012-12-15T20:27:22.903', 'FavoriteCount': '1', 'Id': '7419'},22_104:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to create a DFA that can recognize strings with alphabet $\\{a,b,c\\}$ where $a$ and $c$ appear even number of times and where $b$ appears odd number of times.</p>\n\n<p>I am wondering that this may only be expressed with other methods such as Turing machine or context-free languages.</p>\n\n<p>You might find it fun to think of the solution.</p>\n', 'ViewCount': '199', 'Title': 'Does this DFA have a solution?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-16T16:29:32.997', 'LastEditDate': '2012-12-16T16:29:32.997', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7430', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5079', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-12-16T04:36:17.710', 'Id': '7429'},22_105:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '447', 'Title': 'Which languages are recognized by one-counter machines?', 'LastEditDate': '2012-12-24T01:10:01.373', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2131', 'FavoriteCount': '1', 'Body': '<p><strong><a href="http://en.wikipedia.org/wiki/Counter_machine">Counter machines</a></strong> with two or more counters are typically shown to be equivalent to Turing machines in courses on the theory of computation.  However, I have not seen a formal analysis of which languages can be recognized by a one-counter machine.  Are these languages equivalent to the context-free languages (perhaps by some clever construction relating them to PDAs), or are they an entirely different class of languages?</p>\n', 'Tags': '<computability><automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-24T22:14:55.497', 'CommentCount': '1', 'AcceptedAnswerId': '7575', 'CreationDate': '2012-12-24T00:20:48.480', 'Id': '7574'},22_106:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need some help with the following problem: $L$ - regular language and i have to prove that the language $P$ = {$\\alpha$| $\\beta\\alpha\\gamma \\in L$, $\\beta,\\gamma \\in (A)^*$} is regular. In other words $P$ is the language of all parts of words from $L$.   </p>\n\n<p>Thanks a lot!</p>\n', 'ViewCount': '66', 'Title': u'Regularity of \u201cmiddles\u201d of words from regular language', 'LastEditorUserId': '3011', 'LastActivityDate': '2012-12-24T22:25:40.707', 'LastEditDate': '2012-12-24T22:25:40.707', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7589', 'Score': '1', 'OwnerDisplayName': 'user54060', 'PostTypeId': '1', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2012-12-23T11:59:42.723', 'Id': '7588'},22_107:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need help with the following question:</p>\n\n<p>Order the following formalisms according to their expressive power:\nplacing A before B means that any language definable by A is definable\nby B. Also state which, if any, of them are equivalent.</p>\n\n<pre><code>\u2022 Turing Machines (TM)\n\u2022 Regular expressions (reg.exp.)\n\u2022 Turing Machines with multiple tapes (TM+)\n\u2022 Pushdown Automata (PDA)\n\u2022 Nondeterministic Finite Automata with \u01eb-transitions (NFA\u01eb)\n\u2022 Nondeterministic Finite Automata (NFA)\n\u2022 LR(1) grammars\n\u2022 Nondeterministic Turing Machines (NTM)\n\u2022 Deterministic Pushdown Automata (DPDA)\n\u2022 Deterministic Finite Automata (DFA)\n\u2022 Context-free Grammars (CFG)\n</code></pre>\n\n<p>Is this the correct answer ? I have a exam next week and need to know If my answer is correct.</p>\n\n<pre><code>NFAe=NFA=DFA=Reg.exp, LR(1)-Grammar=DPDA, CFG=PDA, TM=NTM=TM+\n</code></pre>\n\n<p>Thanks in advance </p>\n', 'ViewCount': '173', 'Title': 'Formal Languages - Expressive power of Formalisms', 'LastActivityDate': '2013-01-01T22:35:50.987', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7683', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><regular-languages><context-free><regular-expressions><pushdown-automata>', 'CreationDate': '2013-01-01T22:22:24.913', 'Id': '7682'},22_108:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a problem finding the right string to pump for the following language:</p>\n\n<p>$$L_1 = \\{a^{p+q}b^rc^sd^{q+r}e^s \\mid p, q, r, s \\ge 0\\}$$</p>\n\n<p>Which string should I choose to pump? The problem is that I don't know how to handle the fact that I have $p+q$ and $q+r$?</p>\n\n<p>Can I choose:\n$$Z = a^{2n}b^nc^nd^{2n}e^s$$</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '126', 'Title': 'Pumping lemma problem - Choosing the right string to pump', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-04T09:46:44.527', 'LastEditDate': '2013-01-04T09:28:43.907', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7752', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><automata><context-free><pumping-lemma>', 'CreationDate': '2013-01-04T09:22:51.140', 'Id': '7751'},22_109:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1416', 'Title': 'Explaining why a grammar is not LL(1)', 'LastEditDate': '2014-01-04T15:36:22.460', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'FavoriteCount': '1', 'Body': u'<p>I need some help with explaining why a grammar is not LL(1).</p>\n\n<p>Let us take the following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp; aB \\mid bA \\mid \\varepsilon \\\\\nA \\rightarrow &amp; aS \\mid bAA \\\\\nB \\rightarrow &amp; b \\\\\n\\end{align}\n$$</p>\n\n<p>This is my attempt:</p>\n\n<p>For the grammar to be LL(1) it is a necessary condition that for any strings $c_1\u03b3$ and $c_2\u03b2$, derivable from $S \\rightarrow aB$ and $A \\rightarrow aS$ respectively, we have $c_1 \\ne c_2$. </p>\n\n<p>But, $S \\rightarrow aB$ and $A \\rightarrow aS$, hence $c_1 = c_2$ and the grammar is not LL(1).</p>\n\n<p>Is my reasoning right?</p>\n\n<p>Thanks in advance.</p>\n', 'Tags': '<formal-languages><regular-languages><context-free><pushdown-automata>', 'LastEditorUserId': '10637', 'LastActivityDate': '2014-01-04T15:36:22.460', 'CommentCount': '1', 'AcceptedAnswerId': '7789', 'CreationDate': '2013-01-04T16:14:19.883', 'Id': '7761'},22_110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need some help with the following question:</p>\n\n<p>One of the languages</p>\n\n<p>$$L_1 = \\{a^pb^{q+r}c^sd^{q+t}e^{p+r} \\mid p, q, r, s \\ge 0\\ , s &gt; t\\}$$\n$$L_2 = \\{a^{p+q}b^rc^sd^{q+r}e^s \\mid p, q, r, s \\ge 0\\}$$</p>\n\n<p>is context-free and the other is not. Build a context-free grammar for the one that is. For the other one provide a proof that it is not regular, or that it is not context-free.</p>\n\n<p>How do I approach this problem ? I think that L2 is context-free because no comparisions are made. L1 is not context-free. </p>\n\n<p>Thanks in advance </p>\n', 'ViewCount': '100', 'Title': 'Pumping lemma problem', 'LastActivityDate': '2013-01-04T20:59:08.373', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7770', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><automata><context-free><pumping-lemma>', 'CreationDate': '2013-01-04T19:08:16.647', 'Id': '7767'},22_111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need to design a Turing Machine that accepts the (context-free) language: $L(M)=\\{0^{n}1^{n+1}: n\\ge1$}.</p>\n\n<p>$$Q=\\{q_0,q_1,q_2,q_3,q_4\\} ,\u03a3 = \\{0,1\\}, \u0393 =\\{0,1,X,Y,B\\}, F=\\{q_4\\}$$</p>\n\n<p>X- processed 0<br>\nY- processed 1<br>\nB- blank<br>\nP-move right<br>\nL-move left<br>\nSo far I\'ve succeeded to create a table for languages $\\{0^n1^n\\}$(without the red entry) and $\\{0^n1^k:k\\ge n\\}$.</p>\n\n<p><img src="http://i.stack.imgur.com/NNJCd.jpg" alt="&quot;P&quot; means the right side"></p>\n\n<p>What should it look for case in which there is minimal superiority of "1\'s"?</p>\n\n<p>@EDIT</p>\n\n<p>Meanwhile I\'ve finally hit on an idea for <strong>L(M)</strong></p>\n\n<p><img src="http://i.stack.imgur.com/sly5h.jpg" alt="enter image description here">Is it correct?</p>\n', 'ViewCount': '79', 'Title': 'Design the transition function', 'LastEditorUserId': '5206', 'LastActivityDate': '2013-01-11T16:16:58.327', 'LastEditDate': '2013-01-11T16:16:58.327', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5206', 'Tags': '<automata><turing-machines>', 'CreationDate': '2013-01-10T21:00:40.590', 'Id': '7877'},22_112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A true/false question: If a DFA $M$ contains a self-loop on some state $q$, then $M$ must accept an infinite language.</p>\n\n<p>The answer is "false". I\'ve read <a href="http://cs.stackexchange.com/questions/6609/infinite-language-vs-finite-language">this question</a>, but I\'m still wondering why $M$ does not necessarily accept an infinite language. Isn\'t the language $b^*$ infinite? Don\'t all self-loops look like $b^*$?</p>\n', 'ViewCount': '474', 'Title': 'Do self-loops in DFA cause infinite languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-17T13:36:18.223', 'LastEditDate': '2013-01-17T13:36:18.223', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '8983', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-01-17T07:53:01.867', 'Id': '8982'},22_113:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am learning about context free languages. </p>\n\n<p>I understand how $\\{a^n b^n c^n | n \\ge 0\\}$ can be shown to be not context free using the pumping lemma for CFL's.</p>\n\n<p>Intuitively however it seems that a pushdown automata to recognize $\\{a^n b^n c^n | n \\ge 0\\}$ can be constructed. This PDA would initially push two $a$'s into its stack whenever it sees an $a$ in the input. It would change state when it first encounters a $b$ and pop a single $a$. It would continue to pop $a$'s for every b in the input until it encounters a $c$. It would again change state and pop single $a$'s for every c encountered. If the stack is empty at the end of the input the language is recognized as $\\{a^n b^n c^n | n \\ge 0\\}$.</p>\n\n<p>There must be something I am overlooking whilst constructing the PDA as a language is context free if its has a PDA recognizing it. Please point out my mistake.</p>\n", 'ViewCount': '693', 'Title': 'Push down automata for $\\{a^n b^n c^n | n \\ge 0\\}$', 'LastActivityDate': '2013-01-17T14:04:47.477', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '8990', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<context-free><pushdown-automata><pumping-lemma>', 'CreationDate': '2013-01-17T13:57:17.883', 'Id': '8989'},22_114:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>First, I have tried to build a DFA over the alphabet $\\sum = \\{0,\\dots, 9\\}$ that accepts all decimal representations of natural numbers divisible by 3, which is quite easy because of the digit sum. For this I choose the states $Q = \\mathbb{Z}/3\\mathbb{Z}\\cup\\{q_0\\}$ ($q_0$ to avoid the empty word), start state $q_0$, accept states $\\{[0]_3\\}$ and $\\delta(q, w) =\\begin{cases} [w]_3 &amp;\\mbox{if } q = q_0 \\\\\n[q + w]_3 &amp; \\mbox{else } \\end{cases}$</p>\n\n<p>Of course, it doesn't work that way for natural numbers divisible by 43. For 43 itself, I would end in $[7]_{43}$, which wouldn't be an accepting state. Is there any way I can add something there or do you have other suggestions on how to do this? Thanks.</p>\n", 'ViewCount': '486', 'Title': 'DFA that accepts decimal representations of a natural number divisible by 43', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-20T15:16:39.223', 'LastEditDate': '2013-01-20T15:13:05.993', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'Zlatansbraten', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-01-19T23:50:17.853', 'FavoriteCount': '1', 'Id': '9049'},22_115:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The basic idea is to have one or more symbol that clearly indicate the end. For example:</p>\n\n<p>Non-ambiguous:</p>\n\n<blockquote>\n  <p>$ab^*c$<br>\n  $(a|b)c$<br>\n   $ab^+c$<br>\n   $ab?c$<br>\n   $a(b|c)$<br>\n   $c(ab)^*ccc$<br>\n   $acc^*d$<br>\n   $abc|bcd$  </p>\n</blockquote>\n\n<p>Ambiguous:</p>\n\n<blockquote>\n  <p>$abc^*$<br>\n  $abc^+$<br>\n  $abc?$<br>\n  $acc^*$ or $ac^*c$</p>\n</blockquote>\n\n<p>An alternative definition of a non-ambiguous ending would be that the corresponding DFA can have multiple final states, but none of them can have a outgoing transition.</p>\n', 'ViewCount': '194', 'Title': 'Is there a name/interest for regular languages that have a non-ambiguous ending?', 'LastEditorUserId': '1053', 'LastActivityDate': '2013-01-25T16:19:20.677', 'LastEditDate': '2013-01-25T15:20:19.237', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9094', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1053', 'Tags': '<regular-languages><finite-automata><regular-expressions><ambiguity>', 'CreationDate': '2013-01-22T12:50:22.110', 'Id': '9091'},22_116:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '504', 'Title': 'Prove that the language of unary not-prime numbers satisfies the Pumping Lemma', 'LastEditDate': '2013-01-24T06:32:08.353', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6518', 'FavoriteCount': '1', 'Body': "<p>Here is a question from Daniel I. A. Cohen's book <em>Introduction to Computer Theory</em>:</p>\n\n<blockquote>\n  <p>Consider the language:  </p>\n  \n  <p>$\\quad \\mathrm{PRIME}' = \\{ a^n \\mid n \\text{ is not a prime} \\} = \\{ \\varepsilon, a, aaaa, aaaaaa, aaaaaaaa, \\ldots \\}$</p>\n  \n  <ol>\n  <li>Prove that $\\mathrm{PRIME}'$ is non-regular.  </li>\n  <li>Prove, however, that $\\mathrm{PRIME}'$ does satisfy the pumping lemma.  </li>\n  </ol>\n</blockquote>\n\n<p>Part 1. is really easy to prove. I start my proof of part 2. like this:</p>\n\n<ol>\n<li>We pick $m$ s.t. $m \\geq 4$.  </li>\n<li>The opponent picks $w = a^{n^2}$, where $n$ is any prime number greater than m.</li>\n</ol>\n\n<p>Now I don't know how to decompose $w$ into $xyz$. Any help would be appreciated.</p>\n\n<hr>\n\n<p><strong>Update</strong>: According to the answers below, $\\mathrm{PRIME}'$ doesn't satisfy the Pumping Lemma we commonly talk about (requiring $|xy| \\leq m$). I have checked the book at the library and found there are two versions of the Pumping Lemma in it. The weaker one, which clearly this question refers to, doesn't require a fixed pumping length.</p>\n", 'Tags': '<formal-languages><automata><pumping-lemma>', 'LastEditorUserId': '6518', 'LastActivityDate': '2013-01-25T16:18:09.903', 'CommentCount': '2', 'AcceptedAnswerId': '9108', 'CreationDate': '2013-01-23T08:42:08.650', 'Id': '9104'},22_117:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '140', 'Title': 'Testing whether the language of one automaton is a subset of another', 'LastEditDate': '2013-01-25T11:32:27.240', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Jendas', 'PostTypeId': '1', 'OwnerUserId': '6541', 'Body': '<p>Is there an algorithm to solve following problem?</p>\n\n<p>Given two finite automata $A$ and $B$. Determine whether the language recognized by automaton $A$ is a subset of language recognized by automaton $B$ or otherwise.</p>\n', 'Tags': '<automata><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T11:32:27.240', 'CommentCount': '1', 'AcceptedAnswerId': '9131', 'CreationDate': '2013-01-24T11:28:05.360', 'Id': '9130'},22_118:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '370', 'Title': "How come {ww} isn't regular when {uv | |u|=|v|} is?", 'LastEditDate': '2013-01-26T19:42:01.027', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'henry', 'PostTypeId': '1', 'OwnerUserId': '6576', 'Body': u'<p>As we know, using the pumping lemma, we can easily prove the language $L = \\{ w w \\mid w \\in \\{a,b\\}^* \\}$ is not a regular language.</p>\n\n<p>However, the language $L_1 = \\{ w_1 w_2 \\mid |w_1| = |w_2| \\}$ is a regular language. Because we can get the DFA like below, </p>\n\n<pre><code>DFA:  \n\n--\u25ba((even))------a,b---------\u25ba(odd)  \n      \u25b2                         |  \n      |--------a,b--------------| \n</code></pre>\n\n<p>My question is, $L = \\{ w w \\mid w \\in \\{a,b\\}^* \\}$ also has the even length of strings ($|w|=|w|$, definitely), so $L$ still can have some DFA like the one above. How come is it not a regular language?</p>\n', 'Tags': '<regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-27T05:20:46.897', 'CommentCount': '5', 'AcceptedAnswerId': '9176', 'CreationDate': '2013-01-26T16:53:57.553', 'Id': '9175'},22_119:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1104', 'Title': 'Can we say DFA is more efficient than NFA?', 'LastEditDate': '2013-05-17T04:01:16.283', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'avi', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Body': "<p>I just started reading about theory of computation. If we compare which is more powerful (in accepting strings), both are same. But what about efficiency ? DFA will be fast compared to NFA, since it has only one outgoing edge &amp; there will be no ambiguity. But in case of NFA we have to check all possible cases &amp; that surely takes time. So can we say DFA is more efficient than NFA ? </p>\n\n<p>But, my other part of brain is also thinking that NFA exists only in theory, so we cannot compare it's efficiency with DFA. </p>\n", 'Tags': '<finite-automata><efficiency><nondeterminism>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-17T07:39:06.093', 'CommentCount': '0', 'AcceptedAnswerId': '9393', 'CreationDate': '2013-02-01T14:42:41.990', 'Id': '9389'},22_120:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Speaking in terms of automata and regular languages, how would it be possible for a string repeating some $w$ twice equal a string repeating that same $w$ thrice? That is, why is the language</p>\n\n<p>$\\qquad L = \\{w \\in \\Sigma^ * \\mid ww = www\\}$</p>\n\n<p>not empty? The only thing I can think of is $w = abab, ww = abababab, www = abababababab$, but I don't think this is correct.</p>\n", 'ViewCount': '5901', 'Title': 'How can $ww = www$ hold for any word $w$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:49:11.747', 'LastEditDate': '2013-02-02T13:49:11.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '9401', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-02-01T16:48:32.013', 'Id': '9396'},22_121:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Recall that a language is $\\omega$-regular if and only if it is recognized by a B\xfcchi automaton. How can I prove that</p>\n\n<p>$\\qquad (E_1 + E_2).F^\\omega$</p>\n\n<p>is equivalent to</p>\n\n<p>$\\qquad {E_1.(F^\\omega)+E_2.(F^\\omega)}$</p>\n\n<p>where  </p>\n\n<ul>\n<li>both expressions are <em>omega</em> regular expressions, and  </li>\n<li>$E_1$, $E_2$ and $F$ are <em>arbitrary regular expressions</em> with \n $\\epsilon \\notin L(F)$.  </li>\n</ul>\n\n<p>One way I could think of is to convert expression to a DFA and check\nif it is equivalent.</p>\n\n<p>Or I will really appreciate a hint on how to do the equivalence\nproof, but how to represent $E_1$, $E_2$ and $F$ in DFA.</p>\n', 'ViewCount': '174', 'Title': 'Distributivity of $\\omega$-regular expressions', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-26T13:23:38.430', 'LastEditDate': '2014-01-26T13:23:38.430', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6688', 'Tags': '<regular-expressions><buchi-automata>', 'CreationDate': '2013-02-03T10:32:22.540', 'Id': '9446'},22_122:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I build a finite automaton that accepts only the language of all words in which <code>b</code> is the second letter?</p>\n\n<p>This is my solution so far but I\'m not sure if it\'s correct.</p>\n\n<p><img src="http://i.stack.imgur.com/f5Rcj.gif" alt=""></p>\n', 'ViewCount': '824', 'Title': 'Finite automaton for the language of words whose second letter is b', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-27T17:08:04.247', 'LastEditDate': '2014-03-27T17:08:04.247', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-5', 'PostTypeId': '1', 'OwnerUserId': '6726', 'Tags': '<finite-automata>', 'CreationDate': '2013-02-06T06:03:38.793', 'FavoriteCount': '0', 'Id': '9537'},22_123:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose that we expand our idea of context free grammar rules to allow regular expressions of terminals on the right hand side. For example, consider $G_1$:  </p>\n\n<p>$\\begin{align*}\nS &amp; \\rightarrow (a \\mid b) S (c \\mid d) \\\\\nS &amp; \\rightarrow (a \\mid b) A (c \\mid d) \\\\\nA &amp; \\rightarrow (f \\mid g)^*\n\\end{align*}\n$</p>\n\n<p>Then the language of $G_1$ is the following:<br>\n$$L(G_1) = \\{(a \\mid b)^n (f \\mid g)^* (c \\mid d)^n \\mid n &gt; 0\\}$$</p>\n\n<p>Give a standard CFG that has the same language as $G_1$, is your grammar weakly equivalent to $G_1'$, strongly equivalent to $G_1'$, or both? Why?</p>\n\n<p>Secondly, how can I transform any CFG with regular expressions of terminals on the right hand side to a normal context free grammar?</p>\n", 'ViewCount': '211', 'Title': 'CFG with regular expression terminals on RHS', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-08T17:46:50.903', 'LastEditDate': '2013-02-08T17:27:58.183', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Stefan Widmer', 'PostTypeId': '1', 'Tags': '<regular-expressions><automata>', 'CreationDate': '2013-02-06T16:29:43.277', 'Id': '9602'},22_124:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am taking the <a href="https://class.coursera.org/compilers-selfservice/class/index" rel="nofollow">Coursera class</a> on compilers and in the lesson about lexers it is hinted that there is a time-space tradeoff between using non-deterministic finite automaton (NFA) and deterministic finite automaton (DFA) to parse regular expressions. If I understand correctly, the tradeoff is that a NFA is smaller, but is more time consuming to traverse because all possible states have to be regarded at the same time and therefore it is most of the time transformed into a DFA.  Are there any lexers that use NFAs instead of DFAs in "real"-life i.e. some compiler that is used in production and not a just a proof of concept?</p>\n', 'ViewCount': '200', 'Title': 'Are there real lexers that use NFAs directly instead of first transforming them to DFAs?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-05T19:53:06.097', 'LastEditDate': '2013-04-02T07:28:48.933', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6843', 'Tags': '<automata><finite-automata><compilers><efficiency><nondeterminism>', 'CreationDate': '2013-02-12T17:55:33.023', 'Id': '9708'},22_125:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am learning about automata and finite state machines. Consider the following automaton, that accepts the word 'ab', does not have to be infinite, just once:</p>\n\n<p>alphabet: 'a','b'\nstates: 1,2, 3 (3 is the final state and 1 is the initial state)</p>\n\n<p>transitions:</p>\n\n<pre><code>state 1, symbol a, state 2\nstate 2, symbol b, state 3\n</code></pre>\n\n<p>First part of my questions:</p>\n\n<p>Question 1. Is it required to add self-loops at 1 for 'b', and a self-loop for 'a' at 2?</p>\n\n<p>Question 2. What about at state 3(final)? Should I add self-loops for 'a' and 'b'?</p>\n\n<p>I basically need to know, how to design my final state. So that even if my alphabet was expanded (say a, b, c), and I have a 'dump' state, with the following transitions:</p>\n\n<pre><code>state 1, symbol a, state 2\nstate 1, symbol b or c, state dump\n\nstate 2, symbol b, state 3\nstate 2 symbol a or c, state dump\n</code></pre>\n\n<p>Question 3. Now from final state 3, should I add a transition to dump state, with symbol values a,b,c ???</p>\n\n<p>Your assistance is much appreciated. </p>\n", 'ViewCount': '143', 'Title': 'design of self-loops and final states in fsm', 'LastEditorUserId': '6844', 'LastActivityDate': '2013-02-12T19:48:51.903', 'LastEditDate': '2013-02-12T19:16:08.193', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9713', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6844', 'Tags': '<finite-automata>', 'CreationDate': '2013-02-12T18:53:41.987', 'Id': '9711'},22_126:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do you say $\\delta\\colon Q \\times \\Sigma \\to Q$ in English? Describing what $\\times$" and $\\to$ mean would also help.</p>\n', 'ViewCount': '92', 'Title': u'How does "\u03b4:Q\xd7\u03a3\u2192Q" read in the definition of a DFA (deterministic finite acceptor)?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-02-14T12:56:41.347', 'LastEditDate': '2013-02-14T09:28:07.567', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '9762', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6871', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2013-02-14T07:45:04.143', 'Id': '9761'},22_127:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the book <a href="http://rads.stackoverflow.com/amzn/click/0072322004" rel="nofollow">Introduction to Languages and the Theory of Computation</a>, I\'m reading section 2.6 on how to minimize the number of states in an FA.</p>\n\n<p>I\'m having trouble understanding a notation defined as $L_q$. Here\'s what the book says:</p>\n\n<blockquote>\n  <p>Suppose we have a finite automaton $M = (Q, \\Sigma, q_0, A, \\delta)$ accepting $L \\subseteq \\Sigma^*$. For a state $q$ of $M$, we have introduced the notation $L_q$ to denote the set of strings that cause $M$ to be in state $q$:</p>\n  \n  <p>$$L_q = \\{ x \\in \\Sigma^* | \\delta^*(q_0, x) = q\\}$$.</p>\n  \n  <p>The first step in reducing the number of states of M as much as possible is to eliminate every state $q$ for which $L_q$ = $\\emptyset$, along with transitions from these states. None of these states is reachable from the initial state, and eliminating them does not change the language accepted by $M$.</p>\n</blockquote>\n\n<p>I tried looking at this automaton to try to understand this definition:</p>\n\n<p><img src="http://i.stack.imgur.com/QpfNt.png" alt="enter image description here"></p>\n\n<p>How can any of the states $1$ through $5$ be $L_q = \\emptyset$ if I can find a string that can reach every state for this FA?</p>\n\n<p>That is I can reach state $2$ with string $a$, and state $5$ with string $ab$, etc. Is this a correct way to approach this?</p>\n', 'ViewCount': '57', 'Title': 'How to find $L_q = \\emptyset$, a state that is not reachable for any given string?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-14T20:45:34.953', 'LastEditDate': '2013-02-14T20:45:34.953', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9782', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-02-14T19:47:14.307', 'Id': '9781'},22_128:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a simple problem of making a DFA which accepts all inputs starting with double letters (aa, bb) or ending with double letters (aa, bb), given $\\Sigma =\\{a, b\\}$ is the alphabet set of the given language.</p>\n\n<p>I tried to solve it in a roundabout way by:</p>\n\n<ol>\n<li>Generating a regular expression</li>\n<li>Making its corresponding NFA</li>\n<li>Using powerset construction to deduce a DFA</li>\n<li>Minimizing the number of states in DFA</li>\n</ol>\n\n<p><strong>Step 1:</strong> <em>Regular expression</em> for given problem is (among countless others):</p>\n\n<pre><code>((aa|bb)(a|b)*)|((a|b)(a|b)*(aa|bb))\n</code></pre>\n\n<p><strong>Step 2:</strong> <em>NFA</em> for given expression is:</p>\n\n<p><img src="https://qbcweg.sn2.livefilestore.com/y1pi4Jp5zdZjHEzQ61lYnqZtFu8DQ9B9qS0TyTX2HXh1ZJDDYAmokxBQf4orLezYEon6ct94vJJ18Z8AhfyBHHaBrVp18YEA8aa/automata%20question.jpg" alt="NFA"></p>\n\n<p>In Tabular form, NFA is:</p>\n\n<pre><code>State    Input:a     Input:b\n-&gt;1        2,5         3,5\n  2        4           -\n  3        -           4\n (4)       4           4\n  5        5,7         5,6\n  6        -           8\n  7        8           -\n (8)       -           -\n</code></pre>\n\n<p><strong>Step 3:</strong> Convert into a DFA using powerset construction:</p>\n\n<pre><code>Symbol, State       +   Symbol, State (Input:a) +   Symbol, State (Input:b)\n   -&gt;A, {1}         |        B, {2,5}           |        C, {3,5}\n     B, {2,5}       |        D, {4,5,7}         |        E, {5,6}\n     C, {3,5}       |        F, {5,7}           |        G, {4,5,6}\n   (D), {4,5,7}     |        H, {4,5,7,8}       |        G, {4,5,6}\n     E, {5,6}       |        F, {5,7}           |        I, {5,6,8}\n     F, {5,7}       |        J, {5,7,8}         |        E, {5,6}\n   (G), {4,5,6}     |        D, {4,5,7}         |        K, {4,5,6,8}\n   (H), {4,5,7,8}   |        H, {4,5,7,8}       |        G, {4,5,6}\n   (I), {5,6,8}     |        F, {5,7}           |        I, {5,6,8}\n   (J), {5,7,8}     |        J, {5,7,8}         |        E, {5,6}\n   (K), {4,5,6,8}   +        D, {4,5,7}         +        K, {4,5,6,8}\n</code></pre>\n\n<p><strong>Step 4:</strong> Minimize the DFA:</p>\n\n<p>I have changed K->G, J->F, I->E first. In the next iteration, H->D and E->F. Thus, the final table is:</p>\n\n<pre><code>  State    +   Input:a     +   Input:b\n   -&gt;A     |      B        |      C\n     B     |      D        |      E\n     C     |      E        |      D\n    (D)    |      D        |      D\n    (E)    |      E        |      E\n</code></pre>\n\n<p>And diagramatically it looks like:</p>\n\n<p><img src="https://yhtvma.sn2.livefilestore.com/y1pW43x0q2NHkqp6KEDLVS95HinOgTt-VM3obaUiIJvEe4yBNecx0abQh4P7HOC5Emj6sMnfqsDim0fk3kS0ovA-l3Rf7_GoCxB/automata%20question%20final%20dfa.jpg" alt="Final DFA"></p>\n\n<p>...which is not the required DFA! I have triple checked my result. So, where did I go wrong?</p>\n\n<p>Note:</p>\n\n<ul>\n<li>-> = initial state</li>\n<li>() = final state </li>\n</ul>\n', 'ViewCount': '561', 'Title': 'Not able to convert from NFA to DFA', 'LastEditorUserId': '4289', 'LastActivityDate': '2013-02-16T05:14:07.853', 'LastEditDate': '2013-02-16T05:04:21.590', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9793', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4289', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-02-14T22:56:54.687', 'Id': '9788'},22_129:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '431', 'Title': 'Is there an efficient test for if an NFA accepts a subset of another NFA?', 'LastEditDate': '2014-04-03T11:58:31.807', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '3', 'Body': "<p>So, I know that testing if a regular language $R$ is a subset of regular language $S$ is decidable, since we can convert them both to DFAs, compute $R \\cap \\bar{S}$, and then test if this language is empty.</p>\n\n<p>However, since this requires converting to DFAs, it's possible that the DFAs, and thus the testing algorithm, will be exponential in terms of the number of states in the input NFAs.</p>\n\n<p>Is there a known way to do this in polynomial time? Has this problem in general been proved Co-NP complete? </p>\n\n<p>Note that the problem is in Co-NP since a word accepted by $R$ but not by $S$ would be a polynomial certifier that $R \\not \\subseteq S $.</p>\n\n<p>EDIT: this is incorrect, as there is no guarantee that such a word would be polynomial in the number of states.</p>\n", 'Tags': '<algorithms><regular-languages><automata><np-complete><decision-problem>', 'LastEditorUserId': '15050', 'LastActivityDate': '2014-04-03T11:58:31.807', 'CommentCount': '5', 'AcceptedAnswerId': '9955', 'CreationDate': '2013-02-20T06:11:51.547', 'Id': '9954'},22_130:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was looking at the construction proof showing the equivalence of NFA and DFA from Sipser's text. It started by taking number of states of DFA as $\\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the set of subsets of $Q$. </p>\n\n<p>My doubt is when we construct DFA from NFA, all the subsets may not occur in that DFA. So how could we write that the number of states of DFA constructed is $\\mathcal{P}(Q)$.</p>\n", 'ViewCount': '243', 'Title': 'Equivalence of NFA and DFA - proof by construction', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-21T10:40:49.660', 'LastEditDate': '2013-02-21T10:40:49.660', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9999', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><nondeterminism><automated-theorem-proving>', 'CreationDate': '2013-02-21T02:55:37.267', 'Id': '9998'},22_131:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do we find all equivalence classes of $\\mathsf{R_L}$ for a language? </p>\n\n<p>Say I\'m trying to look for all equivalent classes for the regular language $\\mathsf{L}$ is $011(0+1)^*011$.</p>\n\n<p>Here\'s an example they give us in the book\n<a href="http://books.google.com/books?id=VEHYzv0GHt8C&amp;pg=PA73&amp;lpg=PA73&amp;dq=ding+du+example+2.51&amp;source=bl&amp;ots=P8gAls0z7f&amp;sig=HIsMb7rcD3hKZHYzi8fYZsyrLQ8&amp;hl=en&amp;sa=X&amp;ei=5N0nUfSoJ6We2gWOv4HYDQ&amp;ved=0CDMQ6AEwAA" rel="nofollow">http://books.google.com/books?id=VEHYzv0GHt8C&amp;pg=PA73&amp;lpg=PA73&amp;dq=ding+du+example+2.51&amp;source=bl&amp;ots=P8gAls0z7f&amp;sig=HIsMb7rcD3hKZHYzi8fYZsyrLQ8&amp;hl=en&amp;sa=X&amp;ei=5N0nUfSoJ6We2gWOv4HYDQ&amp;ved=0CDMQ6AEwAA</a></p>\n\n<p>ps\nThe relation $\\mathsf{R_L}$ is an equivalent relation.\n$\\mathsf{R_L}$ on $\\Sigma^* as:$\n$xRy$ iff $(\\forall w)[xw \\in \\mathsf{L} \\Leftrightarrow yw \\in \\mathsf{L}]$</p>\n', 'ViewCount': '425', 'Title': 'DFA Minimization: Finding all equivalence classes of $\\mathsf{R_L}$ for language $011(0+1)^*011$', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-02-22T21:11:15.843', 'LastEditDate': '2013-02-22T21:07:31.420', 'AnswerCount': '1', 'CommentCount': '19', 'AcceptedAnswerId': '10030', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-02-22T19:56:41.727', 'Id': '10029'},22_132:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was going through construction proofs for closure of regular languages under union, star and concatenation operation in the book: "<a href="http://rads.stackoverflow.com/amzn/click/053494728X" rel="nofollow">Introduction to Theory of Computation</a>" by Michael Sipser.</p>\n\n<p>I have doubts regarding how he wrote the transition function. </p>\n\n<p><img src="http://i.stack.imgur.com/R7KhO.jpg" alt="enter image description here"></p>\n\n<p>When $Q \\in F_1$ and $a=\\epsilon$ he wrote $\\delta_1(q,a) \\cup \\{q_2\\}$. I couldn\'t understand why its so. When the input is epsilon, the state moves to $q_2$ and what is the need for writing that $\\delta_1(q,a)$</p>\n\n<p>Also if that is so, the $A^*$ example he wrote for the transition function $\\{q_1\\}$ only  when $q=q_0$ and $a=\\epsilon$</p>\n', 'ViewCount': '171', 'Title': 'Closure of regular Language - Transition Function : Sipser Proof', 'LastEditorUserId': '947', 'LastActivityDate': '2013-04-27T13:09:00.637', 'LastEditDate': '2013-02-26T12:31:34.827', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><proof-techniques><finite-automata><nondeterminism>', 'CreationDate': '2013-02-26T11:47:09.320', 'Id': '10117'},22_133:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '135', 'Title': 'Is The Following Language Regular?', 'LastEditDate': '2013-02-28T00:14:10.330', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Body': '<p>Let $L_{1}$ and $L_{2}$ be 2 languages over the same alphabet $\\Sigma$.  </p>\n\n<p>$$A(L_1,L_2)=\\{x\\in \\Sigma^*|\\exists y,z\\in L_2\\text{ such that } yxz\\in L_1\\}$$</p>\n\n<p>Assume that $L_{1}$ is regular and $L_{2}$ is context-free. The language $A(L_{1},L_{2})$:</p>\n\n<ol>\n<li>is always a regular language</li>\n<li>is always not a regular language</li>\n<li>can sometimes be a regular language</li>\n<li>cannot be context free</li>\n</ol>\n\n<p>They say that the correct answer is 1.</p>\n', 'ClosedDate': '2013-03-01T08:12:00.193', 'Tags': '<formal-languages><regular-languages><automata><context-free><finite-automata>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T03:38:56.220', 'CommentCount': '4', 'AcceptedAnswerId': '10163', 'CreationDate': '2013-02-27T23:51:15.260', 'Id': '10147'},22_134:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>Definition<br>\n  A family of circuits $(C_{1}, C_{2}, \\ldots)$ is uniform if some log\n  space transducer $T$ outputs $\\langle C_{n}\\rangle$ where $T$\'s input is $1^{n}$. (from <a href="http://en.wikipedia.org/wiki/Boolean_circuit#Uniform_Boolean_Circuits" rel="nofollow">http://en.wikipedia.org/wiki/Boolean_circuit#Uniform_Boolean_Circuits</a>)</p>\n</blockquote>\n\n<p>Can anyone exlain this? I know what boolean circuits are, so only explanation needed is what  and transducer exactly are.</p>\n', 'ViewCount': '106', 'Title': 'Definition of uniform boolean circuit', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T04:39:19.890', 'LastEditDate': '2013-03-01T03:49:03.477', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7084', 'Tags': '<complexity-theory><finite-automata><circuits>', 'CreationDate': '2013-03-01T02:09:59.500', 'Id': '10161'},22_135:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a deterministic finite automaton which behaves mostly like a Turing machine, with following difference (relevant to this question):</p>\n\n<ul>\n<li>The tape is initially finite.</li>\n<li>The automaton can insert and delete cells from the tape.</li>\n<li>Actions are associated with states rather than with transitions (this includes head shift and tape manipulation).</li>\n<li>The automaton has no accepting/final state. The computation is only terminated when the machine exits the tape. The final state of the tape is the machine's output.</li>\n</ul>\n\n<p>I know most of the states in the machine are redudant (equivalent to other states). However the good old DFA minimization algorithm won't work here, because it starts its work on the final states (which I don't have).</p>\n\n<p>The algorithm should be efficiently computable (the machines in question have hundreds of thousands to millions of states).</p>\n\n<p>Is this possible in the general case? Every algorithm I make up fails in some cases.</p>\n", 'ViewCount': '123', 'Title': 'Minimizing Turing machine-like automaton with no final states', 'LastActivityDate': '2013-03-01T15:14:45.800', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10176', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7094', 'Tags': '<turing-machines><automata><finite-automata>', 'CreationDate': '2013-03-01T15:02:56.103', 'Id': '10175'},22_136:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1427', 'Title': 'DFA to regular expression conversion', 'LastEditDate': '2013-03-02T00:16:02.467', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was looking at the question <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a> to convert DFA to regex.</p>\n\n<p>The question, I was trying to solve is:</p>\n\n<p><img src="http://i.stack.imgur.com/e7YPr.jpg" alt="enter image description here"></p>\n\n<p>I have got the following equations:</p>\n\n<p>$Q_0=aQ_0 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>$Q_1=aQ_1 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>When solved, we will get $Q_0=a^*b(a \\cup b)^* \\cup\\ \\epsilon$</p>\n\n<p>But my doubt is that, in the DFA starting state is also the final state so, even if we dont give any $b$, it will be accepted, if we give some $a$. But in the regex we have $b$, instead of $b^*$. Why is it so? Is it because,we have that regex $\\cup$ $\\epsilon$ ?</p>\n', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'LastEditorUserId': '947', 'LastActivityDate': '2013-03-02T01:00:05.917', 'CommentCount': '2', 'AcceptedAnswerId': '10184', 'CreationDate': '2013-03-01T17:26:49.227', 'Id': '10180'},22_137:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for practical applications of Finite State Machines like DFA, NFA, Moore, Mealy machines...</p>\n\n<p>It would be helpful if someone point to examples from Linux Kernel. I know that DFA is used in string matching like KMP algorithm.</p>\n\n<p>What is the significance of NFA, Moore and Mealy machines?</p>\n', 'ViewCount': '1145', 'Title': 'Practical application of Finite State Machines', 'LastActivityDate': '2013-03-06T19:32:54.840', 'AnswerCount': '4', 'CommentCount': '3', 'AcceptedAnswerId': '10290', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<reference-request><automata><finite-automata>', 'CreationDate': '2013-03-05T03:25:55.350', 'FavoriteCount': '3', 'Id': '10280'},22_138:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to understand the approach to constructing a PDA which accepts the language { $a^i b^j c^k \\mid i,j,k \\geq0, i+2k = j$ }</p>\n", 'ViewCount': '706', 'Title': 'Constructing PDA to accept language { $a^i b^j c^k \\mid i,j,k \\geq0, i+2k = j$ }', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-03-06T22:51:48.473', 'LastEditDate': '2013-03-06T15:26:08.280', 'AnswerCount': '3', 'CommentCount': '6', 'AcceptedAnswerId': '10337', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<pushdown-automata>', 'CreationDate': '2013-03-06T14:58:56.853', 'Id': '10319'},22_139:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is the question:</p>\n\n<p>Show that $L = \\{0^m1^n : m &gt; 1, n &gt; 1, n &lt; m \\}$ is not regular.</p>\n\n<p>I am not sure what superscripts mean in this situation? Does it mean something like this:</p>\n\n<p>$0^5 = 00000$ or $1^7 = 1111111$.</p>\n', 'ViewCount': '53', 'Title': 'Formal Language Syntax', 'LastEditorUserId': '683', 'LastActivityDate': '2013-03-06T23:44:22.213', 'LastEditDate': '2013-03-06T19:32:26.397', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10331', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-03-06T19:26:52.783', 'Id': '10329'},22_140:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have used FSM in Digital sequential Circuit designs. But I am unfamiliar with Finite Automata. Can somebody help me in understanding 'basic' difference between the two ?    </p>\n", 'ViewCount': '2471', 'Title': 'What is the difference between finite automata and finite state machines?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-09T18:01:35.117', 'LastEditDate': '2013-03-07T15:39:44.790', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2013-03-07T10:44:05.670', 'FavoriteCount': '2', 'Id': '10357'},22_141:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I have been given the task of creating an PDA that recognises the language </p>\n\n<p>$\\{a^{2n} b^{3n} \\mid n = 0,1,2,\\dots\\}$.</p>\n\n<p>Am I right in thinking that it needs to have at least 3 times number of $b$'s than $a$'s? </p>\n\n<p>So for example:\n$aabbb$ would be accepted\n$aaabb$ would NOT be accepted\nHowever, how do I show that using JFlap because I am unfamiliar with the software?</p>\n", 'ViewCount': '687', 'Title': 'Constructing PDA for $a^{2n} b^{3n}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-11T21:22:30.850', 'LastEditDate': '2013-03-11T07:20:49.087', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '10433', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<formal-languages><pushdown-automata>', 'CreationDate': '2013-03-10T14:50:24.700', 'Id': '10423'},22_142:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'Proving that a specific language is a CFL, and that another language is not a CFL', 'LastEditDate': '2013-03-11T02:12:00.413', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7220', 'FavoriteCount': '0', 'Body': "<p>I have two languages $C_1$ and $C_2. \\left(\\Sigma=\\{0,1\\}\\right)$:</p>\n\n<p>$C_1=\\left\\{xyz\\mid x,z \\in \\Sigma^*, y \\in \\Sigma^*1\\Sigma^*, \\text{ where } |x|=|z| \\geq |y|\\right\\}$, and $C_2=\\left\\{xyz\\mid x,z \\in \\Sigma^*, y \\in \\Sigma^*1\\Sigma^*1\\Sigma^*, \\text{ where } |x|=|z| \\geq |y|\\right\\}$</p>\n\n<p>I want to show that $C_1$ is a CFL, while $C_2$ is not a CFL.  I'm trying to create a grammar / pushdown automata that accepts $L(C_1)$, but the $|x|=|z| \\geq |y|$ part is throwing me off.  I plan on using the pumping lemma for $C_2$, but I'm not sure which string to pump.  </p>\n", 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-11T05:34:59.417', 'CommentCount': '4', 'AcceptedAnswerId': '10440', 'CreationDate': '2013-03-10T21:21:27.903', 'Id': '10437'},22_143:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a regular language $L$, can we say anything about its complement $\\overline L$? One thing that is trivial to say is that the DFA's for both languages are equal in size as complementing the language is simply a matter of changing all accepting states into rejecting states and vice-versa. Are there any other things to conclude? Is there anything one can say about the number of states of a (minimal) NFA?</p>\n", 'ViewCount': '272', 'Title': 'Can we say anything about the complement of a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-12T10:28:18.477', 'LastEditDate': '2013-03-12T10:28:18.477', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'FUZxxl', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<regular-languages><finite-automata><closure-properties>', 'CreationDate': '2013-03-11T14:18:52.303', 'Id': '10458'},22_144:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having a little bit of an issue with a pumping lemma problem. I've successfully completely all my other problems but this is the last one and I'm a little confused I must say. If anyone can help me out, it'd be much appreciated.</p>\n\n<p>\\begin{equation} \nA = \\{a^n b^m c^l    \\mid      n\\leq m  \\vee  m\\leq l\\}\n\\end{equation}</p>\n", 'ViewCount': '63', 'Title': 'Proving a language is not regular with pumping lemma', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-12T02:19:28.653', 'LastEditDate': '2013-03-12T02:17:29.153', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10462', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7233', 'Tags': '<automata><pumping-lemma>', 'CreationDate': '2013-03-12T01:15:34.527', 'Id': '10461'},22_145:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading the proof of pumping lemma from Sipser\'s book. I couldn\'t understand certain things mentioned there.</p>\n\n<p><img src="http://i.stack.imgur.com/OEUAS.jpg" alt="pumping lemma proof"></p>\n\n<p>In the second paragraph he has written, "because $r_l$ occurs among first $p+1$ places, we have $l \\le p+1$". Here, does $l$ denotes the number of states visited?</p>\n\n<p>Also he wrote  "We know that $j \\neq l$, so $|y| &gt; 0$; and $l \\le p+1$; so $|xy| \\le p$"</p>\n\n<p>What I didn\'t understand is</p>\n\n<ol>\n<li><p>$j \\neq l$ </p></li>\n<li><p>$j \\neq l$, so $|y| &gt; 0$ </p></li>\n<li><p>$l \\le p+1$; so $|xy| \\le p$</p></li>\n</ol>\n', 'ViewCount': '135', 'Title': 'Pumping Lemma for regular languages proof doubt - Sipser Book', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-17T18:20:36.850', 'LastEditDate': '2013-03-17T18:20:36.850', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10579', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<regular-languages><automata><pumping-lemma>', 'CreationDate': '2013-03-17T12:24:12.517', 'Id': '10577'},22_146:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let \n$A= \\{L \\mid L \\;\\text{is one-counter and \\(\\bar{L}\\) is also one-counter} \\}$</p>\n\n<p>Clearly, $\\text{Deterministic one-counter} \\subseteq A$</p>\n\n<p>Is it the case that $ A = \\text{Deterministic one-counter}$?</p>\n\n<p>I know that for context-free languages the analogue is not the case. For example,\nlet $P =\\{ ww^r\\}$.\nThen both $P$ and $\\bar{P}$ are context-free but $P$ is not deterministic.\nHence $A$ defines a (strict) subset of the context-free languages.</p>\n\n<p>The question is: can we construct a similar one-counter example for which the same holds?</p>\n', 'ViewCount': '143', 'Title': 'Is there a strictly non-deterministic one-counter language whose complement is one-counter?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-18T15:27:47.923', 'LastEditDate': '2013-03-20T10:50:55.130', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4980', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-03-19T15:44:35.443', 'Id': '10621'},22_147:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>E.g.</p>\n\n<p><strong>Matching Problem</strong> The DFA of regex <code>good</code> is like a chain.</p>\n\n<pre><code>match:     "good"\nnot match: "people do not give good comments are not good people"\n</code></pre>\n\n<p><strong>Searching Problem</strong> The DFA used in searching regex <code>good</code> could be:</p>\n\n<p><img src="http://i.stack.imgur.com/BcnoQ.jpg" alt="enter image description here"></p>\n\n<pre><code>1 matching:  "good"\n2 matchings: "people do not give good comments are not good people"\n</code></pre>\n\n<p>Here are the questions:</p>\n\n<ol>\n<li>In the above two problems, it seems the searching problem\'s DFA is the matching problem\'s DFA plus some backedges and an additional state (here state <code>0</code>). Is this the difference in general?</li>\n<li>What is the regex of searching problem in this case?</li>\n</ol>\n', 'ViewCount': '139', 'Title': 'Difference between pattern matching and pattern searching in terms of DFA/Regex', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T18:51:02.610', 'LastEditDate': '2013-03-20T11:08:46.557', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'JackWM', 'PostTypeId': '1', 'Tags': '<finite-automata><regular-expressions><search-algorithms>', 'CreationDate': '2013-03-19T00:16:58.863', 'Id': '10632'},22_148:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '160', 'Title': 'Is $L= \\{ a^ib^j \\mid j\\neq i \\ and \\ j\\neq2i \\ \\} $ context free?', 'LastEditDate': '2013-03-20T05:31:10.373', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4980', 'FavoriteCount': '1', 'Body': "<p>$L = \\{ a^ib^j \\mid j\\neq i \\ and \\ j\\neq2i \\ \\} $</p>\n\n<p>Is this language a context free language?\nIf yes give a PDA. If no, give a proof.</p>\n\n<p>The pumping lemma for context free languages doesn't seem to work here.</p>\n\n<p>Let $p&gt;1$ be the pumping length. Let the string be divided into five parts according to pumping lemma as $w = uvxyz$.</p>\n\n<p>For any string of the form $a^ib^j \\ s.t.$: </p>\n\n<ol>\n<li><p>$ j\\lt i-1$ choose $v=a, \\ x=\\epsilon, \\ y=\\epsilon$</p></li>\n<li><p>$ j\\gt 2i+1$ choose $v=\\epsilon, \\ x=\\epsilon, \\ y=b$</p></li>\n<li><p>$ j = i-1$ choose $v=a, \\ x=\\epsilon, \\ y=b$</p></li>\n<li><p>$ j =  2i+1$ choose $v=a, \\ x=\\epsilon, \\ y=b$</p></li>\n<li><p>$ j\\gt i,\\ j\\lt 2i $ choose $v=a, \\ x=\\epsilon, \\ y=b$</p></li>\n</ol>\n", 'Tags': '<formal-languages><context-free><pushdown-automata>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-20T05:31:10.373', 'CommentCount': '1', 'AcceptedAnswerId': '10638', 'CreationDate': '2013-03-20T04:55:41.533', 'Id': '10635'},22_149:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to find a minimal DFA given the following information: </p>\n\n<blockquote>\n  <p>$ \\{a^nb : n\\geq 0\\} \\cup \\{b^na: n \\geq 1\\}$</p>\n</blockquote>\n\n<p>Now, maybe I'm not seeing this properly, but I don't see how this is possible: the first one will take 0 or more a's followed by one b, whereas the second one will take a 1 or more b's followed by one a.</p>\n\n<p>Drawing the combined automata only brought me to trap states. Any suggestions?</p>\n", 'ViewCount': '311', 'Title': 'Union of two automata', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-23T03:41:04.227', 'LastEditDate': '2013-03-23T03:41:04.227', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10685', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-03-21T17:34:51.983', 'Id': '10684'},22_150:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>Recently, I asked a <a href="http://math.stackexchange.com/q/334581/17111">question</a> on Math SE. No response yet. This question is related to that question, but more technical details toward computer science.</em></p>\n\n<p>Given two DFAs $A = (Q, \\Sigma, \\delta, q_1, F_1)$ and $B = (Q, \\Sigma, \\delta, q_2, F_2)$ where the set of states, the input alphabet and the transition function of $A$ and $B$ are the same, the initial states and the final(accepting) states could be different. Let $L_1$ and $L_2$ be the languages accepted by $A$ and $B$, respectively.</p>\n\n<p>There are four cases:</p>\n\n<ol>\n<li>$q_1 = q_2$ and $F_1 = F_2$.</li>\n<li>$q_1 \\neq q_2$ and $F_1 = F_2$.</li>\n<li>$q_1 = q_2$ and $F_1 \\neq F_2$.</li>\n<li>$q_1 \\neq q_2$ and $F_1 \\neq F_2$.</li>\n</ol>\n\n<p>My question is</p>\n\n<blockquote>\n  <blockquote>\n    <p>What are the differences between $L_1$ and $L_2$\n     in cases 2, 3 and 4?</p>\n  </blockquote>\n</blockquote>\n\n<p>I have a more specific question along this line,</p>\n\n<p>The transition monoid of an automaton is the set of all functions on the set of states\ninduced by input strings. See <a href="http://en.wikipedia.org/wiki/Semiautomaton">the page</a> for more details. The transition monoid can be regarded as a monoid acting on the set of states. See this <a href="http://en.wikipedia.org/wiki/Semigroup_action">Wiki page</a> for more details.</p>\n\n<p>In many literatures, an automaton is called strongly connected when the monoid action is transitive, i.e. there is always at least one transition (input string) from one state to another state.</p>\n\n<blockquote>\n  <blockquote>\n    <p>If $A$ and $B$ are strongly connected automata, what are the differences between $L_1$ and $L_2$ in cases 2, 3 and 4 above?</p>\n  </blockquote>\n</blockquote>\n\n<p>Any literatures discussing these issues in details?</p>\n\n<p>I have searched many books and articles and found nothing helpful so far. I believe I don\'t have the appropriate key words yet. Thus I am seeking help. Any pointers/references will be appreciated very much.</p>\n', 'ViewCount': '170', 'Title': 'Difference between the languages accepted by two DFAs with different initial state/accepting states?', 'LastActivityDate': '2013-03-24T11:48:30.127', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10737', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '630', 'Tags': '<formal-languages><reference-request><finite-automata>', 'CreationDate': '2013-03-24T03:40:45.747', 'FavoriteCount': '1', 'Id': '10733'},22_151:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '405', 'Title': 'Star free language vs. regular language', 'LastEditDate': '2013-03-27T15:46:17.093', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7410', 'FavoriteCount': '2', 'Body': u'<p>I was wondering, since $a^*$ is itself a star-free language, is there a regular language that is not a star-free language? Could you give an example?</p>\n\n<hr>\n\n<p><em>(from <a href="http://en.wikipedia.org/wiki/Star-free_language#cite_ref-Law235_1-0" rel="nofollow">wikipdia</a>)</em> Lawson defines star-free languages as:</p>\n\n<blockquote>\n  <p>A regular language is said to be star-free if it can be described by a regular expression constructed from the letters of the alphabet, the empty set symbol, all boolean operators \u2013 including complementation \u2013 and concatenation but no Kleene star.</p>\n</blockquote>\n\n<hr>\n\n<p>Here is the proof of $a^*$ being star-free:</p>\n\n<blockquote>\n  <p>$\\emptyset$ is star-free $\\Longrightarrow$<br>\n  $\\Sigma^*=\\bar{\\emptyset}$ is star-free $\\Longrightarrow$<br>\n  $A\\subseteq\\Sigma\\Rightarrow\\Sigma^*A\\Sigma^*$ is star-free $\\Longrightarrow$<br>\n  $A\\subseteq\\Sigma\\Rightarrow\\ A^*=\\overline{\\Sigma^*\\overline{A}\\Sigma^*}$ is star-free</p>\n</blockquote>\n', 'Tags': '<formal-languages><regular-languages><automata>', 'LastEditorUserId': '7410', 'LastActivityDate': '2013-08-16T16:56:08.473', 'CommentCount': '0', 'AcceptedAnswerId': '10769', 'CreationDate': '2013-03-25T11:21:07.097', 'Id': '10768'},22_152:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1097', 'Title': u'Why is this true: \u201cThere are countably many Turing Machines\u201d', 'LastEditDate': '2013-03-26T01:18:42.283', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7415', 'FavoriteCount': '2', 'Body': "<p>It is said that there are uncountably many languages but only countably many Turing Machines. Could someone make this clear to me?\nAnd this doesn't mean that the set of TM is finite, yes?</p>\n", 'ClosedDate': '2013-03-25T19:23:00.643', 'Tags': '<turing-machines><automata>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-06-18T19:56:53.950', 'CommentCount': '2', 'CreationDate': '2013-03-25T18:01:11.830', 'Id': '10780'},22_153:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '391', 'Title': 'Can a Turing Machine decide if an NFA accepts a string of prime length?', 'LastEditDate': '2013-03-28T10:11:57.990', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'user2216670', 'PostTypeId': '1', 'OwnerUserId': '7450', 'FavoriteCount': '1', 'Body': "<p>I want to know if the following problem is decidable:</p>\n\n<p>Instance: An NFA A with n states</p>\n\n<p>Question: Does there exist some prime number p such that A accepts some string of length p.</p>\n\n<p>My belief is that this problem is undecidable, but I can't prove it. The decider can easily have an algorithm to figure out if a particular number is prime, but I don't see how it would be able to analyze the NFA in enough detail to know exactly what lengths it can produce. It could start testing strings with the NFA, but for an infinite language, it may never halt (and thus not be a decider).</p>\n\n<p>The NFA can easily be changed to a DFA or regular expression if the solution needs it, of course.</p>\n\n<p>This question is something I've been pondering as a self-made prep question for a final I have coming up in 2 weeks.</p>\n", 'Tags': '<computability><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T10:11:57.990', 'CommentCount': '3', 'AcceptedAnswerId': '10851', 'CreationDate': '2013-03-27T17:28:14.523', 'Id': '10848'},22_154:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was looking at the pumping lemma for CFG. I came across the first problem $a^nb^nc^n$ and understood the answer. Then I thought of the problem $a^nb^n$. I know that this is context free and thought of applying it. I came across a weired situation. Someone please tell me where I went wrong. </p>\n\n<p>So our language is $a^nb^n$. Let $m$ be the pumping length. Pumping lemma says that any sufficiently long string can be divided in $uvxyz$, where $v$ and $y$ can be pumped.</p>\n\n<p>we take our string to be $a^mb^m$ and we can split it into $uxvyz$. Also we know that $|vxy|\\le m$. Also $u$ can be $\\epsilon$. In that case $vxy$ consists only of $a$, since $|vxy|\\le m$ and there are $m$, $a$'s. So when we pump $v$ and $y$, the resulting string wont be in the language!</p>\n\n<p>So where I got wrong? Is it wrong to take $u$ is $\\epsilon$ and proceed from there? </p>\n", 'ViewCount': '398', 'Title': 'Pumping lemma for CFG doubt', 'LastActivityDate': '2013-03-31T06:57:10.293', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10926', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<context-free><automata><pumping-lemma>', 'CreationDate': '2013-03-28T13:51:46.030', 'FavoriteCount': '1', 'Id': '10873'},22_155:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I could find that different texts follow different steps in the conversion of CFG to Chomsky Normal Form. I couldn't find any presumptions they made in the conversion steps. I have some questions regarding the conversion.</p>\n\n<ol>\n<li><p>Most text books tell us about only two rules $A \\rightarrow BC$ and $A \\rightarrow a$. But some texts say that starting productions should not be in the right hand side. Why some stress on that rule and others not?</p></li>\n<li><p>When talking about the rules some don't stress much on the condition of removing useless symbols. Is this condition mandatory or not?</p></li>\n<li><p>Which is the best rule? Remove useless production, remove $\\epsilon$ production, remove unit production, adjust the resulting productions so as to reflect the CNF rules. </p></li>\n<li><p>Converting a grammar to Greibach normal form requires first converting the productions to Chomsky Normal Form?</p></li>\n</ol>\n", 'ViewCount': '268', 'Title': 'CFG to CNF conversion steps', 'LastActivityDate': '2013-03-28T16:53:43.800', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<context-free><automata>', 'CreationDate': '2013-03-28T16:53:43.800', 'Id': '10876'},22_156:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Earlier I asked the question: <a href="http://cs.stackexchange.com/questions/10848/can-a-turing-machine-decide-if-an-nfa-accepts-a-string-of-prime-length">Can a Turing Machine decide if an NFA accepts a string of prime length?</a>. The answer introduced me to Parikh\'s theorem, which I\'ve been reading about. The concept of Parikh\'s theorem, if we apply it to regular expressions, allows us to break down a regular expression into expressions that only have one level of Kleene-star nesting.</p>\n\n<p>So: $aa(b(cc)^*)^*$ can have a list of expressions created using the same methodology as Parikh\'s theorem where none of the new expressions in the final list has nested Kleene-stars. The linear subsets will use starred expressions </p>\n\n<p>To make it more clear, I\'m referencing this paper: <a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow"><a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow">http://people.inf.ethz.ch/torabidm/par-ext.pdf</a></a>.</p>\n\n<p>I\'m not too concerned with it actually being a regular expression, DFAs or NFAs would work fine. It seems easier to work with as an RE.</p>\n\n<hr>\n\n<p>I want to know if the problem is decidable:</p>\n\n<p><strong>Instance</strong>: A regular expression $R$</p>\n\n<p><strong>Question</strong>: Does there exist some length $l \\ge 1$ such that $R$ accepts every string of that length (ie. if its alphabet is $\\Sigma$, it accepts $\\Sigma^l$, for some $l \\ge 1$.</p>\n\n<hr>\n\n<p>I\'m pretty sure the problem actually is decidable but it\'s a tough one. I\'ve enjoyed pondering it so far and would love to see what someone more experienced than myself can come up with.</p>\n', 'ViewCount': '359', 'Title': 'Can a Turing Machine decide if a regular expression matches all strings of exactly some length $l \\geq 1$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-02T07:22:55.830', 'LastEditDate': '2013-03-29T18:35:42.483', 'AnswerCount': '3', 'CommentCount': '8', 'AcceptedAnswerId': '10880', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7450', 'Tags': '<computability><finite-automata><regular-expressions>', 'CreationDate': '2013-03-28T20:10:53.063', 'Id': '10879'},22_157:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Can a two-stack PDA accept language $L=\\{a^nb^mc^nd^m \\mid n \\geq m\\}$, which has no context-free grammar?</p>\n\n<p>I don't believe this has a context-free grammar, but please correct me if I'm wrong.</p>\n", 'ViewCount': '397', 'Title': 'Can a two-stack PDA accept language $a^nb^mc^nd^m$ which is not context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:15:49.030', 'LastEditDate': '2013-04-02T07:15:49.030', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10894', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><automata><machine-models>', 'CreationDate': '2013-03-29T13:13:58.140', 'Id': '10892'},22_158:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the case of LBAs (Linear Bounded Automaton), in writing a decider for the language</p>\n\n<p>$\\qquad A = \\{ \\langle M,w\\rangle \\mid M\\ \\mathrm{LBA}, w \\in \\mathcal{L}(M) \\}$</p>\n\n<p>we reject the input after a specific number (number of possible different configurations) of computation steps.\nWe say that the machine must be looping after this many steps.\nWhy don't we just check in every step to see if there is a loop (repetition of the same configuration) and if it is the case then just reject the input? </p>\n", 'ViewCount': '79', 'Title': 'Recognizing loops in computation on LBA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:33:38.753', 'LastEditDate': '2013-04-02T07:33:38.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10919', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<linear-bounded-automata>', 'CreationDate': '2013-03-30T17:31:35.793', 'Id': '10916'},22_159:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to give a PDA and CFG for a language that contains all binary strings that start and end with the same symbol. I\'ve created the CFG with no problem, but I\'m stuck with the PDA and don\'t quite know how to accomplish it.</p>\n\n<p>The best I can figure is that I need to use non-determinism, but I don\'t quite know how to apply it in this circumstance.</p>\n\n<p>Here\'s the CFG that I came up with:</p>\n\n<p>\\begin{align*}\nA &amp;\\to 1B1 \\mid 0B0 \\mid \\epsilon\\\\\nB &amp;\\to 1B \\mid 0B\\mid \\epsilon\n\\end{align*}</p>\n\n<p>The PDA, insofar as I managed to come up with:</p>\n\n<p><img src="http://i.stack.imgur.com/sjkIy.jpg" alt="enter image description here"></p>\n\n<p>The notation here, just in case it\'s not universal: $a,b \\to c$ means "When you see symbol $a$, pop symbol $b$ off the stack and push symbol $c$ onto the stack."</p>\n\n<p>Any pointers on how to accomplish this?</p>\n', 'ViewCount': '426', 'Title': 'Give CFG and PDA for the words that start and end with the same symbol', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-04T12:02:49.387', 'LastEditDate': '2013-04-04T06:41:56.223', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11006', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<formal-languages><context-free><pushdown-automata>', 'CreationDate': '2013-04-04T01:15:46.140', 'Id': '11004'},22_160:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an exercise in my book to come up with a pushdown automaton accepting a language.</p>\n\n<p>The exercise is to come up with a state diagram for the PDA accepting the language of all odd-length strings over $\\{a, b\\}$ with middle symbol $a$.</p>\n\n<p>Here\'s what I have so far...</p>\n\n<p><img src="http://i.stack.imgur.com/mNXvh.png" alt="enter image description here"></p>\n\n<p>I wasn\'t sure how many states I needed, but I was thinking 3. State $q_0$ for pushing symbols onto the stack until reaching the middle symbol, $q_1$ for after middle symbol is found, and state $q_2$ the accepting state. I think in $q_1$ I need to cancel out input symbols from the stack with the input. I don\'t know how to account for the string being odd length, also.</p>\n\n<p>Is there a smart, systematic way to do this?</p>\n', 'ViewCount': '446', 'Title': 'How to generate a pushdown automata for accepting a language?', 'LastActivityDate': '2013-04-04T19:13:35.593', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11028', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><automata><pushdown-automata>', 'CreationDate': '2013-04-04T18:48:13.270', 'Id': '11023'},22_161:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$L = \\{a^n b^m | m \\not= n^2 \\}$ \nI guess I need to use Pumping Lemma for CFL in order to prove this. But I'm stuck.</p>\n\n<p>Assuming that $ a^n b^m = uvxyz$, we know that $v$ or $y$ can not have both $a$ and $b$ symbols in them. Otherwise pumping would generate strings not of the form $a^i b^j$.</p>\n\n<p>Hence both $v$ and $y$ must consist only of one kind of symbol each.\nBeyond this I wonder what string in $L$ has to be chosen in order to pump and obtain something of the form $a^n b^{n^2}$.</p>\n\n<p><em><strong>Alternative idea :</em></strong> Assuming that $L$ is context-free, then I must have a PDA accepting it by final state. Can I say that this PDA can be adjusted* to accept $L'$ i.e., all $a^n b^{n^2}$ ? However I know that $L'$ is not a CFL. Hence, contradiction ?</p>\n\n<p>*Adjusted = Make the non-final state on reading $a^n b^{n^2}$ as final and the rest as all non-final.</p>\n", 'ViewCount': '223', 'Title': 'Why is the following language not context-free?', 'LastEditorUserId': '7620', 'LastActivityDate': '2013-04-10T11:05:56.600', 'LastEditDate': '2013-04-08T15:54:42.337', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7620', 'Tags': '<formal-languages><context-free><automata><finite-automata><pumping-lemma>', 'CreationDate': '2013-04-07T18:09:51.310', 'Id': '11106'},22_162:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an exam coming up and I need help with the following homework:</p>\n\n<blockquote>\n  <p>Given an NFA $A$ and a regular expression $B$, consider the problem of determining if $L(A) = L(B)$. Is this decidable? Prove your answer.</p>\n</blockquote>\n', 'ViewCount': '135', 'Title': 'Given an NFA A and a regular expression B, is the problem of determining L(A) = L(B) decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:55:24.693', 'LastEditDate': '2013-04-08T14:55:24.693', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7639', 'Tags': '<automata><finite-automata><undecidability><regular-expressions>', 'CreationDate': '2013-04-08T10:13:25.680', 'Id': '11138'},22_163:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This may be a silly question. It seem clear that an FSA, since it is finite, can only count the number of symbols in its input string up to a number bounded by the number of its states. But now suppose we equip the FSA with output (e.g. printing) capabilities. It would then be <em>very</em> easy to construct a machine capable of printing one symbol for each symbol that it reads. Would that count as counting? If not, why not?</p>\n\n<p>To put it in terms of FSTs instead: I take it that it is not possible to construct an FST capable of mapping a string of an arbitrary length to a binary representation (i.e. a number in the base-2 numeral system) of its length. But it IS of course trivial to construct an FST capable of mapping a string of arbitrary length to a string of says zeroes (or ones) of the same length. But that could count as counting, could it not, beacuse what the FST is doing is building a representation of the length of its input. A somewhat odd representation, but still a representation, is it not?</p>\n', 'ViewCount': '353', 'Title': 'Can an FSA count?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:52:44.130', 'LastEditDate': '2013-04-10T08:52:44.130', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '6', 'OwnerDisplayName': u'Torbj\xf6rn', 'PostTypeId': '1', 'OwnerUserId': '7657', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-04-09T07:58:38.200', 'Id': '11155'},22_164:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Considering this FSM:\n<img src="http://i.stack.imgur.com/aIh8C.jpg" alt="finite state machine"></p>\n\n<p>Can someone explain me why the grammar is not:</p>\n\n<ol>\n<li>$S \\rightarrow aA$</li>\n<li>$A \\rightarrow aA \\mid bB \\mid \\varepsilon$</li>\n<li>$B \\rightarrow bB \\mid \\varepsilon$</li>\n</ol>\n\n<p>Why does A not have a transition to $\\varepsilon$?</p>\n', 'ViewCount': '86', 'Title': 'Simple FSM question', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-10T11:08:20.773', 'LastEditDate': '2013-04-09T18:35:08.000', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11167', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1626', 'Tags': '<formal-grammars><finite-automata>', 'CreationDate': '2013-04-09T18:07:59.410', 'Id': '11166'},22_165:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I just learned PDAs in class today, but am having problems understanding the syntax of the transition function. Could someone please explain to me the meaning of this syntax:</p>\n\n<p>$\\delta(q, \\lambda, S) = \\{(q, aaB), (q, bbA)\\}$</p>\n\n<p>This is one of the rules for my language.  I am unsure of what the meanings of this syntax exactly is.</p>\n', 'ViewCount': '185', 'Title': 'Syntax of a Pushdown Automata transition function', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:42:45.443', 'LastEditDate': '2013-04-10T08:42:45.443', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11172', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<terminology><automata><pushdown-automata>', 'CreationDate': '2013-04-09T21:30:06.050', 'Id': '11171'},22_166:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1883', 'Title': 'Convert CFG to PDA', 'LastEditDate': '2013-04-10T08:39:30.413', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7405', 'FavoriteCount': '2', 'Body': '<p>Is there any set of rules or methods to convert any context free grammar to a push down automata? </p>\n\n<p>I already found <a href="http://infolab.stanford.edu/~ullman/ialc/spr10/slides/pda2.pdf" rel="nofollow">some slides online</a> but I wasn\'t able to understand them.</p>\n\n<p>In slide 10 he speaks about some rules could anyone explain that?</p>\n', 'Tags': '<context-free><formal-grammars><pushdown-automata><simulation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:39:30.413', 'CommentCount': '2', 'AcceptedAnswerId': '11186', 'CreationDate': '2013-04-10T03:00:30.087', 'Id': '11182'},22_167:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How would I go about using Cartesian construction to find the intersection between a PDA and a DFA?</p>\n\n<p>Is there another term for Cartesian construction? Would it be similar to the procedure for finding the intersection/union of 2 DFAs?</p>\n', 'ViewCount': '175', 'Title': 'Cartesian construction of PDA and DFA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T20:15:03.627', 'LastEditDate': '2013-04-10T20:15:03.627', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<automata><finite-automata><pushdown-automata>', 'CreationDate': '2013-04-10T18:43:39.247', 'Id': '11201'},22_168:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is the language $ L = \\{0^n 1^m \\mid n \\text{ and } m \\text{ are co-prime}\\}$ context-free ?</p>\n\n<p>I guess that it's not context free because it seems too complicated for a PDA to decided whether 2 numbers are co-prime or not.</p>\n\n<p>I tried using the pumping lemma to no avail.</p>\n\n<p>Any help would be gladly appreciated.</p>\n\n<p>Edit:</p>\n\n<p>Here is one of my failed attempts with the pumping lemma:</p>\n\n<p>Let $N$ be a constant. Take a prime $p$ such that $p &gt; N!$ and then take the word $z = 0^p 1^{p+N!} \\in L$. Let $ z = uvwxy $ be a decomposition of $z$ satisfying the conditions in the pumping lemma.</p>\n\n<p>If $ vx $ contains only zeros then $ |vx| = k $ is an integer between $1$ and $N$. Define $m$ as $m = N!/k$. For $i = m+1$ the word $ uv^iwx^iy = 0^{p+N!}1^{p+N!} \\not\\in L $</p>\n\n<p>However, I've failed to find such an integer $i$ for the other decomposition cases.</p>\n", 'ViewCount': '283', 'Title': 'Is the language $\\{0^n 1^m \\mid n \\text{ and } m \\text{ are co-prime}\\}$ context-free?', 'LastEditorUserId': '7068', 'LastActivityDate': '2013-04-12T20:05:43.350', 'LastEditDate': '2013-04-12T10:49:52.740', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-04-11T18:04:33.373', 'FavoriteCount': '3', 'Id': '11237'},22_169:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I understand that any CFL can be accepted by a PDA by final state or empty store but I have been rather stumped by this question.\nThe question states that the PDA has at most 2 states. Clearly 1 will be the start state while the other will be the final state (they cannot be the same since otherwise the empty string will be accepted). My initial idea was to take a grammar for $L$ in GNF (Greibach Normal Form) (refer to Ran's answer below for details on how a CFG in GNF can be converted to a PDA having 1 state and no $\\epsilon$-transitions that accepts by empty store) and then give a PDA for this that meets the specification. But the problem is that I cannot find a way to do this without having an $\\epsilon$-move at the final step when I have to move to the final state after the stack is empty. Any help would be greatly appreciated.</p>\n\n<p>The PDA can be specified as $M = (K, \\Sigma,\\delta, q_0, Z_0, \\{q_f\\} )$ where\n$q_0$ is the initial state, $Z_0$ is the initial stack symbol and $q_f$ is the final state. The exact question is</p>\n\n<blockquote>\n  <p>Show that if $L$ is a CFL and $\\epsilon$ does not belong to $L$, then there is a PDA $M$ accepting $L$ by final state such that $M$ has at most 2 states and makes no $\\epsilon$-moves.</p>\n</blockquote>\n\n<p>Thus, the PDA should</p>\n\n<ol>\n<li>accept by final state</li>\n<li>have at most 2 states</li>\n<li>make no $\\epsilon$-moves</li>\n</ol>\n", 'ViewCount': '357', 'Title': 'Designing a PDA w/o $\\epsilon$-moves and $\\leq 2$ states to accept an $\\epsilon$-free CFL by final state', 'LastEditorUserId': '7731', 'LastActivityDate': '2013-04-23T19:03:27.153', 'LastEditDate': '2013-04-16T03:57:47.927', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11335', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7731', 'Tags': '<formal-languages><context-free><automata><pushdown-automata>', 'CreationDate': '2013-04-15T01:15:08.810', 'Id': '11321'},22_170:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the language $L = \\{ a^ib^j \\mid i\\ \\nmid\\ j \\ \\} $ context free ?</p>\n\n<p>If we fix $n \\in N$ then we know that the language $L = \\{ a^ib^j \\mid \\ \\forall \\ 1 \\le k \\le n \\ , \\ \\  j\\neq ki \\} $ is context free (as it can be presented as a finite union of context free languages in a similar way to the example here: <a href="http://cs.stackexchange.com/questions/10635/is-l-aibj-mid-j-neq-i-and-j-neq2i-context-free?rq=1">Is $L= \\{ a^ib^j \\mid j\\neq i \\ and \\ j\\neq2i \\ \\} $ context free?</a>)</p>\n\n<p>I think that it\'s not context free but have failed to prove it.\nBy reading other questions on this site I noticed this interesting observation: CFL\'s in $a^*b^*$ are closed under complement as can be seen here: <a href="http://cs.stackexchange.com/questions/11110/are-context-free-languages-in-ab-closed-under-complement">Are context-free languages in $a^*b^*$ closed under complement?</a> </p>\n\n<p>So our language $L$ is context free if and only if $ \\bar L = \\{ a^ib^j \\mid \\ \\ i\\ \\mid\\ j \\ \\} $ is context free. I tried using the pumping lemma but  to no avail.</p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '241', 'Title': 'Is the language $L = \\{ a^ib^j \\mid i\\ \\nmid\\ j \\ \\} $ context free?', 'LastActivityDate': '2013-11-21T01:06:06.003', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11634', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-04-19T10:08:37.820', 'FavoriteCount': '2', 'Id': '11405'},22_171:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following CFG,</p>\n\n<p>$S \\rightarrow CB$<br>\n$C \\rightarrow aCa \\text{ }|\\text{ } bCb \\text{ }|\\text{ } \\text{#}B$<br>\n$B \\rightarrow AB \\text{ }|\\text{ } \\varepsilon$<br>\n$A \\rightarrow a\\text{ }|\\text{ }b$</p>\n\n<p>This is the CFG for the following language:</p>\n\n<p>$$L= \\left\\{w \\text{#} x\\mid w^R \\text{ is a substring of }\\ x \\text{, where }  x,w\\in \\{a, b\\}^*\\right \\}$$</p>\n\n<p>I have a problem with constructing PDA for this CFG.</p>\n\n<p><strong>My attempt</strong></p>\n\n<p>My idea was to store characters in stack until "#" character, then as soon as the sequence of reversed characters go, pop from the stack. If at the end of input stack is empty, then we are done.</p>\n\n<p>The problem is that for the following string, for example:</p>\n\n<p>abbaa#aabbbbbbb(aabba)bbbbbb</p>\n\n<p>when we read characters after "#", PDA will pop 4 characters, the it will see that the sequence is not valid and proceed with input. How can I return these 4 characters back so that I can check sequence again because I need full stack to proceed with accepted reversed substring that I have showed in brackets?</p>\n', 'ViewCount': '406', 'Title': 'Converting CFG to PDA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:39:44.393', 'LastEditDate': '2013-04-21T14:39:44.393', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11447', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7809', 'Tags': '<context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2013-04-20T20:26:38.457', 'Id': '11441'},22_172:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '248', 'Title': 'Does our PC work as Turing Machine?', 'LastEditDate': '2013-04-23T12:28:36.693', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7384', 'FavoriteCount': '2', 'Body': u'<p>Does our PC work as Turing Machine?  The model of a Turing Machine consists of infinite memory tape, which means infinite states. But suppose if our PC has 128 MB memory and 30GB disk it would have 256^30128000000 states and thus, it has finite states.</p>\n\n<p>I know that we can write a type of program that, if during execution we run out of memory, will request to swap memory disk with empty memory disk and resume execution.</p>\n\n<p><strong>But what if we don\u2019t swap memory disk, in this case is it right to consider PC as FA</strong>?  </p>\n', 'Tags': '<complexity-theory><computability><turing-machines><automata>', 'LastEditorUserId': '1861', 'LastActivityDate': '2013-04-23T15:53:04.873', 'CommentCount': '1', 'AcceptedAnswerId': '11516', 'CreationDate': '2013-04-23T11:46:49.043', 'Id': '11514'},22_173:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is the following language context free: $L = \\{ uxvy \\mid u,v,x,y \\in \\{ 0,1 \\}^+, |u| = |v|, u \\neq v, |x| = |y|, x \\neq y\\} $ ?</p>\n\n<p>I think that it's not context free but I'm having a hard time proving it. I tried intersecting this language with a regular language (like  $ \\ 0^*1^*0^*1^* $ for example) then use the pumping lemma and \\ or homomorphisms but I always get a language that is too complicated to characterize and write down. </p>\n", 'ViewCount': '797', 'Title': 'Is this strange language context free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-20T18:37:10.130', 'LastEditDate': '2013-06-13T05:51:03.333', 'AnswerCount': '3', 'CommentCount': '16', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-04-26T17:56:00.657', 'FavoriteCount': '10', 'Id': '11585'},22_174:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '173', 'Title': 'Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular', 'LastEditDate': '2013-04-30T15:54:36.220', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7492', 'FavoriteCount': '1', 'Body': "<p>Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular.</p>\n\n<p>These are the things that I would use to start.</p>\n\n<ul>\n<li>As $L_1L_2$ is regular, then the homomorphism $h(L_1L_2)$ is regular.</li>\n<li>Let $h(L_1) = L_2$ and $h(L_2) = L_1$, then $h(L_1L_2) = L_2L_1$ is regular (we already know that) or $h(L_2) = \\epsilon$ and we get $L_1$</li>\n<li>By reflexing, $L_1L_2 = (L_2L_1)^{R}$, same result.</li>\n</ul>\n\n<p>But i don't know how to, for example, intersect something that gives me $L_1$ in order to preserve closure and finally $L_1$ be regular.</p>\n\n<p>Any help?</p>\n", 'Tags': '<regular-languages><finite-automata><proof-techniques><closure-properties>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-30T15:54:36.220', 'CommentCount': '0', 'AcceptedAnswerId': '11596', 'CreationDate': '2013-04-27T03:06:35.000', 'Id': '11592'},22_175:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '255', 'Title': 'prove no DPDA accepts language of even-lengthed palindromes', 'LastEditDate': '2013-04-27T08:02:10.887', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7410', 'FavoriteCount': '1', 'Body': '<p>How do you prove that the language of even-lengthed palindromes, i.e.,\n$L=\\left\\{ ww^R \\mid w\\in \\left\\lbrace 0,1 \\right\\}^* \\right\\}$, can not be accepted by a determinsitc Push-Down-Automaton?</p>\n\n<p>Is there any general way to prove that a context-free language can not be accepted by a deterministic PDA? I mean something like pumping lemma maybe?</p>\n', 'Tags': '<context-free><pushdown-automata>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-04-27T20:01:26.740', 'CommentCount': '1', 'AcceptedAnswerId': '11608', 'CreationDate': '2013-04-27T06:52:11.577', 'Id': '11598'},22_176:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The regular expression $a^{3}b^{+}$ is indeed regular because we can define an automata $M$. But I see that $\\mathcal{L} = \\{a^{3}b^{n}, n \\geq 1\\}$ may generate the same strings, but using the pumping lemma with constant $N$ for a substring $\\alpha\\beta = a^{3}b^{t},|\\alpha\\beta| \\leq N$, let $\\alpha = a$ and $\\beta = a^{2}b^{t}$, therefore $\\gamma = b^{N-t}$, and when $k = 0$, $\\sigma = \\alpha \\beta^{0} \\gamma = \\alpha \\gamma = ab^{N-t}$, which doesn't belong to $\\mathcal{L}$ and the language isn't regular.</p>\n\n<p>So, is really the regex equal to $\\mathcal{L}$? or am I pumping wrong?</p>\n", 'ViewCount': '62', 'Title': 'Is the language $a^{3}b^{+}$ the same as $\\{a^{3}b^{n}, n \\geq 1\\}$ ? and what is the result of pumping this?', 'LastActivityDate': '2013-04-28T04:30:58.543', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11621', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7492', 'Tags': '<regular-languages><finite-automata><regular-expressions><pumping-lemma>', 'CreationDate': '2013-04-28T03:39:32.733', 'FavoriteCount': '1', 'Id': '11619'},22_177:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Basically, I currently have two ideas but unsure on which is correct for the following question:\n"The High level data link control protocol (HDLC), is a popular protocol used for point-to-point data communication. In HDLC, data are organised into frames which begin and end with the sequence 01111110. This sequence never occurs within the main body of the frame, only at the beginning and end (in order to avoid confusion).</p>\n\n<p>a.)Design an NFA which recognises the language of binary strings which contain one or more HDLC frames"</p>\n\n<p>My possible solutions:\n<a href="http://tinypic.com/r/2bnq4m/5" rel="nofollow">http://tinypic.com/r/2bnq4m/5</a></p>\n\n<p>The next part is to convert to DFA, but I first need to get this part right</p>\n', 'ViewCount': '339', 'Title': 'NFA to recognize bit strings containing 01111110', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-20T17:56:49.680', 'LastEditDate': '2013-07-29T08:00:06.633', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-05-04T20:07:13.117', 'Id': '11780'},22_178:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can we design a regular expressions without particular substrings.\nThe goal of this is to create language <code>L</code> which won't contain a particular substring (i.e. 110)</p>\n\n<p>for the case of a regular expression without substring $110$, I Was thinking of: $\\require{cancel}\\cancel{(101)^*+}(010)^*+(10)^*+(\\cancel{1}1)^*+(\\cancel{0}0)^*+(01)^*$ but is that over excessive?</p>\n\n<p>Then for example, I crossed out (101)* because obviously if you have two of those 101101, a subset of that will be 110, which we don't want.</p>\n\n<h3>Notes:</h3>\n\n<p>Question has been edited since it gained attention in the past few days. Also see comment for justification.</p>\n", 'ViewCount': '3292', 'Title': 'Regular expression for the strings without a particular substring', 'LastEditorUserId': '6980', 'LastActivityDate': '2014-01-31T12:46:01.967', 'LastEditDate': '2014-01-31T12:46:01.967', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '11791', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-05-04T23:46:05.660', 'Id': '11787'},22_179:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have my own version of <code>lex</code> and I would like to add the complement operation. Derived from that I can then add the intersection and difference also. My version also supports the generation of NFAs (Non-deterministic Finite Automaton) and of course I try to keep the automatons as small as possible.</p>\n\n<p>My question thus is: what is the most optimal known upper bound on the number of states in the NFA that accepts the complement of another NFA? Of course going through the conversion to a DFA (Deterministic Finite Automaton) and then interchanging accepting and rejecting states, gives an exponential upper bound. Are there any better known upper bounds? Preferably polynomial or even linear of course.</p>\n\n<p>If no better upper bound is known, has it been shown that for some family of languages the lower bound is exponential or otherwise super polynomial?</p>\n', 'ViewCount': '96', 'Title': 'Optimal upper bound on the number of states in the complement of an NFA', 'LastActivityDate': '2013-05-05T12:58:46.023', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11804', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7970', 'Tags': '<finite-automata>', 'CreationDate': '2013-05-05T09:49:53.543', 'FavoriteCount': '1', 'Id': '11802'},22_180:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm doing some research regarding NFAs and inclusion problems with them. I know that in general, the inclusion problems, and converting to an unambiguous NFA, are both PSPACE-complete.</p>\n\n<p>I'm wondering, are there any sub-classes of NFA for which these can be decided efficiently? In particular, the NFAs I'm looking at accept finite language where all words have the same Parikh vector.</p>\n", 'ViewCount': '107', 'Title': 'Classes of NFAs which allow efficient subset testing or unambiguity conversions', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-06-13T16:33:18.830', 'LastEditDate': '2013-05-06T23:38:41.717', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-05-06T22:26:42.443', 'FavoriteCount': '1', 'Id': '11841'},22_181:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following CFG $G$:\n$$ \\begin{align}\nS &amp;\\rightarrow aAbb \\mid aaBb \\\\\nA &amp;\\rightarrow aAbb \\mid \\epsilon \\\\\nB &amp;\\rightarrow aaBb \\mid \\epsilon \\\\\n\\end{align} $$</p>\n\n<p>I have to create a PDA (pushdown automaton) to recognize this language however I am unsure on how to do it. So far I have this(revised based on feedback from user Hendrik Jan) :</p>\n\n<p><img src="http://i.stack.imgur.com/e9gfG.png" alt="enter image description here"></p>\n\n<p>I understand that it should accept the last one ($aaaabb$) however it does not for the current version.</p>\n', 'ViewCount': '192', 'Title': 'PDA for this context-free grammar', 'LastEditorUserId': '7216', 'LastActivityDate': '2013-06-07T15:33:12.757', 'LastEditDate': '2013-05-08T11:50:48.963', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<context-free><automata><pushdown-automata>', 'CreationDate': '2013-05-07T19:32:21.060', 'Id': '11864'},22_182:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was asked this question at an interview, and couldn't answer it, and would like to know how it is 'shown' that two Turing machines which accept the same language is undecidable. This is not a homework question!</p>\n", 'ViewCount': '482', 'Title': 'Show that it is undecidable if two Turing Machines accept the same language', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-05-14T03:12:53.943', 'LastEditDate': '2013-05-09T20:06:15.133', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8104', 'Tags': '<algorithms><computability><finite-automata><undecidability>', 'CreationDate': '2013-05-09T17:18:46.500', 'Id': '11916'},22_183:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve been reading some formal language theory papers, and I\'ve come across a term that I don\'t understand.</p>\n\n<p>The paper will often refer to a set being "effectively closed under intersection" or other operations. What does "effectively" mean here? How does this differ from normal closure?</p>\n\n<p>For reference, the paper I\'m seeing these in is:</p>\n\n<p>M. Daley and I. McQuillan. Formal modelling of viral gene compression. International Journal of Foundations of Computer Science, 16(3):453\u2013469, 2005.</p>\n', 'ViewCount': '125', 'Title': 'What does it mean to say that a language is "effectively closed" under an operation?', 'LastActivityDate': '2013-05-09T20:16:49.303', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11922', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><terminology><computability><automata><closure-properties>', 'CreationDate': '2013-05-09T19:51:28.577', 'Id': '11920'},22_184:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am doing homework in Formal Languages. I urgently need a language which can be recognised by 2 PDA's but not with 1 PDA. Thanks</p>\n", 'ViewCount': '598', 'Title': 'PDA with 2 stacks', 'LastActivityDate': '2013-05-11T22:39:06.897', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11928', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '7957', 'Tags': '<formal-languages><pushdown-automata>', 'CreationDate': '2013-05-10T06:38:48.983', 'FavoriteCount': '1', 'Id': '11925'},22_185:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Does there exist a cellular automaton (in 2D) which simulates a $1/r$ force between particles?</p>\n\n<p>More specifically, I would like to know whether it is possible, with strictly local update rules, to have two objects (defined within the model) attract each other with a $1/r$ force, where $r$ is the distance separating the objects.  This would in particular entail an acceleration of the object (particles) as they get closer together.</p>\n\n<p>More generally, can long range attractive forces between objects (blobs) be simulated in a cellular automaton setting with strictly local rules?</p>\n', 'ViewCount': '142', 'Title': '1/r attractive force by cellular automaton', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-21T21:02:17.623', 'LastEditDate': '2013-05-10T13:30:34.107', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8114', 'Tags': '<simulation><cellular-automata>', 'CreationDate': '2013-05-10T12:57:12.817', 'FavoriteCount': '3', 'Id': '11933'},22_186:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>So I\'ve been trying to crack this for a long time and almost feel like I am going in loops about this question.</p>\n\n<p>Given the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hL3Ps.png" alt="enter image description here"></p>\n\n<p>Using the GNFA algorithm get the regular expression.</p>\n\n<p>I understand that you would have the following for the first step(adding empty states):\n<img src="http://i.stack.imgur.com/6XXjj.png" alt="enter image description here"></p>\n\n<p>The next step would be removing the state [q1] I would get:\n<img src="http://i.stack.imgur.com/cwjUd.png" alt="enter image description here"></p>\n\n<p>Finally removing [q2] would get:\n<img src="http://i.stack.imgur.com/WW3Fj.png" alt="enter image description here"></p>\n\n<p>However the answers others have got is:\n$(a \\cup bb^*a)^*bb^*$\nWhich does not make sense as I got, $a^*b(b \\cup aa^*b)^*$?\nA GNFA(generalised nondeterministic finite automaton) is described as follows:</p>\n\n<p>A GNFA is similar to an NFA but must obey certain rules: </p>\n\n<ul>\n<li>It has only one accept state</li>\n<li>The initial state has no transitions coming into it</li>\n<li>The accept state has no transitions coming out from it</li>\n<li>A transition can denote any regular expression, rather than just a\nsymbol from the alphabet Note that a symbol is a kind of regular\nexpression.</li>\n</ul>\n\n<p>Furthermore, We may convert an NFA into a GNFA as follows: </p>\n\n<ul>\n<li>Add a new start state with an \u03b5-transition to the old start state</li>\n<li>Add a new accept state with \u03b5-transitions from the old accept states</li>\n<li>If arrows have multiple labels, or if there are multiple arrows\nbetween two states, replace them with the union (or) of those labels</li>\n</ul>\n', 'ViewCount': '2097', 'Title': 'Converting an NFA to regex using GNFA algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:23:30.563', 'LastEditDate': '2013-05-12T10:23:30.563', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '11950', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata><regular-expressions><nondeterminism>', 'CreationDate': '2013-05-10T14:50:56.853', 'Id': '11935'},22_187:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm doing a college work about automatons. In one exercise I've to compare two words with five letters each one, but I don't know how to do it, do you have any tutorial or example for that? </p>\n", 'ViewCount': '205', 'Title': 'Compare two words using a Pushdown Automaton', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-05-13T09:05:23.137', 'LastEditDate': '2013-05-13T03:32:10.813', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'OwnerDisplayName': 'Buni', 'PostTypeId': '1', 'Tags': '<pushdown-automata>', 'CreationDate': '2013-05-03T13:56:15.510', 'Id': '11980'},22_188:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am converting NFA <b>with $\\varepsilon$-moves </b> to the NFA <b>without </b> $\\varepsilon$-null moves. I understand that if, there is a $\\varepsilon$-move between, $q_i$ and $q_j$, then all edges from $q_j$ have to be repeated from $q_i$. And if the $q_j$ is a final state, then $q_i$ will also be a final state.</p>\n\n<p>But, if $q_j$ does not contain any transition, i.e., there are no edges starting from $q_j$, then what has to be done? </p>\n', 'ViewCount': '673', 'Title': 'How to convert NFA with null moves to NFA without null moves?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-05-16T16:06:25.040', 'LastEditDate': '2013-05-14T06:58:57.550', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8155', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-05-14T05:56:21.350', 'Id': '12003'},22_189:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have talked to my friend and he said this is the only place somebody could know how to solve it. It is the only exercise(from around 80) from exam revise I just do not know how to do at all.</p>\n\n<p>Create pushdown automation for\n<code>{w: #a(w) &gt;= 2#b(w)};</code> and simulate it for the word <code>ababaaa</code></p>\n\n<p><code>#</code> means number</p>\n\n<p>Does any one of you is fluent enought in automation to solve it?</p>\n', 'ViewCount': '30', 'ClosedDate': '2013-05-14T10:53:56.813', 'Title': 'Pushdown automation where number of letter `a` is at least as twice as letter `b` in the word', 'LastActivityDate': '2013-05-14T08:55:13.050', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8161', 'Tags': '<pushdown-automata>', 'CreationDate': '2013-05-14T08:55:13.050', 'Id': '12010'},22_190:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '135', 'Title': 'Pushdown automation where number of letter `a` is at least as twice as letter `b` in the word', 'LastEditDate': '2013-05-14T09:13:13.517', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'user2380858', 'PostTypeId': '1', 'OwnerUserId': '8161', 'FavoriteCount': '1', 'Body': '<p>I have talked to my friend and he said this is the only place somebody could know how to solve it. It is the only exercise(from around 80) from exam revise I just do not know how to do at all.</p>\n\n<p>Create pushdown automation for\n<code>{w: #a(w) &gt;= 2#b(w)};</code> and simulate it for the word <code>ababaaa</code></p>\n\n<p><code>#</code> means number</p>\n\n<p>Does any one of you is fluent enought in automation to solve it?</p>\n', 'Tags': '<pushdown-automata>', 'LastEditorUserId': '4873', 'LastActivityDate': '2013-05-14T09:13:13.517', 'CommentCount': '0', 'CreationDate': '2013-05-14T08:51:09.267', 'Id': '12011'},22_191:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can the set of states Q be empty by definition?</p>\n\n<p>I was wondering about this question when doing exercises in the pumping lemma for finite automaton.</p>\n', 'ViewCount': '92', 'Title': 'DFA: Can the set of States Q be empty by definition?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-22T08:01:43.090', 'LastEditDate': '2013-05-22T08:01:43.090', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12167', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8272', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2013-05-20T19:52:43.710', 'Id': '12166'},22_192:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following <em>universe problem</em>.</p>\n\n<blockquote>\n  <p><strong>The universe problem.</strong> Given a finite set $\\Sigma$ for a class of languages, and an automaton accepting the language $L$, decide if $L=\\Sigma^*$.</p>\n</blockquote>\n\n<p>In [1], it is stated and proved that the universe problem is undecidable for a particular class of one-counter automata. This result then follows for the class of all non-deterministic one-counter automata. I\'m wondering if it is known whether this problem is still undecidable when we restrict the size of the input alphabet of the automaton. </p>\n\n<p>I think that with alphabet size 1 the problem becomes decidable, but what about size 2? And if that turns out to be decidable what is the smallest value of $n \\in \\mathbb{N}$ such that the problem is undecidable.</p>\n\n<p>I think it\'s probable that the answer to this question is known but I\'m having trouble finding an answer. If it is already known then I would appreciate a reference.</p>\n\n<hr>\n\n<p>[1] <a href="http://link.springer.com/article/10.1007%2FBF01744294">Ibarra, O. H. (1979). Restricted one-counter machines with undecidable universe problems. Mathematical systems theory, 13(1), 181-186</a></p>\n', 'ViewCount': '126', 'Title': 'Is the universe problem for one-counter automata with restricted alphabet size undecidable?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T15:29:14.707', 'LastEditDate': '2013-05-23T17:42:41.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12235', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '769', 'Tags': '<formal-languages><reference-request><automata><undecidability><decision-problem>', 'CreationDate': '2013-05-23T16:56:50.530', 'Id': '12233'},22_193:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Question:The set of all first names given to children born in New Zealand in 1996</p>\n\n<p>I think this language is regular because every element in the set can be a accept state</p>\n\n<p>How can I prove if the language is regular?</p>\n', 'ViewCount': '65', 'Title': 'Regular language proving', 'LastEditorUserId': '157', 'LastActivityDate': '2013-05-25T00:56:19.277', 'LastEditDate': '2013-05-25T00:56:19.277', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8341', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-05-24T22:06:59.133', 'Id': '12256'},22_194:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it theoretically possible to have a nondeterministic finite state machine without any initial state or does it need at least one initial state?</p>\n', 'ViewCount': '122', 'Title': 'Nondeterministic finite state machine without any initial state possible', 'LastActivityDate': '2013-05-29T15:15:48.100', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8414', 'Tags': '<formal-languages><regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2013-05-28T18:27:39.930', 'Id': '12338'},22_195:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://www.cs.rpi.edu/~moorthy/Courses/modcomp/fall2005/slides/DPDA.ppt&amp;ei=qI6mUeD6KaKOigLr-YH4Cg&amp;usg=AFQjCNHdu1SacbRI9CaOjOvXxzNziaHtEQ&amp;sig2=DLSgGZ-VegxX1lFVSTZTCw&amp;bvm=bv.47244034,d.cGE">These lecture slides</a> sketch a proof that $L=\\{ a^n b^n \\mid n \\geq 0 \\} \\cup  \\{ a^n b^{2n} \\mid n \\geq 0 \\}$\ncannot be accepted by any Deterministic Pushdown Automaton. Unfortunately, the slides give no references as to where the proof comes from.</p>\n\n<p>I was wondering, does anybody know of an academic paper or textbook that gives a full proof? I\'d love to be able to cite it, but I haven\'t been able to find one.</p>\n', 'ViewCount': '143', 'Title': 'Paper with proof that $L=\\{ a^n b^n \\mid n \\geq 0 \\} \\cup \\{ a^n b^{2n} \\mid n \\geq 0 \\}$ is not Deterministic Context Free?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-29T20:10:06.177', 'LastEditDate': '2013-11-29T20:10:06.177', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12367', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><reference-request><automata><pushdown-automata><nondeterminism>', 'CreationDate': '2013-05-29T23:32:51.367', 'Id': '12365'},22_196:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<blockquote>\n  <p>Describe a (general) procedure that, given some finite automaton M, produces a new finite automaton M\u2019 with:  M\u2019 rejects \u03b5, but accepts otherwise the identical language as M does.Note that M may or may not accept \u03b5, while M\u2019 does not!</p>\n</blockquote>\n\n<p>My solution is to discuss the different cases. If M doesn't contain \u03b5, then, don't need to produce a new M', but if M contains \u03b5-transition, then convert it to DFA. I'm not sure my procedure is right or not.</p>\n\n<p>Can someone come up with some more effective idea?</p>\n", 'ViewCount': '160', 'Title': 'Given NFA to recognize a language, construct a new NFA for that language without the empty string', 'LastEditorUserId': '755', 'LastActivityDate': '2013-07-26T06:14:57.440', 'LastEditDate': '2013-07-26T06:14:57.440', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-06-10T02:54:21.953', 'Id': '12579'},22_197:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If not, then what does it mean when for some state $q$ and some symbol $a$, $\\delta(q, a)$ does not exist?</p>\n', 'ViewCount': '667', 'Title': 'In a DFA, does every state have a transition on every symbol of the alphabet?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T22:42:05.853', 'LastEditDate': '2013-06-10T11:16:39.073', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '12596', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2013-06-10T05:15:52.510', 'Id': '12587'},22_198:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to prove a bisimulation relation on $CA_{\\tau}(N)$ (communication algebra with tau-steps) and names $N$.</p>\n\n<p>It need to prove that $p!d.x||p?d.y$ is bisimular with $p!d.(x||p?d.y)+p?d.(p!d.x||y)$ by finding a suitable bisimulation relation $R$.</p>\n\n<p>I was thinking of $R=\\{(x,x) \\mid x \\text{ is a reachable state} \\} \\cup \\{(p!d.(x||p?d.y)+p?d.(p!d.x||y) \\mid x\\text{ and }y \\text{ are reachable states} \\}$.</p>\n\n<p>Is this a suitable relation? How do I prove that.</p>\n\n<p>Note: the definition of bisimularity in this book is:\n$x$ is bisimilar with $y$ when there exists and relation $R$ on automata $M$ and $M'$ with sets of states $S$, $S'$ such that:</p>\n\n<ol>\n<li>$R$ relates the reachable states</li>\n<li>$R$ relates the initial states</li>\n<li>Whenever $sRs'$ and $s$ has an $a$ step to $t$ for some $a$ in the alphabet, then there are states $s''$ and $t'$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and $s''$ has an $a$ step to $t'$ and both $sRs''$ and $tRt'$.</li>\n<li>Whenever $sRs'$ and $s'$ has an $a$ step to $t'$, then there are states $s''$ and $t$ in $S$ such that $s$ has an $\\epsilon$ path to $s''$ and $s''$ has an $a$ step to $t$ and both $s''Rs'$ and $tRt'$.</li>\n<li>Whenever $sRs'$ and $s$ has an $\\tau$ step to $t$, then there are states $s''$ and $t'$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and either:\n<ol>\n<li>$s''=t'$ or</li>\n<li>$s''$ has an $\\tau$ step to $t'$ and both $sRs'$ and $tRt'$</li>\n</ol></li>\n<li>Same as $5$, but then from $M'$ to $M$.</li>\n<li>Whenever $sRs'$ and $s'$ terminates, then there is a state $s''$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and $s''$ terminates and $sRs''$.</li>\n<li>Same as 7, but then from $M'$ to $M$.</li>\n</ol>\n\n<p>How can I prove such relation?</p>\n", 'ViewCount': '56', 'Title': 'Prove a bisimulation relation', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-11T12:55:25.187', 'LastEditDate': '2013-06-11T12:55:25.187', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8588', 'Tags': '<automata><proof-techniques><correctness-proof>', 'CreationDate': '2013-06-10T08:50:59.530', 'Id': '12591'},22_199:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Of course, converting NFA to DFA is not a problem. But what about the other direction?</p>\n\n<p>My motivation is the notion of minimization regular expressions using the DFA minimization algorithm.</p>\n', 'ViewCount': '123', 'Title': 'Can we minimise regular expressions using known DFA minimisation algorithms?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-11T16:57:51.563', 'LastEditDate': '2013-06-11T16:57:51.563', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '1', 'OwnerDisplayName': 'Jendas', 'PostTypeId': '1', 'OwnerUserId': '6541', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-06-11T08:51:24.510', 'Id': '12612'},22_200:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Or at least generate a set of strings that one NFA accepts, so I can feed it into the other NFA.  If I do a search through every path of the NFA, will that work?  Although that will take a long time.</p>\n', 'ViewCount': '149', 'Title': 'Is there a way to test if two NFAs accept the same language?', 'LastActivityDate': '2013-06-11T18:47:24.080', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12625', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<algorithms><regular-languages><finite-automata>', 'CreationDate': '2013-06-11T17:23:26.430', 'FavoriteCount': '1', 'Id': '12624'},22_201:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '124', 'Title': 'Myhill-Nerode style characterization of CFL?', 'LastEditDate': '2013-11-02T13:57:51.987', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5323', 'FavoriteCount': '2', 'Body': '<p>Define the <em>Nerode equivalence</em> over a language $L \\subseteq \\Sigma^{*}$ as $u \\sim_L v$ iff $uw \\in L \\Leftrightarrow vw \\in L$ for every $w \\in \\Sigma^{*}$.</p>\n\n<p>The Nerode equivalence ${\\sim}_L$ has finitely many equivalence classes precisely when $L$ can be recognized by a finite-state automaton.  This is the <a href="http://en.wikipedia.org/wiki/Myhill%E2%80%93Nerode_theorem" rel="nofollow">Myhill-Nerode theorem</a>.</p>\n\n<blockquote>\n  <p>Is there a similar characterization of context-free languages?</p>\n</blockquote>\n\n<hr>\n\n<h1>Motivation:</h1>\n\n<p>The Nerode equivalence classes each correspond to a distinct state in any automaton that recognizes $L$.  Each CFL can be recognized by an NPDA, which has a finite number of states but also a potentially unbounded stack of alphabet symbols.  The stack keeps track of one possible way that a string can be parsed.  The number of equivalence classes may be infinite since the stack can store an unbounded number of symbols.</p>\n\n<p>I am asking: is there always a way to clump together equivalence classes so that each clump represents one state of the PDA, with each class within the clump representing equivalent states of the stack for that PDA state?</p>\n\n<p>For instance, the language of properly nested parentheses only needs states to handle <code>pop</code> and <code>push</code>, as the stack will keep track of the current nesting depth.  If such clumping can always be done, then whether the number of clumps is finite determines whether the language is context-free.</p>\n\n<hr>\n\n<p>As pointed out by @sdcvvc in a comment, a form of this question was asked as <a href="http://math.stackexchange.com/questions/118362">http://math.stackexchange.com/questions/118362</a> although Yuval Filmus\'s answer to the related question at <a href="http://cs.stackexchange.com/questions/12041/example-of-a-non-context-free-language-that-nonetheless-can-be-pumped/12044#12044">Example of a non-context free language that nonetheless CAN be pumped?</a> is more relevant.</p>\n', 'Tags': '<formal-languages><context-free><pushdown-automata>', 'LastEditorUserId': '5323', 'LastActivityDate': '2013-11-02T13:57:51.987', 'CommentCount': '1', 'AcceptedAnswerId': '12645', 'CreationDate': '2013-06-12T21:49:16.247', 'Id': '12643'},22_202:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '409', 'Title': 'Why is NFA minimization a hard problem when DFA minimization is not?', 'LastEditDate': '2013-06-15T18:22:30.120', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I know that we can minimize DFAs by finding and merging equivalent states, but why can't we do the same with NFAs?  I'm not looking for a proof or anything like that--unless a proof is simpler to understand.  I just want to understand intuitively why NFA minimization is so hard when DFA minimization is not.</p>\n", 'Tags': '<complexity-theory><finite-automata><nondeterminism>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-06-18T03:28:02.137', 'CommentCount': '0', 'AcceptedAnswerId': '12712', 'CreationDate': '2013-06-15T17:57:35.147', 'Id': '12693'},22_203:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '141', 'Title': 'Are HTML and CSS regular languages?', 'LastEditDate': '2013-06-24T17:18:01.450', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8839', 'FavoriteCount': '1', 'Body': '<p>I have a question whether or not CSS and HTML are regular languages.</p>\n\n<p>I believe CSS is a regular language, since it should be possible to create a regular expression to match the structure of CSS.</p>\n\n<p>However, I believe that HTML is <strong>not</strong> a regular language since you have nested attributes that could be defined recursively.</p>\n', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-24T17:18:01.450', 'CommentCount': '7', 'AcceptedAnswerId': '12869', 'CreationDate': '2013-06-24T14:45:41.140', 'Id': '12867'},22_204:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Given $m,n\\in\\mathbb{N}$, finite alphabet $A=\\{a,b,c\\}$, and $L=\\{(a^m,a^n)\\}^*=\\{(a^{mk},a^{nk})|k\u2208N\\}\\subseteq A^*\\times A^*$. \nIs this binary language $L$ regular over $A(2,\\$)$ (i.e. $\\{A\u222a\\{\\$\\}\\}\\times \\{A\u222a\\{\\$\\}\\}\\setminus \\{\\$,\\$\\}$)? </p>\n\n<p>For example, is this binary language $L=\\{(a^3,a^7)\\}^*=\\{(a^{3k},a^{7k})|k\u2208N\\}=\\{(a^3,a^7),(a^6,a^{14}),(a^{9},a^{21})(a^{12},a^{28})...\\}$ regular over $A(2,\\$)$?</p>\n\n<p>An illustration of the difference between binary regular language and unitary regular language: Let $L=\\{(w,w')\\mid w\\in L^1,w'\\in L^2\\text{, and }L^1,L^2\\text{ are  unitary  languages}\\}$ be a binary language, the length of $w$ and $w'$ maybe not all the same (suppose some $|w|&gt;|w'|$). Firstly, we must add \\$'s behind $w'$ such that all $|w|=|w'\\$...|$, then we get a new language $L^{\\$}$. And we will say $L$ is regular if and only if $L^{\\$}$ is regular (i.e. there is exist a finite binary automaton to recognize $L^{\\$}$).</p>\n\n<p>And if the binary language $L$ can be showed as finite regular binary languages with the operations: union, intersection, complement, concatenation, $L$ is also regular.</p>\n", 'ViewCount': '161', 'Title': 'Binary regular language?', 'LastEditorUserId': '8880', 'LastActivityDate': '2013-06-28T06:31:56.503', 'LastEditDate': '2013-06-26T13:51:18.613', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8880', 'Tags': '<regular-languages><automata>', 'CreationDate': '2013-06-26T06:36:30.927', 'FavoriteCount': '0', 'Id': '12906'},22_205:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '236', 'Title': 'What is a good algorithm for generating random DFAs?', 'LastEditDate': '2013-06-29T08:40:23.377', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I am generating random DFAs to test a DFA reduction algorithm on them.</p>\n\n<p>The algorithm that I'm using right now is as follows: for each state $q$, for each symbol in the alphabet $c$, add $\\delta (q, c)$ to some random state.  Each state has the same probability of becoming a final state.</p>\n\n<p>Is this a good method of generating unbiased DFAs?  Also, this algorithm doesn't generate a trim DFA (a DFA with no obsolete states) so I'm wondering if there is a better way of generating random DFAs that can somehow ensure that it is trim?</p>\n", 'Tags': '<algorithms><finite-automata><random><pseudo-random-generators><random-graphs>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-18T10:13:05.943', 'CommentCount': '9', 'AcceptedAnswerId': '12949', 'CreationDate': '2013-06-28T05:14:15.410', 'Id': '12943'},22_206:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given s as a string of some alphabet, what is the best known algorithm to compute a corresponding automaton that accepts any string that contains s?</p>\n\n<p>I am mostly intrested of the lowest time complexity so if you tell me what is the best known complexity in O notation to build an automaton for a string that would be just as good.</p>\n', 'ViewCount': '256', 'Title': 'Automaton for substring matching', 'LastEditorUserId': '1033', 'LastActivityDate': '2013-07-02T07:49:31.180', 'LastEditDate': '2013-07-01T12:02:13.157', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1033', 'Tags': '<automata><finite-automata><strings><substrings>', 'CreationDate': '2013-07-01T10:48:25.027', 'Id': '13009'},22_207:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If Turing Machines are the automata equivalent of the $\\lambda$ calculus, what is the automaton equivalent of the $\\pi$ calculus? I suppose it would be some class of automata that resembled a Turing Machine, but with support for communication channels or signals of some type, but I'm not sure, and would appreciate some direction.</p>\n", 'ViewCount': '153', 'Title': u'Automaton equivalent of the \u03c0 calculus?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-27T21:21:29.893', 'LastEditDate': '2013-09-17T17:40:08.220', 'AnswerCount': '2', 'CommentCount': '11', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<automata><concurrency><machine-models><pi-calculus>', 'CreationDate': '2013-07-05T02:12:24.763', 'FavoriteCount': '3', 'Id': '13091'},22_208:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So, it's fairly easy to prove that if $L \\in DCFL$, then $L \\Sigma^* \\in DCFL$. Basically, you take the DPDA accepting $L$. You remove all transitions on final states, and then for each $a \\in \\Sigma$ and each final state $q$, you add a transition looping from $q$ to $q$ on $a$.</p>\n\n<p>I'm using this in a paper, and I'd love to not have to actually prove this construction is valid. It's easy, but it's about a half-page long. Since DPDAs have been studied almost exhaustively, I was wondering, does anybody know of a paper that proves this property?</p>\n", 'ViewCount': '138', 'Title': 'Reference request: proof that if $L \\in DCFL$, then $L \\Sigma^* \\in DCFL$', 'LastActivityDate': '2013-07-10T20:22:04.583', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13215', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><reference-request><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-07-09T17:23:08.623', 'Id': '13179'},22_209:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm doing some research with NFAs, and I'm wondering there are algorithms which quasi-efficiently minimize them. I realize that this problem is $PSPACE$ hard, so I'm not looking for a polynomial time algorithm.</p>\n\n<p>What I mean by this is an algorithm which may run in exponential time in the worst cases, but which uses some sort of heuristic to speed up the process, albiet not enough to make it exponential.</p>\n\n<p>I'm only using this to try to get a better idea of what the minimal NFAs of certain languages look like. I'm not using it in any production code, so it doesn't need to be blazingly fast.</p>\n\n<p>For example, the Antichains algorithm for NFAs does equivalence testing which is usually fast but sometimes has exponential explosion. I'm looking for something similar, but for minimization.</p>\n\n<p>Note that I'm NOT looking for things like equivalences, etc. which run efficiently but don't produce a minimal NFA.</p>\n\n<p>Bonus points to anyone who find one with an implementation, and quadruple bonus points if it's in Prolog or Python.\nIf the tool I'm looking for doesn't exist, I'd be happy if anyone gave any old implementation of NFA minimization.</p>\n", 'ViewCount': '152', 'Title': 'Are there algorithms to exactly minimize NFAs which are sometimes efficient?', 'LastActivityDate': '2014-02-05T14:19:54.790', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<algorithms><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-07-10T17:56:35.363', 'FavoriteCount': '1', 'Id': '13206'},22_210:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is somewhat related to <a href="http://cs.stackexchange.com/questions/13206/are-there-algorithms-to-exactly-minimize-nfas-which-are-sometimes-efficient?noredirect=1#comment27879_13206">another question I asked</a>, but I feel it\'s different enough to warrant its own question.</p>\n\n<p>I\'m doing research where I\'m trying to find the structure of complements of a certain class of finite languages. It\'s easy for me to get the minimal DFAs accepting these languages, but I\'d like to examine what kind of structure NFAs accepting these langauges have, particularly how nondeterminism helps with state-size of the automata (the DFAs are exponentially large).</p>\n\n<p>The problem is, the main NFA reduction technique uses equivalences, which won\'t produce any reduction if I start with a minimal DFA (since it\'s basically using the same technique). If I start with a non-minimal DFA, it just spits out the minimal DFA.</p>\n\n<p>What I\'m wondering is, are there algorithms which can start with a DFA, and shrink it into a smaller NFA by introducing nondeterminism? Are there "standard techniques" to do this?</p>\n\n<p>I have found <a href="http://www.csd.uwo.ca/faculty/ilie/TisF04.pdf">preorder reductions</a>, which look promising but hard to implement. I\'m open to many suggestions.</p>\n', 'ViewCount': '205', 'Title': 'Algorithm to shrink a DFA by introducing nondeterminism?', 'LastActivityDate': '2013-07-17T13:39:28.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '13266', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><automata><finite-automata><discrete-mathematics><nondeterminism>', 'CreationDate': '2013-07-12T16:19:26.300', 'FavoriteCount': '1', 'Id': '13249'},22_211:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>It's known that the complement of a DFA can be easily formed. That is, given a machine $M$, we can construct $M'$ such that $L(M') = \\Sigma^* \\setminus L(M)$.</p>\n\n<p>Is it possible to construct such a complement for a non-deterministic finite automation (NFA)? To my knowledge, it isn't.</p>\n", 'ViewCount': '1457', 'Title': 'Complement of Non deterministic Finite Automata', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-16T18:40:12.790', 'LastEditDate': '2013-07-16T10:18:36.350', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9190', 'Tags': '<automata><finite-automata><closure-properties>', 'CreationDate': '2013-07-15T10:40:24.740', 'FavoriteCount': '1', 'Id': '13282'},22_212:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m attepting to model a process flow where the transition to the next state is occasionally based on not only the input to the current state, but a prior state as well.</p>\n\n<p>Below is an example graph descibring the process. The essence is: If both State Q1 and State Q3 recieve an input of one, after State 3, transition to State Q4, otherwise transition to State Q5.</p>\n\n<p><img src="http://i.stack.imgur.com/DcBTc.png" alt="Non-state dependent machine"></p>\n\n<p>I understand that it would be possible to model this using a finite-state machine where we duplicate any states between those that we are interested in. The example below demonstrates this with States Q2a and Q2b corresponding to the differences in input at state Q1</p>\n\n<p><img src="http://i.stack.imgur.com/r9cMs.png" alt="State-dependent"></p>\n\n<p>However, as the number of conditions and the gaps between them grows (both of which are possible in the process I\'m looking at), the number of states grows exponentially.</p>\n\n<p>The question is, what other computational models could be used to describe a process where an arbitrary number of inputs could be used to control transition between states?</p>\n', 'ViewCount': '96', 'Title': 'State machine with knowledge of prior states?', 'LastActivityDate': '2013-07-22T11:24:27.433', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8632', 'Tags': '<graphs><automata><network-flow>', 'CreationDate': '2013-07-22T00:27:48.457', 'Id': '13379'},22_213:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve written a recursive-descent parser generator, and I\'m trying to classify it (call me a cowboy coder if you must). According to wikipedia, <code>S \u2192 0S0 | 1S1 | \u03b5</code>, which checks for an even-length palindrome, is a non-deterministic grammar. My parser generator can handle this grammar. Does that mean my parser is non-deterministic?</p>\n\n<p>To be honest, I\'m not even sure that it\'s proper to try to classify it like this. It doesn\'t really match the description of a pushdown automata, since it passes data up and down through the stack (parameters, passed by reference, which may be modified). If anyone would be interested in taking a closer look at it, I\'d be most grateful. It handles left recursion and ambiguous grammars in (I believe) polynomial time and space. <a href="https://github.com/coder0xff/parlex" rel="nofollow">https://github.com/coder0xff/parlex</a></p>\n', 'ViewCount': '177', 'Title': 'If a parser can parse a non-deterministic grammar, is the parser non-deterministic?', 'LastActivityDate': '2013-07-22T18:51:39.117', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13395', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<formal-grammars><pushdown-automata><parsers>', 'CreationDate': '2013-07-22T17:38:48.407', 'Id': '13393'},22_214:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I realize non-deterministic pushdown automata can be an improvement over deterministic ones as they can "choose" among several states and there are some context-free languages which cannot be accepted by a deterministic pushdown.</p>\n\n<p>Still, I do not understand <em>how</em> exactly they "choose". For palindormes for example every source I found just says the automaton "guesses" the middle of the word. What does that mean?</p>\n\n<p>I can think of several possible meanings:</p>\n\n<ol>\n<li><p>It goes into one state randomly and therefore might not accept a\nword, which actually is in the language</p></li>\n<li><p>It somehow goes\n"every possible way", so if the first one is wrong it tests if any\nof the other might be right</p></li>\n<li><p>There is some mechanism I am not\naware of, that chooses the middle of the word and is therefore not\nrandom, but the automaton always finds the right middle.<br></p></li>\n</ol>\n\n<p>This is just an example; what I want to know is how it works for any automaton that has several following states for one and the same state before it.</p>\n', 'ViewCount': '118', 'Title': 'Push Down Automatons "guess" - what does that mean?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-07-23T19:18:13.910', 'LastEditDate': '2013-07-23T19:13:48.330', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9308', 'Tags': '<formal-languages><automata><pushdown-automata><nondeterminism>', 'CreationDate': '2013-07-23T17:57:55.890', 'Id': '13400'},22_215:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My task is to design a FSM whose output goes high for a single cycle whenever the pattern 0110 is detected on its input. The patterns may overlap, so an input 0110110 of would cause the output to go high twice- once for the first pattern (0110110), and once for the second pattern (0110110). a is used for the input and f is used for the output.</p>\n\n<p>I am assuming I will need five state bubbles <a href="http://i.stack.imgur.com/ghKNq.png" rel="nofollow">like this.</a></p>\n\n<p>Is this correct or am I missing some cases based on the pattern going high twice if the pattern overlaps?</p>\n', 'ViewCount': '164', 'Title': 'How to design a finite state machine to detect 0110 in the input?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-07-25T18:18:36.643', 'LastEditDate': '2013-07-25T18:18:36.643', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9332', 'Tags': '<finite-automata><digital-preservation>', 'CreationDate': '2013-07-25T01:30:33.483', 'Id': '13425'},22_216:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm wondering, what is the time-complexity of determining emptiness for 2-way DFAs? That is, finite automata which can move backwards on their read-only input tape.</p>\n\n<p>According to Wikipedia, they are equivalent to DFAs, though the equivalent DFA might be exponentially larger. I've found state complexity for their complements and intersections, but not for their emptiness-testing.</p>\n\n<p>Does anyone know of a paper where I could find this?</p>\n", 'ViewCount': '135', 'Title': 'What is the complexity of the emptiness problem for 2-way DFAs?', 'LastActivityDate': '2013-07-30T14:30:26.037', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13482', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><reference-request><automata><finite-automata>', 'CreationDate': '2013-07-26T22:35:28.517', 'Id': '13456'},22_217:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Recently an interesting question was asked and subsequently deleted.</p>\n\n<p>For a regular language $L$, its <em>DFA complexity</em> is the size of the minimal DFA accepting it, and its <em>NFA complexity</em> is the size of the minimal NFA accepting it. It is well-known that there is an exponential separation between the two complexities, at least when the size of the alphabet is unbounded. Indeed, consider the language $L_n$ over the alphabet $\\{1,\\ldots,n\\}$ consisting of all words <em>not</em> containing all symbols. Using the Myhill-Nerode theorem it is easy to calculate the DFA complexity $2^n$. On the other hand, the NFA complexity is only $n$ (if multiple initial states are allowed; otherwise it is $n+1$).</p>\n\n<p>The deleted question concerned the <em>DFA covering complexity</em> of a language, which is the minimal $C$ such that $L$ can be written as the (not necessarily disjoint) union of languages of DFA complexity at most $C$. The DFA covering complexity of $L_n$ is only $2$.</p>\n\n<blockquote>\n  <p>Is there an exponential separation between NFA complexity and DFA covering complexity?</p>\n</blockquote>\n', 'ViewCount': '108', 'Title': 'Exponential separation between NFAs and DFAs in the presence of unions', 'LastActivityDate': '2013-07-27T11:42:51.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13465', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '683', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-07-27T11:42:51.633', 'Id': '13464'},22_218:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Full disclosure, I'm interested in what this means about transformations on NFAs, but regex expressions seem like a easy way to ask the question.</p>\n\n<p>If you have a regex that uses the plus operator (match one or more) can it, in the general case, be transformed into a regex that uses only the star operator (match zero or more).</p>\n\n<p>Since all regular expressions can be converted into an NFA, and all NFAs can be converted into a regular expression (assuming the alphabet is the unicode character set lol), if it's true for one, it's true for both.</p>\n\n<p>An hand-contrived example regex:</p>\n\n<pre><code>&lt;[a-zA-Z]+&gt;\n</code></pre>\n\n<p>A regex recognizing the same language, without the + operator:</p>\n\n<pre><code>&lt;[a-zA-Z][a-zA-Z]*&gt;\n</code></pre>\n\n<p>This may seem intuitively true for such a simple example, but I'd like to know for certain that it is generally true. Also, is there an algorithm that can convert an NFA containing a plus-like flow into a star-like flow NFA? Thanks!</p>\n", 'ViewCount': '243', 'Title': 'Can the plus operator in regex be replaced by the star operator?', 'LastActivityDate': '2013-07-27T21:28:16.823', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<automata><regular-expressions>', 'CreationDate': '2013-07-27T21:19:18.777', 'Id': '13470'},22_219:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a practice problem for a midterm in a class I'm taking:</p>\n\n<blockquote>\n  <p>Given a regular language $L$, describe formally a Turing machine that recognize $L$. </p>\n</blockquote>\n\n<p>I'm not sure how I should do that.</p>\n", 'ViewCount': '440', 'Title': 'How can a Turing Machine recognize a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T15:30:56.463', 'LastEditDate': '2013-07-30T10:26:40.687', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<turing-machines><regular-languages><automata><finite-automata><simulation>', 'CreationDate': '2013-07-29T19:45:40.207', 'Id': '13500'},22_220:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am looking for an example, which corresponds to what I've learned in my Applied Automata Theory Class:</p>\n\n<p>Given a NFA $\\mathcal{A}$, </p>\n\n<ul>\n<li>a $\\approx _\\mathcal{A}$ quotient automaton can be bigger then a $\\sim_\\mathcal{A}$ quotient automaton and this can be bigger than an optimal quotient </li>\n<li>and an optimal quotient does not need to be the smallest equivalent NFA.</li>\n</ul>\n\n<p>$\\approx _\\mathcal{A}$ denotes the bisimulation relation (block refinement algorithm) and $\\sim_\\mathcal{A}$ denotes the canonical congruence, where $p \\sim_\\mathcal{A} q \\text{ iff } \\delta^*(p,w) \\in F \\text{ iff } \\delta^*(q,w) \\in F$, where DFA $\\mathcal{A}= (Q, \\Sigma, q_0, \\delta, F)$.</p>\n\n<p>Follow-up:</p>\n\n<p>The original Automaton $\\mathcal{A}$ over $\\Sigma={\\{a,b\\}}$ recognizing $\\mathcal{L} = \\Sigma a^*$:</p>\n\n<p>The original automaton $\\mathcal{A} = (\\{1,2,3,4,5,6\\}, \\Sigma, 1, \\Delta, \\{{3,4}\\}) $ with $\\Delta$:\n\\begin{pmatrix}\n&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\\\\\n1 &amp;- &amp; b &amp; a &amp; -&amp; -&amp;- &amp;  \\\\\n2 &amp;b &amp; b &amp; - &amp; a &amp; -&amp;- &amp;  \\\\\n3 &amp;- &amp; b &amp; - &amp; a&amp; a&amp;- &amp;  \\\\\n4 &amp;- &amp; b &amp; - &amp; a&amp; a&amp;- &amp;  \\\\\n5 &amp;- &amp; - &amp; - &amp; -&amp; -&amp;b &amp;  \\\\\n6 &amp;- &amp; - &amp;  &amp; a&amp; b&amp;b &amp;  \\\\\n\\end{pmatrix}</p>\n\n<p>The quotient automaton $\\mathcal{A}_{\\approx}  = (\\{12,34,5,6\\}, \\Sigma, 12, \\Delta_{\\approx}, \\{{34}\\}) $ with $\\Delta_{\\approx}$:\n\\begin{pmatrix}\n&amp; 12 &amp; 34 &amp; 5 &amp; 6\\\\\n12 &amp;b &amp; a &amp; - &amp; - \\\\\n34 &amp;b &amp; a &amp; a &amp; - \\\\\n5 &amp;- &amp; - &amp; - &amp; b \\\\\n6 &amp;- &amp; a &amp; b &amp; b  \\\\\n\\end{pmatrix}</p>\n\n<p>The quotient automaton $\\mathcal{A}_{\\sim}  = (\\{126,34,5\\}, \\Sigma, 126, \\Delta_{\\sim}, \\{{34}\\}) $ with $\\Delta_{\\sim}$:\n\\begin{pmatrix}\n&amp; 126 &amp; 34 &amp; 5 \\\\\n126 &amp;b &amp; a &amp; b \\\\\n34 &amp;b &amp; a &amp; a  \\\\\n5 &amp;b &amp; - &amp; -  \\\\\n\\end{pmatrix}</p>\n\n<p>The optimal quotient automaton $\\mathcal{A_{OPT}}  = (\\{1256,34\\}, \\Sigma, 1256, \\Delta_{OPT}, \\{{34}\\}) $ with $\\Delta_{OPT}$:\n\\begin{pmatrix}\n&amp; 1256 &amp; 34 \\\\\n1256 &amp;a,b &amp; a \\\\\n34 &amp;a,b &amp; a  \\\\\n\\end{pmatrix}</p>\n\n<p>The first property is satisfied since $\\mathcal{A}_{\\approx}$ has 4 states and $\\mathcal{A}_{\\sim}$ has 3 states. But in my example $\\mathcal{A}_{OPT}$ is the smallest automaton recognizing the given language. When do they differ?</p>\n", 'ViewCount': '83', 'Title': 'Quality of Reduction of finite automata using different congruences', 'LastEditorUserId': '1382', 'LastActivityDate': '2013-08-01T12:30:08.780', 'LastEditDate': '2013-08-01T12:30:08.780', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1382', 'Tags': '<automata><reductions><finite-automata>', 'CreationDate': '2013-07-31T18:04:22.847', 'Id': '13546'},22_221:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '22', 'Title': 'Complement of non-deterministic finite automation', 'LastEditDate': '2013-08-02T15:20:44.810', 'AnswerCount': '0', 'Score': '2', 'OwnerDisplayName': 'Unni', 'PostTypeId': '1', 'FavoriteCount': '0', 'Body': u'<p>Given an NFA, is there a way to \u201ctake its complement\u201d and obtain an NFA that recognizes the complement language?</p>\n', 'ClosedDate': '2013-08-04T23:26:34.703', 'Tags': '<regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-02T15:20:44.810', 'CommentCount': '2', 'CreationDate': '2013-07-15T06:12:30.940', 'Id': '13572'},22_222:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I found the paper "On the State Minimization of Nondeterministic Finite Automata" which, I assume, contains the Kameda-Weiner algorithm that I\'ve been searching for. It\'s behind a paywall though. I\'m just a hobbyist. Can someone explain it, or point me to another source?</p>\n', 'ViewCount': '135', 'Title': 'Free description of the Kameda-Weiner algorithm?', 'LastActivityDate': '2013-09-26T02:01:37.907', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<algorithms><automata><finite-automata>', 'CreationDate': '2013-08-03T18:57:58.530', 'FavoriteCount': '1', 'Id': '13591'},22_223:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve only recently learned anything substantial about finite automata, and I\'ve just come across some things I hadn\'t seen before. Specifically, that classic NFAs are \u222a-NFA, and there are also these things \u2295-NFA , \u2229-NFA and \u22c6-NFA (I love unicode). These can all be seen in <a href="http://fastar.org/publications/PresentationFEW2006Geldenhuys.pdf" rel="nofollow">http://fastar.org/publications/PresentationFEW2006Geldenhuys.pdf</a> or <a href="http://www.cs.sun.ac.za/~lvzijl/publications/fsmnlp2009.pdf" rel="nofollow">http://www.cs.sun.ac.za/~lvzijl/publications/fsmnlp2009.pdf</a></p>\n\n<p>How are these different from the NFAs I\'m familiar with?</p>\n', 'ViewCount': '46', 'Title': u'How do the non-\u222a variants of NFAs work?', 'LastActivityDate': '2013-08-04T08:04:27.787', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13593', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-08-04T04:55:56.147', 'Id': '13592'},22_224:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do you construct a DFA from a  language that has a + sign? e.g. $L = \\{(a+b)\\}*$</p>\n', 'ViewCount': '1836', 'Title': 'Convert regular expression to DFA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-05T08:26:57.573', 'LastEditDate': '2013-08-05T08:26:57.573', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'messivp', 'PostTypeId': '1', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-08-04T12:27:37.260', 'Id': '13599'},22_225:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For my Bachelor\'s thesis, I consider the class of languages recognized by symmetrical DFAs, that is, deterministic (complete) finite automata satisfying the following condition: </p>\n\n<p>Let $A$ be a complete DFA over the alphabet $\\Sigma$. If, for every $a\\in \\Sigma$ and every transition $u \\stackrel{a}{\\longrightarrow}v$ in $A$, there is a transition $v \\stackrel{a}{\\longrightarrow}u$ in $A$, we call $A$ a <em>symmetrical</em> DFA (<em>SDFA</em>). If $A$ is not complete, we call it a <em>partial</em> SDFA. We can regard an SDFA as an undirected, labeled graph in a natural way. </p>\n\n<p>I could find an algebraic characterization of the class of languages recognized by (complete as well as partial) SDFAs and deduce some closure properties. However, neither me nor my supervisor are aware of previous results concerning this particular class of regular languages (barring results like Reingold\'s $\\mathsf{SL = L}$ which might seem related). </p>\n\n<p>Motivated by a <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory?noredirect=1#comment29176_13631">comment</a> that J.-E. Pin passed on <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory">a related question I asked</a>, my question is now:</p>\n\n<blockquote>\n  <p>Are there results concerning these automata?</p>\n</blockquote>\n', 'ViewCount': '130', 'Title': 'Results on the languages recognized by undirected DFAs', 'LastActivityDate': '2013-08-16T06:31:23.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13760', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><regular-languages><finite-automata>', 'CreationDate': '2013-08-15T10:27:23.167', 'Id': '13759'},22_226:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Wikipedia <a href="http://en.wikipedia.org/wiki/Pushdown_automaton" rel="nofollow">Pushdown automaton</a> (as of aug 16, 2013) states:</p>\n\n<blockquote>\n  <p>In general, pushdown automata may have several computations on a given input string, some of which may be halting in accepting configurations. If only one computation exists for all accepted strings, the result is a deterministic pushdown automaton (DPDA)</p>\n</blockquote>\n\n<p>My professor gave this as an example that we shouldn\'t trust Wikipedia but rather consult a textbook. Is he right? </p>\n', 'ViewCount': '287', 'Title': 'Definition of deterministic pushdown automaton', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-17T12:07:54.710', 'LastEditDate': '2013-08-17T12:07:54.710', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<terminology><pushdown-automata>', 'CreationDate': '2013-08-16T22:04:47.060', 'Id': '13783'},22_227:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '73', 'Title': 'Mealy machines to model ciphers', 'LastEditDate': '2013-08-18T03:18:05.613', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '25', 'FavoriteCount': '1', 'Body': u'<p>Similar questions have occurred quite a number of times <a href="http://cs.stackexchange.com/q/10280/25">(1)</a> <a href="http://cstheory.stackexchange.com/q/8539/869">(2)</a> <a href="http://cstheory.stackexchange.com/q/14811/869">(3)</a>, but I have, say, a specific instance of one. I\'m aware of a bunch of applications of finite automata, but would you provide an academic exposition of applications of finite state machines (like, e.g., Mealy machines) in cryptography and ciphers? There is a mention about things like that in Wikipedia article on Mealy machines (<a href="http://en.wikipedia.org/wiki/Mealy_machine#Applications" rel="nofollow">subsection \u201cApplications\u201d</a>). So the links to some academic texts play up on this are very appreciated. Alternatively would you share your thoughts on how to furnish this topic (FSM in cryptography) for students?</p>\n', 'ClosedDate': '2013-08-22T03:37:30.720', 'Tags': '<reference-request><automata><finite-automata><cryptography>', 'LastEditorUserId': '25', 'LastActivityDate': '2013-08-18T06:53:08.120', 'CommentCount': '1', 'AcceptedAnswerId': '13798', 'CreationDate': '2013-08-17T19:55:32.487', 'Id': '13795'},22_228:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://en.wikipedia.org/wiki/Tag_system" rel="nofollow">Tag systems</a> are Turing-complete. I was wondering if there is any easy way to create tag systems that simulate finite automata. So create tag systems that recognize languages, e.g. by having at the end just one output symbol "A" for accepting the initial input or "R" for rejecting it.</p>\n\n<p>I guess a solution would be to make a Tag system simulate a specific Turing machine that simulates a finite automaton but that seems too much and too complicated. Is there perhaps a direct way from tag systems to finite automata?</p>\n', 'ViewCount': '67', 'Title': 'Make a tag system simulate a finite automaton?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:35:42.117', 'LastEditDate': '2013-08-22T14:35:42.117', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '927', 'Tags': '<computability><finite-automata><simulation><computation-models><turing-completeness>', 'CreationDate': '2013-08-19T03:42:11.630', 'FavoriteCount': '1', 'Id': '13808'},22_229:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have been studying the book <em>Introduction to Computation</em> by Michael Sipser on my own, and I'm stuck on this exercise from the chapter on Pushdown Automato and Context-Free Languages. The exercise is to show that  $$A=\\{x\\#y\\,|\\, x \\neq y\\}$$ is a context-free language. </p>\n\n<p>I'm having a hard time proving this because of the second string not reversed. I've tried both making a context-free grammar and a pushdown automata, but in both cases I can't figure out how to make/check that the initial characters of both $x$ and $y$ are the same.</p>\n\n<p>I would appreciate any hints that could help me get to the answer.</p>\n", 'ViewCount': '103', 'Title': 'Constructing a Context Free Grammar for checking non-equality of strings', 'LastActivityDate': '2013-08-22T12:20:47.063', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9778', 'Tags': '<context-free><pushdown-automata>', 'CreationDate': '2013-08-22T12:20:47.063', 'Id': '13866'},22_230:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>This is a homework question, so I am only looking for hints.</em></p>\n\n<p>I got a question in an assignment which states :</p>\n\n<blockquote>\n  <p>Design a DFA that accepts strings having 1 as the 4th character from the end, on the alphabet {0,1}</p>\n</blockquote>\n\n<p>I have been at this for a few hours now, and I think that designing such a DFA is not possible. However, I am not sure how to move forward in this direction to write up a somewhat formal proof. </p>\n\n<p>So, what should I try to do to prove or disprove my hypothesis?</p>\n', 'ViewCount': '1136', 'Title': 'Designing a DFA that accepts strings such that nth character from last satisfies condition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-29T22:28:11.637', 'LastEditDate': '2013-08-29T14:39:17.470', 'AnswerCount': '4', 'CommentCount': '3', 'AcceptedAnswerId': '14021', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2044', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-08-29T01:49:33.573', 'Id': '14008'},22_231:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am preparing for my exam in formal languages and I need some help with one question from one old exam.</p>\n\n<p><img src="http://i.stack.imgur.com/mHEZ6.png" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/eXL8R.png" alt="enter image description here"></p>\n\n<p>I know that the number of equivalence classes of some regular language L, is the number of states of the minimal DFA for that language.</p>\n\n<p>But how do I give a DFA for one of the equivalence classes ? </p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '346', 'Title': 'DFA - Equivalence classes', 'LastActivityDate': '2013-08-30T10:45:40.983', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14028', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2013-08-29T19:57:52.213', 'Id': '14026'},22_232:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In trying to gain a better understanding of finite state machines, I stumbled across this idea and have been confused as to how to approach this case in terms of a DFA.</p>\n\n<blockquote>\n  <p>The set of binary strings of length at least 3 where every substring\n  of length 3 contains at least two 0s.</p>\n</blockquote>\n\n<p>So in other words, something like 100100010 should be in the language (L) for this DFA but something like 11001010 would not be in the language.</p>\n\n<p>I know that you can start off by writing/drawing smaller DFAs for the substrings that are the pattern 000, 010, 100, 001, etc, but I cannot seem to get a hold of how it should look all together.</p>\n\n<p>Any help in understanding this would be appreciated.</p>\n', 'ViewCount': '224', 'Title': 'DFA drawing for binary string with substrings of minimum length 3 with at least two zeroes in each substring', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-02T09:56:55.093', 'LastEditDate': '2013-09-02T09:56:55.093', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '14055', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2013-08-31T03:05:59.700', 'Id': '14050'},22_233:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know finite-state machines can be used to solve yes/no kind of problems, such as finding whether a word is in language or not. Can somebody tell me exactly what FSM cannot do and why?   </p>\n', 'ViewCount': '283', 'Title': 'What exactly can finite-state machines not do?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-04T09:26:11.450', 'LastEditDate': '2013-09-04T09:26:11.450', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-03T09:32:06.420', 'Id': '14093'},22_234:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When a DFA is converted into an equivalent NFA, the NFA gives more convenience to many yes/no kind of problems (such as a word belong to a language or not?). I want to know in general at what price this convenience is achieved?    </p>\n', 'ViewCount': '113', 'Title': 'What is the trade off in converting a DFA into a NFA?', 'LastEditorUserId': '6466', 'LastActivityDate': '2013-09-03T15:17:08.383', 'LastEditDate': '2013-09-03T12:54:36.230', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-03T11:54:53.030', 'Id': '14099'},22_235:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a regular language $L$ over a unary alphabet $\\Sigma = \\{ a \\}$.</p>\n\n<p>How to decide whether there are two words $w,w' \\in L$ such that\nthe length of $w$ is relatively prime to the length of $w'$ ?</p>\n", 'ViewCount': '146', 'Title': 'Finding two words of lengths that are relatively prime in a regular language?', 'LastActivityDate': '2013-09-03T18:53:48.563', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9963', 'Tags': '<regular-languages><finite-automata><decision-problem>', 'CreationDate': '2013-09-03T16:03:03.457', 'Id': '14106'},22_236:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>At many places I have read that the following language is not a regular, and thus it is impossible to express this in terms of  Finite Automata.    </p>\n\n<blockquote>\n  <p>L={0^i1^i | i>=0}</p>\n</blockquote>\n\n<p>But I tried  this as follows.   </p>\n\n<p><img src="http://i.stack.imgur.com/wKrBi.jpg" alt="enter image description here"></p>\n\n<p>Can somebody explain the fallacy?  </p>\n', 'ViewCount': '30', 'ClosedDate': '2013-09-06T16:09:34.667', 'Title': 'For the langauge L={0^i1^i | i>=0} DFA possible or not?', 'LastActivityDate': '2013-09-06T13:49:36.670', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-06T13:49:36.670', 'Id': '14175'},22_237:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we have some regular language $L$, then can we say that $$L_{half} = \\{w : \\text{for some } z \\in L, x \\in \\Sigma^*, z = wx \\wedge |w| = |x| \\} $$ \nis also regular? </p>\n\n<p>I have a 'feeling' that it is, but I can't sketch a proof for it.</p>\n", 'ViewCount': '119', 'ClosedDate': '2013-09-09T10:16:05.103', 'Title': 'Is $L_{half} = \\{w : \\text{for some } z \\in L, x \\in \\Sigma^*, z = wx \\wedge |w| = |x| \\} $ regular?', 'LastActivityDate': '2013-09-07T15:07:27.570', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14195', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<regular-languages><automata>', 'CreationDate': '2013-09-07T13:40:56.200', 'Id': '14192'},22_238:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider a regular language $L$. Let $D(L)$ be a minimal DFA for $L$ and $N(L)$ be a minimal NFA for $L$ (minimal in the sense of the smallest possible number of states for an automaton that recognizes the given language). Write $|A|$ for the size (number of states) of the automaton $A$. In general, $|N(L)|$ can be a lot smaller than $|D(L)|$ (down to $\\lg |D(L)|$, since determinization is exponential in the worst case).</p>\n\n<p>I am interested in languages for which the minimal NFA is guaranteed to be at least a fraction of the size of the DFA: $|N(L)| \\ge k |D(L)|$. What families of regular languages have this property? In other words, for what family of languages $(L_n)$ such that $|D(L_n)| = n$ is $|N(L_n)| = \\Omega(n)$?</p>\n', 'ViewCount': '176', 'Title': u'For what kinds of languages is min |NFA| = \u03a9(min |DFA|)?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-27T21:37:07.360', 'LastEditDate': '2013-09-13T16:00:09.733', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10106', 'Tags': '<formal-languages><automata><finite-automata><descriptive-complexity>', 'CreationDate': '2013-09-12T16:37:35.247', 'FavoriteCount': '1', 'Id': '14285'},22_239:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a finite automaton with these properties:</p>\n\n<ul>\n<li>Contains cycles</li>\n<li>It's a directed graph</li>\n<li>All the states/nodes are initialy reachable from the initial state</li>\n<li>It has final states but I guess it isn't relevant for my issue</li>\n<li>It's a random generated automaton, and the generation isn't meant to satisfy properties like strongly connected components or connected components </li>\n</ul>\n\n<p>Let's suppose I have to delete an edge. </p>\n\n<p>I need to know if there's a way to prove that the reached state by this edge is still reachable from the initial state without using a classical search (DFS or BFS); obviously, if there is any.</p>\n", 'ViewCount': '57', 'Title': 'What is the optimal solution to prove the reachbility of a node from the root?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T17:36:35.740', 'LastEditDate': '2013-09-17T17:36:35.740', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<graph-theory><finite-automata><graph-traversal>', 'CreationDate': '2013-09-17T15:48:06.797', 'FavoriteCount': '1', 'Id': '14381'},22_240:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '197', 'Title': 'Bridge theorems for group theory and formal languages', 'LastEditDate': '2013-09-18T15:00:13.363', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '3', 'Body': '<blockquote>\n  <p>Is there some natural or notable way to relate or link math <a href="http://en.wikipedia.org/wiki/Group_theory" rel="nofollow">groups</a> and CS <a href="http://en.wikipedia.org/wiki/Formal_language" rel="nofollow">formal languages</a> or some other core CS concept e.g. Turing machines?</p>\n</blockquote>\n\n<p>I am looking for references/applications. However note that I am aware of the link between semigroups and CS languages (namely via <a href="http://en.wikipedia.org/wiki/Semiautomaton" rel="nofollow">finite automata</a>). (Does this literature on semiautomata ever look at "group-automata"?)</p>\n\n<p>I have seen one paper many years ago that might come close, that converts TM transition tables into a binary operation, possibly sometimes a group in some cases, conceivably based on some kind of symmetry in the TM state table. It didn\'t explore that in particular, but also didn\'t rule it out.</p>\n\n<p>Also, in particular, regarding the large body of math research on <a href="http://en.wikipedia.org/wiki/Classification_of_finite_simple_groups" rel="nofollow">classification of finite groups</a>, does or could it have any meaning or interpretation in TCS? What is the "algorithmic lens" view of this massive edifice of mathematical research? What is it "saying" about a possible hidden structure in computation?</p>\n\n<p>This question is partly inspired by some other notes e.g.:</p>\n\n<ul>\n<li><p><a href="http://cstheory.stackexchange.com/questions/10916/uses-of-algebraic-structures-in-theoretical-computer-science?lq=1">Use of algebraic structures in TCS</a></p></li>\n<li><p><a href="http://rjlipton.wordpress.com/2013/06/20/three-theorems-about-growth/" rel="nofollow">RJ Lipton on Gromov\'s theorem</a></p></li>\n</ul>\n', 'Tags': '<formal-languages><reference-request><automata><discrete-mathematics><group-theory>', 'LastEditorUserId': '699', 'LastActivityDate': '2013-09-19T08:20:39.707', 'CommentCount': '4', 'AcceptedAnswerId': '14417', 'CreationDate': '2013-09-18T03:16:40.020', 'Id': '14398'},22_241:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve converted an NFA to a DFA.  But even after checking over it a few times, it still doesn\'t feel right.  I\'m sure this is trivial, but I\'d like someone to give me an idea where I went totally wrong on this.</p>\n\n<p>NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/LgZ9b.jpg" alt="enter image description here"></p>\n\n<p>DFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hMLf8.jpg" alt="enter image description here"></p>\n\n<p>Took several pics, these were the best, can\'t seem to get them straighter than this.</p>\n', 'ViewCount': '705', 'Title': 'Converting NFA to DFA', 'LastActivityDate': '2013-09-20T05:23:51.963', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '14461', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-20T02:44:27.307', 'Id': '14458'},22_242:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '199', 'Title': 'Fundamental algorithms in formal language-automata theory', 'LastEditDate': '2013-09-20T18:45:15.127', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10249', 'Body': "<p>I'm willing to take a course in formal languages and automata theory , where we will explore side by side a functional programming language to implement the different algorithms we will encounter ,despite i am new to the language , i am assuming i've learned what's nessecary to move to the theoretical part , so i'm wondering what are the must-knows of FL &amp; AT to a programmmer , that is what are the most fundamentals algorithms one necesserily have to know while studying formal languages and automata theory ?</p>\n", 'ClosedDate': '2013-10-01T07:02:02.177', 'Tags': '<algorithms><formal-languages><automata>', 'LastEditorUserId': '10249', 'LastActivityDate': '2013-09-22T04:53:51.763', 'CommentCount': '0', 'AcceptedAnswerId': '14489', 'CreationDate': '2013-09-20T18:38:20.970', 'Id': '14480'},22_243:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I just started learning about formal lang and automata theory, and recently learned about regex, so I don't know any complicated symbols, so please stick with basic symbols.</p>\n\n<p>The question is: Write a regex for the following language over {0,1} that is a set of all odd length strings that contain exactly two 0's.</p>\n\n<p>I've got the first part finished (the odd part), it should be:</p>\n\n<p>(0+1)[(0+1)(0+1)]* ( + is the same as | (or) I believe, we learnt it as +)</p>\n\n<p>However, when I think about having exactly two 0's it gets really messed up. I can only see that I can use * with 1 only since # of 0's are limited to 2. But if i do (11)* , I can't get the permutation of 0's inside the 1's. (e.g. can't get 10101 with (11)*).</p>\n\n<p>What I know:</p>\n\n<ol>\n<li>Only 1's can use * </li>\n<li>In the regex only two 0's will be used</li>\n<li>The way to make odd length is to add an odd length to an even length\n(even length needs to have empty string within it's set)</li>\n<li>Odd length should not use * since 2 odd = even, so only even length\ncan use *</li>\n</ol>\n\n<p>For possible hints or answer, please use 0,1,+/|,*,(,) only. Some other expressions I will not be able to understand.</p>\n", 'ViewCount': '903', 'Title': "Regex for all odd length string that contains exactly 2 0's with language {0,1}", 'LastActivityDate': '2013-09-23T07:26:39.710', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14494', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<automata><regular-expressions>', 'CreationDate': '2013-09-21T10:42:50.617', 'Id': '14493'},22_244:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A type-0 grammar generates a recursively enumerable (RE) language. </p>\n\n<p>A RE language is also known as a semi-decidable language. </p>\n\n<p>A semi-decidable language is a particular kind of undecidable language: If a language is semi-decidable, we can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely. </p>\n\n<p>Problem: Provide an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>Answer (I think): The following grammar generates this language: </p>\n\n<pre><code>(a+b+) union (infinite a's)\n</code></pre>\n\n<p>Here is the grammar:</p>\n\n<pre>\nS &rarr; aA | bE\nA &rarr; aA | bB\nB &rarr; bB | &epsilon; | aE\nbE &rarr; aE \nE &rarr; aE\n</pre>\n\n<p>A method for recognizing strings in the language generated by this grammar would return true for strings that are an element of a+b+ and would run indefinitely for strings that are not an element of a+b+</p>\n\n<p>I think that this is an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>If I am incorrect, would you provide an example please?</p>\n", 'ViewCount': '73', 'Title': 'Is this an example of a type-0 grammar that is not context-sensitive?', 'LastActivityDate': '2013-09-21T20:01:25.747', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><formal-grammars><undecidability><linear-bounded-automata>', 'CreationDate': '2013-09-21T20:01:25.747', 'FavoriteCount': '1', 'Id': '14503'},22_245:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Show that L = $\\{0^{2^n}| n\\geq 0\\}$ is not a context free language.</p>\n\n<p>Let string $s = 0^{2^p}$. Then we know we can write $s$ as $s = uvxyz$. I know that |vy| > 0 and $|vxy| \\leq p$. </p>\n\n<p>So how do I show that $uv^2xy^2z$ is not in $L$.</p>\n', 'ViewCount': '525', 'Title': 'Use pumping lemma to show L is not context free', 'LastEditorUserId': '9819', 'LastActivityDate': '2013-10-22T23:00:00.967', 'LastEditDate': '2013-09-22T22:09:07.183', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<context-free><pushdown-automata>', 'CreationDate': '2013-09-22T19:06:38.340', 'Id': '14521'},22_246:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>(1) $L_1 = \\{a^ib^{i+j}c^j|i,j\\geq 0\\} $</p>\n\n<p>(2) $L_2 = \\{xy | x,y \\in \\{0,1\\}^*, x \\neq y, |x| = |y| \\}$</p>\n\n<p>I doubt that $L_1$ is CFL. I've been trying to go with the string $s$ = $a^pb^{2p}c^p$. Thus, we can write $s$ as $uvxyz$. Now I'm trying to show $uv^2xy^2z$ is not in $L_1$. </p>\n\n<p>I really have no idea how to approach (2). And if it is context free, how in the world would you draw a pda?</p>\n", 'ViewCount': '87', 'Title': 'Determine whether two languages are context free', 'LastActivityDate': '2013-10-02T23:17:32.233', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '14531', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<context-free><pushdown-automata>', 'CreationDate': '2013-09-22T22:08:26.540', 'Id': '14527'},22_247:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>An NFA $M$ contains a cycle if there is a state $q$ and a string $x$ such that if $M$ is in state $q$ and reads string $x$, $M$ can return to state $q$. Prove:</p>\n\n<p>If $M$ recognizes an infinite language, then $M$ has a cycle.</p>\n', 'ViewCount': '66', 'ClosedDate': '2013-09-23T07:30:02.960', 'Title': 'If $M$ recognizes an infinite language, then $M$ has a cycle', 'LastActivityDate': '2013-09-23T00:43:28.777', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-09-23T00:42:55.103', 'Id': '14541'},22_248:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm working on a NFA to DFA conversion tool that is different from the Subset Construction and I need to test this tool.</p>\n\n<p>In order to be sure that the immplementation has no bug I'd like to generate a random NFA with these properties:</p>\n\n<ul>\n<li>The NFA should be connected</li>\n<li>The NFA should have one initial state and one or more final states</li>\n<li>The NFA should have \u03b5-moves</li>\n</ul>\n\n<p>Is there a known algorithm or a paper that explains how to generate this NFA automaton as random as possible? </p>\n", 'ViewCount': '100', 'Title': 'NFA random generator', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-23T18:09:45.097', 'LastEditDate': '2013-09-23T18:09:45.097', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<finite-automata><pseudo-random-generators><random>', 'CreationDate': '2013-09-23T15:19:46.953', 'Id': '14555'},22_249:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have seen web sites that purport to "prove" that HTML5+CSS is Turing Complete.</p>\n\n<p>I have seen web sites that purport to "prove" that SQL is Turing Complete.</p>\n\n<p>I have seen a bunch of web sites that purport to "explain" what it means to be Turing Complete.</p>\n\n<p>Enough!</p>\n\n<p>Where can I find a book (written by an expert in computability theory) or a peer-reviewed article (in a reputable journal) that shows a proof of, "This language XYZ is capable of describing a computational machine which has the same computational power as a Turing Machine"?</p>\n', 'ViewCount': '315', 'Title': 'Clear, complete, proof that a language is Turing Compete?', 'LastActivityDate': '2013-09-30T17:12:59.010', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><automata><turing-completeness><church-turing-thesis>', 'CreationDate': '2013-09-30T11:35:37.607', 'FavoriteCount': '1', 'Id': '14697'},22_250:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In some paper I read, </p>\n\n<blockquote>\n  <p>A theoretical worst case study shows that a single regular\n  expression of length $n$ can be expressed as an NFA with $O(n)$\n  states. When the NFA is converted into a DFA, it may generate\n  O($\\Sigma^n$) states. The processing complexity for each character in the inpuyt it $O(1)$ in a DFA, but is $O(n^2)$ for an NFA when all $n$ states are active at the same time.</p>\n</blockquote>\n\n<p>Please explain how NFA has at its maximum just $n$ states and its equivalent DFA has at most $O(\\Sigma^n)$ states?</p>\n', 'ViewCount': '92', 'Title': 'NFA and DFA storage cost', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T06:39:01.737', 'LastEditDate': '2013-10-04T06:39:01.737', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<regular-languages><automata><finite-automata><descriptive-complexity>', 'CreationDate': '2013-10-02T16:31:25.310', 'Id': '14755'},22_251:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '242', 'Title': 'Counting Deterministic Finite Automata', 'LastEditDate': '2013-10-03T22:42:33.607', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'Heplar', 'PostTypeId': '1', 'OwnerUserId': '10493', 'FavoriteCount': '1', 'Body': u'<p>I have a question regarding counting DFAs:</p>\n\n<blockquote>\n  <p>Given a  <code>\u03a3 = {0, 1}</code> input string, with the state set <code>Q = {1...n}</code>, how would I find the total number of DFAs that can be constructed?</p>\n</blockquote>\n\n<p>I believe this is a combinatorics problem, but I am not really sure what I would have to multiply. </p>\n\n<p>Thanks. </p>\n', 'Tags': '<finite-automata>', 'LastEditorUserId': '10493', 'LastActivityDate': '2013-10-03T22:42:33.607', 'CommentCount': '5', 'CreationDate': '2013-09-19T04:17:15.567', 'Id': '14778'},22_252:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '57', 'Title': 'Regular Expression as basis for creating this grammar', 'LastEditDate': '2013-10-06T03:50:49.073', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': u"<p>I made a right-linear grammar from a regular expression:</p>\n\n<p>The alphabet is:</p>\n\n<p>$\u03a3 = \\{a, b, c\\} $</p>\n\n<p>Regular expression:</p>\n\n<p>$r = cc^{*}(ba)^{*}bb$</p>\n\n<p>My solution, it seems a little too short like I'm leaving something out. Maybe someone can see where I went wrong on the right-linearity:</p>\n\n<p>$ S \\to cA $</p>\n\n<p>$ A \\to b a A | B | cA $</p>\n\n<p>$ B \\to bb $</p>\n", 'Tags': '<formal-languages><automata><formal-grammars><regular-expressions>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-06T03:50:49.073', 'CommentCount': '2', 'AcceptedAnswerId': '14850', 'CreationDate': '2013-10-06T03:27:41.210', 'Id': '14849'},22_253:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I used this generalized transition graph with 3 states and got an equivalent generalized\ntransition graph with 2 states:</p>\n\n<p>GTG:</p>\n\n<p><img src="http://i.stack.imgur.com/LSUfs.jpg" alt="enter image description here"></p>\n\n<p>Equivalent with 2 states:</p>\n\n<p><img src="http://i.stack.imgur.com/nenwS.jpg" alt="enter image description here"></p>\n\n<p>I\'m not sure about the regular expressions linking the nodes $q0$ and $q2$, if someone can clarify where I may have gone wrong here.</p>\n', 'ViewCount': '44', 'Title': 'Reducing states of a GTG', 'LastActivityDate': '2013-10-06T09:56:23.350', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14856', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><graphs><automata><formal-grammars>', 'CreationDate': '2013-10-06T04:19:51.400', 'Id': '14852'},22_254:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When we talk about DFA, we say that each new character from the input requires one memory access. What does that mean? </p>\n\n<p>This is what I think about this. Please tell me is this right? \nFor example, I have a transition table stored for a certain regular expression in memory (RAM). Now, for each input character the CPU will fetch the whole transition table to find out the next state. In this way, we have just one memory access?</p>\n', 'ViewCount': '56', 'Title': 'DFA memory bandwidth', 'LastActivityDate': '2013-10-07T16:59:44.987', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<automata>', 'CreationDate': '2013-10-07T16:36:11.933', 'Id': '14889'},22_255:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I know that an \u03b5-NFA (NFA with epsilon transitions) is not an NFA or a DFA and an NFA is not a DFA.</p>\n\n<p>HOWEVER, say you have a complete DFA. Isn\'t that theoretically an NFA and an \u03b5-NFA? Just because it doesn\'t have \u03b5 transitions, does it mean it is not \u03b5-NFA? If a question asks you to turn a DFA into an \u03b5-NFA, can\'t you just write the complete DFA as an answer? What properties make DFA different from \u03b5-NFA and NFA?</p>\n\n<p>The same question applies to NFA \u2192 \u03b5-NFA, isn\'t NFA a more "primitive" version of \u03b5-NFA? It\'s just NFA without the \u03b5...</p>\n', 'ViewCount': '453', 'Title': u'DFA/NFA/\u03b5-NFA: subsetting each other or different sets?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-09T12:53:54.957', 'LastEditDate': '2013-10-09T12:53:54.957', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '14912', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2013-10-08T14:12:16.447', 'Id': '14908'},22_256:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is a simple transition system of beverage vending machine:\n<img src="http://i.stack.imgur.com/bgJM8.png" alt="beverage vending machine"> </p>\n\n<p>The exemplary execution fragments can look like this:</p>\n\n<p><img src="http://i.stack.imgur.com/F0kPo.png" alt="enter image description here"></p>\n\n<p>Now, imagine we have multi-process TS where processes are identical and communicate over channels. I don\'t understand the semantics of how to present an execution fragment that runs across multiple processes. Should I specify the whole execution in one line? If yes how do I denote that the state belongs to some certain process? Or maybe I present execution fragment on each process in the separate line? I\'d love to see a "meta-example" of how that could look like. </p>\n\n<p>I am referring to this specific <a href="http://www-i2.informatik.rwth-aachen.de/i2/fileadmin/user_upload/documents/MC11/sheet02.pdf" rel="nofollow">exercise sheet</a>, task 3.) b). The figures are from the book "Principles of Model Checking" by Christel Baier and Joost-Pieter Katoen p. 22 and p. 25.  </p>\n', 'ViewCount': '65', 'Title': 'Example of execution fragment of multi-process transition system', 'LastActivityDate': '2013-10-08T17:15:44.600', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10582', 'Tags': '<formal-languages><automata><model-checking><denotational-semantics>', 'CreationDate': '2013-10-08T17:15:44.600', 'Id': '14915'},22_257:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it possible to count in Automata theory?</p>\n\n<p>I am begginer in Automata theory and I am trying to do some examples.</p>\n\n<p>Currently I am working on a program that will recognise equal numbers of 0 and 1, but they are orderd in such manner that they are together, example: \n$$\n000111\\rightarrow true \\quad\n0001111\\rightarrow false \\quad\n00011 \\rightarrow false \\quad\n010101\\rightarrow false  \\quad\n$$\nI am trying to figure out is there any possibility to count in Automation theory. If not can you please advise me how it would be possible to solve this assingment, because the only way for me is counting.</p>\n\n<p>Thanks.</p>\n', 'ViewCount': '65', 'Title': 'Counting in Automata theory', 'LastEditorUserId': '140', 'LastActivityDate': '2013-10-08T21:42:48.227', 'LastEditDate': '2013-10-08T17:35:25.897', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10584', 'Tags': '<automata>', 'CreationDate': '2013-10-08T17:31:36.097', 'Id': '14916'},22_258:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm working on a proof that deals with a modified PDA, which is identitical to a PDA, but with transitions: \\begin{equation*}\na,b \\to c\n\\end{equation*} where $a$ is a context free grammar, instead of just a symbol. The modified PDA then reads a prefix $w'$ of $w$, the suffix of the input stream, where $w' \\in L(a)$.</p>\n\n<p>I'm try to prove that the language recognized by this modified PDA is context free, but I'm really stuck. I have no idea how to even get started. If someone could point me in the right direction, I would really appreciate it.</p>\n", 'ViewCount': '65', 'Title': 'Proving a PDA with CFG Transitions recognizes Context Free Languages', 'LastActivityDate': '2013-10-08T22:55:32.770', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14930', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10596', 'Tags': '<formal-languages><automata>', 'CreationDate': '2013-10-08T22:29:05.633', 'Id': '14927'},22_259:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having a lot of trouble constructing a PDA for the language: \\begin{equation*}\n\\{a^m b^n : m &lt; 2n &lt; 3m \\}\n\\end{equation*}</p>\n\n<p>I know if I push a symbol for each $a$ I see, then pop 2 symbols for each $b$ I see, then I should run out to satisfy the $m &lt; 2n$ part of the inequality. But I really don't understand how to include the requirement $2n &lt; 3m$. I'm assuming it has something to do with clever branching based on non-determinism, but I can't wrap my head around it. Any help would really appreciated.</p>\n", 'ViewCount': '664', 'Title': 'Constructing a PDA for the language $\\{a^m b^n : m < 2n < 3m \\}$', 'LastEditorUserId': '9950', 'LastActivityDate': '2013-10-10T01:43:41.060', 'LastEditDate': '2013-10-10T01:43:41.060', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14962', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10448', 'Tags': '<formal-languages><automata><pushdown-automata>', 'CreationDate': '2013-10-09T00:28:08.143', 'Id': '14935'},22_260:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a question concerning Kripke automaton. My answers seem a little short and I was wondering if I was missing something?\nTransition table of a Kripke automaton: </p>\n\n<p><img src="http://i.stack.imgur.com/FefEb.png" alt="enter image description here"></p>\n\n<p>A -> red light is on</p>\n\n<p>B and D -> blue light is on</p>\n\n<p>C -> both light are on</p>\n\n<p>1) Is the test 001blue satisfied by any state?</p>\n\n<pre><code>Attempt: No\n</code></pre>\n\n<p>2) Is the test 001red satisfied by every state?</p>\n\n<pre><code>Attempt: Yes but I dont know how to show it.\n</code></pre>\n\n<p>3) Which test could tell difference btw A and C?</p>\n\n<pre><code>Attempt: test = 100both; C satisfies test, A doesnt\n</code></pre>\n\n<p>4) Can any test distinguish B and C?</p>\n\n<pre><code>Attempt: Yes, test = 10001blue; B satisfies test, C doesnt\n</code></pre>\n\n<p>5)Show that no test can tell the difference btw B and D.</p>\n\n<pre><code>Attempt: Their observations are different.\n</code></pre>\n', 'ViewCount': '54', 'ClosedDate': '2013-10-17T20:35:15.243', 'Title': 'Kripke automaton and observations', 'LastActivityDate': '2013-10-13T18:17:24.183', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16045', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10713', 'Tags': '<automata>', 'CreationDate': '2013-10-13T18:02:58.997', 'Id': '16044'},22_261:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '47', 'Title': 'Deciding the class of certain languages', 'LastEditDate': '2013-10-14T20:20:11.933', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Body': "<p>I am preparing for my exam in Formal languages and Automata theory and I'm looking at some old exam questions right now. I need help with the following question: </p>\n\n<blockquote>\n  <p>For each of the following languages answer whether it is regular, context-free but not regular, or not context-free. A brief, informal explanation is sufficient.</p>\n  \n  <p>$$\n  L_3 = \\left\\{ w \\in \\{a,b,c,d\\}^* \\Bigg| \\begin{array}{l}\n      \\text{\\(w\\) does not have a substring \\(aba\\),} \\\\\n      \\text{each \\(a\\) in \\(w\\) is immediately followed by \\(b\\),} \\\\\n      \\text{and \\(\\#c(w)\\) is odd}\n    \\end{array} \\right\\}\n$$\n  $$ \\begin{align}\n  L_4 &amp;= \\{ a^ib^jc^ka^ib^l \\mid j \\gt l \\text{ and } i,l,k \\gt 0 \\} \\\\\n  L_5 &amp; \\text{ is the image of \\(L_4\\) under the homomorphism }\n  h:\\{a,b,c,d\\}^* \\to \\{0,1,2\\}^* \\\\ &amp; \\text{ such that }\n  h(a) = h(b) = 10 \\text{ and } h(c) = 210 \\text{ and } h(d) = \\epsilon \\\\\n  L_6 &amp; \\text{ is the image of \\(L_4\\) under the homomorphism }\n  h:\\{a,b,c,d\\}^* \\to \\{0,1,2\\}^* \\\\ &amp; \\text{ such that } \n  h(a) = h(b) = 210 \\text{ and } h(c) = h(d) = \\epsilon \\\\\n\\end{align} $$</p>\n</blockquote>\n\n<p>Here is my attempt:</p>\n\n<p>$L_3$ is regular. It's the intersection between 3 regular languages. Regular languages are closed under intersection, so the resulting language is regular. The language where $w$ does not have a substring $aba$ is just the complement of the language $aba$, regular languages are closed under complement, so the resulting language is regular. The language with an odd number of $c$ is regular. Hence the resulting language when taking the intersection between these languages is regular.</p>\n\n<p>$L_4$ is not context-free. When reading the first $a$'s we will push the $a$'s onto the stack. Then we will read the first $b$'s and push them onto the stack. Then we will read the $c$'s. When we now read a second group of $a$'s, we will not be able to compare the number with the first $a$'s, because $b$'s are on the top of the stack and if we pop them then we will not be able to compare the number $b$'s in the beginning and the end. Hence, $L_4$ is not context-free. </p>\n\n<p>$L_5$ is context-free but not regular. The language in question looks like this:\n$$ 10^{i+j} 210^k10^{i+l} \\text{ where } j \\gt l \\text{ and } i,l, k \\gt 0 $$\nA grammar can be constructed which generates at least one more $10$ in the beginning of the string than $10$ after $210$.</p>\n\n<p>$L_6$ is regular because it's given by the regular expression:\n$$ 210^{2i + j + l} \\text{ where } 2i+j+l \\text{ is any number } \\gt 0$$</p>\n\n<p>Is this correct? Note that informal explanations is sufficient in the answer and that no grammars has to be given.</p>\n", 'ClosedDate': '2013-10-30T10:12:35.357', 'Tags': '<formal-languages><context-free><automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-14T20:20:11.933', 'CommentCount': '1', 'AcceptedAnswerId': '16075', 'CreationDate': '2013-10-14T14:29:02.520', 'Id': '16074'},22_262:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm not very comfortable with pumping lemma for context-free grammar. I understand the sufficient conditions that must hold but proving it gets me everytime. For example, I need to prove whether $L = \\{0^{n^3} \\mid n\\in\\mathbb{N}\\}$ is context-free or not. </p>\n\n<p>Based on my intuition, it won't be.  There is no pattern of $0$'s that can be recreated by a pushdown automata but alas I need to prove this. I know you start off assuming it is by being able to create a substring $uvxyz$ where $v$ and $y$ are raised to the $i$th power where $i \\ge 0$. I'm having trouble from there, any help in this and the understanding would be greatly appreciated.</p>\n", 'ViewCount': '169', 'Title': u'Prove that {0^{n^3} | n\u22650} is not context free', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-16T00:20:58.653', 'LastEditDate': '2013-10-15T23:41:01.340', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-10-15T22:45:46.927', 'Id': '16113'},22_263:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is one point I don\'t understand in the DFA construction for mismatch cases.</p>\n\n<p>Here is the lecture note I watched, which describes how to handle mismatched characters during the DFA construction process.</p>\n\n<p><img src="http://i.stack.imgur.com/r4Q1Z.png" alt="enter image description here"></p>\n\n<p>Some information about the presentation screen shot:</p>\n\n<p><code>pat</code> is the pattern, string index starts at 0, <code>dfa</code> is the state transition table, in which the row is indexed by the character(eg, "A","B" or "C"), column by state(1,2,3,...).</p>\n\n<hr>\n\n<p><strong>My question starts</strong>:</p>\n\n<p>In the place in the presentation, where starts with "<em>To compute dfa[c][j]</em>", it says run the simulation using the last j-1 chars.</p>\n\n<p>I am confused:</p>\n\n<p>Why run the simulation using the last <code>j-1</code> chars, rather the last <code>j</code> chars. </p>\n\n<p>What\'s the intuition of this design?</p>\n', 'ViewCount': '277', 'Title': u'Confusion about finite automata construction in Knuth\u2013Morris\u2013Pratt algorithm', 'LastEditorUserId': '4662', 'LastActivityDate': '2013-12-01T06:48:14.043', 'LastEditDate': '2013-10-18T19:04:46.790', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><finite-automata><strings><matching>', 'CreationDate': '2013-10-18T09:15:06.677', 'FavoriteCount': '1', 'Id': '16195'},22_264:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>While Learning about removing null moves from NFA , I came across a thought....</p>\n\n<p>To <strong>Remove Epsilon moves</strong> we follow following steps :</p>\n\n<ol>\n<li>Find <strong>Closure of all states</strong> which have null moves</li>\n<li>Mark <strong>these states which have null moves</strong></li>\n<li><strong>Make a revised transition table without epsilon column</strong> and Find all possible transition for those marked states by using their Closures.</li>\n<li>you will get nfa without null moves/epsilon moves</li>\n</ol>\n\n<p>Where is the issue : Actually, Doubt arises when you think of an nfa like this :</p>\n\n<p>If we try to remove epsilon moves out of it...</p>\n\n<p><img src="http://i.stack.imgur.com/x4yZj.png" alt="enter image description here"></p>\n\n<p>Initial transition Table : \n<img src="http://i.stack.imgur.com/hZeZX.png" alt="enter image description here"></p>\n\n<p>Now finding closure for q0, q1 and q3.</p>\n\n<p><strong>Which is CL(q0) = {q0,q1,q2}\nCL(q1) = {q1,q2}\nCL(q3) = {q2,q3}\nWe find a transition table after following above steps which is :</strong> \n<img src="http://i.stack.imgur.com/XDT2A.png" alt="enter image description here"></p>\n\n<p>The question gets quite tricky...</p>\n\n<p>because now this nfa has q1,q2 where there is no way to reach them..</p>\n\n<p>So What do you think we will remove q1 and q2 as they are unreachable or we will draw a nfa with them... </p>\n', 'ViewCount': '1992', 'Title': 'Removing Null moves from NFA', 'LastEditorUserId': '10861', 'LastActivityDate': '2014-02-27T16:49:27.293', 'LastEditDate': '2013-10-20T07:59:28.647', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><reductions><finite-automata>', 'CreationDate': '2013-10-19T20:40:25.610', 'Id': '16237'},22_265:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There is a saying by Computer Science Professor's everywhere :</p>\n\n<pre><code>PDA Checks the intelligence of Students, as certainly there is no approach except power and imagination\nof mind to solve problems and design PDA...\n</code></pre>\n\n<p>While thinking today i thought How can we design automata of a^2n b^(2n-1)</p>\n\n<p>I tried my best :\nFor example let q0 is initial state and top of the empty stack has Z.</p>\n\n<pre><code>So, Let say Transition of (q0, a , Z) = (q1,Z)\n\n            Transition of (q1, a , a) = (q1,a)\n\n            Transition of (q1, b , a) = (q2,-)\n\n            Transition of (q2, $ , Z) = (qf,Z)\n</code></pre>\n\n<p>I was able to solve this problem all of a sudden...</p>\n\n<p><strong>My doubt is still the same, How to be the best in solving PDA problems and Is there any way \nto define a strategy to solve problems ?</strong></p>\n\n<p>P.S. Your comments are welcome if i did something wrong in above stated question</p>\n", 'ViewCount': '126', 'Title': 'Approaches to Solve PDA', 'LastActivityDate': '2013-10-21T22:38:32.957', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '16310', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><pushdown-automata>', 'CreationDate': '2013-10-21T16:59:47.230', 'Id': '16308'},22_266:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Computer Language/Logic Examples?\nThese are some of the questions i am having within a few chapters of my automata class and would like some help if you could :) Class is online and can be hard to self teach at times, you dont have to answer all or any for that matter, just thought id ask i got a midterm coming up and would like to know how to do these. \xaf<em>(\u30c4)</em>/</p>\n\n<p>\u039b is not a word but it\u2019s still used in its language? How do I show that there are other CFGs for these languages that do not use \u039b-productions.</p>\n\n<p>(ex i) S \u2192 aX | bX\n X \u2192 a | b | \u039b</p>\n\n<p>(ex ii) S \u2192 aX | bS | a | b\n X \u2192 aX | a | \u039b</p>\n\n<p>(ex iii) S \u2192 aS | bX\n X \u2192 aX | \u039b</p>\n\n<p>(ex iv) S \u2192 XaX | bX\n X \u2192 XaX | XbX | \u039b</p>\n\n<p>How would I convert these CFGs to CNF?\n (ex i) S \u2192 SS | a</p>\n\n<p>(ex ii) S \u2192 aSa | SSa | a</p>\n\n<p>(ex iii) S \u2192 aXX\n X \u2192 aS | bS | a</p>\n\n<p>(ex iv) E \u2192 E + E\n E \u2192 E * E\n E \u2192 (E)\n E \u2192 7\n The terminals are + * ( ) 7</p>\n\n<p>How would I make a PDA that accepts the same language (given that a CFG makes L then a PDA makes L)\n S \u2192 XaaX\n X \u2192 aX | bX | \u039b</p>\n', 'ViewCount': '97', 'ClosedDate': '2013-11-08T23:02:43.897', 'Title': 'Computer theory/ automata example help', 'LastActivityDate': '2013-10-23T22:17:26.830', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10905', 'Tags': '<automata>', 'CreationDate': '2013-10-21T23:46:41.367', 'Id': '16319'},22_267:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m considering an automaton $A$ over a alphabet $\\Sigma$, with a set of states $Q$, such that $\\Sigma \\subset Q$, which includes special "accept" and "blank" states not in $\\Sigma$. It also has an infinite list of cells, which begins with the input string, the rest being blank. It has a transition function $\\delta: Q \\times Q \\times Q \\to Q$. The automaton computes by updating the value  of the middle cell, $a$, using $\\delta(x,a,y)$. The automaton accepts if any cell is in the accept state. From what I understand, this automaton is very similar to a 1-dimensional cellular automaton, with the addition of the accept state.</p>\n\n<p>I\'m trying to prove that a language is recognizable by a Turing machine if and only if it can be recognized by the automaton described.</p>\n\n<p>I\'ve been trying to do a proof by construction, but I\'m really lost. I did some research on cellular automata, but the material I\'ve been finding is way over my level. I know somehow I\'m going to have to construct a TM from CA, and vica versa, but I\'m not even sure how to get started. I would really appreciate any help.</p>\n', 'ViewCount': '234', 'Title': 'Proving Equivalence of 1-dimensional Cellular Automaton and Turing Machines', 'LastEditorUserId': '630', 'LastActivityDate': '2013-10-22T13:58:25.280', 'LastEditDate': '2013-10-22T13:58:25.280', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16322', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10448', 'Tags': '<turing-machines><cellular-automata>', 'CreationDate': '2013-10-22T04:11:52.023', 'Id': '16321'},22_268:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm interested in finite state automata which have the capacity to require repetition.  That is, the machine may be in a state in which the next character may be any character from set $S$, but, whatever character there is, it must be repeated 3 times.  Or it may be in a different state, which requires a character from set $T$ repeated twice.</p>\n\n<p>I could in theory make a different state for each character in set S, and for each character in set T.  But that overcomplicates things and obscures the pattern - it can be any character in set S, but the same character must be repeated.</p>\n\n<p>Is there any standard approach to this? I'm interested both in terminology and in practical code.</p>\n\n<hr>\n\n<p>Motivation: I do not know the full makeup of the set $S$ or $T$.  I'd like to be able to communicate effectively about the FSM, draw state diagrams, and do implementation, without having to define $S$ or $T$.  In fact, $S$ and $T$ change based on the scenario.  (Now, given a character, it's trivial to tell if it's part of $S$ or $T$ \u2014 but, a priori, it's impossible to enumerate them.)</p>\n\n<p>At the least, I'd like a good way to draw a state diagram for these types of machines.  Perhaps I should use a standard FSM with some type of annotation? Could state charts help with this?</p>\n", 'ViewCount': '85', 'Title': 'Recognizing finite state machines with repetition', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-24T19:06:19.023', 'LastEditDate': '2013-10-23T04:04:41.797', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10923', 'Tags': '<algorithms><regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2013-10-22T23:13:36.837', 'Id': '16343'},22_269:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read that  the NFA size (i.e., the number of states) is linear in the number of characters in the regular expression. This holds even in the presence of character repetitions.</p>\n\n<p>I would like to know why is it so? </p>\n\n<p>If I have a pattern like this , [b-d]at then the number of states will be just 4 incase of NFA ? Size of DFA for this regular expression will also be 4? </p>\n', 'ViewCount': '59', 'Title': "NFA's number of states", 'LastEditorUserId': '4624', 'LastActivityDate': '2013-10-23T11:24:50.030', 'LastEditDate': '2013-10-23T08:42:00.380', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-10-23T08:36:07.103', 'Id': '16355'},22_270:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $C$ be an infinite set of characters.  I'd like an abstract machine which can recognize sequences consisting of $k$ (constant) of repetitions of a char from $C$.</p>\n\n<p>For example, if ${x,y,z} \\subset C$, and $k = 3$, it should recognize $xxx$ but not $ddd$ or $xyz$.  (The same char must be repeated.)</p>\n\n<p>Since $C$ is infinite, a finite state machine <em>cannot</em> recognize this.  A Turing machine trivially can.  But we don't anything like the power of a Turing machine; simply extending the FSM with a single register that points to a member of $C$ is enough.</p>\n\n<p>My question is: What's the simplest formal abstract machine that is powerful enough to recognize this? Is there a standard extension to FSM's that enables them to recognize this? If I have more complicated versions of this machine (e.g. <em>Move from state 2 to state 3 if you encounter a $k$ repetition of a $C$ char</em>), what's the best way to express them?</p>\n", 'ViewCount': '108', 'Title': 'Abstract machine that can recognize repetition', 'LastActivityDate': '2013-12-22T22:31:30.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<formal-languages><computability><turing-machines><automata><finite-automata>', 'CreationDate': '2013-10-23T13:09:59.097', 'Id': '16362'},22_271:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am taking an undergraduate CS Theory course and the material on finite automata and regular languages is being taught in a non-traditional manner. Instead of using regular expressions, the closure properties of regular languages, the pumping lemma etc, to show that a language is or is not regular, all of our proofs and examples for identifying regular languages use the Myhill-Nerode theorem and boolean matrices as defined below.</p>\n\n<p>Let $L = \\{w_1, w_2, ...\\}$ be a set of words over some alphabet $\\Sigma$ and let $T_L$ be a matrix with entries $t_{ij}$ where</p>\n\n<p>$$ t_{ij} =\n\\left\\{\n \\begin{array}{ll}\n  1  &amp; \\mbox{if } w_iw_j \\in L \\\\\n  0  &amp; \\mbox{otherwise}\n \\end{array}\n\\right.\n$$</p>\n\n<p><strike>Then by Myhill-Nerode, L is non-regular iff all rows of $T_L$ are distinct.</strike></p>\n\n<p><strong>Correction:</strong> Then by Myhill-Nerode, $L$ is non-regular iff $T_L$ has an infinite number of distinct rows. </p>\n\n<p>My question is, are there any readily available books, papers, or lecture notes that lean heavily on this technique and are appropriate for undergrads?</p>\n', 'ViewCount': '90', 'Title': 'Undergrad resources for identifying regular languages with Myhill-Nerode matrices', 'LastEditorUserId': '10980', 'LastActivityDate': '2013-10-26T20:25:02.053', 'LastEditDate': '2013-10-26T20:25:02.053', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10980', 'Tags': '<regular-languages><finite-automata><education><matrices>', 'CreationDate': '2013-10-25T22:43:27.700', 'FavoriteCount': '1', 'Id': '16434'},22_272:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been trying to get a CFG for the language of all words with unequal numbers of a and b, i.e.</p>\n\n<p>$\\qquad \\displaystyle \\{u \\in \\{a, b\\}^* \\mid \\text{number of occurrences of $a$ and $b$ in $u$ are unequal} \\}$,</p>\n\n<p>but it seems that I keep getting specific cases instead of the general case.</p>\n\n<p>Here are some that I have tried:</p>\n\n<p>(S being the start Variable)</p>\n\n<pre><code>S -&gt; A | a | b\nA -&gt; aV | bT\nV -&gt; aV | bL\nL -&gt; aV\nT -&gt; bT | aM\nM -&gt; aT\n</code></pre>\n\n<p>This one's problem is that you can't create 2 of the same string if it's the lesser amount of alphabet.</p>\n\n<p>So I've tried</p>\n\n<pre><code>S-&gt; A | B\nA -&gt; aV | a\nV -&gt; aV | aVb | bVa\nB -&gt; bT | b\nT -&gt; bT | aTb | bTa\n</code></pre>\n\n<p>This one also has problem because if you have a you need to have b on the opposite end.</p>\n\n<p>Additionally, I know this is one of the huge problem in my process is that you start with 'a' or 'b' and use that as a flag for if there is more 'a' or there is more 'b'... </p>\n\n<p>I've been trying to think the way where you can input an alphabet (i.e <code>S -&gt; aV | bV</code>) so that I can start with any variable and I use cases or condition to go to different variable, but I end up with infinite variable situation.</p>\n", 'ViewCount': '241', 'Title': 'Context-free grammar for language with unequal numbers of a and b', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T09:52:27.167', 'LastEditDate': '2013-11-02T09:52:27.167', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<formal-languages><context-free><automata>', 'CreationDate': '2013-11-02T06:30:01.203', 'Id': '16642'},22_273:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The question asks to:</p>\n\n<blockquote>\n  <p>construct a DFA which accepts exactly $\\frac{n(n-1)(n-2)}{6} + \\frac{n(n-1)}{2}+1$ many members of $\\{0, 1\\}^n$ for every n.</p>\n</blockquote>\n\n<p>I have no idea where to start to constructing the DFA, could you give some directions?\nBy the way, how many states should this DFA have?</p>\n', 'ViewCount': '48', 'Title': 'Construct a deterministic finite automation', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-04T19:55:49.573', 'LastEditDate': '2013-11-04T19:25:48.650', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11170', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-11-04T15:39:03.683', 'Id': '16707'},22_274:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I would have a brief question about how to construct a Turing machine that is accepting <em>only</em> this language:</p>\n\n<p>$\\qquad\\displaystyle L_2 = \\{a^i b^j \\mid i \\geq j \\}$.</p>\n\n<p>I can't come up with any mechanism that would preserve that there are greater or equal number of 'a's than 'b's. Could you suggest me something?</p>\n", 'ViewCount': '406', 'Title': 'Turing machine for $a^i b^j$ with $i \\geq j$', 'LastEditorUserId': '630', 'LastActivityDate': '2014-02-03T11:19:19.737', 'LastEditDate': '2013-11-05T03:58:44.963', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11176', 'Tags': '<formal-languages><turing-machines><automata>', 'CreationDate': '2013-11-04T17:05:54.830', 'FavoriteCount': '0', 'Id': '16713'},22_275:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am learning about CS Theory and specifically Nondeterministic Finite Automata (NFA) right now. In my book I came across a section of text that discussed a way to determine the length of a walk stating specifically that :</p>\n\n<blockquote>\n  <p>If a transition graph has a walk labeled $w$, then there is a walk <em>w</em> of length no more than $\\Lambda + (1 + \\Lambda)|w|$ where $\\Lambda$ is the number of $\\lambda$ transitions in the graph.</p>\n</blockquote>\n\n<p>The book does not define $|w|$ which is causing part of my confusion. I\'m assuming $|w|$ is the length of the label of the walk. So in this case it would be 1 when going from $q_1 \\to q_0 \\to q1$ because $a$ is the only labeled edge.\nI am trying to understand this concept and how it works because when I have tested out this claim it has not held true.</p>\n\n<p>Here is the test I did with this NFA</p>\n\n<p><img src="http://i.stack.imgur.com/9tV6X.png" alt="enter image description here"></p>\n\n<p>$q_1$ is the final state. So assuming you were trying to find the length of the walk $a$, the label would indicate that the length is 1 (e.g. $\\delta^* (q_1, a)$) . However due to the lambdas you actually have $\\lambda \\lambda a$ to go from $q_1 \\to q_0 \\to q_1$.</p>\n\n<p>This theorem doesn\'t hold with my math though because it is defined as \u039b + (1 + \u039b)|w| where \u039b is the number of \u03bb-edges in the graph.</p>\n\n<p>Since there are two \u03bb-edges (and it doesn\'t state whether it means \u03bb-edges in the walk itself or in the graph in total...) this would then be 2 + (1 + 2)|w|. So thats 2 + 3|w|. This clearly is more than 3, which is the length of q1 -> q1 of \u03bb\u03bba.</p>\n\n<p>What am I missing here? Any help is greatly appreciated.</p>\n\n<p>This comes from Peter Linz "An Introduction to Formal Languages and Automata" 5th edition.</p>\n\n<p>Some more information about the argument for this claim:</p>\n\n<blockquote>\n  <p>While \u03bb-edges may be repeated, there is always a walk in which every repeated \u03bb-edge is separated by an edge labeled with a nonempty symbol. Otherwise, the walk contains a cycle labeled \u03bb, which can be replaced by a simple path without changing the label of the walk.</p>\n</blockquote>\n\n<p>Also the book never names this as a theorem or lemma or anything of the sort so it has been very difficult to find online resources about this topic.</p>\n', 'ViewCount': '90', 'Title': 'Determining Length of a walk in Nondeterministic Finite Automata with Lambda Transitions', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:40:46.183', 'LastEditDate': '2013-11-28T21:40:46.183', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11178', 'Tags': '<graph-theory><finite-automata><nondeterminism>', 'CreationDate': '2013-11-04T17:36:38.040', 'FavoriteCount': '0', 'Id': '16716'},22_276:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>They have finite resources so they can be modeled by finite number of state what is the same that a finite state machine. There are any proof that it is not true?</p>\n\n<p>Thanks.</p>\n', 'ViewCount': '113', 'ClosedDate': '2013-11-05T13:05:35.547', 'Title': 'Are real computers finite state machines?', 'LastActivityDate': '2013-11-05T12:39:29.787', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '16734', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11196', 'Tags': '<computability><finite-automata>', 'CreationDate': '2013-11-05T08:33:46.060', 'Id': '16729'},22_277:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an assignment where i need to create a Turing machine that decides an infinite language $L\\subset \\{0,1\\}^*$ for which all $L'\\subseteq L$, if $|L'|=\\infty$, then $L'$ is not a regular language.</p>\n\n<p>I think this is not possible due to Rice's Theorem. It's not possible to tell for a Turing Machine if a language is regular or not.</p>\n\n<p>Moreover, on any given input, the machine can loop so it cannot decide an infinite language $L$.</p>\n\n<p>Is this the right answer? It seems too easy to be the answer... Any input would be appreciable. Thanks in advance.</p>\n", 'ViewCount': '311', 'Title': 'Can a Turing Machine decide only non-regular languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T11:27:53.427', 'LastEditDate': '2013-11-08T11:27:53.427', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '16786', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<formal-languages><regular-languages><turing-machines><automata>', 'CreationDate': '2013-11-05T17:52:50.853', 'Id': '16745'},22_278:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I want to be able to describe the idea behind the pushdown automaton (no tables or diagrams). </p>\n\n<p>So, I already know that $L = \\{ ww \\mid w \\text{ in } (0,1)^*\\}$ is not context free. Since CFL are not closed under complement its complement $L'$ is a CFL. \nI also read somewhere that any odd word is part of $L'$ (what about even length words?). So a pushdown automaton description could be: read one letter and put into stack, then read next letter and remove previous letter from stack. Do this until the end. If one letter is left in the stack at the end then word is odd length thus accept, else reject?</p>\n", 'ViewCount': '423', 'Title': 'Pushdown automaton for complement of $L = \\{ ww \\mid w \\text{ in } (0,1)^*\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T22:45:29.333', 'LastEditDate': '2013-11-08T11:45:37.150', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16755', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10713', 'Tags': '<formal-languages><context-free><automata><pushdown-automata>', 'CreationDate': '2013-11-05T23:35:45.853', 'Id': '16753'},22_279:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Let say I have a pda :</p>\n\n<p>\u03b4(q1,a,Z)=(q2,aZ)</p>\n\n<p>\u03b4(q2,a,aZ)=(q2,bZ)</p>\n\n<p>Is this allowed....</p>\n\n<p>you can see that in <strong>\u03b4(q2,a,aZ)=(q2,bZ)</strong>, we are basically popping 'a' and pushing 'b' for a single transition... </p>\n\n<p>Is this allowed for PDA ??</p>\n", 'ViewCount': '76', 'Title': 'Can we push and pop both at a single transition in a PDA?', 'LastActivityDate': '2013-11-07T15:58:10.910', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '16795', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<pushdown-automata>', 'CreationDate': '2013-11-06T16:39:50.133', 'Id': '16774'},22_280:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '66', 'Title': 'Do these languages both have DPDA?', 'LastEditDate': '2013-11-09T15:24:56.840', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10030', 'Body': "<p>We have these languages:\n$$L_1 = \\{a^nb^na^mb^m \\ | n \\ge 0, m \\ge 1\\}$$\n$$L_2 = \\{a^nb^na^mb^{2m} \\ | n \\ge 0, m \\ge 1\\}$$</p>\n\n<p>are both these languages NCFG?</p>\n\n<p>I guess that both of them are NCFG because of $n \\ge 0$ ,at start we can't distinguish whether it is $a$ for the first part or the second part and hence we should act non deterministic.</p>\n", 'ClosedDate': '2013-11-11T13:54:24.870', 'Tags': '<formal-languages><context-free><automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T15:24:56.840', 'CommentCount': '5', 'AcceptedAnswerId': '16849', 'CreationDate': '2013-11-09T12:50:19.650', 'Id': '16846'},22_281:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '227', 'Title': 'Complements of Linear Bounded Automata?', 'LastEditDate': '2013-11-11T02:08:06.417', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11306', 'FavoriteCount': '1', 'Body': "<p>Would switching the accept and reject states of an LBA A create a new LBA we'll say A' in which the language of A' is the complement of the language of A? I believe the answer is yes just by working out an example...but I'm not sure on a solid proof...nor am I sure if the fact that I am working with an LBA vs a regular turing machine makes a difference in this case. </p>\n", 'Tags': '<formal-languages><turing-machines><linear-bounded-automata>', 'LastEditorUserId': '11306', 'LastActivityDate': '2013-11-20T21:18:16.770', 'CommentCount': '3', 'AcceptedAnswerId': '18208', 'CreationDate': '2013-11-11T00:39:57.630', 'Id': '17898'},22_282:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the language with alphabet: $\\{a, b, c\\}$\nDraw an NFA or DFA for all the strings that have exactly twice substrings $ab$ and at least on $c$.\nI\'m stuck with "exactly twice $ab$". Can somebody give me some ideas. It\'s also very good if you can suggest me the regular expression of this statement.</p>\n', 'ViewCount': '399', 'Title': 'NFA or DFA for strings the contain exactly twice substring ab?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-13T16:08:45.447', 'LastEditDate': '2013-11-12T09:47:18.353', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-11-12T03:43:29.253', 'Id': '17942'},22_283:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to design a DFA with last 4th character from end is 1.</p>\n\n<p>The alphabets are {0,1}</p>\n\n<p>for e.g. (Anything)1***</p>\n\n<p>One way is to make an NFA and then convert it to DFA...</p>\n\n<p>But i am finding it quite difficult to do it.</p>\n', 'ViewCount': '85', 'ClosedDate': '2013-11-25T09:45:16.640', 'Title': 'Designing a DFA in which last fourth character is 1', 'LastActivityDate': '2013-11-14T17:49:03.743', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '18027', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><finite-automata><nondeterminism>', 'CreationDate': '2013-11-14T17:04:50.323', 'Id': '18023'},22_284:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to create a PDA for $\\{xy \\mid |x|=|y| \\text{ and } x \\ne y\\}$ over the alphabet $\\Sigma = \\{a, b\\}$. But I don't know how the PDA will know if the two strings $x$ and $y$ are not equal. Please help me create this PDA step by step.</p>\n", 'ViewCount': '67', 'ClosedDate': '2013-11-18T21:20:33.997', 'Title': u'Creating PDA for {xy such that |x|=|y| and x \u2260 y}', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-18T20:07:00.127', 'LastEditDate': '2013-11-18T13:11:33.327', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11417', 'Tags': '<formal-languages><pushdown-automata>', 'CreationDate': '2013-11-16T10:53:57.390', 'Id': '18069'},22_285:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can I think this way:</p>\n\n<p>We can convert a NFA to a RE using GFA.</p>\n\n<p>We build a series of GFAs. At each step, one state (other than start or accept) is removed and replaced by transitions that have the same effect.</p>\n\n<p>So, if we can convert k REs which have different forms but accept same language, then there must exists a string that the NFA accepts along k paths.</p>\n\n<p>Does that sound right?</p>\n\n<p>How to prove it properly?</p>\n', 'ViewCount': '131', 'Title': 'Can it be decided whether there exists a string accepted by a given NFA at least k ways?', 'LastEditorUserId': '10617', 'LastActivityDate': '2013-11-18T21:45:16.193', 'LastEditDate': '2013-11-18T21:45:16.193', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10617', 'Tags': '<turing-machines><finite-automata><undecidability>', 'CreationDate': '2013-11-18T02:51:27.257', 'Id': '18109'},22_286:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question is a follow up to the question: <a href="http://cs.stackexchange.com/questions/16321/proving-equivalence-of-1-dimensional-cellular-automaton-and-turing-machines">Proving Equivalence of 1-dimensional Cellular Automaton and Turing Machines</a>.</p>\n\n<p>To simulate a CA with a TM, I used a construction which placed a marker on the ends of the input, and modeled each "step" with the transition function. Assuming that $\\rho(\\text{\'\'blank\'\'}, \\text{\'\'blank\'\'}, \\text{\'\'blank\'\'}) = \\text{\'\'blank\'\'}$, what is the time complexity of simulating a CA? I\'m only concerned with the upper bound. </p>\n\n<p>I\'m really stuck, any hints would be really appreciated.</p>\n\n<p>Edit: As recommended, I am adding a better description of the algorithm:</p>\n\n<p>On input $w = w_1 w_2 \\dots w_n$, have the TM place unique begin and end characters on each side of the input. We model a single timestamp in the CA by multiple steps of the TM. The head sweeps through the taps, replacing its contents with the contents of the CA tape in the next timestamp. We write each character one place to teh right of where it would have been in the CA. Formally, this is: </p>\n\n<blockquote>\n  <p>there are states $q_{a,b}$ for all pairs of CA states, with transitions in the form:\n  $$ q_{a,b} \\to^{c \\to \\rho(a, b, c), R} q_{b,c}$$</p>\n</blockquote>\n\n<p>after completing a single sweep, return the head to the start of the tape and repeat. Continue unless an accept character is written, in which case, enter the TM accept state.</p>\n', 'ViewCount': '77', 'Title': 'Time Complexity of Simulating CA with TM', 'LastEditorUserId': '10448', 'LastActivityDate': '2013-11-20T04:00:24.680', 'LastEditDate': '2013-11-20T04:00:24.680', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10448', 'Tags': '<complexity-theory><turing-machines><cellular-automata>', 'CreationDate': '2013-11-19T19:37:42.877', 'FavoriteCount': '1', 'Id': '18168'},22_287:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to prove:</p>\n\n<blockquote>\n  <p>Let there be a constructible function $t: ~\\mathcal{N} \\to \\mathcal{N}$. Then there exists a language $L$ where $L$ is decidable by an LBA in $O(t(n))$ time, but not $o\\left(\\frac{t(n)}{\\log t(n)}\\right)$ time. You may assume that LBAs have a fixed tape alphabet and have unique symbols marking the start and end of the input.</p>\n</blockquote>\n\n<p>I've read through Sipser's version of the proof (Theorem 9.10) several times, but am not sure how to apply it to LBAs. Hints only please.</p>\n", 'ViewCount': '74', 'Title': 'Extension of Time Hierarchy Theorem to LBAs', 'LastActivityDate': '2013-11-19T21:36:29.687', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18171', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10596', 'Tags': '<complexity-theory><automata>', 'CreationDate': '2013-11-19T19:51:28.933', 'Id': '18169'},22_288:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>First I apologize if I confused therms DFA and FSM, to me it seems that is the same thing. The question is simple: Are the flowcharts (sequence, branching and jumping) equivalent to DFA resp. FSM? I am a bit confused about this. There are classes where using logical synthesis, Karunaugh maps, state encodings, flip flops etc. one is able to construct hardware consisting of logic gates and flip-flops which realizes the desired DFA. Basically all processes that runs on the computer (no matter if is written in C# or Assembler), are at the lowest level realized through logical gates, zeros and ones. So it seems that programs firstly needs to be converted (by compiler I suppose) to some form as I've described. This might imply that every problem that is solvable using C# is solvable using FSM. But this is in contradiction to Chomsky hierarchy and all this theory related stuff, which says that you cannot do the same magic with regular expressions (which are based on FSM) that you can do on Turing machine (which is equivalent of any programming language, if I am wrong correct me please). Moreover, if flowcharts (or even C#, Java ... source codes) were equivalent to FSM why we do not have all software formally verified so far? There is mathematical apparatus for FSM and related stuff, so why do not formally verify everything and ensure the correctness? What I am missing here?</p>\n", 'ViewCount': '59', 'Title': 'Flowcharts vs DFA resp FSM equivalency', 'LastActivityDate': '2013-11-20T23:19:14.123', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11513', 'Tags': '<formal-languages><turing-machines><finite-automata><computer-architecture>', 'CreationDate': '2013-11-20T23:19:14.123', 'FavoriteCount': '1', 'Id': '18210'},22_289:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm working on some questions to bone up on my knowledge of DFA's for a computing class and I've run across the following problem that is giving me some issues. If we have some \nDFA M = (Q, \u03a3, \u03b4, q0, F) and some other DFA M' = (Q, \u03a3, \u03b4, q0, F') where F is a proper subset of F', are the following relations possible or not between the two produced languages?</p>\n\n<p>1) L(M) \u2282 L(M')</p>\n\n<p>2) L(M) \u2283 L(M')</p>\n\n<p>My current theory is that the first one is not possible, due to the fact that the first machine has more finish states than the other, thus the language must be larger and cannot be subset to M'. This would of course mean that the second relationship is possible, since M must contain M'. Am I on the right track here and if so, how could I prove this?</p>\n", 'ViewCount': '58', 'Title': "Comparing DFA's produced languages", 'LastActivityDate': '2013-11-21T03:46:02.853', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11521', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-11-21T03:46:02.853', 'Id': '18214'},22_290:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know how to figure out the start state, accepting state, input alphabet, and all that stuff. But how do you develop the transition relation of a PDA? For an FSM, (q0,a),q1) means if you start at q0 and get an a, you transition to q1. But what does (S,a,e),(S,a) mean? (S is start state and e is epsilon)</p>\n\n<p>Here\'s a picture if that helps. I want to understand the circled part. I will be extremely appreciative of any help.<br>\n<img src="http://i.stack.imgur.com/87PpS.jpg" alt="enter image description here"></p>\n', 'ViewCount': '41', 'Title': 'How do you obtain transition relation of a PDA?', 'LastActivityDate': '2013-11-22T01:18:04.820', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18228', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10884', 'Tags': '<pushdown-automata>', 'CreationDate': '2013-11-21T15:31:51.493', 'Id': '18224'},22_291:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '430', 'Title': 'Maximum number of states in minimized DFA from NFA with $n$ states', 'LastEditDate': '2013-11-23T16:37:20.623', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8533', 'Body': '<p>If an NFA with $n$ states is converted to an equivalent minimized DFA then what will be the maximum number of states in the DFA? Will it be $2^n$ or $2n$?</p>\n', 'ClosedDate': '2013-11-28T06:27:57.097', 'Tags': '<automata><finite-automata><nondeterminism>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-23T17:32:54.963', 'CommentCount': '2', 'AcceptedAnswerId': '18280', 'CreationDate': '2013-11-23T15:18:01.973', 'Id': '18278'},22_292:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've just been learning about pushdown automata and I'm trying to create one that describe the following language:</p>\n\n<p>{$a^n b^n c^i \\in \\{a,b,c\\}^*\\ |\\ n \\ge 0,i\\ge 0$}</p>\n\n<p>What I have is the following:</p>\n\n<p>(state, symbol, top of stack), (next state, what goes to stack).</p>\n\n<p>$(s,$e$,$e$),(f,$e$)$</p>\n\n<p>$(s,a,$e$),(s,d)$</p>\n\n<p>$(f,b,d),(f,$e$)$</p>\n\n<p>$(f,c,$e$),(f,$e$)$</p>\n\n<p>Where $s$ is the starting state, $f$ is the final state and e is the empty word.</p>\n\n<p>Do I have the right idea? My worry is sending the automata to the final state while there are still entries in the stack - is that allowed?</p>\n", 'ViewCount': '79', 'Title': 'Does this pushdown automaton describe the language {$a^n b^n c^i \\in \\{a,b,c\\}^*\\ |\\ n \\ge 0,i\\ge 0$}?', 'LastEditorUserId': '11408', 'LastActivityDate': '2013-11-24T16:02:41.040', 'LastEditDate': '2013-11-24T15:58:39.410', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11408', 'Tags': '<pushdown-automata>', 'CreationDate': '2013-11-24T15:18:40.683', 'Id': '18302'},22_293:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '199', 'Title': 'Design a DFA which accepts words with sorted letters', 'LastEditDate': '2013-11-26T18:54:29.923', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11125', 'FavoriteCount': '1', 'Body': "<p>I have just started learning Theory of Computation and have come across a question which I am not able to solve.</p>\n\n<p>The question is as follows:</p>\n\n<pre><code>Design a DFA that reads a word (character strings) and decides whether the letters\nof the word are in sorted order.\nFor example: 'adept' and 'chilly' have their words in sorted order but 'baby' doesn't.\n</code></pre>\n\n<p>How should I design a DFA for this language?</p>\n\n<p>What I have tried:</p>\n\n<p>I think there must be two states.</p>\n\n<pre><code>1) While the DFA is scanning the word, the state (q1) will transit to itself \nif it reads a letter greater than or equal to previous letter read.\n\nThat is if the current_letter_read &gt;= previous_letter_read then \nq1 transits to itself. Otherwise, there is no action.\n\n2) If '\\0' is encountered, then the DFA transits to the final accepting state.\n</code></pre>\n\n<p>But in DFA is it possible to do so? How should I draw a DFA for this?\nI got stuck at this point. Am I missing some basic concept that I should know?</p>\n", 'Tags': '<finite-automata>', 'LastEditorUserId': '683', 'LastActivityDate': '2013-11-26T19:31:30.633', 'CommentCount': '5', 'AcceptedAnswerId': '18395', 'CreationDate': '2013-11-26T07:37:07.803', 'Id': '18355'},22_294:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve converted this NFA to a DFA and I get a similar soultion automata but I\'m not sure if I really understand everything. </p>\n\n<p>Please correct me if I\'m explaining it wrong, I would love some feedback.</p>\n\n<p>From the state 0 we only have the set {0} since there doesn\'t exist any \u03b5-transition.\nAfter that we have to input "a" to move to state 1 and here I\'ve got a question. Does it include the 0 also since "a" can either take you to state 1 but also to state 0 since it loops? </p>\n\n<p>Continuing we want to move to state 2 via "a" input. Why does it include the "0"? Is it because you have to consider all the inputs from each set in the state 1? Like, if you input "a" at 0 you loop but you can also go to state 1. From 1 if you input "a" you move forward to state 2. Which gives us the set {0,1,2}. </p>\n\n<p>If this is correct, then the procedure for state 3 should be the same, right? \nAlso, at the third state {0,1,2,3} he can\'t just loop "b" since the other states can\'t "handle" the input so you have to create a new state containing the set {0,3} which can handle the "b" input?</p>\n\n<p>Sorry if this is a bit long, I just want to understand what is going on really. </p>\n\n<p><img src="http://i.imgur.com/O3X8kQB.png?1" alt="Automatas"></p>\n', 'ViewCount': '93', 'Title': 'NFA to DFA convertion explanation', 'LastActivityDate': '2013-11-27T16:27:27.337', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18421', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11661', 'Tags': '<automata><finite-automata><nondeterminism>', 'CreationDate': '2013-11-27T13:45:53.487', 'Id': '18415'},22_295:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it possible to build DFA that support \\d, \\w, .(any symbol)? \nI understand that we can add each symbol from [0-9] as a separate edge for some of the symbols, but what about the others? for example .(any symbol)? or \\S (not white space)?</p>\n\n<p>In other words, can we build equivalent DFA for this NFA</p>\n\n<pre><code>(1) ---a----&gt; (2)\n |\n | \n .(any symbol)\n |\n \\/\n (3)\n</code></pre>\n', 'ViewCount': '38', 'Title': 'Is it possible to support .(any symbol) or \\d, \\w, \\W in DFA', 'LastActivityDate': '2013-11-28T16:59:34.080', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18447', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10348', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-11-28T16:33:28.350', 'Id': '18446'},22_296:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'Turing machine with possible transitions to the final state', 'LastEditDate': '2013-11-29T02:15:18.813', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': '<p><img src="http://i.stack.imgur.com/aRAVI.png" alt="enter image description here"></p>\n\n<p>Let\'s say we want to draw the transition graph of a Turing Machine that accepts that language L and then write the sequence of moves done by the TM when the input sequence is $w = abbcbba$ so I had some thoughts on how this could be built.</p>\n\n<p>$q0 - q1: a,a,R$</p>\n\n<p>$q1-q2: b,b,R$</p>\n\n<p>$q2 (loop): b,b,R$</p>\n\n<p>$q2-q3: c,c,R$</p>\n\n<p>$q3-q4: b,b,R$</p>\n\n<p>But then I\'m getting stuck here, I could see $b,b,R$ to the final state and then add a separate node to account for the case $m=3$, but I\'m teaching this to myself so maybe someone can step in here and get me back on track.</p>\n\n<p>EDIT:</p>\n\n<p>This might work:</p>\n\n<p><img src="http://i.stack.imgur.com/qqxDM.jpg" alt="enter image description here"></p>\n', 'ClosedDate': '2014-01-23T18:49:36.310', 'Tags': '<formal-languages><turing-machines><automata>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-11-29T02:15:18.813', 'CommentCount': '1', 'AcceptedAnswerId': '18456', 'CreationDate': '2013-11-28T19:46:19.570', 'Id': '18452'},22_297:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this nondeterministic pda:\n$$\\Sigma=  \\{a,b,c\\}$$</p>\n\n<p>and </p>\n\n<p>$$\nL=\\{\\omega\\  \\epsilon\\ \\Sigma^*\\ |\\ \\omega\\ = \\alpha\\beta\\beta^R\\gamma\\ and\\ \\alpha,\\beta,\\gamma\\ \\epsilon\\ \\Sigma^*\\ and\\ |\\beta|\\ &gt;3 \\}\n$$</p>\n\n<p>So once i have create the NPDA, i have to calculate the probability of accepting a correct word, i know it depends on the size of $\\alpha$ and the "free" jumps ($\\varepsilon,\\varepsilon-&gt;\\varepsilon$).\nMy problem is that i can\'t find the exact function of probability can someone explain me how to do it?</p>\n\n<p>Thanks.</p>\n', 'ViewCount': '90', 'Title': 'help with the probability of acceptance of a Nondeterministic Pushdown automata', 'LastActivityDate': '2013-11-29T22:57:27.457', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18468', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '11695', 'Tags': '<context-free><probability-theory><pushdown-automata><nondeterminism>', 'CreationDate': '2013-11-29T11:15:00.567', 'Id': '18464'},22_298:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I've been given the following language on an assignment.  It is the only question I have left of 10, and I've been racking my brains out trying to solve it for hours.  </p>\n\n<p>$$L=\\{w:w\\in(a+b+c)^*, n_a(w) &gt; n_b(w)&gt;n_c(w)\\}$$</p>\n\n<p>where $n_x(w)$ represents the number of character $x$ found in $w$.  The problem statement is: <strong>prove or disprove that the language is context-free</strong>.  Context-free grammars or pushdown automata are acceptable proofs.  Use pumping lemma to disprove.</p>\n\n<p>I've extensively explored both possibilities and I'm fairly certain that it is context-free.  </p>\n\n<p>The approach I've taken in finding a context-free grammar for the language involves using rules which preserve the constraint $n_a(w) &gt; n_b(w) &gt; n_c(w)$ (ie. whenever a $b$ is added, add an $a$; whenever a $c$ is added, add a $b$).  Then, I've attempted to enforce that there are at least two $a$s and at least one $b$ (base case for the constraint).</p>\n\n<p>The grammar I've used is:</p>\n\n<p>$S\\implies XaXaXbX | XaXbXaX | XbXaXaX$</p>\n\n<p>$X \\implies XX| A | B | C | \\lambda$</p>\n\n<p>$A \\implies a$</p>\n\n<p>$B \\implies ab | ba$</p>\n\n<p>$C \\implies abc | acb | bac | bca | cab | cba$</p>\n\n<p>(where $\\lambda$ is the empty string)</p>\n\n<p>My grammar fails for strings like $cccaaaaabbbb$.</p>\n\n<p>I'm confused as to where to go from here.  </p>\n\n<p><strong>I would really like a push in the right direction, not an answer.</strong>\n Any help is greatly appreciated!</p>\n", 'ViewCount': '87', 'Title': 'Is $\\{w:w\\in(a+b+c)^*, n_a(w) > n_b(w)>n_c(w)\\}$ context-free?', 'LastEditorUserId': '9612', 'LastActivityDate': '2014-01-29T22:37:10.603', 'LastEditDate': '2013-12-30T11:42:33.360', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10400', 'Tags': '<context-free><formal-grammars><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-11-29T17:48:42.330', 'FavoriteCount': '1', 'Id': '18470'},22_299:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the following multiplication table how could one construct an NFA such that it accepts all strings that have a certain product (say a) ? </p>\n\n<p>The string "abcb" would be evaluated as (a(b(cb))) = a</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; a &amp; c \\\\\n    b &amp; c &amp; a &amp; b \\\\\n    c &amp; b &amp; c &amp;a\n   \\end{array}</p>\n\n<p>I tried to take the transpose of the above matrix:</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; c &amp; b \\\\\n    b &amp; a &amp; a &amp; c \\\\\n    c &amp; c &amp; b &amp; a\n   \\end{array}</p>\n\n<p>And build an NFA for that. I then reversed all the transitions, but I don\'t think that works.</p>\n', 'ViewCount': '72', 'Title': 'NFA for right left multiplication', 'LastActivityDate': '2013-12-02T04:34:35.407', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11741', 'Tags': '<regular-languages><finite-automata><nondeterminism><multiplication>', 'CreationDate': '2013-12-01T20:37:27.720', 'Id': '18509'},22_300:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to describing a Turing machine that computes $\\lceil\\log_{2}(n)\\rceil$ I know that:</p>\n\n<p>n = 1, 2, 3, 4, 5, 6, 7, 8, ... <br>\nf(n) = 0, 1, 2, 2, 3, 3, 3, 3, ...</p>\n\n<p>So I'm thinking of putting $n$ on the tape. Then keeping a count of how many times I multiply 2*2 until it is greater than than $n$. For example for n=5, 2*2*2=8, number of two's is 3 so then $f(n)$ is 3. I don't know how to translate this to the ticker tape of the Turing machine.</p>\n\n<p>But would something like this work? Put $n$ 1's on the tape followed by a 0. Compute 1^(2^1), then check if 1's on the left of the 0 on the tape is less than or equal to the 1's on the right of the 0. If its not then repeat it for 1^(2^(1)). It keeps doing this until the left side has less than or equal number of 1's.</p>\n", 'ViewCount': '98', 'Title': 'Describing a Turing machine that computes $\\lceil\\log_{2}(n)\\rceil$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-02T19:09:53.377', 'LastEditDate': '2013-12-02T19:09:53.377', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18541', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<complexity-theory><turing-machines><automata>', 'CreationDate': '2013-12-02T17:04:15.713', 'Id': '18537'},22_301:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>when converting an NFA to DFA, we create sub-sets of states in the NFA.\ndoes it mean that every DFA-converted-from-NFA contain 2^Q states? or if some sub-sets are unreachable then they are not included in it?</p>\n', 'ViewCount': '308', 'Title': 'does a DFA converted from NFA always contain 2^Q states?', 'LastActivityDate': '2013-12-05T17:00:56.737', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '18579', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11713', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-12-03T17:58:02.983', 'FavoriteCount': '1', 'Id': '18577'},22_302:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '134', 'Title': 'Partition an infinite regular language into 2 disjoint infinite regular languages', 'LastEditDate': '2013-12-05T18:01:50.127', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11713', 'FavoriteCount': '1', 'Body': "<p>Given any infinite regular language $L$, how can I prove that $L$ can be partitioned into 2 disjoint infinite regular languages $L_1, L_2$? That is: $L_1 \\cup L_2 = L$, $L_1 \\cap L_2 = \\varnothing$, and $L_1$ and $L_2$ are both both infinite and regular.</p>\n\n<p>So far, I thought of:</p>\n\n<ol>\n<li><p>using the pumping lemma such that \n$$ \\begin{gather}\n  L_1 &amp;= \\{ xy^nz \\mid \\text{\\(n\\) is even} \\} \\\\\n  L_2 &amp;= \\{ xy^mz \\mid \\text{\\(m\\) is odd} \\} \\\\\n\\end{gather} $$\nbut couldn't prove that they are dijoint or covering $L$ completely. </p></li>\n<li><p>Using the regular language partitions $\\Sigma^*$ into dijoint equivalence classes, but I haven't figured out how to determine if an equivalence class is regular or infinite.</p></li>\n</ol>\n", 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-05T18:01:50.127', 'CommentCount': '0', 'AcceptedAnswerId': '18613', 'CreationDate': '2013-12-04T14:40:00.883', 'Id': '18610'},22_303:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $X = \\{\\langle M \\rangle\\ |\\ M\\text{ is a finite state machine and }L(M) = \\emptyset\\}$ where $\\langle M \\rangle$ is an encoding of the\nmachine $M$.  Is $X$ Turing decidable?  Why or why not?</p>\n', 'ViewCount': '148', 'Title': 'Decide whether a DFA accepts the empty language', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-20T07:31:54.950', 'LastEditDate': '2013-12-19T18:20:56.877', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11809', 'Tags': '<turing-machines><automata><pushdown-automata>', 'CreationDate': '2013-12-04T17:33:25.773', 'Id': '18616'},22_304:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I recently had a problem where I had to create a regular language. After consulting my professor on my solution he told me it was close to correct but to check my definition of a regular language. I am somewhat lost on why my solution is not regular?</p>\n\n<p><img src="http://i.stack.imgur.com/CTosd.png" alt="solution"></p>\n\n<p>From my understanding it meets the requirements of being a right regular language since there is only one non-terminal on the right side of the expression and the non-terminal is the rightmost symbol on the right side of the expression. Are pipe symbols not allowed?</p>\n', 'ViewCount': '79', 'Title': 'Why is this not a regular language', 'LastEditorUserId': '11820', 'LastActivityDate': '2013-12-05T10:04:41.513', 'LastEditDate': '2013-12-05T01:45:19.807', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18627', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11820', 'Tags': '<regular-languages><context-free><automata>', 'CreationDate': '2013-12-05T01:09:19.733', 'Id': '18624'},22_305:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the following:</p>\n\n<p>$$\\{ w\\#x \\mid w^R \\text{ is a substring of $x$, with $x$ and $w \\in \\Sigma^*$} \\}$$</p>\n\n<p>What does $w\\#x$ denote?</p>\n', 'ViewCount': '115', 'Title': 'What does the symbol # mean when it comes to languages', 'LastEditorUserId': '9612', 'LastActivityDate': '2013-12-07T10:37:19.277', 'LastEditDate': '2013-12-07T10:37:19.277', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18631', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-languages><terminology><context-free><automata>', 'CreationDate': '2013-12-05T06:38:57.007', 'Id': '18630'},22_306:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The intersection of a context free language L with a regular language M, is said  to be always context free. I understood the cross product construction proof, but I still don't get why it is context free but not regular.</p>\n\n<p>The language generated by such an intersection has strings that are accepted both by a PDA <em>and</em> a DFA. Since it is accepted by a DFA, shouldn't it be a regular language? Plus, if the intersection is regular, it also implies context free, since all regular languages are also context free.</p>\n\n<p>Can someone explain to me why the language obtained by such an intersection is not regular?</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '273', 'Title': 'Intersection of context free with regular languages', 'LastActivityDate': '2013-12-05T15:20:51.903', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18645', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<context-free><finite-automata><formal-grammars>', 'CreationDate': '2013-12-05T14:24:39.063', 'FavoriteCount': '2', 'Id': '18642'},22_307:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to figure out if there exists a DFA $M$ with $k+2$ states (for every $k\\in \\mathbb{N}$ ) so that every automaton which accepts $L(M)^R$ has at least $2^k$ states.<br>\nI am trying to find an example of such a DFA, any help?</p>\n', 'ViewCount': '66', 'Title': 'Is there a DFA with $k+2$ states which its reverse has $2^k$ states', 'LastActivityDate': '2013-12-06T01:03:55.337', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18655', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11841', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-12-05T16:27:34.630', 'Id': '18648'},22_308:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': 'Synchronizing sequence and Synchronizable DFA', 'LastEditDate': '2013-12-07T01:48:28.913', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11841', 'FavoriteCount': '1', 'Body': '<p>I am trying to prove problem 1.59 in Sipser\'s book: <em>Introduction to the theory of computation , 2nd Edition.</em></p>\n\n<blockquote>\n  <p>Let $M=(Q,\\Sigma,\\delta,q_0,A)$ be a DFA and let $q\'$ be a state of $M$ called its "home". A <strong>Synchronizing sequence</strong> for $M$ and $q\'$ is a string $s\\in \\Sigma^*$ where $\\delta (q,s)=q\'$ for every $q\\in Q$. (We actually have extended $\\delta$ to strings so that $\\delta(q,s)$ equals the state where $M$ ends up when $M$ starts at state $q$ and reads input $s$).</p>\n  \n  <p>Say that $M$ is <strong>Synchronizable</strong> if it has a synchronizing sequence for some state $q\'$.</p>\n  \n  <p>Prove that, if $M$ is a $k$-state synchronizable DFA, then it has a synchronizing sequence of length at most $k^3$. Moreover, can you improve upon this bound?  </p>\n</blockquote>\n\n<p>I\'m more interested in proving that the synchronized sequence is of length of at most $k^3$ then trying to improve upon this bound.  </p>\n\n<p>I tried to prove (with no success) that there exists $w\\in \\Sigma^*$ which $|w| \\leq k^2 $ so that: $\\delta(q_1,w)=\\delta(q_2,w)$ for two distinct states in $M$: $q_1,q_2\\in Q$ (thus, $w$ can be read from two states in the automaton and get to the same final state).<br>\nIf I prove it, I could construct a word $w$ which will be a synchronizing sequence in $M$ and $|w|\\leq k^3$ as required.  </p>\n\n<p>Any suggestions?</p>\n', 'Tags': '<regular-languages><automata><finite-automata>', 'LastEditorUserId': '11841', 'LastActivityDate': '2013-12-07T02:40:56.123', 'CommentCount': '1', 'AcceptedAnswerId': '18704', 'CreationDate': '2013-12-06T18:56:27.920', 'Id': '18692'},22_309:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I've been trying for quite some extended time to find a construction so that I can formally demonstrate that a deterministic PDA is closed under complementation. However, it happens that every idea I got has something that at the end does not fit. Could you give me a hand?</p>\n\n<p>The main problem happens with the <strong>\u03b5-moves</strong>. A PDA could finish reading its input in a non-final (rejecting state) but can still move to a final (accepting) state through an <strong>\u03b5-move</strong> and end up accepting the string. This means that just adding a dead state and complementing the states does not work. I already solved the problem of possible infinite sequences of <strong>\u03b5-moves</strong>, so that is not a main part of my question.</p>\n\n<p><strong>EDIT:</strong> As far as I understand, if the DPDA reaches <em>end of input</em> and is in an accepting state and moves to a rejecting state through an <strong>\u03b5-move</strong> it would still accept it (as it reached a final state with no input symbol left to read).</p>\n\n<p>Please let me know if I can be more clear.</p>\n", 'ViewCount': '148', 'Title': 'Demonstrate that DPDA is closed under complement by construction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-28T10:53:54.807', 'LastEditDate': '2014-03-26T08:26:09.787', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-12-10T00:34:01.010', 'Id': '18800'},22_310:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve had this little doubt bothering me since four semesters now, so I\'ve come here to resolve it. Theoretical CS was probably not the right place to ask.</p>\n\n<p>Coming to the question, my old coursebook (<em>Theory of Computer Science - Automata, Languages and Computation (Eastern Economy Edition)</em> by KLP Mishra) details the conversion of the regular expression -:</p>\n\n<p>$(0 + 1)^* (00 + 11)(0+1)^*$</p>\n\n<p>to a finite automaton. The book details the process as follows:</p>\n\n<p><img src="http://i.stack.imgur.com/BLoTu.jpg" alt="Diagram of Procedure"></p>\n\n<p>I am able to grasp the process uptil step (d). I do not understand how (e) was obtained, and there is no explanation given. I tried to convert (d) to (e) by removing null-moves, but I am not able to get (e) - I obtain a bunch of redundant states (extra initial and final states). </p>\n\n<p>It is not possible to use the DFA minimization procedure to obtain (e) after the null-moves are deleted, simply because this isn\'t a DFA yet - it\'s still an NFA. Note that I\'ve not shown the NFA to DFA conversion procedure, which was on the next page. Could someone point me in the right direction? </p>\n\n<p>There are no steps given to obtain (e) from (d). That\'s what\'s confusing - I know I have  to remove the null-moves but not how to get the neat and \'minimized\' transition system given by (e).</p>\n', 'ViewCount': '239', 'Title': 'Redundant States During Removal of Null-Moves (Regular Expression to DFA)', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-10T17:09:24.310', 'LastEditDate': '2013-12-19T15:36:26.560', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11990', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-12-10T12:40:04.293', 'Id': '18828'},22_311:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having a bit of difficulty understanding the order of precedence in boolean logic for the OR operation. Take this example:</p>\n\n<p>Assume the following regular expression:</p>\n\n<pre><code>((a(b+))+(a|c))|a|c\n</code></pre>\n\n<p>Why is it that this accepts the strings:</p>\n\n<pre><code>a\nc\nabba\nabbabbba\nabbabbc\n</code></pre>\n\n<p>etc</p>\n\n<p>But when I flip it around and use the regular expression</p>\n\n<pre><code>a|c|((a(b+))+(a|c))\n</code></pre>\n\n<p>I can now only ever get the following strings when I check it with a RegExp tester:</p>\n\n<pre><code>a\nc\n</code></pre>\n\n<p>I know it is to do with the order of precedence but I don't understand why, please could somebody enlighten me?</p>\n", 'ViewCount': '81', 'Title': 'Why does a regular expression only accept all my required strings when the concatenation is the first of the OR operations?', 'LastActivityDate': '2013-12-11T05:47:49.150', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '18864', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12006', 'Tags': '<formal-languages><automata><regular-expressions>', 'CreationDate': '2013-12-11T02:11:39.407', 'FavoriteCount': '1', 'Id': '18858'},22_312:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I did see a lot of nice and informative questions, articles on inter-net and on StackOverflow itself, of-course. But I found all the questions or articles following a specific rule or a pattern to explain the topic. I mean, when a question was asked on NFA, DFA or Regular Expression, a solution was presented to the question abiding by the theorems / rules of these topics (Theory of Computation).</p>\n\n<p>But what I feel is that, as most of the questions on DFA/NFA are of the type \n"Design an NFA...." or "design a DFA..." , I feel that developing/Designing DFA/NFA must be an ART. </p>\n\n<p>And where there is ART I feel there is an intuition. If these problems involve "DESIGNING" something ,then everyone must have their own way (of-course not going out-of-the-way of theorems or rules as such) of solving or attacking these problems. One should have developed a thinking process (over the years of practise) to solve these problems.</p>\n\n<p>So I would like all the experts over this Site to share their knowledge (preferably in simple words) how they think over the problems (simple ones) of these topics.</p>\n\n<p>I would like to elaborate the question with a simple example.</p>\n\n<blockquote>\n  <p>Let F be the language of all strings over {0,1} that do not contain a pair of 1s that\n  are separated by an odd number of symbols. Give the state diagram of a DFA with\n  five states that recognizes F . </p>\n</blockquote>\n\n<p>Or maybe this:</p>\n\n<blockquote>\n  <p>Design an NFA to find a 4-state NFA for the complement of F.</p>\n</blockquote>\n\n<p>These questions are from the Sipser\'s book and I have also found the solutions for them myself. </p>\n\n<p>I just want to know , how one can develop an intuition for solving the problems?</p>\n', 'ViewCount': '215', 'ClosedDate': '2013-12-13T08:23:17.523', 'Title': 'How to approach NFA design questions intuitively?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-12T09:39:34.433', 'LastEditDate': '2013-12-12T09:39:34.433', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11125', 'Tags': '<regular-languages><finite-automata><education>', 'CreationDate': '2013-12-12T07:26:32.340', 'Id': '18913'},22_313:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a non-deterministic push down automata (we define "accept" here using accept states), if we assume any operation popping from the stack and checking if the top of the stack contains some symbol can succeed (i.e. "getting rid" of the stack), we get a non-deterministic finite automata.</p>\n\n<p>If we convert two such PDAs, whose languages recognized are the same, and assuming <em>all states are reachable</em>, to NFAs in this fashion, are the languages recognized by the NFAs still the same?</p>\n\n<hr>\n\n<p>Here\'s a simple example.  Consider the language $\\{a^n b^n : n \\in \\mathbb{N}\\}$.  Here\'s one simple PDA for it.  The PDA has two states, $q_0,q_1$.  When it is in state $q_0$ and it reads the symbol $a$ on the input tape, it pushes $A$ on the stack and remains in state $q_0$.  When it reads the symbol $b$ on the input table and the stack is non-empty, it pops whatever is on the stack and moves to state $q_1$.  The PDA accepts if the stack is empty at the end of the input string.  If we convert this PDA to a NFA, we get a NFA with two states $q_0,q_1$ and transitions $q_0 \\stackrel{a}{\\to} q_0$, $q_0 \\stackrel{b}{\\to} q_1$, $q_1 \\stackrel{b}{\\to} q_1$.  This NFA accepts the language $a^* b^*$.  There are other ways to build a PDA for the language $\\{a^n b^n : n \\in \\mathbb{N}\\}$; if we apply the same conversion to them, does the corresponding NFA always accept the language $a^* b^*$?</p>\n', 'ViewCount': '86', 'Title': 'Relaxing the stack in a push down automata', 'LastEditorUserId': '9173', 'LastActivityDate': '2013-12-14T11:26:22.807', 'LastEditDate': '2013-12-14T06:50:09.547', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '18970', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9173', 'Tags': '<formal-languages><pushdown-automata><nondeterminism>', 'CreationDate': '2013-12-13T16:15:38.797', 'Id': '18955'},22_314:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>How would one go about proving that one PDA that may only pop one symbol from its stack per transition, is equivalent to a second PDA that is allowed to pop any number of symbols?</p>\n\n<p>That is a PDA with transitions of type $(Q\xd7(\u03a3\u222a{\u03b5})\xd7(\u0393\u222a{\u03b5}))\xd7(Q\xd7\u0393^*)$ is equivalent to a PDA with transitions of type $(Q\xd7(\u03a3\u222a{\u03b5})\xd7(\u0393^*))\xd7(Q\xd7\u0393^*)$.</p>\n', 'ViewCount': '41', 'Title': 'Equivalency of two pushdown automata', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-12-18T01:03:00.653', 'LastEditDate': '2013-12-18T01:03:00.653', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user12200', 'PostTypeId': '1', 'Tags': '<proof-techniques><pushdown-automata>', 'CreationDate': '2013-12-18T00:53:11.713', 'Id': '19078'},22_315:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to show that the language Anfa = {(A,w)| A is an nondeterministic finite automata that accepts w} can be decided in polynomial time. My problem is every solution that I think of requires exponential time.</p>\n\n<p>I would appreciate any help, Thanks in advance..</p>\n', 'ViewCount': '115', 'Title': 'how to solve NFA acceptance problem in polynomial time', 'LastActivityDate': '2013-12-19T17:38:29.810', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12242', 'Tags': '<time-complexity><finite-automata><nondeterminism><polynomial-time>', 'CreationDate': '2013-12-19T17:12:44.090', 'Id': '19126'},22_316:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to understand decidable languages. In particular, I would like to show that\n$$B = \\lbrace \\langle D \\rangle \\mid \\exists k \\geq 0 \\,.\\,\\text{DFA $D$ accepts $a^k b^k$}\\rangle.$$\nI don't quite understand the process of proving these. I know that $a^kb^k$ is not regular, so then no DFA accepts it. I also know that $A_{DFA}$ (acceptance DFA) is decidable, I also know several other decidable languages like $E_{DFA}$ and $EQ_{DFA}$. How can I use these to prove that $B$ is decidable? </p>\n\n<p>If no DFA accepts $a^kb^k$, doesn't that mean that $A_{DFA}$ will reject? So if $A_{DFA}$ rejects then shouldn't the decider for $B$ accept? </p>\n", 'ViewCount': '110', 'Title': 'Decidability of $\\lbrace \\langle D \\rangle \\mid \\text{$D$ accepts $a^kb^k$ for some $k > 0$}\\rbrace$', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-29T09:53:04.893', 'LastEditDate': '2013-12-29T09:53:04.893', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '19173', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<computability><finite-automata>', 'CreationDate': '2013-12-21T02:54:13.680', 'Id': '19171'},22_317:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As described in <a href="http://courses.engr.illinois.edu/cs421/sp2012/project/PracticalEarleyParsing.pdf" rel="nofollow">this paper</a>, you can use an pre-computed automaton to speed up an Earley parse.  I\'m not interested in the rigorous proof of this, but just how the basic algorithm works so that I can implement it.  Understanding this paper on my own would take a long long time, and I don\'t think it\'s justified for this algorithm because it seems simple enough, but the paper is accademic and is required to be over my head, so they didn\'t write it for a reader like me.</p>\n\n<p>For instance, what does a transition labeled with a variable in the automaton mean?  How does this thing work?</p>\n', 'ViewCount': '35', 'Title': 'How does Earley parsing using an automaton work?', 'LastActivityDate': '2013-12-25T17:26:45.727', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12373', 'Tags': '<algorithms><automata><parsers>', 'CreationDate': '2013-12-25T17:26:45.727', 'Id': '19284'},22_318:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to find a formal proof of the following fact:</p>\n\n<blockquote>\n  <p>Given a context-free language $L_1$ and a context-sensitive language $L_2$, it is NOT decidable if their intersection is empty ($L_1 \\cap L_2 = \\varnothing$).</p>\n</blockquote>\n\n<p>I want to be able to prove it by contradiction, knowing the fact that it's undecidable to say if a given context sensitive grammar is empty.</p>\n\n<p>I know that the intersection of two context-free languages is undecidable, but I have to make a formal proof by contradiction. Taking $L_1$ as $\\Sigma^*$ ends up with a CS intersection, ok that's fine but I would like to make a better and more formal proof, without recurring to take specific languages, in a more general way... </p>\n", 'ViewCount': '76', 'Title': 'Intersection between context-free and context-sensitive language decidability', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-28T16:25:05.513', 'LastEditDate': '2013-12-28T16:25:05.513', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12405', 'Tags': '<computability><context-free><automata><undecidability><context-sensitive>', 'CreationDate': '2013-12-27T14:51:43.293', 'Id': '19326'},22_319:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '24', 'Title': 'Decidability. $\\lbrace \\langle D \\rangle \\mid \\text{$D$ accepts $a^kb^k$ for some $k > 0$}\\rbrace$', 'LastEditDate': '2013-12-29T09:52:56.220', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'Data', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Body': "<p>I'm trying to understand decidable languages. In particular, I would like to show that\n$$B = \\lbrace \\langle D \\rangle \\mid \\exists k \\geq 0 \\,.\\,\\text{DFA $D$ accepts $a^k b^k$}\\rangle.$$\nI don't quite understand the process of proving these. I know that $a^kb^k$ is not regular, so then no DFA accepts it. I also know that $A_{DFA}$ (acceptance DFA) is decidable, I also know several other decidable languages like $E_{DFA}$ and $EQ_{DFA}$. How can I use these to prove that $B$ is decidable? </p>\n\n<p>If no DFA accepts $a^kb^k$, doesn't that mean that $A_{DFA}$ will reject? So if $A_{DFA}$ rejects then shouldn't the decider for $B$ accept? </p>\n", 'ClosedDate': '2013-12-29T11:42:46.690', 'Tags': '<computability><finite-automata>', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-29T09:52:56.220', 'CommentCount': '4', 'CreationDate': '2013-12-21T01:42:14.683', 'Id': '19357'},22_320:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do I iterate over all the $k$-element subsets of $\\{1,2,\\dots, n\\}$ by switching one element at a time?</p>\n\n<pre><code>123\n134\n234\n124\n145\n245\n345\n135\n235\n125\n</code></pre>\n\n<p>This comes from Ch2 of  <a href="http://www.math.upenn.edu/~wilf/website/CombinatorialAlgorithms.pdf" rel="nofollow">Combinatorial Algorithms</a> by Nienhuis and Wilf.</p>\n\n<p>Equivalently I am asking for a Hamiltonian circuit on the <a href="http://en.wikipedia.org/wiki/Johnson_graph" rel="nofollow">Johnson graph</a> of $k$ element subsets of a set of $n$ elements connected if their intersection has $k-1$ elements. </p>\n\n<hr>\n\n<p>I am trying to understand how the equation $$A(n,k) = A(n-1,k), \\overline{ A(n-1,k-1)}\\otimes \\{n\\}$$ from Nienhuis-Wilf leads to a type of "gray code" for subsets.  In fact, it is the gray code when you restruct to $k$-element sets. </p>\n\n<p>Here, $A(n,k)$ is an ordering, looping over the $k$-element subsets of $\\{1,2,\\dots, n\\}$.   The notation $\\overline{ A(n-1,k-1)}\\otimes \\{n\\}$ means we should list the $k-1$-element substs of $\\{1,2,\\dots, n-1\\}$ and append the element $n$ to each element of that list.</p>\n\n<p>This equation can also be thought of a set theoretic version of the binomial coefficient identity</p>\n\n<p>$$ \\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$$</p>\n\n<p>Using this formation I came up a means of listing all the subsets in order. </p>\n\n<p>Here <code>gc(n,k)</code> is returning an array of $k$-element arrays, enumerating the $k$-element subsets of $\\{1,2,\\dots, n\\}$.</p>\n\n\n\n<pre><code>def gc(n,k):\n    if(k==1):\n        return [[i+1] for i in range(n)]\n    elif(n == 0):\n        return []\n    else:\n        L = [ x+ [n] for x in gc(n-1,k-1)]\n        return gc(n-1,k)+ L[::-1]\n</code></pre>\n\n<p>How do I find the predecessor or successor of a given subset without generating all the subsets?  I wrote some python code for this, which is different from what is in the textbook.  It still doesn\'t return the correct answer.</p>\n\n<pre><code>def S(n,k,a):\n    if k == 1:\n        return [(a[0] + 1)%n]\n    elif(a[-1] == n-1):\n        return P(n-1,k-1, a[:-1]) + [n-1]\n    else:\n        return S(n-1,k,a)\n\ndef P(n,k,a):\n    if k == 1:\n        return [(a[0] - 1)%n]\n    elif(a[-1] == n-1):\n        return S(n-1,k-1, a[:-1]) + [n-1]\n    else:\n        return P(n-1,k,a)\n</code></pre>\n\n<p>This looks pretty close to the recursion in Nienhuis-Wilf but I would like to understand where I am going wrong in my implementation.</p>\n', 'ViewCount': '99', 'Title': 'iterating over subsets by switching one element at a time', 'LastEditorUserId': '3131', 'LastActivityDate': '2014-01-08T21:29:35.157', 'LastEditDate': '2014-01-05T18:08:51.710', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><graph-theory><finite-automata>', 'CreationDate': '2014-01-05T03:35:26.093', 'Id': '19504'},22_321:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>(I\'m aware that software questions are better suited for stackoverflow, but since DFAs are not something that software developers usually care about, I hope it\'s alright if I ask here.)</p>\n\n<p>I\'m currently working on a project to do with regular overapproximations for context free languages. For this purpose, I need to implement stuff that requires me to represent regular languages in a minimized form, intersect them, complement them, etc. - i.e. everything that\'s easy and quick to do with DFAs. However, I\'m having a hard time finding still-maintained libraries for DFAs in C++. I could find <a href="http://augeas.net/libfa/index.html" rel="nofollow">libfa</a> which does everything quite nicely, but that\'s as far as I\'ve gotten. <a href="http://www.cse.ust.hk/faculty/dwood/.grail/" rel="nofollow">Grail</a> hasn\'t been maintained in 15+ years and the download link is dead. <a href="http://fado.dcc.fc.up.pt/" rel="nofollow">FAdo</a> seemed interesting initially, but it\'s in Python and I can\'t determine whether there\'s a way to use it as a C++ library, or whether it offers the functionality I mentioned above (the Docs are a bit slim).</p>\n\n<p>Do you know of C(++) libraries for DFAs that offer minimization, intersection and complementation that are free for academic use? I\'d like to have at least one alternative to libfa that I can use.</p>\n', 'ViewCount': '92', 'Title': 'C(++) library for DFAs - free for academic use', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-12T11:35:11.127', 'LastEditDate': '2014-01-12T11:35:11.127', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6689', 'Tags': '<reference-request><automata><finite-automata><mathematical-software>', 'CreationDate': '2014-01-12T04:18:00.143', 'FavoriteCount': '1', 'Id': '19664'},22_322:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two sets $A,B$ of strings over alphabet $\\Sigma$, can we compute the smallest deterministic finite-state automaton (DFA) $M$ such that $A \\subseteq L(M)$ and $L(M) \\subseteq \\Sigma^*\\setminus B$?</p>\n\n<p>In other words, $A$ represents a set of positive examples.  Every string in $A$ needs to be accepted by the DFA.  $B$ represents a set of negative examples.  No string in $B$ should be accepted by the DFA.</p>\n\n<p>Is there a way to solve this, perhaps using <a href="https://en.wikipedia.org/wiki/DFA_minimization">DFA minimization</a> techniques?  I could imagine creating a DFA-like automaton that has three kinds of states: accept states, reject states, and "don\'t-care" states (any input that ends in a "don\'t-care" state can be either accepted or rejected).  But can we then find a way to minimize this to an ordinary DFA?</p>\n\n<p>You could think of this as the problem of learning a DFA, given positive and negative examples.</p>\n\n<p>This is inspired by  <a href="http://cs.stackexchange.com/q/19686/755">Is regex golf NP-Complete?</a>, which asks a similar questions for regexps instead of DFAs.</p>\n', 'ViewCount': '158', 'Title': 'Smallest DFA that accepts given strings and rejects other given strings', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:31:57.547', 'LastEditDate': '2014-01-13T12:59:49.750', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '19693', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<regular-languages><automata><finite-automata><machine-learning>', 'CreationDate': '2014-01-13T09:37:38.647', 'Id': '19687'},22_323:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m totally new to DFA\'s and automaton in general -- this is the first week or two of class that I\'ve actually seen this -- and I\'m curious as to a pattern to match the following: </p>\n\n<p>"Match the set of all strings on the alphabet {a, b} that have at least one b and exactly 2 a\'s" </p>\n\n<p>I\'ve tried to construct a DFA to represent this structure, but I have no idea how to form a structure to count for something and match for one. </p>\n\n<p>Can someone help? </p>\n\n<hr>\n\n<p>Okay, so. Here\'s what I got and I think it\'s the right answer. <img src="http://i.stack.imgur.com/ZxdI4.jpg" alt="dfa"></p>\n', 'ViewCount': '115', 'Title': 'DFA for exactly two of a and one or more of b', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:32:48.550', 'LastEditDate': '2014-01-15T08:32:48.550', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '19738', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12863', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-01-15T03:24:11.070', 'Id': '19736'},22_324:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking at the following non-deterministic finite automata which accepts all strings that end with at least 2 bs.  I am wondering what would happen when you have the input string \'abba\' with this automata:</p>\n\n<p><img src="http://i.stack.imgur.com/hQYaA.png" alt="Automata"></p>\n\n<p>The possible computations I have so far are</p>\n\n<p>q0, q0, q0, q0, q0</p>\n\n<p>q0, q0, q1, q2, ??</p>\n\n<p>q0, q0, q0, q1, ??</p>\n\n<p>Would anyone be able to fill in the \'??\'s in this automata and be able to explain why they occur?</p>\n', 'ViewCount': '40', 'Title': 'Finite Automata Input Confusion', 'LastEditorUserId': '12879', 'LastActivityDate': '2014-01-17T18:52:39.547', 'LastEditDate': '2014-01-17T18:33:14.803', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19790', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12879', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-01-17T18:04:12.667', 'Id': '19786'},22_325:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm studying for my Computing languages test and there's one idea I'm having problems wrapping my head around, as far as I know for any Context Free Grammar (CFG), we can design a 2-state Pushdown Automaton (PDA). I am however a little bit confused that why this is possible.</p>\n", 'ViewCount': '165', 'Title': 'How to get 2-state PDA for CFG?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T14:37:05.360', 'LastEditDate': '2014-01-26T14:37:05.360', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13108', 'Tags': '<formal-languages><context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2014-01-24T18:53:40.317', 'FavoriteCount': '4', 'Id': '19946'},22_326:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>When translating an NFA into an equivalent DFA, we can say that all\n  states that contain the final states of NFA, is the final state of\n  DFA.</p>\n</blockquote>\n\n<p>What should my arguments be in order to prove this?</p>\n', 'ViewCount': '76', 'Title': 'NFA to DFA final states proof', 'LastActivityDate': '2014-01-25T14:47:06.420', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13122', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-01-25T13:32:47.600', 'FavoriteCount': '1', 'Id': '19966'},22_327:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '85', 'Title': 'Non determininstic finite state automata', 'LastEditDate': '2014-01-28T06:55:30.370', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'user116317', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Body': '<p>I wanted to construct a NFA over sigma star, where sigma={a,b}, such that at least one of the last 2 symbols is an "a".  I just wanted to make sure that this construction is correct.</p>\n\n<p><img src="http://i.stack.imgur.com/Tusk8.png" alt="State table"></p>\n\n<p><a href="http://i.stack.imgur.com/6zC8W.jpg" rel="nofollow">Original image</a></p>\n', 'ClosedDate': '2014-01-28T08:04:38.627', 'Tags': '<finite-automata><nondeterminism>', 'LastEditorUserId': '1669', 'LastActivityDate': '2014-01-28T06:55:30.370', 'CommentCount': '4', 'CreationDate': '2014-01-28T01:16:36.123', 'Id': '20025'},22_328:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am taking a course in the theory of computation and am trying to understand how to correctly design NFA\'s so that I can transform them into regex. I was wondering if I have Sigma={a,b} and need to design a NFA over Sigma Star that has at least one of its last 2 characters to be an \'a\'; Can I simply start 2 threads, one that will accept \'a\' as the last character and the other will accept \'a\' or \'b\' in the second to last position and \'a\' as the last symbol? Also, the fact that this will be over Sigma Star, would that also mean that I have to have epsilon transitions included in this design?<img src="http://i.stack.imgur.com/LGiyR.jpg" alt="L(A)={w: at least one the last 2 characters of w is an \'a\'}"></p>\n', 'ViewCount': '30', 'ClosedDate': '2014-01-28T17:50:39.120', 'Title': 'Non-deterministic finite state automoton', 'LastEditorUserId': '13175', 'LastActivityDate': '2014-01-29T19:02:16.467', 'LastEditDate': '2014-01-29T19:02:16.467', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<finite-automata><nondeterminism>', 'CreationDate': '2014-01-28T14:15:44.520', 'Id': '20038'},22_329:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $A$ and $B$ be regular languages. Let $C$ be their difference, i.e $C = B \\setminus A$.</p>\n\n<p>Given NFAs for $A$ and $B$, is it possible to directly construct an NFA for $C$ without (implicitly or explicitly) converting them to DFAs first?</p>\n', 'ViewCount': '62', 'Title': 'Direct construction of NFA for the difference of regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-29T02:00:09.690', 'LastEditDate': '2014-01-28T17:51:44.843', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12837', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-01-28T15:45:02.117', 'Id': '20042'},22_330:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assuming we have an automaton that simultaneously accepts a string on two paths. Would this mean that the construction of the NFA might be faulty?  In other words; at the end of any string over any alphabet, does the NFA have to end up accepting one single path only? Or could it accept several at the same time?</p>\n', 'ViewCount': '57', 'ClosedDate': '2014-02-16T18:12:58.687', 'Title': '2 threads accepted at the same time', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-31T09:11:28.767', 'LastEditDate': '2014-01-31T08:26:18.397', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<terminology><automata><finite-automata><nondeterminism>', 'CreationDate': '2014-01-31T00:41:46.270', 'Id': '20136'},22_331:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am new to Automata Theory. I am studying the book thoroughly and understanding it well. I have got a confusion regarding NFA. Why does this automaton accept the empty string \u03bb?</p>\n\n<p><img src="http://i.stack.imgur.com/BV2Eh.jpg" alt="NFA"></p>\n\n<p>What I think is that: implicitly \u03b4(q,\u03bb)=q for all states q. But here also explicitly defined \u03b4(q0,\u03bb)=q2. As there is a walk to the final state using \u03b4(q0,\u03bb)=q0, so \u03b4(q0,\u03bb)=q2 will not be followed. Am I correct?  </p>\n', 'ViewCount': '92', 'Title': 'Why does this automation accept the empty string?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-19T14:49:30.260', 'LastEditDate': '2014-01-31T09:47:25.713', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '20144', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '13053', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-01-31T06:37:15.070', 'Id': '20143'},22_332:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There are two languages,</p>\n\n<p>$\\qquad L_1 = \\{w\\in\\{a,b\\}^*: N_a\\leq N_b\\}$ and<br>\n$\\qquad L_2=\\{w\\in\\{a,b\\}^*: N_b\\leq 2N_a\\}$ </p>\n\n<p>where $N_a$ means the number of occurrences of $a$ in the string $w$. Same for $N_b$.</p>\n\n<p>I've proved that $L_1$ has a DPDA (hope this is right). </p>\n\n<p>Now I want to know whether $L=L_1\\cap L_2$ has a DPDA or not. </p>\n\n<p>I applied the Pumping lemma but it seems like there is no contradiction. I tried to draw the DPDA but failed. Maybe $L$ has a nondeterministic PDA but not a DPDA. However I cannot prove this.</p>\n\n<p>Could anyone give me some hints?</p>\n", 'ViewCount': '79', 'Title': 'How to find a Deterministic PDA for an intersection of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T20:49:59.820', 'LastEditDate': '2014-02-05T08:34:26.133', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21328', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><context-free><automata><pushdown-automata>', 'CreationDate': '2014-02-05T04:09:47.847', 'Id': '21309'},22_333:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is this true? If I change all final states of a given Deterministic Finite Automata to non final states and all non final states to final states then does this new automata represent the complement of the language that was accepted by the original automata?</p>\n\n<p>What if we talk about a Non deterministic finite automata instead of a DFA?</p>\n', 'ViewCount': '81', 'Title': 'Can reversing the final and non-final states of a DFA produce the complement of the original language?', 'LastActivityDate': '2014-02-06T08:29:16.050', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21361', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12845', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-02-06T07:09:39.397', 'Id': '21359'},22_334:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that a DFA has to have exactly one transition for each symbol in the alphabet, but is it allowed to have two symbols on the same arrow? If, for example, I have a DFA with states $q_0$ and $q_1$, can I have one arrow from $q_0$ to $q_1$ with both $a$ and $b$? </p>\n\n<p>This may be a stupid question, but I need to be completely sure that this is allowed (I believe it is).</p>\n', 'ViewCount': '52', 'Title': 'Can a DFA have two symbols on one arrow?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-06T14:46:04.787', 'LastEditDate': '2014-02-06T13:27:53.107', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21374', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2014-02-06T12:51:38.073', 'Id': '21373'},22_335:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My method of conversion is by creating a reachable set tree and each set within the tree would represent the new states. </p>\n\n<p>I have never dealt with FSAs that has 2 or more initial states. How do i create my reachable set tree with two or more states? </p>\n', 'ViewCount': '35', 'Title': 'Non-Deterministic FSA to Deterministic FSA, Two initial states', 'LastActivityDate': '2014-02-07T03:52:52.393', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '21417', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14460', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-07T02:51:06.547', 'Id': '21414'},22_336:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A deterministic queue automaton (DQA) is like a PDA except the stack is replaced by a queue. A queue is a tape allowing symbols to be written (push) on the left-end and read (pull) on the right-end. </p>\n\n<p>Actually I've proved that a 2-tape Turing Machine can simulate the DQA. Now I'm proving the DQA can simulate Turing Machine TM. Let the queue store all the input and the right-end symbol is the one being read. Suppose $a$ is the right-end symbol in the queue. </p>\n\n<p>For the transition $\\delta(q,a)=(r,b,L)$ in TM, it's easy to simulate. Just pull $a$ and push $b$. Now the right-end symbol would be the symbol on the left of $a$. It's like move the head in TM to the left. </p>\n\n<p>My problem is I cannot find a way to simulate the transition $\\delta(q,a)=(r,b,R)$. Since the symbol on the right of $a$ is actually the left-end symbol, how can I let this symbol move to the right-end? I spend several hours on this and I think answers on Internet are not very clear. Could anyone give me some hint? </p>\n", 'ViewCount': '48', 'Title': 'Prove Queue Automaton is equivalent to Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T23:27:53.420', 'LastEditDate': '2014-02-09T22:51:54.143', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21465', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<turing-machines><automata><simulation>', 'CreationDate': '2014-02-09T03:01:35.187', 'Id': '21460'},22_337:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We know algorithm to convert each PDA in the underlying grammar that generates the language the PDA recognize.\nBut we have also the algorithm for creating a two state pda from a grammar. \nThis algorithm use the first state for all the computation, with rules based on the stack and the input symbol, and when the stack is empty goes to a final state.\nThis  means that, for all the generic PDAs we can create a minimal PDA with only two states (and a lot of rules for the first state).\nAm I right?</p>\n', 'ViewCount': '24', 'ClosedDate': '2014-02-10T11:42:10.043', 'Title': 'Are all PDA equivalent to two-state-PDA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-10T11:42:05.793', 'LastEditDate': '2014-02-10T11:42:05.793', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7955', 'Tags': '<automata><pushdown-automata>', 'CreationDate': '2014-02-10T11:02:00.820', 'Id': '21494'},22_338:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>While going through certain problems. it seems that more than one NFA is possible for the given language. Is it so? </p>\n\n<p>For example for drawing: NFA ending with 1 where $\\Sigma=\\{0,1\\}$ is</p>\n\n<p><img src="http://i.stack.imgur.com/dUGPO.png" alt="From Wikipedia page on NFA"></p>\n\n<p>and also we can draw one without 0 from the edge P to P!</p>\n\n<p>Which one should be considered "more" correct?</p>\n', 'ViewCount': '114', 'Title': 'More than one NFA accepting a given language', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T09:03:46.317', 'LastEditDate': '2014-02-11T07:07:42.027', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21516', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-11T01:25:57.827', 'Id': '21515'},22_339:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I saw this old post on stack overflow of a PDA that accepts a language where there are exactly twice as many a\'s as there are b\'s. The image they used is below and so is the link to the post itself.</p>\n\n<p><a href="http://stackoverflow.com/questions/7018113/what-language-does-this-pushdown-automata-pda-accept">PDA for language that accepts twice as many a\'s as b\'s.</a></p>\n\n<p><img src="http://i.stack.imgur.com/BK7Q4.jpg" alt="enter image description here"></p>\n\n<p>It was commented that the PDA was not deterministic. So I\'m wondering what exactly makes a PDA deterministic, for example, would you remove the epsilon transitions here to make it deterministic or what?</p>\n\n<p>If somebody could convert this into a deterministic PDA and explain the steps to do so, I would appreciate it, I\'m pretty lost when it comes to push down automata.</p>\n', 'ViewCount': '80', 'Title': 'Creating a Deterministic Push Down Automata', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-11T17:44:07.337', 'LastEditDate': '2014-02-11T07:08:59.830', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '21523', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13257', 'Tags': '<automata><pushdown-automata><nondeterminism>', 'CreationDate': '2014-02-11T04:35:31.363', 'Id': '21518'},22_340:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to construct NFA for all languages ending in 00.</p>\n\n<p>I got this </p>\n\n<p><img src="http://i.stack.imgur.com/MKW9H.png" alt="enter image description here"></p>\n\n<p>and this</p>\n\n<p><img src="http://i.stack.imgur.com/gSaQO.png" alt="enter image description here"></p>\n\n<p>First one I could convert to DFA by subset construction and I got the correct DFA. For the second one I got the DFA by subset construction, but it is not the correct one since it couldn\'t accept strings like 100.</p>\n\n<p>Is this beacuse, there is no non determinism in the second NFA? Or what is the general rule in drawing an NFA? We could always provide some form of non determinism?</p>\n', 'ViewCount': '56', 'Title': 'Why the given NFA is not possible', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-13T10:12:02.390', 'LastEditDate': '2014-02-13T10:12:02.390', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21588', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-13T02:18:39.663', 'Id': '21586'},22_341:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>given a turing machine M over the input alphabet $\\Sigma $ , any state q of M and a word w $\\epsilon\\Sigma $* , does the computation of M on w visit the state q ?</p>\n\n<p>Is this problem decidable ?</p>\n', 'ViewCount': '55', 'ClosedDate': '2014-02-16T18:36:16.933', 'Title': 'Decidability Problem', 'LastEditorUserId': '12805', 'LastActivityDate': '2014-02-13T17:09:23.360', 'LastEditDate': '2014-02-13T16:56:15.337', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12805', 'Tags': '<turing-machines><automata>', 'CreationDate': '2014-02-13T16:50:35.013', 'Id': '21602'},22_342:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In most (all I have seen) work on cellular automata, the state of a cell is from a finite set. Such as a cell can take value from a binary set, or from among few colors. Can we define the state to be something more complicated such as a function of the coordinates of the neighbor cells? (assuming there is a initial coordinate value give to at least one cell) So for example in 2-D if my neighbor to the left has coordinate $(x,y)$ my state will take a value $f(x,y)$ where $f$ is same for all cells.</p>\n', 'ViewCount': '29', 'Title': 'Does the state of a cell in cellular automata has to be from a finite set?', 'LastActivityDate': '2014-02-14T17:37:20.480', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<automata><cellular-automata>', 'CreationDate': '2014-02-14T17:37:20.480', 'Id': '21638'},22_343:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is a context-free grammar with a single nonterminal symbol S and three terminal symbols +, *, and s:</p>\n\n<p>S -> + S S | * S S| s</p>\n\n<p>My purpose is to build the <a href="http://en.wikipedia.org/wiki/LR_parser#LR_Generator_Analysis" rel="nofollow">LR state machine</a> for this grammar.  My attempt:</p>\n\n<pre><code>[State 0]      -&gt;     [State 1]       -&gt;       [State 2]\nS -&gt; . + S S   (+)    S -&gt; + . S S    (*)      S -&gt; * . S S\nS -&gt; . * S S          S -&gt; . * S S             S -&gt; . + S S //leads to loop\nS -&gt; .s               S -&gt; .s\n</code></pre>\n\n<p>When I get to state 2, I see that an infinite loop begins to form. I think I am missing/misunderstanding part of the algorithm to form the machine. Can you ignore a production if it already exists somewhere else?</p>\n', 'ViewCount': '73', 'Title': 'How to generate the LR(0) finite state machine for a grammar', 'LastEditorUserId': '885', 'LastActivityDate': '2014-03-20T21:49:21.737', 'LastEditDate': '2014-02-18T21:26:56.030', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<automata><formal-grammars>', 'CreationDate': '2014-02-18T16:12:22.957', 'Id': '21774'},22_344:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>While studying automata theory a typical problem that I face is of the following type:</p>\n\n<blockquote>\n  <p>Constructing a DFA with minimum number of states for all strings over\n  $\\{a,b\\}$ which have number of $a$\u2019s divisible by $X$ and number of $b$\u2019s\n  divisible by $Y$ (where $X$ and $Y$ are some positive integer values).</p>\n</blockquote>\n\n<p>Is there some standard way of solving such problems?  </p>\n\n<p>I looked it up over the net and most people seem to have an idea that minimum number of states will be $X \\cdot Y$. I don\'t think that is right. I constructed a DFA with 15 states for $X = 6$ and $Y = 8$.</p>\n\n<p>Also along a similar line suppose the problem is changed slightly and we are \ngiven "number of $a$\'s mod $X$ = $P$ and number of $b$\'s mod $Y$ = $Q$".  </p>\n\n<p>I believe this type of problem will also have a similar solution as the above problem. Only difference will be in the final states of the two machines. Can someone please confirm whether I am right about this? </p>\n', 'ViewCount': '122', 'Title': 'Minimum number of states in DFA for the given language?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T00:21:27.540', 'LastEditDate': '2014-02-19T07:58:35.027', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12845', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-19T07:18:18.303', 'FavoriteCount': '2', 'Id': '21802'},22_345:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Describe a regular language that cannot be accepted by any DFA that has only three states.</p>\n</blockquote>\n\n<p>I'm not really sure where to start on this and was wondering if someone could give me some tips or advice. I understand that the pumping lemma can be used to prove a language is not regular, but in this case, it should be a regular language. If anyone has any thoughts it would be appreciated.</p>\n", 'ViewCount': '512', 'Title': 'Regular language not accepted by DFA having at most three states', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-30T02:24:06.250', 'LastEditDate': '2014-03-29T11:53:14.010', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '14857', 'Tags': '<formal-languages><regular-languages><finite-automata><pumping-lemma>', 'CreationDate': '2014-02-19T22:05:01.387', 'FavoriteCount': '1', 'Id': '21826'},22_346:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '87', 'Title': 'showing that the pair of Finite Automata are equivalent', 'LastEditDate': '2014-02-22T09:48:46.713', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14495', 'FavoriteCount': '1', 'Body': '<p>Here I am trying to show that the pair of Finite Automata are equivalent. I have tried something but I am not sure if I am in the right direction. This is what I have.</p>\n\n<p>These are pairs of FA\'s. Set theory formula in here is <code>(L1\' + L2)\' + (L2\' + L2)\'</code></p>\n\n<p><img src="http://i.stack.imgur.com/pnj9J.png" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/McwoT.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/8mF4g.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/SVpwy.jpg" alt="enter image description here"></p>\n\n<p>Conclusion:</p>\n\n<blockquote>\n  <p>Both machines (FA1\'+FA2)\' and (FA2+FA1)\' has no final states.\n  (FA1\'+FA2)\' to have a final state, the machine (FA1\'+FA2)\' must have\n  no final state. The exact same thing half of the formula. Clearly, if\n  we added these machines together we would get a machine with nine\n  state and no final state. Because there is no final state, it accepts\n  no words and two languages L1 and L2 ar equivalent.</p>\n  \n  <p>So the two regular expressions defame the same language and\n  equivalent.</p>\n</blockquote>\n\n<p>Am I in the right direction ?</p>\n', 'Tags': '<formal-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T09:48:46.713', 'CommentCount': '3', 'AcceptedAnswerId': '21906', 'CreationDate': '2014-02-21T17:58:54.570', 'Id': '21897'},22_347:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Consider a DFA over $a,b$  accepting all strings having number of $a$ 's divible by 6 and number of $b$ 's divisble by 8. What is the minimum number of states in the resultant DFA ?</p>\n</blockquote>\n\n<p>This problem can be solved by assuming 2 DFAs. One accepting the number of $a$ 's divible by 6 and the other accepting with number of $b$ 's divisble by 8. And then taking intersection of them. So what will be the number of states in the resultant DFA?</p>\n\n<p>I tried drawing the DFA accepting all strings having number of $a$ 's divible by 3 and number of $b$ 's divisble by 3, and found it to have 3x3 (9) states. Can I asssume the reuslt to be 48 states for this case? Can it be inferred that the for string accepting number of $a$ 's divible by $m$  and number of $b$ 's divisble by $n$ , there will be $mn$  states? Or I need to draw it by hand? Or anything other? Any subtle hint will be very helpful.</p>\n", 'ViewCount': '59', 'Title': 'What is the possible number of states in the DFA of intersection of two given FA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T09:50:41.753', 'LastEditDate': '2014-02-22T09:50:41.753', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21919', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14933', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-22T06:04:42.697', 'Id': '21918'},22_348:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose $L1, L2$ are both regular languages and $A1, A2$ are their corresponding DFA's.\nHow can I construct a new DFA for the regular language $L1 \\cup L2$?</p>\n", 'ViewCount': '53', 'Title': "Given 2 regular languages and their DFA's, how to construct the DFA of the union?", 'LastActivityDate': '2014-02-24T20:35:30.693', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '22001', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14999', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2014-02-24T20:04:23.093', 'Id': '22000'},22_349:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was going through the text Introduction to Theory of Computation by Michael Sipser. It is written that $R\\circ\\emptyset$ may not equal to $R$. I thought $R\\circ\\emptyset=\\emptyset$ always. $R$ is any regular expression.</p>\n\n<p>Couldnt find any example that contradicts that</p>\n', 'ViewCount': '51', 'Title': 'Why $R\\circ\\emptyset$ is not always equal to $\\emptyset$', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-26T17:00:53.427', 'LastEditDate': '2014-02-26T17:00:53.427', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22013', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><regular-expressions>', 'CreationDate': '2014-02-25T03:50:57.280', 'Id': '22012'},22_350:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '72', 'Title': 'What languages does a (1-way) quantum finite state automata recognize?', 'LastEditDate': '2014-03-03T14:59:28.130', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15077', 'FavoriteCount': '1', 'Body': '<p>Sorry if this is well known, but most of the research is paywalled.</p>\n\n<p>So far I know that it is a subset of the regular languages, but I cannot seem to find any (available) research which pins it down.</p>\n\n<p>Thanks!</p>\n', 'Tags': '<finite-automata><quantum-computing>', 'LastEditorUserId': '15077', 'LastActivityDate': '2014-03-03T14:59:28.130', 'CommentCount': '0', 'AcceptedAnswerId': '22165', 'CreationDate': '2014-02-26T18:59:37.350', 'Id': '22059'},22_351:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Here is the problem:</p>\n\n<p>Prove the single-tape TM that cannot write on the portion of the tape containing the input string recognize only regular language. </p>\n\n<p>My idea is to prove that this particular TM is equivalent to DFA. </p>\n\n<p>Using this TM to simulate DFA is very straightforward. </p>\n\n<p>However, when I want to use this DFA to simulate TM, I encounter the problem. For the TM transition $\\delta(q,a)=(q',a,R)$, DFA can simulate definitely by reading tape to the right and doing the same state transition. </p>\n\n<p>For $\\delta(q,a)=(q',a,L)$, I cannot figure out how to use this DFA or NFA to simulate the left move because the DFA only reads to left and has no stack or something to store.</p>\n\n<p>Should I consider another way? Could anyone give me some hints? Thanks. </p>\n", 'ViewCount': '56', 'Title': 'Prove Single-Tape and Non-write Turing Machine can Only Recognize Regular Language?', 'LastActivityDate': '2014-02-27T06:41:33.020', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><computability><regular-languages><turing-machines><automata>', 'CreationDate': '2014-02-27T06:41:33.020', 'Id': '22082'},22_352:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to find a <code>regular expression</code> and <code>finite automaton</code> that each define $L_1 \\cap L_2$, where $L_1 = (ab^*)^*$ and $L_2 = b(a+b)^*$.</p>\n\n<p>How would I start doing this problem?</p>\n\n<p>So I would draw a FA and when I draw it I would have a complement meaning take anywhere you have a plus, get rid of it and anywhere you didn't have a plus add one in. Am I on the right track?</p>\n", 'ViewCount': '53', 'Title': 'find a regular expression and FA that each define $L_1 \\cap L_2$', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-02T15:56:22.643', 'LastEditDate': '2014-03-02T01:54:43.447', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15179', 'Tags': '<finite-automata><regular-expressions>', 'CreationDate': '2014-03-01T23:21:21.307', 'Id': '22174'},22_353:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Minimizing deterministic finite automata (DFAs) is a problem that has been thoroughly studied in the literature, and several algorithms have been proposed to solve the following problem: \nGiven a DFA $\\mathscr{A}$, compute a corresponding minimal DFA accepting the same language as $\\mathscr{A}$.\nMost of these algorithms run in polynomial time.</p>\n\n<p>However, I wonder whether the decision variant of this problem - "given a DFA $\\mathscr{A}$, is $\\mathscr{A}$ minimal?" - can be solved more efficiently than actually computing the minimal automaton.\nObviously, this can also be done efficiently by running for example <a href="http://en.wikipedia.org/wiki/DFA_minimization#Hopcroft.27s_algorithm">Hopcroft\'s partition-refinement algorithm</a> and then deciding whether all partitions contain precisely one state.</p>\n\n<p>As Yuval Filmus suggests <a href="http://cs.stackexchange.com/a/3046/7486">in his answer</a>, the decidability variant can be solved faster, possibly by using the standard algorithms.\nUnfortunately, I cannot see how (I hope I am not missing an obvious point here).</p>\n\n<p>Yuval points out in the comments here that the best known algorithms (like the one above) run in time $\\mathcal{O}(n \\log n)$ for constant-sized alphabets. Therefore, I am not only interested in asymptotically significant gains in runtime, as these seem rather unlikely. What bothers me most is that I cannot imagine any "shortcut" that might be drawn from the fact that we are only interested in a yes-no-answer - not even a shortcut that allows for saving an asymptotically negligible amount of time. I feel that every sensible algorithm that decides the minimality of a DFA would have to actually minimize the DFA and see if anything changes during the process. </p>\n', 'ViewCount': '121', 'Title': 'How fast can we decide whether a given DFA is minimal?', 'LastEditorUserId': '7486', 'LastActivityDate': '2014-03-02T20:05:21.393', 'LastEditDate': '2014-03-02T18:51:48.217', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<algorithms><formal-languages><finite-automata>', 'CreationDate': '2014-03-02T12:41:01.930', 'FavoriteCount': '2', 'Id': '22191'},22_354:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can we add new words to DFA, maintaining minimality?</p>\n\n<p>Maybe, you can advise some completely different approach to solve the following problem:</p>\n\n<blockquote>\n  <p>A program must process two types of queries:</p>\n  \n  <ol>\n  <li>Add new word to the language.</li>\n  <li>Check if some word of the language occurs in the input string as a substring.</li>\n  </ol>\n  \n  <p>Time and space complexity should be as low as possible.</p>\n</blockquote>\n\n<p>The only solution that I know so far is to rebuild an automaton from scratch every time, using Aho-Corasick algorithm, but, you know, it\'s really-really inefficient.</p>\n\n<p>I\'ve performed some search on Internet and found some papers like <a href="http://acl.ldc.upenn.edu/J/J00/J00-1002.pdf" rel="nofollow">"Incremental Construction of Minimal Acyclic Finite-State Automata"</a>, but, unfortunately, algorithm described there produces and maintains just a minimal trie (not a complete FSM with suffix links, like an automaton produced by Aho-Corasick algo).</p>\n', 'ViewCount': '66', 'Title': 'Adding words to DFA, maintaining minimality', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-03T15:22:33.553', 'LastEditDate': '2014-03-03T10:08:34.447', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8991', 'Tags': '<algorithms><finite-automata>', 'CreationDate': '2014-03-03T10:06:53.027', 'FavoriteCount': '1', 'Id': '22215'},22_355:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am currently reading Introduction to the Theory of Computation (Sipser), and after introducing epsilon labeled transition arrows, the book shows the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/B8lUJ.jpg" alt="enter image description here"></p>\n\n<p>I was following it until I read the following :</p>\n\n<blockquote>\n  <p>Practice with it to satisfy yourself that it accepts the strings \u03f5, a, baba and baa...</p>\n</blockquote>\n\n<p>What does an input string of \u03f5 mean?</p>\n', 'ViewCount': '39', 'Title': 'What does an input string of epsilon mean?', 'LastActivityDate': '2014-03-03T18:43:22.290', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22229', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15239', 'Tags': '<finite-automata>', 'CreationDate': '2014-03-03T18:17:27.267', 'Id': '22227'},22_356:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '101', 'Title': 'Why are pushdown automata countable?', 'LastEditDate': '2014-03-04T19:03:17.140', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13257', 'FavoriteCount': '0', 'Body': '<p>I began a chapter in a textbook on computational theory where they begin to talk about decidable languages. </p>\n\n<p>The problems in this section are pretty confusing and I honestly don\'t know how to begin them because I\'m not 100% on what they mean when they say "countable". </p>\n\n<p>Can anyone help walk me through this problem in the book, that simply states;</p>\n\n<blockquote>\n  <p>Show that the number of push-down automatons is countable.</p>\n</blockquote>\n', 'ClosedDate': '2014-03-06T15:52:04.650', 'Tags': '<terminology><automata><pushdown-automata><uncountability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-04T19:03:17.140', 'CommentCount': '6', 'AcceptedAnswerId': '22265', 'CreationDate': '2014-03-04T03:41:50.343', 'Id': '22255'},22_357:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '42', 'Title': 'If L is a non-regular language over {a}, are all Myhill-Nerode classes singletons?', 'LastEditDate': '2014-03-06T15:55:26.960', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'idannik', 'PostTypeId': '1', 'OwnerUserId': '16112', 'Body': '<p>Is there a non-regular language over unary alphabet $\\{a\\}$ which has a Myhill-Nerode equivalence class that is not a singleton?</p>\n', 'Tags': '<formal-languages><automata>', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-06T15:55:26.960', 'CommentCount': '1', 'AcceptedAnswerId': '22273', 'CreationDate': '2014-01-22T19:28:06.297', 'Id': '22272'},22_358:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm going over some of the pre-requisite math regarding Automata theory, and finite representations.</p>\n\n<p>I read the following:</p>\n\n<p>If \u2211 is a finite alphabet the set of all strings over the alphabet (\u2211*) is <strong>countably infinite</strong>.</p>\n\n<p>The set of all possible languages over an alphabet \u2211 is <strong>uncountably infinite</strong>.</p>\n\n<p>How can the set of languages possible from \u2211 be <strong>uncountably infinite</strong>, yet the possible application of that alphabet to a language be <strong>countably infinite</strong>?</p>\n\n<p>Can I ask those replying to not use too much complex notation, as I'm not a mathematics wizz.</p>\n", 'ViewCount': '18', 'ClosedDate': '2014-03-05T07:08:58.450', 'Title': 'Automata Theory countably and uncountably infinite', 'LastActivityDate': '2014-03-05T01:00:25.613', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15290', 'Tags': '<automata><programming-languages><uncountability>', 'CreationDate': '2014-03-05T01:00:25.613', 'Id': '22285'},22_359:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have few CS textbooks with me which discuss languages, well actually 2 plus old course notes supplied a few years ago. I have been searching the web too any only seem to come up with vague responses just like the text books I have.</p>\n\n<p>My question is about language recognisers verses generators. </p>\n\n<p>I get the overriding principle of a recogniser. That it analyses a language and is able to determine nay or yay if a String belongs to a language.  This is at least what I have picked up from the books and notes. However, it's much more complex than that is it not? A tokenise and syntax analyser  (which I assume to be recognisers) do not just say yes or no, they also ways where don't they...?</p>\n\n<p>However, language generators. No one seems to be very clear about what they are. The typical description I get is  For example Sebasta's Concepts of programming languages says <em>'A language generator is a device that can be used to generate the sentences of a language. We can think of a generator as a push button that produces a sentence of a language every time it is pressed.'</em>  Seriously? That's it?? Your kidding right.... </p>\n\n<p>I read that Regex is an example of a Generator, then why when people talk of generators to they not talk of the inputs. For example Regex has a target String, and the Regex with defines both the accepted alphabet and it's grammar rules.</p>\n\n<p>Can someone provide for me a clearer distinction of what a recogniser is?</p>\n", 'ViewCount': '89', 'Title': 'Language Recognition Devices and Language Generators', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-05T22:24:39.077', 'LastEditDate': '2014-03-05T07:16:31.087', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '22298', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15290', 'Tags': '<formal-languages><terminology><automata>', 'CreationDate': '2014-03-05T02:39:33.337', 'Id': '22288'},22_360:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m looking for formal statements and proofs that I can make when using <a href="http://www.w3.org/TR/scxml/" rel="nofollow">SCXML statecharts</a>. As such, I\'m trying to categorize it properly.</p>\n\n<p>SCXML supports hierarchical states. I believe that any hierarchical state machine can be converted into an equivalent non-hierarchical state machine. And I believe that a "simple" non-hierarchical state machine can be considered a DFA (deterministic finite automata).</p>\n\n<p>SCXML is not a "simple" state machine, however:</p>\n\n<ul>\n<li><p>Transitions between states may be guarded by arbitrary code conditions. Only one transition from an active state will be taken as a result of a single event, but which transition is taken may vary. Given this, I believe that SCXML should be considered (for certain configurations) an <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton" rel="nofollow">NFA</a> (non-deterministic finite automata).</p></li>\n<li><p>Certain transitions may be taken not in response to an event, but as soon as a condition is valid. Given this, I believe that SCXML may at times be considered an <a href="http://en.wikipedia.org/wiki/Nondeterministic_finite_automaton_with_%CE%B5-moves" rel="nofollow">NFA with \u03b5-moves</a>.</p></li>\n<li><p>SCXML supports not just hierarchical states, but also "parallel" (orthogonal) states. These allow the runtime to be in more than one atomic ("leaf") state simultaneously.</p></li>\n</ul>\n\n<p>This last detail gives me pause, as I have not found any formal statements classifying parallel state machines. <strong>Does the introduction of concurrent parallel states break any NFA definition?</strong></p>\n\n<p>I <em>think</em> that it doesn\'t. I <em>think</em> that you can convert any parallel state machine into an equivalent non-parallel machine via combinatorial explosion. But I\'d like to know it for sure.</p>\n', 'ViewCount': '34', 'Title': 'Are statecharts with parallel states NFA, DFA, or none of the above?', 'LastActivityDate': '2014-04-06T05:47:31.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15351', 'Tags': '<automata>', 'CreationDate': '2014-03-06T18:05:23.567', 'Id': '22349'},22_361:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The Chomsky hierarchy is a guideline on language expressive power. The linear feedback shift register is a very interesting "element" to structure a language and there is a large theoretical literature. </p>\n\n<p>In reference to the Chomsky hierarchy (and automata), which is the linear feedback shift register languages/automaton ? </p>\n', 'ViewCount': '23', 'Title': 'In reference to the Chomsky hierarchy (and automatas), Which is the linear feedback shift register Languages/automaton?', 'LastEditorUserId': '6447', 'LastActivityDate': '2014-03-06T21:29:06.013', 'LastEditDate': '2014-03-06T21:29:06.013', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15361', 'Tags': '<formal-languages><automata>', 'CreationDate': '2014-03-06T20:32:54.597', 'Id': '22351'},22_362:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Currently I am studying Turing machines and I understand that a Turing machine can produce all the strings of the language accepted by that particular Turing machine. We call such a Turing machine an <em>enumerator</em>. I have studied the formal definition of enumerators that have no input. But I am unable to realize how a Turing machine can work as an enumerator for the language $L=\\{a^nb^n:n\\geq0\\}$. Any help would be greatly appreciated.</p>\n', 'ViewCount': '142', 'Title': 'How turing machine can be used as enumerator', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-09T00:53:06.260', 'LastEditDate': '2014-03-09T00:48:45.823', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13053', 'Tags': '<turing-machines><automata>', 'CreationDate': '2014-03-08T20:35:14.753', 'Id': '22410'},22_363:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider\n  the language $L = \\{w, w \\in \\{a,b,c\\}^*, n_c(w) = n_a(w) + n_b(w)\\}$, where $n_q(\\omega)$ is defined to be "the number of $p \\in \\omega$.</p>\n\n<p>I have tried a couple of PDA\'s that follow this whole idea of a stack-replacement kind of algorithm, but the reasoning behind it is incorrect. I know it is not the right structure; furthermore, those examples of my previous attempts don\'t really fit in the context of the question that I\'m asking.</p>\n\n<p>There I have a gut feeling that I need to exploit the fact that $0=n_a(w)+n_b(w)-n_c(w)$ but I have absolutely the faintest idea how to do so. When building this kind of "counting machine," what are some design patterns that I can exploit? </p>\n', 'ViewCount': '64', 'Title': 'A NPDA for the language $L = \\{w \\mid w \\in \\{a,b,c\\}^*, n_c(w) = n_a(w) + n_b(w)\\}$', 'LastEditorUserId': '12863', 'LastActivityDate': '2014-03-11T02:53:10.467', 'LastEditDate': '2014-03-11T02:53:10.467', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22414', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12863', 'Tags': '<formal-languages><pushdown-automata><nondeterminism>', 'CreationDate': '2014-03-09T01:16:21.513', 'Id': '22412'},22_364:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In case of algorithm analysis we assume a generic one processor Random Access Machine(RAM). As I know RAM is machine which is no more efficient than the Turing machine.All algorithms can be implemented in the Turing machine.So my question is if Turing machine is equally efficient as RAM, then why we are not assuming Turing machine for algorithm analysis.What is the difference between RAM and TM. </p>\n', 'ViewCount': '55', 'Title': 'What is the difference between RAM and TM', 'LastActivityDate': '2014-03-09T05:55:07.097', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22419', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13053', 'Tags': '<complexity-theory><turing-machines><automata>', 'CreationDate': '2014-03-09T05:42:40.073', 'FavoriteCount': '2', 'Id': '22418'},22_365:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was going through a deterministic PDA that accepts $wcw^R$ (described in Ullman's textbook), in which the last transition is given as $(q_1,\\epsilon, Z_0)\\to(q_2,Z_0)$, where $q_2$ is the final state. </p>\n\n<p>In DFAs we don't consider $\\epsilon$ transitions, while in PDAs we do include them. Why?</p>\n", 'ViewCount': '40', 'Title': 'Why Deterministic PDA accepts $\\epsilon$ input but DFA not', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-10T09:14:56.833', 'LastEditDate': '2014-03-10T02:39:07.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><pushdown-automata><nondeterminism>', 'CreationDate': '2014-03-10T02:06:20.490', 'Id': '22446'},22_366:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '698', 'Title': 'Why is non-determinism useful concept?', 'LastEditDate': '2014-03-11T11:29:18.970', 'AnswerCount': '8', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '13053', 'FavoriteCount': '4', 'Body': '<p>An automaton is an abstract model of a digital computer. Digital computers are completely deterministic; their state at any time is uniquely predictable from the input and the initial state. </p>\n\n<p>When we are trying to model real systems, why include nondeterminism in Automata theory? </p>\n', 'Tags': '<automata><nondeterminism><applied-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T08:53:54.247', 'CommentCount': '5', 'AcceptedAnswerId': '22481', 'CreationDate': '2014-03-10T15:18:44.627', 'Id': '22472'},22_367:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<ol>\n<li><p>In a given cellular automaton, such as Conway\'s Game of Life, is there anything known about how many Garden of Eden patterns there are by pattern size? Say, pattern size is n x n, what\'s the likelihood that a random pattern is a GoE as n increases? </p>\n\n<p>Also, by the Garden of Eden-theorem, only cellular automata which are non-injective, that is, for which a given pattern may have more than one predecessor, contain Gardens of Eden.</p></li>\n<li><p>Is it then in general impossible to see whether a given cellular automaton pattern at some time-step is derived from a GoE (since there could also have been a non-GoE ancestor leading to the same state)? That is, does the evolution of the CA \'wash out\' the information that it is derived from a GoE? (I hope it\'s sufficiently clear what I mean.)</p></li>\n<li><p>Furthermore, is there a relation between GoE-patterns and uncomputability/undecidability? It seems to me that if you consider the CA to be implementing some computation, then the GoEs are \'outputs that could never be produced\', at least heuristically, but a brief Google search led nowhere. Perhaps asked another way, is there a relation between the existence of GoEs and the universality of a CA? I know Life is both universal and has GoEs, but I don\'t know about the general case. Any pointers would be much appreciated.</p></li>\n</ol>\n\n<p>Having done some additional reading, I think I can strike out the third question: since reversible cellular automata that are computationally universal exist (according to <a href="http://en.wikipedia.org/wiki/Reversible_cellular_automaton#Simulation_of_irreversible_automata" rel="nofollow">wiki</a>), there doesn\'t seem to be any connection between computational universality and GoEs. Now, what about universal constructors? Are there reversible universal constructors? Von Neumann\'s original rule happens not to be reversible, and in fact, has GoEs, but again, this need not say much. </p>\n\n<p>The wikipedia page above mentions a way to emulate d dimensional irreversible CAs within d + 1 dimensional reversible ones, which readily establishes the computational universality of the latter, but I\'m not sure if this holds as well for universal construction: the emulated constructor would only construct patterns on a d-dimensional sub-grid of the automaton (?).</p>\n', 'ViewCount': '68', 'Title': 'What is the distribution of Garden of Eden patterns in cellular automata with increasing pattern size?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T10:59:38.620', 'LastEditDate': '2014-04-12T10:59:38.620', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15588', 'Tags': '<automata><cellular-automata>', 'CreationDate': '2014-03-12T07:23:06.393', 'FavoriteCount': '1', 'Id': '22532'},22_368:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '36', 'Title': 'Proving a language is not a regular language but a context free language', 'LastEditDate': '2014-03-17T23:09:15.107', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': "<p>I have the languages $L_1$ and $L_2$ such that $L_1 = \\{a^nba^n :n \\in N\\}$ and $L_2 =\\{a,b\\}^*\\setminus L_1$.</p>\n\n<p>I want to prove that $L_2$ is not a regular language. I know that to prove that $L_2$ is not a regular language I can use the pumping lemma but I'm unsure about the details.</p>\n\n<p>I also want to prove that $L_2$ is a context free language. Do I need a Push Down Automaton that accepts the language to prove that $L_2$ is a context free language? If so, what would this Push-Down Automaton look like?</p>\n", 'ClosedDate': '2014-03-18T07:47:52.957', 'Tags': '<formal-languages><regular-languages><context-free><pushdown-automata>', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-17T23:28:09.877', 'CommentCount': '1', 'AcceptedAnswerId': '22731', 'CreationDate': '2014-03-17T22:36:34.083', 'Id': '22727'},22_369:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read that linear bounded automaton is a Non deterministic Turing machine. Why is it so?</p>\n', 'ViewCount': '25', 'Title': 'Why it is said that LBA is a non deterministic Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:35:08.413', 'LastEditDate': '2014-03-22T11:35:08.413', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22922', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<terminology><turing-machines><automata><nondeterminism><linear-bounded-automata>', 'CreationDate': '2014-03-22T01:05:54.747', 'Id': '22919'},22_370:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read in <a href="https://en.wikipedia.org/wiki/Halting_problem#Common_pitfalls" rel="nofollow">Wikipedia</a> and some other texts that</p>\n\n<blockquote>\n  <p>The halting problem is [...] decidable for <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" rel="nofollow">linear bounded\n  automata</a> (LBAs) [and] deterministic machines with finite memory.</p>\n</blockquote>\n\n<p>But earlier it is written that the halting problem is an undecidable problem and thus TM can\'t solve it! Since LBA are defined as a type of TM, should the same not hold for them?</p>\n', 'ViewCount': '192', 'Title': 'Why is the halting problem decidable for LBA?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-22T13:15:09.093', 'LastEditDate': '2014-03-22T13:15:09.093', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<turing-machines><automata><undecidability><halting-problem><linear-bounded-automata>', 'CreationDate': '2014-03-22T02:06:19.990', 'Id': '22925'},22_371:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to convert Finite Automata into Push Down Automata and I am not sure if I am doing this right. There are not many good tutorials on this topic that I can find, but this is what I have. I am on the right track here ? Does this look ok ?</p>\n\n<p>this is the FA I am trying to convert</p>\n\n<p><img src="http://i.stack.imgur.com/Xib6u.png" alt="enter image description here"></p>\n\n<p>this is what I have</p>\n\n<p><img src="http://i.stack.imgur.com/iWJYx.jpg" alt="enter image description here"></p>\n', 'ViewCount': '47', 'ClosedDate': '2014-04-29T22:41:32.273', 'Title': 'how to convert Finite Automata into Push Down Automata', 'LastActivityDate': '2014-03-23T16:25:21.957', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15179', 'Tags': '<finite-automata><pushdown-automata>', 'CreationDate': '2014-03-23T16:25:21.957', 'Id': '22973'},22_372:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When converting a CFG to a PDA I know that you get three main states, Qstart, Qloop and Qaccept. But Qloops will need a various amount of states, and my question is how many? Is there a way to find out the "worst case scenario" of how many states there can potentially be? I don\'t mean for one particular CFG, but in general. I\'m having difficulties trying to figure out how I can calculate this... </p>\n', 'ViewCount': '62', 'Title': 'How many states when converting CFG to PDA', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T14:40:54.410', 'LastEditDate': '2014-03-24T10:49:04.057', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '22994', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<context-free><automata><formal-grammars><pushdown-automata><simulation>', 'CreationDate': '2014-03-24T09:24:37.833', 'Id': '22992'},22_373:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Are all Deterministic Finite Automatons also Non Deterministic Finite Automatons?</p>\n', 'ViewCount': '70', 'Title': 'Are all DFAs also NFAs?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T21:26:05.983', 'LastEditDate': '2014-03-24T21:26:05.983', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23013', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11684', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2014-03-24T16:52:37.563', 'Id': '23008'},22_374:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is there a way to take the interection of two NPDAs?</p>\n\n<p>I can't seem to find anything that can make that happen, but it seems like the type of thing that is should be relatively trival.</p>\n", 'ViewCount': '54', 'Title': 'Intersection of two NPDAs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T13:43:12.540', 'LastEditDate': '2014-03-26T08:50:40.920', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23057', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '863', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-26T02:34:19.813', 'Id': '23056'},22_375:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '84', 'Title': 'Computing the intersection of two NPDA where it is possible', 'LastEditDate': '2014-03-27T08:34:24.147', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '863', 'FavoriteCount': '1', 'Body': '<p>Apropois to Raphael\'s suggestion on <a href="http://cs.stackexchange.com/questions/23056/intersection-of-two-npdas">Intersection of two NPDAs</a>:</p>\n\n<p>Let $A_1$ and $A_2$ NPDA for context-free languages $L_1$ and $L_2$, respectively. Assuming that we know that $L = L_1 \\cap L_2$ is context-free, can we (effectively) construct NPDA $A$ for $L$?</p>\n\n<p>Any type of algorithm would be acceptable, but the more practical the better.</p>\n', 'Tags': '<computability><automata><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T10:20:05.773', 'CommentCount': '5', 'AcceptedAnswerId': '23587', 'CreationDate': '2014-03-27T01:19:07.693', 'Id': '23111'},22_376:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Could I construct (for some wired reason) a DFA that has a state that is not connected to anything, and it would still be legal?</p>\n\n<p>I'm studying for a test, and I found a question that asks if an infinite DFA could represent a regular language, and I want to use a regular DFA and add all the infinite states not connected to the original. Can I do that?</p>\n", 'ViewCount': '231', 'Title': 'Do all states in a DFA must be connected?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-27T17:49:15.833', 'LastEditDate': '2014-03-27T15:14:26.687', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '23145', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15081', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-03-27T13:47:11.203', 'Id': '23127'},22_377:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was trying to find info about this Finite Automata type FAB (Finite Automata Bowl) and wasn't able to find a lot. It is basically the rules that apply to PDA apply to FAB except you drop the temporal order of the stack. So instead of being restricted to only removing the top symbol of the stack, you can remove any symbol of the bowl.</p>\n\n<p>The question is, does there exist a context-free language that is <em>not</em> accepted by an FAB?</p>\n", 'ViewCount': '57', 'Title': 'What is Finite Automata Bowl?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-31T07:58:15.327', 'LastEditDate': '2014-03-31T07:58:15.327', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16197', 'Tags': '<terminology><reference-request><automata><finite-automata>', 'CreationDate': '2014-03-27T14:56:09.013', 'Id': '23128'},22_378:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It seems like the proof that $A_{DFA}$ is decidable in <a href="http://rads.stackoverflow.com/amzn/click/0534950973" rel="nofollow">Sipser (2nd ed.)</a> assumes the computation will halt... and hence only really proves that $A_{DFA}$ is recognizable. </p>\n\n<p>The language $A_{DFA}$ is defined by $A_{DFA} = \\{\\langle B, w \\rangle \\mid B \\text{ is a } \\mathsf{DFA} \\text{ that accepts input string } w \\}$.</p>\n\n<p>Here is the passage (I\'ve bolded the most relevant sentence):</p>\n\n<blockquote>\n  <p>First, let\'s examine the input $\\langle B, w \\rangle$. It is a representation of a $\\mathsf{DFA}$ $B$ together with a string $w$. One reasonable representation of $B$ is simply a list of its five components, $Q$, $\\Sigma$, $\\delta$, $q_0$, and $F$. When $M$ receives its input, $M$ first determines whether it properly represents a $\\mathsf{DFA}$ $B$ and a string $w$. If not, $M$ rejects.</p>\n  \n  <p>Then $M$ carries out the simulation directly. It keeps track of $B$\'s current state and $B$\'s current position in the input $w$ by writing this information down on its tape. Initially, $B$\'s current state is $q_0$ and $B$\'s current input position is the leftmost symbol of $w$. The states and position are updated according to the specified transition function $\\delta$. <strong>When $M$ finishes processing the last symbol of $w$, $M$ accepts the input if $B$ is in an accepting state; $M$ rejects the input if $B$ is in a nonaccepting state.</strong></p>\n</blockquote>\n\n<p>Am I missing something or is this proof bogus?</p>\n\n<p><strong>EDIT</strong>: Never mind, I think I see my problem. A Turing machine may move back and forth, never halting, but an automaton like $B$ given finite input $w$ finishes after $|w|$ steps, correct? So $M$ does halt. Feel free to post an answer explaining this yourself - I don\'t want anyone to miss out on a chance to answer by me deleting the question. If no one responds within a day, I\'ll post an answer myself.</p>\n', 'ViewCount': '35', 'Title': 'Proof that $A_{DFA}$ is decidable in Sipser', 'LastEditorUserId': '12588', 'LastActivityDate': '2014-03-29T18:56:59.760', 'LastEditDate': '2014-03-29T18:56:59.760', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23226', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<formal-languages><finite-automata><undecidability>', 'CreationDate': '2014-03-29T18:04:51.747', 'Id': '23225'},22_379:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to prove that a language is not $\\omega$-regular. </p>\n\n<p>The language I\'m working with can be defined as:</p>\n\n<p>$$L = \\{ a_1 \\dots a_n x^\\omega ~ | ~ n &gt; 0, a_1 \\dots a_n \\in L^\\prime \\}$$</p>\n\n<p>where $L^\\prime$ is a specific non regular language (I omit the definition $L^\\prime$ because I think it is of no help for my problem), $a_i$ are symbols in $L^\\prime$ alphabet and $x$ is any symbol not in $L^\\prime$ alphabet.</p>\n\n<p>I\'m aware of several proof techniques for proving a language is not regular (see e.g. <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a> ). </p>\n\n<p>Are there similar proof techniques for proving that a language is not $\\omega$-regular?</p>\n', 'ViewCount': '54', 'Title': u'Proving that the continuation of a non-regular language is not \u03c9-regular', 'LastEditorUserId': '14441', 'LastActivityDate': '2014-03-29T23:41:34.323', 'LastEditDate': '2014-03-29T23:41:34.323', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '23235', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14441', 'Tags': '<formal-languages><regular-languages><proof-techniques><buchi-automata>', 'CreationDate': '2014-03-29T18:56:27.080', 'Id': '23227'},22_380:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Every proof I can find of this result is by way of regular expressions. Is there any "constructive" proof that defines the corresponding DFA (probably NFA)? For instance the proof of concatenation closure is most often presented by demonstrating the NFA. I\'m just curious whether this is out there somewhere</p>\n', 'ViewCount': '162', 'Title': 'Does there exist a proof of closure of regular languages under regular substitution by giving the corresponding DFA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-10T06:27:44.253', 'LastEditDate': '2014-03-31T08:21:05.427', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '23623', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><reference-request><finite-automata><closure-properties>', 'CreationDate': '2014-03-30T17:15:21.897', 'Id': '23265'},22_381:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to figure out a reduction to prove $W[1]$-hardness for this, but I am having significant trouble. Here is the problem:</p>\n\n<p><strong>Bag Automaton</strong>: \nA non deterministic finite state automaton $M=(Q,I,s,F,d)$. $Q$ is the set of states, $I$ is the set of items, $s\\in Q$ is the start state, $F\\subseteq Q$ is the set of accepting states, $d\\subseteq Q\\times 2^I\\times Q\\times 2^I$ is the set of transitions, where $2^I$ is the set of all subsets of $I$. \nA computation of a Bag Automaton starts in $s$, with given item set $I' \\subseteq I$. At each step the bag automaton in state $q$ and associated item set  $I^* \\subseteq I$ does a state transition $(q,A,q',B)$, $A\\subseteq I^*$, which sets the state to $q'$ and the bag automaton's item set to $(I'-A) \\cup B $. $M$ accepts if there is a sequence of transitions from $s$ to an $f \\in F$.</p>\n\n<p><strong>Bag Automaton Computation</strong>\nInput: A Bag Automaton $M=(Q,I,s,F,d)$, a set $I' \\subseteq I$ and a positive integer $k$.</p>\n\n<p>Parameters: $k$</p>\n\n<p>Question: Can $M$ accept on $I'$ by executing at most $k$ transitions?</p>\n\n<p>I am almost certain a reduction from clique where the initial bag contains all vertices will work, but I cannot figure out how to formalize it.</p>\n", 'ViewCount': '51', 'Title': 'Reduction from clique to bag automata', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-01T15:00:21.597', 'LastEditDate': '2014-04-01T15:00:21.597', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '16079', 'Tags': '<complexity-theory><automata><reductions><parametrized-complexity>', 'CreationDate': '2014-03-31T00:46:42.120', 'Id': '23276'},22_382:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $P$ be a deterministic PDA recognizing a deterministic CFL with a binary alphabet. Modify $P$ to identify its <em>reading states</em> (denote this subset of states by $R$) in accordance with the construction in Theorem 2.42 in Sipser (3$^{rd}$ edition only) for complementing DPDA. The final states of $P$ are $F\\subset R$, and $\\overline{P}$ recognizing the complement language is given by the same DPDA, but with final states $R-F$. </p>\n\n<p>Combine this with the construction in Lemma 2.59 showing that every DPDA recognizing an end-marked language has an equivalent DCFG. Modify $P$ to have a new accept state $q_\\mbox{accept}$. If $P$ enters a state in $F$ after reading the endmarker, it empties its stack and goes to $q_\\mbox{accept}$. Now do the same with $R-F$ and a new sink state $q_\\mbox{reject}$. </p>\n\n<p>In the grammar $G$ we have a start variable $A_{q_0q_\\mbox{accept}}$ which generates every string that takes $P$ from $q_0$ to $q_\\mbox{accept}$ with empty stack. Let $\\overline{G}$ be a copy of $G$, without renaming the variables, but replace the start state with $A_{q_0q_\\mbox{reject}}$. Then these grammars are both deterministic, and generate complement languages with respect to the portion of the string preceding the endmarker.</p>\n\n<p>Why do this? I think we can show DCFLs with binary alphabets are closed under substitution with an endmarked language and its complement using such a grammar. I think this is not in general the case as otherwise the resulting grammar with substitutions may have a forced handle in the production rules of both substituted grammars. Consider for example the language $\\{w\\mid w\\in\\{0,1\\}^*,\\#_0(w)=\\#_1(w)\\}$. Every string in this language can be extended to one in the complement and vice versa, so there must be strings for which both grammars would be able to match a handle based on just some initial portion of the string. Using the grammar construction described above, there will never be more than one forced handle, and every string will resolve to one of the start symbols. </p>\n\n<p>If this is a legitimate way to construct the complementary grammars, the very restricted closure result follows easily from the determinism of the grammars involved. Can anyone poke some holes in this?   </p>\n', 'ViewCount': '35', 'Title': 'A construction to show a very restricted substitution closure result for DCFLs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T07:42:25.793', 'LastEditDate': '2014-04-01T07:42:25.793', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-31T08:17:43.793', 'Id': '23288'},22_383:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a homework question about the properties (decidability, Turing-recognizability, etc.) of the language </p>\n\n<p>$$ L = \\{ \\langle M \\rangle | \\text{$M$ is a TM and $M$ accepts some string $w$ which has 101 as a prefix} \\}. $$</p>\n\n<p>I have made an attempt at showing decidability of $L$:</p>\n\n<p>On input $\\langle M, w\\rangle$ (where $M$ is a TM and $w \\in \\sigma^*$):</p>\n\n<ol>\n<li>Simulate $M$ on $w$.</li>\n<li>If $M$ rejects and halts, reject. If $M$ accepts and halts, accept.</li>\n</ol>\n\n<p>However, I'm not sure about moving forward after this. I do not want a solution, but I want some ideas/techniques as to what else I can prove about $L$. </p>\n", 'ViewCount': '85', 'Title': 'The language of TMs accepting some word starting with 101', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-31T23:14:21.683', 'LastEditDate': '2014-03-31T22:38:24.807', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16332', 'Tags': '<complexity-theory><formal-languages><turing-machines><automata>', 'CreationDate': '2014-03-31T21:27:37.883', 'Id': '23300'},22_384:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><img src="http://i.stack.imgur.com/lSvI9.png" alt="enter image description here"></p>\n\n<p>Is this state machine a moore machine or a mealy machine? I am confused because the states have outputs and the transitions have output based on the input. I tried making a state table but I think its wrong. Can anyone provide the state machine?</p>\n', 'ViewCount': '44', 'Title': 'How to read edge labels like "01, 1" on a state diagram?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T08:46:59.387', 'LastEditDate': '2014-04-02T08:46:59.387', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23333', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2014-04-01T23:43:25.007', 'Id': '23329'},22_385:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '385', 'Title': 'how to draw a complement of a Turing Machine?', 'LastEditDate': '2014-04-03T06:35:15.050', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '14495', 'FavoriteCount': '1', 'Body': '<p>I am now pretty confident on how I would turn something into a Turing Machine. Now my question is how do you convert TM into a complement of a Turing Machine. From what I can remember in Finite Automata, complementing it you would just turn a start state into a ending state, also if you have an ending state you would make it into a start state..How would you do complement of a Turing Machine ? </p>\n\n<p>For example here I have a simple TM of a Palindrome and I want a Palindrome\'</p>\n\n<p><img src="http://i.stack.imgur.com/x3TEH.png" alt="enter image description here"></p>\n', 'Tags': '<turing-machines><automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-03T17:05:24.023', 'CommentCount': '5', 'AcceptedAnswerId': '23378', 'CreationDate': '2014-04-02T23:50:40.633', 'Id': '23375'},22_386:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let A = $(Q, \\Sigma, \\delta, S, F)$ be a deterministic finite automaton associated with the language \n$L \\subseteq \\Sigma^*$ </p>\n\n<blockquote>\n  <p>$L' = \\{y \\in \\Sigma^*:\\exists x\\in L. |x| = |y|\\}$ </p>\n  \n  <p>$L \\subseteq L'$</p>\n</blockquote>\n\n<p>How do I show that there exist a NDFA associated with L' ? </p>\n", 'ViewCount': '35', 'Title': 'NDFA associated with language L', 'LastActivityDate': '2014-04-06T10:16:11.893', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16431', 'Tags': '<regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2014-04-04T01:31:52.257', 'Id': '23407'},22_387:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '200', 'Title': "I need clarification about DFA's and DFA acceptable languages", 'LastEditDate': '2014-04-05T19:38:55.520', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '16480', 'FavoriteCount': '1', 'Body': "<p>In class yesterday we went over DFA's and DFA acceptable languages.  An example of a language that is not DFA acceptable was given as $\\{ ab, aabb, aaabbb, aaaabbbb, \\ldots \\}$.  The reason given was that the machine would need an infinite amount of states.  </p>\n\n<p>But wouldn't a simple DFA that has only one state that is a final state and loops back to itself on all inputs accept that language?  </p>\n\n<p>Also in class we discussed how the complement of a DFA acceptable language is also DFA acceptable simply by swapping the final states and the non-final states.  But if you had the language $L = \\{ a \\}$, over the alphabet $\\{ a, b \\}$, then obviously $L$ is DFA acceptable, but the complement of $L$ is $\\{ a, b \\}^* - \\{ a \\}$, which includes $\\{ ab, aabb, aaabbb, \\ldots \\}$.</p>\n\n<p>I think I must be misunderstanding something crucial here.  </p>\n", 'Tags': '<formal-languages><finite-automata>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-12T19:46:34.000', 'CommentCount': '4', 'AcceptedAnswerId': '23470', 'CreationDate': '2014-04-05T18:34:32.793', 'Id': '23460'},22_388:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I having trouble constructing NPDAs for these two languages:</p>\n\n<p>$L_1 = \\{a^nb^m \\mid 2n \\le m \\le 3n\\}$</p>\n\n<p>$L_2 = \\{a^nb^mc^k \\mid n = m \\: or \\: m \\ne k\\}$</p>\n\n<p>Would these be the proper states for the first one?  </p>\n\n<ul>\n<li>$q_0$ \u2013 reading $a$\u2019s (initial state)  </li>\n<li>$q_1$ \u2013 reading $b$\u2019s and popping $A$\u2019s  </li>\n<li>$q_2$ \u2013 reading $b$\u2019s  </li>\n<li>$q_f$ \u2013 \ufb01nal state </li>\n</ul>\n\n<p>Would these be the proper states for the second one?  </p>\n\n<ul>\n<li>$q_0$ \u2013 reading $a$\u2019s (initial state) </li>\n<li>$q_1$ \u2013 reading $b$\u2019s and popping $A$\u2019s  </li>\n<li>$q_2$ \u2013 reading $b$\u2019s and pushing $B$\u2019s    </li>\n<li>$q_3$ \u2013 reading $c$\u2019s  </li>\n<li>$q_f$ \u2013 \ufb01nal state  </li>\n</ul>\n\n<p>How would I go from here? Any help would be appreciated.</p>\n', 'ViewCount': '50', 'Title': 'Constructing nondeterministic pushdown automata', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-08T14:54:27.627', 'LastEditDate': '2014-04-08T14:54:27.627', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16554', 'Tags': '<automata><finite-automata><pushdown-automata>', 'CreationDate': '2014-04-08T13:55:34.987', 'Id': '23551'},22_389:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Does anyone know any good introductions to Formal Language theory and Formal Grammar, that cover the mathematical basis of Syntax and things like context free grammars and pushdown automata. In particular, I\'d like to be able to understand:</p>\n\n<p>-Parikh\u2019s theorem</p>\n\n<p>-Pentus\' proof that Lambek-calculus grammars define only context-free stringsets</p>\n\n<p>-the theorem of Chandra, Kozen and Stockmeyer</p>\n\n<p>-B\xfbchi\u2019s theorem and Doner\u2019s theorem</p>\n\n<p>Geoffrey Pullum\'s review <a href="http://www.lel.ed.ac.uk/~gpullum/Rev_Kracht.pdf" rel="nofollow">http://www.lel.ed.ac.uk/~gpullum/Rev_Kracht.pdf</a> has put me off reading a book called "The Mathematics of Language" by Markus Kracht, since I am not sure I have the required level of mathematical maturity. He writes:</p>\n\n<p>"Readers of The Mathematical Intelligencer will probably get on with it well enough, but others should be warned that Kracht assumes a lot of mathematical sophistication: graduate students whose first degree is in humanities or social science may experience symbol shock. Kracht does not pamper those who crave intuitive presentations. He will not explain that a finite automaton accepts exactly those strings on which there is a run beginning in the start state and ending in a final state; he will expect you to see that immediately when he tells you (on p.96) that $L(A) = \\{x \\colon~ \\delta(\\{i_0\\},x)\\cap F \\neq \\emptyset\\}$."</p>\n\n<p>The review has also put me off several other introductions:</p>\n\n<p>"W. J. M. Levelt\u2019s truly excellent 3-volume 1974 textbook [6] had remarkably wide coverage (Lev- elt\u2019s psycholinguistic interests lead him to cover work on \u2018learnability\u2019, also known as grammar induction, which Kracht does not touch on), but sadly has long been out of print. And the standard text by Partee, ter Meulen and Wall [9] is now more than fifteen years behind the leading edge of research, especially with respect to grammars and automata. (Though it was published in 1990, the Partee el al. volume reports as open the question of whether the complement of a context-sensitive stringset is always context-sensitive, which was settled in the affirmative in 1987, at Partee\u2019s insti- tution!) Though strong on formal semantics, it completely misses important topics in other areas (parsing and computational complexity, for example), and it looks positively fusty beside Kracht\u2019s much more up-to-date and considerably more mathematical book."</p>\n\n<p>So I\'d be grateful to hear if there are any introductions to this field which people can recommend.</p>\n', 'ViewCount': '62', 'Title': 'Good introductions to Formal Language Theory and Formal Grammars', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-08T23:10:13.477', 'LastEditDate': '2014-04-08T23:10:13.477', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16562', 'Tags': '<formal-languages><context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2014-04-08T18:09:27.717', 'Id': '23557'},22_390:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have always had a hard time making sense of infinities.     </p>\n\n<p>Example: the language $L = \\{ \\epsilon , 01, 0011, 000111, 00001111, ... \\}$ is not DFA acceptable because a machine capable of accepting it would require an infinite amount of states.  </p>\n\n<p>I can draw a DFA with ellipses in the middle to represent it's expansion.  I can prove that: </p>\n\n<p>For all strings x in L, using a machine M = mentioned DFA, under some finite expansion, I can accept all strings y in L, such that $|y| \\leq |x|$ and such that M has $|x| + 2$ states and such that all strings in compliment(L) are not accepted by M.</p>\n\n<p>All of those machines are finite.  </p>\n\n<p>The problem that prevents me from making the leap to claim that L is then DFA acceptable, is that I need to prove that there exists a largest string in L, but there is no largest string in L.</p>\n\n<p>Anyways, I know this sounds stupid because knowing what is proven about convergence and divergence, I should be able to make mathematical sense of this.  The problem is that no matter how much I know about infinity, I still do not think that what is said about convergence and divergence seems logical.  I always have this feeling that something is wrong.  </p>\n\n<p>So I guess I just wonder how I can look at it so that it makes more sense. </p>\n\n<p>In short, when a DFA needs a state for each character of a string in order to accept the string, and the language is an infinite set of strings whose enumeration could be represented as a sequence of strings increasing in length, how is it that a DFA needs an infinite amount of states to accept all of those strings, given each string is finite?</p>\n", 'ViewCount': '122', 'Title': 'Help me resolve my doubts about infinities, exemplified by an example of non DFA acceptable language', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-09T19:07:25.167', 'LastEditDate': '2014-04-09T13:26:57.210', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Tyson', 'PostTypeId': '1', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-04-09T04:55:45.693', 'FavoriteCount': '1', 'Id': '23583'},22_391:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working on making patterns for a digital lava lamp (essentially, making interesting patterns using a 4x10 grid), and I\'ve been looking into cellular automata. I tried implementing some variations on <a href="http://en.wikipedia.org/wiki/Langton%27s_ant" rel="nofollow" title="Langton\'s Ant">Langton\'s Ant</a> but it tends to loop in very boring ways. Does anyone have any suggestions for interesting automata on small boards?</p>\n\n<p>The lamp I\'m working on can be played with <a href="http://tryion.lava.io/" rel="nofollow">here</a>.</p>\n\n<p>Any suggestions on a more appropriate place to post this question are welcome.</p>\n\n<p>EDIT: By interesting, I mean patterns that work well on small boards. For example, \nLangton\'s Ant was not interesting because it always tended to find some static state over such a small board.</p>\n', 'ViewCount': '36', 'Title': 'Cellular Automata Using Small Boards', 'LastEditorUserId': '16663', 'LastActivityDate': '2014-04-12T20:50:33.153', 'LastEditDate': '2014-04-12T20:50:33.153', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16663', 'Tags': '<automata><cellular-automata>', 'CreationDate': '2014-04-10T21:08:12.633', 'Id': '23658'},22_392:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In my first lecture of "Theory of Automata", after giving some concepts of Alphabet, Language, transition function etc. and a couple of simple automata of an electric circuit with one and two switches, is this question.</p>\n\n<p><img src="http://i.stack.imgur.com/WIYoO.png" alt="enter image description here"></p>\n\n<p>I understand what an Alphabet as well as the Language of a DFA is, but are there any rules or steps to followed to reach a correct automaton for a given Language? Or we just have to imagine and think in our mind and get to a solution which satisfies the given Language?</p>\n\n<p>Note:- Please keep your language as simple as you can, since this is my first lecture and I am not yet aware of concepts like regular expressions or any other thing in the subject for that matter.</p>\n', 'ViewCount': '73', 'Title': 'Are there any steps or rules to draw a DFA?', 'LastActivityDate': '2014-04-12T11:19:47.723', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23699', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16703', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-04-12T07:41:22.240', 'Id': '23694'},22_393:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How would I go about making a Turing machine to accept the following language L?</p>\n\n<p>$$L = \\{ www \\mid w = \\{0,1\\}^* \\text{ and } w &gt; 0\\}$$</p>\n\n<p>I was thinking counting the number of symbols in the input string and then dividing by three to find the beginning of each instance of <em>w</em> and then testing if each instance is the same, but this seems a bit roundabout. </p>\n\n<p>I feel like there is a way by marking the first three symbols and then moving the 2nd and 3rd markers until the strings in between them are the same but I'm having a hard time articulating this into an algorithm.</p>\n\n<p>Can anyone point me in the right direction?</p>\n", 'ViewCount': '45', 'Title': 'Turing machine with repeated strings', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T10:19:18.573', 'LastEditDate': '2014-04-29T10:19:18.573', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24214', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14950', 'Tags': '<formal-languages><turing-machines><automata><strings>', 'CreationDate': '2014-04-28T13:35:58.237', 'Id': '24184'},22_394:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working on a paper and would like to review the origins of <a href="http://en.wikipedia.org/wiki/Kleene_star">Kleene\'s closure</a>. I am unable to find any article of Kleene\'s that has the original definition of the Kleene closure.</p>\n\n<p>Is there a paper by Kleene in which he first defines the Kleene closure?</p>\n', 'ViewCount': '74', 'Title': 'Where/when did Stephen Kleene first define the Kleene closure/star?', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-04-30T07:25:55.133', 'LastEditDate': '2014-04-30T07:25:55.133', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '17192', 'Tags': '<formal-languages><reference-request><automata>', 'CreationDate': '2014-04-29T21:40:11.143', 'Id': '24237'},22_395:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am relatively new to the pumping lemma, and I have a problem here that I think I answered correctly, can anyone tell me if this works and if not why not </p>\n\n<p>The problem: $L=\\{www \\mid w \\in  \\{a,b\\}^*\\}$ </p>\n\n<p>My approach: </p>\n\n<p>take a string $www$ </p>\n\n<p>$u^* (v^k)^* w$ has to be a word in $L$ </p>\n\n<p>now let\'s split $www$ into $xyz$<br>\nso that $w_1=x, w_2=y,$ and $w_3=z$</p>\n\n<p>I then decide to say that x should be able to to "loop" twice\n$(x)^*(y^2)^*(z) = xyyz =wwww$ </p>\n\n<p>$wwww$ is not part of the language $www$ and therefore not regular</p>\n\n<p>Edit: Well my according to my understanding the pumping lemma by taking the "test string" we are looking at and splitting it into a portion that stays the same follow by a portion that is repeatable and then lastly another portion that remains the same. In my "approach" I took the test string "www" and split it into x,y, and z each respectively holding a single "w", with y being the repeatable section and the other two being the ones that remain the same. I double the y section and end up with a resulting xyyz which translates to wwww which appears as if it is not a part of the language www. I have a good feeling that I am wrong because of the condition "w is {a,b}<em>" which I think includes the empty string, and since the empty string is viable in the languages that accept wwww and www with the condition "w is {a,b}</em>" my pumping lemma is faulty. I would just like to know what I would have to do to tackle such a problem, its just a practice problem </p>\n', 'ViewCount': '48', 'ClosedDate': '2014-04-30T17:36:06.393', 'Title': 'Pumping Lemma Problem?', 'LastEditorUserId': '17221', 'LastActivityDate': '2014-05-01T17:17:44.297', 'LastEditDate': '2014-05-01T17:17:44.297', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17221', 'Tags': '<finite-automata><pumping-lemma>', 'CreationDate': '2014-04-30T15:38:50.900', 'Id': '24260'},22_396:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given an automaton and an alphabet $\\{a, b\\} $,  and the language accepted by the automaton is $ab^*$. </p>\n\n<p>Such an automata can be found here:</p>\n\n<p><img src="http://i.stack.imgur.com/Vmutm.gif" alt="an automaton"></p>\n\n<p>My question is: this automaton cannot process the word $ba$ for example. In general,  do automata have to be able to process any word?</p>\n', 'ViewCount': '24', 'Title': 'Automata with no transition for some character', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-05-03T08:54:03.733', 'LastEditDate': '2014-05-03T08:54:03.733', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '24350', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17296', 'Tags': '<finite-automata>', 'CreationDate': '2014-05-03T08:07:09.610', 'Id': '24345'}