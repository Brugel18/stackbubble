{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Cormen talks briefly about the advantages of picking a random pivot in quicksort.  However as pointed out <a href="http://algoviz.org/OpenDSA/Books/OpenDSA/html/Quicksort.html" rel="nofollow">here</a>(4th to the last paragraph):</p>\n\n<blockquote>\n  <p>Using a random number generator to choose the positions is relatively\n  expensive</p>\n</blockquote>\n\n<p>So how is picking a random pivot actually implemented in practice, and how random is it?  It can\'t be too expensive, since from what I understand one of quicksort\'s main advantages over other $\\cal{O}(n \\lg n)$ sorts is the small constant factors, and spending allot of cycles picking pivots would undermine that advantage.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>As an example, the <code>C</code> code from "<a href="http://www.catonmat.net/blog/three-beautiful-quicksorts/" rel="nofollow">Three Beautiful Quicksorts</a>" actually calls the <code>C</code> library <code>rand</code> function:</p>\n\n<pre><code>int randint(int l, int u) {\n    return rand()%(u-l+1)+l;\n}\n\nvoid quicksort(int l, int u) {\n    int i, m;\n    if (l &gt;= u) return;\n    swap(l, randint(l, u));\n    m = l;\n    for (i = l+1; i &lt;= u; i++)\n        if (x[i] &lt; x[l])\n            swap(++m, i);\n    swap(l, m);\n    quicksort(l, m-1);\n    quicksort(m+1, u);\n}\n</code></pre>\n\n<p>While the pivot picking code here is clearly $\\cal{O}(1)$, it would seem that the hidden $c$ here is relatively high.</p>\n', 'ViewCount': '207', 'Title': 'From Whence the Randomization in Randomized Quicksort', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T09:45:57.250', 'LastEditDate': '2013-04-21T14:02:28.190', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '11387', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<algorithms><randomized-algorithms><quicksort>', 'CreationDate': '2013-04-18T18:04:50.873', 'Id': '11385'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '5058', 'Title': 'Quicksort Partitioning: Hoare vs. Lomuto', 'LastEditDate': '2013-04-21T15:09:19.573', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '6728', 'FavoriteCount': '4', 'Body': '<p>There are two quicksort partition methods mentioned in Cormen:</p>\n\n<pre><code>Hoare-Partition(A, p, r)\nx = A[p]\ni = p - 1\nj = r + 1\nwhile true\n    repeat\n        j = j - 1\n    until A[j] &lt;= x\n    repeat\n        i = i + 1\n    until A[i] &gt;= x\n    if i &lt; j\n        swap( A[i], A[j] )\n    else\n        return j\n</code></pre>\n\n<p>and:</p>\n\n<pre><code>Lomuto-Partition(A, p, r)\nx = A[r]\ni = p - 1\nfor j = p to r - 1\n    if A[j] &lt;= x\n        i = i + 1\n        swap( A[i], A[j] )\nswap( A[i +1], A[r] )\nreturn i + 1\n</code></pre>\n\n<p>Disregarding the method of choosing the pivot, in what situations is one preferable to the other?  I know for instance that Lomuto preforms relatively poorly when there is a high percentage of duplicate values ( i.e. where say more than 2/3rds the array is the same value ), where as Hoare performs just fine in that situation.</p>\n\n<p>What other special cases make one partition method significant better than the other?</p>\n', 'Tags': '<algorithms><sorting><quicksort>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-25T07:17:36.723', 'CommentCount': '2', 'AcceptedAnswerId': '11550', 'CreationDate': '2013-04-21T08:02:32.013', 'Id': '11458'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am having problems understanding a basic concept in CLRS, it is about worst case partitioning during quicksort -- </p>\n\n<blockquote>\n  <p>The worst-case behavior for quicksort occurs when the partitioning routine produces one subproblem with $n \u2212 1$ elements and one with $0$ elements.</p>\n</blockquote>\n\n<p>What does it mean by subproblem of size $0$? But what I see is there will be two subproblems, one with size $n-1$ and another with size $1$. I fail to grasp the idea of $0$ size. </p>\n\n<p>Can someone explain?</p>\n', 'ViewCount': '68', 'Title': 'what does it mean by problem of size $0$?', 'LastActivityDate': '2013-07-03T22:24:22.237', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13073', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7678', 'Tags': '<algorithms><quicksort>', 'CreationDate': '2013-07-03T22:19:08.847', 'Id': '13072'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been looking for a quick and easy explanation on Quick Select and stumbled upon <a href="http://www.youtube.com/watch?v=1vrdZiVmqno" rel="nofollow">this</a>. It\'s quick and easy to follow, but there\'s a part which I am not following quite well:</p>\n\n<p>The uploader is sorting the following array using the 4th smallest element</p>\n\n<p>2 6 5 1 4 9 3, pivot is 2 and last element is 3</p>\n\n<p>We rearrange, the array is now:</p>\n\n<p>2 1 5 6 4 9 3, 5 is greater than 3 so we swap them</p>\n\n<p>2 1 3 6 4 9 5</p>\n\n<p>We go to n/2 and see the right half.</p>\n\n<p>6 4 9 5, pivot is 5</p>\n\n<p>Then the sub-array is rearranged as follows:</p>\n\n<p>4 5 6 9</p>\n\n<p>Shouldn\'t this be 4 5 9 6?</p>\n\n<p>Or is it just putting and shifting?</p>\n', 'ViewCount': '59', 'Title': 'Quick Select explanation', 'LastEditorUserId': '10398', 'LastActivityDate': '2013-10-27T08:38:55.293', 'LastEditDate': '2013-10-27T08:38:55.293', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<sorting><quicksort>', 'CreationDate': '2013-10-26T20:15:34.240', 'Id': '16453'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So given a input of lets say 10 strings, what way can we input these so we get the best or worst case for these two given sorts?</p>\n\n<pre><code>Heap sort:\nbest case - nlogn\nworst case - nlogn\n\nQuick sort:\nbest case - nlogn\nworst case - n^2\n</code></pre>\n\n<p>Where i get confused on these two is:</p>\n\n<p>heap- Since the best and worst case are the same does it not matter the input order? The number of comparisons and assignments will always be the same? I imagine in a heap sort it may be the same since the real work is done in the insertion, but the sorting only uses the removal of the max/min heap? Is that why?</p>\n\n<p>quick sort- This one I don't know for sure. I'm not sure what the best case and worst case situations are for this. If its a already sorted list of 10 strings for example wouldn't we always have to choose the same amount of pivots to get complete the recursive algorithm? Any help on this explanation would really help.</p>\n\n<p>Thanks</p>\n", 'ViewCount': '2076', 'Title': 'Best and worse case inputs for heap sort and quick sort?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-13T07:41:27.657', 'LastEditDate': '2013-12-13T07:41:27.657', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'OwnerDisplayName': 'user3037172', 'PostTypeId': '1', 'Tags': '<algorithm-analysis><runtime-analysis><sorting><quicksort>', 'CreationDate': '2013-11-26T16:04:07.403', 'Id': '18945'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it possible to use a sorting algorithm with a non-transitive comparison, and if yes, why is transitivity listed as a requirement for sorting comparators?</p>\n\n<p>Background:</p>\n\n<ul>\n<li><p><em>A sorting algorithm generally sorts the elements of a\nlist according to a comparator function C(x,y), with</em></p>\n\n<p>\\begin{array}{ll} C(x,y) = \\begin{cases}\n    -1  &amp; {\\text{if}}\\ x\\prec y   \\\\ 0 &amp; {\\text{if}}\\ x\\sim y \\\\ \n    +1 &amp; {\\text{if}}\\ x\\succ y  \\\\ \\end{cases} \\end{array}</p>\n\n<p><em>The requirements for this comparator are, as far as I\nunderstand them:</em></p>\n\n<ul>\n<li><em>reflexive:</em> $\\forall x: C(x,x)=0$ </li>\n<li><em>antisymmetric:</em> $\\forall x,y: C(x,y) = - C(y,x)$ </li>\n<li><em>transitive:</em> $\\forall x,y,z, a: C(x,y)=a \\land C(y,z)=a \\Rightarrow C(x,z)=a$</li>\n<li><em>C(x,y) is defined for all x and y, and the results depend only on x and y</em></li>\n</ul>\n\n<p><em>(These requirements are always listed differently accross different\nimplementations, so I am not sure I got them all right)</em></p></li>\n</ul>\n\n<p>Now I am wondering about a "tolerant" comparator function, that accepts numbers x,y as similar if$ |x - y| \\le 1$:\n\\begin{array}{ll}\nC(x,y) = \\begin{cases}\n-1  &amp; {\\text{if}}\\ x\\lt y-1   \\\\\n0 &amp; {\\text{if}}\\ |x - y| \\le 1 \\\\ \n+1 &amp; {\\text{if}}\\ x\\gt y+1  \\\\\n\\end{cases}\n\\end{array}</p>\n\n<p>Examples: both <code>[ 1, 2, 3, 4, 5]</code> and <code>[1, 4, 3, 2, 5]</code> are correctly sorted  in ascending order according to the tolerant comparator ($C(x,y) \\le 0$ if x comes before y in the list)<br>\nbut <code>[1, 4, 2, 3, 5]</code> is not, since C(4,2)=1</p>\n\n<p>This tolerant comparator is reflexive and antisymmetric, but not transitive.</p>\n\n<p>i.e. C(1,2) = 0 , c(2,3) = 0, but C(1,3) = -1, violating transitivity</p>\n\n<p>Yet I cannot think of any sorting algorithm that would fail to produce a "correctly sorted" output when given this comparator and a random list.</p>\n\n<p>Is transitivity therefore not required in this case? And is there a less strict version of transitivity that <em>is</em> required for the sorting to work?</p>\n\n<p>Related questions:</p>\n\n<ul>\n<li><a href="http://math.stackexchange.com/q/276907/34541">Why is antisymmetry necessary for comparison sort?</a> (about antisymmetry)</li>\n<li><a href="http://cs.stackexchange.com/q/2336/2932">Sorting algorithms which accept a random comparator</a> (about a random C(x,y))</li>\n<li><a href="http://stackoverflow.com/q/20363810/145999">OrderBy with a non-transitive IComparer</a> (about the c# sort algorithm, by me)</li>\n</ul>\n', 'ViewCount': '234', 'Title': 'Is transitivity required for a sorting algorithm', 'LastActivityDate': '2014-02-12T23:38:27.540', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2932', 'Tags': '<algorithms><sorting><quicksort><transitivity>', 'CreationDate': '2013-12-15T17:19:24.000', 'Id': '19013'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's have an array where first half are of value 50 and the second half 100. What would be the asymptotic performance when sorting using Quicksort.</p>\n\n<p>I think it it should be $O(n^2)$ as for array of same elements the complexity is $O(n^2)$ and this particular problem could be rewritten as sorting the first half + sorting the second hald $O(2*(\\frac{n}{2})^2 + n)$ which is still $O(n^2)$.</p>\n\n<p>But my schoolmates claim it should be $O(n log(n))$.. so which one is correct?</p>\n", 'ViewCount': '87', 'LastEditorDisplayName': 'user12779', 'Title': "Quicksort's asymptotic performance for array of [50,...,50,100,...100]", 'LastActivityDate': '2014-01-29T21:37:14.940', 'LastEditDate': '2014-01-12T18:30:54.990', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user12779', 'PostTypeId': '1', 'Tags': '<algorithms><asymptotics><performance><quicksort>', 'CreationDate': '2014-01-12T18:18:39.200', 'Id': '19675'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '248', 'Title': 'QuickSort Dijkstra 3-Way Partitioning: why the extra swapping?', 'LastEditDate': '2014-03-18T10:08:54.497', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15391', 'FavoriteCount': '1', 'Body': u'<p><img src="http://i.stack.imgur.com/qeA2F.png" alt="Algorithm"></p>\n\n<p>Given the algorithm above (taken from the <a href="https://d396qusza40orc.cloudfront.net/algs4partI/slides/23Quicksort.pdf" rel="nofollow">slides</a> (p. 35) of the <a href="http://coursera.org" rel="nofollow">Coursera</a> course \u201cAlgorithms Part I\u201d by Robert Sedgewick and Kevin Wayne), look at the scenario where i is at "X", the following happens:</p>\n\n<p><strong>Scenario:</strong> i -> "X", "X" > "P"</p>\n\n<pre><code>1. swap("X", "Z"), gt--;   // the value at i is now "Z", which is still &gt; "P"\n2. swap("Z", "Y"), gt--;   // the value at i is now "Y", which is still &gt; "P"\n3. swap("Y", "C"), gt--;    // Now we finally get a value at i "C" which is &lt; "P"\n// Now we can swap values at i and lt, and increrement them\n4. swap("P", "C"), i++, lt++;\n</code></pre>\n\n<p>Why don\'t we just decrement gt until gt points to a value that is &lt; the value at lt ("P" in this case), then we swap this value with the value at i. This will save swapping operations.</p>\n\n<p>So if we do that for the scenario mentioned above, we\'ll do:</p>\n\n<pre><code>1. gt--\n2. gt--\n3. swap("X", "C"), gt--;   \n// Now we can swap values at i and lt, and increrement them\n4. swap("P", "C"), i++, lt++;\n</code></pre>\n\n<p>Is this excessive swapping needed for the algorithm? does it improve performance in some way?\nIf it does improve performance, how? </p>\n\n<p>If it doesn\'t affect performance, please give a proper explanation or a proof as to why this it does not affect performance. </p>\n\n<p>Also, would the second method I mentioned affect performance in any way? please explain why.</p>\n\n<p>P.S. "Affect performance" as used above means either improve/degrade performance.</p>\n', 'Tags': '<algorithms><sorting><quicksort>', 'LastEditorUserId': '133', 'LastActivityDate': '2014-03-24T05:53:55.407', 'CommentCount': '7', 'AcceptedAnswerId': '22395', 'CreationDate': '2014-03-08T05:27:19.077', 'Id': '22389'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '874', 'Title': 'Why is Quicksort described as "in-place" if the sublists take up quite a bit of memory? Surely only something like bubble sort is in-place?', 'LastEditDate': '2014-03-14T09:28:19.193', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '15572', 'FavoriteCount': '2', 'Body': '<p>Quicksort is described as "in-place" but using an implementation such as:</p>\n\n<pre><code>def sort(array):\n    less = []\n    equal = []\n    greater = []\n    if len(array) &gt; 1:\n        pivot = array[0]\n        for x in array:\n            if x &lt; pivot:\n                less.append(x)\n            if x == pivot:\n                equal.append(x)\n            if x &gt; pivot:\n                greater.append(x)\n        return sort(less) + equal + sort(greater)\n    else:\n        return array\n</code></pre>\n\n<p>You have to create a copy of the list for each recursion. By the first return, in memory we have:</p>\n\n<ul>\n<li>array</li>\n<li>greater+equal+less</li>\n</ul>\n\n<p>Then by the second recursion across all sub-lists we have:</p>\n\n<ul>\n<li>array</li>\n<li>greater, equal, less from first recursion</li>\n<li>greater+equal+less from less1, greater+equal+less from greater1</li>\n</ul>\n\n<p>etc...</p>\n\n<p>Is this just badly written code or am I correct in thinking that for a big list, you actually have to have, proportionally, a fair amount of extra space to store thse?</p>\n\n<p>When I think of something that is "in-place", I think of bubble sort, which simply swaps elements in the list like: <a href="http://en.wikipedia.org/wiki/File:Bubble-sort-example-300px.gif">http://en.wikipedia.org/wiki/File:Bubble-sort-example-300px.gif</a></p>\n\n<p>BubbleSort only requires 1 extra variable to store a potentially swapped element.</p>\n', 'Tags': '<algorithms><sorting><quicksort>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-14T11:57:21.597', 'CommentCount': '2', 'AcceptedAnswerId': '22517', 'CreationDate': '2014-03-11T22:51:08.497', 'Id': '22516'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As a programmer with non CS background, I am learning algorithms.</p>\n\n<p>When explaining the performance of quicksort in an <a href="http://www.amazon.de/Algorithms-Robert-Sedgewick/dp/032157351X/ref=sr_1_1?ie=UTF8&amp;qid=1394794069&amp;sr=8-1&amp;keywords=algorithm" rel="nofollow">Algorithm book</a> and also elsewhere on the web, I do not see any reference to the time/space needed for shuffling. I <em>do</em> understand that shuffling is important to have the $O(n\\log n)$ performance, but shuffling itself would have a complexity of $O(n)$. Why does this become irrelevant in the total performance?</p>\n', 'ViewCount': '165', 'Title': 'Performance impact due to time required for shuffling in Quicksort', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-03T22:02:32.870', 'LastEditDate': '2014-04-03T22:02:32.870', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23394', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16409', 'Tags': '<time-complexity><runtime-analysis><quicksort>', 'CreationDate': '2014-04-03T09:34:36.643', 'Id': '23387'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '41', 'Title': 'Dual-pivot Quicksort reference implementation?', 'LastEditDate': '2014-04-25T06:56:55.333', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7533', 'FavoriteCount': '2', 'Body': "<p>Has some sort of canonical - or reference - implementation of Dual-pivot Quicksort been posted anywhere?</p>\n\n<p>I would like to include that algorithm in a comparison among sorting algorithms for a specialized need that I have, but the Java versions I've seen appear to have various kinds of tweaks applied to them, like using Insertion Sort for small (sub-) arrays, which makes it harder to compare the fundamentals.</p>\n", 'Tags': '<algorithms><reference-request><sorting><quicksort>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-25T09:18:42.890', 'CommentCount': '7', 'AcceptedAnswerId': '24099', 'CreationDate': '2014-04-25T00:47:08.157', 'Id': '24092'}