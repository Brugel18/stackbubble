{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3821', 'Title': 'Language theoretic comparison of LL and LR grammars', 'LastEditDate': '2013-06-06T14:05:27.163', 'AnswerCount': '1', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '13', 'Body': '<p>People often say that <a href="https://en.wikipedia.org/wiki/LR_parser">LR(k)</a> parsers are more powerful than <a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a> parsers. These statements are vague most of the time; in particular, should we compare the classes for a fixed $k$ or the union over all $k$? So how is the situation really? In particular, I am interested in how LL(*) fits in.</p>\n\n<p>As far as I know, the respective sets of grammars LL and LR parsers accept are orthogonal, so let us talk about the languages generated by the respective sets of grammars. Let $LR(k)$ denote the class of languages generated by grammars that can be parsed by an $LR(k)$ parser, and similar for other classes.</p>\n\n<p>I am interested in the following relations:</p>\n\n<ul>\n<li>$LL(k) \\overset{?}{\\subseteq} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{\\subseteq} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{=} LL(*)$</li>\n<li>$LL(*) \\overset{?}{\\circ} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n</ul>\n\n<p>Some of these are probably easy; my goal is to collect a "complete" comparison. References are appreciated.</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T14:05:27.163', 'CommentCount': '2', 'AcceptedAnswerId': '48', 'CreationDate': '2012-03-07T00:32:31.947', 'Id': '43'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>EPAL, the language of even palindromes, is defined as the language generated by the following unambiguous context-free grammar:</p>\n\n<blockquote>\n  <p>$S \\rightarrow a a$</p>\n  \n  <p>$S \\rightarrow b b$</p>\n  \n  <p>$S \\rightarrow a S a$</p>\n  \n  <p>$S \\rightarrow b S b$</p>\n</blockquote>\n\n<p>EPAL is the 'bane' of many parsing algorithms: I have yet to encounter any parsing algorithm for unambiguous CFGs that can parse any grammar describing the language. It is often used to show that there are unambiguous CFGs that cannot be parsed by a particular parser. This inspired my question:</p>\n\n<blockquote>\n  <p>Is there some parsing algorithm accepting only unambiguous CFGs that works on EPAL?</p>\n</blockquote>\n\n<p>Of course, one can design an ad-hoc two-pass parser for the grammar that parses the language in linear time. I'm interested in parsing methods that have not been designed specifically with EPAL in mind.</p>\n", 'ViewCount': '150', 'Title': 'Is there any nongeneral CFG parsing algorithm that recognises EPAL?', 'LastActivityDate': '2013-01-24T01:25:28.517', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '141', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<formal-languages><formal-grammars><parsers>', 'CreationDate': '2012-03-07T16:56:52.460', 'FavoriteCount': '0', 'Id': '102'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '188', 'Title': 'Parsing arbitrary context-free grammars, mostly short snippets', 'LastEditDate': '2012-03-12T17:43:05.270', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '2', 'Body': "<p>I want to parse user-defined domain specific languages. These languages are typically close to mathematical notations (I am not parsing a natural language). Users define their DSL in a BNF notation, like this:</p>\n\n<pre><code>expr ::= LiteralInteger\n       | ( expr )\n       | expr + expr\n       | expr * expr\n</code></pre>\n\n<p>Input like <code>1 + ( 2 * 3 )</code> must be accepted, while input like <code>1 +</code> must be rejected as incorrect, and input like <code>1 + 2 * 3</code> must be rejected as ambiguous.</p>\n\n<p>My parser must work on any context-free grammar, even ambiguous ones, and must accept all unambiguous input. I need the parse tree for all accepted input. For invalid or ambiguous input, I ideally want good error messages, but to start with I'll take what I can get.</p>\n\n<p>I will typically invoke the parser on relatively short inputs, with the occasional longer input. So the asymptotically faster algorithm may not be the best choice. I would like to optimize for a distribution of around 80% inputs less than 20 symbols long, 19% between 20 and 50 symbols, and 1% rare longer inputs. Speed for invalid inputs is not a major concern. Furthermore, I expect a modification of the DSL around every 1000 to 100000 inputs; I can spend a couple of seconds preprocessing my grammar, not a couple of minutes.</p>\n\n<p>What parsing algorithm(s) should I investigate, given my typical input sizes? Should error reporting be a factor in my selection, or should I concentrate on parsing unambiguous inputs and possibly run a completely separate, slower parser to provide error feedback?</p>\n", 'Tags': '<formal-languages><parsers><compilers>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-24T01:22:22.403', 'CommentCount': '9', 'AcceptedAnswerId': '237', 'CreationDate': '2012-03-12T11:27:50.537', 'Id': '234'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><em>Originally <a href="http://math.stackexchange.com/questions/22614/help-understand-texthandle-in-parsing-problem">http://math.stackexchange.com/questions/22614/help-understand-texthandle-in-parsing-problem</a> but unaswered there</em></p>\n\n<p>The BNF is defined as followed:</p>\n\n<pre><code>S -&gt; aAb | bBA \nA -&gt; ab | aAB\nB -&gt; bB | b\n</code></pre>\n\n<p>The sentence is:</p>\n\n<pre><code>aaAbBb\n</code></pre>\n\n<p>And this is the parse tree:\n<img src="http://i.stack.imgur.com/gpdeo.png" alt="enter image description here"></p>\n\n<p><strong>Phrases:</strong> aaAbBb, aAbB, bB<br>\n<strong>Simple Phrases:</strong> bB<br>\n<strong>Handle:</strong> ?    </p>\n\n<p>From the book, <code>handle</code> is defined as followed:\n<code>B</code> is the handle of the right sentential from $y = aBw$ if and only if:<br>\n$S \\to_{rm} \\cdot aAw \\to_{rm} aBw$</p>\n\n<p>So in my case, what\'s the handle? Any idea?  </p>\n', 'ViewCount': '213', 'Title': 'Understanding $\\text{handle}$ in parsing problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-29T12:53:46.907', 'LastEditDate': '2012-06-29T12:53:46.907', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<formal-languages><compilers><parsers>', 'CreationDate': '2012-03-13T06:36:58.727', 'Id': '290'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm working on a parser for a C-style language, and for that parser I need the regular expression that matches C-style /**/ comments. Now, I've found this expression on the web:</p>\n\n<pre><code>/\\*([^\\*]*\\*+[^\\*/])*([^\\*]*\\*+|[^\\*]*\\*/\n</code></pre>\n\n<p>However, as you can see, this is a rather messy expression, and I have no idea whether it actually matches exactly what I want it to match.</p>\n\n<p>Is there a different way of (rigorously) defining regular expressions that are easy to check by hand that they are really correct, and are then convertible ('compilable') to the above regular expression?</p>\n", 'ViewCount': '845', 'Title': 'Deriving the regular expression for C-style /**/ comments', 'LastEditorUserId': '95', 'LastActivityDate': '2013-03-20T16:37:17.823', 'LastEditDate': '2012-03-13T21:36:26.030', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '312', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<compilers><parsers><regular-languages>', 'CreationDate': '2012-03-13T14:00:00.143', 'Id': '311'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '730', 'Title': 'Why is using a lexer/parser on binary data so wrong?', 'LastEditDate': '2012-03-30T17:39:36.810', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '0', 'Body': '<p>I often work with <a href="http://en.wikipedia.org/wiki/Lexical_analysis" rel="nofollow">lexer</a>/<a href="http://en.wikipedia.org/wiki/Parsing" rel="nofollow">parsers</a>, as opposed to a parser combinator and see people who never took a class in parsing, ask about parsing binary data. Typically the data is not only binary but also context sensitive. This basically leads to having only one type of token, a token for byte.  </p>\n\n<p>Can someone explain why parsing binary data with a lexer/parser is so wrong with enough clarity for a CS student who hasn\'t taken a parsing class, but with a footing on theory?</p>\n', 'Tags': '<programming-languages><compilers><parsers>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-04T18:24:18.923', 'CommentCount': '18', 'AcceptedAnswerId': '901', 'CreationDate': '2012-03-30T11:37:54.867', 'Id': '899'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '271', 'Title': 'From the LR(1) parsing table, can we deduce that it is also an LALR and SLR table?', 'LastEditDate': '2012-04-02T04:47:34.390', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Jatin', 'PostTypeId': '1', 'OwnerUserId': '949', 'Body': '<p>There is this question I read somewhere but could not answer myself.</p>\n\n<p>Assume I have an LR(1) Parsing table. Is there any way that just by looking at it and its items, can I deduce that it is also a table for LALR and SLR?</p>\n', 'Tags': '<compilers><parsers>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-02T04:47:34.390', 'CommentCount': '2', 'AcceptedAnswerId': '940', 'CreationDate': '2012-04-01T05:39:31.193', 'Id': '938'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have to write a grammar for Pascal, and there is just one thing that is causing problems. </p>\n\n<p>Lets say we have operators (sorted by priority from low to high):</p>\n\n<ol>\n<li><em>Postfix <code>^</code></em>.</li>\n<li><em>Prefix <code>^</code></em>.</li>\n<li><em><code>[ ]</code></em>, and <code>.</code>, (same priority and left associative).</li>\n<li>The only terminal is <code>id</code>, which is any lowercase letter.</li>\n</ol>\n\n<p>Now let's say that an expression is:</p>\n\n<ol>\n<li>Any id.</li>\n<li>Any expression with the <em>Postfix <code>^</code></em> operator.</li>\n<li>Any expression with the <em>Prefix <code>^</code></em> operator.</li>\n<li>Any expression with <code>.</code> followed by <code>id</code>.</li>\n<li>Any expression with <code>[</code> and another expression and <code>]</code>.</li>\n</ol>\n\n<p>Now I would like to know how can I make a LALR grammar without shift-reduce and reduce-reduce conflicts, OR if that can't be done how can I prove that it can't be done.</p>\n\n<p>Some examples:</p>\n\n<pre><code>good:\na.b.c.d               \na.b^.c\n^a.b^\na.b^^[c]^^.d.e        \n^^a.b^.d.e^[]\n\nbad:\na.^b.c\n</code></pre>\n\n<p>Without the prefix <code>^</code>, this problem is easy to solve, but the prefix sign keeps getting me. Can anyone help? My solutions so far:</p>\n\n<pre><code>// this works without the prefix but it does not produce a.b^.c which is wrong.\nA ::= B | A ^ ;\nB ::= C | ^ B ;\nC ::= id | C [ A ] | C . id;\n</code></pre>\n\n<p>So I thought that the prefix can only occur before the first dot, and between dots, there can only be a postfix <code>^</code> and brackets. So I came up with this:</p>\n\n<pre><code>A ::= B | A ^ ;\nB ::= C | ^ B ;\nC ::= id | C [ A ] |id D;\nD ::= id E;\nF ::= E | F ^;\nE ::= id | F . id;\n</code></pre>\n\n<p>But this causes 3 conflicts.</p>\n", 'ViewCount': '367', 'Title': 'reduce reduce and shift reduce error in LALR grammar', 'LastEditorUserId': '12', 'LastActivityDate': '2012-04-05T07:15:43.883', 'LastEditDate': '2012-04-05T04:28:13.693', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'zidarsk8', 'PostTypeId': '1', 'OwnerUserId': '936', 'Tags': '<programming-languages><parsers><formal-grammars>', 'CreationDate': '2012-04-04T08:40:53.177', 'Id': '1029'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to convert a user entered regular expression into an NFA so that I can then run the NFA against a string for matching purposes. What is the minimum machine that can be used to parse regular expresssions? </p>\n\n<p>I assume it must be a push down automaton because the presense of brackets means the need to count and a DFA/NFA cannot perform arbitrary counting. Is this assumption correct? For example, the expression a(bc*)d would require a PDA so that the sub-expression in brackets is handled correctly.</p>\n', 'ViewCount': '549', 'Title': 'Does the language of Regular Expressions need a push down automata to parse it?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-22T07:41:16.970', 'LastEditDate': '2012-05-20T12:32:09.750', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1434', 'Tags': '<formal-languages><parsers><regular-expressions><pushdown-automata>', 'CreationDate': '2012-05-20T03:26:18.503', 'FavoriteCount': '3', 'Id': '1939'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given a <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="nofollow">parsing expression grammar</a> (PEG) grammar and the name of the start production, I would like to label each node with the set of characters that can follow it.  I would be happy with a good approximation that is conservative -- if a character can follow a node then it must appear in the follower set.</p>\n\n<p>The grammar is represented as a tree of named productions whose bodies contain nodes representing</p>\n\n<ol>\n<li>Character</li>\n<li>Concatenation</li>\n<li>Union</li>\n<li>Non-terminal references</li>\n</ol>\n\n<p>So given a grammar in ABNF style syntax:</p>\n\n<pre><code>A := B (\'a\' | \'b\');\nB := (\'c\' | \'d\') (B | ());\n</code></pre>\n\n<p>where adjacent nodes are concatenated, <code>|</code> indicates union, single quoted characters match the character they represent, and upper case names are non-terminals.</p>\n\n<p>If the grammar\'s start production is <code>A</code>, the annotated version might look like</p>\n\n<pre><code>A := \n  (\n    (B /* [ab] */)\n    (\n      (\'a\' /* eof */)\n    | \n      (\'b\' /* eof */)\n    /* eof */\n    )\n  /* eof */\n  );\n\nB :=\n  (\n    (\n      (\'c\' /* [abcd] */)\n      |\n      (\'d\' /* [abcd] */)\n    /* [abcd] */\n    )\n    (\n      (B /* [ab] */)\n      |\n      ( /* [ab] */)\n    /* [ab] */\n    )\n  );\n</code></pre>\n\n<p>I want this so that I can do some simplification on a PEG grammar.  Since order is important in unions in PEG grammars, I want to partition the members of unions based on which ones could accept the same character so that I can ignore order between partition elements.</p>\n\n<p>I\'m using OMeta\'s grow-the-seed scheme for handling direct left-recursion in PEG grammars, so I need something that handles that.  I expect that any scheme for handling scannerless CF grammars with order-independent unions that is conservative or correct would be conservative for my purposes.</p>\n\n<p>Pointers to algorithms or source code would be much appreciated.</p>\n', 'ViewCount': '87', 'Title': 'Computing follow sets conservatively for a PEG grammar', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-16T18:02:43.013', 'LastEditDate': '2012-06-09T18:04:51.030', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '2297', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><reference-request><formal-grammars><parsers>', 'CreationDate': '2012-06-08T21:42:44.733', 'Id': '2292'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3538', 'Title': 'Left recursion and left factoring -- which one goes first?', 'LastEditDate': '2014-01-23T17:17:37.047', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '2', 'Body': '<p>if I have a grammar having a production that contains both left recursion and left factoring like </p>\n\n<p>$\\qquad \\displaystyle F \\to FBa \\mid cDS \\mid c$ </p>\n\n<p>which one has priority, left recursion or left factoring?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:37.047', 'CommentCount': '3', 'AcceptedAnswerId': '2720', 'CreationDate': '2012-07-11T16:32:10.717', 'Id': '2696'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '880', 'Title': 'Are regular expressions $LR(k)$?', 'LastEditDate': '2012-07-18T00:50:56.043', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'Andrea Tucci', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '1', 'Body': '<p>If I have a Type 3 Grammar, it can be represented on a pushdown automaton (without doing any operation on the stack) so I can represent regular expressions by using context free languages. But can I know if a type 3 grammar is $LR(1)$, $LL(1)$, $SLR(1)$, etc. without constructing any parse tables?</p>\n', 'Tags': '<formal-languages><regular-languages><formal-grammars><parsers><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T00:50:56.043', 'CommentCount': '0', 'AcceptedAnswerId': '2715', 'CreationDate': '2012-07-11T12:26:59.840', 'Id': '2713'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/LR_parser#LR_and_Other_Kinds_of_Parsers">the Wikipedia article</a>, the L in $LR(k)$ means "left-to-right scan", and the "R" means "rightmost derivation."  However, in <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf">Knuth\'s original paper on $LR(k)$ grammars</a>, he defines $LR(k)$ (on page 610) as a language that is "translatable from left to right with bound $k$."</p>\n\n<p>I am guessing that this new terminology was chosen to complement $LL(k)$ parsing\'s "left-to-right scan, leftmost derivation."  That said, I don\'t know when the terminology changed meaning.</p>\n\n<p>Does anyone know where the newer acronym for $LR(k)$ comes from?</p>\n', 'ViewCount': '115', 'Title': 'When did $LR(k)$ acquire the meaning "left-to-right scan, rightmost derivation?"', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:09:46.040', 'LastEditDate': '2012-07-17T22:09:46.040', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><reference-request><terminology><formal-grammars><parsers>', 'CreationDate': '2012-07-17T19:10:32.620', 'FavoriteCount': '1', 'Id': '2791'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have the grammar: </p>\n\n<p>$\\qquad \\begin{align}\n S &amp;\\to S = P \\mid S \\neq P \\mid P  \\\\\n P &amp;\\to NUM\n\\end{align}$</p>\n\n<p>This grammar suffers from left recursion. To eliminate left recursion, I got: </p>\n\n<p>$\\qquad \\begin{align}\n S &amp;\\to PS' \\\\\n S' &amp;\\to\\, = PS' \\mid\\, \\neq PS' \\mid \\varepsilon \\\\\n P &amp;\\to NUM\n\\end{align}$</p>\n\n<p>However when constructing the LL(1) parsing table, it turns out the grammar is ambiguous. Is there a way to disambiguate the grammar without changing the generated language, or did I make a mistake somewhere?</p>\n\n<p>This is my work so far: </p>\n\n<pre><code>Non-terminal Nullable First            Follow\nS            False    NUM              $\n    S'           True     !=, ==, epsilon  $\nP            False    NUM              $, ==, !=\n\nParse Table\n     !=       ==    NUM      $\nS                   -&gt;PS'\nS'  -&gt;!=PS'  -&gt;==PS'        -&gt;epsilon\nP                   -&gt;NUM\n</code></pre>\n", 'ViewCount': '270', 'Title': 'Is this grammar ambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-16T22:57:05.150', 'LastEditDate': '2012-07-17T22:44:58.257', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'OwnerDisplayName': 'barq', 'PostTypeId': '1', 'Tags': '<formal-grammars><parsers><ambiguity>', 'CreationDate': '2012-05-17T22:56:12.917', 'Id': '2794'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<h3>Abstract problem description</h3>\n\n<p>The way I see it, unparsing means to create a token stream from an AST, which when parsed again produces an equal AST, i.e. <code>parse(unparse(AST)) = AST</code> should hold.  </p>\n\n<p>This is the equal to finding a valid parse tree which would produce the same AST. </p>\n\n<p>The language is described by a context free S-attributed grammar using a eBNF variant. </p>\n\n<p>So the unparser has to find a valid \'path\' through the traversed nodes in which all grammar constraints hold. This bascially means to find a valid allocation of AST nodes to grammar production rules. This is a constraint satisfaction problem (CSP) in general and could be solved, like parsing, by backtracking in $O(e^n)$. </p>\n\n<p>Fortunately for parsing, this can be done in $O(n^3)$ using GLR (or better restricting the grammar). Because the AST structure is so close to the grammar production rule structure, I was really surprised seeing an implementation where the runtime is worse than parsing: XText uses ANTLR for parsing and backtracking for unparsing. </p>\n\n<h3>Questions</h3>\n\n<ol>\n<li>Is a context free S-attribute grammar everything a parser and unparser need to share or are there further constraints, e.g. on the parsing technique / parser implementation?</li>\n<li>I\'ve got the feeling this problem isn\'t $O(e^n)$ in general -- could some genius help me with this?</li>\n</ol>\n\n<p>I didn\'t receive an answer for this question on <a href="http://stackoverflow.com/questions/11918961/unparse-ast-oexpn">StackOverflow</a>. It was suggested to ask here, but I hate redundancy, so I hope you forgive me for asking you to <a href="http://stackoverflow.com/questions/11918961/unparse-ast-oexpn">answer here</a>. </p>\n', 'ViewCount': '148', 'Title': 'Can abstract syntax trees be unparsed in subexponential time?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-12-24T19:05:30.280', 'LastEditDate': '2012-12-23T05:26:29.457', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2465', 'Tags': '<algorithms><compilers><parsers>', 'CreationDate': '2012-08-16T21:52:15.340', 'FavoriteCount': '1', 'Id': '3233'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>I tried to find a simple example for a language that is not parseable with an LL(1) parser. I finally found this language.</p>\n\n<p>$$L=\\{a^nb^m|n,m\\in\\mathbb N\\land n\\ge m\\}$$</p>\n\n<p>Is my hypothesis true or is this language parseable with an LL(1) parser?</p>\n\n<p>One can use this simple grammar to describe $L$ (of course it is isn't LL(1) parseable):</p>\n\n<pre><code>S -&gt; \u03b5\nS -&gt; A\nA -&gt; aA\nA -&gt; aAb\nA -&gt; a\nA -&gt; ab\n</code></pre>\n", 'ViewCount': '604', 'Title': 'Is this language LL(1) parseable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-29T09:51:17.570', 'LastEditDate': '2012-08-28T23:14:02.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '3359', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<formal-languages><formal-grammars><context-free><parsers>', 'CreationDate': '2012-08-28T12:40:52.453', 'Id': '3350'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I try to teach myself the usage of bison. The manpage bison(1) says about bison:</p>\n\n<blockquote>\n  <p>Generate a deterministic LR or generalized LR (GLR) parser employing LALR(1), IELR(1), or canonical LR(1) parser tables.</p>\n</blockquote>\n\n<p>What is an IELR-parser? All relevant articles I found on the world wide web are paywalled.</p>\n', 'ViewCount': '372', 'Title': 'What is an IELR(1)-parser?', 'LastEditorUserId': '3094', 'LastActivityDate': '2013-06-27T08:08:03.550', 'LastEditDate': '2012-12-05T12:26:17.283', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<formal-languages><terminology><formal-grammars><parsers>', 'CreationDate': '2012-09-07T15:07:37.423', 'FavoriteCount': '1', 'Id': '3461'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>I have a homework assignment where I need to convert a grammar into LL(1). I've already removed the left recursion, but I'm having trouble doing left-factoring. All of the examples I've found are simple, and look something like this:</p>\n\n<p><code>A -&gt; aX | aY</code><br>\nbecomes:<br>\n<code>A -&gt; aZ</code><br>\n<code>Z -&gt; X | Y</code></p>\n\n<p>I understand that. However, my grammar looks more like this:</p>\n\n<pre><code>X -&gt; aE | IXE | (X)E\nE -&gt; IE | BXE | \u03f5\nI -&gt; ++ | --\nB -&gt; + | - | \u03f5\n</code></pre>\n\n<p>I'm not sure how to apply the simpler example to this. I've been trying for at least a couple of hours and I've lost track of all of the things I've tried. Generally, my attempts have looked something like this:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nE  -&gt; IE | BIX'E | BX'E | \u03f5\n</code></pre>\n\n<p>And I then try to convert the E rules into ones having only one production starting with + or -:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; IE | B'IX'E | IX'E | B'X'E | X'E | \u03f5\n</code></pre>\n\n<p>And then...</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; +P | -M | \u03f5\nP  -&gt; +E | IX'E | +X'E | X'E\nM  -&gt; -E | IX'E | -X'E | X'E\n</code></pre>\n\n<p>And so on. But I continually end up with a lot of extra nonterminals, and some very long productions / chains of productions, without actually having left-factored it. I'm not sure how to approach this - I can't seem to eliminate <i>some</i> nonterminal having multiple productions starting with a + and with a -.</p>\n", 'ViewCount': '2109', 'Title': 'Left-Factoring a grammar into LL(1)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:21:31.690', 'LastEditDate': '2014-01-23T17:21:31.690', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '4873', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3049', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-10-03T19:44:14.687', 'Id': '4862'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am having difficulty with one of the exercises in the <em>Dragon Book</em>:</p>\n\n<blockquote>\n  <p><strong>Exercise 2.4.1(c):</strong> Construct recursive-descent parsers, starting with\n  the following grammars:</p>\n  \n  <p>$$S \\rightarrow 0S1\\ |\\ 01$$</p>\n</blockquote>\n\n<p>Yet, for constructing a feasible parser, it is required that for two productions $A \\rightarrow \\alpha\\ |\\ \\beta$, their FIRST sets are disjoint. But since:</p>\n\n<blockquote>\n  <p>$$FIRST(0S1) = \\{ 0 \\} \\hspace{2em}\\&amp;\\hspace{2em} FIRST(01) = \\{ 0 \\}$$</p>\n</blockquote>\n\n<p>this is not the case. How does one proceed here? Just state it is not feasible due to the stated conflict or is there alternative approach, like modfying the grammar?</p>\n', 'ViewCount': '523', 'Title': 'Recursive-Descent Predictive Parser for $S \\rightarrow 0S1\\ |\\ 01$', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-05T22:00:36.987', 'LastEditDate': '2012-11-05T01:53:06.597', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4459', 'Tags': '<context-free><compilers><parsers>', 'CreationDate': '2012-11-05T01:09:51.563', 'Id': '6479'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1826', 'Title': 'How is this grammar LL(1)?', 'LastEditDate': '2012-11-19T18:22:36.037', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '135', 'FavoriteCount': '1', 'Body': '<p>This is a question from the Dragon Book. This is the grammar:</p>\n\n<blockquote>\n  <p>$S \\to  AaAb \\mid BbBa $<br>\n  $A \\to \\varepsilon$<br>\n  $B \\to \\varepsilon$  </p>\n</blockquote>\n\n<p>The question asks how to show that it is LL(1) but not SLR(1). </p>\n\n<p>To prove that it is LL(1), I tried constructing its parsing table, but I am getting multiple productions in a cell, which is contradiction.</p>\n\n<p>Please tell how is this LL(1), and how to prove it?</p>\n', 'Tags': '<formal-grammars><compilers><parsers>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-03T22:23:27.980', 'CommentCount': '2', 'AcceptedAnswerId': '6774', 'CreationDate': '2012-11-19T14:30:09.487', 'Id': '6768'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am studying formal languages and playing with writing my own parsers for them. I have a context free grammar parser already that works well. I am wondering if anyone can point me towards actually implemented examples of rewriters. For example, suppose I had the rules</p>\n\n<p>WORD: [A-Z]+</p>\n\n<p>QUOTE: "</p>\n\n<p>And I wanted to input a lot of words,put quotes around each one, and write out the string. Or go back and forth. Something like this:</p>\n\n<p>(WORD [\' \'])+   &lt;--> (QUOTE WORD QUOTE [\' \'])+</p>\n\n<p>That seems kind of possible to implement automatically without ambiguity, but I was hoping someone had seen something along that line that already exists.</p>\n', 'ViewCount': '107', 'Title': 'Example of a parsing/rewriting system?', 'LastActivityDate': '2012-11-22T06:56:28.430', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4657', 'Tags': '<formal-languages><parsers><term-rewriting>', 'CreationDate': '2012-11-21T11:23:56.357', 'Id': '6808'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>Why LL(k) and LL(\u221e) are incompatible with left-recursion? I understand that a LL(k) language can support left-recursivity provided that with k-overahead tokens can be resolved any ambiguity. But, with a LL(\u221e) grammar, which type of ambiguities can't be solved?</p>\n", 'ViewCount': '101', 'Title': 'LL grammars and left-recursiviity', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:19:48.497', 'LastEditDate': '2014-01-23T17:19:48.497', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6824', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4675', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-11-21T11:41:00.150', 'Id': '6809'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '186', 'Title': 'Is this grammar really LL(1) while not being LR(1)?', 'LastEditDate': '2012-12-23T11:32:28.010', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4383', 'FavoriteCount': '0', 'Body': "<p>$S \\rightarrow S$, $L(G) = \\{\\}$</p>\n\n<p><strong>LL(1) analysis:</strong></p>\n\n<p>We estabilish $FIRST(S)$ to be empty and $FOLLOW(S)$ to be $\\{\\$\\}$.\n$FIRST(S)$ doesn't contain &epsilon;, so the parse table looks like this:</p>\n\n<pre><code>+---+---+\n|   | $ |\n+---+---+\n| S |   |\n+---+---+\n</code></pre>\n\n<p>and correctly rejects any input including &epsilon;.</p>\n\n<p><strong>LR(1) analysis:</strong></p>\n\n<p>We start with the initial state 0:</p>\n\n<p>$S' \\rightarrow \\bullet S [\\$]$</p>\n\n<p>calculate its closure:</p>\n\n<p>$S' \\rightarrow \\bullet S [\\$]$</p>\n\n<p>$S \\rightarrow \\bullet S [\\$]$</p>\n\n<p>and the only transition, which leads to state 1 on S:</p>\n\n<p>$S' \\rightarrow S \\bullet [\\$]$</p>\n\n<p>$S \\rightarrow S \\bullet [\\$]$</p>\n\n<p>State 1 has a reduce/reduce conflict.</p>\n\n<p>Now, obviously there must be something I'm missing, since LL(k) grammars are a proper subset of LR(k) grammars. Would anyone care to point out the error?</p>\n", 'Tags': '<formal-grammars><context-free><parsers>', 'LastEditorUserId': '4383', 'LastActivityDate': '2012-12-24T19:41:08.793', 'CommentCount': '2', 'AcceptedAnswerId': '7581', 'CreationDate': '2012-12-23T10:56:44.823', 'Id': '7560'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '599', 'Title': 'What are handles in parsing?', 'LastEditDate': '2012-12-24T23:06:04.487', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'eshi14', 'PostTypeId': '1', 'OwnerUserId': '5245', 'Body': '<p>I have read a few algorithms for $LR(k)$ parser, in which there is a frequent mention of selecting a handle from the grammar given.\nFor example, one document said  - <em>"the essence of LR parsing is identifying the handle on top of stack"</em></p>\n\n<p>Please help me understand, what are handles in parsing?</p>\n', 'Tags': '<compilers><parsers>', 'LastEditorUserId': '3011', 'LastActivityDate': '2012-12-25T01:36:13.580', 'CommentCount': '0', 'AcceptedAnswerId': '7592', 'CreationDate': '2012-12-24T03:48:43.007', 'Id': '7587'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Supposing we have two grammars which define the same languge: regular one and LALR(1) one.</p>\n\n<p>Both regular and LALR(1) algorithms are O(n) where n is input length.</p>\n\n<p>Regexps are usually preferred for parsing regular languages. Why? Is there a formal proof (or maybe that's obvious) that they are faster?</p>\n", 'ViewCount': '125', 'Title': 'Regular vs LALR(1): what is faster', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-26T18:03:37.970', 'LastEditDate': '2013-01-26T18:03:37.970', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6564', 'Tags': '<regular-languages><efficiency><parsers>', 'CreationDate': '2013-01-25T23:42:16.297', 'Id': '9159'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have two regular languages <em>A</em> and <em>B</em>, and I want to determine whether there is any pair of strings, <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em>, such that (<em>a</em>&nbsp;<em>b</em>) is a prefix of a string in (<em>A</em>&nbsp;<em>B</em>) and the left-most match of <em>B</em> in (<em>a</em>&nbsp;<em>b</em>) includes one or more characters from <em>a</em>.</p>\n\n<p>Raphael\'s formulation is good:</p>\n\n<blockquote>\n  <p>Given two regular language A, B, is there a (non-empty) prefix of a word b in B that is a suffix of a word in A so that the rest of b is a prefix of another word in B?</p>\n</blockquote>\n\n<h1>Example</h1>\n\n<p>For example, let\'s say I have two regular languages, one which describes some properly escaped HTML text, and one which describes an end tag:</p>\n\n<pre><code>A := ([^&amp;&lt;&gt;] | [&amp;] [a-z] [a-z0-9]+ [;])*;\nB := "&lt;/title";\n</code></pre>\n\n<p>By inspection, I can tell that there is no string (<em>a</em>&nbsp;<em>b</em>) in (<em>A</em>&nbsp;<em>B</em>) such that the first match of <em>B</em> includes characters from <em>a</em> because <code>"&lt;"</code> is a prefix of <em>B</em> which cannot occur as a suffix of <em>A</em>.</p>\n\n<p>But given a different grammar:</p>\n\n<pre><code>A\' := (A | "&lt;![CDATA[" ("]"? "&gt;" | "]"* [^\\]&gt;])* "]]&gt;")*;\nB\' := "&lt;/title" ([^&gt;\\"] | [\\"] [^\\"]* [\\"])* "&gt;";\n</code></pre>\n\n<p>then there are strings</p>\n\n<pre><code>a = \'&lt;![CDATA[&lt;/title "]]&gt;"\';\nb = \'&lt;/title&gt;\';\n</code></pre>\n\n<p>where (<em>A</em>&nbsp;<em>B</em>) matches <code>\'&lt;![CDATA[&lt;/title "]]&gt;"&lt;/title&gt;\'</code> and the left-most match of <em>B</em> is <code>\'&lt;/title "]]&gt;"&lt;/title&gt;\'</code> which includes a non-empty suffix of <em>a</em> : <code>\'&lt;/title "]]&gt;"\'</code>.</p>\n\n<h1>Motivation</h1>\n\n<p><em>A</em> in my situation describes the output of an encoder/sanitizer that is derived from a grammar, so an untrusted input is fed to the encoder/sanitizer and I know the output matches <em>A</em> by construction.</p>\n\n<p><em>B</em> is a limit condition in a larger grammar that describes how parsers determine where a chunk of an embedded language ends so they can hand it off to a parser for the embedded language.</p>\n\n<p>My end goal is to be able to determine when I can optimize away runtime checks that ensure that it is safe to embed a particular encoded string.  For these examples, it would be safe to optimize out the first check, but not the second.</p>\n\n<hr>\n\n<p>Is this a solved problem?  Does it have a name?  Any pointers appreciated.</p>\n', 'ViewCount': '76', 'Title': 'For regular languages A and B, determine whether B might match early in (A B)', 'LastEditorUserId': '1298', 'LastActivityDate': '2013-03-28T18:43:58.467', 'LastEditDate': '2013-03-28T18:43:58.467', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><regular-languages><regular-expressions><parsers>', 'CreationDate': '2013-03-27T21:11:15.627', 'Id': '10852'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Consider such a rule in grammar for an LR-family parsing generator (e.g YACC, BISON, etc.):</p>\n\n<p><code>Nonterminal : [ lookahead not in {Terminal1, ..., TerminalN} ] Rule ;</code></p>\n\n<p>It's an ordinary rule, except that it has a restriction: a phrase produced with this rule cannot begin with <code>Terminal1, ..., TerminalN</code>. (Surely, this rule can be replaced with a set of usual rules, but it will result in a bigger grammar). This can be useful for resolving conflicts.</p>\n\n<p>The question is, is there a modification of LR table construction algorithm that accepts such restrictions? It seems to me that such a modification is possible (like precedence relations).</p>\n\n<p>Surely, it can be checked in runtime, but I mean compile-time check (a check which is performed while building parsing table, like <code>%prec</code>, <code>%left</code>, <code>%right</code> and <code>%nonassoc</code> directives in yacc-compartible generators.)</p>\n", 'ViewCount': '68', 'Title': 'Negative lookahead in LR parsing algorithm', 'LastActivityDate': '2013-04-20T18:43:21.803', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6564', 'Tags': '<formal-grammars><parsers>', 'CreationDate': '2013-04-20T18:43:21.803', 'Id': '11437'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am studying parsing, i.e. bottom-up parsing. it is said that there some rules which are used by weak precedence grammar. What does weak precedence grammar mean? What about precedence relation?</p>\n\n<p>Any help will be appreciated. If it is possible, could you give an example. Thanks</p>\n', 'ViewCount': '59', 'Title': 'Weak Precedence Grammar and Parsing', 'LastActivityDate': '2013-05-29T22:21:32.073', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11753', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7957', 'Tags': '<formal-languages><terminology><context-free><parsers>', 'CreationDate': '2013-05-02T11:42:03.387', 'Id': '11730'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I want to prove that grammar\n$$\n\\begin{cases}\nS'\\rightarrow S\\\\\nS\\rightarrow aSb ~|~ A\\\\\nA\\rightarrow bA~|~b\n\\end{cases}\n$$\nisn't $LR(1)$. I've constructed parser table and got Shift-Reduce conflict.</p>\n\n<p>I want to prove that without parser table, using another $LR(1)$ definition.</p>\n\n<p>Here's definition:\nGrammar is $LR(1)$, if from</p>\n\n<ol>\n<li>$S' \\Rightarrow^*_r uAw \\Rightarrow_r uvw$</li>\n<li>$S' \\Rightarrow^*_r zBx \\Rightarrow_r uvy$</li>\n<li>$FIRST(w) = FIRST(y)$</li>\n</ol>\n\n<p>$\\Rightarrow uAy=zBx.$</p>\n\n<p>So how can prove that?</p>\n", 'ViewCount': '138', 'Title': "How to prove formally that grammar isn't LR(1)", 'LastActivityDate': '2013-06-05T15:25:57.933', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12472', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8530', 'Tags': '<formal-grammars><parsers>', 'CreationDate': '2013-06-05T12:01:44.743', 'Id': '12470'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am working with HOL-Light parser and keeping seeing references to preterm parser. </p>\n\n<p>What is a preterm parser?</p>\n\n<p>The most informative statement I find is from the <a href="http://www.cl.cam.ac.uk/~jrh13/hol-light/reference.pdf" rel="nofollow">HOL-Light reference</a> for the parse_pretype function.</p>\n\n<blockquote>\n  <p>This is mostly an internal function; pretypes and preterms are used as\n  an intermediate representation for typechecking and overload\n  resolution and are not normally of concern to users.</p>\n</blockquote>\n', 'ViewCount': '47', 'Title': 'What is a preterm parser?', 'LastEditorUserId': '268', 'LastActivityDate': '2013-12-13T17:21:13.157', 'LastEditDate': '2013-10-27T14:17:03.933', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16473', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<lambda-calculus><parsers><type-checking>', 'CreationDate': '2013-06-05T21:59:40.477', 'Id': '12478'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I\'ve written a recursive-descent parser generator, and I\'m trying to classify it (call me a cowboy coder if you must). According to wikipedia, <code>S \u2192 0S0 | 1S1 | \u03b5</code>, which checks for an even-length palindrome, is a non-deterministic grammar. My parser generator can handle this grammar. Does that mean my parser is non-deterministic?</p>\n\n<p>To be honest, I\'m not even sure that it\'s proper to try to classify it like this. It doesn\'t really match the description of a pushdown automata, since it passes data up and down through the stack (parameters, passed by reference, which may be modified). If anyone would be interested in taking a closer look at it, I\'d be most grateful. It handles left recursion and ambiguous grammars in (I believe) polynomial time and space. <a href="https://github.com/coder0xff/parlex" rel="nofollow">https://github.com/coder0xff/parlex</a></p>\n', 'ViewCount': '177', 'Title': 'If a parser can parse a non-deterministic grammar, is the parser non-deterministic?', 'LastActivityDate': '2013-07-22T18:51:39.117', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13395', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<formal-grammars><pushdown-automata><parsers>', 'CreationDate': '2013-07-22T17:38:48.407', 'Id': '13393'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to create simple tokenizer to transform following (only part shown) search expression to tokens</p>\n\n<pre><code>word1 near(1) word2\n</code></pre>\n\n<p>where word1, word2 are some words and near(1) is distance operator.\nThe question is how this expression should be tokenized. \nI see two ways</p>\n\n<pre><code>1. &lt;WORD, word1&gt; &lt;WORD, near&gt; &lt;LPAREN&gt; &lt;NUMBER,1&gt; &lt;RPAREN&gt; &lt;WORD, word2&gt;.\n2. &lt;WORD, word1&gt; &lt;NEAROP, 1&gt; &lt;WORD, word2&gt;\n</code></pre>\n\n<p>But should I really try to tokenize NEAR(\\d+) during tokenization, or should I go first way and handle NEAR operator at parser level, during building parse tree?</p>\n", 'ViewCount': '49', 'Title': 'Tokenizer and complex operators', 'LastEditorUserId': '683', 'LastActivityDate': '2013-07-25T08:41:26.530', 'LastEditDate': '2013-07-24T15:48:58.567', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '13430', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9325', 'Tags': '<parsers>', 'CreationDate': '2013-07-24T14:07:52.047', 'Id': '13418'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I don\'t "see" why the following syntax is equivalent to the second</p>\n\n<p>syntax1:</p>\n\n<pre><code>E -&gt; E + T\nE -&gt; T\n</code></pre>\n\n<p>syntax2: </p>\n\n<pre><code>E -&gt; T E\'\nE\' -&gt; + T E\'\nE\' -&gt;\n</code></pre>\n\n<p>(it is to avoid left recursion and I am not understanding why the solution works)</p>\n\n<p>How do I mathematically prove that both syntax definitions are equivalent</p>\n', 'ViewCount': '57', 'Title': 'Prove that the syntax is equivalent', 'LastActivityDate': '2013-08-09T11:54:08.293', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13688', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1700', 'Tags': '<programming-languages><proof-techniques><parsers>', 'CreationDate': '2013-08-09T10:49:22.573', 'Id': '13686'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Considering a grammar that includes a dictionary or list with an optional terminal separator - e.g.: </p>\n\n<p>$$ \n\\begin{align} \nobj \\to    &amp; dict  \\\\   \n           &amp;\\mid OTHER  \\\\ \ndict \\to   &amp; \\{ \\quad \\}  \\\\ \n           &amp; \\mid \\{ \\quad pairs \\quad \\} \\\\ \npairs \\to  &amp; pair \\quad ,?  \\\\\n           &amp; \\mid pair \\quad , \\quad pairs  \\\\ \npair \\to   &amp; PAIR\n\\end{align}\n$$</p>\n\n<p>My understanding is that the above is <strong>not</strong> an LL(1) grammar because there are productions with FIRST() sets\ncrossing over.</p>\n\n<p>But what if we convert it to the following:</p>\n\n<p>$$ \n\\begin{align} \nobj \\to    &amp; dict  \\\\   \n           &amp;\\mid OTHER  \\\\ \ndict \\to     &amp; \\{ \\quad dictrest \\\\\ndictrest \\to &amp; \\}  \\\\    \n             &amp; \\mid pair \\quad pairseq \\quad ,? \\quad \\}  \\\\\npairseq \\to  &amp; \\varepsilon \\\\\n             &amp; \\mid , \\quad pair \\quad pairseq \\\\\npair \\to   &amp; PAIR\n\\end{align}\n$$</p>\n\n<p>Is this latter version LL(1)?</p>\n', 'ViewCount': '64', 'Title': 'Representing grammar for list/dictionary with optional end separator as LL(1)', 'LastActivityDate': '2013-08-13T14:40:27.497', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '13735', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9637', 'Tags': '<formal-grammars><parsers>', 'CreationDate': '2013-08-13T13:52:57.563', 'Id': '13733'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '165', 'Title': 'How is non-ambuiguity different from determinism?', 'LastEditDate': '2013-09-26T09:15:33.267', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10314', 'FavoriteCount': '1', 'Body': '<p>I am trying to understand what is meant by "deterministic" in expressions such as "deterministic context-free grammar". (There are more deterministic "things" in this field). I would appreciate an example more then the most elaborate explanation! If possible.</p>\n\n<p>My primary source of confusion is from not being able to tell how this property of a grammar is different from (non-)ambiguity.</p>\n\n<p>The closest I got to finding what it means is this quote from the paper by D. Knuth <em>On the Translation of Languages from Left to Right</em>:</p>\n\n<blockquote>\n  <p>Ginsburg and Greibach (1965) have defined the notion of a\n  deterministic language; we show in Section V that these are precisely\n  the languages for which there exists an L R ( k ) grammar</p>\n</blockquote>\n\n<p>which becomes circular as soon you get to the <code>Section V</code>, because there it says that what LR(k) parser can parse is the deterministic language...</p>\n\n<hr>\n\n<p>Below is an example that I could find to help me understand what "ambigous" means, please take a look:</p>\n\n<pre><code>onewartwoearewe\n</code></pre>\n\n<p>Which can be parsed as <code>one war two ear ewe</code> or <code>o new art woe are we</code> - if a grammar allows that (say it has all the words I just listed).</p>\n\n<p>What would I need to do to make this example language (non-)deterministic? (I could, for example, remove the word <code>o</code> from the grammar, to make the grammar not ambiguous).</p>\n\n<p>Is the above language deterministic?</p>\n\n<p><em>PS. The example is from the book Godel, Esher, Bach: Eternal Golden Braid.</em></p>\n\n<hr>\n\n<p>Let\'s say, we define the grammar for the example language like so:</p>\n\n<pre><code>S -&gt; A \'we\' | A \'ewe\'\nA -&gt; B | BA\nB -&gt; \'o\' | \'new\' | \'art\' | \'woe\' | \'are\' | \'one\' | \'war\' | \'two\' | \'ear\'\n</code></pre>\n\n<p>By the argument about having to parse the whole string, does this grammar make the language non-deterministic?</p>\n\n<hr>\n\n\n\n<pre><code>let explode s =\n  let rec exp i l =\n    if i &lt; 0 then l else exp (i - 1) (s.[i] :: l) in\n  exp (String.length s - 1) [];;\n\nlet rec woe_parser s =\n  match s with\n  | \'w\' :: \'e\' :: [] -&gt; true\n  | \'e\' :: \'w\' :: \'e\' :: [] -&gt; true\n  | \'o\' :: x -&gt; woe_parser x\n  | \'n\' :: \'e\' :: \'w\' :: x -&gt; woe_parser x\n  | \'a\' :: \'r\' :: \'t\' :: x -&gt; woe_parser x\n  | \'w\' :: \'o\' :: \'e\' :: x -&gt; woe_parser x\n  | \'a\' :: \'r\' :: \'e\' :: x -&gt; woe_parser x\n  (* this line will trigger an error, because it creates \n     ambiguous grammar *)\n  | \'o\' :: \'n\' :: \'e\' :: x -&gt; woe_parser x\n  | \'w\' :: \'a\' :: \'r\' :: x -&gt; woe_parser x\n  | \'t\' :: \'w\' :: \'o\' :: x -&gt; woe_parser x\n  | \'e\' :: \'a\' :: \'r\' :: x -&gt; woe_parser x\n  | _ -&gt; false;;\n\nwoe_parser (explode "onewartwoearewe");;\n- : bool = true\n</code></pre>\n\n<hr>\n\n<pre><code>| Label   | Pattern      |\n|---------+--------------|\n| rule-01 | S -&gt; A \'we\'  |\n| rule-02 | S -&gt; A \'ewe\' |\n| rule-03 | A -&gt; B       |\n| rule-04 | A -&gt; BA      |\n| rule-05 | B -&gt; \'o\'     |\n| rule-06 | B -&gt; \'new\'   |\n| rule-07 | B -&gt; \'art\'   |\n| rule-08 | B -&gt; \'woe\'   |\n| rule-09 | B -&gt; \'are\'   |\n| rule-10 | B -&gt; \'one\'   |\n| rule-11 | B -&gt; \'war\'   |\n| rule-12 | B -&gt; \'two\'   |\n| rule-13 | B -&gt; \'ear\'   |\n#+TBLFM: @2$1..@&gt;$1=\'(format "rule-%02d" (1- @#));L\n\nGenerating =onewartwoearewe=\n\nFirst way to generate:\n\n| Input             | Rule    | Product           |\n|-------------------+---------+-------------------|\n| \'\'                | rule-01 | A\'we\'             |\n| A\'we\'             | rule-04 | BA\'we\'            |\n| BA\'we\'            | rule-05 | \'o\'A\'we\'          |\n| \'o\'A\'we\'          | rule-04 | \'o\'BA\'we\'         |\n| \'o\'BA\'we\'         | rule-06 | \'onew\'A\'we\'       |\n| \'onew\'A\'we\'       | rule-04 | \'onew\'BA\'we\'      |\n| \'onew\'BA\'we\'      | rule-07 | \'onewart\'A\'we\'    |\n| \'onewart\'A\'we\'    | rule-04 | \'onewart\'BA\'we\'   |\n| \'onewart\'BA\'we\'   | rule-08 | \'onewartwoe\'A\'we\' |\n| \'onewartwoe\'A\'we\' | rule-03 | \'onewartwoe\'B\'we\' |\n| \'onewartwoe\'B\'we\' | rule-09 | \'onewartwoearewe\' |\n|-------------------+---------+-------------------|\n|                   |         | \'onewartwoearewe\' |\n\nSecond way to generate:\n\n| Input             | Rule    | Product           |\n|-------------------+---------+-------------------|\n| \'\'                | rule-02 | A\'ewe\'            |\n| A\'ewe\'            | rule-04 | BA\'ewe\'           |\n| BA\'ewe\'           | rule-10 | \'one\'A\'ewe\'       |\n| \'one\'A\'ewe\'       | rule-04 | \'one\'BA\'ewe\'      |\n| \'one\'BA\'ewe\'      | rule-11 | \'onewar\'A\'ewe\'    |\n| \'onewar\'A\'ewe\'    | rule-04 | \'onewar\'BA\'ewe\'   |\n| \'onewar\'BA\'ewe\'   | rule-12 | \'onewartwo\'A\'ewe\' |\n| \'onewartwo\'A\'ewe\' | rule-03 | \'onewartwo\'B\'ewe\' |\n| \'onewartwo\'B\'ewe\' | rule-13 | \'onewartwoearewe\' |\n|-------------------+---------+-------------------|\n|                   |         | \'onewartwoearewe\' |\n</code></pre>\n', 'Tags': '<context-free><formal-grammars><parsers>', 'LastEditorUserId': '10314', 'LastActivityDate': '2013-09-26T09:15:33.267', 'CommentCount': '14', 'AcceptedAnswerId': '14585', 'CreationDate': '2013-09-24T20:35:01.163', 'Id': '14583'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the <a href="https://class.coursera.org/compilers/lecture/index" rel="nofollow">compiler course by Alex Aiken on Coursera</a>, more specifically lecture <a href="https://class.coursera.org/compilers/lecture/20" rel="nofollow">05-02 Context Free Grammars</a>,  the professor says that CFGs give answers of the type yes/no, i.e. whether the given string of tokens is valid or not. He adds that it is also desirable to know <em>how</em> a particular string of tokens is in the language; for this purpose he introduces parse trees.</p>\n\n<p>Why is the "how" part important?      </p>\n', 'ViewCount': '328', 'Title': "What information do we get from a compiler's parse tree?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-03T09:22:35.317', 'LastEditDate': '2013-11-02T15:49:25.097', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<context-free><compilers><parsers>', 'CreationDate': '2013-11-02T10:34:57.683', 'Id': '16647'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am learning LR(1) parsing from the Dragon Book. I am really confused with this sentence.</p>\n\n<blockquote>\n  <p>Formally we say that a configuration $[A \\to u\u2022v, a]$ is valid for a viable prefix $\u03b1$ if  there is a rightmost derivation $S \\Rightarrow^* \u03b2Aw \\Rightarrow^* \u03b2uvw$ where $\u03b1 = \u03b2u$ and either $a$ is the first symbol of $w$ or $w$ is $\u2202$ and $a$ is $\\$$. </p>\n</blockquote>\n\n<p>I am not able to figure out how validation of a configuration for a viable prefix is <em>useful</em> . What does it speak <em>intutively</em> and why does it matters?</p>\n', 'ViewCount': '47', 'Title': u'what does \u201cConfiguration is valid for a viable prefix \u201d actually means?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-03T15:24:39.277', 'LastEditDate': '2013-11-03T15:24:39.277', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11151', 'Tags': '<terminology><compilers><parsers><parsing>', 'CreationDate': '2013-11-03T14:55:18.830', 'FavoriteCount': '1', 'Id': '16673'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have seen this question: <a href="http://cs.stackexchange.com/questions/2713/are-regular-expressions-lrk">Are regular expressions $LR(k)$?</a> and my question is slightly related.</p>\n\n<p>Suppose I have a regular expression:\nRE=(a*a*)?(a*a*)</p>\n\n<p>and I convert it to a grammar:\nG ::= A B\nA ::= C | (empty)\nC ::= D D\nD ::= aD | empty\nB ::= D D</p>\n\n<p>Can an LALR(1) parser such as Bison generate matches such that I can perform actions such as recording captures, etc... If so, is the cost linear in the size of the input?</p>\n\n<p>If not, is the lower bound on this operation the cost of simulating an NFA generated by the regular expression? I know that DFAs can\'t perform sub-match captures.</p>\n', 'ViewCount': '21', 'Title': 'Can regular expression captures be matched by a CFG being simulated by an $LR(k)$ parser?', 'LastActivityDate': '2013-11-14T05:00:11.847', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5331', 'Tags': '<regular-languages><context-free><regular-expressions><parsers>', 'CreationDate': '2013-11-14T05:00:11.847', 'Id': '18005'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>The syntax of dice notation follows the following grammar:</p>\n\n<p>$$ Roll \\rightarrow Dice | Dice'x'Int | More \\quad Mod \\quad More $$\n$$ Dice \\rightarrow Int_{1}'d'Int_2$$\n$$ Mod \\rightarrow '+'|'-'$$\n$$ More \\rightarrow Int | Roll$$\n$$ Int \\rightarrow &lt;integer&gt;$$</p>\n\n<p>Give a leftmost derivation for the sample string:\n$3d8 + 2d4x3 + 1d12 + 567$</p>\n\n<p>I was able to parse the two first operands $3d8 + 2d4x3$ but I couldn't find a reasonable derivation for the rest.</p>\n\n<p>My solution is like:</p>\n\n<pre><code>E -&gt; More Mod More\nE -&gt; Roll Mod More\nE -&gt; Dice Mod More\nE -&gt; Int1\u2019d\u2019Int2 Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019Int2 Mod More\n...\n...\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + More Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + Roll Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + Dice Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + Int1\u2019d\u2019Int2 Mod More\n</code></pre>\n\n<p>I was thinking that the given string is not a valid string for this grammar.</p>\n\n<p>Does any have any idea for this problem. I'm newbie in Compiler Design :-)</p>\n", 'ViewCount': '45', 'Title': 'Parsing Dice Notation', 'LastEditorUserId': '11326', 'LastActivityDate': '2013-12-26T10:35:13.830', 'LastEditDate': '2013-11-22T01:00:42.440', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<parsers><parsing>', 'CreationDate': '2013-11-22T00:55:20.480', 'Id': '18245'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>How would I find an LL(1) grammar for the language:</p>\n\n<blockquote>\n  <p>L=a<sup>m</sup> b<sup>n</sup> c<sup>m+n</sup></p>\n</blockquote>\n\n<p>Where m and n are elements of the naturals? My context-free grammar is:</p>\n\n<blockquote>\n  <p>S &rarr; aSc | B</p>\n  \n  <p>B &rarr; bBc | A</p>\n  \n  <p>A &rarr; bc</p>\n</blockquote>\n\n<p>Is my grammar LL(1) parsable?</p>\n', 'ViewCount': '99', 'ClosedDate': '2014-02-02T11:19:15.587', 'Title': 'Finding an LL(1) grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T16:06:25.357', 'LastEditDate': '2013-12-02T12:09:50.653', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11752', 'Tags': '<formal-languages><context-free><formal-grammars><parsers>', 'CreationDate': '2013-12-02T03:37:45.623', 'Id': '18523'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>As described in <a href="http://courses.engr.illinois.edu/cs421/sp2012/project/PracticalEarleyParsing.pdf" rel="nofollow">this paper</a>, you can use an pre-computed automaton to speed up an Earley parse.  I\'m not interested in the rigorous proof of this, but just how the basic algorithm works so that I can implement it.  Understanding this paper on my own would take a long long time, and I don\'t think it\'s justified for this algorithm because it seems simple enough, but the paper is accademic and is required to be over my head, so they didn\'t write it for a reader like me.</p>\n\n<p>For instance, what does a transition labeled with a variable in the automaton mean?  How does this thing work?</p>\n', 'ViewCount': '35', 'Title': 'How does Earley parsing using an automaton work?', 'LastActivityDate': '2013-12-25T17:26:45.727', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12373', 'Tags': '<algorithms><automata><parsers>', 'CreationDate': '2013-12-25T17:26:45.727', 'Id': '19284'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '101', 'Title': 'Is this grammar LR(1)', 'LastEditDate': '2014-01-29T17:12:56.117', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11750', 'FavoriteCount': '1', 'Body': "<p>I am reading parser chapter from dragon book and I found a grammar over there - </p>\n\n<p>$ S \\rightarrow L=R $</p>\n\n<p>$ S \\rightarrow R $</p>\n\n<p>$L \\rightarrow *R $</p>\n\n<p>$L \\rightarrow id $</p>\n\n<p>$R \\rightarrow L $</p>\n\n<p>Now I have created some of its items, not sure if they are correct - </p>\n\n<p>$ I_{0} $</p>\n\n<p>$S' \\rightarrow .S  ; \\$ $</p>\n\n<p>$S \\rightarrow .L=R ; \\$ $</p>\n\n<p>$S \\rightarrow .R ; \\$ $</p>\n\n<p>$ L \\rightarrow .*R; \\$/= $</p>\n\n<p>$ L \\rightarrow .id; \\$/= $</p>\n\n<p>$ R \\rightarrow .L; \\$ $</p>\n\n<p>$ I_{1} $</p>\n\n<p>$ S' \\rightarrow S.; \\$ $</p>\n\n<p>$ I_{2} $</p>\n\n<p>$S \\rightarrow L.=R ; \\$ $</p>\n\n<p>$ R \\rightarrow L.; \\$ $</p>\n\n<p>Now I2 contains Shift reduce conflict but the lookahead symbol that is appearing is creating doubt I mean how $ can be lookahead symbol to shift <code>=</code> sign? </p>\n", 'Tags': '<formal-grammars><compilers><parsers>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T22:55:58.517', 'CommentCount': '0', 'AcceptedAnswerId': '20232', 'CreationDate': '2014-01-29T15:42:30.253', 'Id': '20068'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Considering programming languages with significant whitespace for indentation, such as Python or Haskell. How does this whitespace fit into the grand schemes of programming language grammars.</p>\n\n<p>I can see that a "preprocessor" can convert indent changes into tokens which are then handled in grammars, yet can one also perform the parsing based upon a single grammar without changing the intrinsic complexity of the 2nd grammer?</p>\n', 'ViewCount': '29', 'Title': 'Indentation based Grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-01T15:40:14.350', 'LastEditDate': '2014-02-01T15:34:28.963', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '20188', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8028', 'Tags': '<formal-grammars><compilers><parsers>', 'CreationDate': '2014-02-01T10:34:48.470', 'Id': '20181'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was trying to rule out whether this was LL(1) by checking for left-recursion in the following grammar:</p>\n\n<p>$\\qquad  A \\to 0 A 1 \\mid 0 1$</p>\n\n<p>Which produces:</p>\n\n<p>$\\qquad 0 A 1 \\Rightarrow 0 0 A 1 1 \\Rightarrow \\dots$</p>\n\n<p>But I am unsure what type of recursion this is called, since it sorta stays in the middle.</p>\n\n<p>If this is not left-recursive, would you agree that this is not LL(1) because non-terminal A has 0 appear twice in FIRST(A)?</p>\n', 'ViewCount': '51', 'Title': 'What type of recursion is this?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T00:04:23.193', 'LastEditDate': '2014-02-18T08:18:31.617', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21756', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2014-02-18T06:31:22.527', 'Id': '21753'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a VHDL elaboration engine/simulator. As I understand it, the language syntax allows for ambiguities at syntax level. That is, an assignment</p>\n\n<pre><code>pin_value &lt;= bus(5)\n</code></pre>\n\n<p>can be interpreted as picking a child of the bus by index. Here the bus is a signal (an object). However, it can also be that paranthis are applied to a type</p>\n\n<pre><code>int_signal &lt;= integer(1.1)\n</code></pre>\n\n<p>which should be interpreted as type conversion.</p>\n\n<p>I wonder. The elaborator should take the parse tree, instantiate objects and tie them together resolving the names. However, the parser has no idea if the prefix at the parensis is a type or array. So, it treats all parensis as indexed objects.</p>\n\n<pre><code>simple_assignment ::= target &lt;= value_expression { , value_expression } \nvalue_expression ::= name | literal | function_call | type_conversion \nname ::= simple_name | indexed_name \nindexed_name ::= prefix ( expression { , expression } ) // example: REG_ARRAY(5)    \ntype_conversion ::= type_mark ( expression )\n</code></pre>\n\n<p>I do not see how can I distinguish between value_expression and type_conversion at syntactic level. My parser parses both as indexed_name and name resolution, when fails to find array object, falls back into type conversion. I am asking if such case analysis it the only way to handle the problem or more strighnforward approach exists that I am missing?</p>\n', 'ViewCount': '49', 'Title': 'parsing at semantic level due to ambiguities', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T22:10:45.090', 'LastEditDate': '2014-04-22T22:10:45.090', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<formal-grammars><parsers><ambiguity>', 'CreationDate': '2014-04-22T20:11:35.043', 'Id': '24032'}}