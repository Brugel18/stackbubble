{'ViewCount': '194', 'Title': 'Proving the security of Nisan-Wigderson pseudo-random number generator', 'LastEditDate': '2012-04-07T23:33:31.787', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '41', 'FavoriteCount': '1', 'Body': "<p>Let $\\cal{S}=\\{S_i\\}_{1\\leq i\\leq n}$ be a partial $(m,k)$-design and $f: \\{0,1\\}^m \\to \\{0,1\\}$ be a Boolean function. The Nisan-Wigderson generator $G_f: \\{0,1\\}^l \\to \\{0,1\\}^n$ is defined as follows:</p>\n\n<p>$$G_f(x) = (f(x|_{S_1}) , \\ldots, f(x|_{S_n}) )$$</p>\n\n<p>To compute the $i$th bit of $G_f$ we take the bits of $x$ with indexes in $S_i$ and then apply $f$ to them.</p>\n\n<blockquote>\n  <p>Assume that $f$ is $\\frac{1}{n^c}$-hard for circuits of size $n^c$ where $c$ is a constant.\n  How can we prove that $G_f$ is $(\\frac{n^c}{2}, \\frac{2}{n^c})$-secure pseudo-random number generator?</p>\n</blockquote>\n\n<h3>Definitions:</h3>\n\n<p>A partial $(m,k)$-design is a collection of subsets $S_1, \\ldots, S_n \\subseteq [l] = \\{1, \\ldots, l\\}$ such that </p>\n\n<ul>\n<li>for all $i$: $|S_i|=m$, and</li>\n<li>for all $i \\neq j$: $|S_i \\cap S_j| \\leq k$.</li>\n</ul>\n\n<p>A function $f$ is $\\epsilon$-hard for circuits of size $s$ iff no circuit of size $s$ can predict $f$ with probability $\\epsilon$ better than a coin toss.</p>\n\n<p>A function $G:\\{0,1\\}^l \\to \\{0,1\\}^n$ is $(s, \\epsilon)$-secure pseudo-random number generator iff no circuit of size $s$ can distinguish between a random number and a number generated by $G_f$ with probability better than $\\epsilon$.</p>\n\n<p>We use $x|_A$ for the string composed of $x$'s bits with indexes in $A$.</p>\n", 'Tags': '<cryptography><pseudo-random-generators>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-09-04T15:21:55.373', 'CommentCount': '6', 'AcceptedAnswerId': '3417', 'CreationDate': '2012-03-13T04:08:58.890', 'Id': '286''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am confused about how taps are chosen for Linear Feedback Shift Registers.</p>\n\n<p>I have a diagram which shows a LFSR with connection polynomial $C(X) = X^5 + X^2 + 1$. The five stages are labelled: $R4, R3, R2, R1$ and $R0$ and the taps come out of $R0$ and $R3$.</p>\n\n<p>How are these taps decided? When I am given a connection polynomial but no diagram, how do I know what values I should XOR?</p>\n\n<p><img src="http://i.stack.imgur.com/ubz8P.jpg" alt="enter image description here"></p>\n', 'ViewCount': '221', 'Title': 'Choosing taps for Linear Feedback Shift Register', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-08T00:26:01.017', 'LastEditDate': '2012-04-07T23:33:01.787', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '1123', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '995', 'Tags': '<cryptography><pseudo-random-generators><shift-register>', 'CreationDate': '2012-04-07T22:38:27.080', 'Id': '1121''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to calculate the output of the sequence generated by this shift register but I cannot find anywhere how to do it. Everywhere the results are just given but there is no explanation how to do compute them. I know the the sequence will repeat every 2^3-1=7 times. Could anyone explain me how to do it. Thank you.</p>\n\n<p><img src="http://i.stack.imgur.com/sEhMT.jpg" alt="enter image description here"></p>\n', 'ViewCount': '86', 'Title': 'LFSR sequence computation', 'LastEditorUserId': '2639', 'LastActivityDate': '2012-08-26T19:19:44.063', 'LastEditDate': '2012-08-26T14:18:02.693', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3338', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2639', 'Tags': '<cryptography><pseudo-random-generators><shift-register>', 'CreationDate': '2012-08-26T13:28:54.913', 'Id': '3337''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I am trying to teach myself the principles of cryptograhpy, and want to solve the following question:</p>\n\n<blockquote>\n  <p>Let G be the algorithm that takes an input x = (x1, . . . , xn) from\n  {0, 1} n (so each xi \u2208 {0, 1}) and outputs the string G(x1, . . . ,\n  xn) = (x1, . . . , xn, x1 \u2295 x2) in {0, 1} n+1. Rigorously prove that G\n  is not a pseudorandom generator.</p>\n</blockquote>\n\n<p>So, we would want to prove that either <strong>expansion</strong> doesn't hold (for all n, l(n) > n), which, in this case, would mean that for each x, the corresponding G > x, or <strong>pseudorandomness</strong> doesn't hold ( For efficient algorithm D, there is a negligible function 'n' such that: </p>\n\n<blockquote>\n  <p>Pr[D(r) = 1]-Pr[D(G(s)) = 1] $\\leq$ $\\epsilon$(n), </p>\n  \n  <p>where 'r' is uniform on {0,1}$^{l(n)}$ and 's' is uniform on {0,1}$^n$</p>\n</blockquote>\n\n<p>), which, in this case, means that we need to prove that there does not exist a function n such that the difference of the probabilities of the function D(r) and D(G(s)) is very small.</p>\n\n<p>Now, I understand these concepts, but I am  having trouble approaching this problem practically... what would be the best way to start?</p>\n", 'ViewCount': '78', 'Title': 'Rigorous proof against pseudorandom generator', 'LastActivityDate': '2012-09-27T06:54:15.687', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4757', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<correctness-proof><pseudo-random-generators>', 'CreationDate': '2012-09-26T22:28:27.563', 'Id': '4754''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In some literature, as well as in <a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="nofollow">Wikipedia</a>, the middle term parameter <em>m</em> of Mersenne twister is called "number of parallel sequences". Why? What is meant here by "parallel sequences"?</p>\n', 'ViewCount': '32', 'Title': 'Mersenne twister middle word', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-20T00:43:31.747', 'LastEditDate': '2012-10-20T00:43:31.747', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4276', 'Tags': '<terminology><cryptography><pseudo-random-generators>', 'CreationDate': '2012-10-19T20:39:43.797', 'Id': '6178''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm attempting to use the MT19937 variant of the Mersenne Twister PRNG to accomplish something.  Whether or not this something is feasible depends upon the answers to these two questions:</p>\n\n<p>What is the greatest value of <strong>m</strong> for which the following statements hold true:</p>\n\n<p>1 - For all seed values, the algorithm eventually produces every integer list of length <strong>m</strong>.</p>\n\n<p>2 - There exists a seed value for which the algorithm would eventually produce a given integer list of length <strong>m</strong>.</p>\n", 'ViewCount': '93', 'Title': 'Will the Mersenne Twister PRNG eventually produce all integer sequences of a certain length?', 'LastEditorUserId': '5308', 'LastActivityDate': '2013-01-05T18:42:00.607', 'LastEditDate': '2013-01-05T18:42:00.607', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5308', 'Tags': '<algorithms><pseudo-random-generators>', 'CreationDate': '2013-01-05T05:17:40.293', 'Id': '7775''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It is well known that the efficiency of randomized algorithms (at least those in BPP and RP) depends on the quality of the random generator used. Perfect random sources are unavailable in practice. Although it is proved that for all $0 &lt; \\delta \\leq \\frac{1}{2}$ the identities BPP = $\\delta$-BPP and RP = $\\delta$-RP hold, it is not true that the original algorithm used for a prefect random source can be directly used also for a $\\delta$-random source. Instead, some simulation has to be done. This simulation is polynomial, but the resulting algorithm is not so efficient as the original one.</p>\n\n<p>Moreover, as to my knowledge, the random generators used in practice are usually not even $\\delta$-sources, but pseudo-random sources that can behave extremely badly in the worst case.</p>\n\n<p>According to <a href="http://en.wikipedia.org/wiki/Randomized_algorithm" rel="nofollow" title="Wikipedia">Wikipedia</a>:</p>\n\n<blockquote>\n  <p>In common practice, randomized algorithms are approximated using a pseudorandom number generator in place of a true source of random bits; such an implementation may deviate from the expected theoretical behavior.</p>\n</blockquote>\n\n<p>In fact, the implementations of randomized algorithms that I have seen up to now were mere implementations of the algorithms for perfect random sources run with the use of pseudorandom sources.</p>\n\n<p>My question is, if there is any justification of this common practice. Is there any reason to expect that in most cases the algorithm will return a correct result (with the probabilities as in BPP resp. RP)? How can the "approximation" mentioned in the quotation from Wikipedia be formalized? Can the deviation mentioned be somehow estimated, at least in the expected case? Is it possible to argue that a Monte-Carlo randomized algorithm run on a perfect random source will turn into a well-behaved stochastic algorithm when run on a pseudorandom source? Or are there any other similar considerations?</p>\n', 'ViewCount': '92', 'Title': 'Random generator considerations in the design of randomized algorithms', 'LastActivityDate': '2013-05-02T22:23:28.033', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11744', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2091', 'Tags': '<randomized-algorithms><randomness><pseudo-random-generators>', 'CreationDate': '2013-05-02T10:41:01.760', 'Id': '11726''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to understand how the Mersenne Twister random number generator works (in particular, the 32-bit TinyMT). I am still relatively new to the concept of RNG. As I read the source code, I noticed there were two ways to seed the MT: with a single integer seed or an array of integer seeds. What is the point in seeding with an array? Does it produce a better distribution or a longer period? </p>\n\n<p>Also, I would appreciate it if somebody could explain to me what is meant by the "state" of the RNG, as I am seeing that word all over the source code. Is it like a finite state machine in a way? </p>\n\n<p>Thanks for your time!</p>\n', 'ViewCount': '152', 'Title': 'Seeding the Mersenne Twister Random Number Generator', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-24T14:19:28.083', 'LastEditDate': '2014-03-24T14:19:28.083', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8783', 'Tags': '<algorithms><randomized-algorithms><pseudo-random-generators><random-number-generator>', 'CreationDate': '2013-06-20T16:09:56.607', 'Id': '12792''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '236', 'Title': 'What is a good algorithm for generating random DFAs?', 'LastEditDate': '2013-06-29T08:40:23.377', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I am generating random DFAs to test a DFA reduction algorithm on them.</p>\n\n<p>The algorithm that I'm using right now is as follows: for each state $q$, for each symbol in the alphabet $c$, add $\\delta (q, c)$ to some random state.  Each state has the same probability of becoming a final state.</p>\n\n<p>Is this a good method of generating unbiased DFAs?  Also, this algorithm doesn't generate a trim DFA (a DFA with no obsolete states) so I'm wondering if there is a better way of generating random DFAs that can somehow ensure that it is trim?</p>\n", 'Tags': '<algorithms><finite-automata><random><pseudo-random-generators><random-graphs>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-18T10:13:05.943', 'CommentCount': '9', 'AcceptedAnswerId': '12949', 'CreationDate': '2013-06-28T05:14:15.410', 'Id': '12943''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm working on a NFA to DFA conversion tool that is different from the Subset Construction and I need to test this tool.</p>\n\n<p>In order to be sure that the immplementation has no bug I'd like to generate a random NFA with these properties:</p>\n\n<ul>\n<li>The NFA should be connected</li>\n<li>The NFA should have one initial state and one or more final states</li>\n<li>The NFA should have \u03b5-moves</li>\n</ul>\n\n<p>Is there a known algorithm or a paper that explains how to generate this NFA automaton as random as possible? </p>\n", 'ViewCount': '100', 'Title': 'NFA random generator', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-23T18:09:45.097', 'LastEditDate': '2013-09-23T18:09:45.097', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<finite-automata><pseudo-random-generators><random>', 'CreationDate': '2013-09-23T15:19:46.953', 'Id': '14555''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>consider a program that generates a <a href="http://en.wikipedia.org/wiki/Random_walk" rel="nofollow">random walk</a> using a <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator" rel="nofollow">PRNG</a>, as in following pseudocode. it uses <a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="nofollow">arbitrary precision arithmetic</a> such that there is no limit on variable values (ie no overflow).</p>\n\n<pre><code>srand(x)\nz = 0\nwhile (z &gt;= 0)\n{\n  r = rand(100)\n  if (r &lt;= 50) z -= 1\n  else z += 1\n}\n</code></pre>\n\n<p>the PRNG is inited with seed <code>x</code> <em>(also arbitrary precision).</em> the PRNG <code>rand(100)</code> generates a value between <code>0..99</code>. hence for 51 values the accumulator var <code>z</code> is decremented, for 49 values it is incremented.</p>\n\n<p>it is expected due to the <a href="http://en.wikipedia.org/wiki/Law_of_large_numbers" rel="nofollow">law of large numbers</a> that this program will halt for all initial seeds <code>x</code>. however, </p>\n\n<blockquote>\n  <p>how does one prove it will halt for all initial seeds <code>x</code>?</p>\n</blockquote>\n\n<p>it seems such a proof must depend on the details of the construction of the PRNG. am assuming there exist PRNGs such that a different random sequence is generated for every initial seed <code>x</code> (ie the infinite set of naturals). that in itself may be up for question. are such PRNGs known? where are they used? etc.. so an answer may come up with an arbitrary PRNG for the purposes of the question. a single example fulfilling the criteria would be an acceptable answer.</p>\n\n<p>looking for related literature, similar problems/proof considered, etc.</p>\n', 'ViewCount': '58', 'Title': 'proof of convergence in arbitrary precision PRNGs', 'LastActivityDate': '2013-11-19T00:38:41.127', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '699', 'Tags': '<algorithms><reference-request><probability-theory><pseudo-random-generators><random-walks>', 'CreationDate': '2013-11-18T21:52:05.343', 'FavoriteCount': '1', 'Id': '18132''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '64', 'Title': 'Are there pseudorandom number generators (PRNG) with no finite period?', 'LastEditDate': '2013-11-22T11:16:09.327', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p>The typical and widely used <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator" rel="nofollow">PRNG</a>, the <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator" rel="nofollow">linear congruential generator</a> always has a finite (though possibly "long") period. Are there PRNGs that have no finite period?</p>\n</blockquote>\n\n<p>For this question it is not necessary that it be practical or used in real-world implementations.</p>\n', 'Tags': '<reference-request><number-theory><pseudo-random-generators>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-22T19:53:32.883', 'CommentCount': '1', 'AcceptedAnswerId': '18251', 'CreationDate': '2013-11-22T03:12:52.983', 'Id': '18250''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can I generate a random integer through calls to a function that generates one random bit at a time.</p>\n\n<p>Do I place the bit randomly generated at a random position?</p>\n', 'ViewCount': '8', 'ClosedDate': '2014-01-22T18:55:05.407', 'Title': 'Uniform Random Integer Generation', 'LastActivityDate': '2014-01-22T18:45:10.583', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10950', 'Tags': '<pseudo-random-generators>', 'CreationDate': '2014-01-22T18:45:10.583', 'Id': '19896''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Whilst reading up on <a href="https://en.wikipedia.org/wiki/Xorshift" rel="nofollow">Xorshift</a> I came across the following (emphases added):</p>\n\n<blockquote>\n  <p>The following xorshift+ generator, instead, has 128 bits of state, a maximal period of 2^128 \u2212 1 and passes BigCrush:</p>\n  \n  <p><code>[snip code]</code></p>\n  \n  <p>This generator is one of the fastest generator passing BigCrush; however, <strong>it is only 1-dimensionally equidistributed</strong>.</p>\n</blockquote>\n\n<p>Earlier in the article there\'s the following:</p>\n\n<blockquote>\n  <p><code>[snip code]</code></p>\n  \n  <p>Both generators, as all xorshift* generators of maximal period, emit a sequence of 64-bit values <strong>that is equidistributed in the maximum possible dimension</strong>.</p>\n</blockquote>\n\n<p>What does it mean for a sequence to be equidistributed in one dimension vs. multiple dimensions vs. not at all?</p>\n', 'ViewCount': '64', 'Title': "What does it mean for a random number generator's sequence to be only 1-dimensionally equidistributed?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-25T03:28:25.933', 'LastEditDate': '2014-04-23T18:52:36.400', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24038', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10487', 'Tags': '<randomness><statistics><pseudo-random-generators>', 'CreationDate': '2014-04-23T02:03:10.837', 'Id': '24037''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}