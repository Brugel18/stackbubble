{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>In the case of LBAs (Linear Bounded Automaton), in writing a decider for the language</p>\n\n<p>$\\qquad A = \\{ \\langle M,w\\rangle \\mid M\\ \\mathrm{LBA}, w \\in \\mathcal{L}(M) \\}$</p>\n\n<p>we reject the input after a specific number (number of possible different configurations) of computation steps.\nWe say that the machine must be looping after this many steps.\nWhy don't we just check in every step to see if there is a loop (repetition of the same configuration) and if it is the case then just reject the input? </p>\n", 'ViewCount': '79', 'Title': 'Recognizing loops in computation on LBA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:33:38.753', 'LastEditDate': '2013-04-02T07:33:38.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10919', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<linear-bounded-automata>', 'CreationDate': '2013-03-30T17:31:35.793', 'Id': '10916'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>A type-0 grammar generates a recursively enumerable (RE) language. </p>\n\n<p>A RE language is also known as a semi-decidable language. </p>\n\n<p>A semi-decidable language is a particular kind of undecidable language: If a language is semi-decidable, we can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely. </p>\n\n<p>Problem: Provide an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>Answer (I think): The following grammar generates this language: </p>\n\n<pre><code>(a+b+) union (infinite a's)\n</code></pre>\n\n<p>Here is the grammar:</p>\n\n<pre>\nS &rarr; aA | bE\nA &rarr; aA | bB\nB &rarr; bB | &epsilon; | aE\nbE &rarr; aE \nE &rarr; aE\n</pre>\n\n<p>A method for recognizing strings in the language generated by this grammar would return true for strings that are an element of a+b+ and would run indefinitely for strings that are not an element of a+b+</p>\n\n<p>I think that this is an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>If I am incorrect, would you provide an example please?</p>\n", 'ViewCount': '73', 'Title': 'Is this an example of a type-0 grammar that is not context-sensitive?', 'LastActivityDate': '2013-09-21T20:01:25.747', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><formal-grammars><undecidability><linear-bounded-automata>', 'CreationDate': '2013-09-21T20:01:25.747', 'FavoriteCount': '1', 'Id': '14503'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '227', 'Title': 'Complements of Linear Bounded Automata?', 'LastEditDate': '2013-11-11T02:08:06.417', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11306', 'FavoriteCount': '1', 'Body': "<p>Would switching the accept and reject states of an LBA A create a new LBA we'll say A' in which the language of A' is the complement of the language of A? I believe the answer is yes just by working out an example...but I'm not sure on a solid proof...nor am I sure if the fact that I am working with an LBA vs a regular turing machine makes a difference in this case. </p>\n", 'Tags': '<formal-languages><turing-machines><linear-bounded-automata>', 'LastEditorUserId': '11306', 'LastActivityDate': '2013-11-20T21:18:16.770', 'CommentCount': '3', 'AcceptedAnswerId': '18208', 'CreationDate': '2013-11-11T00:39:57.630', 'Id': '17898'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have read that linear bounded automaton is a Non deterministic Turing machine. Why is it so?</p>\n', 'ViewCount': '25', 'Title': 'Why it is said that LBA is a non deterministic Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:35:08.413', 'LastEditDate': '2014-03-22T11:35:08.413', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22922', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<terminology><turing-machines><automata><nondeterminism><linear-bounded-automata>', 'CreationDate': '2014-03-22T01:05:54.747', 'Id': '22919'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have read in <a href="https://en.wikipedia.org/wiki/Halting_problem#Common_pitfalls" rel="nofollow">Wikipedia</a> and some other texts that</p>\n\n<blockquote>\n  <p>The halting problem is [...] decidable for <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" rel="nofollow">linear bounded\n  automata</a> (LBAs) [and] deterministic machines with finite memory.</p>\n</blockquote>\n\n<p>But earlier it is written that the halting problem is an undecidable problem and thus TM can\'t solve it! Since LBA are defined as a type of TM, should the same not hold for them?</p>\n', 'ViewCount': '192', 'Title': 'Why is the halting problem decidable for LBA?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-22T13:15:09.093', 'LastEditDate': '2014-03-22T13:15:09.093', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<turing-machines><automata><undecidability><halting-problem><linear-bounded-automata>', 'CreationDate': '2014-03-22T02:06:19.990', 'Id': '22925'}}