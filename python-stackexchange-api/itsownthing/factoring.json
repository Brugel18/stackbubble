{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Let's say I am trying to break all the numbers from 1 to N down into their prime factors. Once I have the factors from 1 to N-1, is there an algorithm to give me the factors of 1 to N using dynamic programming?</p>\n", 'ViewCount': '280', 'Title': 'Is it possible to use dynamic programming to factor numbers', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-06T20:41:21.420', 'LastEditDate': '2012-05-06T19:56:49.690', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Will Den', 'PostTypeId': '1', 'Tags': '<algorithms><dynamic-programming><factoring>', 'CreationDate': '2012-05-06T16:42:27.970', 'FavoriteCount': '1', 'Id': '1694'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Modern SAT-solvers are very good at solving many real-world examples of SAT instances. However, we know how to generate hard ones: for instance use a <a href="http://cstheory.stackexchange.com/q/6755/1037">reduction from factoring to SAT</a> and give the RSA numbers as input.</p>\n\n<p>This raises the question: what if I take an easy example of factoring. Instead of taking two large primes on $n/2$ bits, what if I take a prime $p$ on $\\log n$ bits and a prime q on $n/\\log n$ bits, let $N = pq$ and the encode $\\mathrm{FACTOR}(N)$ as a SAT instance. $N$ would be an easy number to factor by brute-force search or sieve methods since one of the factors in so small; does a modern SAT-solver with some standard reduction from factoring to SAT also pick up on this structure?</p>\n\n<p><strong>Can top SAT-solvers factor $N = pq$ where $|p| = \\log n$ quickly?</strong></p>\n', 'ViewCount': '190', 'Title': 'Can top SAT-solvers factor easy numbers?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-22T05:29:43.467', 'LastEditDate': '2012-07-22T05:14:29.103', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<complexity-theory><satisfiability><sat-solvers><factoring>', 'CreationDate': '2012-07-22T00:41:51.747', 'FavoriteCount': '4', 'Id': '2857'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '456', 'Title': 'Reducing the integer factorization problem to an NP-Complete problem', 'LastEditDate': '2013-12-19T14:18:14.570', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '12230', 'FavoriteCount': '2', 'Body': "<p>I'm struggling to understand the relationship between NP-Intermediate and NP-Complete. I know that if P != NP based on Lander's Theorem there exists a class of languages in NP but not in P or in NP-Complete. Every problem in NP can be reduced to an NP-Complete problem, however I haven't seen any examples for reducing a suspected NPI problem (such as integer factorization) into an NP-Complete problem. Does anyone know of any example of this or another NPI->NPC reduction?</p>\n", 'Tags': '<np-complete><reductions><factoring>', 'LastEditorUserId': '12230', 'LastActivityDate': '2013-12-19T14:18:14.570', 'CommentCount': '2', 'AcceptedAnswerId': '6605', 'CreationDate': '2012-11-10T00:38:55.120', 'Id': '6588'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '527', 'Title': 'How can P =? NP enhance integer factorization', 'LastEditDate': '2012-11-13T20:01:21.107', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '4365', 'FavoriteCount': '3', 'Body': '<p>If ${\\sf P}$ does in fact equal ${\\sf NP}$, how would this enhance our algorithms to factor integers faster. In other words, what kind of insight would this fact give us in understanding integer factorization better?</p>\n', 'Tags': '<complexity-theory><computability><np-complete><p-vs-np><factoring>', 'LastEditorUserId': '2755', 'LastActivityDate': '2012-11-18T19:44:37.800', 'CommentCount': '0', 'AcceptedAnswerId': '6652', 'CreationDate': '2012-11-13T19:13:56.870', 'Id': '6650'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Optimization factoring:<br>\nInput: $N\\in \\mathbb{N}$<br>\nOutput: All prime factors of $N$</p>\n\n<p>Decision factoring:<br>\nInput: $N, k\\in \\mathbb{N}$<br>\nOutput: True iff $N$ has a prime factor of at most $k$</p>\n\n<p>How can I solve the optimization problem in polynomial time if the decision problem is polynomially solvable?</p>\n', 'ViewCount': '57', 'Title': 'Optimization-factoring $\\le_p$ Decision-factoring', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-26T01:10:28.467', 'LastEditDate': '2012-11-25T20:58:32.787', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '6900', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4730', 'Tags': '<optimization><reductions><factoring>', 'CreationDate': '2012-11-25T20:54:34.053', 'Id': '6897'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Assume i have 2 numbers in binary form (or, more precisely, assume to know the number of their digits, DF1, DF2):</p>\n\n<p>101010101001010101010101010111111111111111111111010101\n10101111111111111111010101</p>\n\n<p>Is there a formula for the exact number of binary digits (DP) of the product?</p>\n\n<pre><code>  DP = F (DF1, DF2)\n</code></pre>\n\n<p>[I need this, in a practical case, to size a target array]</p>\n', 'ViewCount': '219', 'Title': 'Number of digits in a binary product', 'LastActivityDate': '2012-12-21T01:11:24.847', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7527', 'Score': '3', 'OwnerDisplayName': 'Pam', 'PostTypeId': '1', 'OwnerUserId': '5147', 'Tags': '<factoring>', 'CreationDate': '2012-12-20T12:16:24.823', 'FavoriteCount': '1', 'Id': '7525'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Say I have numbers with known factorizations $n = \\prod \\limits _i p_i ^{n_i}$ and  $m = \\prod \\limits _i p_i ^{m_i}$ (where $p_i$ is the $i$th prime).</p>\n\n<p>How hard is it to factorize $m+n$? Is there a more intelligent algorithm than if factorizations of $m$ and $n$ were not known? Assume $n$ and $m$ coprime as it is trivial to make them so.</p>\n\n<p>The fact that $m+n$ will share no factors with $n$ or $m$ seems very helpful for small numbers, but I doubt it offers much for large ones.</p>\n', 'ViewCount': '79', 'Title': 'How hard is it to factorize sum of two numbers', 'LastActivityDate': '2014-03-20T00:45:27.843', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '22836', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5167', 'Tags': '<complexity-theory><factoring>', 'CreationDate': '2013-01-13T11:05:21.217', 'Id': '7921'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to solve exercise 6.5 on page 309 from Richard Crandall\'s "Prime numbers - A computational perspective". It basically asks for an algorithm to factor integers in randomized polynomial time given an oracle for taking square roots modulo $n$.</p>\n\n<p>I think, the basic idea is the following: Given a composite number $n$, to take a random element $r$ in $\\left.\\mathbb{Z}\\middle/n\\mathbb{Z}\\right.$ and square it. If $r$ was a square, $r^2$ can have up to $4$ different square roots and the basic idea of the algorithm is that the oracle has some chance not to choose $\\pm r$, but one of the other two roots. It will turn out that we then can determine a factor of $n$ using Euclidean\'s algorithm. </p>\n\n<p>I formalized this to</p>\n\n<p><strong>Input</strong>: $n=pq\\in\\mathbb{Z}$ with primes $p$ and $q$.</p>\n\n<p><strong>Output</strong>: $p$ or $q$</p>\n\n<ol>\n<li>Take a random number $r$ between $1$ and $n-1$</li>\n<li>If $r\\mid n$ then return $r$ (we were lucky)</li>\n<li>$s:= r^2\\pmod{n}$</li>\n<li>$t:=\\sqrt{s}\\pmod{n}$ (using the oracle)</li>\n<li>If $t\\equiv \\pm r\\pmod{n}$ then goto step 1.</li>\n<li>Return $\\gcd(t-r,n)$</li>\n</ol>\n\n<p>One can show that $t \\not\\equiv \\pm r\\pmod{n}$ implies that $\\gcd(t-r,n)\\neq 1,n$ and therefore get that the return value of the algorithm is a non-trivial factor of $n$. </p>\n\n<p>Inspired by my main question "How do I prove that the running time is polynomial in the bit-size of the input?" I have some follow up questions:</p>\n\n<ol>\n<li>Do I have to show that a lot of numbers between $1$ and $n-1$ are squares? There must be a well-known theorem or easy fact that shows this (well... not well-known to me ;-). </li>\n<li>Are there any more details I have consider? </li>\n<li>Has every square of a square exactly $4$ square roots modulo $n$? </li>\n</ol>\n', 'ViewCount': '109', 'Title': 'Solve Integer Factoring in randomized polynomial time with an oracle for square root modulo $n$', 'LastActivityDate': '2013-01-23T15:57:01.553', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9114', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2103', 'Tags': '<randomized-algorithms><integers><factoring>', 'CreationDate': '2013-01-23T09:39:28.187', 'FavoriteCount': '1', 'Id': '9106'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Consider the following variant of the FACTORING problem (given N,M decide whether N has a prime factor less than M):</p>\n\n<blockquote>\nMULTIPLE-FACTORING: Given three integers $1 \\leq K \\leq M \\leq N$ decide if there are at least $K$ prime factors of $N$ less than $M$\n</blockquote>\n\n<p>FACTORING $\\leq_m$ MULTIPLE-FACTORING (just pick $K=1$) and</p>\n\n<p>MULTIPLE-FACTORING $\\leq_T$ FACTORING (find all factors of $N$ using FACTORING, and count if their number is $\\geq K$)</p>\n\n<p>But is MULTIPLE-FACTORING many one reducible to FACTORING?<br>\n(MULTIPLE-FACTORING $\\leq_m^?$ FACTORING)</p>\n', 'ViewCount': '62', 'Title': 'Karp reduction between FACTORING and a variant of it', 'LastEditorUserId': '140', 'LastActivityDate': '2013-03-11T07:46:28.627', 'LastEditDate': '2013-03-11T07:46:28.627', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '140', 'Tags': '<complexity-theory><reductions><factoring><np>', 'CreationDate': '2013-03-11T00:00:51.463', 'FavoriteCount': '1', 'Id': '10441'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I read somewhere that 3SAT can be used to solve Integer Factorization.</p>\n\n<p>If that is true, could someone teach me a simple example of generating the 3SAT by using a small number? Let's say you are given the number 6, then the factors are 2 and 3.</p>\n", 'ViewCount': '206', 'Title': 'Generating 3SAT circuit for Integer factorization example', 'LastActivityDate': '2013-05-02T11:11:58.450', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11727', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8006', 'Tags': '<np-hard><factoring><3-sat>', 'CreationDate': '2013-05-02T06:11:30.077', 'FavoriteCount': '3', 'Id': '11718'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>My question is related to <a href="http://math.stackexchange.com/questions/465240/constant-time-algorithm-for-finding-greatest-factor-of-odd-composite-number">this question</a> posted on <a href="http://math.stackexchange.com">math.SE</a>:</p>\n\n<blockquote>\n  <p>Given an odd number, what is the quickest (constant-time) algorithm for finding its largest factor and suppose you can call a helper function $B$ which takes as its input $(N, k)$ and outputs True iff $N$ has a factor greater than or equal to $k$? Obviously, the factor cannot be itself. </p>\n</blockquote>\n\n<p>My slightly altered problem statement goes like this.</p>\n\n<blockquote>\n  <p>Given an odd integer $n$, find its largest factor (that is not itself). You can call a function $B(m,k)$ that returns $1$ iff $m$ has a factor smaller than $k$. The function runs in constant time.</p>\n</blockquote>\n\n<p>Can this be done faster than $O(\\log n)$ in the average case (assuming the input is chosen uniformly at random)? Is my altered problem statement any better than the original? Specifically, I know that the probability some large number will have no factor smaller than $M$ is asymptotic to $\\frac{1}{\\log M}$ (see <a href="http://math.stackexchange.com/questions/94645/expected-smallest-prime-factor">A</a>, and <a href="http://math.stackexchange.com/questions/284500/probability-of-a-number-not-having-factors-below-n">B</a>). Can you use this to your advantage?</p>\n\n<p>You can also assume that division is constant time.</p>\n\n<h1>Edit and Attempt Solution:</h1>\n\n<p>$\n\\newcommand{\\ha}[2]{\\left[#1 \\dots #2\\right)} \n\\newcommand{\\expa}[1]{2^{#1}}\n\\newcommand{\\expb}[1]{2^{2^{#1}}}\n\\newcommand{\\abs}[1]{\\left|#1\\right|}\n\\newcommand{\\expv}[1]{\\mathrm{E}\\left(#1\\right)}\n\\newcommand{\\sch}{\\mathbb{S}}\n\\newcommand{\\floor}[1]{\\left\\lfloor#1 \\right\\rfloor}\n\\newcommand{\\logb}[1]{\\log \\log #1}\n$\nThe difference between my problem statement and the original, is the definition of the function $B$. In the original, $B(N,k)$ returns $1$ if $N$ has a factor greater than or equal to $k$; in my version, this happens if $N$ has a factor <em>less than</em> $k$. </p>\n\n<p>By making this change, I aim to capitalize on the fact that the probability of a large $N$ having no factors smaller than $M$ is asymptotic to $(\\log M)^{-1}$. While this fact does not change the worst-case performance of an algorithm, it can change average-case performance. Here, by average case, I mean probabilistic analysis of the algorithm over random, uniformly distributed inputs.</p>\n\n<p>(Note that my question involves only exact algorithms)</p>\n\n<p>I conjectured in my comment to the related question that you can benefit from the probability by changing the way in which you partition your search space when performing a binary search (since it is much more likely for the solution to be in $\\ha{1}{1000}$ instead of $\\ha{1000}{N}$). I also conjectured the algorithm could run in $O(\\logb N)$ average-case.</p>\n\n<h2>Attempted Solution</h2>\n\n<p>I decided to do some work on the problem myself, and I think I have a solution. I haven\'t really done this sort of analysis previously, so I may have some error, and there is definitely a lot missing in terms of details. I think the idea is correct, though. Note that here I find the <em>smallest</em> factor of $N$. We can easily find the largest factor by division (which I assume to be contstant time).</p>\n\n<p>I\'m posting it as part of the question because I\'m not sure if it\'s correct, and I still want to know if there\'s a better way.</p>\n\n<p>Let us partition the search space $\\sch = \\ha{1}{N}$ into disjoint integer intervals, \n$$ r_k = \\ha{\\expb k}{\\expb {k+1}} \\qquad 0 \\leq k \\leq \\floor{\\logb N}$$</p>\n\n<p>Note that it can be that,\n$$ \\expb{\\floor{\\logb N+1}} &gt; N$$\nThat doesn\'t really matter; all we want from the partitioning $r$ is to contain the entire search space.</p>\n\n<p>Now, the probability that the smallest factor of $N$, which we will call $A$, is greater than $m$ is asymptotic to $(\\log m)^{-1}$. \nThen let, $P(A &gt; \\expb{k}) = 2^{-k}$, where $A$ is taken to be a random variable. If we let $P(r_k)$ denote the probability that $A \\in r_i$, we can calculate this as:\n$$P(r_k) = P(a &gt; \\expb{k}) - P(a &gt; \\expb{k+1}) = 2^{-(k+1)}$$</p>\n\n<p>We can identify which partition $r_k$ contains $A$ by calling the function $B(N,\\expb{k})$ up to $\\floor{\\logb N} + 1$ times. After finding the $r_k$, we then perform a binary search for $A$ in the partition, which involves $\\log \\abs{r_k}$ operations. Here we note that:\n$$|r_k|=\\expb{k+1}-\\expb{k} = \\expb{k}\\left(\\expb{k} - 1\\right)\\leq \\expb{k+1}$$</p>\n\n<p>Let $X$ be a random variable representing the number of operations taken by the binary search. The value of $X$ for the case when $A \\in r_k$ is given $X_k = \\log \\expb{k+1} = 2^{k+1}$. The expected value of $X$ is then,\n$$\\expv{X} = \\sum_{k=0}^{\\floor{\\logb N} + 1} X_i P(r_i) = \\sum_{k=0}^{\\floor{\\logb N} + 1} 2^{k+1}\\cdot 2^{-(k+1)} = \\floor{\\logb N} +1$$</p>\n\n<h2>Notes</h2>\n\n<p>I\'ve considered partitioning the search space using triple-exponentiation (e.g. $\\expa{\\expb{k}}$), but that provides no benefit. There might be a way to make the search algorithm inside the partitions faster though, but I\'m not sure how. </p>\n\n<p>You can also reduce the search space drastically (such as to something like $\\sqrt{N}$), but I think this will have a constant speedup at most.</p>\n', 'ViewCount': '195', 'Title': 'Time complexity of finding the largest factor of a number (using a specific oracle)', 'LastEditorUserId': '4543', 'LastActivityDate': '2013-08-17T16:51:14.237', 'LastEditDate': '2013-08-17T16:51:14.237', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4543', 'Tags': '<algorithms><time-complexity><number-theory><factoring>', 'CreationDate': '2013-08-16T09:49:37.510', 'FavoriteCount': '2', 'Id': '13773'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given complex number $C=a+ib$, I want to find two complex numbers $C_1=x+iy$ and $C_2=z+iw$ such that $C=C_1*C_2$ (a,b,x,y, z and w are all non zero integers). This problem is at least as hard as Integer factoring. Prime complex number has one as its only factor.</p>\n\n<p>Does this problem reduce to integer factoring? Is it NP-hard?</p>\n', 'ViewCount': '128', 'Title': 'How hard is factoring a complex number?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-06T15:28:15.030', 'LastEditDate': '2013-09-06T15:28:15.030', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14160', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><number-theory><factoring>', 'CreationDate': '2013-09-05T21:54:52.927', 'Id': '14158'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>It seems that factoring a number known to be composite is in its own interesting little complexity class, e.g. polynomial time using quantum computing even though no one has proved $\\mathsf{P} = \\mathsf{NP}$ for quantum computing. </p>\n\n<p>Are there interesting, non-obvious examples of problems with polynomial-time verifiability for solutions, which have been shown to be polynomial-time equivalent to factoring a composite number into primes, under the classical non-quantum computational model?   </p>\n', 'ViewCount': '83', 'Title': 'Are there problems that are polynomial-time equivalent to factoring composites?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-17T08:13:13.480', 'LastEditDate': '2013-09-17T08:13:13.480', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14368', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9584', 'Tags': '<complexity-theory><complexity-classes><factoring>', 'CreationDate': '2013-09-16T17:55:59.850', 'Id': '14359'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Reading an article on <a href="http://www.ams.org/notices/199612/pomerance.pdf" rel="nofollow">integer factorization</a> I implemented the following -  rather inefficient - factorization method:  </p>\n\n<blockquote>\n  <p>Every odd\n  composite can be factored as a difference of\n  squares: $$ ab = \\left[\\tfrac{1}{2}(a+b)\\right]^2 -\n \\left[\\tfrac{1}{2}(a-b)\\right]^2$$ \n  We can look at values of $f(x) = x^2 - n$ until we find a perfect square and factor.</p>\n</blockquote>\n\n<p>Here\'s my implementation in Python.</p>\n\n\n\n<pre><code>def fermat(n):\n    x = int(np.sqrt(n))+1\n    y = int(np.sqrt(abs(y*y - n)))\n\n    while( n - x*x + y*y != 0):\n        x += 1\n        y = int(np.sqrt(abs(x*x - n)))\n\n    return x, y\n</code></pre>\n\n<p>How expensive are the square root calculations here?  Are they necessary?\nIn order to check I have a perfect square, I compute $\\lfloor \\sqrt{x^2-n}\\rfloor$ many times.  </p>\n', 'ViewCount': '105', 'Title': "integer factoring using Fermat's method", 'LastActivityDate': '2013-10-07T16:54:29.277', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><number-theory><factoring>', 'CreationDate': '2013-10-07T15:49:11.143', 'Id': '14888'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm a fledgling computer science scholar, and I'm being asked to write a paper which involves integer factorization. As a result, I'm having to look into Shor's algorithm on quantum computers.</p>\n\n<p>For the other algorithms, I was able to find specific equations to calculate the number of instructions of the algorithm for a given input size (from which I could calculate the time required to calculate on a machine with a given speed). However, for Shor's algorithm, the most I can find is its complexity: <code>O( (log N)^3 )</code>.</p>\n\n<p>Is there either some way I can find its speed/actual complexity from its Big-O Notation? If not, is there someone who can tell me what I want, or how to find it?</p>\n", 'ViewCount': '161', 'Title': "Shor's Algorithm speed", 'LastActivityDate': '2013-11-04T09:54:16.450', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11162', 'Tags': '<time-complexity><quantum-computing><factoring>', 'CreationDate': '2013-11-04T00:54:24.083', 'Id': '16684'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '281', 'Title': 'CNF Generator for Factoring Problems', 'LastEditDate': '2013-11-07T21:03:05.140', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10572', 'FavoriteCount': '1', 'Body': '<p>I\'ve been reading these:</p>\n\n<ul>\n<li><a href="http://cstheory.stackexchange.com/questions/6755/fast-reduction-from-rsa-to-sat">Fast Reduction from RSA to SAT</a></li>\n<li><a href="http://cgi.cs.indiana.edu/~sabry/cnf.html" rel="nofollow">CNF Generator for Factoring Problems</a> (Also have C code implementation)</li>\n</ul>\n\n<p>I don\'t understand how the reduction from <a href="https://en.wikipedia.org/wiki/Integer_factorization" rel="nofollow">FACT</a> to <a href="https://en.wikipedia.org/wiki/Clausal_normal_form" rel="nofollow">$3\\text{-SAT}$</a> works. Are there any simple articles in which I can read about it?</p>\n\n<p>My final goal is to eventually implement a reduction from $3\\text{-SAT}$ to the <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem" rel="nofollow">undirected Hamiltonian circuit problem</a>.</p>\n', 'Tags': '<algorithms><graph-theory><reductions><factoring><hamiltonian-path>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-13T22:15:26.360', 'CommentCount': '7', 'AcceptedAnswerId': '16805', 'CreationDate': '2013-11-07T06:57:01.380', 'Id': '16789'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Problem: Input is an integer number $x$ that we know factors as $p_{i_1}\\cdot p_{i_2}\\ldots p_{i_n}$, where the $p_{i_j}$'s are distinct prime numbers. Output is the above factorization of $x$.</p>\n\n<p>Do you know any results/references for the time complexity of this factoring problem? </p>\n\n<p>Note: If the $p_{i_j}$'s are not assumed distinct, then the problem is just integer factorization. This is a very special case.</p>\n", 'ViewCount': '18', 'Title': 'Complexity of factoring products of distinct prime numbers', 'LastActivityDate': '2014-05-02T20:00:41.800', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6610', 'Tags': '<complexity-theory><reference-request><time-complexity><factoring>', 'CreationDate': '2014-05-02T16:15:36.450', 'Id': '24319'}},