{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '584', 'Title': 'Why is unification so important to inference engines?', 'LastEditDate': '2012-03-30T07:01:26.807', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '1', 'Body': '<p><sup><em>I am learning <a href="http://en.wikipedia.org/wiki/Automated_theorem_proving">Automated Theorem Proving</a> / <a href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">SMT solvers</a> / <a href="http://en.wikipedia.org/wiki/Proof_assistant">Proof Assistants</a> by myself and post a series of questions about the process, starting <a href="http://cs.stackexchange.com/questions/820/learning-automated-theorem-proving">here</a>.</em></sup></p>\n\n<p>I keep reading about the <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29">Unification Algorithm</a>. </p>\n\n<ul>\n<li>What is it and why is so important to <a href="http://en.wikipedia.org/wiki/Inference_engine">Inference Engines</a>?</li>\n<li>Why is it so important to Computer Science?</li>\n</ul>\n', 'Tags': '<logic><proof-assistants><automated-theorem-proving><smt-solvers><unification>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-30T13:35:19.713', 'CommentCount': '0', 'AcceptedAnswerId': '900', 'CreationDate': '2012-03-29T23:05:40.840', 'Id': '882'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '158', 'Title': 'Unification vs. SAT solver', 'LastEditDate': '2012-09-21T13:12:01.017', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2879', 'FavoriteCount': '1', 'Body': '<p>I read on Wikipedia that <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29">unification</a> is a process of solving the satisfability problem.</p>\n\n<p>At the same time, I know that such solvers are called "SAT solvers" or "SMT solvers". So, are they different names for the same thing?</p>\n\n<p>If you say that they are different, please point out a flaw in my treatment. </p>\n', 'Tags': '<terminology><sat-solvers><unification>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-21T13:12:01.017', 'CommentCount': '1', 'AcceptedAnswerId': '4652', 'CreationDate': '2012-09-21T08:05:59.773', 'Id': '4650'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am looking into Hindler-Milney type system and I am trying to add support for\nthe pair type. In Pierces book, he introduces special language constructs for creation of pairs and getting their elements.</p>\n\n<p>What I am interested in is the following. What if I don't introduce new constructs, yet use special functions with this signatures: </p>\n\n<p>$$pair: \\alpha \\rightarrow \\beta \\rightarrow \\alpha \\times \\beta $$ </p>\n\n<p>$$proj1: \\alpha \\times \\beta \\rightarrow \\alpha$$ </p>\n\n<p>$$proj2: \\alpha \\times \\beta \\rightarrow \\beta $$</p>\n\n<p>If I use Wand's algorithm for type inference, after collecting all equations between type expressions and solving it a bit, I get the following equation\nfor $((pair\\; 2\\;) 4): \\tau$:</p>\n\n<p>$$\\alpha \\rightarrow \\beta \\rightarrow \\alpha \\times \\beta = Int \\rightarrow Int \\rightarrow \\tau$$</p>\n\n<p>It seems to me that the unification algorithm should infer at the end that $\\tau = Int \\times Int$. Is this true? </p>\n\n<p>Do I really need a special construct for pairs? Is there something conceptually wrong with this? Probably their is, so it would be great if someone could point me out. </p>\n\n<p>Note that I would also prefer using special constructs as that way looks cleaner and easier to program with; this question is just for my complete understanding of the subject.</p>\n", 'ViewCount': '51', 'Title': 'Type inference of pair (product) types', 'LastActivityDate': '2013-10-02T20:49:19.097', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14759', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<type-theory><type-inference><unification>', 'CreationDate': '2013-10-02T15:57:00.007', 'Id': '14754'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In unification, given a set of equations, a standard problem is to compute a most general unifier (mgu). I am interested in a somewhat reversed problem. Imagine having a set of equations that do not have an mgu, like this one:</p>\n\n<pre><code>x = a\nx = b\n</code></pre>\n\n<p><code>x</code> here is a variable, whereas <code>a</code> and <code>b</code> are terms. I am interested are there any algorithms that could find a possible replacement for <code>a</code> and <code>b</code> such that the resulting equations have mgu? In the above example, that would be <code>a -&gt; y, b -&gt; y</code>, <code>y</code> being a variable. Lets call this a <em>fix</em>. I am particularly interested in most specific fixes. I could not find anything so far, but this seems like a natural problem, or not?</p>\n', 'ViewCount': '55', 'Title': 'Unification --- most specific unifier', 'LastActivityDate': '2014-03-27T22:32:18.053', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23148', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<algorithms><logic><unification><equality>', 'CreationDate': '2014-03-21T19:28:11.560', 'Id': '22910'}}