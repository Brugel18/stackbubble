{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1205', 'Title': 'Not all Red-Black trees are balanced?', 'LastEditDate': '2012-04-12T05:55:31.997', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '2', 'Body': '<p>Intuitively, "balanced trees" should be trees where left and right sub-trees at each node must have "approximately the same" number of nodes.</p>\n\n<p>Of course, when we talk about red-black trees*(see definition at the end) being balanced, we actually mean that they are <em>height</em> balanced and in that sense, they are balanced. </p>\n\n<p>Suppose we try to formalize the above intuition as follows:</p>\n\n<blockquote>\n  <p><strong>Definition:</strong> A Binary Tree is called $\\mu$-balanced, with $0 \\le \\mu \\leq \\frac{1}{2}$, if for every node $N$, the inequality</p>\n  \n  <p>$$ \\mu \\le \\frac{|N_L| + 1}{|N| + 1} \\le 1 - \\mu$$</p>\n  \n  <p>holds and for every $\\mu&#39; \\gt \\mu$, there is some node for which the above statement fails. $|N_L|$ is the number of nodes in the left sub-tree of $N$ and $|N|$ is the number of nodes under the tree with $N$ as root (including the root).</p>\n</blockquote>\n\n<p>I believe, these are called <em>weight-balanced</em> trees in some of the literature on this topic. </p>\n\n<p>One can show that if a binary tree with $n$ nodes is $\\mu$-balanced (for a constant $\\mu \\gt 0$), then the height of the tree is $\\mathcal{O}(\\log n)$, thus maintaining the nice search properties.</p>\n\n<p>So the question is:</p>\n\n<blockquote>\n  <p>Is there some $\\mu \\gt 0$ such that every big enough red-black tree is $\\mu$-balanced?</p>\n</blockquote>\n\n<hr>\n\n<p>The definition of Red-Black trees we use (from Introduction to Algorithms by Cormen et al):</p>\n\n<p>A binary search tree, where each node is coloured either red or black and</p>\n\n<ul>\n<li>The root is black</li>\n<li>All NULL nodes are black</li>\n<li>If a node is red, then both its children are black.</li>\n<li>For each node, all paths from that node to descendant NULL nodes have the same number of black nodes.</li>\n</ul>\n\n<p>Note: we don\'t count the NULL nodes in the definition of $\\mu$-balanced above. (Though I believe it does not matter if we do).</p>\n', 'Tags': '<data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:55:44.147', 'CommentCount': '19', 'AcceptedAnswerId': '375', 'CreationDate': '2012-03-14T00:15:10.127', 'Id': '342'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1248', 'Title': 'AVL trees are not weight-balanced?', 'LastEditDate': '2012-04-12T05:55:19.533', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '1', 'Body': '<p>In a previous <a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">question</a> there was a definition of weight balanced trees and a question regarding red-black trees. </p>\n\n<p>This question is to ask the same question, but for <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL trees</a>. </p>\n\n<p>The question is, given the definition of $\\mu$-balanced trees as in the other question,</p>\n\n<blockquote>\n  <p>Is there some $\\mu \\gt 0$ such that all big enough AVL trees are $\\mu$-balanced?</p>\n</blockquote>\n\n<p>I presume there is only one definition of AVL trees and there is no ambiguity.</p>\n', 'Tags': '<data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:56:47.213', 'CommentCount': '0', 'AcceptedAnswerId': '424', 'CreationDate': '2012-03-15T16:56:32.180', 'Id': '421'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '472', 'Title': 'Creating a Self Ordering Binary Tree', 'LastEditDate': '2012-04-12T05:55:04.773', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '79', 'FavoriteCount': '1', 'Body': "<p>I have an assignment where I need to make use a binary search tree and alter it to self order itself such that items that are accessed the most (have a higher priority) are at the top of the tree, the root being the most accessed node.</p>\n\n<p>The professor gave me the BST and node struct to work with, but trying to get my head around the algorithm to update the tree as things are being inserted is confusing me.</p>\n\n<p>I know that as the insert is happening, it checks if the current node's data is less or greater than the current node, then recursively goes in the correct direction until it finds a null pointer and inserts itself there. and after it is inserted it increases the priority by 1.</p>\n\n<pre><code>template &lt;class Type&gt;\nvoid BinarySearchTree&lt;Type&gt; ::  insert( const Type &amp; x, BinaryNode&lt;Type&gt; * &amp; t )\n{\n    if( t == NULL )\n        t = new BinaryNode&lt;Type&gt;( x, NULL, NULL );\n    else if( x &lt; t-&gt;element )\n        insert( x, t-&gt;left );\n    else if( t-&gt;element &lt; x )\n        insert( x, t-&gt;right );\n    else\n        t-&gt;priority++;  // Duplicate; do nothing for right now\n}\n</code></pre>\n\n<p>Now I need to figure out when the node is equal, how to re-order the tree so that the current node (who is equal to an already existing node) finds the existing node, increases that node's priority, then shifts it up if the root is a lower priority.</p>\n\n<p>I think I have the idea down that the AVL logic would work, and when a shift would take place, it would be a single rotation right or a single rotation left.</p>\n\n<p>Here's where I'm confused,  don't really know where to start with creating an algorithm to solve the problem. Since the AVL algorithm works with keeping track of the balance of a tree, then rotating nodes left or right accordingly, this tree doesn't need to worry about being balanced, just that the nodes with the highest priority not have children with a higher priority.</p>\n", 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-12T05:55:04.773', 'CommentCount': '0', 'AcceptedAnswerId': '610', 'CreationDate': '2012-03-21T00:05:18.697', 'Id': '559'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '893', 'Title': 'Logarithmic vs double logarithmic time complexity', 'LastEditDate': '2012-04-12T05:54:48.283', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '652', 'FavoriteCount': '2', 'Body': '<p>In real world applications is there a concrete benefit when using $\\mathcal{O}(\\log(\\log(n))$ instead of $\\mathcal{O}(\\log(n))$ algorithms ?</p>\n\n<p>This is the case when one use for instance van Emde Boas trees instead of more conventional binary search tree implementations. \nBut for example, if we take $n &lt; 10^6$ then in the best case the double logarithmic algorithm outperforms the logarithmic one by (approximately) a factor of $5$. And also in general the implementation is more tricky and complex. </p>\n\n<p>Given that I personally prefer BST over VEB-trees, what do you think ?</p>\n\n<p><em>One could easily demonstrate that :</em></p>\n\n<p>$\\qquad \\displaystyle \\forall n &lt; 10^6.\\ \\frac{\\log n}{\\log(\\log(n))} &lt; 5.26146$</p>\n', 'Tags': '<algorithms><complexity-theory><binary-trees><algorithm-analysis><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:54:23.937', 'CommentCount': '3', 'AcceptedAnswerId': '661', 'CreationDate': '2012-03-22T14:23:03.533', 'Id': '654'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '855', 'Title': 'Why does the splay tree rotation algorithm take into account both the parent and grandparent node?', 'LastEditDate': '2012-08-10T11:00:07.597', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '1056', 'FavoriteCount': '2', 'Body': '<p>I don\'t quite understand why the rotation in the splay tree data structure is taking into account not only the parent of the rating node, but also the grandparent (zig-zag and zig-zig operation). Why would the following not work:</p>\n\n<p>As we insert, for instance, a new node to the tree, we check whether we insert into the left or right subtree. If we insert into the left, we rotate the result RIGHT, and vice versa for right subtree. Recursively it would be sth like this</p>\n\n<pre><code>Tree insert(Tree root, Key k){\n    if(k &lt; root.key){\n        root.setLeft(insert(root.getLeft(), key);\n        return rotateRight(root);\n    }\n    //vice versa for right subtree\n}\n</code></pre>\n\n<p>That should avoid the whole "splay" procedure, don\'t you think?</p>\n', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '187', 'LastActivityDate': '2012-08-10T11:00:07.597', 'CommentCount': '0', 'AcceptedAnswerId': '1230', 'CreationDate': '2012-04-11T21:37:01.123', 'Id': '1229'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am struggling with hashing and binary search tree material.\nAnd I read that instead of using lists for storing entries with the same hash values, it is also possible to use binary search trees. And I try to understand what the worst-case and average-case running time for the operations</p>\n\n<ol>\n<li><code>insert</code>, </li>\n<li><code>find</code> and</li>\n<li><code>delete</code></li>\n</ol>\n\n<p>is in worth- resp. average case. Do they improve with respect to lists?</p>\n', 'ViewCount': '1265', 'Title': 'Hashing using search trees instead of lists', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T15:37:46.957', 'LastEditDate': '2012-05-10T15:37:46.957', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<data-structures><time-complexity><runtime-analysis><search-trees><hash-tables>', 'CreationDate': '2012-05-08T21:46:33.920', 'Id': '1739'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I've been given the following problem:</p>\n\n<p>Given a data structure $M$ that is based on comparisons and supports the following methods on a group of numbers $S$:</p>\n\n<ul>\n<li>$\\text{Insert}(x)$ \u2013 add $x$ to $S$</li>\n<li>$\\text{Extract_min}()$ \u2013 remove the minimal element in $S$ and return it </li>\n</ul>\n\n<p>We can implement with a heap the above methods in $O(\\log n)$, however, we're looking at \na bigger picture, a general case that we have no guarantee that $M$ is indeed a heap. Prove that \nno matter what kind of data structure $M$ is, that <strong>at least one</strong> of the methods that $M$ supports must take $\\Omega(\\log n )$.</p>\n\n<p><strong>My solution:</strong></p>\n\n<p>Each sorting algorithm that is based on comparisons must take at the worst case at least $\\Omega(n\\log n)$ \u2013 we'll prove that using a decision tree: if we look at any given algorithm that is based on comparisons, as a binary tree where each vertex is a <em>compare-method</em> between 2 elements: </p>\n\n<ul>\n<li>if the first is bigger than the second element \u2013 we'll go to the left child</li>\n<li>if the second is bigger than the first element \u2013 we'll go to the right child</li>\n</ul>\n\n<p>At the end, we'll have $n!$ leaves that are the options for sorting the elements.</p>\n\n<p>The height of the tree is $h$, then:</p>\n\n<p>$$2^h \\ge n! \\quad\\Longrightarrow\\quad \\log(2^h) &gt;= \\log(n!) \\quad\\Longrightarrow\\quad h \\ge \\log(n!) \\quad\\Longrightarrow\\quad h = \\Omega(n \\log n)$$</p>\n\n<p>Then, if we have a $\\Omega(n \\log n)$ worst case for $n$ elements, then we have a $\\Omega(\\log n)$ for a single element. </p>\n\n<p>I'm not sure regarding this solution, so I'd appreciate for corrections or anything else \nyou can come up with. </p>\n", 'ViewCount': '311', 'Title': 'Prove that for a general data structure - operations Extract_min() and Insert(x) cost $\\Omega(\\log n)$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-26T12:42:03.597', 'LastEditDate': '2012-06-26T12:42:03.597', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '776', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'CreationDate': '2012-06-23T13:38:12.030', 'FavoriteCount': '0', 'Id': '2459'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve been reading a bit of the literature lately, and have found some rather interesting data-structures.</p>\n\n<p>I have researched various different methods of getting update times down to $\\mathcal{O}(1)$ worst-case update time [1-7].</p>\n\n<p>Recently I begun looking into lock-free data-structures, to support efficient concurrent access.</p>\n\n<p><strong>Have any of these worst-case $\\mathcal{O}(1)$ update-time techniques been used in the implementation of lock-free data structures?</strong></p>\n\n<p>I ask because; to me, they seem like the obvious practical extension of this "theoretical enhancement".</p>\n\n<hr>\n\n<ol>\n<li><p><a href="http://www.sciencedirect.com/science/article/pii/0020019083900996">Tarjan, Robert Endre. \u201cUpdating a Balanced Search Tree in O(1) Rotations.\u201d Information Processing Letters 16, no. 5 (1983): 253 \u2013 257.</a></p></li>\n<li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.133.4630">Driscoll, J R, N Sarnak, D D Sleator, and R E Tarjan. \u201cMaking Data Structures Persistent.\u201d In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, 109\u2013121. STOC  \u201986. New York, NY, USA: ACM, 1986.</a></p></li>\n<li><p><a href="http://dx.doi.org/10.1007/BF00299635">Levcopoulos, C., and Mark H. Overmars. \u201cA Balanced Search Tree with O(1) Worst Case Update Time.\u201d Acta Inf. 26, no. 3 (November 1988): 269\u2013277.</a></p></li>\n<li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.9433">Fleischer, Rudolf. A Simple Balanced Search Tree With O(1) Worst-Case Update Time</a></p></li>\n<li><p><a href="http://dx.doi.org/10.1016/0020-0190%2894%2900115-4">Dietz, Paul F, and Rajeev Raman. \u201cA Constant Update Time Finger Search Tree.\u201d Information Processing Letters 52, no. 3 (1994): 147 \u2013 154.</a></p></li>\n<li><p><a href="http://dl.acm.org/citation.cfm?id=998223.998229">Lagogiannis, George, Christos Makris, Yannis Panagis, Spyros Sioutas, and Kostas Tsichlas. \u201cNew Dynamic Balanced Search Trees with Worst-case Constant Update Time.\u201d J. Autom. Lang. Comb. 8, no. 4 (July 2003): 607\u2013632.</a></p></li>\n<li><p><a href="http://www.cs.au.dk/~gerth/papers/stoc02.pdf">Brodal, Gerth St\xf8lting, George Lagogiannis, Christos Makris, Athanasios Tsakalidis, and Kostas Tsichlas. \u201cOptimal Finger Search Trees in the Pointer Machine.\u201d J. Comput. Syst. Sci. 67, no. 2 (September 2003): 381\u2013418.</a></p></li>\n</ol>\n', 'ViewCount': '506', 'Title': 'Lock-free, constant update-time concurrent tree data-structures?', 'LastEditorUserId': '1120', 'LastActivityDate': '2013-05-14T16:27:44.497', 'LastEditDate': '2012-07-18T05:21:06.267', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '1120', 'Tags': '<reference-request><data-structures><time-complexity><concurrency><search-trees>', 'CreationDate': '2012-07-10T20:04:39.177', 'FavoriteCount': '5', 'Id': '2680'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the book 'Introduction to Algorithms 3/e', I have found the following definition of Binary Search Tree property:</p>\n\n<blockquote>\n  <p>Let $x$ be a node in a binary search tree. If $y$ is a node in the left subtree\n  of $x$, then $y.key \\leq x.key$. If $y$ is a node in the right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n\n<p>My confusion is that while implementing binary search trees we either consider that the keys of left-subtree of a node $x$ would be $\\leq x.key$ <strong>or</strong> the keys of right-subtree of a node $x$ would be $\\geq x.key$ but <strong>not both</strong>. That is we follow one of the two convention. But in the property they have included $=$ in both the cases. Where am I wrong?</p>\n\n<p>I would appreciate any idea on this issue.</p>\n", 'ViewCount': '274', 'Title': 'Binary Search Tree Property', 'LastEditorUserId': '29', 'LastActivityDate': '2012-08-29T00:50:34.147', 'LastEditDate': '2012-08-28T11:38:51.780', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2556', 'Tags': '<terminology><data-structures><binary-trees><search-trees>', 'CreationDate': '2012-08-28T05:54:20.237', 'Id': '3345'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a GRE practice question. </p>\n\n<p><img src="http://i.stack.imgur.com/dUavw.png" alt="BST n=8"></p>\n\n<p>If a node in the binary search tree above is to be located by binary tree search, what is the expected number of comparisons required to locate one of the items (nodes) in the tree chosen at random?</p>\n\n<p>(A) 1.75 </p>\n\n<p>(B) 2 </p>\n\n<p>(C) 2.75 </p>\n\n<p>(D) 3 </p>\n\n<p>(E) 3.25</p>\n\n<p>My answer was 3 because $n=8$ and $\\lg(n)$ comparisons should be made, and $\\lg(8) = 3$. But the correct answer is 2.75. Can someone explain the correct answer? Thanks!</p>\n', 'ViewCount': '1385', 'Title': 'Average number of comparisons to locate item in BST', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-16T15:02:35.267', 'LastEditDate': '2012-10-15T08:13:09.373', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6089', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4198', 'Tags': '<binary-trees><probability-theory><search-trees><average-case>', 'CreationDate': '2012-10-15T06:49:28.390', 'Id': '6085'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>From <a href="http://fileadmin.cs.lth.se/cs/Personal/Rolf_Karlsson/lect12.pdf" rel="nofollow">Van Emde Boas trees lecture</a>:</p>\n\n<blockquote>\n  <p>We will use the idea of superimposing a tree of degree ${u^{1/2}}$ on top of\n  a bit vector, but <strong>shrink the universe size recursively</strong> by a square\n  root at each tree level. The ${u^{1/2}}$ items on the \ufb01rst level each hold\n  structures of ${u^{1/4}}$ items, which hold structures of ${u^{1/8}}$ items, and\n  so on, down to size 2.\n  I have a  question regarding van Emde Boas trees :</p>\n</blockquote>\n\n<ol>\n<li>How is the universe size getting reduced ? Aren\'t we just spreading the universe keys which is always constant at $u$ to different levels ? I can not understand the idea of "<strong>shriniking</strong>" the universe size .  I find similar language is used in defining the recursive structure for Van Emde Boas tree in <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" rel="nofollow">Introduction to Algorithms</a> by CLRS also .</li>\n</ol>\n', 'ViewCount': '563', 'Title': 'Explanation of recursive structure of Van Emde Boas Tree', 'LastEditorUserId': '2223', 'LastActivityDate': '2013-01-18T15:27:02.663', 'LastEditDate': '2012-10-22T09:04:38.213', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6197', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><data-structures><algorithm-analysis><search-trees><trees>', 'CreationDate': '2012-10-20T14:15:05.167', 'Id': '6192'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1759', 'Title': 'Proof that a randomly built binary search tree has logarithmic height', 'LastEditDate': '2012-10-28T11:16:30.370', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '1', 'Body': '<p>How do you prove that the expected height of a randomly built <a href="http://en.wikipedia.org/wiki/Binary_search_tree" rel="nofollow">binary search tree</a> with $n$ nodes is $O(\\log n)$? There is a proof in CLRS <em>Introduction to Algorithms</em> (chapter 12.4), but I don\'t understand it.</p>\n', 'Tags': '<data-structures><algorithm-analysis><binary-trees><search-trees><average-case>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T12:56:45.620', 'CommentCount': '4', 'AcceptedAnswerId': '6356', 'CreationDate': '2012-10-27T19:37:43.787', 'Id': '6342'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I am making a red-black search tree, and in my right subtree, I have a black node, then a red node, and it has two black children, the black children further black childrens. As such a lemma has been made that red-black trees with $n$ internal nodes have height at most $2\\log(n+1)$, would this proof still hold for such a black tree?</p>\n', 'ViewCount': '64', 'Title': 'Can you have three consecutive black nodes in red-black search tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T10:55:19.397', 'LastEditDate': '2012-10-28T10:55:19.397', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6344', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2012-10-27T23:52:30.187', 'Id': '6343'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p><img src="http://i.stack.imgur.com/2hUx4.jpg" alt="search tree"></p>\n\n<p><strong>Problem : Two players have in front of\nthem a single pile of objects, say a stack of 7 pennies. The first player divides the original\nstack into two stacks that must be unequal. Each player alternatively thereafter does the\nsame to some single stack when it is his turn to play. The game proceeds until each stack has\neither just one penny or two\u2014at which point continuation becomes impossible. The player\nwho first cannot play is the loser. Show, by drawing a game tree, whether any of the players\ncan always win.</strong></p>\n\n<p>Why is the state 6-1 not going to 3-3-1?If we have 6-1 pennies we can remove 3 pennies from the 6 stack and we have 3-3-1 pennies.So why isn\'t 3-3-1 not a child of 6-1?</p>\n', 'ViewCount': '1689', 'Title': 'Nim game tree + minimax', 'LastActivityDate': '2012-10-28T23:34:33.923', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '6364', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3004', 'Tags': '<artificial-intelligence><search-trees><game-theory>', 'CreationDate': '2012-10-28T23:20:35.870', 'FavoriteCount': '1', 'Id': '6363'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $n$ be the number of strings which are sorted in lexicographical order and stored in a balanced binary search tree. You are provided with a prefix $x$ of which $M$ strings have the prefix $x$. I have devised the following algorithm, where I search until I find the first occurence of the prefix $x$ in one of the nodes. After that I run an inorder traversal on it, such that I print only the ones, that have prefix $x$ and are in order. </p>\n\n<p>For example of sorted strings: $[ACT,BAT,CAT,CAB]$ and the prefix $x = CA$, I would print $CAT$ and $CAB$. </p>\n', 'ViewCount': '170', 'Title': 'Can you have a binary search tree with O(logn + M) property for the following case', 'LastEditorUserId': '31', 'LastActivityDate': '2012-10-30T07:32:51.260', 'LastEditDate': '2012-10-29T08:36:24.140', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '6381', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<binary-trees><search-trees>', 'CreationDate': '2012-10-29T05:32:13.887', 'Id': '6368'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '748', 'Title': 'What is the time complexity of calling successor $n$ times during tree traversal?', 'LastEditDate': '2012-10-30T10:28:52.880', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '2', 'Body': '<p>According to some <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/binarySearchTree.htm" rel="nofollow">sources</a>, the time complexity of finding the successor of a node in a tree is $O(h)$. So, if the tree is well balanced, the height $h=\\log n$, and the successor function takes time $O(\\log n)$. \nYet, according to this <a href="http://stackoverflow.com/questions/12447499/time-complexity-of-bst-inorder-traversal-if-implemented-this-way">stackoverflow post on the time complexity of an inorder traversal of a binary search tree</a>, if you call the successor function $n$ times, the time complexity is $O(n)$.</p>\n\n<p>What resolves the apparent contradiction between:</p>\n\n<blockquote>\n  <p>If I call the sucessor function once, the time complexity is $O(h)$, which could be $O(n)$ or $O(\\log n)$, depending on the kind of tree.</p>\n</blockquote>\n\n<p>AND</p>\n\n<blockquote>\n  <p>If I call the successor $n$ times, the time complexity is $O(n)$ in a balanced tree.</p>\n</blockquote>\n\n<p>Shouldn\'t tree traversal take $O(n^2)$ or $O(n\\log n)$ time?</p>\n', 'Tags': '<binary-trees><search-trees>', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-10-30T15:34:30.833', 'CommentCount': '3', 'AcceptedAnswerId': '6383', 'CreationDate': '2012-10-30T03:10:00.910', 'Id': '6378'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know the term <strong>order</strong> of a B-tree. Recently I heard a new term  <strong>B tree with minimum degree of 2.</strong><br>\nWe know the degree is related with a node but what is degree of a tree.<br>\nIs degree imposes any kind of a restriction on height of a B-tree?  </p>\n', 'ViewCount': '1586', 'Title': 'B-Tree Is degree and order both are the same thing related to a B-Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T10:30:15.287', 'LastEditDate': '2014-02-21T10:30:15.287', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3075', 'Tags': '<terminology><data-structures><search-trees><dictionaries>', 'CreationDate': '2012-11-21T05:17:52.773', 'FavoriteCount': '1', 'Id': '6799'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Problem:</strong> Suppose $V$ is an <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL tree</a> (a self-balancing binary search tree) of $n$\n  elements. After the insertion of $n^2$ elements, what would be its\n  height?</p>\n</blockquote>\n\n<p><strong>My idea:</strong> the height of an AVL tree is originally $O(\\log(n))$ where $n$ is the number of elements. After insertion of $n^2$ elements, its height will be:$$O(\\log(n+n^2))=O(\\log(n^2))=O(2\\log(n))=O(\\log(n))$$</p>\n\n<p>My answer would be $O(\\log(n))$ but I\'m having doubts.</p>\n\n<p>Why is the asymptotic complexity of the result the same despite the fact that there are more elements?</p>\n', 'ViewCount': '82', 'Title': 'Height of AVL after entries', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-29T07:36:40.940', 'LastEditDate': '2012-11-29T06:08:02.270', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7007', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<algorithms><asymptotics><binary-trees><search-trees>', 'CreationDate': '2012-11-28T15:22:50.797', 'Id': '6995'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A BTree has a $k$ value that determines that every node has $k$ to $2k$ children. When a node has $2k$ keys it needs to be split into two nodes.</p>\n\n<p>Let's say I want to create a $k/(2k-x)$ tree. (like a 2-3 tree that follows the BTree rules, but isnt $k/2k$)</p>\n\n<p>What is the possible range of $x$? The tree must follow the behavior of a BTree, meaning it needs to hold keys and split accordingly.</p>\n", 'ViewCount': '188', 'Title': 'B-tree branching factor boundaries', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-16T21:30:40.277', 'LastEditDate': '2012-12-16T21:30:40.277', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5078', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2012-12-16T03:55:01.130', 'Id': '7428'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose that we take an initial search problem and we add $c &gt; 0$ to the costs on all edges. Will <a href="http://en.wikipedia.org/wiki/Uniform-cost_search" rel="nofollow">uniform-cost search</a> return the same answer as in the initial search problem?</p>\n\n<p>Definitions: Uniform-cost search is also known as lowest cost first. Initial search problem can be any graph with a start and a goal state. You just apply the uniform cost search algorithm on the graph. </p>\n', 'ViewCount': '426', 'Title': 'Uniform-cost Search Problem', 'LastEditorUserId': '867', 'LastActivityDate': '2013-11-19T07:11:47.707', 'LastEditDate': '2013-01-29T03:40:50.913', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6601', 'Tags': '<graphs><search-algorithms><search-trees><search-problem>', 'CreationDate': '2013-01-29T02:33:45.660', 'Id': '9265'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '143', 'Title': 'Are probabilistic search data structures useful?', 'LastEditDate': '2013-03-03T16:57:40.847', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7022', 'FavoriteCount': '1', 'Body': '<p>A SkipList provides the same $O(\\log n)$ bounds for search as a balanced tree with the advantage that rebalancing isn\'t necessary. Since the SkipList is constructed using random coin flips, these bounds only hold as long as the structure of the SkipList is sufficiently "balanced". In particular, with probability $1/n^c$ for some constant $c&gt;0$, the balanced structure might be lost after inserting an element.</p>\n\n<p>Let\'s say I want to use a skip list as a storage backend in a web application that potentially runs forever. So after some polynomial number of operations, the balanced structure of the SkipList is very likely to be lost. </p>\n\n<p>Is my reasoning correct? Do such probabilistic search/storage data structures have practical applications and if so, how is the above problem avoided? </p>\n\n<p>Edit: I\'m aware that there are deterministic variants of the SkipList, which, are much more complicated to implement in comparison to the (classic) randomized SkipList.</p>\n', 'Tags': '<data-structures><search-trees><probabilistic-algorithms>', 'LastEditorUserId': '7022', 'LastActivityDate': '2013-03-08T13:10:42.580', 'CommentCount': '1', 'AcceptedAnswerId': '10239', 'CreationDate': '2013-03-03T14:09:52.280', 'Id': '10229'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1020', 'Title': 'Colour a binary tree to be a red-black tree', 'LastEditDate': '2013-04-03T16:56:13.100', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '2', 'Body': '<p>A common interview question is to give an algorithm to determine if a given binary tree is height balanced (AVL tree definition).</p>\n\n<p>I was wondering if we can do something similar with Red-Black trees.</p>\n\n<blockquote>\n  <p>Given an arbitrary uncoloured binary tree (with NULL nodes), is there a "fast" algorithm which can determine if we can colour (and find a colouring) the\n  nodes Red/Black so that they satisfy all the properties of a Red-Black\n  tree (definition as in this <a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">question</a>)?</p>\n</blockquote>\n\n<p>An initial thought was that we can just remove the NULL nodes and try to recursively verify if the resulting tree can be a red-black tree, but that didn\'t seem to go anywhere.</p>\n\n<p>I did (a brief) web search for papers, but could not seem to find any which seem to deal with this problem.</p>\n\n<p>It is possible that I am missing something simple.</p>\n', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '139', 'LastActivityDate': '2013-04-20T17:57:19.710', 'CommentCount': '1', 'AcceptedAnswerId': '10999', 'CreationDate': '2013-04-03T08:02:32.960', 'Id': '10990'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '183', 'Title': 'Number of possible search paths when searching in BST', 'LastEditDate': '2013-04-11T23:41:46.050', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'FavoriteCount': '1', 'Body': "<p>I have the following question, but don't have answer for this. I would appreciate if my method is correct :</p>\n\n<p>Q. When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70, 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root node containing the value 60? </p>\n\n<p>(A) 35 (B) 64 (C) 128 (D) 5040 </p>\n\n<p>From the question, I understand that all nodes given have to be included in traversal and ultimately we have to reach the key, 60. For example, one such combination would be : </p>\n\n<p>10, 20, 40, 50, 90, 80, 70, 60. </p>\n\n<p>Since we have to traverse all nodes given above, we have to start either with 10 or 90. If we start with 20, we will not reach 10 (since 60 > 20 and we will traverse right subtree of 20)</p>\n\n<p>Similarly, we cannot start with 80, because we will not be able to reach 90, since 80>60, we will traverse in left sub tree of 80 &amp; thus not reaching 90. </p>\n\n<p>Lets take 10. The remaining nodes are 20, 40, 50, 70, 80, 90. Next node could be either 20 or 90. We cannot take other nodes for same earlier mentioned reason.</p>\n\n<p>If we consider similarly, at each level we are having two choices. Since there are 7 nodes, two choices for first 6 &amp; no choice for last one. So there are totally </p>\n\n<p>$2*2*2*2*2*2*1$ permutations = $2^6$ = $64$</p>\n\n<ol>\n<li><p>Is this a correct answer?</p></li>\n<li><p>If not, whats the better approach?</p></li>\n<li><p>I would like to generalize. If $n$ nodes are given then total possible search paths would be $2^{n-1}$</p></li>\n</ol>\n", 'Tags': '<data-structures><combinatorics><binary-trees><search-trees><graph-traversal>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T23:41:46.050', 'CommentCount': '0', 'AcceptedAnswerId': '11048', 'CreationDate': '2013-04-05T07:42:32.627', 'Id': '11043'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been reading about AVL trees, at the moment I\'m trying to figure out how to determine the height of a tree and how to draw an AVL tree of some height with minimum number of elements.  </p>\n\n<p>In a tutorial I found that this: would be a AVL tree of height 7<br>\n<img src="http://i.stack.imgur.com/xc90l.jpg" alt="enter image description here"></p>\n\n<p>And this AVL tree with the height 4<br>\n<img src="http://i.stack.imgur.com/ZseOY.jpg" alt="enter image description here"></p>\n\n<p>This is really confusing by the look I would guess that both of them are of height 4. I\'m fairly new to data structures, I could not find a simple documentation/tutorial regarding this most of what i found was about Insertion/Deletion with AVL trees.  </p>\n\n<p>So is the top tree of height 7 if not how would I draw it with the minimal number of elements. I understand the each sub tree would have to be balanced.</p>\n', 'ViewCount': '362', 'Title': 'AVL tree with fixed height and as few elements as possible', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:57:27.700', 'LastEditDate': '2013-04-07T12:57:27.700', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7619', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-04-07T01:48:44.733', 'Id': '11086'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A program takes as input a balanced binary search tree with $n$ leaf nodes and computes the value of a function $g(x)$ for each node $x$. If the cost of computing $g(x)$ is </p>\n\n<p>$\\qquad \\min(\\#\\text{leaves in } L(x), \\#\\text{leaves in } R(x))$</p>\n\n<p>for $L(x), R(x)$ the left resp. right subtree of $x$, then the worst-case time complexity of the program is</p>\n\n<ol>\n<li>$\\Theta(n)$</li>\n<li>$\\Theta(n \\log n)$</li>\n<li>$\\Theta(n^2)$ </li>\n<li>$\\Theta(n^2 \\log n)$</li>\n</ol>\n\n<p>I am actually looking for a subtle hint. </p>\n', 'ViewCount': '492', 'Title': 'Finding no. of leaf nodes for each node in a BST', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-22T14:55:46.203', 'LastEditDate': '2013-04-12T10:03:59.117', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11254', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><binary-trees><search-trees>', 'CreationDate': '2013-04-12T08:03:52.183', 'Id': '11252'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><img src="http://i.stack.imgur.com/reeMb.jpg" alt="Pruning"></p>\n\n<p>I am studying some old past test questions.  Is this search tree correctly pruned?</p>\n', 'ViewCount': '140', 'Title': 'Did I correctly prune this min-max search tree using alpha-beta pruning?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T21:55:57.437', 'LastEditDate': '2013-04-14T11:51:58.280', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11312', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7721', 'Tags': '<search-trees><check-my-answer>', 'CreationDate': '2013-04-14T09:36:32.457', 'Id': '11308'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '216', 'Title': 'Is there a binary search tree datastructure which can avoid becoming badly weight-balanced?', 'LastEditDate': '2013-05-04T09:38:43.037', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2152', 'FavoriteCount': '1', 'Body': '<p>This is a follow-up question of "<a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">Not all Red-Black trees are balanced?</a>" and "<a href="http://cs.stackexchange.com/questions/421/avl-trees-are-not-weight-balanced">AVL trees are not weight-balanced?</a>".$\\def\\le{\\leqslant}\\def\\ge{\\geqslant}$</p>\n\n<blockquote>\n  <p><strong>Definition:</strong> For a rooted tree $T$ and a vertex $v \\in V(T)$, let $L_T(v)$ be the number of nodes in the left-subtree from $v$, and $N_T(v)$ be the number of nodes in the subtree rooted at $v$. We say that $T$ is <em>$\\mu$-balanced</em>, with $0 \\le \\mu \\le \\frac{1}{2}$, if for every node $v \\in V(T)$ the inequality\n  $$ \\mu \\le \\frac{L_T(v) + 1}{N_T(v) + 1} \\le 1 - \\mu$$\n  holds, and if $\\mu$ is minimal subject to this inequality holding.</p>\n</blockquote>\n\n<p>(These are apparently also known as  <em>weight-balanced</em> trees in some of the literature.) A tree which is $\\mu\'$-balanced for some $\\mu\' &lt; \\mu$, we will say is <strong>&mu;-imbalanced</strong>.</p>\n\n<p>The above-linked posts essentially show that neither <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL trees</a>, nor <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black trees</a>, can be guaranteed to be $\\mu$-balanced for any $\\mu &gt; 0$: that is, for any such $\\mu$, one can provide a sequence of inputs to be inserted so that the resulting tree is $\\mu$-imbalanced.</p>\n\n<p><strong>Question.</strong> Is there any binary search tree structure, with the usual characteristics of $O(\\log n)$ insertion and search time, and some $m &gt; 0$, such that the tree will always be $\\mu$-balanced for some $\\mu &gt; m$?</p>\n', 'Tags': '<data-structures><search-trees>', 'LastEditorUserId': '2448', 'LastActivityDate': '2013-05-04T09:38:43.037', 'CommentCount': '2', 'AcceptedAnswerId': '11758', 'CreationDate': '2013-05-03T13:19:28.613', 'Id': '11756'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The idea of <a href="http://en.wikipedia.org/wiki/Splay_tree">splay trees</a> is very nice as they move frequently accessed elements to the top, which can gain a considerable speed up in many applications. The drawback is that in the worst case an operation can have $O(n)$ complexity. \n(Although amortized bounds are $O(n\\log n)$ <a href="http://en.wikipedia.org/wiki/Splay_tree#Performance_theorems">if we perform at least $n$ operations</a>.)</p>\n\n<p>Is there a self-adjusting search tree structure that has both? Favoring recently accessed elements and with worst $O(\\log n)$ complexity for a single operation?</p>\n', 'ViewCount': '286', 'Title': 'Is there a binary tree structure with fast access to recently accessed elements and worst $O \\left( \\log n \\right )$ complexity?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-09-24T06:09:43.897', 'LastEditDate': '2013-05-07T07:14:06.917', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2448', 'Tags': '<data-structures><binary-trees><search-trees><splay-trees>', 'CreationDate': '2013-05-04T09:54:49.780', 'FavoriteCount': '2', 'Id': '11772'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We're asked to prove the above mentioned lemma but I having a hard time proving this rigorously.</p>\n\n<p>We did prove that given $n$ values AVL's height is $\\Theta\\left (\\log \\left ( n \\right ) \\right )$ So I thought that after inserting a $\\frac{n}{2}$ values the height of the tree will be at least $\\Theta\\left (\\log \\left ( \\frac{n}{2} \\right ) \\right )$ which and because each isertion we make is now on a tree with at least $\\frac{n}{2}$ and insertion is $\\log \\left (h \\right ) $ where $h$ is the height of the tree.</p>\n\n<p>So for a function $F$ using the previous logic:</p>\n\n<p>$\\begin{align}  F &amp;= \\frac{n}{2} \\times \\log \\left (h \\right ) \n\\\\&amp; \\geq \\frac{n}{2} \\times \\log \\left (\\frac{n}{2} \\right ) \n\\\\&amp;=\\Omega\\left( n\\log \\left (n \\right )  \\right)\n\\end{align}$</p>\n\n<p>But I have a few issues with this </p>\n\n<ul>\n<li>This does feel fishy to me don't know why but it doesn't feel like a good well defined calculus proof :)</li>\n<li>I'm not sure which way to take it in order to prove the upper boud i.e $\\mathcal{O}$</li>\n</ul>\n\n<p>If I haven't given all the required information I'd be glad to.</p>\n", 'ViewCount': '78', 'Title': 'Prove that inserting $n$ sorted values in to an AVL using AVL insertion is $\\Theta\\left (n \\log \\left ( n \\right ) \\right )$', 'LastEditorUserId': '31', 'LastActivityDate': '2013-05-05T16:35:06.797', 'LastEditDate': '2013-05-05T16:35:06.797', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11808', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8004', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'CreationDate': '2013-05-05T15:30:17.330', 'Id': '11807'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A lot of articles say that hash tree traversal cost to any <em>randomly</em> chosen leaf is $\\mathcal{O}(\\log_2 N)$ ($N$ is a number of leafs) and that is right. If we have a tree of 8 leafs it will take us at most 3 operations to get to any leaf, if we have a tree of 64 leafs it will take us at most 5 operations etc.</p>\n\n<p>But lets say I need to check <strong><em>every</em></strong> leaf sequentially to check if <strong><em>all blocks</em></strong> of a file are correct, then I would need $\\mathcal{O}(N \\log_2 N)$ operations. Or if I would check every second leaf (just left leaf of every pair) I would need $\\mathcal{O}((\\frac{N\\log_2 N}{2}))$ operations. That is, I will need $\\mathcal{O}(\\log_2 N)$ operations for every leaf? Which leads to exponentially growing evaluations curve and it would be better to use simple hash list or hash chain? Am I right?</p>\n\n<p>Or I just don\'t see/know something?</p>\n\n<p><img src="http://i.stack.imgur.com/Mnvvt.jpg" alt=""></p>\n\n<p>*Note, chart has logarithmic scale</p>\n', 'ViewCount': '102', 'Title': 'Sequential hash tree traversal', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-14T18:11:32.220', 'LastEditDate': '2013-05-14T10:59:03.967', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8111', 'Tags': '<data-structures><search-trees><graph-traversal><hash-tables>', 'CreationDate': '2013-05-10T07:16:57.917', 'Id': '11927'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In both <a href="https://mitpress.mit.edu/books/introduction-algorithms" rel="nofollow">CLRS</a> (third edition) and Erik Demaine\'s <a href="https://www.youtube.com/watch?v=AjFtTQevtq0" rel="nofollow">lecture</a>, the van Emde Boas tree is defined to store <code>max</code> but not <code>min</code> recursively.  Why store max recursively?</p>\n\n<p>If it is <em>not</em> stored recursively, insert(<em>V</em>, <em>x</em>) can take advantage of the special case where a cluster or summary contains one element (<code>min = max</code>), although I think the advantage gained from this is insignificant.  Keith Schwarz implements it this way in his Archive of Interesting Code.  So why do CLRS and Erik not make use of this optimization in the algorithm?  Is it actually a mistake?</p>\n', 'ViewCount': '142', 'Title': 'van Emde Boas tree: why store max recursively?', 'LastEditorUserId': '8460', 'LastActivityDate': '2013-11-01T10:09:31.133', 'LastEditDate': '2013-06-02T00:10:12.777', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8460', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2013-05-31T06:01:44.097', 'Id': '12392'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Well, i have a binary search tree $T$ that is equilibrated by height witch has $2^d+c$ nodes ($c&lt;2^d$). \nWhat is the number of comparisons that will occur in the worst case scenario, if we ask whether $k\\in V(T)$ and why does it arise?</p>\n', 'ViewCount': '274', 'Title': 'Worst case scenario in binary search tree retrieval', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-14T21:57:25.843', 'LastEditDate': '2013-06-14T12:13:40.983', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'Mihai Alin', 'PostTypeId': '1', 'Tags': '<graph-theory><search-trees><search-problem>', 'CreationDate': '2013-06-13T18:46:27.367', 'Id': '12667'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Working on a project for my Data Structures class. </p>\n\n<p>I\'ve implemented a Red/Black tree in Java. One of the operations required of the data structure is "find a node which has a key of at least n". The leaves of the tree are the sentinel node.</p>\n\n<p>My initial thought was using the regular search with modifications:</p>\n\n<ol><li>Search for a node with key == n</li><li>If result == sentinel, call getSuccessor on parent until a node with key > n is found</li></ol>\n\n<p>I -think- this is $O(m*lgm)$ ($m$ being number of nodes in the tree) at the worst case. </p>\n\n<p>Inspired by the getSuccessor code - if right subtree of target node is empty, find smallest ancestor which has a left child also an ancestor - was wondering if there is a better way to do this.</p>\n\n<p>Would appreciate any advice; thanks. </p>\n', 'ViewCount': '84', 'Title': 'Find node with key of at least n in a binary search tree', 'LastActivityDate': '2013-06-30T08:45:47.077', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12975', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8929', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-06-29T21:31:49.023', 'Id': '12971'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a valid binary search tree whose keys are unique real numbers, and a set of $k$ pointers to the $k$ minimum elements in the tree, will the BST property be maintained if I replace all $k$ elements with the average of the $k$ elements? </p>\n\n<p>The BST property as given in Corman:</p>\n\n<blockquote>\n  <p>Let $x$ be a node in a binary search tree. If $y$ is a node in the\n  left subtree of $x$, then $y.key \\leq x.key$. If $y$ is a node in the\n  right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n\n<p>I've tried this with a few test cases for $k=3$ and a few different trees, and it seems to hold, but I'm not sure if it actually does <em>and how I could prove it</em>.</p>\n", 'ViewCount': '122', 'Title': 'Binary Search Tree: Replace $k$ min elements with their average', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-30T20:46:51.233', 'LastEditDate': '2013-06-30T19:15:30.497', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '12998', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<data-structures><proof-techniques><search-trees>', 'CreationDate': '2013-06-30T09:09:43.920', 'Id': '12984'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>As I think of data structures I studied and dealt with, they are all optimized to retrieve/put  a random element, to perform optimally based on unspoken assumption that each element has equal odds of being asked for (e.g. Red-Black trees).</p>\n\n<p>By the nature of my program, I need to maintain an online dictionary of items that typically serves items that were added last.</p>\n\n<p>That is, the later an item has been added, the higher the likelihood of it being retrieved back in the nearest future.</p>\n\n<p>Speaking more formally, let's define a set $S$ of pair $(k_i, d_i)$, where $k_i \\in K $ and $K$ has a comparison operator $\\leq$ defined, $d_i \\in D$. Let $p(k)$ be the probability of our need to retrieve pair $(k, d)$.</p>\n\n<p>What is an efficient way to store $S$ with regard to function $p$ ?</p>\n", 'ViewCount': '117', 'Title': '"Last Come => More Relevant" data structures', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-13T10:12:31.957', 'LastEditDate': '2013-07-12T07:34:39.067', 'AnswerCount': '3', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9134', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2013-07-11T17:29:37.650', 'Id': '13231'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My similarity search seminar topic are <a href="https://en.wikipedia.org/wiki/M-tree" rel="nofollow">M-trees</a>. I would like to give some examples about where they are practically applied, but I can\'t find anything googling. </p>\n\n<p>Does someone know if M-trees are still used and what for? I am interested in answers regarding both practice and applied research.</p>\n', 'ViewCount': '96', 'Title': 'Where are M-Trees applied in practice?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-30T18:04:07.047', 'LastEditDate': '2013-07-30T16:40:04.920', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9407', 'Tags': '<data-structures><search-trees><applied-theory>', 'CreationDate': '2013-07-29T16:39:35.700', 'Id': '13493'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><img src="http://i.stack.imgur.com/oB6Zq.jpg" alt="enter image description here"></p>\n\n<p>From the above image, while trying to maintain an <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL tree data structure</a>, how would the tree look after inserting the value 10? Also, if anyone has any suggestions or simple method of rotating, feel free to share. I am a bit lost with this idea of maintaining a certain height in this data structure.</p>\n', 'ViewCount': '200', 'Title': 'How does insertion work in an AVL tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-08T18:19:50.890', 'LastEditDate': '2013-08-05T20:31:26.483', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13582', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9490', 'Tags': '<data-structures><trees><search-trees>', 'CreationDate': '2013-08-03T05:50:15.613', 'Id': '13581'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have </p>\n\n<ol>\n<li>two red-black trees $T_1$ of black height $H_1$ and $T_2$ of black height $H_2$</li>\n<li>such that all the nodes $N$ belonging to $T_1$ are less than (in value) all the nodes $N$ of $T_2$</li>\n<li>and a key $K$ such that $K$ is greater than all the nodes of $T_1$ and less than all the nodes of $T_2$.</li>\n</ol>\n\n<p>I wanted to devise an algorithm to combine $T_1$, $K$ and $T_2$ into a single red-black tree $T$.</p>\n\n<p>I could delete each element from either $T_1$ or $T_2$ and put it in other tree. But that will give me an algorithm of time-complexity $2^{H_1}$ or $2^{H_2}$ (depending on the tree from which I have deleted the elements from). I would like to have an algorithm which is $O(\\max(H_1,H_2))$.</p>\n\n<blockquote>\n  <p>Definitions : <br><br> Black-height is the number of black-colored nodes in\n  its path to the root.</p>\n  \n  <p>Red-Black tree : A binary search tree, where each node is coloured\n  either red or black and</p>\n  \n  <ul>\n  <li>The root is black All NULL nodes are black</li>\n  <li>If a node is red, then both its children are black </li>\n  <li>For each node, all paths from that node to descendant NULL nodes have the same number of black nodes.</li>\n  </ul>\n</blockquote>\n', 'ViewCount': '561', 'Title': 'Joining two red-black trees', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-12T23:42:30.383', 'LastEditDate': '2013-08-11T13:20:15.663', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6699', 'Tags': '<algorithms><data-structures><search-trees>', 'CreationDate': '2013-08-11T07:06:44.943', 'Id': '13703'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to keep a collection on integers in the range 0 to 65535 so that I can quickly do the following:</p>\n\n<ul>\n<li>Insert a new integer</li>\n<li>Insert a range of contiguous integers</li>\n<li>Remove an integer</li>\n<li>Remove all integers below an integer</li>\n<li>Test if an integer is present</li>\n</ul>\n\n<p>My data has the property that it often contains runs of integers in the collection.  For example, the collection might at one point in time be:</p>\n\n<pre><code>{ 121, 122, 123, 124, 3201, 3202, 5897, 8912, 8913, 8914, 18823, 18824, 40891 }\n</code></pre>\n\n<p>The simplest approach is just to use a balanced binary tree like the C++ std::set, however, using that, I am not leveraging the fact that I often have runs of numbers.  Perhaps it would be better to store a collection of ranges?  But that means a range needs to be able to be broken up if an integer in its middle is removed, or joined together if the space between two ranges in filled in.</p>\n\n<p>Are there any existing data structures that would be well suited for this problem?</p>\n', 'ViewCount': '402', 'Title': 'What data structure would efficiently store integer ranges?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-26T17:37:25.270', 'LastEditDate': '2013-08-26T11:07:37.533', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7284', 'Tags': '<data-structures><efficiency><search-trees><integers>', 'CreationDate': '2013-08-22T20:22:55.240', 'Id': '13874'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having trouble finding materials on what 'finger search' is, in the context of a red black tree.</p>\n\n<p>Even Wikipedia has a very short page about that, could you refer me or explain what kind of search is that.</p>\n", 'ViewCount': '119', 'Title': 'finger search on a red black tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T07:28:09.240', 'LastEditDate': '2013-09-16T07:28:09.240', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14292', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9851', 'Tags': '<terminology><data-structures><search-trees>', 'CreationDate': '2013-09-13T17:11:10.787', 'Id': '14291'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If we have $n$ elements $s_1, \\dots, s_n$ and build a kind of treap (tree-heap) out of it. Each $s_k$ has a priority, which is an integer in $\\{ 1, 2, 3 \\dots, \\lceil \\log n \\rceil\\}$. Since the priorities will have duplicates, I just want the treap the verify that for each node $s_k$, all the nodes in its right and left subtrees have smaller priority. </p>\n\n<p>Is there a way to find the expected depth of this tree?</p>\n', 'ViewCount': '96', 'Title': 'Expected depth of modified kind of treap', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T09:06:30.243', 'LastEditDate': '2013-09-18T09:06:30.243', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10186', 'Tags': '<algorithm-analysis><data-structures><search-trees><heaps>', 'CreationDate': '2013-09-17T21:35:36.280', 'Id': '14391'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I can't figure out or find on the Internet what is the time complexity of B-tree in-order depth-first iteration. Can you help me out here, please?</p>\n\n<p>What is the characteristic operation we're using to estimate the running time here, is it a disk seek? Assuming that we have enough space to temporarily store the number of tree nodes equal to the height of the tree, it looks like we will only need to load each node once and keep it in memory while we're examining its children. Am I right?</p>\n", 'ViewCount': '53', 'Title': 'What is time complexity of in-order depth-first iteration over keys in a B-tree?', 'LastEditorUserId': '10378', 'LastActivityDate': '2013-09-28T18:19:24.870', 'LastEditDate': '2013-09-28T18:19:24.870', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10378', 'Tags': '<time-complexity><search-trees>', 'CreationDate': '2013-09-28T14:01:24.307', 'Id': '14654'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following problem:</p>\n\n<blockquote>\n  <p>Does inserting a node into a red-black tree and then immediately deleting it always result in the original tree? Prove that it does or give a counter-example if it does not. Does deleting a leaf node from a red-black tree, then reinserting the same node always result in the original tree? Prove that it does or give a counter-example if it does not.</p>\n</blockquote>\n\n<p>I have used several demos, but none of them have made much sense to answer this question. I havent been sure as to yes or no, I am still new to binary trees.</p>\n', 'ViewCount': '141', 'Title': 'Does inserting and immediately removing a node change a red-black tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T15:26:08.840', 'LastEditDate': '2013-10-04T07:00:36.170', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10497', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-10-04T05:02:22.753', 'Id': '14804'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m looking at the lecture review for one of my computer science classes and I\'m having trouble coming up with an answer. Could someone help me work through it?</p>\n\n<p>Background: </p>\n\n<p>Let the balance factor of a node be defined by $\\left| height(\\text{right sub tree}) - height(\\text{left sub tree}) \\right|$.</p>\n\n<p>Questions:</p>\n\n<ol>\n<li><strong>Give the balance factor for the nodes in slides 27-30 (given below)</strong></li>\n<li><strong>Instead of storing the heights of the nodes, can we store the balance factors of the nodes and update an AVL tree (for insertion and deletion) based on this information?</strong></li>\n</ol>\n\n<p>Here are the relevant slides: </p>\n\n<p><img src="http://i.stack.imgur.com/LusSW.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/wuUdi.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/47jDV.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/P8w2s.png" alt="enter image description here"></p>\n', 'ViewCount': '118', 'Title': 'Updating an AVL Tree Based On Balance Factors', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-21T19:44:13.303', 'LastEditDate': '2013-10-21T19:44:13.303', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<binary-trees><trees><search-trees>', 'CreationDate': '2013-10-21T19:14:25.870', 'Id': '16313'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Why is it that Iterative-deepening A* is optimal, even without monotonicity? How can I be sure that the first goal reached is the optimal one?</p>\n', 'ViewCount': '282', 'Title': 'Why is Iterative-deepening A* optimal, even without monotonicity?', 'LastActivityDate': '2013-10-28T20:50:58.197', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '16514', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10575', 'Tags': '<search-algorithms><search-trees>', 'CreationDate': '2013-10-27T17:01:21.627', 'Id': '16477'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '150', 'Title': 'Artificial Intelligence: Condition for BFS being optimal', 'LastEditDate': '2013-11-18T19:12:31.383', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6998', 'FavoriteCount': '1', 'Body': '<p>It is said in the book <em>Artificial Intelligence: A Modern Approach</em> for finding a solution on a tree using BFS that: </p>\n\n<blockquote>\n  <p>breadth-first search is optimal if the path cost is a nondecreasing function of the\n  depth of the node. The most common such scenario is that all actions have the same cost.</p>\n</blockquote>\n\n<p>From that I understand that if the path cost is non decreasing function of depth, the BFS algorithm returns an optimal solution, i.e., <strong>the only condition is the cost function being nondecreasing</strong>. But I think the only way for BFS to be optimal is the scenario in which all the path costs are identical, therefore a node found in a certain level is necessarily the optimal solution, as, if they exist, the others are. Therefore I think for BFS to be optimal, cost function should be non decreasing <strong>AND</strong> the costs of nodes should be identical. However, the book says only one of the conditions (former one) makes BFS optimal.</p>\n\n<p>Is there a situation in which the costs are not identical, the cost function is nondecreasing and the solution returned by BFS is guaranteed to be optimal?</p>\n', 'Tags': '<optimization><artificial-intelligence><search-algorithms><search-trees><search-problem>', 'LastEditorUserId': '6998', 'LastActivityDate': '2013-11-18T19:12:31.383', 'CommentCount': '0', 'AcceptedAnswerId': '16780', 'CreationDate': '2013-11-06T01:16:28.697', 'Id': '16758'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider this tree:</p>\n\n<p><img src="http://i.stack.imgur.com/cMslZ.png" alt="Simple binary tree"></p>\n\n<p>If I traverse it using post-order, I\'d start at <em>B</em> (as it is the leftmost leaf) and that\'s where my misunderstanding begins. I know <em>B</em> is the first and <em>A</em> will be the last node in post order, as the rule is left-right-root. One of my university professors said the correct answer for the post-order traversal of a tree similar to the one above would be <strong><em>B</em>, <em>C</em>, <em>D</em>, <em>E</em>, <em>A</em></strong>, but in my understanding, it should be <strong><em>B</em>, <em>D</em>, <em>E</em>, <em>C</em>, <em>A</em></strong>.  </p>\n\n<p>Am I getting it wrong? Shouldn\'t I evaluate <em>(C,D),(C,E)</em> as a subtree and then go back to the parent tree?</p>\n', 'ViewCount': '40', 'Title': "Doesn't post-order traversal require subtrees to be evaluated separately?", 'LastEditorUserId': '12111', 'LastActivityDate': '2013-12-14T19:07:44.407', 'LastEditDate': '2013-12-14T19:07:44.407', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18988', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12111', 'Tags': '<data-structures><binary-trees><search-algorithms><trees><search-trees>', 'CreationDate': '2013-12-14T17:40:35.087', 'Id': '18987'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is how deletion in B-trees is described:</p>\n\n<blockquote>\n  <ol>\n  <li><p>If the key k is in node x and x is a leaf, delete the key k from x.</p></li>\n  <li><p>If the key k is in node x and x is an internal node, do the following.</p>\n  \n  <p>a) If the child y that precedes k in node x has at least t keys, then find the predecessor k0 of k in the sub-tree rooted at y. Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)</p>\n  \n  <p>b) If y has fewer than t keys, then, symmetrically, examine the child z that follows k in node x. If z has at least t keys, then find the successor k0 of k in the subtree rooted at z. Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)</p>\n  \n  <p>c) Otherwise, if both y and z have only t-1 keys, merge k and all of z into y, so that x loses both k and the pointer to z, and y now contains 2t-1 keys. Then free z and recursively delete k from y.</p></li>\n  <li><p>If the key k is not present in internal node x, determine the root x.c(i) of the appropriate subtree that must contain k, if k is in the tree at all. If x.c(i) has only t-1 keys, execute step 3a or 3b as necessary to guarantee that we descend to a node containing at least t keys. Then finish by recursing on the appropriate child of x.</p></li>\n  </ol>\n</blockquote>\n\n<p>What is the actual difference between case 1 case 3? Both seem to be directing to a leaf node.</p>\n', 'ViewCount': '40', 'Title': 'Case distinction in B-tree deletion', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-08T17:04:46.533', 'LastEditDate': '2014-01-08T17:04:46.533', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11804', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2014-01-08T12:53:21.410', 'Id': '19580'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im learning the delete operation on <a href="http://www.cs.princeton.edu/~rs/talks/LLRB/08Dagstuhl/RedBlack.pdf" rel="nofollow">Left-leaning Red Black Tree</a> invented by Prof. Sedgewick. In delete operation, a node could be only deleted from a 3-node or a 4-node but 2-node. In order to ensure we dont end up at 2-node, we push the red link down when both the left and left of left of this node are black (if the cmp &lt; 0) by the code below</p>\n\n<pre><code>// Assuming that h is red and both h.left and h.left.left\n// are black, make h.left or one of its children red.\nprivate Node moveRedLeft(Node h) {\n    assert (h != null);\n    assert isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.left.left);\n\n    flipColors(h);\n    if (isRed(h.right.left)) { \n        h.right = rotateRight(h.right);\n        h = rotateLeft(h);\n    }\n    return h;\n}\n</code></pre>\n\n<p>The fact is before we invoke this function, there is not any check if this node is red. So, This must be one of the characters of LLRB. Actually the image below just show this.</p>\n\n<p><img src="http://i.stack.imgur.com/FazCz.png" alt="one possible llrb tree"></p>\n\n<p>But how to prove this?</p>\n', 'ViewCount': '35', 'Title': 'LLRB Tree How to prove if left and left of left node are black, then this node must be a red node?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-13T19:09:14.983', 'LastEditDate': '2014-01-13T19:09:14.983', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12804', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2014-01-13T16:07:25.153', 'Id': '19696'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the accepted answer to my question <a href="http://cs.stackexchange.com/a/19998/13022">Data Structure For Closest Pair Problem</a>, I do not see why deletion works.</p>\n\n<p>Let\'s say (x, y) are the closest pair before the delete. If the node to be deleted is either x or y, then we would have to recalculate the closest pair, which would not satisfy the O(log n) requirement. The best solution I currently see is that each time a "new" closest pair occurs during an insertion, we link it to the previous closest pair. That is, instead of storing just the closest pair in the root node, we store a linked list of closest pairs. However, this seems like overkill. </p>\n\n<p>Is there a better way resp. why does the proposed solution work?</p>\n', 'ViewCount': '134', 'ClosedDate': '2014-02-02T11:24:13.863', 'Title': 'AVL Trees - Maintaining Closest Pair information on a Delete', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-01-28T12:17:10.023', 'LastEditDate': '2014-01-28T12:17:10.023', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8639', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2014-01-27T04:16:48.070', 'Id': '20005'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As per <a href="http://algs4.cs.princeton.edu/lectures/52Tries.pdf" rel="nofollow">Tries slides</a> (page 17) from Algorithm 4th edition book by Robert Sedgewick, the asymptotic expected runtime for an unsuccessful search in $R$-way tries miss is $O(\\log_R N)$. Can someone please explain how this number can be derived?</p>\n', 'ViewCount': '21', 'Title': 'Understanding expected time bound for unsuccessful search in R-way tries', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T16:21:49.280', 'LastEditDate': '2014-02-06T16:21:49.280', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21387', 'Score': '1', 'OwnerDisplayName': 'ManojGumber', 'PostTypeId': '1', 'Tags': '<data-structures><runtime-analysis><search-trees>', 'CreationDate': '2014-01-12T22:11:10.073', 'Id': '21386'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can we prove a binary search tree with $n$ internal vertices has height $h = \\lceil \\log(n+1) \\rceil$? </p>\n', 'ViewCount': '31', 'ClosedDate': '2014-02-18T21:34:52.390', 'Title': 'Binary search tree with $n$ internal vertices', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T21:35:18.720', 'LastEditDate': '2014-02-18T21:35:18.720', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14815', 'Tags': '<data-structures><combinatorics><trees><search-trees>', 'CreationDate': '2014-02-18T17:27:13.633', 'Id': '21781'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In the words of (<a href="http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf" rel="nofollow">http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf</a>, section 17.2), "Each $f(x)$ can be interpreted as de\ufb01ning a hyperplane in $R^n$. Thus, tracing a path through the tree computes the intersection of the half-planes de\ufb01ned by the nodes touched by the path."</p>\n\n<p>I fail to visualize how path tracing is done? I would be glad to see it explained through the presentation of the path in a 2-dimensional space.</p>\n\n<p>I do understand that $x_1,x_2,...,x_n$ is a point in the $R^n$ dimensional space. But I don\'t get how Figure 17.1 in (<a href="http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf" rel="nofollow">http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf</a>) helped in proving the lower bounds of Element Uniqueness as $\\Omega(n\\log n)$. I also don\'t get the implication of $\\#F$ being connected components; why can\'t they simply be called solutions?</p>\n\n<p>Unfortunately, reading online resources did not help me much understand the aforementioned concepts.</p>\n\n<p>Thank you in advance.</p>\n', 'ViewCount': '34', 'Title': 'Help in geometrically understanding "Linear Decision Trees"', 'LastEditorUserId': '15072', 'LastActivityDate': '2014-02-27T22:05:37.933', 'LastEditDate': '2014-02-27T19:22:01.350', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22113', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<algorithms><search-trees><lower-bounds>', 'CreationDate': '2014-02-27T19:09:05.800', 'Id': '22102'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '76', 'Title': 'Why should leaf nodes in a red-black tree be black?', 'LastEditDate': '2014-03-27T15:03:50.240', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16188', 'FavoriteCount': '1', 'Body': u'<p>From the property of Red-Black Trees we know that: </p>\n\n<ul>\n<li>All leaves (NIL) are black. (All leaves are same color as the root.)(Comren et al "Introduction to Algorithms")</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/hz7wf.png" alt="An example of a red\u2013black tree. From Wikipedia"></p>\n\n<p>But what is the reason that we should enforce them as Black, even though they\'re NILL\'s? </p>\n', 'Tags': '<terminology><data-structures><search-trees><dictionaries>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T05:15:31.620', 'CommentCount': '1', 'AcceptedAnswerId': '23123', 'CreationDate': '2014-03-27T10:13:14.353', 'Id': '23119'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The <a href="http://en.wikipedia.org/wiki/K-d_tree" rel="nofollow">link</a> in wikipedia about kd-trees store points in the inner nodes. I have to perform NN queries and I <strong>think</strong> (newbie here), I am understanding the concept.</p>\n\n<p>However, I was said to study Kd-trees from Computational Geometry Algorithms and Applications (De Berg, Cheong, Van Kreveld and Overmars), section 5.2, page 99. The main difference I can see is that Overmars places the splitting data in the inner nodes and the actual points of the dataset in the leaves. For example, in 2D, an inner node will hold the splitting line.</p>\n\n<p>Wikipedia on the other hand, seems to store points in inner nodes and leaves (while Overmars only on leaves).</p>\n\n<p>In this case, how do we perform nearest neighbour search? Moreover, why there is this difference?</p>\n', 'ViewCount': '36', 'Title': 'kd-tree stores points in inner nodes? If yes, how to search for NN?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-10T14:43:00.437', 'LastEditDate': '2014-04-10T14:43:00.437', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16638', 'Tags': '<data-structures><computational-geometry><search-algorithms><search-trees><nearest-neighbour>', 'CreationDate': '2014-04-10T13:20:27.113', 'Id': '23636'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let\'s say you have the following sentence: "This is my first cs question posted here". How would I go about inserting the sentence into a search tree. Do I assign each word a number value and perform the insertions based on those? </p>\n', 'ViewCount': '15', 'Title': 'Inserting a sentence into search trees', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T08:37:33.313', 'LastEditDate': '2014-04-29T08:37:33.313', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17159', 'Tags': '<data-structures><strings><search-trees>', 'CreationDate': '2014-04-29T01:30:52.450', 'Id': '24204'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In my algorithms course I have learned about the binary search tree and its functions add, find and remove.\nI have also learned about how to find the successor and the predecessor in a balanced binary search tree, but they are both $O(\\log n)$ I think.</p>\n\n<p>Now, I have been thinking, how can I change a given binary search tree so that I could find any given node's successor in $O(1)$ time? The other operations should still run in $O(\\log n)$ time.</p>\n\n<p>I have thought about maintaining the tree in a linked list but I am sure that there is a better solution to it.</p>\n", 'ViewCount': '36', 'ClosedDate': '2014-05-02T21:52:16.723', 'Title': 'Finding a successor in a binary search tree in $O(1)$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T21:51:10.597', 'LastEditDate': '2014-05-02T21:51:10.597', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14724', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2014-05-02T15:37:33.333', 'Id': '24317'}