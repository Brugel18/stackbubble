{'ViewCount': '194', 'Title': 'Proving the security of Nisan-Wigderson pseudo-random number generator', 'LastEditDate': '2012-04-07T23:33:31.787', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '41', 'FavoriteCount': '1', 'Body': "<p>Let $\\cal{S}=\\{S_i\\}_{1\\leq i\\leq n}$ be a partial $(m,k)$-design and $f: \\{0,1\\}^m \\to \\{0,1\\}$ be a Boolean function. The Nisan-Wigderson generator $G_f: \\{0,1\\}^l \\to \\{0,1\\}^n$ is defined as follows:</p>\n\n<p>$$G_f(x) = (f(x|_{S_1}) , \\ldots, f(x|_{S_n}) )$$</p>\n\n<p>To compute the $i$th bit of $G_f$ we take the bits of $x$ with indexes in $S_i$ and then apply $f$ to them.</p>\n\n<blockquote>\n  <p>Assume that $f$ is $\\frac{1}{n^c}$-hard for circuits of size $n^c$ where $c$ is a constant.\n  How can we prove that $G_f$ is $(\\frac{n^c}{2}, \\frac{2}{n^c})$-secure pseudo-random number generator?</p>\n</blockquote>\n\n<h3>Definitions:</h3>\n\n<p>A partial $(m,k)$-design is a collection of subsets $S_1, \\ldots, S_n \\subseteq [l] = \\{1, \\ldots, l\\}$ such that </p>\n\n<ul>\n<li>for all $i$: $|S_i|=m$, and</li>\n<li>for all $i \\neq j$: $|S_i \\cap S_j| \\leq k$.</li>\n</ul>\n\n<p>A function $f$ is $\\epsilon$-hard for circuits of size $s$ iff no circuit of size $s$ can predict $f$ with probability $\\epsilon$ better than a coin toss.</p>\n\n<p>A function $G:\\{0,1\\}^l \\to \\{0,1\\}^n$ is $(s, \\epsilon)$-secure pseudo-random number generator iff no circuit of size $s$ can distinguish between a random number and a number generated by $G_f$ with probability better than $\\epsilon$.</p>\n\n<p>We use $x|_A$ for the string composed of $x$'s bits with indexes in $A$.</p>\n", 'Tags': '<cryptography><pseudo-random-generators>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-09-04T15:21:55.373', 'CommentCount': '6', 'AcceptedAnswerId': '3417', 'CreationDate': '2012-03-13T04:08:58.890', 'Id': '286'}{'ViewCount': '1940', 'Title': 'Why is encrypting with the same one-time-pad not good?', 'LastEditDate': '2012-03-15T07:22:59.783', 'AnswerCount': '4', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '1', 'Body': '<p>To encrypt a message $m_1$ with a one-time-pad key $k$ you do\n$Enc(m_1,k) = m_1 \\oplus k$. </p>\n\n<p>If you use the same $k$ to encrypt a different message $m_2$ you get\n$Enc(m_2,k) = m_2 \\oplus k$, and if you perform Xor of the two ciphertext you get\n$$( m_1 \\oplus k) \\oplus ( m_2 \\oplus k) = m_1 \\oplus m_2$$</p>\n\n<p>so, OK, there is some information leakage becuse you learn $m_1 \\oplus m_2$, but why is it not secure? I have no way to learn (say) $m_1$ unless I know $m_2$. So why is it wrong to use $k$ twice??</p>\n', 'Tags': '<cryptography><information-theory><encryption>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-25T07:11:47.277', 'CommentCount': '5', 'AcceptedAnswerId': '365', 'CreationDate': '2012-03-14T06:52:07.727', 'Id': '349'}{'ViewCount': '2078', 'Title': "Why hasn't there been an encryption algorithm that is based on the known NP-Hard problems?", 'LastEditDate': '2012-03-15T07:04:19.330', 'AnswerCount': '4', 'Score': '51', 'PostTypeId': '1', 'OwnerUserId': '5', 'FavoriteCount': '8', 'Body': "<p>Most of today's encryption, such as the RSA, relies on the integer factorization, which is not believed to be a NP-hard problem, but it belongs to BQP, which makes it vulnerable to quantum computers. I wonder, why has there not been an encryption algorithm which is based on an known NP-hard problem. It sounds (at least in theory) like it would make a better encryption algorithm than a one which is not proven to be NP-hard.</p>\n", 'Tags': '<complexity-theory><np-hard><encryption><cryptography>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-22T00:58:17.060', 'CommentCount': '1', 'AcceptedAnswerId': '364', 'CreationDate': '2012-03-14T08:02:26.627', 'Id': '356'}{'ViewCount': '4378', 'Title': 'How to verify number with Bob without Eve knowing?', 'LastEditDate': '2012-03-15T07:02:35.387', 'AnswerCount': '7', 'Score': '26', 'PostTypeId': '1', 'OwnerUserId': '71', 'FavoriteCount': '1', 'Body': '<p>You need to check that your friend, Bob, has your correct phone number, but you cannot ask him directly. You must write the question on a card which and give it to Eve who will take the card to Bob and return the answer to you. What must you write on the card, besides the question, to ensure Bob can encode the message so that Eve cannot read your phone number?</p>\n\n<p><em>Note:</em> This question is on a list of "google interview questions". As a result, there are tons of versions of this question on the web, and many of them don\'t have clear, or even correct answers. </p>\n\n<p><em>Note 2:</em> The snarky answer to this question is that Bob should write "call me". Yes, that\'s very clever, \'outside the box\' and everything, but doesn\'t use any techniques that field of CS where we call our hero "Bob" and his eavesdropping adversary "Eve". </p>\n\n<p><strong>Update:</strong> <br>\nBonus points for an algorithm that you and Bob could both reasonably complete by hand.</p>\n\n<p><strong>Update 2:</strong> <br>\nNote that Bob doesn\'t have to send you any arbitrary message, but only confirm that he has your correct phone number without Eve being able to decode it, which may or may not lead to simpler solutions.</p>\n', 'Tags': '<algorithms><cryptography>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T13:59:02.063', 'CommentCount': '7', 'AcceptedAnswerId': '399', 'CreationDate': '2012-03-14T08:18:00.390', 'Id': '358'}{'Body': u'<p>Consider the following protocol, meant to authenticate $A$ (Alice) to $B$ (Bob) and vice versa.</p>\n\n<p>$$ \\begin{align*}\r\n A \\to B: &amp;\\quad \\text{\u201cI&#39;m Alice\u201d}, R_A \\\\\r\n B \\to A: &amp;\\quad E(R_A, K) \\\\\r\n A \\to B: &amp;\\quad E(\\langle R_A+1, P_A\\rangle, K) \\\\\r\n\\end{align*} $$</p>\n\n<ul>\n<li>$R$ is a random nonce.</li>\n<li>$K$ is a pre-shared symmetric key.</li>\n<li>$P$ is some payload.</li>\n<li>$E(m, K)$ means $m$ encrypted with $K$.</li>\n<li>$\\langle m_1, m_2\\rangle$ means $m_1$ assembled with $m_2$ in a way that can be decoded unambiguously.</li>\n<li>We assume that the cryptographic algorithms are secure and implemented correctly.</li>\n</ul>\n\n<p>An attacker (Trudy) wants to convince Bob to accept her payload $P_T$ as coming from Alice (in lieu of $P_A$). Can Trudy thus impersonate Alice? How?</p>\n\n<p><sub>\nThis is slightly modified from exercise 9.6 in <a href="http://rads.stackoverflow.com/amzn/click/0471738484" rel="nofollow"><em>Information Security: Principles and Practice</em></a> by <a href="http://www.cs.sjsu.edu/~stamp/" rel="nofollow">Mark Stamp</a>. In the book version, there is no $P_A$, the last message is just $E(R_A+1,K)$, and the requirement is for Trudy to \u201cconvince Bob that she is Alice\u201d. Mark Stamp asks us to find two attacks, and the two I found allow Trudy to forge $E(R+1,K)$ but not $E(\\langle R, P_T\\rangle, K)$.\n</sub></p>\n', 'ViewCount': '185', 'Title': 'Break an authentication protocol based on a pre-shared symmetric key', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-17T23:38:55.327', 'LastEditDate': '2012-03-17T23:25:42.723', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '480', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<cryptography><protocols><authentication>', 'CreationDate': '2012-03-16T00:56:14.627', 'Id': '431'}{'Body': '<p>Windows NT used a point-to-point protocol where a client can communicate "securely" with a server by using a stream cipher to encrypt an array of messages with some key $k$. The server also encrypts its response with the same key $k$. But how is it aware of this key?</p>\n\n<p>More general: if Alice and Bob use some encryption/decryption algorithm that operates on the same private key $k$, what is a secure way of exchanging this key? (without using a different key ofcourse) </p>\n\n<p>This is something that I\'ve always asked myself whilest studying private key cryptography.</p>\n', 'ViewCount': '209', 'Title': 'How is the key in a private key encryption protocol exchanged?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-19T08:22:05.680', 'LastEditDate': '2012-03-18T00:58:39.457', 'AnswerCount': '5', 'CommentCount': '1', 'AcceptedAnswerId': '472', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '17', 'Tags': '<cryptography><encryption>', 'CreationDate': '2012-03-17T17:30:02.783', 'Id': '470'}{'Body': u'<p>Consider the following protocol, meant to authenticate $A$ (Alice) to $B$ (Bob) and vice versa.</p>\n\n<p>$$ \\begin{align*}\r\n A \\to B: &amp;\\quad \\text{\u201cI&#39;m Alice\u201d}, R_A \\\\\r\n B \\to A: &amp;\\quad E(\\langle 1, R_A\\rangle, K) \\\\\r\n A \\to B: &amp;\\quad E(\\langle 2, R_A+1, P_A\\rangle, K) \\\\\r\n\\end{align*} $$</p>\n\n<ul>\n<li>$R$ is a random nonce.</li>\n<li>$K$ is a pre-shared symmetric key.</li>\n<li>$P$ is some payload.</li>\n<li>$E(m, K)$ means $m$ encrypted with $K$.</li>\n<li>$\\langle m_1, \\ldots, m_n\\rangle$ means an assemblage of the $m_i$\'s that can be decoded unambiguously ($n$ is encoded unambiguously as well).</li>\n<li>We assume that the cryptographic algorithms are secure and implemented correctly.</li>\n</ul>\n\n<p>An attacker (Trudy) wants to convince Bob to accept her payload $P_T$ as coming from Alice (in lieu of $P_A$). Can Trudy thus impersonate Alice? How?</p>\n\n<p><sub>\nThis is a follow-up to <a href="http://cs.stackexchange.com/questions/431/break-an-authentication-protocol-based-on-a-pre-shared-symmetric-key">Break an authentication protocol based on a pre-shared symmetric key</a>.\n</sub></p>\n', 'ViewCount': '100', 'Title': 'Break an authentication protocol based on a pre-shared symmetric key, with message numbers', 'LastActivityDate': '2012-03-20T17:16:11.060', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '542', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<cryptography><protocols><authentication>', 'CreationDate': '2012-03-17T23:42:57.927', 'Id': '481'}{'Body': '<p>Simply put, if one were to build a quantum computing device with the power of, say, 20 qubits,  could such a computer be used to make any kind of modern hashing algorithm useless?</p>\n\n<p>Would it even be possible to harness the power of quantum computing in a traditional computing application?</p>\n', 'ViewCount': '896', 'Title': 'Could quantum computing eventually be used to make modern day hashing trivial to break?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-03-25T21:54:37.717', 'LastEditDate': '2012-03-25T21:54:37.717', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '751', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '367', 'Tags': '<cryptography><quantum-computing><hash>', 'CreationDate': '2012-03-21T07:01:46.637', 'Id': '586'}{'Body': "<p>How does the password that we enter (to connect to a wireless network) encrypt the data on the wireless network?</p>\n\n<p>Through my reading I am not sure if the password that we enter is the same as the passphrase. If that is right then how can the passphrase generate the four WEP keys?</p>\n\n<p>I understand how the four keys work in WEP and how they encrypt the data. Also, I know how WPA's keys encrypt the data but the only thing I have to know is: </p>\n\n<blockquote>\n  <p>what is the benefit of the password that we enter to get access to the network, and how does this password help in encrypting the data?</p>\n</blockquote>\n", 'ViewCount': '1009', 'Title': 'How does a wifi password encrypt data using WEP and WPA?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T14:54:04.653', 'LastEditDate': '2012-03-25T14:54:04.653', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '701', 'Tags': '<cryptography><computer-networks><encryption><security>', 'CreationDate': '2012-03-23T19:41:23.180', 'FavoriteCount': '1', 'Id': '704'}{'Body': '<p>I am confused about how taps are chosen for Linear Feedback Shift Registers.</p>\n\n<p>I have a diagram which shows a LFSR with connection polynomial $C(X) = X^5 + X^2 + 1$. The five stages are labelled: $R4, R3, R2, R1$ and $R0$ and the taps come out of $R0$ and $R3$.</p>\n\n<p>How are these taps decided? When I am given a connection polynomial but no diagram, how do I know what values I should XOR?</p>\n\n<p><img src="http://i.stack.imgur.com/ubz8P.jpg" alt="enter image description here"></p>\n', 'ViewCount': '221', 'Title': 'Choosing taps for Linear Feedback Shift Register', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-08T00:26:01.017', 'LastEditDate': '2012-04-07T23:33:01.787', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '1123', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '995', 'Tags': '<cryptography><pseudo-random-generators><shift-register>', 'CreationDate': '2012-04-07T22:38:27.080', 'Id': '1121'}{'Body': "<p>I am revising for a computer security course and I am stuck on one of the past questions. Here is it:</p>\n\n<blockquote>\n  <p>Alice ($A$) wants to send a short message $M$ to Bob ($B$) using a shared secret $S_{ab}$ to authenticate that the message has come from her. She proposes to send a single message with two pieces:\n  $$ A \\to B: \\quad M, h(M \\mathbin\\parallel S_{ab})$$\n  where $h$ is a hash function and $\\parallel$ denotes concatenation.</p>\n  \n  <ol>\n  <li>Explain carefully what Bob does to check that the message has come from Alice, and why (apart from properties of $h$) he may believe this.</li>\n  <li>Suppose that $h$ does not satisfy the one-way property and it is possible to generate pre-images. Explain what an attacker can do and how.</li>\n  <li>If generating pre-images is comparatively time-consuming, suggest a simple countermeasure to improve the protocol without changing $h$.</li>\n  </ol>\n</blockquote>\n\n<p>I think I know the first one. Bob needs to take a hash of the received message along with his shared key and compare that hash with the hash received from Alice, if they match then this should prove Alice sent it.</p>\n\n<p>I am not sure about the second two questions though. For the second one, would the answer be that an attacker can simply obtain the original message given a hash? I'm not sure how that would be done though.</p>\n", 'ViewCount': '170', 'Title': 'Attack on hash functions that do not satisfy the one-way property', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:44:58.717', 'LastEditDate': '2013-03-10T00:44:58.717', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1227', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '995', 'Tags': '<cryptography><hash><one-way-functions>', 'CreationDate': '2012-04-11T16:25:33.290', 'Id': '1225'}{'Body': '<p>An asymptotic lower bound such as exponential-hardness is generally thought to imply that a problem is "inherently difficult". Encryption that is "inherently difficult" to break is thought to be secure. </p>\n\n<p>However, an asymptotic lower bound does not rule out the possibility that a huge but finite class of problem instances are easy (eg. all instances with size less than $10^{1000}$).</p>\n\n<p>Is there any reason to think that cryptography being based on asymptotic lower bounds would confer any particular level of security? Do security experts consider such possibilities, or are they simply ignored? </p>\n\n<p>An example is the use of trap-door functions based on the decomposition of large numbers into their prime factors. This was at one point thought to be inherently difficult (I think that exponential was the conjecture) but now many believe that there may be a polynomial algorithm (as there is for primality testing). No one seems to care very much about the lack of an exponential lower bound.</p>\n\n<p>I believe that other trap door functions have been proposed that are thought to be NP-hard (see <a href="http://cs.stackexchange.com/q/356/98">related question</a>), and some may  even have a proven lower bound. My question is more fundamental: does it matter what the asymptotic lower bound is? If not, is the practical security of any cryptographic code at all related to any asymptotic complexity result?</p>\n', 'ViewCount': '199', 'Title': 'Are asymptotic lower bounds relevant to cryptography?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-13T07:08:10.570', 'LastEditDate': '2012-04-13T07:08:10.570', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '1038', 'Tags': '<complexity-theory><cryptography><asymptotics>', 'CreationDate': '2012-04-11T16:44:36.490', 'FavoriteCount': '1', 'Id': '1226'}{'ViewCount': '201', 'Title': 'Is it possible to create a "Time Capsule" using encryption?', 'LastEditDate': '2012-04-26T22:25:21.077', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1038', 'FavoriteCount': '1', 'Body': '<p>I want to create a digital time capsule which will remain unreadable for some period of time and then become readable. I do not want to rely on any outside service to, for instance, keep the key secret and then reveal it at the required time. Is this possible? If not, is some kind of proof possible that it is not?</p>\n\n<p>One strategy would be based on projections of future computing capabilities, but that is unreliable and makes assumptions about how many resources would be applied to the task.</p>\n', 'Tags': '<cryptography><encryption><digital-preservation>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-12T05:46:21.313', 'CommentCount': '1', 'AcceptedAnswerId': '1518', 'CreationDate': '2012-04-26T13:37:39.000', 'Id': '1514'}{'Body': '<p>Will there be a need to change the definitions of security if we have quantum computers? What cryptographic constructions will break? Do you know a survey or an article that explains what will be needed to change?</p>\n', 'ViewCount': '314', 'Title': 'What is the difference between classical crypto and post-quantum crypto?', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-30T19:48:18.947', 'LastEditDate': '2012-04-30T17:21:10.673', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1318', 'Tags': '<reference-request><cryptography><quantum-computing>', 'CreationDate': '2012-04-30T17:11:36.020', 'FavoriteCount': '1', 'Id': '1595'}{'Body': '<p>When setting up an access point and selecting WPA2, one must manually enter a pre-shared key (a password), PSK, into both the AP and the STA. </p>\n\n<p>Both parties, AP and STA, must authenticate each other. But they have to do so without revealing the PSK. Both have to proof to the other party that they know the PSK without actually sending it. </p>\n\n<p>Is that an example of a <a href="http://en.wikipedia.org/wiki/Zero-knowledge_proof">zero-knowledge proof</a>?</p>\n\n<p>I thought it was, but nothing legit shows up when I google for zero-knowledge proof and WPA2 or EPA-PSK (the authentication method used). </p>\n', 'ViewCount': '389', 'Title': 'Is WPA2 with pre-shared key an example of a zero-knowledge proof?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T13:46:35.333', 'LastEditDate': '2012-05-10T13:46:35.333', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '8', 'OwnerDisplayName': 'Maiken Holm', 'PostTypeId': '1', 'Tags': '<cryptography><security><authentication>', 'CreationDate': '2012-05-04T22:22:55.337', 'Id': '1680'}{'Body': '<p>it\'s a well known statement that </p>\n\n<p>"<em>Cryptographic security must rely on a secret key instead of a secret algorithm</em>."</p>\n\n<p>I would like to ask about some details about it. <em>And which are their differences?</em></p>\n\n<p>I see the obvious thing that for a multi user system, generating a key is overwhelmingly easier than generating a distinct alghorithm for every user pair, (and even for a single pair of users one could argue that updating the key is easier)</p>\n\n<p>But, Is it the only argument? </p>\n\n<p>I mean, if we define </p>\n\n<pre><code>AlgorithmA = AlgorithmX + key A\nAlgorithmB = AlgorithmX + key B\n</code></pre>\n\n<p>Then a change on the key is not different from a change in the algorithm.</p>\n\n<p>The only different I see is that for a new pair of users/keys</p>\n\n<ul>\n<li><p><em>Most of</em> the Algorithm structure <strong>remains constant</strong> in the case of secret key,</p></li>\n<li><p><em>Most of</em> Algorithm structure <strong>need to change</strong> in the case of secret Algorithm</p></li>\n</ul>\n\n<p>But where is the limit? "most of" meaning?</p>\n\n<p>I would like to have more views and clues to understand why this distinction is usually mentioned.</p>\n', 'ViewCount': '255', 'Title': 'Key secrecy vs Algorithm secrecy', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-14T15:49:59.243', 'LastEditDate': '2012-05-11T22:36:20.483', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '1834', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<cryptography><security><encryption>', 'CreationDate': '2012-05-11T17:57:33.800', 'Id': '1797'}{'Body': '<p>If an encryption algorithm is meant to convert a string to another string which can then be decrypted back to the original, how could this process involve any randomness?  </p>\n\n<p>Surely it has to be deterministic, otherwise how could the decryption function know what factors were involved in creating the encrypted string?</p>\n', 'ViewCount': '210', 'Title': 'How can encryption involve randomness?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-05-26T18:25:38.433', 'LastEditDate': '2012-05-26T18:25:38.433', 'AnswerCount': '5', 'CommentCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1622', 'Tags': '<cryptography><encryption><randomness>', 'CreationDate': '2012-05-23T21:13:58.847', 'Id': '2030'}{'Body': '<p><strong>Preface:</strong> This question was originally asked on <a href="http://cstheory.stackexchange.com/questions/11521">Theoretical Computer Science</a>, and the kind people there referred me to this web site. It is being repeated here in an attempt to find a satisfying answer.</p>\n\n<hr>\n\n<p>Over the years, two novel encryption techniques have come to mind and been implemented as programming libraries that could be integrated into applications. However, how to analyze their security and vulnerability characteristics has never been very clear, and their usage has been limited to mainly experimental tests. Are there tools available for automated examination of such parameters one may be interested in understanding for an encryption library? Are there bodies of people who are interested in being introduced to new encryption concepts for the purpose of executing their own personal analysis on such a process? I\'m not sure where to look.</p>\n\n<p>The first encryption algorithm is a mono-alphabetic simple substitution cipher. It requires two keys to operate and is designed to frustrate frequency analysis. The longer of the keys forms a table by which plain-text has a normal substitution cipher applied. Each encoded byte is then split into four values of two bits each. The second, shorter key is then used to allow a random selection from four groups of sixty-four unique bytes each. Each two bit value from the encoded byte is used to select which group of sixty-four bytes to use. Encoding has two disadvantages: the output is four times larger, and repeated data encoding may allow some frequency analysis.</p>\n\n<p>The second encryption algorithm is a stream cipher like the first but internally operates on blocks of data. It utilizes two keys to operate: the first is a two-dimensional array that describes how to construct a (virtual) multidimensional grid, and the second is an initialization vector for the encoding/decoding engine. It attempts to overcome frequency analysis by encoding bytes with a window of preceding bytes (initialized from the second key). A byte with its preceding window of bytes form a multidimensional index into the aforementioned grid. Unfortunately, encoding duplicate blocks of data longer than the window size starts yielding equivalent data.</p>\n', 'ViewCount': '284', 'Title': 'After implementing a novel encryption algorithm, how would one go about analyzing its security or get help from others in doing so?', 'LastEditorUserId': '1644', 'LastActivityDate': '2012-05-25T08:31:52.593', 'LastEditDate': '2012-05-25T08:31:52.593', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1633', 'Tags': '<cryptography><encryption>', 'CreationDate': '2012-05-24T20:48:26.443', 'Id': '2053'}{'Body': '<p><a href="https://en.wikipedia.org/wiki/Side_channel_attack" rel="nofollow">Wikipedia</a> defines <em>side-channel attacks</em> as:</p>\n\n<blockquote>\n  <p>any attack based on information gained from the physical implementation of a cryptosystem</p>\n</blockquote>\n\n<p>Usually in side channel attacks the implementations leak information (e.g., timing attack: the implementation leaks the time it takes to complete a task, etc.)</p>\n\n<p><strong>Are tampering-attacks also considered as side-channel attacks?</strong></p>\n\n<p>On one hand, tampering-attacks are (usually) attacks on the implementation itself.\nOn the other hand, the attack might be such that information only enters the device, and no information comes out of the device, so there is no "side-channel" that leaks the information.\n(example: If we heat some access-control device, until it grants us the access. Or if we perform SQL injection that causes the device to grant the access (but leaks no secret other than that))</p>\n', 'ViewCount': '63', 'Title': 'Are tamper attacks considered side-channel?', 'LastActivityDate': '2012-06-19T20:05:59.080', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '157', 'Tags': '<terminology><cryptography>', 'CreationDate': '2012-06-19T19:08:30.063', 'Id': '2417'}{'Body': u'<p>IPv6 addresses in the form of <code>862A:7373:3386:BF1F:8D77:D3D2:220F:D7E0</code> are much harder to memorize or even transcribe than the 4 octets of IPv4.  </p>\n\n<p>There <a href="http://blog.jgc.org/2011/07/pronounceable-ipv6-addresses-wpa2-psk.html?m=1" rel="nofollow">have</a> <a href="http://www.halfbakery.com/idea/IPv6_20Worded_20Addresses#1260513928" rel="nofollow">been</a> attempts to mitigate this, making IPv6 addresses somehow more memorable.</p>\n\n<p>Is there an intentionally-weak hashing function which could be reversed to find that the phrase, say, <a href="http://en.wikipedia.org/wiki/Dissociated_press" rel="nofollow">"This is relatively benign and easy to spot if the phrase is bent so as to be not worth paying"</a> would hash to a target IPv6 address?  The hash would, of course, have many colliding inputs to choose from, and a potentially more memorable sentence, such as this example phrase, could be automatically offered.</p>\n\n<p>I guess there are two parts: First a weak hash with good distribution in both directions.  Second is an algorithm for selecting memorable phrases from among the many collisions (short, consisting of words from a specified language, perhaps even following a simplified grammar).</p>\n\n<p>Although the hash function would need to be weak, I don\'t doubt that the effort is still significant - however, once the phrase is known, the computation of the hash to the target address is very quick.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>I found this related idea, <a href="https://en.wikipedia.org/wiki/Piphilology" rel="nofollow">Piphilology</a>, for memorizing some digits of \u03c0:</p>\n\n<blockquote>\n  <p>How I wish a drink, alcoholic of course, after the heavy lectures involving quantum mechanics!</p>\n</blockquote>\n', 'ViewCount': '301', 'Title': 'Weak hashing function for memorable IPv6 addresses', 'LastEditorUserId': '41', 'LastActivityDate': '2013-12-18T02:30:58.523', 'LastEditDate': '2013-07-20T09:19:35.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '762', 'Tags': '<cryptography><computer-networks><hash><user-interface>', 'CreationDate': '2012-07-15T17:57:04.403', 'FavoriteCount': '3', 'Id': '2752'}{'ViewCount': '182', 'Title': 'A hash function with predicted collisions', 'LastEditDate': '2012-08-08T07:12:26.080', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2383', 'FavoriteCount': '0', 'Body': '<p>As far as I know, the more collision-resistant a hash function is, the better. But is there any way to define a hash function with <em>predicted</em> collisions? In other words, a hash function that collides for some known set of possible inputs and avoids collisions for other input values. To state the problem simpler:</p>\n\n<p>Let $A$ be some set of strings. \nDefine a function $f$ such that $f(x_i) \\rightarrow y_i$ with $y_i \\neq y_j$ for all $i,j \\notin A$ with $i \\neq j$, and otherwise $f(x_i) \\rightarrow y$ where $y \\notin \\{y_i \\mid i \\notin A\\}$ is constant.</p>\n\n<p>Is it possible? In addition, is it possible for performance of such a hash function <em>not</em> to depend on the size of $A$?</p>\n', 'Tags': '<cryptography><hash>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-08T07:12:26.080', 'CommentCount': '3', 'AcceptedAnswerId': '3063', 'CreationDate': '2012-08-06T21:22:55.007', 'Id': '3061'}{'Body': '<p>I need to calculate the output of the sequence generated by this shift register but I cannot find anywhere how to do it. Everywhere the results are just given but there is no explanation how to do compute them. I know the the sequence will repeat every 2^3-1=7 times. Could anyone explain me how to do it. Thank you.</p>\n\n<p><img src="http://i.stack.imgur.com/sEhMT.jpg" alt="enter image description here"></p>\n', 'ViewCount': '86', 'Title': 'LFSR sequence computation', 'LastEditorUserId': '2639', 'LastActivityDate': '2012-08-26T19:19:44.063', 'LastEditDate': '2012-08-26T14:18:02.693', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3338', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2639', 'Tags': '<cryptography><pseudo-random-generators><shift-register>', 'CreationDate': '2012-08-26T13:28:54.913', 'Id': '3337'}{'Body': "<p>I was wondering, if there is an MD5 hash collision in the UNSIGNED MEDIUMINT Range (0 - 16777215). Sadly, I'm unable to run a script to check this myself, due to Memory (RAM) limitations. The answer is probably no; the next step would be - how many characters are even needed, until the first collision is found? </p>\n\n<p>An MD5 hash has 32 Characters. If you only would use, lets say, the first nine characters from all MD5 hashes in the MEDIUMINT range, would they still all be unique?</p>\n\n<p>The reason behind this: I'm trying to find a simple way to basically use an MD5 hash for every number in the MEDIUMINT range, to create a short, unique string, preferably not longer than 9 letters -- as abstraction to the actual number (so instead of an <code>1</code>, you get something like <code>c4ca4238a</code>)</p>\n\n<p>Are the first nine characters of all MD5 hashes in the UNSIGNED MEDIUMINT (whitout 0) range unique?</p>\n", 'ViewCount': '152', 'Title': 'Collisions of prefixes of MD5 hashes in some fixed interval', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-26T18:58:11.490', 'LastEditDate': '2012-09-26T15:26:15.797', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'OwnerDisplayName': 'Katai', 'PostTypeId': '1', 'Tags': '<cryptography><hash>', 'CreationDate': '2012-09-25T14:52:01.787', 'Id': '4742'}{'Body': u"<p>I have the following problem:</p>\n\n<p>De\ufb01ne the keyed function F as follows: On input k \u2208 {0, 1}$^n$\nand x \u2208 {0, 1}$^n$ , Fk(x) = k \u2295 x.Rigorously prove that F is not a pseudorandom function.</p>\n\n<p>How do I approach a proof against pseudorandomness for a keyed function? I don't know where to start with this one.</p>\n", 'ViewCount': '397', 'Title': 'Rigorous proof against pseudo random function', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T13:44:19.380', 'LastEditDate': '2012-10-22T13:44:19.380', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6145', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<proof-techniques><cryptography>', 'CreationDate': '2012-10-18T00:40:36.627', 'Id': '6144'}{'Body': '<p>In some literature, as well as in <a href="http://en.wikipedia.org/wiki/Mersenne_twister" rel="nofollow">Wikipedia</a>, the middle term parameter <em>m</em> of Mersenne twister is called "number of parallel sequences". Why? What is meant here by "parallel sequences"?</p>\n', 'ViewCount': '32', 'Title': 'Mersenne twister middle word', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-20T00:43:31.747', 'LastEditDate': '2012-10-20T00:43:31.747', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4276', 'Tags': '<terminology><cryptography><pseudo-random-generators>', 'CreationDate': '2012-10-19T20:39:43.797', 'Id': '6178'}{'Body': '<p>The following is an excerpt from the <a href="http://en.wikipedia.org/wiki/Miller-Rabin_primality_test#Accuracy_of_the_test" rel="nofollow">Wikipedia article on the Miller-Rabin primality test</a>:</p>\n\n<blockquote>\n  <p>It can be shown that for any odd composite $n$, at least $\\frac{3}{4}$ of the bases $a$ are witnesses for the compositeness of $n$.</p>\n</blockquote>\n\n<p>In the Fermat primality test, if $n$ is not a Carmichael number, <a href="http://en.wikipedia.org/wiki/Fermat_primality_test#Flaw" rel="nofollow">at least half of the bases $a$ are Fermat witnesses</a>. Testing for non-trivial roots in the Miller-Rabin primality test however increases the minimum number of witnesses to $\\frac{3}{4}$.</p>\n', 'ViewCount': '321', 'Title': 'In the Miller-Rabin primality test, for a composite number, why are at least $\\frac{3}{4}$ of the bases witnesses of compositeness?', 'LastEditorUserId': '4267', 'LastActivityDate': '2012-12-10T00:51:28.710', 'LastEditDate': '2012-12-10T00:51:28.710', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6250', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4267', 'Tags': '<cryptography><number-theory>', 'CreationDate': '2012-10-22T20:39:25.463', 'Id': '6241'}{'Body': "<p>I'm trying to solve a problem:</p>\n\n<p>I have 11 ciphers encoded with the same key.\nMy aim is to decode target cipher.</p>\n\n<p>If I do xor C1, C2 (<strong>ciphers encoded with the same key</strong>) I do get M1 xor M2 (where M1, M2 are plain text messages).</p>\n\n<p>Please say what to do next. I don't understand how to get plain texts from M1 xor M2</p>\n\n<p><strong>UPD:</strong> it's a two time pad (i.e. the same key has been use more than one time)</p>\n", 'ViewCount': '573', 'Title': 'One time pad, get plaintext using ciphers encoded with the same key', 'LastEditorUserId': '4639', 'LastActivityDate': '2012-12-23T10:32:19.413', 'LastEditDate': '2012-11-18T14:04:32.200', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4639', 'Tags': '<cryptography><encryption><xor>', 'CreationDate': '2012-11-18T11:07:56.430', 'FavoriteCount': '1', 'Id': '6740'}{'Body': '<p>For Shamir\'s secret sharing scheme (<a href="http://dx.doi.org/10.1145/359168.359176" rel="nofollow">doi 10.1145/359168.359176</a>), one obtains a random polynomial $q$ of degree at most $n-1$ (over $\\mathbb{Z}_p[x]$).  The constant coefficient of this polynomial is defined to be the key.  Then the scheme sends to player $i$ the value $q(i)$ (for $i \\leq k$ for some fixed $k$). The interpolation theorem says that if $n$ players come together, then I can use interpolation to reconstruct the polynomial (there is a unique polynomial $p$ of degree at most $n-1$ such that $p(i)=q(i)$ .. in otherwords $p=q$.  So that I can grab the constant coefficient of $p$ and it must be the same as the constant coefficient of $q$, and hence must be the key).</p>\n\n<p>The question I have, is that what if the polynomial is degree less than $n-1$.  There seems to be nothing in the construction as described by Shamir that prevents this.  However, Shamir states that $n-1$ players cannot reconstruct the polynomial.</p>\n\n<p>The problem I am having is that there seems to be a "most of the time" clause missing. If I happen to pick a degree one polynomial then any two players can reconstruct the polynomial.  So is it that the players do not know the degree of the polynomial, or that the probability of picking a small degree polynomial is low enough that the probability of two participants guessing the key is still the same as random guessing, or am I missing something else.</p>\n', 'ViewCount': '73', 'Title': 'Condition in Shamir Secret Sharing Scheme', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-28T06:29:54.707', 'LastEditDate': '2012-11-28T06:05:45.310', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4774', 'Tags': '<probability-theory><cryptography>', 'CreationDate': '2012-11-28T05:34:05.030', 'Id': '6981'}{'Body': '<p>I was wondering how should I proceed in order to show that the composition of (say) two one-way functions (either weak or strong or both together) is not a one-way function?</p>\n\n<p>Specifically: Say $f$ and $g$ are one-way functions (either weak or strong).\nHow do I prove that their composition $g(f(x))$ is not necessarily a one-way function?</p>\n', 'ViewCount': '403', 'Title': 'How to show composition of one way function is not such?', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:44:40.480', 'LastEditDate': '2013-03-10T00:44:40.480', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9232', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4488', 'Tags': '<proof-techniques><cryptography><one-way-functions>', 'CreationDate': '2012-12-01T10:21:02.673', 'Id': '7076'}{'Body': '<p>I know that a <a href="http://en.wikipedia.org/wiki/One-way_function" rel="nofollow">one-way function</a> is informally a function that it\'s easy to compute but hard to invert.<br/>\nIf f(x) is a one way function the function  $g(x) = x\\oplus f(x)$ is a one-way function?\nMy intuition is that it\'s but i not really sure.</p>\n', 'ViewCount': '206', 'Title': "What will i obtain if i apply a xor-ing a one way function and it's input?", 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:43:38.110', 'LastEditDate': '2013-03-10T00:43:38.110', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7163', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3048', 'Tags': '<cryptography><one-way-functions>', 'CreationDate': '2012-12-04T18:24:57.147', 'Id': '7160'}{'Body': '<p>I have just read <a href="http://en.wikipedia.org/wiki/Mental_poker" rel="nofollow">mental poker</a>, described in this <a href="http://people.csail.mit.edu/rivest/ShamirRivestAdleman-MentalPoker.pdf" rel="nofollow">fascinating paper(PDF)</a> by cryptographic greats Adi Shamir, Ron Rivest, and Leonard Adleman.</p>\n\n<p>Assuming I have a website, (TTP) how can I prove to the player that the hand dealt to him is fair? Most importantly how can I prove that I didn\'t bruteforce until an unfair hand is dealt to him to gain house edge, are there any C# implentations of such code?</p>\n', 'ViewCount': '129', 'Title': 'Mental poker: proving dealt hand is fair', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-15T22:49:18.767', 'LastEditDate': '2012-12-08T23:15:38.550', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4939', 'Tags': '<probability-theory><cryptography><board-games>', 'CreationDate': '2012-12-08T21:20:39.903', 'FavoriteCount': '2', 'Id': '7257'}{'Body': '<p>A function is $(\\varepsilon, t)$-collision resistant if there is no boolean circuit (using "not", "and", "or") of size at most $t$ which outputs a collision with probability at least $\\varepsilon$.</p>\n\n<p>Let $h_0:\\{0,1\\}^{2m}\\rightarrow\\{0,1\\}^m$ be a $(\\varepsilon, t)$-collision resistant hash function and $i\\in\\mathbb{N}_{\\geq 1}$.<br>\nDefine a hash function $h_i: \\{0,1\\}^{2^{i+1}\\cdot m}\\rightarrow \\{0,1\\}^m$ recursively using $h_{i-1}$ in the following way:<br>\nInterpret the bit string $x\\in \\{0,1\\}^{2^{i+1}\\cdot m}$ as $x=x_1 x_2$, where both $x_1,x_2\\in \\{0,1\\}^{2^i\\cdot m}$.  </p>\n\n<p>Then the hash value $h_i(x)$ is defined as</p>\n\n<p>$$h_i(x)=h_0(h_{i-1}(x_1)h_{i-1}(x_2)).$$</p>\n\n<p>For which $(\\varepsilon_i, t_i)$ is $h_i$ $(\\varepsilon_i, t_i)$-collision resistant?<br>\nAnd can we successfully use the birthday attack on this hash function to find collisions?</p>\n', 'ViewCount': '378', 'Title': 'Collision resistant hash function', 'LastActivityDate': '2013-01-18T03:34:50.863', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5408', 'Tags': '<cryptography><hash>', 'CreationDate': '2013-01-13T18:21:29.690', 'Id': '7928'}{'Body': '<p>I often read that deciding whether or not a number $r$ is a quadratic residue modulo $n$ is an interesting (and hard) problem from number theory (especially if $n$ is not prime). </p>\n\n<p>I am looking at the following special case of this problem: Let $p$ and $q$ be two different prime numbers and $n:=pq$. Given $r$ between $1$ and $n$. Decide if there exists an $x\\in\\mathbb{Z}/n\\mathbb{Z}$ such that $x^2\\equiv r\\pmod{n}$.</p>\n\n<p>My question is: The functional version of this problem i.e. "Find such an $x$ as above" yields an randomized algorithm for integer factoring. So it is <em>very</em> interesting for practical reasons like "breaking RSA". Is there any such result for the decision version of this problem? If not, what are typical problems that let us think that deciding quadratic residuosity it is a hard problem?</p>\n\n<p>And furthermore, is the special case I\'m looking at really a special case? Or can I solve the general case with an arbitrary $n$ with an oracle for the decision problem above?</p>\n', 'ViewCount': '151', 'Title': 'Quadratic residue and integer factoring', 'LastActivityDate': '2013-02-11T09:03:33.197', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9666', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2103', 'Tags': '<cryptography><number-theory>', 'CreationDate': '2013-02-10T17:33:56.953', 'Id': '9642'}{'Body': "<p>If I have a system of N polynomial equations with N unknowns in GF(2):</p>\n\n<ul>\n<li>What are some good methods to solve them?</li>\n<li>What are some software packages or libraries that implement this?</li>\n<li>What's the highest value of N that can be reasonable solved?</li>\n</ul>\n\n<p>Now, my root interest isn't GF, it's crypto.  Here's my reasoning:</p>\n\n<ol>\n<li>Any function from a n-dimensional binary vector to {0,1} can be represented as a GF(2) polynomial function of n variables.</li>\n<li>Thus, for instance, any cipher from (Plaintext, Key) to Ciphertext can be represented as a series of equations (one for each bit in the ciphertext), each a GF(2) polynomial of (p-bits + k-bits) variables.</li>\n<li>Thus, if we know P and C, and we can solve systems of GF(2) equations, we can determine K.</li>\n</ol>\n", 'ViewCount': '115', 'Title': 'Complexity of GF(2) and applications to cryptography', 'LastActivityDate': '2013-09-11T23:27:21.163', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9682', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '6824', 'Tags': '<algorithms><cryptography><discrete-mathematics><sat-solvers>', 'CreationDate': '2013-02-11T13:38:17.613', 'FavoriteCount': '1', 'Id': '9678'}{'Body': '<p>Suppose $f(x)$ is a one way function. What about $h(x)=f(x_1) \\, \\oplus \\,f(x_2)$, where $x=x_1 || x_2$ and $\\lvert x_1 \\rvert = \\lvert x_2\\rvert$?</p>\n\n<ul>\n<li>$\\oplus$ is exclusive disjunction (xor)</li>\n<li>$||$ is concatenation</li>\n<li>$|u|$ is the length of $u$</li>\n</ul>\n', 'ViewCount': '263', 'Title': 'If xor-ing a one way function with different input, is it still a one way function?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-03-17T19:53:50.897', 'LastEditDate': '2013-03-13T20:16:34.320', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7209', 'Tags': '<cryptography><one-way-functions>', 'CreationDate': '2013-03-10T00:39:41.690', 'Id': '10415'}{'Body': '<p>Unfortunately my background in computational complexity is still weak, but I am working on it.</p>\n\n<p>As I understand, the question of existence of one-way functions is very important in the field.</p>\n\n<p>Assume there are one way-functions, how it can be shown that there exist one-way functions which are length preserving?</p>\n', 'ViewCount': '200', 'Title': 'Length-preserving one-way functions', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-21T10:21:10.180', 'LastEditDate': '2013-03-20T16:22:22.640', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<complexity-theory><cryptography><one-way-functions>', 'CreationDate': '2013-03-20T08:46:30.130', 'Id': '10639'}{'Body': '<p>Can anyone suggest me some good books on cryptography? I have just starting studying cryptography but I know elementary number theory, abstract algebra and algorithms. Also please mention the difficulty level of the book. </p>\n', 'ViewCount': '998', 'Title': 'A good introductory book on cryptography', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:48:42.810', 'LastEditDate': '2013-04-02T07:48:42.810', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '778', 'Tags': '<reference-request><cryptography><books>', 'CreationDate': '2013-03-31T16:45:31.587', 'Id': '10938'}{'ViewCount': '476', 'Title': 'Negligible Function in Cryptography', 'LastEditDate': '2013-04-06T12:01:29.477', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4799', 'FavoriteCount': '1', 'Body': '<p>In the field of Cryptography and Computation Complexity there is a notion of negligible function.</p>\n\n<p>I have some difficulties in understanding intuition behind this notion. The following are some definitions from Chapter 9. Cryptography from the textbook Computation Complexity. A modern approach by Arora and Barak with extensive use of negligible function. There my question after every definition about negligible function.</p>\n\n<blockquote>\n  <p>Before proceeding further, we make a simple definition that will greatly  simplify notation throughout this chapter.</p>\n  \n  <p><strong>Definition of negligible function</strong>. a function $\\epsilon : \\mathbb{N} \\rightarrow [0,1]$ is called negligible if $\\epsilon(n)=n^{-\\omega(1)}$. </p>\n  \n  <p>Because negligible functions tend to zero very fast as their input grows, events that happen with negligible probability can be safely ignored in most practical and theoretical settings.</p>\n</blockquote>\n\n<p>So far so good, it\'s just the definition of negligible function, the only point is why do we need to care about this function if it <em>"can be safely ignored".</em></p>\n\n<blockquote>\n  <p><strong>The notion of computational secure function</strong>.$k \\in_R \\{0,1\\}^n, x \\in_R \\{0,1\\}^m, Pr [A(E_k(x))=(i,b) s.t. x_i=b] \\leq \\frac{1}{2}+\\epsilon(n)$.</p>\n</blockquote>\n\n<p>Less intuitive usage of negligible function. As I understood, in general, $A$ can with probability 0.5 guess uniformly distributed $x_i$, therefore it makes sence to expected lower bound of success to be $\\leq \\frac{1}{2}$, however it\'s $\\leq \\frac{1}{2} + \\epsilon(n)$, it we can "safely ignore" $\\epsilon(n)$ why to mention it, and the second point is it possible to run $A$ some fixed finite number of times to get probability infinitely close to 1?</p>\n\n<blockquote>\n  <p><strong>Definition of one-way function</strong>. $x\\in_R\\{0,1\\}^n, y=f(x), Pr[A(y)=x\' s.t. f(x\')=y] &lt; \\epsilon(n)$</p>\n</blockquote>\n\n<p>In this case, the usage of negligible function is very intuitive, the success probability is upper bounded by negligible function $\\epsilon(n)$. I am not sure how it\'s correlated with existence of computationally secure encryption scheme (of course =0 is preferable by encryption scheme), however if $\\epsilon(n)$ can be safely ignored than it\'s ok.</p>\n\n<p>The problem is I am not quite understand why do we need negligible function. By mentioning few definition I tried to be more specific about what exactly I don\'t understand. </p>\n\n<p>I would appreciate if anyone can shed the light on the usage of negligible function</p>\n', 'Tags': '<complexity-theory><probability-theory><cryptography>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-07T13:22:40.707', 'CommentCount': '0', 'AcceptedAnswerId': '11074', 'CreationDate': '2013-04-06T09:45:34.340', 'Id': '11073'}{'Body': '<p>I try to get the intuition behind the notion of <em>strong one way function</em> and <em>weak one way function</em> by reading the scribe <a href="http://www.cs.cornell.edu/courses/cs6830/2011fa/scribes/lecture3.pdf" rel="nofollow">One-Way Functions</a>. Particularly, I am interested in examples and definitions of the weak and strong one way function. I known it\'s very broad notion, therefore I will be as specific as possible in my questions.</p>\n\n<p><strong>Strong one way function</strong>. $\\forall$ nonuniform PPT $A$, $\\exists \\epsilon s.t. \\forall n \\in N, Pr_{x\\in\\{0,1\\}^n}[A(1^n, f(x)) \\in f^{-1}(f(x))] \\leq \\epsilon(n)$</p>\n\n<blockquote>\n  <p>Q:$1^n$ as the first parameter of the PPT $A$ represent the length of the initial input, the usage of it is justified as <em>"this ensures that the output of A doesn\'t shrink the size if its too must as in the f(x)=|x| example".</em> Unfortunately I didn\'t get the previous explanation (may be because the lost the sign, which takes an additional bit). In my opinion putting in A the size of $x$ might help $A$ get the right output $x$.</p>\n  \n  <p>Q: in the lecture it mentioned that $f(x)=|x|$ is hard, <em>"because it will take $2^c$ time to write a valid inverse of something such that $f(x)=c$"</em>. It happens because we cannot find $x$ with probability with negligible more than 0.5,  but it\'s due to another problem not a computational but rather information theory problem, by running the function we lost the information about the sign of the input $x$, if it\'s a correct reasoning, why actually it would take $2^c$ time?  In addition for  me it looks like the great discover to find the strong one way function, however do have more assumption of hard function like $f(x)=|x|$?</p>\n</blockquote>\n\n<p><strong>Definition of weak one way function</strong>.$\\exists$ $q(x)$, $\\forall$ nonunoform PPT A, $\\forall$ n $\\in$ N,\n$Pr_{x \\in \\{0,1\\}^n}[A(1^n,f(x)) \\in f^{-1}(f(x))] \\leq 1-\\frac{1}{q(n)}$</p>\n\n<blockquote>\n  <p>Q: in the lecture there was an assumption that the multiplication is weak one function, how we can actually show that the multiplication is weak one way function, and do we have more assumptions of examples of weak one way functions?</p>\n</blockquote>\n\n<p>I am very sorry for being naive, even though I will appreciate any help.</p>\n', 'ViewCount': '87', 'Title': 'Assumptions of One Way Functions', 'LastEditorUserId': '157', 'LastActivityDate': '2013-05-18T07:11:24.310', 'LastEditDate': '2013-04-18T06:04:27.470', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<complexity-theory><cryptography><one-way-functions>', 'CreationDate': '2013-04-17T19:40:32.080', 'Id': '11369'}{'Body': '<p>I need to construct d-regular expander graph for some small fixed d (like 3 or 4) of n vertices.</p>\n\n<p>What is the easiest method to do this in practice? \nConstructing a random d-regular graph, which is proven to be a.a.s. an expander?</p>\n\n<p>I also read about Margulis constructions and Ramanujan graphs that are expanders and a construction using a zig-zag product. Wikipedia gives a nice but very short overview: <a href="http://en.wikipedia.org/wiki/Expander_graph#cite_note-10">http://en.wikipedia.org/wiki/Expander_graph#cite_note-10</a>\nBut which method do I choose in practice?</p>\n\n<p>For me, these methods seem all very complicated to implement and in particular to understand and maybe quite specific.\nAren\'t there easier methods, maybe based on permutations or so, to practically generate a sequence of d-regular expander graphs?  </p>\n\n<p>Is it maybe easier to construct d-regular bipartite expander graphs?</p>\n\n<p>I also have another question: What about families of bad d-regular expanders? Does such a notion make sense? Can one construct a family of d-regular graphs (that are of course connected) that is as bad as possible in the sense of an expander?</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '200', 'Title': 'How to practically construct regular expander graphs?', 'LastEditorUserId': '7309', 'LastActivityDate': '2014-01-19T18:58:28.767', 'LastEditDate': '2013-04-24T16:42:32.183', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '7309', 'Tags': '<graph-theory><combinatorics><cryptography><discrete-mathematics><expanders>', 'CreationDate': '2013-04-24T13:37:26.307', 'FavoriteCount': '3', 'Id': '11538'}{'Body': '<p>From graph isomorphism, we know that two graphs A and B are isomorphic if there is a permutation matrix P such that \n$A = P \\times B \\times P^{-1}$</p>\n\n<p>So, to solve the problem, if two graphs are isomorphic, we need to find such a permutation matrix P. The problem is believed to be NP (and NP complete for the case of subgraph isomorphism). However, I found an example to solve for P which seemed promising to me and can be found in \n<a href="http://en.wikipedia.org/wiki/Permutation_matrix" rel="nofollow">http://en.wikipedia.org/wiki/Permutation_matrix</a>\nin section: solving for P. </p>\n\n<p>The confusion I have now is, does that work for larger matrices? very large? am I right the above equation is hard to solve and can be candidate for a cryptographic system?</p>\n', 'ViewCount': '112', 'Title': 'How hard is it to solve for $P$ in $A = PBP^{-1}$?', 'LastEditorUserId': '755', 'LastActivityDate': '2013-04-26T23:40:13.320', 'LastEditDate': '2013-04-25T22:09:10.967', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'boFatom', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><cryptography><graph-isomorphism>', 'CreationDate': '2013-04-16T21:10:39.030', 'Id': '11553'}{'Body': '<p>In the classic crypto textbook "Introduction to Modern Cryptography" by Jonathan Katz and Yehuda Lindell, there is a definition for indistinguishable encryption in the presence of an eavesdropper as such that for every probabilistic polynomial time adversary A there is a negligible function negl(n) such that</p>\n\n<p>$\\Pr[PrivK_{A,\\Pi}=1] \\leq negl(n)$</p>\n\n<p>where PrivK is the indistinguishability experiment and for the purpose of this question we only need to know that the experiment outcome is 1 iff the adversary makes the correct guess.</p>\n\n<p>My doubts are as follows. Consider a sequence of probabilistic polynomial time adversaries $\\{A_i\\}_{i&gt;=1}$ whose advantage in the indistinguishability experiment is bounded by the following sequence of negligible functions</p>\n\n<p>$\\Pr[PrivK_{A,\\Pi}=1] \\leq negl_i(n) = \\frac{1}{(1+1/i)^n}$</p>\n\n<p>Clearly it is necessary for the above conditions to hold for a indistinguishable encryption. But is it a correct model/condition for real-world applications? For example, in practice we typically choose a sufficiently large n and set up some encryption scheme. However, there is the always some adversary $A_i$ that wins the experiment with probability close to one. So what\'s wrong?</p>\n', 'ViewCount': '59', 'Title': 'Doubts on Definition of Indistinguishable Encryption in the Textbook', 'LastActivityDate': '2013-06-04T13:55:33.533', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12459', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '848', 'Tags': '<cryptography>', 'CreationDate': '2013-06-04T10:34:16.977', 'FavoriteCount': '1', 'Id': '12457'}{'Body': '<p>I\'m in the middle of planning a 5000ish word essay on <a href="http://en.wikipedia.org/wiki/Homomorphic_encryption#Fully_homomorphic_encryption" rel="nofollow">fully homomorphic cryptography</a>, the current practical implementations and their limitations.</p>\n\n<p>Which areas of CS as a subject have been (or will be) most affected or will utilise fully homomorphic cryptography the most in the coming years and developments?</p>\n\n<p>PS. I did several searches and couldn\'t find a repeated iteration of this question, hope the fact this isn\'t a specific theory questions gets me in hot water!</p>\n', 'ViewCount': '39', 'Title': 'Which areas in CS will be (or have been) most affected by fully homomorphic cryptography?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-06-08T20:37:48.477', 'LastEditDate': '2013-06-08T20:37:48.477', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '971', 'Tags': '<cryptography>', 'CreationDate': '2013-06-08T20:17:49.197', 'Id': '12544'}{'Body': '<p>For my CS degree I have had most of the "standard" mathematical background:</p>\n\n<ul>\n<li>Calculus: differential, integral, complex numbers</li>\n<li>Algebra: pretty much the concepts up until fields.</li>\n<li>Number Theory: XGCD and related stuff, mostly for crypto.</li>\n<li>Linear Algebra: up until eigenvectors/eigenvalues</li>\n<li>Statistics: probabilities, testing</li>\n<li>Logic: propositional, predicate, modal, hybrid.</li>\n</ul>\n\n<p>My main interests in the CS area are security, cryptography and artificial intelligence.\nI was wondering if there are any suggestions for mathematical topics that could be interesting for these areas, particularly for AI as it is not my main field of study at the moment.</p>\n', 'ViewCount': '157', 'Title': 'What mathematics can be interesting for these CS areas?', 'LastActivityDate': '2013-07-07T08:22:24.320', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7592', 'Tags': '<artificial-intelligence><cryptography><discrete-mathematics>', 'CreationDate': '2013-07-06T16:58:40.467', 'FavoriteCount': '1', 'Id': '13114'}{'Body': "<p>While reading a cryptography textbook, i find the definition of a function that is hard on the average.(More precisely, it is 'hard on the average but easy with auxiliary input', but i omit latter for simplicity.)</p>\n\n<blockquote>\n  <p><strong>Definition : Hard on the average</strong> : </p>\n  \n  <p>$h:\\{0,1\\}^*\\to \\{0,1\\}^* $ is hard on the average if <strong>there exists</strong> a probabilistic polynomial-time algorithm $G$ such that<br>\n  for every probabilistic polynomial-time algorithm $A'$ every positive polynomial $p(\\cdot)$, and all sufficiently large $n$'s,  Pr$[A'(X_n)=h(X_n)]&lt;\\frac{1}{p(n)}$  </p>\n  \n  <p>where $X_n := G(1^n)$ is a random variable assigned the output of $G$.</p>\n</blockquote>\n\n<p>My question is why the statement of the existence of qualified algorithm G is sufficient? </p>\n\n<p>In other words, why the above definition gives a formal definition of 'hardness on the average' instead of following definition, which is more intuitive(?) to understand and more strict.\nWhy is the above definition sufficient? </p>\n\n<p>( Now I'm thinking that problem might occur when $G$ has only polynomial number of possible outputs, but if so, let's replace 'for any $G$' with 'for any $G$ which have exponentially many possible outputs' in following definition.)</p>\n\n<blockquote>\n  <p><strong>(strong?) Def : Hard on the average</strong> : </p>\n  \n  <p>$h:\\{0,1\\}^*\\to \\{0,1\\}^* $ is hard on the average if <strong>for any</strong> probabilistic polynomial-time algorithm $G$ and for every probabilistic polynomial-time algorithm $A'$ every positive polynomial $p(\\cdot)$, and all sufficiently large $n$'s,  Pr$[A'(X_n)=h(X_n)]&lt;\\frac{1}{p(n)}$  </p>\n  \n  <p>where $X_n := G(1^n)$ is a random variable assigned the output of $G$.</p>\n</blockquote>\n\n<p>Another question is that whether a following simpler definition is equivalent to original definition or not?</p>\n\n<blockquote>\n  <p><strong>(simple) Def : Hard on the average</strong> : </p>\n  \n  <p>$h:\\{0,1\\}^*\\to \\{0,1\\}^* $ is hard on the average if for every probabilistic polynomial-time algorithm $A'$ every positive polynomial $p(\\cdot)$, and all sufficiently large $n$'s,  Pr$[A'(U_n)=h(U_n)]&lt;\\frac{1}{p(n)}$  </p>\n  \n  <p>where $U_n$ is a random variable uniformly distributed over $\\{0,1\\}^n$.</p>\n</blockquote>\n", 'ViewCount': '64', 'Title': "Completeness of formal definition of 'hardness on the average'", 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-09T07:02:13.240', 'LastEditDate': '2013-08-09T07:02:13.240', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13678', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9565', 'Tags': '<complexity-theory><terminology><cryptography><randomized-algorithms><average-case>', 'CreationDate': '2013-08-08T12:43:21.820', 'Id': '13674'}{'ViewCount': '73', 'Title': 'Mealy machines to model ciphers', 'LastEditDate': '2013-08-18T03:18:05.613', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '25', 'FavoriteCount': '1', 'Body': u'<p>Similar questions have occurred quite a number of times <a href="http://cs.stackexchange.com/q/10280/25">(1)</a> <a href="http://cstheory.stackexchange.com/q/8539/869">(2)</a> <a href="http://cstheory.stackexchange.com/q/14811/869">(3)</a>, but I have, say, a specific instance of one. I\'m aware of a bunch of applications of finite automata, but would you provide an academic exposition of applications of finite state machines (like, e.g., Mealy machines) in cryptography and ciphers? There is a mention about things like that in Wikipedia article on Mealy machines (<a href="http://en.wikipedia.org/wiki/Mealy_machine#Applications" rel="nofollow">subsection \u201cApplications\u201d</a>). So the links to some academic texts play up on this are very appreciated. Alternatively would you share your thoughts on how to furnish this topic (FSM in cryptography) for students?</p>\n', 'ClosedDate': '2013-08-22T03:37:30.720', 'Tags': '<reference-request><automata><finite-automata><cryptography>', 'LastEditorUserId': '25', 'LastActivityDate': '2013-08-18T06:53:08.120', 'CommentCount': '1', 'AcceptedAnswerId': '13798', 'CreationDate': '2013-08-17T19:55:32.487', 'Id': '13795'}{'Body': '<p>By Information-Theoretic definitions, the <a href="http://en.wikipedia.org/wiki/One-time_pad" rel="nofollow">One Time Pad (OTP)</a> is called/was proved to be a Perfectly Secure Cipher. For the sake of completeness, we define</p>\n\n<ul>\n<li>OTP: An enc/dec function, $f:\\mathcal{P} \\times \\mathcal{K} \\rightarrow \\mathcal{C}$</li>\n<li>Perfect Security: Given $m, m^* \\in \\mathcal{M}$,\n$$P\\big(m=m^* \\mid E_\\mathcal{K}(m) = c\\big) = P(m=m^*) $$</li>\n</ul>\n\n<p>I ask, <strong>Are there any more Perfectly Secure Ciphers known other than the OTP?</strong> </p>\n', 'ViewCount': '80', 'Title': 'Perfectly Secure Ciphers known other than the OTP', 'LastActivityDate': '2013-09-21T07:05:38.950', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '14473', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<cryptography>', 'CreationDate': '2013-09-20T14:01:40.700', 'Id': '14467'}{'Body': '<p><strong>Situation</strong>: Alice has selected a positive integer $a$, and Bob has selected a positive integer $b$. Alice and Bob want to know whether $a &gt; b$, $a = b$, or $a &lt; b$, but neither wishes to reveal their chosen number to the other party. </p>\n\n<p>How can Alice and Bob make this determination?</p>\n', 'ViewCount': '55', 'Title': 'What is a protocol for determining which of two numbers is larger, without sharing those numbers?', 'LastActivityDate': '2013-11-18T23:59:19.443', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18134', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9699', 'Tags': '<cryptography>', 'CreationDate': '2013-11-14T05:21:07.263', 'FavoriteCount': '1', 'Id': '18007'}{'Body': "<p>I am trying to find the plain text for the following cipher text using a frequency analysis</p>\n\n<pre><code>vr pvst yqlp mq nvf\n</code></pre>\n\n<p>But for the letters above this is really difficult, as if I use the alphabetic substitution technique, where I assume that v corresponds to e as this occurs most in the english alphabet. What about p, this also occurs three times, does this mean it corresponds to e. Same for <code>r,s,t,y,l,m,n,j,f</code> which occur only once. Is there an algorithm which looks at such duplicated frequencies, or do I guess:</p>\n\n<p>v and p corresponds to e\nq corresponds to t \nr to f correspond to a</p>\n\n<p>?</p>\n\n<p>even using the bigram method for something like this is difficult as a bigram of pv is found, \nif p = t\nand v = h\nthat means p doesn't correspond to t anymore? </p>\n\n<p>Thanks in advance!</p>\n", 'ViewCount': '44', 'Title': 'Cryptography substitution frequency analysis', 'LastActivityDate': '2013-12-15T11:13:56.573', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<cryptography>', 'CreationDate': '2013-12-15T09:38:24.860', 'Id': '19007'}{'Body': '<p>How do I see if the following ciphertext <code>eaeairtntrnaeemtve</code> is a transposition cipher, using letter frequency?</p>\n\n<p><a href="http://en.wikipedia.org/wiki/Transposition_cipher" rel="nofollow">This</a> article suggest how to detect by using letter frequency detection and cryptanalysis but I am unsure of how to do this. Any suggestions?</p>\n', 'ViewCount': '72', 'Title': 'Decrypting transposition ciphers', 'LastEditorUserId': '39', 'LastActivityDate': '2014-01-03T09:46:14.660', 'LastEditDate': '2014-01-03T09:46:14.660', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '19454', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<cryptography>', 'CreationDate': '2014-01-02T15:19:39.047', 'Id': '19453'}{'Body': '<p>I believe this question should be extremely easy but I am having a (embarrassing) hard time figuring out why its true if there exist OWF (computable in polynomial time) then there exits a OWF that is computed in $O(n^2)$.</p>\n\n<p>This is what I have/tried.</p>\n\n<p>Let $ \\ f(x)$ be a OWF that can be computed in $k^c$. Then we can construct a OWF:</p>\n\n<p>$$\nf\'(x\'||\\ x\'\') = f(x\') || \\ x\'\'\n$$\nwhere:\n$$\n|x\'| = k \\\\\n|x\'\'| = k^c\n$$</p>\n\n<p>Notice the size of the input for $f\'$ is $n = k^c + k$.</p>\n\n<p>Its intuitively "obvious" f\' is a OWF since f is OWF (or you can go ahead and prove it by contradiction if you want to be pedantic). But how come it takes $O(n^2)$ to compute the OWF f\'? Does this depend on the Turing Machine model being used to compute f\'?</p>\n\n<p>It seems to me you can just parse the input $x\'||x\'\'$ (separate it so that you can feed the appropriate thing to the original f) in O(n) and then compute $f(x\')$ in $k^c = O(n)$\nand then concatenate it to $x\'\'$ and print f(x\')|x\'\' (printing takes at most $O(n)$). It seems to me it takes $O(n)$ and that the bound $O(n^2)$ is unnecessarily un-tight (I know $cn + d = O(n) = O(n^2)$). Or maybe the parsing algorithm is "harder" than I expect it... even if you just append the lengths at the beginning just for parsing purposes , isn\'t the time to compute $f\'$ just $O(n)$?</p>\n\n<p>Does someone understands why my O(n) argument is wrong?</p>\n', 'ViewCount': '44', 'Title': 'If a one-way functions (OWF) exist, then there exits a OWF that is computable in quadratic running time by a padding argument', 'LastEditorUserId': '12623', 'LastActivityDate': '2014-01-08T06:44:06.893', 'LastEditDate': '2014-01-07T00:25:10.693', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19532', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12623', 'Tags': '<asymptotics><cryptography><one-way-functions>', 'CreationDate': '2014-01-06T04:48:25.020', 'Id': '19527'}{'Body': u'<p>(This question is related to homework)\nI am doing a cryptography course via long distance and we have been given an assignment which is based on lattice-based cryptography. I have spent the majority of the past week sifting through papers and videos in an attempt to build my understanding of the subject, but due to the intensely technical manner in which information on the subject is presented, I have not been able to answer many questions in my mind. Due to the structure of my long distance course I have no access to professors or extensive libraries so my question is one which merely seeks to increase my understanding, please bear with me.</p>\n\n<p>Thus far I have understood that:\n- Lattices are a collection of regularly ordered points in euclidean space (its terms like this which have caused me to be searching for answers for days)</p>\n\n<ul>\n<li><p>A lattice may be defined through n vectors called a basis where n = the dimension (for now I am working in dimension 2), and any other basis can be found by applying positive or negative multiples of each vector in the basis to another vector in the basis</p></li>\n<li><p>Defining a lattice L1 as a set of points allows one to multiply the whole set by some co-efficient which will essentially transform it into a new lattice L2</p></li>\n<li><p>The determinant of the vectors of the basis essentially tells us the volume (area in 2 dimensions) of the parallelpiped which will be repeated to form the lattice, the lattice points being the vertices.</p></li>\n</ul>\n\n<p>Having said this, I am now stuck in understanding how I move all of this to cryptography. I am on a question which asks me to compute the output for 3 inputs to a function:</p>\n\n<p>\'We will see that q-ary lattices give provably collision-resistent hashing. We choose integers q; a\nand b. Our hash function (presented by Mikl\xb4os Ajtai in a breakthrough paper in 1996) is a 2-variable\nfunction: h(x, y) = ax + by mod q.\n(a) For q = 5; a = 14; b = 13; compute h(17, 8), h(21, 16) and h((17, 8) - (21, 16))\'</p>\n\n<p>Having found the answers, h(17, 8) = 14*17 + 13*8 = 342 mod 5 = 2; h(21, 16) = 14*21 + 13*16 = 502 mod 5 = 2; h((17, 8)-(21, 16)) -> (h(-4, -8) = 14*-4 + 13*-8 = 160 mod 5 = 0</p>\n\n<p>I believe this means that with the first two points the lattice has been moved by some multiple of 5 plus two, which has displaced it by two and thus formed a new lattice. While in the last case, the lattice has been moved by a multiple of its determinant and thus is the same lattice.</p>\n\n<p>However, I just cannot understand the link to hashing. In an application would the points be the cleartext and the \'answer modulo 5\' the output of the hash function? If so would\'nt there be too many collisions as we have already seen two examples of which give the answer 2? How exactly is this linked to the shortest vector problem or short integer solution if they are not the same thing? Are q-ary lattices only an attempt to store the basic pattern needed to reproduce the lattice? and if so wouldn\'t the lattice itself be the cleartext and the basic pattern (given by the basis and the determinant) the answer from the hash function??? How exactly would you <em>encrypt</em> a message using a lattice???</p>\n\n<p>I just wish I could find some text which explained this in English rather than symbols.. like this <a href="http://www.wisdom.weizmann.ac.il/~odedg/COL/cfh.pdf" rel="nofollow">http://www.wisdom.weizmann.ac.il/~odedg/COL/cfh.pdf</a> . I really hope I have not repeated any questions through my lack of understanding. Thanks in advance.</p>\n', 'ViewCount': '51', 'Title': 'Help in understanding exactly how lattices used as one way functions for hashing', 'LastEditorUserId': '14437', 'LastActivityDate': '2014-02-06T15:51:37.247', 'LastEditDate': '2014-02-06T15:51:37.247', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21377', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14437', 'Tags': '<cryptography><hash><lattices>', 'CreationDate': '2014-02-06T12:49:55.937', 'Id': '21372'}{'Body': '<p>I have been working on a challenge i found on the internet. It is as follows:</p>\n\n<blockquote>\n  <p>You\'ve stumbled onto a significant vulnerability in a commonly used cryptographic library. It turns out that the random number generator it uses frequently produces the same primes when it is generating keys.</p>\n  \n  <p>Exploit this knowledge to factor the (hexadecimal) keys below, and enter your answer as the last six digits of the largest factor you find (in decimal).</p>\n  \n  <p>Key 1: 1c7bb1ae67670f7e6769b515c174414278e16c27e95b43a789099a1c7d55c717b2f0a0442a7d49503ee09552588ed9bb6eda4af738a02fb31576d78ff72b2499b347e49fef1028182f158182a0ba504902996ea161311fe62b86e6ccb02a9307d932f7fa94cde410619927677f94c571ea39c7f4105fae00415dd7d</p>\n  \n  <p>Key 2: \n   2710e45014ed7d2550aac9887cc18b6858b978c2409e86f80bad4b59ebcbd90ed18790fc56f53ffabc0e4a021da2e906072404a8b3c5555f64f279a21ebb60655e4d61f4a18be9ad389d8ff05b994bb4c194d8803537ac6cd9f708e0dd12d1857554e41c9cbef98f61c5751b796e5b37d338f5d9b3ec3202b37a32f</p>\n</blockquote>\n\n<p>These seem to be common RSA 1024-bit keys.</p>\n\n<p>My approach to the problem was to implement <a href="http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm" rel="nofollow">Pollard\'s rho algorithm</a> to find factors, then once a factor is found, try dividing the decimal form of the keys by that factor until it is not divisible anymore. Iterate. </p>\n\n<p>Now, i used Pollard\'s rho and tried to divide until the key is not divided anymore because of the information the problem gave: the keys are not completely random. </p>\n\n<p>But here comes the question: assuming the algorithm generates two primes and multiplies them to get a co-prime, which is the key, the low randomness doesn\'t help much, does it? I mean, even if both keys share a common factor, finding it the first time would take the regular-impractical-exponential time.</p>\n\n<p>That seems to be the case, as my Python algorithm is running for about 5 hours now and has not found any factor to the second key, which i decided to start with.</p>\n\n<p>As it is a challenge, i assume there is a practical way of finding the answer. \nSo what im i doing wrong? Is just the algorithm choice wrong, as Pollard\'s rho is intended mainly for integer with small factors? Is my assumption that i can only use the lack of randomness after i find the first of the four factor, to then try to break the other key with the same factor, wrong?</p>\n\n<p>I would like if someone could just point me in right direction, instead of just giving the answer. Thank you. </p>\n', 'ViewCount': '33', 'Title': 'Finding prime factors of non-random key generator', 'LastActivityDate': '2014-03-05T05:41:29.360', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22291', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15293', 'Tags': '<algorithms><cryptography><randomness><primes>', 'CreationDate': '2014-03-05T03:22:05.833', 'Id': '22289'}{'Body': '<p>I was just reading something about NP-hard problems and cryptosystems. </p>\n\n<p>I was thinking: Every NP-complete problem can be reduced to another and every NP-complete problem has an equivalent (NP-hard) optimisation problem. A successful attack on one such NP-hard cryptosystem $A$ would mean that every other NP-hard cryptosystem $B$ would be vulnerable to that same attack; just reduce $B$ to $A$ and use the available attack. </p>\n\n<p>That would actually mean that we would be able to extend Information Set Decoding attack of Code-based systems to any NP-hard based cryptosystem.</p>\n\n<p>Is this consideration correct?</p>\n', 'ViewCount': '124', 'Title': 'Can all NP-complete cryptosystems be broken if one is broken?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T17:35:50.940', 'LastEditDate': '2014-03-24T22:51:15.960', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '5', 'OwnerDisplayName': 'user3313119', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-hard><cryptography>', 'CreationDate': '2014-03-22T22:34:35.087', 'FavoriteCount': '1', 'Id': '23000'}{'ViewCount': '150', 'Title': 'Could program verification techniques prevent bugs of the genre of Heartbleed from occurring?', 'LastEditDate': '2014-04-16T12:41:34.870', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'Mok-Kong Shen', 'PostTypeId': '1', 'OwnerUserId': '6437', 'FavoriteCount': '1', 'Body': '<p>On the matter of the Heartbleed bug, Bruce Schneier wrote in his Crypto-Gram of 15th April:\n\'"Catastrophic" is the right word. On the scale of 1 to 10, this is an 11.\' I read several years ago that a kernel of a certain operating system has been rigorously verified with a modern program verification system. Could hence bugs of the genre of Heartbleed be prevented from occurring via application of program verification techniques today or is this yet unrealistic or even principally impossible?</p>\n', 'Tags': '<cryptography><correctness-proof><security><software-verification><program-correctness>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-23T20:21:04.283', 'CommentCount': '1', 'CreationDate': '2014-04-15T14:30:22.640', 'Id': '23856'}{'Body': '<p>Is it necessary to take the same bit size of "p" and "q" in case of RSA algorithm? i had read that  bitsize of p and q must be same. BUT after calculating, i found that bit size could be different also. But time complexity will increase. Can anyone help me?</p>\n', 'ViewCount': '41', 'Title': 'In RSA, must $p$ and $q$ have the same number of bits?', 'LastEditorUserId': '7459', 'LastActivityDate': '2014-04-22T15:43:57.057', 'LastEditDate': '2014-04-22T12:17:50.873', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16982', 'Tags': '<cryptography>', 'CreationDate': '2014-04-22T10:33:54.657', 'Id': '24022'}{'Body': "<p>Is there any class of NP problems that have one unique solution?\nI'm asking that, because when I was studying cryptography I read about the knapsack and I found very interesting the idea.</p>\n", 'ViewCount': '106', 'Title': 'NP Problems with unique solution', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-23T14:33:23.040', 'LastEditDate': '2014-04-23T14:32:38.843', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'OwnerDisplayName': 'user3513151', 'PostTypeId': '1', 'OwnerUserId': '17026', 'Tags': '<complexity-theory><decision-problem><np><cryptography>', 'CreationDate': '2014-04-23T01:24:04.347', 'Id': '24043'}