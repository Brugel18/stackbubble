2850:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a function to count upper bits of a 32 bit value. So if a number is 11100011111..., the result is 3 as there are 3 ones in the most significant place before a 0 is hit.</p>\n\n<p>I need to convert the function to use only bitwise operations (no if statements or while loops) and the total number of operations should be lesser than 50.</p>\n\n<p>Question: How can this be converted to bitwise operations only while keeping less than 50 ops?</p>\n\n<p>Here is the Code:</p>\n\n<pre><code>  int count = 0;\n  int i = 28;\n\n  while(i &gt;= 0) {\n    int temp = (x&gt;&gt;i) &amp; 0xF;\n    i-=4;\n    if(temp == 0xF) count+=4;\n    else {\n      int mask = 0x1;\n      int a = (temp&gt;&gt;3) &amp; mask;\n      int b = (temp&gt;&gt;2) &amp; mask;\n      int c = (temp&gt;&gt;1) &amp; mask;\n      int d = temp &amp; mask;\n\n      if (a != 1) break;\n        count+=1;\n      if (b != 1) break;\n        count+=1;\n      if (c != 1) break;\n        count+=1;\n      if (d != 1) break;\n        count+=1;\n    }\n</code></pre>\n', 'ViewCount': '441', 'Title': 'Converting function to bitwise only?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-12T12:11:10.530', 'LastEditDate': '2012-09-11T11:43:56.560', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2771', 'Tags': '<algorithms><integers><binary-arithmetic>', 'CreationDate': '2012-09-10T02:05:39.293', 'FavoriteCount': '2', 'Id': '3484'},2851:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am performing an addition operation on two large binary numbers that have an equal number of bits. Both numbers are stored in an array of length $N$, which is rather large.</p>\n\n<p>At first I tried running a loop over them and keeping track of carry bits. This wasted time, because the aim is to get the bit at a specific position in this sum.</p>\n\n<p>So I modified my approach in following way. Starting from the specified index, I am looping until I find a 0 bit in same position on both numbers; I add only those parts to each other and return the bit at the specified position.</p>\n\n<p>This seems okay, but is this the best I can do? Recall that I want to get the value of one specific bit of the sum, given by its position.</p>\n', 'ViewCount': '384', 'Title': 'Get specified bit in addition of two large binary numbers', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-20T20:40:41.733', 'LastEditDate': '2012-09-20T20:40:41.733', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'Ravi Joshi', 'PostTypeId': '1', 'OwnerUserId': '2908', 'Tags': '<arrays><integers><binary-arithmetic>', 'CreationDate': '2012-09-20T14:01:20.360', 'Id': '4643'},2852:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this little exercise:</p>\n\n<pre><code>for ( i = 0; i &lt; 2 * n; i += 2 )\n  for ( j = 1; j &lt;= n; j &lt;&lt;= 1 )\n    if ( j &amp; i )\n      foo ();\n</code></pre>\n\n<p>(<code>j &lt;&lt;= 1</code> means <code>j = (j &lt;&lt; 1)</code>, where <code>&lt;&lt;</code> is the bitwise left shift operator. <code>&amp;</code> is the bitwise and operator.)</p>\n\n<p>I am supposed to determine how many times will the <em>foo</em> function be called for some <em>n</em>. The result should be both an exact number (or the most accurate approximation possible) and asymptotic (like O(n)).</p>\n', 'ViewCount': '195', 'Title': 'Double-nested loop with bitwise operation', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-13T02:07:02.597', 'LastEditDate': '2012-09-22T23:09:47.477', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'Machta', 'PostTypeId': '1', 'OwnerUserId': '12141', 'Tags': '<time-complexity><imperative-programming><binary-arithmetic>', 'CreationDate': '2012-01-12T17:25:30.387', 'Id': '4681'},2853:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is the procedure for computing the rank of a <a href="http://mathworld.wolfram.com/Multiset.html" rel="nofollow">multiset</a> after inserting an element?</p>\n\n<p>For instance, lets say we have a set $S = (0,1)$ containing $n = 2$ distinct elements.</p>\n\n<p>The multiset $M = (1,1)$ has rank $5$ because there are $4$ multisets less than it based on lexicographic ordering: $(0), (1), (0,0), (0,1)$.</p>\n\n<p>If we insert $0$, we get $(0,1,1)$ which has rank $8$. If $1$ were inserted instead we\'d have $(1,1,1)$ with rank $9$.</p>\n\n<p>Is there a function $f(r,x,n)$ which takes a rank $r$, an element $x$, and $n$, and returns the new rank after inserting $x$?</p>\n', 'ViewCount': '93', 'Title': 'Computing the rank of a multiset after inserting another element', 'LastEditorUserId': '4223', 'LastActivityDate': '2012-10-27T15:58:34.620', 'LastEditDate': '2012-10-27T07:27:16.467', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6339', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4223', 'Tags': '<algorithms><combinatorics><sets><binary-arithmetic>', 'CreationDate': '2012-10-27T01:53:27.787', 'Id': '6325'},2854:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd like to know if there is a function $f$ from n-bit numbers to n-bit numbers that has the following characteristics:</p>\n\n<ul>\n<li>$f$ should be bijective</li>\n<li>Both $f$ and $f^{-1}$ should be calculable pretty fast</li>\n<li>$f$ should return a number that has no significant correlation to its input.</li>\n</ul>\n\n<p>The rationale is this:</p>\n\n<p>I want to write a  program that operates on data. Some information of the data is stored in a binary search tree where the search key is a symbol of an alphabet. With time, I add further symbols to the alphabet. New symbols simply get the next free number available. Hence, the tree will always have a small bias to smaller keys which causes more rebalancing than I think should be needed.</p>\n\n<p>My idea is to mangle the symbol numbers with $f$ such that they are widely spread over the whole range of $[0,2^{64}-1]$. Since the symbol numbers only matter during input and output which happens only once, applying such a function should not be too expensive.</p>\n\n<p>I thought about one iteration of the Xorshift random number generator, but I don't really know a way to undo it, although it should theoretically be possible.</p>\n\n<p>Does anybody know such a function?<br>\nIs this a good idea?</p>\n", 'ViewCount': '151', 'Title': 'Function that spreads input', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-07T02:34:50.327', 'LastEditDate': '2013-01-31T06:57:46.533', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<binary-trees><hash><binary-arithmetic>', 'CreationDate': '2012-11-14T20:53:55.090', 'FavoriteCount': '2', 'Id': '6668'},2855:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having difficulty with the following question:</p>\n\n<blockquote>\n  <p>Given a bit pattern with mantissa $10110000$ and exponent $0111$, what\n  does the bit pattern represent in denary (i.e decimal / base 10)?</p>\n</blockquote>\n\n<p>I got the right answer(!) but the wrong (or alternative) work:</p>\n\n<ol>\n<li>Convert the exponent to denary: $0111$ is $7$</li>\n<li>Apply this exponent to the mantissa: $10110000\\rightarrow1011000$ after shifting $7$ places</li>\n<li>Convert the mantissa to denary: $1011000$ is $88$</li>\n<li>Set the sign: $-88$ (which is correct!)</li>\n</ol>\n\n<p>Using a different method, the mantissa $1.0110000$ is somehow deteremined to be $-11/16$ and then $-11/16 \\times 2^7 = - 88$ (I understand this shift with the exponent). However, what I don't understand is:</p>\n\n<blockquote>\n  <p><strong>How do you convert 1.0101 (mantissa) to -11/16?</strong> Is this a standard way to do it?</p>\n</blockquote>\n", 'ViewCount': '140', 'Title': 'Floating-Point Binary to Decimal', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T18:09:03.697', 'LastEditDate': '2012-11-19T18:09:03.697', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4614', 'Tags': '<terminology><binary-arithmetic>', 'CreationDate': '2012-11-16T12:02:13.513', 'Id': '6694'},2856:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a <a href="http://en.wikipedia.org/wiki/Binary_expression_tree" rel="nofollow">binary expresion tree</a>, with addition and multiplication operations, how can we optimize it\'s evaluation?</p>\n\n<p>Can we learn from <a href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication" rel="nofollow">matrix chain multiplication</a>? A <a href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication#Generalizations" rel="nofollow">generalization</a> of matrix chain multiplication is defined as:</p>\n\n<blockquote>\n  <p>Given a linear sequence of objects, an associative binary operation on those objects, and a way to compute the cost of performing that operation on any two given objects (as well as all partial results), compute the minimum cost way to group the objects to apply the operation over the sequence.</p>\n</blockquote>\n\n<p>What happens if we put <em>two</em> binary operators? <strong>Can the algorithm for <em>Matrix chain multiplication</em> be further generalized (or how can we otherwise solve this problem) to <em>two</em> binary operators in a <em>binary expresion tree</em>, given the cost functions of these operations?</strong> In particular, <strong>multiplication and addition, which complicates things further by allowing distribution</strong>. Also, does it matter that mind that some of the numbers can be negative, allowing reduction in size of intermediate results (see <a href="http://cs.stackexchange.com/q/1424/2755">Overflow safe summation</a>)?</p>\n\n<p><strong>Also, how does this relate to  <a href="http://en.wikipedia.org/wiki/Graph_reduction" rel="nofollow">Graph Reduction</a>?</strong></p>\n\n<p>I also remember learning about database <a href="http://en.wikipedia.org/wiki/Query_optimization" rel="nofollow">query optimization</a> which seemed to do something similar to determine how early to execute particular joins to keep the intermediate values smaller.</p>\n', 'ViewCount': '422', 'Title': 'Chained operations on sequences with two operators', 'LastEditorUserId': '2755', 'LastActivityDate': '2012-11-28T22:31:40.290', 'LastEditDate': '2012-11-28T22:31:40.290', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<optimization><binary-trees><dynamic-programming><efficiency><arithmetic>', 'CreationDate': '2012-11-20T18:58:03.297', 'FavoriteCount': '1', 'Id': '6790'},2857:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '158', 'Title': 'How can repeated addition/multiplication be done in polynomial time?', 'LastEditDate': '2012-11-22T23:53:23.740', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2860', 'FavoriteCount': '1', 'Body': '<p>I can see how adding 2 unsigned four-bit values is $O(n)$. We just go from the rightmost digits to the leftmost digits and add the digits up sequentially. We can also perform multiplication in polynomial time ($O(n^2)$) via the algorithm we all learned in grade school.</p>\n\n<p>However, how can we add up or multiply say $i$ numbers together in polynomial time? After we add up 2 numbers together, we get a bigger number that will require more bits to represent. Same with multiplication.</p>\n\n<p>How can we ensure that these extra bits do not produce exponential blowup?</p>\n', 'Tags': '<time-complexity><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-23T00:03:19.090', 'CommentCount': '1', 'AcceptedAnswerId': '6845', 'CreationDate': '2012-11-22T23:18:09.637', 'Id': '6843'},2858:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://en.wikipedia.org/wiki/Fibonacci_number" rel="nofollow">Binet\'s formula</a> for the nth Fibonacci numbers is remarkable because the equation "converts" via a few arithmetic operations an irrational number $\\phi$ into an integer sequence. However, using finite precision arithmetic, one would always have some (small) roundoff error. </p>\n\n<blockquote>\n  <p>Is there a discussion/description somewhere of how to calculate the Fibonacci sequence using Binet\'s formula (ie <em>not</em> the recurrence relation) and floating point arithmetic which results in no roundoff error?</p>\n</blockquote>\n', 'ViewCount': '277', 'Title': "Calculating Binet's formula for Fibonacci numbers with arbitrary precision", 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-04T09:51:48.217', 'LastEditDate': '2012-12-04T04:02:54.733', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7150', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '699', 'Tags': '<algorithms><discrete-mathematics><floating-point><arithmetic><mathematical-programming>', 'CreationDate': '2012-12-04T03:33:25.020', 'Id': '7145'},2859:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '356', 'Title': 'Finding maximum and minimum of consecutive XOR values', 'LastEditDate': '2012-12-28T21:15:49.023', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '5218', 'FavoriteCount': '1', 'Body': '<p>Given an integer array (maximum size 50000), I have to find the minimum and maximum $X$ such that $X = a_p \\oplus a_{p+1} \\oplus \\dots \\oplus a_q$ for some $p$, $q$ with $p \\leq q$.</p>\n\n<p>I have tried this process: $\\text{sum}_i = a_0 \\oplus a_1 \\oplus  \\dots \\oplus a_i$ for all $i$. I pre-calculated it in $O(n)$ and then the value of $X$ for some $p$, $q$ such that $(p\\leq q)$ is: $X = \\text{sum}_q \\oplus \\text{sum}_{p-1}$. Thus:</p>\n\n<p>$$\n\\mathrm{MinAns} = \\min_{(p,q) \\text{ s.t. } p\\le q}{\\text{sum}_q \\oplus \\text{sum}_{p-1}} \\\\\n\\mathrm{MaxAns} = \\max_{(p,q) \\text{ s.t. } p\\le q}{\\text{sum}_q \\oplus \\text{sum}_{p-1}} \\\\\n$$</p>\n\n<p>But this process is of $O(n^2)$. How can I do that more efficiently?</p>\n', 'Tags': '<algorithms><algorithm-analysis><performance><binary-arithmetic><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-29T05:03:58.663', 'CommentCount': '1', 'AcceptedAnswerId': '7640', 'CreationDate': '2012-12-28T03:12:04.687', 'Id': '7622'},28510:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2499', 'Title': 'Normalizing the mantissa in floating point representation', 'LastEditDate': '2013-01-09T11:44:45.023', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4422', 'FavoriteCount': '0', 'Body': "<p>How to represent $0.148 * 2^{14}$ in normalized floating point arithmetic with the format</p>\n\n<pre><code>1 - Sign bit\n7 - Exponent in Excess-64 form\n8 - Mantissa\n</code></pre>\n\n<p>$(0.148)_{10} = (0.00100101\\;111...)_2$</p>\n\n<p>We shift it 3 bits to left to make it normalized $(1.00101\\;111)_2 * 2^{11}$. </p>\n\n<p>Exponent = $11+64 = (75)_{10} = (1001011)_2$ and Mantissa = $(01001\\;111)_2$.</p>\n\n<p>So floating point representation is $(0\\;1001011\\;00101111)_2 = (4B2F)_{16}$ <strong>Representation A</strong></p>\n\n<p>But if we store the denormalized mantissa into 8 bit register, then it won't have stored the last three $1$s and then the mantissa would have normalized from $(0.00100101)_2$ to $(1.00101\\;000)_2$ by inserting 3 $0$s instead of $1$s.</p>\n\n<p>The representation would have been $(0\\;1001011\\;00101000)_2 = (4B28)_{16}$ <strong>Representation B</strong></p>\n\n<p>So while normalizing, does the processor takes into account the denormalized mantissa bits beyond 8 bits too? Or just rounds it off? Which one is correct: <strong>A</strong> or <strong>B</strong>?</p>\n\n<p>Does it store the mantissa in fixed point representation? How does it all work?</p>\n", 'Tags': '<binary-arithmetic><floating-point><rounding>', 'LastEditorUserId': '4422', 'LastActivityDate': '2013-01-09T11:44:45.023', 'CommentCount': '0', 'AcceptedAnswerId': '7847', 'CreationDate': '2013-01-08T06:59:08.923', 'Id': '7828'},28511:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On a PC I am implementing an algorithm in which a number from a look table will be chosen randomly, and will be multiplied by 1000 or 10000. Instead of multiplying by 1000 or 10000 I am thinking of simply padding the numbers with the required 0s. This padding will be nothing but some write operations (though random writes) in memory. </p>\n\n<p>Which is more computationally efficient: multiplication or 0 padding?      </p>\n', 'ViewCount': '92', 'Title': 'Which is more computationally efficient: multiplication or 0 padding?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-01T10:45:11.737', 'LastEditDate': '2013-02-01T10:45:11.737', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9352', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<efficiency><binary-arithmetic>', 'CreationDate': '2013-01-31T11:45:12.727', 'Id': '9350'},28512:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Theoretically, if I were to subtract the number 10 from the ASCII character 10 (which is really 00110001 00110000), what would I get?</p>\n\n<p>Does the computer add both ASCII characters and subtract?  </p>\n', 'ViewCount': '286', 'Title': 'Subtracting an integer from an ASCII number', 'LastActivityDate': '2013-02-01T17:52:29.260', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '9402', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-02-01T04:05:36.380', 'Id': '9377'},28513:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm being asked this question for my computer conceptes class, can't find anything about this in my text book, and have only been able to find half-baked answers googling it.</p>\n\n<p>Why is binary subtraction referred to as the invert-add-shift-add method?</p>\n", 'ViewCount': '108', 'Title': 'Why is binary subtraction referred to as the invert-add-shift-add method?', 'LastActivityDate': '2013-02-04T05:13:12.510', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9460', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6694', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-02-03T23:53:52.910', 'Id': '9457'},28514:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '135', 'Title': 'Minimizing the full adder - where did this XOR come from?', 'LastEditDate': '2013-02-17T20:00:31.630', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6921', 'FavoriteCount': '1', 'Body': "<p>When minimizing the full adder, I don't understand why $A(\\bar{B}\\bar{C} + BC)$ reduces to $A\\overline{(B\\oplus{C})}.$</p>\n\n<p>$(\\bar{B}\\bar{C} + BC)\\to (B\\oplus{C})$ is partially decipherable, but why is $(B\\oplus{C})$ inverted to $\\overline{(B\\oplus{C})}?$</p>\n\n<hr>\n\n<p>Full adder simplification:</p>\n\n<p>$\n\\bar{A}\\bar{B}C + \\bar{A}B\\bar{C} + A\\bar{B}\\bar{C} + ABC \\\\\n= \\bar{A}(\\bar{B}C + B\\bar{C}) + A(\\bar{B}\\bar{C} + BC) \\\\\n= \\bar{A}(B\\oplus{C}) + A(\\overline{B\\oplus{C}}) \\\\\n= A\\oplus{(B\\oplus{C})}\n$</p>\n\n<hr>\n\n<h3>Could you help me out?</h3>\n\n<p>PS: I hope that this is the correct subforum of StackExchange to ask this (perhaps <em>Electrical Engineering</em> is the proper venue). I couldn't find appropriate tags on <em>either</em> site.</p>\n", 'Tags': '<binary-arithmetic><xor>', 'LastEditorUserId': '6921', 'LastActivityDate': '2013-02-17T20:11:58.480', 'CommentCount': '6', 'AcceptedAnswerId': '9869', 'CreationDate': '2013-02-17T19:43:33.377', 'Id': '9866'},28515:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to solve the following problem: </p>\n\n<p>$$ 6AD3 - AF20 $$</p>\n\n<p>Both of these are hex values in two's complement.</p>\n\n<p>I keep getting one answer but it's turning out worng. What I tried to do, was take the complement of AF20, which I got as 50D1, and instead of subtracting, I added it to 6AD3, and I got BBA4, however, I am being told this is the wrong answer.</p>\n\n<p>Where am I going wrong?</p>\n", 'ViewCount': '42', 'Title': "Subtracting a two's complement value from another two's complement value", 'LastActivityDate': '2013-03-06T06:54:06.033', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-03-06T00:57:40.247', 'Id': '10308'},28516:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been looking into the math behind converting from any base to any base. This is more about confirming my results than anything. I found what seems to be my answer on mathforum.org  but I'm still not sure if I have it right. I have the converting from a larger base to a smaller base down okay because it is simply take first digit multiply by base you want add next digit repeat. My problem comes when converting from a smaller base to a larger base. When doing this they talk about how you need to convert the larger base you want into the smaller base you have. An example would be going from base 4 to base 6 you need to convert the number 6 into base 4 getting 12. You then just do the same thing as you did when you were converting from large to small. The difficulty I have with this is it seems you need to know what one number is in the other base. So I would of needed to know what 6 is in base 4. This creates a big problem in my mind because then I would need a table. Does anyone know a way of doing this in a better fashion. </p>\n\n<p>I thought a base conversion would help but I can't find any that work. And from the site I found it seems to allow you to convert from base to base without going through base 10 but you first need to know how to convert the first number from base to base. That makes it kinda pointless.</p>\n\n<p>Commenters are saying I need to be able to convert a letter into a number. If so I already know that. That isn't my problem however.\nMy problem is in order to convert a big base to a small base I need to first convert the base number I have into the base number I want. In doing this I defeat the purpose because if I have the ability to convert these bases to other bases I've already solved my problem.</p>\n\n<p>Edit: I have figured out how to convert from bases less than or equal to 10 into other bases less than or equal to 10. I can also go from a base greater than 10 to any base that is 10 or less. The problem starts when converting from a base greater than 10 to another base greater than 10. Or going from a base smaller than 10 to a base greater than 10. I don't need code I just need the basic math behind it that can be applied to code.</p>\n", 'ViewCount': '3899', 'Title': 'The math behind converting from any base to any base without going through base 10?', 'LastEditorUserId': '6912', 'LastActivityDate': '2013-03-12T23:02:49.237', 'LastEditDate': '2013-03-12T21:18:02.180', 'AnswerCount': '4', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6912', 'Tags': '<algorithms><arithmetic><number-formats>', 'CreationDate': '2013-03-06T14:17:37.380', 'FavoriteCount': '2', 'Id': '10318'},28517:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am looking for a way to implement division in modular arithmetic using modulo prime.</p>\n\n<p>The method I found in math books is to <strong>try</strong> $u$ such that</p>\n\n<p>$au \\equiv 1 \\pmod{p}$</p>\n\n<p>$b/a \\equiv bu \\pmod{p}$</p>\n\n<p>where $a, b, u \\in Z_p$ (remainder class of mod p) and $p$ is a prime number. But trying things isn't probably a good and <em>fast</em> approach (as it seems to me it has linear complexity and my $p$ can be <em>big</em>, up to $10^9$). What is the right way to do division in modulo prime?</p>\n", 'ViewCount': '72', 'Title': 'Dividing in modulo prime arithmetic', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-16T19:12:23.223', 'LastEditDate': '2013-03-16T19:12:23.223', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10553', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7287', 'Tags': '<arithmetic>', 'CreationDate': '2013-03-16T14:41:48.407', 'Id': '10552'},28518:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How would I solve the following can anyone help me.I know MIPS is basically how many instruction the processor can do per second but what should I do?</p>\n\n<p>Assume that we are receiving a message across a network using a modem with a rate of 56,000 bits/second. Furthermore assume that we are working on a workstation with an instruction rate of 500 mips. How many instructions can the processor execute between the receipt of each individual bit of the message?</p>\n', 'ViewCount': '413', 'Title': 'Network modem question', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-18T01:17:39.627', 'LastEditDate': '2013-03-17T21:29:54.510', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10589', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7002', 'Tags': '<computer-architecture><coding-theory><arithmetic>', 'CreationDate': '2013-03-16T20:33:11.283', 'Id': '10561'},28519:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is the complexity class <a href="https://en.wikipedia.org/wiki/Elementary_recursive" rel="nofollow">ELEMENTARY</a> that captures all problems that can be solved by using elementary recursive function only. So if algorithms for solving problems in some complexity class (e.g. NP or P) are converted to elementary recursive function form, would they retain time complexity of the complexity class? </p>\n\n<p>For example, in complexity class P, we know that problems take deterministic polynomial time to solve. Would an elementary recursive form of a solving algorithm retain this complexity?</p>\n\n<p>By converting into elementary recursive form, I mean:</p>\n\n<p>Yes, it is true that NP is in elementary, that is there is an elementary recursive algorithm that can solve NP problems, but what I ask is "will such algorithm retain its time complexity?" For example, complexity P has problems that can be solved in polynomial time complexity; however, it is not clear whether it will retain polynomial time complexity if the algorithm has to be in elementary recursive form.</p>\n\n<p>By my understanding, elementary recursive algorithm would be the one that does not necessarily use "if and else".</p>\n\n<p>Modification to the question: Let us say that for all decision problems we consider, there exist function problems that have same time complexity as their decision problem counterparts. For example, for 3-SAT problem with some input $x$, one satisfying assignment to the variables is treated as output. The reason why some people think this question is not valuable may be because for all decision problems, output is always either zero or one. So let us consider the function version of decision problems (that keeps time complexity).</p>\n', 'ViewCount': '122', 'ClosedDate': '2013-04-20T20:27:22.187', 'Title': 'Does converting algorithms into elementary recursive form preserve runtime bounds?', 'LastEditorUserId': '7743', 'LastActivityDate': '2013-04-18T08:30:59.960', 'LastEditDate': '2013-04-16T15:12:54.647', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7720', 'Tags': '<complexity-theory><time-complexity><arithmetic>', 'CreationDate': '2013-04-14T06:57:39.190', 'Id': '11302'},28520:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need to find largest value for $\\frac{\\phi(i)}{i}$ for $i \\in (2, N)$ where $N$ can be as large as $10^{18}$.</p>\n\n<p>I tried this approach , but is too slow.\nFinding the just smallest prime number to $N$, as its $\\frac{\\phi(i)}{i}$ value is $\\frac{i-1}{i}$, which is maximum in the range. (See <a href="http://math.stackexchange.com/questions/381053/maximum-of-frac-phiii">Maximum of \u03d5(i)i\\frac{\\phi(i)}i</a>)</p>\n\n<p>So, I was wondering if there is any other faster way to find the maximum value. More precisely I need the value of i where $\\frac{\\phi(i)}{i}$ is maximum.</p>\n', 'ViewCount': '76', 'Title': 'Finding largest value for $\\frac{\\phi(i)}{i}$ for $i \\in (2, N)$', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-08T15:05:00.257', 'LastEditDate': '2013-05-08T14:20:51.633', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7711', 'Tags': '<algorithms><arithmetic><primes>', 'CreationDate': '2013-05-08T09:29:46.807', 'Id': '11885'},28521:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to perform some interval-operations, and for addition, subtraction, and logic-/shift-operators, that works very well.</p>\n\n<p>The only problem I have is the multiplication.</p>\n\n<p>An interval $[a, b]$ denotes all two\'s complement numbers $x$ with the property $a \\leq x \\leq b$.</p>\n\n<p>An interval-operation means that if i have a binary operation $\\circ$ and two intervals $[a, b]$ and $[c, d]$, then $[a, b] \\circ [c, d] = [e, f]$ means that for for an arbitrary $x \\in [a, b]$ and $y \\in [c, d]$: $$x \\circ y \\in [e, f].$$</p>\n\n<p>But additionally, I want to have the most precise or a very precise interval.</p>\n\n<p>"The most precise" means that there are the values $w,x \\in [a, b]$ and $y,z \\in [c, d]$ for which holds that $w \\circ y = e$ and $x \\circ z = f$</p>\n\n<p>An example of an interval-operation:</p>\n\n<ul>\n<li>$A = [7,14]$</li>\n<li>$B = [-6, 77]$</li>\n<li>$A + B = [1, 91]$</li>\n</ul>\n\n<p>It\'s correct, because there is no value outside of $[1, 91]$ that can be reached, when adding numbers out of $A$ and $B$.</p>\n\n<p>Also it\'s precise, because $7+(-6) = 1$ and $14+77 = 91$</p>\n\n<p>It seems impossible to find an efficient algorithm that handles all the overflows correctly and finds the precise (or at least a good) interval.</p>\n\n<p>Is there a good algorithm?</p>\n', 'ViewCount': '103', 'Title': "Multiplying intervals in Two's complement", 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-06T14:53:16.570', 'LastEditDate': '2013-06-06T14:53:16.570', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3133', 'Tags': '<binary-arithmetic><arithmetic><intervals>', 'CreationDate': '2013-05-29T15:43:49.867', 'Id': '12360'},28522:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve got the following theoretical problem which puzzles me a bit:</p>\n\n<p>I can obtain a string of <em>n</em> bytes (as octets, one byte = one octet = eight bits) of random data. I need to preserve the randomness <em>while</em> reducing the base from 256 to <em>x</em> where <em>x</em> is below 256 (and not 0, 1, 2, 4, 8, 16, 32, 64 or 128).</p>\n\n<p>As I want to preserve the randomness, I don\'t want to cut-off (waste) any information from this string <em>until</em> I\'ve obtained the number of chunks I need. This is for reason of randomness which can be a limited resource on the computer.</p>\n\n<p>I had the idea to do this for base64 which is simple because I can just create 4 numbers out of a single byte (by shifting bits for example: <a href="http://cvsweb.openwall.com/cgi/cvsweb.cgi/projects/phpass/PasswordHash.php?rev=1.8" rel="nofollow">encode64()</a>). But how to do with a base like 254 for example? I can not cut off at bit-boundaries here, can I?</p>\n\n<p>Do I probably need to create a number large enough out of base 2 based bits that can contain both bases? (This is one of the ideas I have so far).</p>\n\n<p>Would be great to get some feedback, I normally paint pictures with such problems, however, just discovered this website here yesterday and I normally use Stackoverflow so I thought I give it a try :D</p>\n\n<p>If you\'re interested in some non-theoretical background to my question, see <a href="http://security.stackexchange.com/q/39417/17473"><em>"What is the meaning of the term \u201csimple string\u201d for the SALT string in Unix crypt using SHA-256 and SHA-512?"</em></a>, you might get an idea why I don\'t want to loose any information bits from the random source.</p>\n', 'ViewCount': '71', 'Title': 'Bitarithmetrics to Base X', 'LastEditorUserId': '9321', 'LastActivityDate': '2013-07-25T07:53:02.513', 'LastEditDate': '2013-07-25T07:53:02.513', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '13419', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9321', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-07-24T10:39:21.783', 'Id': '13415'},28523:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the following function, let $n \\geq m$.  </p>\n\n<pre><code>int gcd(n,m)  \n{  \n if (n % m == 0) return m;  \n n = n % m;  \n return gcd(m, n);  \n}\n</code></pre>\n\n<p>How many recursive calls are made by this function?</p>\n\n<ul>\n<li>$\\Theta (\\log_2 n)$</li>\n<li>$\\Omega (n)$</li>\n<li>$\\Theta (\\log_2(\\log_2 n))$</li>\n<li>$\\Theta ( \\sqrt{n} )$  </li>\n</ul>\n\n<p>I think the answer is $\\Theta (\\log_2(\\log_2n))$, but my book is saying $\\Theta (\\log_2 n)$.    </p>\n\n<p>My reasoning is as follows. Here we are not dividing the number. If there was a division then it would be $\\log n$. But here operation is $\\bmod$. So we will get a very small number after the first call. So it must be $\\log \\log n$. Am I thinking correctly?</p>\n', 'ViewCount': '259', 'Title': 'How many recursive calls are made by this gcd function?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-19T12:42:07.087', 'LastEditDate': '2013-08-17T18:18:39.033', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9343', 'Tags': '<algorithms><algorithm-analysis><arithmetic>', 'CreationDate': '2013-08-15T17:26:36.207', 'Id': '13761'},28524:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose I have two polynomials $f(x)$ and $g(x)$ and I somehow represent their coefficients.\nI have a couple of ways to hold a polynomial depending on how many significant coefficients the polynomial has.\nI want to determine the amount of significant coefficients in the results of\n$f(x) + g(x)$ ,$f(x) \\cdot g(x)$ , $f(x) - g(x)$ etc. .</p>\n\n<p>But I'd like to do it before I create the object that holds them, is there some efficient way of doing this without calculating the result twice?</p>\n\n<p>I can assume that I know the current rank and number of elements in $f(x)$ and $g(x)$</p>\n\n<p>If this is not possible knowing that the new polynomial's non-trivial coefficients will be at least half of the rank will suffice, but I'm unsure how to do it as well.</p>\n\n<p>I did try to apply various heuristics but didn't come up with something consistent and fast. </p>\n", 'ViewCount': '67', 'Title': 'Calculate the number of elements after multiplying/adding two polynomials', 'LastActivityDate': '2013-08-28T21:13:52.333', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14006', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8709', 'Tags': '<algorithms><time-complexity><optimization><efficiency><arithmetic>', 'CreationDate': '2013-08-28T19:13:48.453', 'Id': '13997'},28525:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '39', 'Title': "Compute 'permutation' like problem with modulo", 'LastEditDate': '2013-09-18T08:31:08.223', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10193', 'Body': "<p>Say, I have some permutation or combination formula like this,<br>\n$$\\frac{n!}{(n-r)!r!},$$\nand I want to $\\bmod$ the result with some big prime ($10^9+7$ for example). </p>\n\n<p>I already tried with modular operation and multiplicative inverse but failed (I don't quite understand them). Can someone give me some example in code so I can grasp the idea? (I prefer C).</p>\n", 'ClosedDate': '2013-09-18T09:18:08.173', 'Tags': '<arithmetic>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-18T08:31:08.223', 'CommentCount': '4', 'AcceptedAnswerId': '14407', 'CreationDate': '2013-09-18T05:37:42.567', 'Id': '14402'},28526:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2654', 'Title': 'Factorial algorithm more efficient than naive multiplication', 'LastEditDate': '2013-09-20T08:18:53.507', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '7307', 'FavoriteCount': '2', 'Body': "<p>I know how to code for factorials using both iterative and recursive (e.g. <code>n * factorial(n-1)</code> for e.g.). I read in a textbook (without been given any further explanations) that there is an even more efficient way of coding for factorials by dividing them in half recursively. </p>\n\n<p>I understand why that may be the case. However I wanted to try coding it on my own, and I don't think I know where to start though. A friend suggested I write base cases first. and I was thinking of using arrays so that I can keep track of the numbers... but I really can't see any way out to designing such a code.</p>\n\n<p>What kind of techniques should I be researching?</p>\n", 'Tags': '<algorithms><efficiency><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-16T08:26:18.543', 'CommentCount': '0', 'AcceptedAnswerId': '14476', 'CreationDate': '2013-09-20T02:00:56.260', 'Id': '14456'},28527:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>C++11 has a convenient Bernoulli RNG, illustrated at \n<a href="http://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution" rel="nofollow">http://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution</a> .\nHowever, distilling an entire random integer into a single random bit seems inefficient when the expectation parameter $p$ is rational with a small or power-of-two denominator.\nIs there a reasonably fast way to generate 32 random Bernoulli bits at once in such cases? My application uses long streams of bits, so I can keep track of statistics if needed (but this would consume runtime).</p>\n', 'ViewCount': '78', 'Title': "Isn't std::bernoulli_distribution inefficient? Designing a bit-parallel Bernoulli generator", 'LastEditorUserId': '5189', 'LastActivityDate': '2013-09-25T04:26:33.097', 'LastEditDate': '2013-09-25T04:26:33.097', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5189', 'Tags': '<randomized-algorithms><integers><randomness><binary-arithmetic>', 'CreationDate': '2013-09-22T21:10:38.360', 'Id': '14525'},28528:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Reading the Appendix A (<em>Binary numbers</em>) of <em>Structured Computer organization</em> by Tanenbaum I've found this exercise:</p>\n\n<blockquote>\n  <p>Signed decimal numbers consisting of $n$ digits can be represented in $n + 1$ digits without a sign. Positive numbers have $0$ as the leftmost digit. Negative numbers are formed by subtracting each digit from $9$. Thus the negative of $014725$ is $985274$. Such numbers are called <strong>nine</strong>\u2019s complement numbers and are analogous to one\u2019s complement binary numbers. Express the following as three-digit <strong>nine</strong>'s complement numbers: $6$. $-2$, $100$, $-14$, [etc].</p>\n</blockquote>\n\n<p>Ok, it all works fine with $6$ for instance: using the given rule it is $006 \\mapsto 993$. That makes sense: as Tanenbaum says this system for negative-value representation is similar to <strong>one</strong>'s complement: it has two different <em>zero</em> representation ($000$ and $999$) and it has negative possible value as much as the positive ones.</p>\n\n<p>What I don't understand is how can $100$ fit in this scenario. To me, with 3 digits I ca only represent value in range $[-900, 099]$; moreover $100$ is <em>not</em> considered a <em>positive</em> number --it shoudl have a $0$ as leftmost digit.</p>\n\n<p>Is there an error in Tanenbaum-exercise?, if not, where I'm wrong?</p>\n", 'ViewCount': '179', 'Title': "Can I express 100 as a three-digit 9's complement number?", 'LastActivityDate': '2013-11-04T20:09:53.287', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10482', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-10-05T14:19:28.047', 'Id': '14828'},28529:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I am given a number $n$ (less than $10^8$) and $m$ (less than $10^7$) and $p$ (less than $10^4$), I have to write a program to find number of numbers that divide $n^m$ exactly $p$ times.</p>\n\n<p>Mathematically, I have to find number of distinct $x$ such that\n$$ n^m \\equiv 0 \\mod x^p \\qquad\\text{and}\\qquad n^m \\ne 0 \\mod x^{p+1} $$</p>\n\n<p>(From <a href="http://uva.onlinejudge.org/external/122/12216.html" rel="nofollow">UVa Online Judge</a>)</p>\n\n<p>What approach could be better than brute force?</p>\n', 'ViewCount': '55', 'Title': 'Finding number of numbers dividing n^m exactly p times', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-10T09:25:41.220', 'LastEditDate': '2013-10-10T09:25:41.220', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7890', 'Tags': '<algorithms><number-theory><arithmetic><mathematical-programming>', 'CreationDate': '2013-10-10T08:27:13.950', 'Id': '14981'},28530:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this question I'm struggling with. </p>\n\n<p>Let $A=\\{&lt;i,n&gt;|\\;n \\in \\phi ^{(i)}\\}$. In other words, $A$ is the language defined by the set of all pairs $&lt;i,n&gt;$ such that $n$ is $\\leq_m$ to the $i$th Turing jump.\nA is definitely not an arithmetically definable language, and you can prove this by contradiction. </p>\n\n<p>I have to find a language, let's say $B$, that is more complex than $A$ $i.e.$ $B\\nleq_T A$. I thought about $B=\\{&lt;i,n&gt;|\\;n \\not\\in \\phi ^{(i)}\\}$, but I'm not sure about my reasoning, I think an oracle turing machine with an oracle $A$ couldn't reduce to $B$..</p>\n\n<p>And one last thing, do you think there exists a language that is more complex than any other (it doesn't reduce to anything)?</p>\n\n<p>If you have any hints that could help me solve those two questions I would be really grateful! </p>\n", 'ViewCount': '62', 'Title': 'What would be a not arithmetically definable language that is not Turing reducible to another given not arithmetically definable language?', 'LastActivityDate': '2013-10-24T16:13:26.107', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '16405', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<complexity-theory><computability><reductions><arithmetic>', 'CreationDate': '2013-10-21T00:29:52.033', 'Id': '16271'},28531:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given three numbers $m$, $n$ and $p$ in interleaved binary encoding<sup>1</sup>, it\'s obviously possible to check in $O(1)$ space whether $m+n=p$. It\'s less obvious<sup>2</sup> that it isn\'t possible  to check in $O(1)$ space whether $m\\cdot n=p$. I wonder whether one can prove that it isn\'t possible to check in $O(\\log N)$ space<sup>3</sup> whether $m\\cdot n=p$. On the other hand, are there any known non-trivial upper bounds on the space complexity of this problem, like $O(N/\\log N)$? </p>\n\n<p>The problem described above is a simplified version of the "Multiplication decision problem: Is the $k$th bit of the product of $m$ and $n$ a one?" Since this problem is more "powerful" (and also better known), I wonder whether one can show that this problem can\'t be decided in $O((\\log N)^2)$ space.</p>\n\n<hr>\n\n<p><sub>\n1. The interleaved binary encoding starts with the lowest significant bit, and allows "leading" zeros for the most significant bits.\n</sub></p>\n\n<p><sub>\n2. The proof idea I have in mind would use such an algorithm as building block for a decision procedure of Robinson arithmetic. I call this less obvious, because the fact that Robinson arithmetic is undecidable may be well known, but still remains non-trivial.\n</sub></p>\n\n<p><sub>\n3. Here $N$ is the length of the input $m$, $n$ and $p$ in binary encoding.\n</sub></p>\n', 'ViewCount': '82', 'Title': 'Known bounds on space complexity of multiplication decision problem', 'LastEditorUserId': '1557', 'LastActivityDate': '2013-10-27T19:35:21.797', 'LastEditDate': '2013-10-27T14:32:42.443', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1557', 'Tags': '<space-complexity><binary-arithmetic>', 'CreationDate': '2013-10-27T12:32:23.403', 'Id': '16469'},28532:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to use gates that do addition and multiplication modulo 5 to emulate logic gates.</p>\n\n<p>Assuming false and true are mapped to 0 and 1 respectively (with 2, 3, and 4 being invalid), I figured out I can map the operations like this:</p>\n\n<pre><code>a and b -&gt; a*b (mod 5)\na or b -&gt; 2*(a+b)*(a+b+2) (mod 5)\n</code></pre>\n\n<p>I was wondering if there was a simpler approach.</p>\n\n<p>For the application I have in mind, a toy example of secure multi party computation using secret sharing, I haven't shown/discovered/figured-out yet if it's safe to re-use private values. If I have to recompute a, b, and a+b two times in order to do an <code>or</code>, costs would be exponential in the length of the circuit. (I'm only using tiny circuits so that's not a big deal, but it would be interesting to know if it was just a non-issue via a clever transformation.)</p>\n", 'ViewCount': '59', 'Title': 'Emulating boolean circuits using addition and multiplication (mod 5)', 'LastEditorUserId': '535', 'LastActivityDate': '2013-11-11T07:20:35.247', 'LastEditDate': '2013-11-11T06:06:12.970', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '17909', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '535', 'Tags': '<circuits><modular-arithmetic>', 'CreationDate': '2013-11-11T05:59:47.090', 'Id': '17908'},28533:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to subtract these two binary numbers:</p>\n\n<p>$  1110\n- 1011$</p>\n\n<p>First I convert 1011 to two's complement by doing 1011 to 0100 and then adding 1 to get 0101. Then I add the first number to the converted two's complement number:</p>\n\n<p>$1110$</p>\n\n<p>$+$ $0101$</p>\n\n<p>$-----$</p>\n\n<p>$0011$</p>\n\n<p>0 + 1 = 1</p>\n\n<p>1 + 0 = 1</p>\n\n<p>1 + 1 = 0 carry 1</p>\n\n<p>carry 1 + 1 + 0 = 0</p>\n\n<p>For a final answer of $0011$ which is 3 in decimal, however, the answer in my book says it should be 2 or 0010...?</p>\n", 'ViewCount': '57', 'Title': "Subtracting binaries using two's complement", 'LastActivityDate': '2013-11-12T03:52:34.110', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '17943', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11322', 'Tags': '<computer-architecture><binary-arithmetic>', 'CreationDate': '2013-11-12T01:20:50.483', 'Id': '17939'},28534:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '107', 'Title': "Implement Mathematica's capability of rationalizing machine reals", 'LastEditDate': '2014-03-24T14:14:18.297', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'LCFactorization', 'PostTypeId': '1', 'OwnerUserId': '11634', 'Body': '<p>If I have a variable <code>x</code> bound to a machine precision real in <em>Mathematica</em>, I can use</p>\n\n<pre><code> y = FromDigits[RealDigits[x]]\n</code></pre>\n\n<p>then y is bound to a <em>completely equivalent</em> rational number which has <em>infinite precision</em>.</p>\n\n<p>What are the basic principles behind <code>FromDigits</code> and <code>RealDigits</code>?\nHow could I implement a similar conversion using common machine operations (fixed-size integers and floating point operations) to coerce a double in a rational, or at least obtain the long integer denominator and numerator of a double?</p>\n', 'Tags': '<number-theory><arithmetic><real-numbers>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-24T14:14:18.297', 'CommentCount': '4', 'AcceptedAnswerId': '18417', 'CreationDate': '2013-11-26T05:43:58.190', 'Id': '18365'},28535:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>What is the range of \u201cthe\u201d CRC-32, the one used by <a href="http://pubs.opengroup.org/onlinepubs/009695299/utilities/cksum.html" rel="nofollow">Unix</a>, Ethernet, zip, and many other industrial standards?</p>\n\n<p>Mathematically, a <a href="http://en.wikipedia.org/wiki/CRC" rel="nofollow">CRC</a> is defined as follows: let $G$ be the CRC polynomial in $\\mathbb{F}_2[X]$, and $M$ be a representation of the input bitstring in $\\mathbb{F}_2[X]$. Let $Q$ be the quotient of $M \\cdot X^{\\deg G}$ by $G$; the CRC value is $\\bar Q(2)$ where $\\bar Q$ is the canonical injection of $Q$ into $\\mathbb{Z}[X]$. The codomain of the CRC function is thus the integer range $[0,2^{\\deg G}-1]$ (or equivalently the set of polynomials of degree $\\le \\deg G$). Which values are reachable?</p>\n\n<p>This question is specifically about $$\\scriptstyle G = G_{Ethernet} = X^{32}+X^{26}+X^{23}+X^{22}+X^{16}+X^{12}+X^{11}+X^{10}+X^{8}+X^{7}+X^{5}+X^{4}+X^{2}+X^{1}+X^{0}$$\nthough I\'m curious whether the result generalizes to other <a href="https://en.wikipedia.org/wiki/CRC-32#Commonly_used_and_standardized_CRCs" rel="nofollow">common CRC</a>.</p>\n\n<p>Bonus: is there anything known and interesting about the relative density of preimages?</p>\n', 'ViewCount': '43', 'Title': 'Range of CRC-32', 'LastActivityDate': '2013-12-01T01:19:48.777', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18433', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<arithmetic><error-correcting-codes>', 'CreationDate': '2013-11-28T00:33:47.417', 'Id': '18431'},28536:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If we suppose that we are given two numbers $a$ and $b$ to add, what circuit depth do we require to add them?</p>\n\n<p>I'm wondering if $a$ and $b$ are $O(n)$, and thus the amount of bits required to store $a$ and $b$ are $O(\\log_2(n))$, how much time and/or space we must require to add them.  </p>\n\n<p>I'm interested in the general case.  However, I am wondering if there is anything else to be said about the case of adding $a+2a+1$.  It would be spectacular if we could do this addition in constant circuit depth.</p>\n", 'ViewCount': '33', 'Title': 'What circuit depth is required to add?', 'LastActivityDate': '2014-01-03T01:45:41.977', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19472', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1667', 'Tags': '<circuits><binary-arithmetic>', 'CreationDate': '2014-01-03T00:44:01.267', 'Id': '19468'},28537:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m studying about Local Binary Pattern and I\'m having trouble understanding the following part about the number of output labels for binary patterns from <em>Computer Vision using Local Binary Patterns</em>, by Pietik\xe4inen et al. (2011):</p>\n\n<blockquote>\n  <p>Another extension to the original operator uses so called <em>uniform patterns</em>&nbsp;[53]. For this, a uniformity measure of a pattern is used: $U$ ("pattern") is the number of bitwise transitions from 0 to&nbsp;1 or vice versa when the bit pattern is considered circular. A local binary pattern is called uniform if its uniformity measure is at most&nbsp;2. For example, the patterns 00000000 (0&nbsp;transitions), 01110000 (2&nbsp;transitions) and 11001111 (2&nbsp;transitions) are uniform whereas the patterns 11001001 (4&nbsp;transitions) and 01010011 (6&nbsp;transitions) are not. In uniform LBP mapping there is a separate output label for each uniform pattern and all the non-uniform patterns are assigned to a single label. Thus, the number of different output labels for mapping for patterns of $P$&nbsp;bits is $P(P-1)+3$. For instance, the uniform mapping produces 59 output labels for neighborhoods of 8 sampling points and 243 labels for neighborhoods of 16 sampling points.</p>\n</blockquote>\n\n<p>I don\'t understand why the number of different LBP output labels is $P(P-1) + 3$. Could someone explain why?....</p>\n\n<p>Thnx for any help =) </p>\n\n<p>Update: I think I have some idea already :) I included an example from my book:</p>\n\n<p><img src="http://i.stack.imgur.com/AMLGu.png" alt="LBP example"></p>\n', 'ViewCount': '54', 'Title': 'Number of different output labels in Local Binary Pattern', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-01-20T12:40:12.363', 'LastEditDate': '2014-01-20T12:16:14.070', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19849', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12977', 'Tags': '<image-processing><binary-arithmetic>', 'CreationDate': '2014-01-20T07:10:14.723', 'Id': '19844'},28538:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been wondering lately how GPUs compute sines and cosines, and Google hasn't helped me finding a precise answer.</p>\n\n<p>Initially, I was thinking that in order to make the computations as fast as possible, the GPU would use some kind of lookup table. But then I realized, storing all sin values in a table of the range of doubles between [0, 2 * pi] would be a massive one, and thus not be a valid option.</p>\n\n<p>The table could possible be shrunk down in resolution, and the missing values for a lookup can then be lerped. This however, introduces a possible error which can propagate to bigger and unacceptable errors when performing the computation multiple times.</p>\n\n<p>My last idea is then that they could be using a Taylor approximation, but that would involve quite some arithmetic, which may be too slow for a GPU. So the question is, what do GPUs use to calculate the sines? Are it lookup tables, approximations, or a hybrid of both? And possible, do they use the same method for other computations like sqrt()?</p>\n", 'ViewCount': '111', 'Title': 'How do GPUs compute sines?', 'LastActivityDate': '2014-02-02T19:37:31.007', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '20227', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '13308', 'Tags': '<approximation><arithmetic>', 'CreationDate': '2014-02-01T15:48:44.533', 'Id': '20189'},28539:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the Hexadecimal value 98C2417D. I've converted this into non-signed decimal by multiplying each value with it's corresponding power and added them together. This gave me 2562867581. I'm having trouble obtaining the signed value for this number. I converted the number to binary and took the 2's compliment, but this didn't give me the correct answer. </p>\n", 'ViewCount': '37', 'Title': 'Converting from Hex to Signed number', 'LastActivityDate': '2014-04-05T14:47:18.853', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13366', 'Tags': '<binary-arithmetic>', 'CreationDate': '2014-02-03T20:39:48.020', 'Id': '20262'},28540:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><strong>EDIT</strong></p>\n\n<p>As requested, a single question </p>\n\n<p><strong>Why can\'t arbitrary base conversion be done as fast as converting from base $b$ to base $b^k$ ?</strong> </p>\n\n<p>There is a big time complexity difference, so I am also interested in <em>further reading material about it</em>.</p>\n\n<hr>\n\n<p><strong>Old. Original question</strong></p>\n\n<p>Conversion between power-2-radix can be done faster than between non-power-of-2 radix, they can be even done in parallel, as every digit (or some groups of them) can be decoded independently of the rest.</p>\n\n<p>For example the binary number <code>00101001</code> can be converted to hexadecimal <code>0x29</code> nibble by nibble (<code>0010</code> and <code>1001</code>), and vice versa (i.e. every hex-digit can be parsed to 4 bits independently of the rest), but doing that conversion from to decimal (or any other non-power-of-2 radix) it\'s not so easy because digits affects each other.</p>\n\n<p>I\'ve seen time complexity of math operations in <a href="http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#Arithmetic_functions" rel="nofollow">wikipedia</a>, and there is also a related question in <a href="http://stackoverflow.com/questions/17649524/time-complexity-to-convert-a-decimal-to-another-base">stackoverflow</a> saying time complexity of conversions of arbitrary digit length to be $\\mathcal{O}(M(n) log(n))$</p>\n\n<p>I\'m not interested in a "general time complexity bounds for any base conversion" but I would like to know more about the big differences in time complexity between power-of-2 conversions vs any other base conversions. </p>\n\n<p>It\'s could be a general fact about conversions that can be done faster if they are done between numbers where its bases are power among themselves, not only for 2, but the same to a base 10 to base 100.</p>\n\n<p>Is there any known proof or materials around this ?</p>\n', 'ViewCount': '185', 'Title': 'Time complexity of base conversion', 'LastEditorUserId': '1396', 'LastActivityDate': '2014-04-18T19:19:26.113', 'LastEditDate': '2014-02-21T12:31:12.923', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<complexity-theory><reference-request><time-complexity><binary-arithmetic>', 'CreationDate': '2014-02-17T13:58:42.143', 'FavoriteCount': '1', 'Id': '21736'},28541:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '267', 'Title': 'How does binary addition work?', 'LastEditDate': '2014-03-09T04:55:53.763', 'AnswerCount': '1', 'Score': '6', 'OwnerDisplayName': 'Link TheProgrammer', 'PostTypeId': '1', 'OwnerUserId': '15435', 'FavoriteCount': '3', 'Body': '<p>I find <strong>binary</strong> confusing. I have watched minecraft redstone videos on binary adders, real binary adders, diagrams, etc and yet I have not learned much at all. <em>How does electrons flowing through wires made of gold "add/subtract" to make numbers through some logic gates?!</em></p>\n', 'Tags': '<logic><binary-arithmetic>', 'LastEditorUserId': '15202', 'LastActivityDate': '2014-03-09T23:34:17.203', 'CommentCount': '6', 'AcceptedAnswerId': '22415', 'CreationDate': '2014-03-09T00:06:51.107', 'Id': '22413'},28542:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I found an intersting problem. I have to compute <code>n! modulo p</code> and can't figure out a way of doing this. For small <code>n</code>s I can actually compute the factorial, but for large ones, <code>n!</code> doesn't fit a known type.</p>\n\n<p>So, my question is.. how can I compute <code>n! modulo p</code>?</p>\n\n<p><code>p</code> might be prime, but I can't remember the problem exactly.</p>\n", 'ViewCount': '32', 'ClosedDate': '2014-03-27T14:24:28.367', 'Title': 'Computing n! modulo p', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-27T14:22:28.643', 'LastEditDate': '2014-03-27T14:22:28.643', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16193', 'Tags': '<algorithms><number-theory><arithmetic>', 'CreationDate': '2014-03-27T12:49:15.957', 'Id': '23122'},28543:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '65', 'Title': 'Quick calculation for $(x^y) \\bmod z$', 'LastEditDate': '2014-03-30T11:10:13.400', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12905', 'FavoriteCount': '2', 'Body': '<p>What are the possible ways to calculate $(x^y) \\bmod z$ quickly for very large integers?\nIntegers $x,y \\lt 10^{10000}$ and $z \\lt 10^6$.</p>\n', 'Tags': '<integers><number-theory><arithmetic>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-31T02:12:44.727', 'CommentCount': '7', 'AcceptedAnswerId': '23257', 'CreationDate': '2014-03-30T10:50:29.727', 'Id': '23252'},28544:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve read <a href="http://cs.brown.edu/~jes/book/pdfs/ModelsOfComputation_Chapter2.pdf" rel="nofollow">this</a> which describes how to do do integer arithmetic in circuits. The one thing that it does not describe is how to do these operations with a modulus. How can modular arithmetic be done in circuits? Can someone point me to a resource or describe the modular step here?</p>\n', 'ViewCount': '23', 'Title': 'Circuits for Modular Arithmetic', 'LastActivityDate': '2014-04-08T23:02:21.387', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16568', 'Tags': '<circuits><modular-arithmetic>', 'CreationDate': '2014-04-08T22:03:25.713', 'Id': '23568'},28545:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '109', 'Title': 'Proving a language (ir)regular (standard methods have failed)', 'LastEditDate': '2014-04-19T21:26:37.113', 'AnswerCount': '1', 'Score': '7', 'OwnerDisplayName': 'James', 'PostTypeId': '1', 'OwnerUserId': '16922', 'FavoriteCount': '1', 'Body': "<p>I'm currently trying to prove a language regular (for personal amusement). The language is:</p>\n\n<p><em>The language containing all numbers in ternary that have even bit-parity when encoded in binary.</em></p>\n\n<p>Now, I've currently tried a few different approaches that have not led me to any success. I've tried using the pumping lemma (couldn't find anything to pump on), Myhill-Nerode (similar) and even counted the number of strings of each length for which the statement is true (my intuition is that it checks out with a probabilistic argument).</p>\n\n<p>Are their any other approaches that might help here, or are there any intuitions that might be helpful? At this point, my best guess is that the language is not regular, but I don't seem to be able to come up with an explanation.</p>\n", 'Tags': '<formal-languages><regular-languages><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-21T10:31:58.500', 'CommentCount': '3', 'AcceptedAnswerId': '23982', 'CreationDate': '2014-04-19T13:47:36.470', 'Id': '23944'},28546:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What are the best arithmetic algorithms out there (addition, subtraction, multiplication, division, power, root)?</p>\n\n<p>I am looking for algorithms that could be easily extended to multiprecision and arbitrary precision settings.</p>\n', 'ViewCount': '26', 'Title': 'Best (Fastest) Arithmetic Algorithms', 'LastActivityDate': '2014-05-03T17:24:56.497', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17001', 'Tags': '<binary-arithmetic><arithmetic>', 'CreationDate': '2014-05-03T14:10:19.847', 'Id': '24353'}