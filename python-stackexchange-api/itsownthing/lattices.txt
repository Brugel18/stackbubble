{'Body': "<p>I am having a problem trying to solve a question on a past paper asking to design a security lattice. Here is the question:</p>\n\n<blockquote>\n  <p>The AB model (Almost Biba) is a model for expressing integrity policies rather\n      than confidentiality. It has the same setup as Bell-LaPadula, except that $L$ is now a set of\n      integrity levels which express the degree of confidence we have in the integrity of\n      subjects and objects. Subjects and data at higher integrity levels are considered\n      to be more accurate or safe. The set of subjects and objects may also be different,\n      for example, programs are naturally considered as subjects.</p>\n  \n  <p>Often, the set $L$ is actually a lattice of levels, with two operations: least\n      upper bound $l_1 \\vee l_2$ and greatest lower bound $l_1 \\wedge l_2$, where $l_1, l_2 \\in L$.</p>\n  \n  <p>i. Design an example integrity lattice for AB, by combining two degrees of\n          data integrity <strong>dirty</strong> and <strong>clean</strong> and two means by which a piece of input\n          may be received, <strong>website</strong> (external user input from a web site form) and\n          <strong>dataentry</strong> (internal user input by trusted staff).</p>\n</blockquote>\n\n<p>I have been looking for an explanation on how to build lattices but can't seem to find one on the internet or in textbooks. Can anyone point me in the right direction?</p>\n", 'ViewCount': '237', 'Title': 'Security Lattice Construction', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-17T15:40:08.717', 'LastEditDate': '2012-04-15T22:12:05.363', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '1321', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '995', 'Tags': '<security><lattices><integrity>', 'CreationDate': '2012-04-15T11:16:22.733', 'Id': '1288'}{'ViewCount': '217', 'Title': 'Is there a data-structure for semilattices similar to a tree data-structure?', 'LastEditDate': '2013-03-18T23:58:01.183', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1557', 'FavoriteCount': '1', 'Body': '<p>If we regard a tree as a partial ordered set, it becomes a special case of a join-semilattice. For a join-semilattice, we want to be able to compute the (unique) least upper bound of two elements (more or less) efficiently. In the case of a tree, a data structure which would enable this would be to store for each element in the corresponding node a pointer to the parent and a distance measure to the root. (Actually, a labeling based on topological sort usually used for "a distance measure to the root", effectively all that is needed is a compatible partial order which can be evaluated efficiently).</p>\n\n<p>Each finite join-semilattice can be represented as a set of subsets of a finite set with containment as order such that the least upper bound is given by the union of the sets. Hence, representing each element by a finite number of tags, and computing the least upper bound by the union of the corresponding tags would be one possible data structure. (By looking at the complement, one sees that defining the least upper bound as the intersection of the corresponding tags would also be possible.) A much more common data-structure is to simply use a matrix to store all results of "a &lt;= b" or even all results of "join(a,b)".</p>\n\n<p>However, using such a data-structure to represent a tree would be sort of strange. Are there more tree-like data-structures for join-semilattices, which still allow (more or less) efficient computation of the (unique) least upper bound of two elements? (Perhaps some sort of directed acyclic graph with additional information in the nodes similar to the distance measure to the root for the tree?)</p>\n', 'Tags': '<data-structures><lattices>', 'LastEditorUserId': '1557', 'LastActivityDate': '2013-03-18T23:58:01.183', 'CommentCount': '1', 'AcceptedAnswerId': '10608', 'CreationDate': '2012-10-22T22:20:31.173', 'Id': '6245'}{'ViewCount': '503', 'Title': 'What are lattices used for?', 'LastEditDate': '2013-06-06T16:39:10.167', 'AnswerCount': '6', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1590', 'FavoriteCount': '5', 'Body': '<p>Wikipedia <a href="http://en.wikipedia.org/wiki/Complete_lattice">says</a>:</p>\n\n<blockquote>\n  <p>Complete lattices appear in many applications in mathematics and computer science</p>\n</blockquote>\n\n<p>Is it just referring to the fact that the standard Boolean algebra used in computation is a complete lattice? Is there anything we gain by working at the abstract level of lattices instead of with Boolean logic specifically?</p>\n\n<p>A google search doesn\'t find much on the subject, but I\'m probably using the wrong keywords.</p>\n', 'Tags': '<lattices><order-theory>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-06-30T02:08:56.750', 'CommentCount': '1', 'AcceptedAnswerId': '12498', 'CreationDate': '2013-06-06T16:38:42.860', 'Id': '12493'}{'Body': '<blockquote>\n  <p>A ranking algorithm determines the position (or rank) of a combinatorial object among all the objects (with respect to a given order); an unranking algorithm finds the object having a specified rank. Thus, ranking and unranking can be considered as inverse operations.</p>\n</blockquote>\n\n<p>The following lattice has 9 unique max length paths from {} to {1,2,3,4,5}, which can be obtained by a depth first search.</p>\n\n<p><img src="http://i.stack.imgur.com/wGYHo.png" alt="lattice">(The graph is directed, with arrows pointing down)</p>\n\n<p>Is it possible to write a function that generates the N\'th path without enumerating paths 1..N-1.</p>\n\n<p>see: <a href="http://math.stackexchange.com/questions/510911/computing-all-simple-paths-in-a-distributive-lattice-in-parallel">http://math.stackexchange.com/questions/510911/computing-all-simple-paths-in-a-distributive-lattice-in-parallel</a> for more problem details.</p>\n', 'ViewCount': '53', 'Title': 'Unranking paths in a graph/lattice', 'LastActivityDate': '2013-10-26T02:10:56.440', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16437', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10979', 'Tags': '<graph-theory><combinatorics><lattices>', 'CreationDate': '2013-10-25T21:37:10.387', 'Id': '16433'}{'Body': u'<p>(This question is related to homework)\nI am doing a cryptography course via long distance and we have been given an assignment which is based on lattice-based cryptography. I have spent the majority of the past week sifting through papers and videos in an attempt to build my understanding of the subject, but due to the intensely technical manner in which information on the subject is presented, I have not been able to answer many questions in my mind. Due to the structure of my long distance course I have no access to professors or extensive libraries so my question is one which merely seeks to increase my understanding, please bear with me.</p>\n\n<p>Thus far I have understood that:\n- Lattices are a collection of regularly ordered points in euclidean space (its terms like this which have caused me to be searching for answers for days)</p>\n\n<ul>\n<li><p>A lattice may be defined through n vectors called a basis where n = the dimension (for now I am working in dimension 2), and any other basis can be found by applying positive or negative multiples of each vector in the basis to another vector in the basis</p></li>\n<li><p>Defining a lattice L1 as a set of points allows one to multiply the whole set by some co-efficient which will essentially transform it into a new lattice L2</p></li>\n<li><p>The determinant of the vectors of the basis essentially tells us the volume (area in 2 dimensions) of the parallelpiped which will be repeated to form the lattice, the lattice points being the vertices.</p></li>\n</ul>\n\n<p>Having said this, I am now stuck in understanding how I move all of this to cryptography. I am on a question which asks me to compute the output for 3 inputs to a function:</p>\n\n<p>\'We will see that q-ary lattices give provably collision-resistent hashing. We choose integers q; a\nand b. Our hash function (presented by Mikl\xb4os Ajtai in a breakthrough paper in 1996) is a 2-variable\nfunction: h(x, y) = ax + by mod q.\n(a) For q = 5; a = 14; b = 13; compute h(17, 8), h(21, 16) and h((17, 8) - (21, 16))\'</p>\n\n<p>Having found the answers, h(17, 8) = 14*17 + 13*8 = 342 mod 5 = 2; h(21, 16) = 14*21 + 13*16 = 502 mod 5 = 2; h((17, 8)-(21, 16)) -> (h(-4, -8) = 14*-4 + 13*-8 = 160 mod 5 = 0</p>\n\n<p>I believe this means that with the first two points the lattice has been moved by some multiple of 5 plus two, which has displaced it by two and thus formed a new lattice. While in the last case, the lattice has been moved by a multiple of its determinant and thus is the same lattice.</p>\n\n<p>However, I just cannot understand the link to hashing. In an application would the points be the cleartext and the \'answer modulo 5\' the output of the hash function? If so would\'nt there be too many collisions as we have already seen two examples of which give the answer 2? How exactly is this linked to the shortest vector problem or short integer solution if they are not the same thing? Are q-ary lattices only an attempt to store the basic pattern needed to reproduce the lattice? and if so wouldn\'t the lattice itself be the cleartext and the basic pattern (given by the basis and the determinant) the answer from the hash function??? How exactly would you <em>encrypt</em> a message using a lattice???</p>\n\n<p>I just wish I could find some text which explained this in English rather than symbols.. like this <a href="http://www.wisdom.weizmann.ac.il/~odedg/COL/cfh.pdf" rel="nofollow">http://www.wisdom.weizmann.ac.il/~odedg/COL/cfh.pdf</a> . I really hope I have not repeated any questions through my lack of understanding. Thanks in advance.</p>\n', 'ViewCount': '51', 'Title': 'Help in understanding exactly how lattices used as one way functions for hashing', 'LastEditorUserId': '14437', 'LastActivityDate': '2014-02-06T15:51:37.247', 'LastEditDate': '2014-02-06T15:51:37.247', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21377', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14437', 'Tags': '<cryptography><hash><lattices>', 'CreationDate': '2014-02-06T12:49:55.937', 'Id': '21372'}{'Body': '<p>I\'m taking a graduate course on the theory of functional programming, based on Paul Taylor\'s "Practical Foundations of  Mathematics." I understand the statement of Tarski\'s theorem about how for any $\\omega$-compelte poset $X$, and any $\\omega$-continuous function $T:X\\rightarrow X$, that $T$ has a fixed point which is the join of (The statement and proof can be found <a href="http://www.paultaylor.eu/~pt/prafm/html/s33.html" rel="nofollow">here</a>).</p>\n\n<p>What I want to know is, how is this applicable, other than being a proof that the Y-combinator exists? It just seems to me that it says "we can use recursion to build a function that is defined for all natural numbers", where we could use some other recursive type for numbers. Doesn\'t the existence of the Y-combinator show the same thing?</p>\n', 'ViewCount': '73', 'Title': "What does Tarski's Fixed-Point theorem give us that that Y-Combinator does't", 'LastActivityDate': '2014-04-04T19:32:29.183', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<lambda-calculus><recursion><type-theory><partial-order><lattices>', 'CreationDate': '2014-04-04T19:16:13.043', 'Id': '23431'}