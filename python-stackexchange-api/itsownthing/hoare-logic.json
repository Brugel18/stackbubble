{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the discussion around <a href="http://cs.stackexchange.com/q/1157/98">this question</a>, Gilles mentions correctly that any correctness proof of an algorithm that uses arrays has to prove that there are no out-of-bounds array accesses; depending on the runtime model, this would cause a runtime error or access to non-array elements.</p>\n\n<p>One common technique to perform such correctness proofs (at least in undergrad studies and probably in automated verification) is by using <a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>. I am not aware that the standard set of rules containes anything relating to arrays; they seem to be restricted to monadic variables.</p>\n\n<p>I can imagine adding axioms of the form</p>\n\n<p>$\\qquad \\displaystyle \\frac{}{\\{0 \\leq i \\lt A.\\mathrm{length} \\land {P[A[i]/E]} \\}\\ A[i] := E;\\ \\{P\\}}$</p>\n\n<p>However, it is not clear to me how you would deal with an array access on the right hand side, i.e. if it is part of a complex expression $E$ in some statement $x := E$.</p>\n\n<blockquote>\n  <p>How can arrays accesses be modelled in Hoare logic so that the absence of invalid accesses can and has to be proven for program correctness?</p>\n</blockquote>\n\n<p>Answers may assume that we disallow array elements to be used in statements other than $A[i] := E$ or as part of some $E$ in $x := E$ as this does not restrict expressiveness; we can always assign a temporary variable the desired value, i.e. write $t := A[i];\\ \\mathtt{if} ( t &gt; 0 ) \\dots$ instead of $\\mathtt{if} ( A[i] &gt; 0 )\\dots$.</p>\n', 'ViewCount': '317', 'Title': 'How to deal with arrays during Hoare-style correctness proofs', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-10T16:17:41.297', 'LastEditDate': '2012-04-10T16:17:41.297', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<proof-techniques><semantics><arrays><hoare-logic><software-verification>', 'CreationDate': '2012-04-10T08:00:09.683', 'FavoriteCount': '1', 'Id': '1200'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to understand Hoare logic presented at Wikipedia,\n<a href="http://en.wikipedia.org/wiki/Hoare_logic" rel="nofollow">Hoare logic at Wikipedia</a>\nApparently, if I  understand correctly, a Hoare triple $$\\{P\\}~ C ~\\{Q\\}$$ means</p>\n\n<blockquote>\n  <p>if P just before C, then Q holds immediately after C, as long as C terminates. (A)</p>\n</blockquote>\n\n<p>However, the assignment axiom schema seems to be interpreted in a different way:</p>\n\n<p>$$\\frac{}{\\{P[x/E]\\} ~~x:=E~~   \\{P\\}}$$</p>\n\n<p>The wikipedia says:</p>\n\n<p>The assignment axiom means that the truth of $\\{P[x/E]\\}$ is equivalent to the after-assignment truth of $\\{P\\}$. Thus were $\\{P[x/E]\\}$ true prior to the assignment, by the assignment axiom, then $\\{P\\}$ would be true subsequent to which. Conversely, were $\\{P[x/E]\\}$ false prior to the assignment statement, $\\{P\\}$ must then be false consequently.</p>\n\n<p>I think the Hoare triple only affirms that if P[x/E] before x:=E, then P(x) holds after x:=E. It DOES NOT affirm, by its definition, that if P(x) holds after x:=E, then P[x/E] holds before x:=E. </p>\n\n<p>My naive question is, how can $\\{P[x/E]\\}$ before the assignment can be equivalent to $\\{P\\}$ after the assignment? Does this contradict with point (A) at the beginning of my post?</p>\n', 'ViewCount': '245', 'Title': 'Hoare triple for assignment P{x/E} x:=E {P}', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-16T21:09:01.143', 'LastEditDate': '2012-05-16T21:09:01.143', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '1867', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '694', 'Tags': '<logic><programming-languages><semantics><hoare-logic><program-verification>', 'CreationDate': '2012-05-16T09:09:24.887', 'Id': '1864'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following specification technique.</p>\n\n<p>A specification consists of a finite set of triples $\\langle C, A, C\' \\rangle$,\nwhere $A$ is the name of an action and $C, C\'$ are conditions, that is,\npropositional formulas over propositional variables.</p>\n\n<p>Example rules (in a more suggestive notation):</p>\n\n<ul>\n<li>$C_1 \\wedge \\neg(C_2 \\vee C_3) \\stackrel{A_1}{\\longrightarrow} C_1 \\wedge \\neg C_2$</li>\n<li>$C_1 \\vee C_3 \\stackrel{A_2}{\\longrightarrow} C_2 \\vee C_3$</li>\n</ul>\n\n<p>Each triple specifies an event together with its preconditions and postconditions:\nthe semantics can be defined by saying that the system being described has a state space consisting of the set of possible truth value assignments to the propositional variables, and that the actions may take the system from any state in which the precondition of a rule for that action holds to any state in which the postcondition of that same rule holds.</p>\n\n<p>This formalism, or a restriction (e.g. no negation in formulas, or only Horn clauses) will only suit my purposes if software exists that can answer questions such as</p>\n\n<ul>\n<li>Given a condition, which events may happen?</li>\n<li>Given a condition, may it lead to deadlock (a condition in which no event can happen)?</li>\n<li>Given a condition, will it <em>never</em> lead to deadlock?</li>\n<li>Do deadlock conditions exist at all?</li>\n<li>Given a condition, which events can never happen?</li>\n</ul>\n\n<p>in under a second.</p>\n\n<p>My question: what to Google for?</p>\n\n<p>Does this formalism have a name?\nCan it be converted to one for which equivalent problems have been studied?\nI\'m thinking of safe Petri nets, for which I\'ve found <a href="http://www.imsc.res.in/~kamal/old/pc1safe.pdf" rel="nofollow">some</a> <a href="http://people.cs.aau.dk/~srba/courses/MCS-07/safePN-atva04.pdf" rel="nofollow">papers</a>, Hoare logic, dynamic logic, no doubt there is more.</p>\n\n<p>Does such software exist?  How do I Google for it?</p>\n', 'ViewCount': '60', 'Title': 'Spot the formalism (some kind of process logic)', 'LastEditorUserId': '917', 'LastActivityDate': '2012-10-19T17:53:22.403', 'LastEditDate': '2012-10-19T17:53:22.403', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '917', 'Tags': '<logic><model-checking><linear-temporal-logic><hoare-logic>', 'CreationDate': '2012-10-19T17:47:54.750', 'Id': '6174'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose you have some loop and and integer k:</p>\n\n<pre><code>int k = 5;\nfor (int i = 0 ; i &lt; N; i++)\n{\n  //(*)\n  //do something \n}\n</code></pre>\n\n<p>The loop invariant at (*) is:\n$\\{ K=k\\}$</p>\n\n<p>Does that guarantee that $k$ doesn't change in between iterations? if not, is there any otherway to guarantee that?</p>\n", 'ViewCount': '35', 'Title': 'Does this loop invariant guarantee that the variable never changes?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T23:04:59.827', 'LastEditDate': '2013-04-12T23:04:59.827', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11270', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<loop-invariants><program-correctness><hoare-logic>', 'CreationDate': '2013-04-12T16:12:13.507', 'Id': '11269'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In Don Knuth\'s famous series of books, <em>The Art of Computer Programming</em>, section 2.3.1, he describes an algorithm to traverse binary tree in inorder, making use of an auxiliary stack:</p>\n\n<blockquote>\n  <p><strong>T1</strong> [Initialize.] Set stack $\\rm A$ empty and set the link variable $\\rm P\\gets T$</p>\n  \n  <p><strong>T2</strong> [$\\rm P=\\Lambda$?] If $\\rm P=\\Lambda$, go to step T4.</p>\n  \n  <p><strong>T3</strong> [Stack$\\rm \\;\\Leftarrow P$] (Now $\\rm P$ points to a nonempty binary tree that is to be traversed.) push the value of $\\rm P$ onto stack $\\rm A$, then set $\\rm P\\gets LLINK(P)$</p>\n  \n  <p><strong>T4</strong> [$\\rm P\\Leftarrow Stack$] If stack $\\rm A$ is empty, the algorithm terminates; otherwise pop the top of $\\rm A$ to $\\rm P$.</p>\n  \n  <p><strong>T5</strong> [Visit $\\rm P$] Visit $\\rm NODE(P)$. Then set $\\rm P\\gets RLINK(P)$ and return to step T2.</p>\n</blockquote>\n\n<p>We can plot a flow chart of the algorithm. In the succeeding paragraph, he gives a <em>formal proof</em> of the algorithm:</p>\n\n<blockquote>\n  <p>Starting at step T2 with $\\rm P$ a pointer to a binary tree of $n$ nodes and with the stack $\\rm A$ containing $\\rm A[1]\\dotsc A[m]$ for some $m\\ge 0$, the procedure of steps T2-T5 will traverse the binary tree in question, in inorder, and will then arrive at step T4 with stack $\\rm A$ returned to its original value $\\rm A[1]\\dotsc A[m]$.</p>\n</blockquote>\n\n<p>However, as far as I know, such a formal proof is quite different from the general method described in section 1.2.1:</p>\n\n<blockquote>\n  <p>for each box in the flow chart, that if an assertion attached to any arrow leading into the box is true before the operation in that box is performed, then all of the assertions on relevant arrows leading away from the box are true after the operation.</p>\n</blockquote>\n\n<p>In fact, such a method is somewhat equivalent to <a href="http://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>, which is used to formally check the validity of algorithms.</p>\n\n<p>Can we turn the statement mentioned to prove the traversing algorithm into a schema of Hoare logic, or the assertion-attachment of a flow chart?</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '122', 'Title': 'Question about the formal proof of the inorder traversing', 'LastActivityDate': '2013-06-11T20:17:23.337', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1715', 'Tags': '<algorithms><correctness-proof><graph-traversal><hoare-logic>', 'CreationDate': '2013-06-11T08:47:50.447', 'Id': '12610'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ll preface this by saying that this IS a homework question.</p>\n\n<p>However, when asked about how to solve it in class, (I believe) my professor was unable to complete it.</p>\n\n<p>The question is: </p>\n\n<blockquote>\n  <p>Compute the weakest precondition for each of the following \n  assignment statements and postconditions:\n  $$a = a + 2b - 1\\ \\{a &gt; 1\\}$$ (where a > 1 is the postcondition)</p>\n</blockquote>\n\n<p>His answer was: "$a &gt; 2 - 2b$."\nIs this correct? It seems that he broke the rules of equivalents, by using the ">" as "="</p>\n\n<p>I believe the answer is:\n$$\\{a&gt;1\\;\\wedge\\; b&lt;\\tfrac12\\}\\quad\\text{or}\\quad \\{a &gt; 0\\;\\wedge\\;2b-1 +a &gt;1\\},$$ \n    where the "$\\wedge$" symbol means "and"</p>\n\n<p>We\'re using <em>Concepts of Programming Languages</em>, by Sebesta, 10th Edition, so any references from that material would be excellent :)</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '35', 'Title': 'Axiomatic Semantics and Postconditions', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-07T00:42:18.400', 'LastEditDate': '2014-02-06T23:02:29.157', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21411', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14445', 'Tags': '<semantics><hoare-logic>', 'CreationDate': '2014-02-06T22:17:44.433', 'Id': '21407'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Without using any Haore logic, given the following Hoare triple: <code>(|x \u2265 1|) C (|y \u2265 1|)</code> is partially correct and using the definition of partial correctness. </p>\n\n<p>How to determine if <code>(|x &gt; 1|) C (|y \u2265 1|)</code> is partially correct or not?</p>\n\n<p>C is a piece of code</p>\n', 'ViewCount': '8', 'ClosedDate': '2014-04-29T08:37:05.757', 'Title': u'How to determine if (|x > 1|) C (|y \u2265 1|) is partially correct ? - Partial correctness', 'LastActivityDate': '2014-04-29T02:04:46.897', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17160', 'Tags': '<program-correctness><hoare-logic><reasoning>', 'CreationDate': '2014-04-29T02:04:46.897', 'Id': '24206'}