133_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '243', 'Title': 'Polymorphism and Inductive datatypes', 'LastEditDate': '2012-03-30T02:36:02.300', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '68', 'FavoriteCount': '1', 'Body': u'<p>I\'m curious. I\'ve been working on this datatype in <em>OCaml</em>:</p>\n\n<pre><code>type \'a exptree =\n  | Epsilon\n  | Delta of \'a exptree * \'a exptree\n  | Omicron of \'a\n  | Iota of \'a exptree exptree\n</code></pre>\n\n<p>Which can be manipulated using explicitly typed recursive functions (a feature that has been added quite recently). Example:</p>\n\n<pre><code>let rec map : \'a \'b. (\'a -&gt; \'b) -&gt; \'a exptree -&gt; \'b exptree =\n  fun f -&gt;\n    begin function\n    | Epsilon -&gt; Epsilon\n    | Delta (t1, t2) -&gt; Delta (map f t1, map f t2)\n    | Omicron t -&gt; Omicron (f t)\n    | Iota tt -&gt; Iota (map (map f) tt)\n    end\n</code></pre>\n\n<p>But I\'ve never been able to define it in <em>Coq</em>:</p>\n\n<pre><code>Inductive exptree a :=\n  | epsilon : exptree a\n  | delta : exptree a -&gt; exptree a -&gt; exptree a\n  | omicron : a -&gt; exptree a\n  | iota : exptree (exptree a) -&gt; exptree a\n.\n</code></pre>\n\n<p><em>Coq</em> is whining. It doesn\'t like the last constructor, and says something I don\'t completely understand or agree with:</p>\n\n<pre><code>Error: Non strictly positive occurrence of "exptree" in "exptree (exptree a) -&gt; exptree a".\n</code></pre>\n\n<p>What I can understand is that inductive types using a negation inside their definition like <code>type \'a term = Constructor (\'a term -&gt; \u2026)</code> are rejected, because they would lead to ugly non well-founded beasts like (untyped) \u03bb-terms.\nHowever this particular <code>exptree</code> datatype seems genuine enough: looking at its <em>OCaml</em> definition, it\'s argument <code>\'a</code> is never used in negative positions.</p>\n\n<p>It seems that <em>Coq</em> is overcautious here.\nSo is there really a problem with this particular inductive datatype?\nOr could <em>Coq</em> be slightly more permissive here?</p>\n\n<p>Also, what about other proof assistants, are they able to cope with such an inductive definition (in a natural way)?</p>\n', 'Tags': '<logic><programming-languages><coq><inductive-datatypes>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-30T02:36:02.300', 'CommentCount': '0', 'AcceptedAnswerId': '885', 'CreationDate': '2012-03-28T11:47:06.847', 'Id': '851'},133_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am working on an expression based language of ML genealogy, so it naturally needs type inference >:)</p>\n\n<p>Now, I am trying to extend a constraint-based solution to the problem of inferring types, based on a simple implementation in EOPL (Friedman and Wand), but they elegantly side-step algebraic datatypes.</p>\n\n<p>What I have so far works smoothly; if an expression <code>e</code> is <code>a + b</code>, <code>e : Int</code>, <code>a : Int</code> and <code>b : Int</code>. If <code>e</code> is a match,</p>\n\n<pre><code>match n with\n  | 0 -&gt; 1\n  | n' -&gt; n' * fac(n - 1)`, \n</code></pre>\n\n<p>I can rightly infer that the <code>t(e) = t(the whole match expression)</code>, <code>t(n) = t(0) = t(n')</code>, <code>t(match) = t(1) = t(n' * fac(n - 1)</code> and so on...</p>\n\n<p>But I am very unsure when it comes to algebraic datatypes. Suppose a function like filter:</p>\n\n<pre><code>let filter pred list =\n  match list with\n    | Empty -&gt; Empty\n    | Cons(e, ls') when pred e -&gt; Cons (e, filter ls')\n    | Cons(_, ls') -&gt; filter \n</code></pre>\n\n<p>For the list type to remain polymorphic, Cons needs to be of type <code>a * a list -&gt; a list</code>. So, in establishing these constraints, I obviously need to look up these types of my algebraic constructors - the problem I now have is the 'context-sensitivity' of multiple uses of algebraic constructors - how do I express in my constraint equations that the <code>a</code> in each case needs to be the same?</p>\n\n<p>I am having trouble finding a general solution to this, and I am unable to find much literature on this. Whenever I find something similar - expression based language with constraint-based type inference - they stop just short of algebraic datatypes and polymorphism.</p>\n\n<p>Any input is much appreciated!</p>\n", 'ViewCount': '214', 'Title': 'Constraint-based Type Inference with Algebraic Data', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-20T10:07:16.937', 'LastEditDate': '2012-04-06T23:30:01.300', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '979', 'Tags': '<programming-languages><type-theory><functional-programming><inductive-datatypes><typing>', 'CreationDate': '2012-04-06T23:09:22.253', 'Id': '1092'},133_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I think of type as a range of values that the variable can take whereas the rest is known constant or does not matter. Variables (instances or objects), which share common properties, are considered to belong to the same type/kind/class. That is, the type properties are constant across the type. The type is actually a common property of a class of objects (variables). The variables have a variable part, which may change, making them flipping from one subtype to the other. However, the same applies to subtypes: subtypes also share a common constant property.</p>\n\n<p>I may describe a class by a circle in Vienn Diagramm. Its subspheres would be types or variables. I think that the variable means that it has some fixed part, its type, and variable part, which make it variable and not constant. The constants or values would be an elementary point in the diagramm. </p>\n\n<p>For instance, integer is a subtype of real. Integer variable means that it can take concrete values within the range of the integer area. Similarly, boolean variables, taking only values 0 and 1, are subtype of integer. But, what is a constant 1? Is it a real or integer or boolean variable or it is a specific type, instances of which have a common property: they have a value of 1? Is it a known treatment?</p>\n\n<p>My interest stems from the practice: how can I save memory fixing the common part of variables in a language processing framework?</p>\n', 'ViewCount': '86', 'Title': 'Is constant a variable or subtype?', 'LastActivityDate': '2013-05-31T10:52:28.827', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<type-theory><type-inference><inductive-datatypes>', 'CreationDate': '2013-05-30T10:01:44.873', 'Id': '12372'},133_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When should I call a definition recursive and when should I call it inductive?</p>\n\n<p>I have read Carl Mummert\'s <a href="http://math.stackexchange.com/a/228870/468">nice answer</a> on MSE. So if I understand correctly we refer to definitions of objects like natural numbers, lists, trees, etc. as inductive whereas we refer to definitions of operations over objects like $+$ or $head$ or $leftchild$ as recursive.</p>\n\n<p>Is this the correct way to distinguish these in programming languages theory?</p>\n\n<p>Are there examples where using either would make sense?</p>\n', 'ViewCount': '187', 'Title': 'Inductive vs. recursive definition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-17T13:01:02.477', 'LastEditDate': '2013-07-12T10:59:05.280', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<terminology><programming-languages><logic><recursion><inductive-datatypes>', 'CreationDate': '2013-07-11T09:02:21.290', 'FavoriteCount': '1', 'Id': '13225'},133_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>the standard List type in Coq can be expressed as:</p>\n\n<pre><code>Inductive List (A:Set) : Set :=\n  nil : List A\n| cons : A -&gt; List A -&gt; List A.\n</code></pre>\n\n<p>as I understand, W-type express a well-founded tree of elements of this type. so, what if <code>nil</code> is not qualified by <code>A</code>? i.e. we have:</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil : List A</code> </p>\n</blockquote>\n\n<p>instead of</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil A: List A</code></p>\n</blockquote>\n\n<p>is this a correct W-type? can I express this in Coq?</p>\n', 'ViewCount': '38', 'Title': 'Is this a well founded inductive type? Can I express this in Coq?', 'LastActivityDate': '2014-02-16T08:07:20.807', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21693', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9922', 'Tags': '<type-theory><dependent-types><coq><inductive-datatypes>', 'CreationDate': '2014-02-14T17:40:00.397', 'Id': '21639'}