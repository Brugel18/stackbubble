266_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We learned about the concept of enumerations of functions. In practice, they correspond to programming languages.</p>\n\n<p>In a passing remark, the professor mentioned that the class of all total functions (i.e. the functions that always terminate for every input) is <em>not</em> enumerable. That would mean that we can not devise a programming language that allows us to write all total functions but no others---which would be nice to have!</p>\n\n<p>So how is it that we (apparently) have to accept the potential for non-termination if we want decent computational power?</p>\n', 'ViewCount': '631', 'Title': 'Why are the total functions not enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T09:26:07.503', 'LastEditDate': '2013-09-09T09:26:07.503', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '274', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<computability><enumeration>', 'CreationDate': '2012-03-13T00:02:58.013', 'Id': '266'},266_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '266', 'Title': 'Time complexity of an enumeration of SUBSET SUM instances', 'LastEditDate': '2012-10-04T17:08:49.840', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>An instance of the <strong><a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">SUBSET SUM</a></strong> problem (given $y$ and $A = \\{x_1,...,x_n\\}$ is there a non-empty subset of $A$ whose sum is $y$) can be represented on a one-tape Turing Machine with a list of comma separated numbers in binary format.\nIf $\\Sigma = \\{0,1,\\#\\}$ a reasonable format could be:</p>\n\n<p>$( 1 \\; (0|1)^* \\; \\#)^* \\#$</p>\n\n<p>Where the first required argument is the value $y$ and $\\#\\#$ encodes the end of the input. For example:</p>\n\n<pre><code> 1  0  0  #  1  0  #  1  #  #\n^^^^^^^^     ^^^^     ^\n   y          x1     x2\nInstance: y=4, A={2,1}\n</code></pre>\n\n<p>I would like to enumerate the SUBSET SUM instances.</p>\n\n<blockquote>\n<b>Question</b>: What is the (best) time complexity that can be achieved by a Turing Machine $TM_{Enum}$ that on input $m$ (which can be represented on the tape with a string of size $\\log m + 1$) - outputs the $m$-th SUBSET SUM instance in the above format?\n</blockquote>\n\n<p><strong>EDIT</strong>:</p>\n\n<p>Yuval\'s answer is fine, this is only a longer explanation.</p>\n\n<p>Without loss of  generality we set that $y &gt; 0$ and $0 &lt; x_1 \\leq x_2 \\leq ...  \\leq x_n$, $n \\geq 0$</p>\n\n<p>And we can represent an instance of subset sum using this encoding:</p>\n\n<p>$y \\# x_1\\# d_2\\# ...\\# d_{n} \\#\\#$ where $d_i \\geq 1, x_i = x_{i-1} + d_i - 1 \\; , i \\geq 2$</p>\n\n<p>Using a binary representation for $y,x_1, d_2, d_3, ...$ we have the following representation:</p>\n\n<p>$1 \\; ((0|1)^* \\# 1)^* \\; \\#\\#$</p>\n\n<p>Equivalent to $1 \\; (0|1|\\#1)^* \\; \\#\\#$. There is always a leading 1 and a trailing ## so we can consider only the $(0|1|\\#1)^*$ part.</p>\n\n<p>So the decoder TM on input $m$ in binary format should:</p>\n\n<ul>\n<li>output the leading 1</li>\n<li>convert $m$ to base 3 mapping digit 2 to $\\#1$</li>\n<li>when outputing the i-th intermediate $\\#$ calculate $x_i = d_i + x_{i-1}-1$</li>\n<li>output the trailing $\\#\\#$</li>\n</ul>\n\n<p>No duplicate instances are generated.</p>\n', 'Tags': '<algorithms><formal-languages><turing-machines><enumeration>', 'LastEditorUserId': '140', 'LastActivityDate': '2012-10-04T17:08:49.840', 'CommentCount': '7', 'AcceptedAnswerId': '4870', 'CreationDate': '2012-09-29T14:53:22.363', 'Id': '4794'},266_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we are given $n$ variables $X_i, i=1,\\dots,n$, each taking values from $\\{0,1\\}$, and a constant integer $k$ with $ 0\\leq k \\leq n$.</p>\n\n<p>What are some efficient ways to enumerate all possible combinations of values of $X_i$'s subject to the constraint $\\sum_{i=1}^n X_i = k$?</p>\n\n<p>A naive way is to first enumerate one by one all possible combinations of values of $X_i$'s without the constraint  $\\sum_{i=1}^n X_i = k$, and for each combination, check if it satisfies  $\\sum_{i=1}^n X_i = k$ (if it does, keep it; if it doesn't, discard it).  </p>\n\n<p>That naive way may be inefficient.\nFor example, when $k=1$, a more efficient way will be for each $i$, letting $X_i=1$ and $X_j =0, \\forall j \\neq i$.</p>\n\n<p>So I wonder for general $k$, what are some efficient ways to do the above task? </p>\n", 'ViewCount': '190', 'Title': 'How to enumerate all combinations of $n$ binary variables s.t. their sum is $k$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T11:49:26.130', 'LastEditDate': '2013-03-28T10:42:56.347', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '336', 'Tags': '<algorithms><combinatorics><enumeration>', 'CreationDate': '2013-03-28T08:21:59.237', 'Id': '10861'},266_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am given a list of $n&gt;1$ arrays, where each array has fairly small number of elements (rarely above $5$). Also $n$ is quite small in practice (around $6$).</p>\n\n<p>My problem is that I would like to efficiently map each element product to unique integer. Also, I would like to efficiently compute the integer, when I change the order of the arrays in the list.</p>\n\n<p>I was thinking something in the line of integer factorization.</p>\n\n<p>Take first $n$ primes ($p_1, p_2, ..., p_n$) and remeber the index of the array in the original list with $ind: A \\rightarrow \\mathbb{N}$. So the initial function would be $ind(A_i)=i$.</p>\n\n<p>Also we denote with $a_{i,j}$ the $j$-th element of the $i$-th array in the list. So the function $F:A_1 \\times A_2 \\times \\ldots \\times A_n \\rightarrow \\mathbb{N}$ would be:</p>\n\n<p>$$F(a_{1,i_1}, a_{2,i_2}, \\ldots, a_{n,i_n})=\\prod_{j=1}^{j=n}p_{ind(A_i)}^{i_j}$$</p>\n\n<p>In more common words, we initially assign a prime number $p_i$ to array $i$ and raise $p_i$ to the index of the element in array $i$. </p>\n\n<p>This guarantees us the uniqueness and also if we change the order of the arrays in the list, we just need to change the $ind$ function. But the problem here is that these products are fairly large and will overflow soon enough (even with using doubles).</p>\n\n<p>Do you have any better idea how to enumerate these products without the large number constraint? I am implementing this in Java and I really would not like to use BigInteger implementation.</p>\n', 'ViewCount': '70', 'Title': 'Assign unique integer keys to sets', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T11:42:08.067', 'LastEditDate': '2013-04-05T10:11:00.107', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4254', 'Tags': '<enumeration><primes>', 'CreationDate': '2013-04-05T09:58:17.547', 'Id': '11046'},266_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '216', 'Title': 'Average length of s-t (simple) paths in a directed graph', 'LastEditDate': '2013-04-08T19:10:43.587', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7644', 'FavoriteCount': '3', 'Body': '<p>Given the fact that $s$-$t$ path enumeration is a #P-complete problem, could there be efficient methods that compute (or at least approximate) the average length of $s$-$t$ path without enumerating them? <strike>What if paths are allowed to revisit vertices?</strike> </p>\n\n<p>Relevant results on special graphs could also be helpful.</p>\n', 'Tags': '<algorithms><complexity-theory><graphs><approximation><enumeration>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T04:41:12.817', 'CommentCount': '5', 'AcceptedAnswerId': '11184', 'CreationDate': '2013-04-08T18:28:42.923', 'Id': '11146'},266_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$A \\times B$ is an r.e. set,  I want to show that $A$ (or $B$) is  r.e.</p>\n', 'ViewCount': '100', 'Title': 'Each of the two sets is recursively enumerable given their cartesian product is', 'LastActivityDate': '2013-05-12T17:47:25.320', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<computability><enumeration>', 'CreationDate': '2013-05-12T09:47:43.230', 'Id': '11961'},266_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $B = \\{z \\mid (\\exists x)\\; P(x,z)\\}$ and $P$ be a computable predicate. Show $B$ is a recursive enumerable set.</p>\n\n<p><strong>My attempt</strong></p>\n\n<p>As $P$ is a computable predicate then there is a program that computes it, therefore $B= \\{z \\mid (\\exists x)(\\exists t)\\;\\text{STP}^{(1)}(x,z,t)\\} \\Rightarrow B= \\{z \\mid \\Phi(x)\\downarrow\\} = W_z$ and so $B$ is a recursive enumerable set.</p>\n\n<p><strong>Further info</strong></p>\n\n<p>$\\text{STP}^{(n)} (x_1, \\ldots, x_n, y,t)$ is a predicate that is true if the program number $y$ halts after $t$ or fewer steps on inputs $x_1, \\ldots, x_n$.</p>\n\n<p><em>Note: please note this is the first time I ever try to solve this kind of exercises, so even if I got everything wrong and nothing makes sense, every nudge in the right direction is really welcome.</em></p>\n', 'ViewCount': '71', 'Title': 'Show $B= \\{z \\mid (\\exists x)\\; P(x,z)\\}$ is a recursive enumerable set', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-05T14:07:40.023', 'LastEditDate': '2013-09-05T14:07:40.023', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><check-my-proof><enumeration>', 'CreationDate': '2013-09-04T14:21:03.683', 'Id': '14129'},266_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $S$ be a set of $n$ integers. Consider the following <em>weighted permutations problem</em>.</p>\n\n<blockquote>\n  <p>Let $m&lt;n$ be an integer. What is an efficient algorithm to enumerate all subsets of $m$ integers of $S$ such that they are listed in order of the sum of the integers in each subset?</p>\n</blockquote>\n\n<p>Each subset is a permutation, and each permutation has a total weight that is the sum of the integers in the permutation.</p>\n\n<p>The idea is to come up with an algorithm that is not the trivial algorithm of enumerating all subsets, and then sorting them, i.e. more of a "streaming" type algorithm. That is, efficiency in terms not so much of time but of "small" space.</p>\n\n<p>Maybe this is published somewhere in the literature although I have not seen it.</p>\n', 'ViewCount': '89', 'Title': 'Enumerating weighted permutations in sorted order problem', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-18T21:03:07.127', 'LastEditDate': '2013-11-18T21:03:07.127', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '699', 'Tags': '<algorithms><reference-request><sorting><efficiency><enumeration>', 'CreationDate': '2013-11-05T17:32:02.033', 'FavoriteCount': '1', 'Id': '16744'},266_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We know that deterministic TMs are countable (enumeration). Does the same hold for NTMs? Are TMs and NTMS equinumerous?</p>\n', 'ViewCount': '81', 'Title': 'Is the set of non-deterministic Turing machines countable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-19T08:15:24.767', 'LastEditDate': '2013-11-18T21:14:57.643', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18149', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11440', 'Tags': '<turing-machines><enumeration>', 'CreationDate': '2013-11-17T15:42:47.290', 'Id': '18099'},266_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was wondering how I could go about creating an algorithm that gets all the cliques in a graph in PSPACE</p>\n\n<p>So far, based on some of the readings I've done, I am considering to use bit-strings (that have a length equal to the number of vertices in the graph). Then, for every possible subset of the vertices, a turing machine writes bit-strings in order and checks if the subset is a clique. On the side there will also be a counter that counts the number of cliques </p>\n\n<p>This is where I am stuck so far. Can anyone help me improve my solution (or tell me whats wrong with it)? Thanks very much</p>\n", 'ViewCount': '48', 'ClosedDate': '2014-04-02T06:20:16.330', 'Title': 'Clique and PSPACE', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T06:20:01.417', 'LastEditDate': '2014-04-02T06:20:01.417', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16368', 'Tags': '<complexity-theory><graphs><space-complexity><enumeration>', 'CreationDate': '2014-04-02T01:55:22.447', 'Id': '23331'},266_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>The following may contain errors. It is precisely because I am not\nsure I understand the topic that I am asking questions. I do not have\nbooks about it and could not find an adequate reference on the web.</em></p>\n\n<p>I am discussing a problem regarding an enumeration of strings that\nshould be in <strong>amortized constant delay</strong>. From what I understood (but\nunderstanding that is part of my question), this means that the average\ntime taken for each answer should be independent of the size of the\nanswer, so that the total cost is $O(n)$ where $n$ is the number of\nanswers.</p>\n\n<p>My discussion partner went on to assert (I believe) that amortized\nconstant delay is possible for enumerating the strings accepted by a\ntrie, but not for enumerating the paths of a DAG. And I am at loss to\nsee a significant difference, since proper use of a stack should let\nme explore the DAG as if it had been exploded into a trie (by\nduplicating whatever is below a merge vertex).</p>\n\n<p>The only real difference I can see is that the accepting nodes of a\ntrie can be labeled with a single symbol identifier characterizing the accepted word (turning the trie\ninto a Moore machine) so that the total cost is only a traversal of\nthe trie, with single step output of the symbol label when traversing an\naccepting node.</p>\n\n<p>Such labeling identification is not possible for a DFA structured as a DAG, since an\naccepting node can correspond to different paths. The only way to name\npaths is to describe them in extenso (or nearly so: enough to disambiguate merges), so that the cost\nof the output by itself is already something like $O(n\\times s)$ where\n$s$ is the size of the longest path, thus entailing the same time cost\njust for doing the output.</p>\n\n<p>Where do I err, and what is the accepted wisdom and knowledge on this topic?\nPointers to web references are useful too.</p>\n', 'ViewCount': '31', 'Title': 'What is hiding behind amortized constant delay enumeration?', 'LastActivityDate': '2014-04-02T10:58:09.810', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<complexity-theory><graphs><strings><amortized-analysis><enumeration>', 'CreationDate': '2014-04-02T10:58:09.810', 'Id': '23337'},266_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In my textbook, enumeration machines are defined as possessing a special write-only output tape, which they can write characters to, but not move the head of. When they hit the print state, the string on the output tape is enumerated and reset to a blank tape.</p>\n\n<p>Is this equivalent to the model of enumeration machines where they have just one tape, the contents of which is enumerated (but not cleared) whenever they hit the print state? One direction seems easy, but I'm not sure how to prove you wouldn't need the extra tape.</p>\n", 'ViewCount': '17', 'Title': 'Alternate definitions of enumeration machines', 'LastActivityDate': '2014-04-21T15:02:52.847', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23991', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15627', 'Tags': '<turing-machines><enumeration>', 'CreationDate': '2014-04-20T23:37:23.767', 'Id': '23971'},266_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider a random $n$ dimensional vector $v$ where $v_i \\in \\{0,1\\}$.  For each $i$ we know $p_i = P(v_i = 1)$ and let us assume the $v_i$ are independent.  Using these probabilities, is there an efficient way to iterate over all possible binary $n$ dimensional vectors in order from most likely to least likely (with arbitrary choices for ties)?  </p>\n\n<p>Take for example $p = \\{0.8, 0.3, 0.6\\}$. The most likely vector is $(1,0,1)$ and the least likely is $\\{0,1,0\\}$.  </p>\n\n<p>For small $n$ we could label each vector with its probability and sort although this isn't very efficient. However, consider $n=100$ for example. This is no longer an option.</p>\n", 'ViewCount': '70', 'Title': 'How to iterate over vectors in order of probability', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-28T20:21:46.513', 'LastEditDate': '2014-04-26T17:58:45.207', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '17089', 'Tags': '<algorithms><enumeration>', 'CreationDate': '2014-04-26T08:23:55.233', 'FavoriteCount': '2', 'Id': '24123'},266_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The definition of the complexity class $\\mathsf{NP}$ seems to ensure (as good as possible) that it is computably enumerable. It looks as if the class could be enumerated by enumerating all Turing machines, and for each Turing machine report for each $k\\in\\mathbb{N}$ the language generated by stopping each computation after $n^k$ steps, and reject if the input hasn't been accepted before reaching this step limit.</p>\n\n<p>This only gives a computable enumeration of Turing machines. However, it seems that the corresponding languages will be decidable, because the enumeration includes an explicit time bound for each of its Turing machines. Hence this should give an computable enumeration of $\\mathsf{NP}$.</p>\n\n<blockquote>\n  <p>Question: Is the conclusion from this reasoning correct, i.e. is $\\mathsf{NP}$ computably enumerable? One issue that I have is that even for decidable languages, we can only (computably) decide whether two given languages are different, but not whether they are equal. Hence it seems that we can't avoid to report the same language more than once. The deeper issue here is that being computably enumerable is a property of subsets of the natural numbers, but the complexity class $\\mathsf{NP}$ doesn't seem to correspond to a subset of the natural numbers in any canonical way.</p>\n</blockquote>\n", 'ViewCount': '101', 'Title': 'Is the complexity class NP computably enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-03T00:18:54.527', 'LastEditDate': '2014-05-02T21:46:47.193', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1557', 'Tags': '<computability><complexity-classes><np><enumeration>', 'CreationDate': '2014-05-02T20:51:31.623', 'Id': '24326'}