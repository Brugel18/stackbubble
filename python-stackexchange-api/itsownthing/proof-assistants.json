{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Consider an inductive type which has some recursive occurrences in a nested, but strictly positive location. For example, trees with finite branching with nodes using a generic list data structure to store the children.</p>\n\n<pre><code>Inductive LTree : Set := Node : list LTree -&gt; LTree.\n</code></pre>\n\n<p>The naive way of defining a recursive function over these trees by recursing over trees and lists of trees does not work. Here\'s an example with the <code>size</code> function that computes the number of nodes.</p>\n\n<pre><code>Fixpoint size (t : LTree) : nat := match t with Node l =&gt; 1 + (size_l l) end\nwith size_l (l : list LTree) : nat := match l with\n    | nil =&gt; 0\n    | cons h r =&gt; size h + size_l r\n  end.\n</code></pre>\n\n<p>This definition is ill-formed (error message excerpted):</p>\n\n<pre><code>Error:\nRecursive definition of size_l is ill-formed.\nRecursive call to size has principal argument equal to\n"h" instead of "r".\n</code></pre>\n\n<p>Why is the definition ill-formed, even though <code>r</code> is clearly a subterm of <code>l</code>? Is there a way to define recursive functions on such a data structure?</p>\n\n<hr>\n\n<p>If you aren\'t fluent in Coq syntax: <code>LTree</code> is an inductive type corresponding to the following grammar.</p>\n\n<p>$$\\begin{align}\r\n  \\mathtt{LTree} ::= &amp; \\\\\r\n  \\vert &amp; \\mathtt{list}(\\mathtt{LTree}) \\\\\r\n\\end{align}$$</p>\n\n<p>We attempt to define the <code>size</code> function by induction over trees and lists. In OCaml, that would be:</p>\n\n<pre><code>type t = Node of t list\nlet rec size = function Node l -&gt; 1 + size_l l\nand size_l = function [] -&gt; 0\n                    | h::r -&gt; size h + size_l r\n</code></pre>\n', 'ViewCount': '481', 'Title': 'Recursive definitions over an inductive type with nested components', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-29T18:24:01.597', 'LastEditDate': '2012-03-29T18:24:01.597', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<logic><coq><type-theory><recursion><proof-assistants>', 'CreationDate': '2012-03-07T17:38:37.210', 'Id': '104'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1708', 'Title': 'Learning Automated Theorem Proving', 'LastEditDate': '2012-03-31T07:58:46.967', 'AnswerCount': '5', 'Score': '14', 'OwnerDisplayName': 'Guy Coder', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '6', 'Body': '<p><sup><em>I am learning <a href="http://en.wikipedia.org/wiki/Automated_theorem_proving">Automated Theorem Proving</a> / <a href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">SMT solvers</a> / <a href="http://en.wikipedia.org/wiki/Proof_assistant">Proof Assistants</a> by myself and post a series of questions about the process, starting here.</em></sup>  </p>\n\n<p><sup><em>Note that these topics are not easily digested without a background in (mathematical) logics. If you have problems with basic terms, please read up on those, for instance <a href="http://www.cs.bham.ac.uk/research/projects/lics/">Logics in Computer Science</a> by M. Huth and M. Ryan (in particular chapters one, two and four) or <a href="http://gtps.math.cmu.edu/tttp.html">An Introduction to Mathematical Logic and Type Theory</a> by P. Andrews.</em><br>\n<em>For a short introduction into higher order logic (HOL) see <a href="http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/AIencyclopedia/">here</a>.</em></sup></p>\n\n<p>I looked at <a href="http://coq.inria.fr/">Coq</a> and read the first chapter of the intoduction to <a href="http://www.cl.cam.ac.uk/research/hvg/isabelle/">Isabelle</a> amongst others; <a href="http://cs.stackexchange.com/q/868/268">Types of Automated Theorem Provers</a></p>\n\n<p>I have known Prolog for a few decades and am now learning F#, so ML, O\'Caml and LISP are a bonus. Haskell is a different beast.</p>\n\n<p>I have the following books</p>\n\n<p><a href="http://books.google.com/books/about/Handbook_of_automated_reasoning.html?id=X3z8ujBRgmEC">"Handbook of Automated Reasoning"</a> edited by Alan Robinson and Andrei Vornkov</p>\n\n<p><a href="http://books.google.com/books/about/Handbook_of_automated_reasoning.html?id=X3z8ujBRgmEC">"Handbook of Practical Logic and Automated Reasoning"</a> by John Harrison</p>\n\n<p><a href="http://www4.in.tum.de/~nipkow/TRaAT/">"Term Rewriting and All That"</a> by Franz Baader and Tobias Nipkow</p>\n\n<ol>\n<li><p>What are the differences between Coq and Isabelle?</p></li>\n<li><p>Should I learn either Isabelle or Coq, or both?</p></li>\n<li><p>Is there an advantage to learning either Isabelle or Coq first?</p></li>\n</ol>\n\n<p><sup><em>Find the series\' next question <a href="http://cs.stackexchange.com/questions/868/types-of-automated-theorem-provers">here</a>.</em></sup></p>\n', 'Tags': '<logic><proof-assistants><automated-theorem-proving><coq>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T15:10:57.490', 'CommentCount': '5', 'AcceptedAnswerId': '823', 'CreationDate': '2012-03-27T11:18:38.243', 'Id': '820'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '317', 'Title': 'Types of Automated Theorem Provers', 'LastEditDate': '2012-03-30T07:02:19.973', 'AnswerCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '1', 'Body': '<p><sup><em>I am learning <a href="http://en.wikipedia.org/wiki/Automated_theorem_proving" rel="nofollow">Automated Theorem Proving</a> / <a href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories" rel="nofollow">SMT solvers</a> / <a href="http://en.wikipedia.org/wiki/Proof_assistant" rel="nofollow">Proof Assistants</a> by myself and post a series of questions about the process, starting <a href="http://cs.stackexchange.com/questions/820/learning-automated-theorem-proving">here</a>.</em></sup></p>\n\n<p>Which are the relevant automated theorem provers? I found <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;frm=1&amp;source=web&amp;cd=6&amp;ved=0CGgQFjAF&amp;url=http%3A%2F%2Fwww.cs.cornell.edu%2FNuprl%2FPRLSeminar%2FPRLSeminar01_02%2FNogin%2FPRLseminar7b.pdf&amp;ei=Nkx0T-XMMqjc0QGv-Nj_Ag&amp;usg=AFQjCNGslr0mgMKpFQg1NdtEmA-BxY-eTA" rel="nofollow">A Review of Theorem Provers</a></p>\n\n<p>Is this still current?</p>\n\n<p>Which ones are still very active, i.e. which are currently used beyond the group that created it?</p>\n\n<p><sup><em>Find the series\' next question <a href="http://cs.stackexchange.com/questions/879/why-do-some-inference-engines-need-human-assistance-while-others-dont">here</a>.</em></sup></p>\n', 'Tags': '<logic><automated-theorem-proving><proof-assistants>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-30T07:02:19.973', 'CommentCount': '0', 'AcceptedAnswerId': '869', 'CreationDate': '2012-03-29T12:00:18.817', 'Id': '868'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '188', 'Title': "Why do some inference engines need human assistance while others don't?", 'LastEditDate': '2012-03-30T07:02:09.643', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '3', 'Body': '<p><sup><em>I am learning <a href="http://en.wikipedia.org/wiki/Automated_theorem_proving" rel="nofollow">Automated Theorem Proving</a> / <a href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories" rel="nofollow">SMT solvers</a> / <a href="http://en.wikipedia.org/wiki/Proof_assistant" rel="nofollow">Proof Assistants</a> by myself and post a series of questions about the process, starting <a href="http://cs.stackexchange.com/questions/820/learning-automated-theorem-proving">here</a>.</em></sup></p>\n\n<p>Why is it that automated theorem provers, i.e. <a href="http://en.wikipedia.org/wiki/ACL2" rel="nofollow">ACL2</a>, and SMT solvers do not need human assistance while proof assistants, i.e. <a href="http://en.wikipedia.org/wiki/Isabelle_%28theorem_prover%29" rel="nofollow">Isabelle</a> and <a href="http://en.wikipedia.org/wiki/Coq" rel="nofollow">Coq</a>, do?</p>\n\n<p><sup><em>Find the series\' next question <a href="http://cs.stackexchange.com/questions/882/why-is-unification-so-important-to-inference-engines">here</a>.</em></sup></p>\n', 'Tags': '<logic><proof-assistants><automated-theorem-proving><smt-solvers>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-04T13:44:42.637', 'CommentCount': '0', 'AcceptedAnswerId': '881', 'CreationDate': '2012-03-29T20:51:43.170', 'Id': '879'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '584', 'Title': 'Why is unification so important to inference engines?', 'LastEditDate': '2012-03-30T07:01:26.807', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '1', 'Body': '<p><sup><em>I am learning <a href="http://en.wikipedia.org/wiki/Automated_theorem_proving">Automated Theorem Proving</a> / <a href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories">SMT solvers</a> / <a href="http://en.wikipedia.org/wiki/Proof_assistant">Proof Assistants</a> by myself and post a series of questions about the process, starting <a href="http://cs.stackexchange.com/questions/820/learning-automated-theorem-proving">here</a>.</em></sup></p>\n\n<p>I keep reading about the <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29">Unification Algorithm</a>. </p>\n\n<ul>\n<li>What is it and why is so important to <a href="http://en.wikipedia.org/wiki/Inference_engine">Inference Engines</a>?</li>\n<li>Why is it so important to Computer Science?</li>\n</ul>\n', 'Tags': '<logic><proof-assistants><automated-theorem-proving><smt-solvers><unification>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-30T13:35:19.713', 'CommentCount': '0', 'AcceptedAnswerId': '900', 'CreationDate': '2012-03-29T23:05:40.840', 'Id': '882'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am teaching myself program verification and am currently learning <a href="http://en.wikipedia.org/wiki/Proof_assistant" rel="nofollow">proof assistants</a>. I have the book <a href="http://www.cambridge.org/gb/knowledge/isbn/item2327697/?site_locale=en_GB" rel="nofollow">Handbook of Practical Logic and Automated Reasoning</a> which gives the proofs necessary for the understanding of such a system, but more importantly for me it also gives an implementation of the necessary algorithms as <a href="http://www.cl.cam.ac.uk/~jrh13/atp/index.html" rel="nofollow">OCAML source</a>.</p>\n\n<p>I know that some of the tools listed in <a href="http://en.wikipedia.org/wiki/List_of_model_checking_tools" rel="nofollow">Wikipedia: Model Checking tools</a> and <a href="http://anna.fi.muni.cz/yahoda/" rel="nofollow">YAHODA: Verifications Tools Database</a> are open source, but I also prefer it when the theory, proofs, algorithms and source code are presented at the same time reinforcing each other, and in a progression building up to a final application.</p>\n\n<p>Is there such a book for model checking?</p>\n\n<p>EDIT </p>\n\n<p>I may have found what I am looking for in <a href="http://www.springer.com/computer/theoretical+computer+science/book/978-1-4471-4128-0" rel="nofollow">Mathematical Logic for Computer Science</a> with <a href="http://code.google.com/p/mlcs/" rel="nofollow">Prolog source</a>. As I don\'t have the book, does anyone know if this book fits the requirement?</p>\n', 'ViewCount': '76', 'Title': 'Looking for a book that derives and constructs a model checking application', 'LastEditorUserId': '268', 'LastActivityDate': '2012-07-29T02:07:34.563', 'LastEditDate': '2012-07-28T21:16:21.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2931', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<reference-request><formal-methods><proof-assistants><model-checking>', 'CreationDate': '2012-07-27T13:10:10.487', 'Id': '2923'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '311', 'Title': 'Is there a repository for the hierarchy of proofs?', 'LastEditDate': '2012-08-13T05:42:14.743', 'AnswerCount': '4', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '4', 'Body': '<p>I am self-learning <a href="http://en.wikipedia.org/wiki/Proof_assistant">proof assistants</a> and decided to start on some basic proofs and work my way up. Since proofs are based on other proofs and so form a hierarchy, is there a repository of the hierarchy of proofs?</p>\n\n<p>I know I can pick a particular proof-assistant and analyze its library to extract its hierarchy, however if I want to find the next proof in a chain to prove, I can\'t when it is not in the library.</p>\n\n<p>In my mind I picture a graph, probably a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>, of all of the known mathematical proofs that can be expressed using English statements, not <a href="http://www.billthelizard.com/2009/07/six-visual-proofs_25.html">proofs using pictures</a>. This would be the master map (a map in the sense of starting at one point and traveling to another point via intermediate points), and for a particular proof assistant, one would have a subgraph of the master map. Then if one wanted to create a proof using a proof assistant found on the master not on the subgraph, by comparing the two graphs one could get an idea of the work needed to create the missing proof(s) for the proof assistant. </p>\n\n<p>I am aware that mathematical proofs are not necessarily easily convertable for use with a proof assistant, however having a general idea of what to do is much better than none at all.</p>\n\n<p>Also by having the master map, I can see if there are mulitple paths from one point to antoher and choose a path that is more amenable for the particualr proof assistant.</p>\n\n<p>EDIT</p>\n\n<p>In searching I found something similar for <a href="http://dlmf.nist.gov/">mathematical functions</a>. I did not find one for proofs at the <a href="http://www.nist.gov/index.html">NIST</a></p>\n', 'Tags': '<reference-request><logic><proof-assistants>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-10T13:35:25.587', 'CommentCount': '4', 'AcceptedAnswerId': '3490', 'CreationDate': '2012-08-08T00:13:21.220', 'Id': '3086'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In a comment to <a href="http://stackoverflow.com/q/12662896/1243762">Learning F#: What books using other programming languages can be translated to F# to learn functional concepts?</a> <a href="http://stackoverflow.com/users/2121246/makarius">Makarius</a> stated:</p>\n\n<blockquote>\n  <p>Note that the "CPS" approach has done great harm to performance in\n  SML/NJ. Its physical evaluation model violates too many assumptions\n  that are built into the hardware. If you take big symbolic\n  applications of SML like Isabelle/HOL, SML/NJ with CPS comes out\n  approx. 100 times slower than Poly/ML with its conventional stack.</p>\n</blockquote>\n\n<p>Can someone explain the reasons for this? (Preferably with some examples) Is there an impedance mismatch here?</p>\n', 'ViewCount': '159', 'Title': 'The "CPS" approach has done great harm to performance in SML/NJ; reasoning desired', 'LastEditorUserId': '39', 'LastActivityDate': '2013-03-03T20:52:58.603', 'LastEditDate': '2013-03-03T20:52:58.603', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10235', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<compilers><functional-programming><proof-assistants><continuations>', 'CreationDate': '2013-03-03T15:49:23.960', 'Id': '10233'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>I am currently working on the following task:</p>\n\n<p>A language L = {&lt; M> | M(x) = x^2} is given. Now I need to show, that this language is not decidable.\n<br> By the way, &lt; M> is the G\xf6del number</p>\n\n<p>But right now, I don't know how to deal with that task. Honestly, this is the first time that I am working with this kind of task.</p>\n\n<p>I would appreciate if you could give me some hints, because I don't know how to proceed with the task.</p>\n", 'ViewCount': '29', 'ClosedDate': '2013-12-08T23:35:00.803', 'Title': 'Recursive set - How to show a language is undecidable', 'LastActivityDate': '2013-12-08T23:29:39.940', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11941', 'Tags': '<turing-machines><undecidability><computation-models><proof-assistants>', 'CreationDate': '2013-12-08T23:29:39.940', 'Id': '18764'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '130', 'Title': 'Theorem Proofs in Coq', 'LastEditDate': '2013-12-09T18:57:00.543', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '11942', 'FavoriteCount': '1', 'Body': "<h1>Background</h1>\n\n<p>I am learning assistance, Coq, on my own. So far, I have completed reading Yves Bertot's <em>Coq in a Hurry</em>. Now, my goal is to prove some basic results concerning the natural numbers, culminating with the so-called division algorithm. However, I have encountered some setbacks on my way towards that goal. In particular, the two following results have proved (pun intended) to be more difficult to prove in Coq than I initially imagined. In fact, I have, after many fruitless attempts, resorted to prove them by hand (as shown below). This is clearly not helping me become more proficient in handling Coq; which is why I turn to this forum. My hope is that someone on this site is able and <strong>willing</strong> to help me translate my proofs below into a proof that Coq accepts. All help is sincerely appreciated!</p>\n\n<h2>Theorem A</h2>\n\n<p>For all $x,y \\in N$ \\begin{equation} x &lt; S(y) \\subset x &lt; y \\lor \\text{I}(N,x,y) \\end{equation}\n<strong>Proof:</strong></p>\n\n<p>Suppose $x &lt; S(y)$. Hence there is a $z \\in N$ with \\begin{equation} \\text{I}(N,x+S(z),S(y)) \\tag{*}\\end{equation}\nHence by (Peano 1b and 3) \\begin{equation} \\text{I}(N,x+z,y) \\end{equation}</p>\n\n<p>Define a predicate \\begin{equation} Q(u):=(\\text{I}(N,x+u,y) \\subset x&lt;y \\lor \\text{I}(N,x,y) \\end{equation}</p>\n\n<p>It is sufficient to show $Q(z)$. We prove this by induction on $z$. To see $Q(0)$, not ethat if $\\text{I}(N,x+0,y)$ holds then $\\text{I}(N,x,y)$ is true by Peano 1a. Thus, $x&lt;y \\lor \\text{I}(n,x,y)$. Now, we prove $Q(S(v))$: Suppose $\\text{I}(N,x+S(v),y)$. From this definition we have $x&lt;y$ and thus $x&lt;y \\lor \\text{I}(N,x,y)$ also in this case. Finally, Peano's fifth axiom gives $Q(z)$ and by $(*)$ we get $x &lt; y \\lor \\text{I}(N,x,y)$. \n\\begin{equation} \\tag{$\\square$} \\end{equation}</p>\n\n<h2>Theorem B</h2>\n\n<p>For all $x,y \\in N$ \\begin{equation} x &lt;y \\lor \\text{I}(N,x,y) \\lor y&lt;x \\end{equation}\n<strong>Proof:</strong></p>\n\n<p>If $x&lt;y$ then $\\neg \\text{I}(N,x,y)$ by definition, and if $x&gt;y$ then $\\neg \\text{I}(N,x,y)$ also by definition. If $x&gt;y$ <strong>and</strong> $y&gt;x$ then by transitivity and reflexivity, we have $\\text{I}(N,x,y)$, which is a contradiction. Consequently, no more than one of the statements is true. </p>\n\n<p>We keep $y$ fixed and induct on $x$. When $\\text{I}(N,0,y)$ we have $0 &lt; y \\lor \\text{I}(N,0,y)$ for all $y$, which proves the base case. Next, suppose the theorem holds for $x$; now we want to prove the theorem for $S(x)$. From the trichotomy for $x$, there are three cases: $x&lt;y,\\text{I}(N,x,y)$, and $x&gt;y$. If $x&gt;y$, then clearly $S(x) &gt;y$. If $\\text{I}(N,x,y)$, then $S(x) &gt;y$ (as $S(x) &gt;x$ for all $x\\in \\mathbb{N}$). Finally, suppose $x &lt;y$ Then, by theorem A we have $S(x) &lt; y$ or $\\text{I}(N,S(x),y)$, and in either case we are done.\n\\begin{equation} \\tag{$\\square$} \\end{equation}</p>\n\n<p>The theorems that I wish to prove, can be expressed as follows in Coq. </p>\n\n<blockquote>\n  <p>Lemma less_lem (x y:N) : \n  less x (succ y) -> or (less x y) (I N x y).</p>\n  \n  <p>Theorem Ntrichotomy: (forall x y:N, \n  or (less x y) (or (I N x y) (less y x))).</p>\n</blockquote>\n\n<h2>Useful results</h2>\n\n<p>Here, I have gathered some of the results that I have defined, and proved up to this point. These are the ones that I refer to above. *<em>This is the code that I have managed to write so far, note that most consists of definitions. *</em></p>\n\n<pre><code>(* Sigma types *)\n\n\nInductive Sigma (A:Set)(B:A -&gt; Set) :Set :=\n  Spair: forall a:A, forall b : B a,Sigma A B.\n\nDefinition E (A:Set)(B:A -&gt; Set)\n  (C: Sigma A B -&gt; Set)\n  (c: Sigma A B)\n  (d: (forall x:A, forall y:B x, \n      C (Spair A B x y))): C c :=\n\nmatch c as c0 return (C c0) with\n| Spair a b =&gt; d a b\nend. \n\n\n(* Binary sum type *)\n\nInductive sum' (A B:Set):Set := \ninl': A -&gt; sum' A B | inr': B -&gt; sum' A B.\n\nPrint sum'_rect.\n\nDefinition D (A B : Set)(C: sum' A B -&gt; Set)\n(c: sum' A B)\n(d: (forall x:A, C (inl' A B x)))\n(e: (forall y:B, C (inr' A B y))): C c :=\n\nmatch c as c0 return C c0 with\n| inl' x =&gt; d x\n| inr' y =&gt; e y\nend.\n\n(* Three useful finite sets *)\n\nInductive N_0: Set :=.\n\nDefinition R_0\n  (C:N_0 -&gt; Set)\n  (c: N_0): C c :=\nmatch c as c0 return (C c0) with\nend.\n\nInductive N_1: Set := zero_1:N_1.\n\nDefinition R_1 \n  (C:N_1 -&gt; Set)\n  (c: N_1)\n  (d_zero: C zero_1): C c :=\nmatch c as c0 return (C c0) with\n  | zero_1 =&gt; d_zero\nend.\n\nInductive N_2: Set := zero_2:N_2 | one_2:N_2.\n\nDefinition R_2 \n  (C:N_2 -&gt; Set)\n  (c: N_2)\n  (d_zero: C zero_2)\n  (d_one: C one_2): C c :=\nmatch c as c0 return (C c0) with\n  | zero_2 =&gt; d_zero\n  | one_2  =&gt; d_one\nend.\n\n\n(* Natural numbers *)\n\nInductive N:Set :=\nzero: N | succ : N -&gt; N.\n\nPrint N. \n\nPrint N_rect.\n\nDefinition R \n  (C:N -&gt; Set)\n  (d: C zero)\n  (e: (forall x:N, C x -&gt; C (succ x))):\n  (forall n:N, C n) :=\nfix F (n: N): C n :=\n  match n as n0 return (C n0) with\n  | zero =&gt; d\n  | succ n0 =&gt; e n0 (F n0)\n  end.\n\n(* Boolean to truth-value converter *)\n\nDefinition Tr (c:N_2) : Set :=\nmatch c as c0 with\n  | zero_2 =&gt; N_0\n  | one_2 =&gt; N_1\nend.\n\n(* Identity type *)\n\nInductive I (A: Set)(x: A) : A -&gt; Set :=\nr :  I A x x.\n\nPrint I_rect.\n\nTheorem J \n  (A:Set)\n  (C: (forall x y:A, \n              forall z: I A x y, Set))\n  (d: (forall x:A, C x x (r A x)))\n  (a:A)(b:A)(c:I A a b): C a b c.\ninduction c.\napply d.\nDefined.\n\n(* functions are extensional wrt\n  identity types *)\n\nTheorem I_I_extensionality (A B: Set)(f: A -&gt; B):\n(forall x y:A, I A x y -&gt; I B (f x) (f y)).\nProof.\nintros x y P.\ninduction P.\napply r.\nDefined.\n\n\n(* addition *)\n\nDefinition add (m n:N) : N \n := R (fun z=&gt; N) m (fun x y =&gt; succ y) n.\n\n(* multiplication *)\n\nDefinition mul (m n:N) : N \n := R (fun z=&gt; N) zero (fun x y =&gt; add y m) n.\n\n\n(* Axioms of Peano verified *)\n\nTheorem P1a: (forall x: N, I N (add x zero) x).\nintro x.\n(* force use of definitional equality\n  by applying reflexivity *)\napply r.\nDefined.\n\n\nTheorem P1b: (forall x y: N, \nI N (add x (succ y)) (succ (add x y))).\nintros.\napply r.\nDefined.\n\n\nTheorem P2a: (forall x: N, I N (mul x zero) zero).\nintros.\napply r.\nDefined.\n\n\nTheorem P2b: (forall x y: N, \nI N (mul x (succ y)) (add (mul x y) x)).\nintros.\napply r.\nDefined.\n\nDefinition pd (n: N): N :=\nR (fun _=&gt; N) zero (fun x y=&gt; x) n.\n\n(* alternatively\nDefinition pd (x: N): N :=\nmatch x as x0 with\n  | zero =&gt; zero\n  | succ n0 =&gt; n0\nend.\n*)\n\nTheorem P3: (forall x y:N, \nI N (succ x) (succ y) -&gt; I N x y).\nintros x y p.\napply (I_I_extensionality N N pd (succ x) (succ y)).\napply p.\nDefined.\n\nDefinition not (A:Set): Set:= (A -&gt; N_0).\n\nDefinition isnonzero (n: N): N_2:=\nR (fun _ =&gt; N_2) zero_2 (fun x y =&gt; one_2) n.\n\n\nTheorem P4 : (forall x:N, \nnot (I N (succ x) zero)).\nintro x.\nintro p.\n\napply (J N (fun x y z =&gt; \n    Tr (isnonzero x) -&gt; Tr (isnonzero y))\n    (fun x =&gt; (fun t =&gt; t)) (succ x) zero)\n.\napply p.\nsimpl.\napply zero_1.\nDefined.\n\nTheorem P5 (P:N -&gt; Set):\nP zero -&gt; (forall x:N, P x -&gt; P (succ x))\n   -&gt; (forall x:N, P x).\nintros base step n.\napply R.\napply base.\napply step.\nDefined.\n\n(* I(A,-,-) is an equivalence relation *)\n\nLemma Ireflexive (A:Set): (forall x:A, I A x x).\nintro x.\napply r.\nDefined.\n\nLemma Isymmetric (A:Set): (forall x y:A, I A x y -&gt; I A y x).\nintros x y P.\ninduction P.\napply r.\nDefined.\n\nLemma Itransitive (A:Set): \n(forall x y z:A, I A x y -&gt; I A y z -&gt; I A x z).\nintros x y z P Q.\ninduction P.\nassumption.\nDefined.\n\n\nLemma succ_cong : (forall m n:N, I N m n -&gt; I N (succ m) (succ n)).\nintros m n H.\ninduction H.\napply r.\nDefined.\n\nLemma zeroadd: (forall n:N, I N (add zero n) n).\nintro n.\ninduction n.\nsimpl.\napply r.\napply succ_cong.\nauto.\n\nDefined.\n\nLemma succadd: (forall m n:N, I N (add (succ m) n) (succ (add m n))).\nintros.\ninduction n.\nsimpl.\napply r.\nsimpl.\napply succ_cong.\nauto.\n\nDefined.\n\nLemma commutative_add: (forall m n:N, I N (add m n) (add n m)).\nintros n m; elim n.\napply zeroadd.\nintros y H; elim (succadd m y).\nsimpl.\nrewrite succadd.\napply succ_cong.\nassumption.\n\n\nDefined.\n\nLemma associative_add: (forall m n k:N, \nI N (add (add m n) k) (add m (add n k))).\nintros m n k.\ninduction k.\nsimpl.\napply Ireflexive.\nsimpl.\napply succ_cong.\nassumption.\nDefined.\n\nDefinition or (A B : Set):= sum' A B.\n\n\nDefinition less (m n: N) :=\n Sigma N (fun z =&gt; I N (add m (succ z)) n).\n\n\n\nLemma less_lem (x y:N) : \nless x (succ y) -&gt; or (less x y) (I N x y).\nintro.\ndestruct H.\nright.\n\n(* Here is where I'm working right now *)\n\nDefined.\n\n\nTheorem Ntrichotomy: (forall x y:N, \nor (less x y) (or (I N x y) (less y x))).\n</code></pre>\n", 'Tags': '<automated-theorem-proving><proof-assistants><mathematical-programming><coq>', 'LastEditorUserId': '106', 'LastActivityDate': '2013-12-10T16:39:28.090', 'CommentCount': '6', 'AcceptedAnswerId': '18792', 'CreationDate': '2013-12-08T23:54:04.043', 'Id': '18765'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<h2>Question</h2>\n\n<blockquote>\n  <p>How do I write more intuitive proofs of the two following results in Coq? </p>\n</blockquote>\n\n<pre><code>Theorem Course_of_values_ind: \n        InductiveRel N less\n\n  Theorem DivRem: (forall d n:N, \n      (Sigma N (fun q =&gt; (Sigma N (fun s =&gt;\n         and  (I N n (add (mul (succ d) q) s)) (less s (succ d))))))).\n</code></pre>\n\n<h2>Background</h2>\n\n<p>I recognize all of these results are already built into Coq, and so it is possible to provide much easier proofs than what I am asking for. This is something I have managed to do on my own; simply using the Coq library for this particular task. Even though this is much more concise (and thus arguably more elegant), I find don\'t find it very instructive.<strong>Luke Mathieson</strong> provided a good example of this when he gave an alternative proof in Coq of trichonomy for natural numbers:</p>\n\n<pre><code>(*\n  The following is just to show what can be done with some of the tactics\n  The omega tactic implements a Pressburger arithmetic solver, so anything\n  with natural numbers, plus, multiplication by constants, and basic logic\n  can just be solved. Not very interesting for practicing Coq, but cool to\n  know.\n*)\n\nRequire Import Omega.\n\nExample trich\' : forall (n m : nat),\n  n &lt; m \\/ n = m \\/ m &lt; n.\nProof.\n  intros.\n  omega.\nQed\n</code></pre>\n\n<p>Notice that the actual proof of the theorem in Coq does not reveal how the proof would look like informally. Thus, my hope is that someone may be kind enough to give a more, shall we say "intuitive", proof of the Euclidean division algorithm in Coq. The proof I have in mind will uses structural induction, which rests on the validity of the following lemma:</p>\n\n<blockquote>\n  <p><strong>Lemma</strong>: *$(\\mathbb{N},&lt;)$ is well founded. (Course_of_values_ind)*</p>\n</blockquote>\n\n<p>As this is so critical to the proof of the Euclidean division algorithm I decided to prove it. </p>\n\n<p><strong>Proof</strong>:</p>\n\n<p>Suppose that $P(x)$ set $(x:N$) is a progressive predicate  (definition is given below the proof of the Euclidean division algorithm) on $N$. Define \\begin{equation} Q(x)=_{def}(\\forall y:N)(y&lt;x \\subset P(y)) \\tag{*}\\end{equation}</p>\n\n<p>It is enough to prove $(\\forall x:N)Q(x)$, as then for any $x:N$ we have $x&lt;S(x)$ and so $P(x)$. $Q(0)$ follows by Peano\'s forth axiom. The inductive step $(\\forall x N)(Q(x) \\subset Q(S(x)))$ follows by theorem A (see <a href="http://cs.stackexchange.com/questions/18765/theorem-proofs-in-coq">Theorem Proofs in Coq</a>) combined with Peano 1a and 1b (see Code-file). </p>\n\n<blockquote>\n  <p>For all natural numbers $n$ and $m$ if $n&gt;0$, if $m&gt;0$ then there are natural numbers $q$ and $r$ such that $n=qm+r$ and $r&lt;m$. </p>\n</blockquote>\n\n<p>One may formalize this as:</p>\n\n<blockquote>\n  <p>\\begin{equation}(\\forall n:\\mathbb{N})(\\forall k:\\mathbb{N})(\\exists q:\\mathbb{N})(\\exists r:\\mathbb{N})(n=_{\\mathbb{N}}q\\cdot S(k)+r \\land r&lt;S(k) \\end{equation}</p>\n</blockquote>\n\n<p>where $m:=S(k)$. Now, an informal proof of the so-called Eucliean theorem can be given as:</p>\n\n<p>Proof:</p>\n\n<p>Let $k$\xa0be an arbitrary natural number, define $m:=S(k)$ and then proceed by strong induction on $n$ (this is justified by lemma). Suppose $n$ is a natural number and for every $l &lt;n$ there are natural numbers $q$ and $r$  such that $l=mq+r$ and $r &lt;m$. We now have two cases:</p>\n\n<ol>\n<li>$n&lt;m$. Let $q=0$ and $r=n$, Then clearly $n=qm+r$ and $r&lt;m$.</li>\n<li>$n \\geq m$ Let $l=n-m&lt;n$ and observe that since $n \\geq m$, $l$ is a natural number. By the inductive hypothesis one may now choose $q\'$ and $r\'$ such that $l=q\'m+r\'$ and $r\'&lt;m$. But, this means we have $n-m=q\'m+r\'$, so $n=q\'m+r\'+m=m(q\'+1)+r\'$. So, if we let $q=q\'+1$ and $r=r\'$, then we have $n=qm+r$ and $r&lt;m$. </li>\n</ol>\n\n<h1>Definitions of the terms I use in my informal proofs</h1>\n\n<pre><code>      Definition Progressive \n           (A:Set)(R: A -&gt; A -&gt; Set)(P:A -&gt; Set):=\n        (forall x:A, \n         (forall y:A, R y x -&gt; P y) -&gt; P x).\n\n        Definition InductiveRel \n        (A:Set)(R: A -&gt; A -&gt; Set):=\n        (forall P:A-&gt;Set, Progressive A R P -&gt; \n        forall x:A, P x). \n\n        Theorem Course_of_values_ind: \n        InductiveRel N less\n    Definition Decidable (A B:Set)(R: A -&gt; B -&gt; Set):Set :=\n    forall x:A, forall y:B, or (R x y) (not (R x y)).\n\n\n    Definition and (A B:Set) := prod A B.\n    Definition and_el_left (A B: Set)(p: and A B) \n    := fst p.\n    Definition and_el_right (A B: Set)(p: and A B) \n    := snd p.\n(* Euclidean Division *)\n\nTheorem DivRem: (forall d n:N, \n  (Sigma N (fun q =&gt; (Sigma N (fun s =&gt;\n     and  (I N n (add (mul (succ d) q) s)) (less s (succ d))))))).\n</code></pre>\n\n<h2>Code-file</h2>\n\n<p>This code was generously provided by <strong>cody</strong> (again see <a href="http://cs.stackexchange.com/questions/18765/theorem-proofs-in-coq">Theorem Proofs in Coq</a>). It is my intent to add the results presented above to this code as soon as they are all complete. </p>\n\n<pre><code>(* Inductive Sigma (A:Set)(B:A -&gt; Set) :Set := Spair: forall a:A, forall b : B a,Sigma A B. *)\n\n(* Definition E (A:Set)(B:A -&gt; Set) (C: Sigma A B -&gt; Set) (c: Sigma A B)  *)\n(*   (d: (forall x:A, forall y:B x, C (Spair A B x y))): C c := *)\n(*   match c as c0 return (C c0) with  *)\n(*     | Spair a b =&gt; d a b  *)\n(*   end. *)\n\nPrint sigT.\n\n(* Binary sum type *)\n\n(* Inductive sum\' (A B:Set):Set := inl\': A -&gt; sum\' A B | inr\': B -&gt; sum\' A B. *)\n\n(* Print sum\'_rect. *)\n\n(* Definition D (A B : Set)(C: sum\' A B -&gt; Set) (c: sum\' A B)  *)\n(*   (d: (forall x:A, C (inl\' A B x))) (e: (forall y:B, C (inr\' A B y))): C c := *)\n(*   match c as c0 return C c0 with  *)\n(*     | inl\' x =&gt; d x  *)\n(*     | inr\' y =&gt; e y  *)\n(*   end. *)\n\nPrint sum.\n\n(* Three useful finite sets *)\n\n(* Inductive N_0: Set :=. *)\n\n(* Definition R_0 (C:N_0 -&gt; Set) (c: N_0): C c :=  *)\n(*   match c as c0 return (C c0) with end. *)\n\nPrint False.\n\n\n(* Inductive N_1: Set :=  *)\n(*   zero_1 : N_1. *)\n\n(* Definition R_1 (C:N_1 -&gt; Set) (c: N_1) (d_zero: C zero_1): C c :=  *)\n(*   match c as c0 return (C c0) with  *)\n(*     | zero_1 =&gt; d_zero  *)\n(*   end. *)\n\nPrint unit.\n\n\n(* Inductive N_2: Set :=  *)\n(*  | zero_2 : N_2  *)\n(*  | one_2 : N_2. *)\n\n(* Definition R_2 (C:N_2 -&gt; Set) (c: N_2) (d_zero: C zero_2) (d_one: C one_2): C c :=  *)\n(*   match c as c0 return (C c0) with  *)\n(*     | zero_2 =&gt; d_zero  *)\n(*     | one_2 =&gt; d_one  *)\n(*   end. *)\n\nPrint bool.\n\n(* Natural numbers *)\n\n(* Inductive N:Set :=  *)\n(* |zero: N  *)\n(* | succ : N -&gt; N. *)\n\n(* Print N. *)\n\n(* Print N_rect. *)\n\n(* Definition R (C:N -&gt; Set) (d: C zero) (e: (forall x:N, C x -&gt; C (succ x))): (forall n:N, C n) :=  *)\n(*   fix F (n: N): C n :=  *)\n(*   match n as n0 return (C n0) with  *)\n(*     | zero =&gt; d  *)\n(*     | succ n0 =&gt; e n0 (F n0)  *)\n(*   end. *)\n\nPrint nat.\n\n(* Boolean to truth-value converter *)\n\n(* Definition Tr (c:N_2) : Set :=  *)\n(*   match c as c0 with  *)\n(*     | zero_2 =&gt; N_0  *)\n(*     | one_2 =&gt; N_1  *)\n(*   end. *)\n\nDefinition Tr (b : bool) : Type := if b then unit else False.\n\n(* Identity type *)\n\n(* Inductive I {A: Type}(x: A) : A -&gt; Type :=  *)\n(*   r : I x x. *)\n\n(* Print I_rect. *)\n\n(* Hint Resolve r.  *)\n\nPrint identity.\n\nNotation "x ~ y" := (identity x y)(at level 60).\n\nNotation "#":=(identity_refl)(at level 10).\n\nDefinition J \n  (A : Type)\n  (C: (forall x y : A, forall e : x ~ y, Type)) \n  (d: (forall x:A, C x x (# x))) :\n  (forall (a : A)(b : A)(e : a ~ b),  C a b e) :=\n    fun a b e =&gt;\n      match e in _ ~ b with\n        | # =&gt; d a\n      end.\n\nCheck J.\n\n(* functions are extensional wrt identity types *)\n\nDefinition id_ext {A B: Type} {x y : A} (f: A -&gt; B): \n  (x ~ y -&gt; (f x) ~ (f y))\n  := fun p =&gt;\n    match p with\n      # =&gt; # (f x)\n    end.\n\n(* addition *)\n\n(* Definition add (m n:N) : N := R (fun z=&gt; N) m (fun x y =&gt; succ y) n. *)\n\nPrint plus.\n\n(* multiplication *)\n\n(* Definition mul (m n:N) : N := R (fun z=&gt; N) zero (fun x y =&gt; add y m) n. *)\n\nPrint mult.\n\n(* Axioms of Peano verified *)\n\nRequire Import Arith.\n\nTheorem P1a: (forall x: nat, (0 + x) ~ x).\nProof.\n  simpl; auto.\nDefined.\n\n\nTheorem P1b: forall x y: nat, ((S x) + y) ~ (S (x + y)).\nProof.\n  simpl; auto.\nDefined.\n\nTheorem P2a: (forall x: nat, (0 * x) ~ 0).\nProof.\n  simpl; auto.\nDefined.\n\nTheorem P2b: forall x y: nat, ((S x) * y) ~ (y + (x * y)).\nProof.\n  simpl; auto.\nDefined.\n\n(* Definition pd (n: N): N := R (fun _=&gt; N) zero (fun x y=&gt; x) n. *)\n\nPrint pred.\n\nTheorem P3: (forall x y: nat, (S x) ~ (S y) -&gt; x ~ y).\nProof.\n intros x y p.\n apply (id_ext pred p).\nDefined.\n\n(* Definition not (A:Set): Set:= (A -&gt; N_0). *)\n\nPrint notT.\n\nDefinition isnonzero (n: nat): bool:= if n then false else true.\n\nEval compute in isnonzero 1.\nEval compute in isnonzero 0.\n\nNotation "x !~ y":= (notT (x ~ y))(at level 60).\n\nDefinition false_if_succ (n : nat) : Type := if n then unit else False.\n\nHint Resolve tt.\n\nTheorem P4 : (forall x: nat, (S x) !~ 0).\nProof.\n  intro x.\n  intro.\n  assert (false_if_succ (S x)).\n  rewrite H.\n  simpl; auto.\n  simpl in X; auto.\nQed.\n\n\nTheorem P5 (P:nat -&gt; Type): P 0 -&gt; (forall x:nat, P x -&gt; P (S x)) -&gt; (forall x:nat, P x).\nProof.\n  intros; induction x; auto.\nDefined.\n\n(* I(A,-,-) is an equivalence relation *)\n\n(*All these are in the std library *)\n\nLemma Ireflexive (A:Set): (forall x:A, x ~ x).\nProof.\n  auto.\nDefined.\n\nLemma Isymmetric (A:Set): (forall x y:A, x ~ y -&gt; y ~ x).\nProof.\n  auto.\nDefined.\n\nLemma Itransitive (A:Set): (forall x y z:A, x ~ y -&gt; y ~ z -&gt; x ~ z).\nProof.\n  intros x y z e1 e2.\n  rewrite e1; auto.\nDefined.\n\nLemma S_cong : (forall m n:nat, m ~ n -&gt; (S m) ~ (S n)).\nProof.\n  intros m n e; rewrite e; auto.\nDefined.\n\nLemma zeroadd: (forall n:nat, (n + 0) ~ n).\nProof.\n  induction n; simpl; auto.\n  rewrite IHn; auto.\nDefined.\n\nHint Rewrite zeroadd.\n\nLemma Sadd: (forall m n:nat, (m + (S n)) ~ (S (m + n))).\nProof.\n  induction m; intro n; auto.\n  simpl; rewrite IHm; auto.\nDefined.\n\nHint Rewrite Sadd.\n\nLemma commutative_add: (forall m n:nat, (m + n) ~ (n + m)).\nProof.\n  induction m; intro n.\n  rewrite zeroadd; auto.\n  simpl; rewrite IHm.\n  rewrite Sadd; auto.\nDefined.\n\nLemma associative_add: (forall m n k:nat, ((m + n) + k) ~ (m + (n + k))).\nProof.\n  induction m; auto.\n  intros n k; simpl.\n  rewrite IHm; auto.\nDefined.\n\nPrint sum.\n\nOpen Scope type_scope.\n\n(* Definition or (A B : Set):= (A + B). *)\n\nDefinition less (m n: nat) := { z : nat &amp; S (z + m) ~ n}.\n\nNotation "m &lt; n" := (less m n)(at level 70).\n\nLemma less_lem : forall n m : nat, n &lt; (S m) -&gt; (n &lt; m) + (n ~ m).\nProof.\n  intros n m leq.\n  elim leq.\n  induction x; simpl; intro e.\n  right.\n  apply P3; auto.\n  left.\n  exists x.\n  apply P3; auto.\nDefined.\n\n\nTheorem nattrichotomy: forall n m:nat, (n &lt; m) + (n ~ m) + (m &lt; n).\nProof.\n  induction n; induction m; simpl.\n  left; right; auto.\n  left; left.\n  exists m; rewrite zeroadd; auto.\n  right; exists n; rewrite zeroadd; auto.\n  destruct IHm as [ leq | gt ].\n  destruct leq as [lt | eq].\n  left; left; destruct lt.\n  exists (S x).\n  simpl; rewrite i; auto.\n  left; left; exists 0.\n  rewrite eq; simpl; auto.\n  generalize (less_lem _ _ gt); intro less_eq.\n  destruct less_eq as [less| eq].\n  right.\n  destruct less.\n  exists x.\n  rewrite Sadd; rewrite&lt;- i; auto.\n  left;right; rewrite eq; auto.\nDefined.\n</code></pre>\n', 'ViewCount': '115', 'Title': 'Euclidean Algorithm in Coq', 'LastEditorUserId': '11942', 'LastActivityDate': '2013-12-12T20:56:15.797', 'LastEditDate': '2013-12-12T12:25:32.687', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11942', 'Tags': '<proof-techniques><automated-theorem-proving><proof-assistants><mathematical-programming><coq>', 'CreationDate': '2013-12-12T00:51:07.960', 'Id': '18908'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Has anyone ever actually written a system (software or detailed explanation on paper with simple examples) that generates computer programs?  I input $Prime(x) \\wedge x&lt;10$ and it creates a program that lists the prime numbers less than 10.  $Prime(x)$ is simply defined as \n$$1&lt;x \\wedge \\not\\exists A\\; s.t. 1&lt;A \\wedge A&lt;x \\wedge x=A\\times B,\\mbox{ with }\nA,B\\in \\mathbb{N}$$\nProfessors say they can but nobody gives actual complete examples.</p>\n', 'ViewCount': '191', 'Title': 'Has Anyone Actually Created a System that Writes Computer Programs from specification?', 'LastEditorUserId': '988', 'LastActivityDate': '2014-03-04T20:59:31.517', 'LastEditDate': '2014-03-04T20:51:13.270', 'AnswerCount': '4', 'CommentCount': '8', 'Score': '11', 'OwnerDisplayName': 'Charlie', 'PostTypeId': '1', 'Tags': '<logic><type-theory><coq><proof-assistants>', 'CreationDate': '2014-03-02T17:08:50.310', 'Id': '22241'}}