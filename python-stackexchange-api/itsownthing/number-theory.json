1960:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $a \\neq b$ be two integers from the interval $[1, 2^n].$ Let $p$ be a random prime with $ 1 \\le p \\le n^c.$ Prove that\n$$\\text{Pr}_{p \\in \\mathsf{Primes}}\\{a \\equiv  b \\pmod{p}\\} \\le c \\ln(n)/(n^{c-1}).$$</p>\n\n<p>Hint: As a consequence of the prime number theorem, exactly $n/ \\ln(n) \\pm o(n/\\ln(n))$ many numbers from $\\{ 1, \\ldots, n \\}$ are prime.</p>\n\n<p>Conclusion: we can compress $n$ bits to $O(\\log(n))$ bits and get a quite small false-positive rate.</p>\n\n<p>My question is how can i proove that $$\\text{Pr}_{p \\in \\mathsf{Primes}}\\{a \\equiv  b \\pmod{p}\\} \\le c \\ln(n)/(n^{c-1})$$?</p>\n', 'ViewCount': '118', 'Title': 'Prove fingerprinting', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-06T23:19:40.733', 'LastEditDate': '2012-05-06T22:16:55.400', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1704', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1393', 'Tags': '<probability-theory><information-theory><coding-theory><number-theory>', 'CreationDate': '2012-05-06T18:34:00.527', 'Id': '1692'},1961:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is the complexity of computing $n^{n^2},\\;n \\in \\mathbb{N}$?</p>\n', 'ViewCount': '206', 'Title': 'Complexity of computing $n^{n^2}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-30T19:25:30.803', 'LastEditDate': '2012-07-28T11:10:16.207', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '8', 'OwnerDisplayName': 'Croq', 'PostTypeId': '1', 'Tags': '<complexity-theory><integers><number-theory>', 'CreationDate': '2012-07-27T19:18:38.527', 'FavoriteCount': '1', 'Id': '2933'},1962:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to make a sequence of numbers, where I pick the numbers $a_{0}, a_{1},..,a_{n}$. The length of the sequence is $n+1$.</p>\n\n<p>Now I want the product of any pair of two numbers in the sequence modulo $k$ to be guaranteed to be unique and $k$ has to be as small as it can be in such a way that the resulting set has to be $\\{r_{0},r_{1},\\ldots,r_{k-1\\}}$. So</p>\n\n<p>$$a_{0}a_{1} \\bmod k \\rightarrow r_{0} \\\\\na_{0}a_{2} \\bmod k \\rightarrow r_{1} \\\\\na_{1}a_{2} \\bmod k \\rightarrow r_{2} \\\\\n\\vdots\\\\\na_{n-1}a_{n} \\bmod k \\rightarrow r_{k-1}$$</p>\n\n<p>First I was thinking about using prime numbers, so that the products could be unique, but I have to find a property so that every product is not congruent to every other product. </p>\n\n<p>To be more general: I am looking for a sequence of length $n$ and minimal $k$ such that </p>\n\n<p>$\\qquad \\displaystyle |\\{a_ia_j \\mod k \\mid 0 \\leq i &lt; j \\leq n\\}| = n(n+1)$.</p>\n\n<p>So a mapping from every product mod k to "a value" filling up every number from $0$ to $k-1$.</p>\n', 'ViewCount': '171', 'Title': 'Finding a sequence of numbers where every product of two mod k is unique', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-01T21:59:34.120', 'LastEditDate': '2012-08-01T21:59:34.120', 'AnswerCount': '0', 'CommentCount': '19', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2317', 'Tags': '<algorithms><number-theory>', 'CreationDate': '2012-07-31T08:03:37.330', 'FavoriteCount': '1', 'Id': '2957'},1963:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '748', 'Title': 'How fast can we find all Four-Square combinations that sum to N?', 'LastEditDate': '2012-08-02T16:54:45.280', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2334', 'FavoriteCount': '2', 'Body': '<p>A question was asked at Stack Overflow (<a href="http://stackoverflow.com/questions/11732555/how-to-find-all-possible-values-of-four-variables-when-squared-sum-to-n#comment15599644_11732555">here</a>):</p>\n\n<blockquote>\n  <p>Given an integer $N$, print out all possible\n  combinations of integer values of $A,B,C$ and $D$ which solve the equation $A^2+B^2+C^2+D^2 = N$.</p>\n</blockquote>\n\n<p>This question is of course related to <a href="http://en.wikipedia.org/wiki/Lagrange%27s_four-square_theorem" rel="nofollow">Bachet\'s Conjecture</a> in number theory (sometimes called Lagrange\'s Four Square Theorem because of his proof).  There are some papers that discuss how to find a single solution, but I have been unable to find anything that talks about how fast we can find <em>all</em> solutions for a particular $N$ (that is, all <em>combinations</em>, not all <em>permutations</em>).</p>\n\n<p>I have been thinking about it quite a bit and it seems to me that it can be solved in $O(N)$ time and space, where $N$ is the desired sum. However, lacking any prior information on the subject, I am not sure if that is a significant claim on my part or just a trivial, obvious or already known result.</p>\n\n<p>So, the question then is, how fast can we find all of the Four-Square Sums for a given $N$?</p>\n\n<hr>\n\n<p>OK, here\'s the (nearly) O(N) algorithm that I was thinking of.  First two supporting functions, a nearest integer square root function:</p>\n\n<pre><code>    // the nearest integer whose square is less than or equal to N\n    public int SquRt(int N)\n    {\n        return (int)Math.Sqrt((double)N);\n    }\n</code></pre>\n\n<p>And a function to return all TwoSquare pairs summing from 0 to N:</p>\n\n<pre><code>    // Returns a list of all sums of two squares less than or equal to N, in order.\n    public List&lt;List&lt;int[]&gt;&gt; TwoSquareSumsLessThan(int N)\n    {\n        //Make the index array\n        List&lt;int[]&gt;[] Sum2Sqs = new List&lt;int[]&gt;[N + 1];\n\n        //get the base square root, which is the maximum possible root value\n        int baseRt = SquRt(N);\n\n        for (int i = baseRt; i &gt;= 0; i--)\n        {\n            for (int j = 0; j &lt;= i; j++)\n            {\n                int sum = (i * i) + (j * j);\n                if (sum &gt; N)\n                {\n                    break;\n                }\n                else\n                {\n                    //make the new pair\n                    int[] sumPair = { i, j };\n                    //get the sumList entry\n                    List&lt;int[]&gt; sumLst;\n                    if (Sum2Sqs[sum] == null)\n                    {   \n                        // make it if we need to\n                        sumLst = new List&lt;int[]&gt;();\n                        Sum2Sqs[sum] = sumLst;\n                    }\n                    else\n                    {\n                        sumLst = Sum2Sqs[sum];\n                    }\n                    // add the pair to the correct list\n                    sumLst.Add(sumPair);\n                }\n            }\n        }\n\n        //collapse the index array down to a sequential list\n        List&lt;List&lt;int[]&gt;&gt; result = new List&lt;List&lt;int[]&gt;&gt;();\n        for (int nn = 0; nn &lt;= N; nn++)\n        {\n            if (Sum2Sqs[nn] != null) result.Add(Sum2Sqs[nn]);\n        }\n\n        return result;\n    }\n</code></pre>\n\n<p>Finally, the algorithm itself:</p>\n\n<pre><code>    // Return a list of all integer quads (a,b,c,d), where:\n    //      a^2 + b^2 + c^2 + d^2 = N,\n    // and  a &gt;= b &gt;= c &gt;= d,\n    // and  a,b,c,d &gt;= 0\n    public List&lt;int[]&gt; FindAllFourSquares(int N)\n    {\n        // get all two-square sums &lt;= N, in descending order\n        List&lt;List&lt;int[]&gt;&gt; Sqr2s = TwoSquareSumsLessThan(N);\n\n        // Cross the descending list of two-square sums &lt;= N with\n        // the same list in ascending order, using a Merge-Match\n        // algorithm to find all combinations of pairs of two-square\n        // sums that add up to N\n        List&lt;int[]&gt; hiList, loList;\n        int[] hp, lp;\n        int hiSum, loSum;\n        List&lt;int[]&gt; results = new List&lt;int[]&gt;();\n        int prevHi = -1;\n        int prevLo = -1;\n\n        //  Set the Merge sources to the highest and lowest entries in the list\n        int hi = Sqr2s.Count - 1;\n        int lo = 0;\n\n        //  Merge until done ..\n        while (hi &gt;= lo)\n        {\n            // check to see if the points have moved\n            if (hi != prevHi)\n            {\n                hiList = Sqr2s[hi];\n                hp = hiList[0];     // these lists cannot be empty\n                hiSum = hp[0] * hp[0] + hp[1] * hp[1];\n                prevHi = hi;\n            }\n            if (lo != prevLo)\n            {\n                loList = Sqr2s[lo];\n                lp = loList[0];     // these lists cannot be empty\n                loSum = lp[0] * lp[0] + lp[1] * lp[1];\n                prevLo = lo;\n            }\n\n            // do the two entries\' sums together add up to N?\n            if (hiSum + loSum == N)\n            {\n                // they add up, so cross the two sum-lists over each other\n                foreach (int[] hiPair in hiList)\n                {\n                    foreach (int[] loPair in loList)\n                    {\n                        // make a new 4-tuple and fill it\n                        int[] quad = new int[4];\n                        quad[0] = hiPair[0];\n                        quad[1] = hiPair[1];\n                        quad[2] = loPair[0];\n                        quad[3] = loPair[1];\n\n                        // only keep those cases where the tuple is already sorted\n                        //(otherwise it\'s a duplicate entry)\n                        if (quad[1] &gt;= quad[2]) //(only need to check this one case, the others are implicit)\n                        {\n                            results.Add(quad);\n                        }\n                        //(there\'s a special case where all values of the 4-tuple are equal\n                        // that should be handled to prevent duplicate entries, but I\'m\n                        // skipping it for now)\n                    }\n                }\n                // both the HI and LO points must be moved after a Match\n                hi--;\n                lo++;\n            }\n            else if (hiSum + loSum &lt; N)\n            {\n                lo++;   // too low, so must increase the LO point\n            }\n            else    // must be &gt; N\n            {\n                hi--;   // too high, so must decrease the HI point\n            }\n        }\n        return results;\n    }\n</code></pre>\n\n<p>As I said before, it should be pretty close to O(N), however, as Yuval Filmus points out, as the number of Four Square solutions to N can be of order (N ln ln N), then this algorithim could not be less than that.</p>\n', 'Tags': '<algorithms><complexity-theory><performance><number-theory>', 'LastEditorUserId': '2334', 'LastActivityDate': '2012-08-02T16:54:45.280', 'CommentCount': '5', 'AcceptedAnswerId': '3003', 'CreationDate': '2012-08-01T20:29:11.273', 'Id': '2988'},1964:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $S$ be a set of natural numbers. We consider $S$ under the divisibility partial order, i.e. $s_1 \\leq s_2 \\iff s_1 \\mid s_2$. Let </p>\n\n<p>$\\qquad \\displaystyle \\alpha(S) = \\max \\{|V| \\mid V\\subseteq S, V\\text{ an antichain }\\}$.</p>\n\n<p>If we consider the subset sum problem where the multiset of numbers are in $S$ ,  what can we say about about the complexity of the problem related to $\\alpha(S)$? It is simple to see if $\\alpha(S)=1$, then the problem is easy. Note it is easy even for the harder knapsack problem when $\\alpha(S)=1$<sup>$\\dagger$</sup>.</p>\n\n<hr>\n\n<p>$\\dagger$ <a href="http://dx.doi.org/10.1016/0167-6377%2893%2990044-H" rel="nofollow">Solving sequential knapsack problems</a> by M. Hartmann and T. Olmstead (1993)</p>\n', 'ViewCount': '210', 'Title': 'Subset sum problem with many divisibility conditions', 'LastEditorUserId': '41', 'LastActivityDate': '2013-07-20T09:09:39.243', 'LastEditDate': '2013-07-20T09:09:39.243', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '220', 'Tags': '<complexity-theory><number-theory><knapsack-problems>', 'CreationDate': '2012-08-12T04:42:56.943', 'FavoriteCount': '4', 'Id': '3132'},1965:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was solving this equation:\n$$\\text{key}=\\left(\\sum_{K=0}^n\\frac{1}{a^K}\\right)\\bmod{m}.$$</p>\n\n<h3>Given</h3>\n\n<p>$$ 1,000,000,000 &lt; a, n, m \\; &lt; 5,000,000,000, $$\n$$ a, m \\text{ are coprime}. $$</p>\n\n<p>I solved it by brute force, but it won't work in the given constrains so I need a faster algorithm or is there is something I can notice to make the formula easier to solve ?</p>\n", 'ViewCount': '49', 'Title': 'Solving $\\text{key}=(\\sum_{K=0}^n\\frac{1}{a^K})\\bmod m$ with High limits', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-22T10:30:53.557', 'LastEditDate': '2012-08-22T06:51:14.843', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2607', 'Tags': '<algorithms><discrete-mathematics><number-theory>', 'CreationDate': '2012-08-22T02:25:44.527', 'Id': '3283'},1966:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My question is related to the <a href="http://en.wikipedia.org/wiki/Integer_relation_algorithm" rel="nofollow">Integer Relation Detection Problem</a> which can be formulated as:</p>\n\n<p>$\\qquad a_1x_1 + a_2x_2 + \\cdots + a_nx_n = 0$</p>\n\n<p>Where $\\forall i. a_i\\in\\mathbb{Z} \\land a_i&lt;c \\land x\\in \\mathbb{R}$, and $\\exists i. a_i\\neq 0$. $c$ and vector $\\mathbf{x}$ are given, and the problem is to find a valid vector $\\mathbf{a}$ that satisfies these constraints.</p>\n\n<p>There are a few algorithms to solve this problem, listed on the wikipedia page linked.</p>\n\n<p>My question: are there algorithms for a solution to the same problem with the modification that</p>\n\n<p>$\\qquad a_1x_1 + a_2x_2 + \\cdots + a_nx_n = 1$?</p>\n\n<p>Or equivalently (I believe),</p>\n\n<p>$\\qquad a_1x_1 + a_2x_2 + \\cdots + a_nx_n = b$?</p>\n\n<p>The constant $b\\in \\mathbb R$ is a given.</p>\n\n<p>On <a href="http://math.stackexchange.com/questions/191545/integer-relation-that-equals-one">math.se</a> I ask for a polynomial time algorithm or proof that none exist, with not much luck. Here I ask if a solution to this is equivalent to a solution the knapsack problem (can the knapsack problem be reduced to this), and this would thus be NP-hard.</p>\n', 'ViewCount': '145', 'Title': 'Reduction from knapsack problem to Integer relation that equals one', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-12T22:38:34.833', 'LastEditDate': '2012-09-12T22:38:34.833', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><complexity-theory><np-hard><number-theory><knapsack-problems>', 'CreationDate': '2012-09-11T02:29:27.720', 'FavoriteCount': '0', 'Id': '3503'},1967:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The following is an excerpt from the <a href="http://en.wikipedia.org/wiki/Miller-Rabin_primality_test#Accuracy_of_the_test" rel="nofollow">Wikipedia article on the Miller-Rabin primality test</a>:</p>\n\n<blockquote>\n  <p>It can be shown that for any odd composite $n$, at least $\\frac{3}{4}$ of the bases $a$ are witnesses for the compositeness of $n$.</p>\n</blockquote>\n\n<p>In the Fermat primality test, if $n$ is not a Carmichael number, <a href="http://en.wikipedia.org/wiki/Fermat_primality_test#Flaw" rel="nofollow">at least half of the bases $a$ are Fermat witnesses</a>. Testing for non-trivial roots in the Miller-Rabin primality test however increases the minimum number of witnesses to $\\frac{3}{4}$.</p>\n', 'ViewCount': '321', 'Title': 'In the Miller-Rabin primality test, for a composite number, why are at least $\\frac{3}{4}$ of the bases witnesses of compositeness?', 'LastEditorUserId': '4267', 'LastActivityDate': '2012-12-10T00:51:28.710', 'LastEditDate': '2012-12-10T00:51:28.710', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6250', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4267', 'Tags': '<cryptography><number-theory>', 'CreationDate': '2012-10-22T20:39:25.463', 'Id': '6241'},1968:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '194', 'Title': 'Algorithmic consequences of algebraic formula for partition function?', 'LastEditDate': '2012-10-27T11:21:20.700', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '667', 'FavoriteCount': '2', 'Body': '<p><a href="http://www.aimath.org/news/partition/brunier-ono">Bruinier and Ono</a> have found an algebraic formula for the <a href="http://en.wikipedia.org/wiki/Partition_function_%28number_theory%29#Partition_function">partition function</a>, which was widely reported to be a breakthrough. I am unable to understand the paper, but does it have any algorithmic consequences for fast computation of the partition function?</p>\n', 'Tags': '<algorithms><complexity-theory><number-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-27T15:47:28.097', 'CommentCount': '2', 'AcceptedAnswerId': '6338', 'CreationDate': '2012-10-26T11:33:57.743', 'Id': '6323'},1969:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I often read that deciding whether or not a number $r$ is a quadratic residue modulo $n$ is an interesting (and hard) problem from number theory (especially if $n$ is not prime). </p>\n\n<p>I am looking at the following special case of this problem: Let $p$ and $q$ be two different prime numbers and $n:=pq$. Given $r$ between $1$ and $n$. Decide if there exists an $x\\in\\mathbb{Z}/n\\mathbb{Z}$ such that $x^2\\equiv r\\pmod{n}$.</p>\n\n<p>My question is: The functional version of this problem i.e. "Find such an $x$ as above" yields an randomized algorithm for integer factoring. So it is <em>very</em> interesting for practical reasons like "breaking RSA". Is there any such result for the decision version of this problem? If not, what are typical problems that let us think that deciding quadratic residuosity it is a hard problem?</p>\n\n<p>And furthermore, is the special case I\'m looking at really a special case? Or can I solve the general case with an arbitrary $n$ with an oracle for the decision problem above?</p>\n', 'ViewCount': '151', 'Title': 'Quadratic residue and integer factoring', 'LastActivityDate': '2013-02-11T09:03:33.197', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9666', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2103', 'Tags': '<cryptography><number-theory>', 'CreationDate': '2013-02-10T17:33:56.953', 'Id': '9642'},19610:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The sum divider game for $n$ starts with the set $M_0 = \\{1,\\dots,n\\}$. Player A chooses a number $m_1$ from $M_0 \\setminus \\{1\\}$ and B has to choose a divider $m_2$ of $m_1$ from $M_1 = M_0 \\setminus \\{m_1\\}$. The players continue to choose a number $m_i$ from $M_{i-1} = M_{i-2} \\setminus \\{m_{i-1}\\}$ alternatingly, where every $m_i$ has to divide $\\sum_{k=1}^{i-1} m_k$. A player wins, if the other player is unable to do so and $M_{i-1} \\neq \\emptyset$, $M_{i-1} = \\emptyset$ is considered a tie.</p>\n\n<p>My questions:</p>\n\n<ul>\n<li>Is there an $n &gt; 2$, for which A has no winning strategy?</li>\n<li>Given some $n$ (in <strike>binary</strike> unary representation), how hard is it to decide whether there is a winning strategy for A\n<ul>\n<li>where A wins in at most $k$ steps ?</li>\n<li>where A chooses no prime numbers ?</li>\n</ul></li>\n</ul>\n', 'ViewCount': '230', 'Title': 'Complexity of deciding whether there is a winning strategy in the following game', 'LastEditorUserId': '41', 'LastActivityDate': '2013-07-20T09:17:09.133', 'LastEditDate': '2013-07-20T09:17:09.133', 'AnswerCount': '0', 'CommentCount': '18', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6716', 'Tags': '<complexity-theory><time-complexity><game-theory><number-theory>', 'CreationDate': '2013-02-21T14:10:55.227', 'FavoriteCount': '2', 'Id': '10011'},19611:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '448', 'Title': 'Finding the size of the smallest subset with GCD = 1', 'LastEditDate': '2013-03-04T17:08:46.660', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'user7134', 'PostTypeId': '1', 'OwnerUserId': '7137', 'FavoriteCount': '3', 'Body': '<p>This is a problem from the practice session of the <a href="http://main.edu.pl/en/archive/amppz/2012/dzi">Polish Collegiate Programming Contest 2012</a>. Although I could find the solutions for the main contest, I can\'t seem to find the solution for this problem anywhere.</p>\n\n<p>The problem is: Given a set of $N$ distinct positive integers not greater than $10^9$, find the size $m$ of the smallest subset that has no common divisor other than 1. $N$ is at most 500, and a solution can be assumed to exist.</p>\n\n<p>I managed to show that $m \\le 9$. My reasoning is: Suppose there exists a minimal subset $S$ of size $|S|=10$, with gcd = 1. Then all 9-subsets of $S$ must have gcd > 1. There are exactly 10 such subsets, and their gcds must be pairwise coprime. Let these gcds be $1 &lt; g_1 &lt; g_2 &lt; ... &lt; g_{10}$, where $\\gcd(g_i,g_j)=1$, for $i \\neq j$. Then the maximum number in $S$ is $g_2g_3...g_{10}$. But $g_2g_3...g_{10} \\ge 3\\times5\\times7\\times11\\times...\\times29=3234846615 &gt; 10^9$, a contradiction.</p>\n\n<p>However, even with this, a straightforward brute force is still too slow. Does anyone have any other ideas?</p>\n', 'Tags': '<algorithms><number-theory>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-08T19:29:52.007', 'CommentCount': '2', 'CreationDate': '2013-03-04T06:25:47.053', 'Id': '10249'},19612:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can anyone suggest an algorithm faster than $\\Theta(n^{2})$ for computing the following function:</p>\n\n<p>$$||n||:=\\frac{1}{\\max\\{k \\in \\mathbb{N}: 1|n, 2|n,\\ldots,k|n\\}}$$</p>\n', 'ViewCount': '49', 'Title': 'Faster Algorithm for Computing Norm', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T13:33:31.867', 'LastEditDate': '2013-03-25T10:34:36.653', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10772', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4829', 'Tags': '<algorithms><discrete-mathematics><number-theory>', 'CreationDate': '2013-03-25T05:15:10.013', 'Id': '10762'},19613:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I found a variant of this problem in one of the recent algorithms competitions. </p>\n\n<p>Given any two integers ($A,B, A \\lt B$), find the least number, $L$, of integers between $A$ and $B$ ($N_i, 1 \\lt i \\lt L, A \\le N_i \\le B_i$), such that any two consecutive integers are co-prime</p>\n\n<p>$$\\gcd(A, N_1) = 1, \\gcd( N_i, N_{i+1}) = 1, \\gcd( N_L, B) = 1$$</p>\n\n<ol>\n<li>Example 1: $A = 7, B = 13$. $A$ and $B$ are co-prime, therefore the result is $0$.</li>\n<li>Example 2: $A = 10, B = 12$. Since $A$ and $B$ have a $\\gcd$ of $2$, therefore at least one integer has to be in between them, in this case $11$ ( $\\gcd(10, 11) = 1, \\gcd(11, 12) = 1$).</li>\n<li>Example 3: $A = 2184, B = 2200$. In this case, there is no single integer between $A$ and $B$ can be found that is co-prime to both $A$ and $B$. However, we can find $2$ integers that satisfy this problem.</li>\n</ol>\n\n<p>The solution assumes that </p>\n\n<p>a) the problem is always solvable and that </p>\n\n<p>b) the number of integers, $L$, is at most $2$. I'm having trouble with proving either of those claims.</p>\n\n<p>For reference, I have a polynomial-time (w.r.t. $B-A$ ) solution that does not assume  either of the two claims above. I'm not losing out on the asymptotic performance compared to the reference solution, but I could get the performance constants much lower if I can understand and prove the validity of the claims.</p>\n", 'ViewCount': '134', 'Title': 'The length of the smallest co-prime chain between any two integers', 'LastEditorUserId': '139', 'LastActivityDate': '2013-05-02T15:28:11.350', 'LastEditDate': '2013-05-02T15:28:11.350', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7997', 'Tags': '<number-theory>', 'CreationDate': '2013-05-01T14:17:13.347', 'FavoriteCount': '2', 'Id': '11694'},19614:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This seems like a question that should have an easy answer, but I don\'t have a definitive one: </p>\n\n<blockquote>\n  <p>If I have two $n$ bit numbers $a, p$, what is the complexity of\n  computing $a\\bmod p$ ?</p>\n</blockquote>\n\n<p>Merely dividing $a$ by $p$ <a href="http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations">would take time</a> $O(M(n))$ where $M(n)$ is the complexity of multiplication. But can $\\bmod$ be performed slightly faster ? </p>\n', 'ViewCount': '134', 'Title': 'Complexity of taking mod', 'LastActivityDate': '2013-06-28T01:35:18.507', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12934', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '45', 'Tags': '<algorithms><number-theory>', 'CreationDate': '2013-06-27T19:34:48.577', 'FavoriteCount': '2', 'Id': '12931'},19615:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to find out an algorithm to find out the largest least common multiple (LCM) of the partitions of an integer $n$.</p>\n\n<p>Example:  $5 = 1 + 4$, $5 = 2 + 3$, since $\\mathrm{LCM}(1,4) &lt; \\mathrm{LCM}(2,3) = 6$, the largest LCM of the partitions of $5$ is 6.</p>\n\n<p>The definition of "partition" is the standard definition of it. In order to make the problem more clearly, I will take n = 10 as an example. The largest LCM if the partitions of 10 is 30, since 10 = 2 + 3 + 5.\nMore examples(Let g(n) be the answer that I want to get):\ng(11) = 30\ng(12) = 60\ng(13) = 60</p>\n\n<p>I want to find out an algorithm that can get the largest LCM in 1 second with the n less or equal to 250.</p>\n', 'ViewCount': '408', 'Title': 'Find out the largest LCM of the partitions of n', 'LastEditorUserId': '9042', 'LastActivityDate': '2013-08-15T10:53:20.320', 'LastEditDate': '2013-07-07T07:24:40.940', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9042', 'Tags': '<algorithms><number-theory>', 'CreationDate': '2013-07-06T02:43:45.263', 'Id': '13101'},19616:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a set $S$ of integers.  I want to remove all elements of $S$ that are divisors of another element of $S$.  In other words, I want to compute $T = \\{y \\in S : \\forall d \\in S . d \\nmid y \\}$.</p>\n\n<p>How do I do this efficiently?</p>\n\n<p>I can see how to do it in $\\Theta(|S|^2)$ time, by examining all pairs of elements of $S$ and keeping only the ones that don't have any divisor in $S$.  Can it be done substantially faster?  (For simplicity, I'm willing to assume that all standard integer operations---addition, multiplication, division, etc.---can be done in $O(1)$ time.  Yes, I know this is an imperfect approximation, but if it makes your answer cleaner, I'm fine with it.)</p>\n", 'ViewCount': '64', 'Title': 'Remove divisors from a set of integers', 'LastActivityDate': '2013-07-08T06:31:54.970', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><integers><number-theory>', 'CreationDate': '2013-07-08T03:30:37.670', 'Id': '13153'},19617:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a question from the book <code>Data structures using C and C++ by Tenenbaum</code>. Not a homework problem but self-study.</p>\n\n<blockquote>\n  <p>Recursive definition of a+b, where a and b are non-negative integers, in terms of successor function <code>succ</code> defined as</p>\n  \n  <p>succ(int x)\n      {\n          return(x++);\n      }</p>\n</blockquote>\n\n<p>I have been thinking how is it possible? Can I change the function? I am not sure from the problem definition in the book. So how can this be done?</p>\n', 'ViewCount': '282', 'Title': 'Recursive definition of sum of two numbers in terms of the successor function', 'LastEditorUserId': '683', 'LastActivityDate': '2013-09-02T11:13:25.650', 'LastEditDate': '2013-08-07T15:23:59.207', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13660', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9051', 'Tags': '<algorithms><recursion><number-theory>', 'CreationDate': '2013-08-07T14:26:48.393', 'Id': '13659'},19618:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My question is related to <a href="http://math.stackexchange.com/questions/465240/constant-time-algorithm-for-finding-greatest-factor-of-odd-composite-number">this question</a> posted on <a href="http://math.stackexchange.com">math.SE</a>:</p>\n\n<blockquote>\n  <p>Given an odd number, what is the quickest (constant-time) algorithm for finding its largest factor and suppose you can call a helper function $B$ which takes as its input $(N, k)$ and outputs True iff $N$ has a factor greater than or equal to $k$? Obviously, the factor cannot be itself. </p>\n</blockquote>\n\n<p>My slightly altered problem statement goes like this.</p>\n\n<blockquote>\n  <p>Given an odd integer $n$, find its largest factor (that is not itself). You can call a function $B(m,k)$ that returns $1$ iff $m$ has a factor smaller than $k$. The function runs in constant time.</p>\n</blockquote>\n\n<p>Can this be done faster than $O(\\log n)$ in the average case (assuming the input is chosen uniformly at random)? Is my altered problem statement any better than the original? Specifically, I know that the probability some large number will have no factor smaller than $M$ is asymptotic to $\\frac{1}{\\log M}$ (see <a href="http://math.stackexchange.com/questions/94645/expected-smallest-prime-factor">A</a>, and <a href="http://math.stackexchange.com/questions/284500/probability-of-a-number-not-having-factors-below-n">B</a>). Can you use this to your advantage?</p>\n\n<p>You can also assume that division is constant time.</p>\n\n<h1>Edit and Attempt Solution:</h1>\n\n<p>$\n\\newcommand{\\ha}[2]{\\left[#1 \\dots #2\\right)} \n\\newcommand{\\expa}[1]{2^{#1}}\n\\newcommand{\\expb}[1]{2^{2^{#1}}}\n\\newcommand{\\abs}[1]{\\left|#1\\right|}\n\\newcommand{\\expv}[1]{\\mathrm{E}\\left(#1\\right)}\n\\newcommand{\\sch}{\\mathbb{S}}\n\\newcommand{\\floor}[1]{\\left\\lfloor#1 \\right\\rfloor}\n\\newcommand{\\logb}[1]{\\log \\log #1}\n$\nThe difference between my problem statement and the original, is the definition of the function $B$. In the original, $B(N,k)$ returns $1$ if $N$ has a factor greater than or equal to $k$; in my version, this happens if $N$ has a factor <em>less than</em> $k$. </p>\n\n<p>By making this change, I aim to capitalize on the fact that the probability of a large $N$ having no factors smaller than $M$ is asymptotic to $(\\log M)^{-1}$. While this fact does not change the worst-case performance of an algorithm, it can change average-case performance. Here, by average case, I mean probabilistic analysis of the algorithm over random, uniformly distributed inputs.</p>\n\n<p>(Note that my question involves only exact algorithms)</p>\n\n<p>I conjectured in my comment to the related question that you can benefit from the probability by changing the way in which you partition your search space when performing a binary search (since it is much more likely for the solution to be in $\\ha{1}{1000}$ instead of $\\ha{1000}{N}$). I also conjectured the algorithm could run in $O(\\logb N)$ average-case.</p>\n\n<h2>Attempted Solution</h2>\n\n<p>I decided to do some work on the problem myself, and I think I have a solution. I haven\'t really done this sort of analysis previously, so I may have some error, and there is definitely a lot missing in terms of details. I think the idea is correct, though. Note that here I find the <em>smallest</em> factor of $N$. We can easily find the largest factor by division (which I assume to be contstant time).</p>\n\n<p>I\'m posting it as part of the question because I\'m not sure if it\'s correct, and I still want to know if there\'s a better way.</p>\n\n<p>Let us partition the search space $\\sch = \\ha{1}{N}$ into disjoint integer intervals, \n$$ r_k = \\ha{\\expb k}{\\expb {k+1}} \\qquad 0 \\leq k \\leq \\floor{\\logb N}$$</p>\n\n<p>Note that it can be that,\n$$ \\expb{\\floor{\\logb N+1}} &gt; N$$\nThat doesn\'t really matter; all we want from the partitioning $r$ is to contain the entire search space.</p>\n\n<p>Now, the probability that the smallest factor of $N$, which we will call $A$, is greater than $m$ is asymptotic to $(\\log m)^{-1}$. \nThen let, $P(A &gt; \\expb{k}) = 2^{-k}$, where $A$ is taken to be a random variable. If we let $P(r_k)$ denote the probability that $A \\in r_i$, we can calculate this as:\n$$P(r_k) = P(a &gt; \\expb{k}) - P(a &gt; \\expb{k+1}) = 2^{-(k+1)}$$</p>\n\n<p>We can identify which partition $r_k$ contains $A$ by calling the function $B(N,\\expb{k})$ up to $\\floor{\\logb N} + 1$ times. After finding the $r_k$, we then perform a binary search for $A$ in the partition, which involves $\\log \\abs{r_k}$ operations. Here we note that:\n$$|r_k|=\\expb{k+1}-\\expb{k} = \\expb{k}\\left(\\expb{k} - 1\\right)\\leq \\expb{k+1}$$</p>\n\n<p>Let $X$ be a random variable representing the number of operations taken by the binary search. The value of $X$ for the case when $A \\in r_k$ is given $X_k = \\log \\expb{k+1} = 2^{k+1}$. The expected value of $X$ is then,\n$$\\expv{X} = \\sum_{k=0}^{\\floor{\\logb N} + 1} X_i P(r_i) = \\sum_{k=0}^{\\floor{\\logb N} + 1} 2^{k+1}\\cdot 2^{-(k+1)} = \\floor{\\logb N} +1$$</p>\n\n<h2>Notes</h2>\n\n<p>I\'ve considered partitioning the search space using triple-exponentiation (e.g. $\\expa{\\expb{k}}$), but that provides no benefit. There might be a way to make the search algorithm inside the partitions faster though, but I\'m not sure how. </p>\n\n<p>You can also reduce the search space drastically (such as to something like $\\sqrt{N}$), but I think this will have a constant speedup at most.</p>\n', 'ViewCount': '195', 'Title': 'Time complexity of finding the largest factor of a number (using a specific oracle)', 'LastEditorUserId': '4543', 'LastActivityDate': '2013-08-17T16:51:14.237', 'LastEditDate': '2013-08-17T16:51:14.237', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4543', 'Tags': '<algorithms><time-complexity><number-theory><factoring>', 'CreationDate': '2013-08-16T09:49:37.510', 'FavoriteCount': '2', 'Id': '13773'},19619:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given complex number $C=a+ib$, I want to find two complex numbers $C_1=x+iy$ and $C_2=z+iw$ such that $C=C_1*C_2$ (a,b,x,y, z and w are all non zero integers). This problem is at least as hard as Integer factoring. Prime complex number has one as its only factor.</p>\n\n<p>Does this problem reduce to integer factoring? Is it NP-hard?</p>\n', 'ViewCount': '128', 'Title': 'How hard is factoring a complex number?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-06T15:28:15.030', 'LastEditDate': '2013-09-06T15:28:15.030', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14160', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><number-theory><factoring>', 'CreationDate': '2013-09-05T21:54:52.927', 'Id': '14158'},19620:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Reading an article on <a href="http://www.ams.org/notices/199612/pomerance.pdf" rel="nofollow">integer factorization</a> I implemented the following -  rather inefficient - factorization method:  </p>\n\n<blockquote>\n  <p>Every odd\n  composite can be factored as a difference of\n  squares: $$ ab = \\left[\\tfrac{1}{2}(a+b)\\right]^2 -\n \\left[\\tfrac{1}{2}(a-b)\\right]^2$$ \n  We can look at values of $f(x) = x^2 - n$ until we find a perfect square and factor.</p>\n</blockquote>\n\n<p>Here\'s my implementation in Python.</p>\n\n\n\n<pre><code>def fermat(n):\n    x = int(np.sqrt(n))+1\n    y = int(np.sqrt(abs(y*y - n)))\n\n    while( n - x*x + y*y != 0):\n        x += 1\n        y = int(np.sqrt(abs(x*x - n)))\n\n    return x, y\n</code></pre>\n\n<p>How expensive are the square root calculations here?  Are they necessary?\nIn order to check I have a perfect square, I compute $\\lfloor \\sqrt{x^2-n}\\rfloor$ many times.  </p>\n', 'ViewCount': '105', 'Title': "integer factoring using Fermat's method", 'LastActivityDate': '2013-10-07T16:54:29.277', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><number-theory><factoring>', 'CreationDate': '2013-10-07T15:49:11.143', 'Id': '14888'},19621:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I am given a number $n$ (less than $10^8$) and $m$ (less than $10^7$) and $p$ (less than $10^4$), I have to write a program to find number of numbers that divide $n^m$ exactly $p$ times.</p>\n\n<p>Mathematically, I have to find number of distinct $x$ such that\n$$ n^m \\equiv 0 \\mod x^p \\qquad\\text{and}\\qquad n^m \\ne 0 \\mod x^{p+1} $$</p>\n\n<p>(From <a href="http://uva.onlinejudge.org/external/122/12216.html" rel="nofollow">UVa Online Judge</a>)</p>\n\n<p>What approach could be better than brute force?</p>\n', 'ViewCount': '55', 'Title': 'Finding number of numbers dividing n^m exactly p times', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-10T09:25:41.220', 'LastEditDate': '2013-10-10T09:25:41.220', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7890', 'Tags': '<algorithms><number-theory><arithmetic><mathematical-programming>', 'CreationDate': '2013-10-10T08:27:13.950', 'Id': '14981'},19622:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let:</p>\n\n<ul>\n<li>$\\left\\{m_1, ~...~, m_k\\right\\}$ be a set of coprime natural numbers,</li>\n<li>$M=\\prod_{i=1}^{k} m_i$</li>\n<li>$X$ be a natural integer, such that $X &lt; M$</li>\n</ul>\n\n<p>Then $X$ can be expressed in the <a href="http://en.wikipedia.org/wiki/Residue_number_system" rel="nofollow">Residue Number System</a> as:</p>\n\n<p>$$X={\\left(x_1, ~...~, x_k\\right)}_{RNS\\left(m_1, ~...~, m_k\\right)}~.$$</p>\n\n<p>Where $\\forall_{m_i} \\left[\\left(x_i \\equiv X \\mod m_i\\right) ~~~ \\wedge ~~~0 \\le x_i &lt; m_i \\right]$.</p>\n\n<p>There are a plethora of papers attacking the problem of parity/magnitude comparison in <em>Residue Number Systems</em>; however many of these papers are focused on chip-depth or shaving large constants off of chip-area. I am finding it difficult to decipher if there are any exact algorithms that run faster than full binary reconstruction, which takes $\\sim \\mathcal{O}(k^2)$  time. (For simplicty/brevity, I am assuming small $m_i$, and constant-time modulo-multiplication/addition of each RNS "digit").</p>\n\n<p>Most of the papers\' novelties lie in some seeming "gimmick", but no real complexity decrease; examples of results:</p>\n\n<ul>\n<li>Fast inexact parity algorithms (usually work terribly when $X &lt; \\sqrt{M}$, or $|X| \\ll |M|$, where $\\left|n\\right|=\\text{size of }n=\\left\\lceil\\log_2n\\right\\rceil$)</li>\n<li>Algorithms that work quickly "most of the time"; ie. they use an inexact algorithm, and then the full CRT reconstruction or equivalent in the worst case</li>\n<li>The circuit they present competes with some other paper\'s circuit by some constant, or area/depth tradeoff, but makes no complexity advance</li>\n<li>Full CRT reconstruction of $X$, perhaps using some trick to save some constants</li>\n<li>Reconstruct/convert to another number system (including binary) where parity/comparison is easy, but:\n<ul>\n<li>this conversion/reconstruction takes $\\sim \\mathcal{O}(k^2)$ time,</li>\n<li>or it runs in $\\sim \\mathcal{O}(k)$, time but with $k$ processors,</li>\n<li>or it runs in $\\sim \\mathcal{O}(k)$ time because that is the depth of the circuit, but this is not algorithmic complexity,</li>\n<li>or it reuses previous components that must be there for RNS multiplication (saving circuit space), but still runs in $\\sim \\mathcal{O}(k^2)$ sequential-time, or $\\sim \\mathcal{O}(k)$ parallel-time</li>\n</ul></li>\n<li>Using a "core" function which basically boils down to a constant-trimmed-CRT, or an approximate CRT</li>\n<li>Using special moduli, makes individual operations simpler, but parity complexity stays the same</li>\n<li>Using special moduli, but limited number of moduli or can\'t have small $m_i$</li>\n<li>Base extension, saves some constant or allows parallel-ness, but complexity is again $\\sim \\mathcal{O}(k^2)$ sequential-time, or $\\sim \\mathcal{O}(k)$ parallel-time (for multiplication)</li>\n<li>Redundant moduli, but maintaining the redundant moduli takes  $\\sim \\mathcal{O}(k^2)$ sequential-time, or $\\sim \\mathcal{O}(k)$ parallel-time</li>\n<li>Using lookup tables to reduce depth of some parity, no complexity improvement</li>\n</ul>\n\n<p>Many of the papers do not address complexity at all, or do not address sequential complexity, or even more confusingly, some state the depth/parallel complexity without being precise that it is not sequential; until you read and decipher the entire paper, and discover it yourself.</p>\n\n<h3>Bottom line</h3>\n\n<p><strong>What are the best <em>sequential</em>, <em>worst-case</em>, complexity results in RNS<sup>*</sup> for <em>exact</em> parity checking or magnitude comparison?</strong></p>\n\n<p><sup><strong>*Results for RNS-<em>like</em> system would also be interesting, including special moduli sets</strong></sup></p>\n\n<hr>\n\n<p><sup><sup>\n<strong>More background info</strong>:\n</sup></sup></p>\n\n<p><sup><sup> Multiplication of two numbers in the same RNS base is simply pointwise modulo multiplication of the two numbers (this can be approximately linear time). However, overflow detection is difficult (it is difficult with addition as well). Multiplication seems much simpler, but parity and magnitude comparison of two numbers seems much more difficult. Magnitude comparison is simply determining which of two numbers is greater, $X \\stackrel{?}{&lt;} Y$, given <em>only</em> their RNS form with the same RNS bases. Parity is simply deciding if a number, $X={\\left(x_1, ~...~, x_k\\right)}_{RNS\\left(m_1, ~...~, m_k\\right)}$ is even or odd (obviously, $X$ is not given, only its RNS form). An interesting thing is that magnitude comparison and parity are related: If you were able to compute parity, then you can do comparison. To do comparison with parity, you do $(X - Y)$ (in RNS), and if it underflows, the parity will be unexpected. That is, normally, assuming $p(X) = X \\mod 2, ~~~ p(X) \\in \\{0,1\\}$ is the parity function, $p(X-Y) \\equiv p(X) + p(Y) \\mod 2$. However, if it underflows, it will wrap around to $M-1$. Therefore if the parity is off after $X-Y$, you know that $Y &gt; X$.\n</sup></sup></p>\n', 'ViewCount': '208', 'Title': 'Best complexity of parity/comparison in the Residue Number System', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-23T23:32:04.833', 'LastEditDate': '2013-10-23T23:32:04.833', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><reference-request><integers><number-theory>', 'CreationDate': '2013-10-23T21:28:12.190', 'Id': '16374'},19623:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '130', 'Title': 'Carry-free multiplication operation', 'LastEditDate': '2013-10-30T17:32:48.187', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '3', 'Body': '<p>In long-multiplication, you shift and add, once for each $1$ bit in the lower number.</p>\n\n<p>Let $r = p \\otimes q$ be an operation similar to multiplication, but slightly simpler: when expressed via long-multiplication, the addition does not carry. Essentially you bitwise-<strong>xor</strong> the shifted numbers.</p>\n\n<p>Like so:</p>\n\n<p>$$\n  \\left[\\begin{matrix}\n    &amp;&amp;p_n &amp; ... &amp; p_i &amp; ... &amp; p_2 &amp; p_1 \\\\\n    &amp;&amp;q_n &amp; ... &amp; q_i &amp; ... &amp; q_2 &amp; q_1 &amp; \\otimes\\\\\n    \\hline\\\\\n    &amp;&amp;q_1 \\cdot p_n &amp; ... &amp; q_1 \\cdot p_i\n      &amp; ... &amp; q_1 \\cdot p_2 &amp; q_1 \\cdot p_1\\\\\n    &amp;q_2 \\cdot p_n &amp; ... &amp; q_2 \\cdot p_i\n      &amp; ... &amp; q_2 \\cdot p_2 &amp; q_2 \\cdot p_1\\\\\n    &amp;&amp;&amp;&amp;&amp;&amp;&amp;...\\\\\n    q_i \\cdot p_n &amp; ... &amp; q_i \\cdot p_i\n      &amp; ... &amp; q_i \\cdot p_2 &amp; q_i \\cdot p_1 &amp; \\stackrel{i}{\\leftarrow}\n      &amp;&amp;{\\Huge{\\oplus}} \\\\\n    \\hline \\\\\n    \\\\r_{2n}&amp; ... &amp; r_i\n      &amp; ... &amp;r_4&amp; r_3 &amp; r_2 &amp;r_1 &amp; =\n  \\end{matrix}\n  \\right]\n$$</p>\n\n<p>Using the long-multiplication-style formulation, this takes $\\mathcal O\\left(\\max\\left(\\left|p\\right|,\\left|q\\right|\\right)^2\\right)=\\mathcal O\\left(\\left|r\\right|^2\\right)$ time. Can we do better? Perhaps we can reuse some existing multiplication algorithms, or even better.</p>\n\n<hr>\n\n<h2>Followup: <a href="http://cs.stackexchange.com/q/16585/2755">Shift-and-or multiplication operation</a></h2>\n', 'Tags': '<algorithms><integers><number-theory><multiplication>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-30T17:32:48.187', 'CommentCount': '4', 'AcceptedAnswerId': '16581', 'CreationDate': '2013-10-30T16:33:37.543', 'Id': '16578'},19624:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Continuing in the same vein as <a href="http://cs.stackexchange.com/q/16578/2755">Carry-free multiplication operation</a>, a followup question is as follows (differences in bold):</p>\n\n<p>Let $r = p \\oplus q$ be an operation similar to multiplication, but slightly simpler: when expressed via long-multiplication the columns aren\'t summed up, but rather <strong>or</strong>\'d (not <strong>xor</strong>) together. Nothing is carried.</p>\n\n<p>$$\n  \\left[\\begin{matrix}\n    &amp;&amp;p_n &amp; ... &amp; p_i &amp; ... &amp; p_2 &amp; p_1 \\\\\n    &amp;&amp;q_n &amp; ... &amp; q_i &amp; ... &amp; q_2 &amp; q_1 &amp; \\otimes\\\\\n    \\hline\\\\\n    &amp;&amp;q_1 \\cdot p_n &amp; ... &amp; q_1 \\cdot p_i\n      &amp; ... &amp; q_1 \\cdot p_2 &amp; q_1 \\cdot p_1\\\\\n    &amp;q_2 \\cdot p_n &amp; ... &amp; q_2 \\cdot p_i\n      &amp; ... &amp; q_2 \\cdot p_2 &amp; q_2 \\cdot p_1\\\\\n    &amp;&amp;&amp;&amp;&amp;&amp;&amp;...\\\\\n    q_i \\cdot p_n &amp; ... &amp; q_i \\cdot p_i\n      &amp; ... &amp; q_i \\cdot p_2 &amp; q_i \\cdot p_1 &amp; \\stackrel{i}{\\leftarrow}\n      &amp;&amp;{\\bigvee} \\\\\n    \\hline \\\\\n    \\\\r_{2n}&amp; ... &amp; r_i\n      &amp; ... &amp;r_4&amp; r_3 &amp; r_2 &amp;r_1 &amp; =\n  \\end{matrix}\n  \\right]\n$$</p>\n\n<p>Using the long-multiplication-style formulation, this takes $\\mathcal O\\left(\\max\\left(\\left|p\\right|,\\left|q\\right|\\right)^2\\right)=\\mathcal O\\left(\\left|r\\right|^2\\right)$ time. Can we do better? Perhaps we can reuse some existing multiplication algorithms, or even better.</p>\n', 'ViewCount': '446', 'Title': 'Shift-and-or multiplication operation', 'LastActivityDate': '2013-10-30T19:44:37.417', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><integers><number-theory><multiplication>', 'CreationDate': '2013-10-30T17:35:19.933', 'FavoriteCount': '2', 'Id': '16585'},19625:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we have a $n\\times n$ symmetric matrix $\\mathbf A$.</p>\n\n<p>I want to know if there exists two elements of a vector $\\mathbf x$, let's call them $x_i,x_j,i\\ne j$, such that $x_i +x_j+[A]_{i,j}\\ge y$ for some vector $\\mathbf x$ of size $n$. So:</p>\n\n<p>$$\nf\\left(\\mathbf x \\in \\mathbb N^n,y\\right)=\n\\begin{cases}\n1&amp;\\text{if }\\exists_{i,j,i\\ne j}x_i+x_j+[A]_{i,j}\\ge y\\\\\n0&amp;\\text{otherwise}\\\\\n\\end{cases}\n$$</p>\n\n<p>We can alternatively formulate it simpler, by subtractiong $\\frac y 2$ from all $x_i \\in \\mathbf x$, and flip the sign of the elements $\\mathbf A$ and formulate it like this:</p>\n\n<p>$$\ng\\left(\\mathbf x \\in \\mathbb N^n\\right)=\n\\begin{cases}\n1&amp;\\text{if }\\exists_{i,j,i\\ne j}x_i+x_j\\ge [A]_{i,j}\\\\\n0&amp;\\text{otherwise}\\\\\n\\end{cases}\n$$\n$\\mathbf A$ does not have to be stored as a matrix, and I am hoping some other form of storage can help here - some sort of precomputation.</p>\n\n<h3>Is there an efficient algorithm for this (subquadtratic in $n$)?</h3>\n\n<p>I am sort of struggling to name this, so:</p>\n\n<h3>Is this a known problem, or reducible to a known problem?</h3>\n", 'ViewCount': '46', 'Title': '2SUM with a weight', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-12T00:37:23.937', 'LastEditDate': '2013-11-11T14:59:50.627', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><data-structures><number-theory>', 'CreationDate': '2013-11-11T05:49:04.410', 'Id': '17907'},19626:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to estimate the computational complexity of some algorithm that does $\\psi_q(m)$ iterations. Assume that all inputs $m$ are coprime to $q$.</p>\n\n<p>So I need to know what growth the $\\psi(m)$ has.</p>\n', 'ViewCount': '44', 'Title': u'What is growth of $\\psi_q(m) = \\min \\{ p: m \u2223 (q^p\u22121) \\}$ for fixed $q$?', 'LastEditorUserId': '8887', 'LastActivityDate': '2013-11-14T23:39:56.287', 'LastEditDate': '2013-11-14T23:11:45.677', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18035', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8887', 'Tags': '<asymptotics><number-theory>', 'CreationDate': '2013-11-14T22:44:13.930', 'Id': '18033'},19627:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '64', 'Title': 'Are there pseudorandom number generators (PRNG) with no finite period?', 'LastEditDate': '2013-11-22T11:16:09.327', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p>The typical and widely used <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator" rel="nofollow">PRNG</a>, the <a href="http://en.wikipedia.org/wiki/Linear_congruential_generator" rel="nofollow">linear congruential generator</a> always has a finite (though possibly "long") period. Are there PRNGs that have no finite period?</p>\n</blockquote>\n\n<p>For this question it is not necessary that it be practical or used in real-world implementations.</p>\n', 'Tags': '<reference-request><number-theory><pseudo-random-generators>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-22T19:53:32.883', 'CommentCount': '1', 'AcceptedAnswerId': '18251', 'CreationDate': '2013-11-22T03:12:52.983', 'Id': '18250'},19628:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '107', 'Title': "Implement Mathematica's capability of rationalizing machine reals", 'LastEditDate': '2014-03-24T14:14:18.297', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'LCFactorization', 'PostTypeId': '1', 'OwnerUserId': '11634', 'Body': '<p>If I have a variable <code>x</code> bound to a machine precision real in <em>Mathematica</em>, I can use</p>\n\n<pre><code> y = FromDigits[RealDigits[x]]\n</code></pre>\n\n<p>then y is bound to a <em>completely equivalent</em> rational number which has <em>infinite precision</em>.</p>\n\n<p>What are the basic principles behind <code>FromDigits</code> and <code>RealDigits</code>?\nHow could I implement a similar conversion using common machine operations (fixed-size integers and floating point operations) to coerce a double in a rational, or at least obtain the long integer denominator and numerator of a double?</p>\n', 'Tags': '<number-theory><arithmetic><real-numbers>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-24T14:14:18.297', 'CommentCount': '4', 'AcceptedAnswerId': '18417', 'CreationDate': '2013-11-26T05:43:58.190', 'Id': '18365'},19629:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am having a plane in N dimension. Th distance between 2 points (a1,a2,...,aN) and (b1,b2,...,bN) is max{|a1-b1|, |a2-b2|, ..., |aN-bN|}.</p>\n\n<p>I need to to know how many K-sets exist(here K-set refers to set of points whose distance between 2 points of set is K).But as there can be infinite number of these K-sets. Thus, we would only like to count the number of classes of K-sets, such that any two K-sets which belong to the same class are equivalent if they follow given conditions.Two K-sets X and Y are considered equivalent (and belong to the same class) if:</p>\n\n<pre><code>They contain the same number of points \nThere exists N integer numbers (t1, ..., tN) such that by translating each point of X  \n by the amount ti in dimension i (1\u2264i\u2264N) we obtain the set of points Y.\n</code></pre>\n\n<p>Let's consider N=2, K=4 and the following sets of points X={(1,2), (5,5), (4,3)} and Y={(2,5), (5,6), (6,8)}. Let's consider now the tuple (1,3). By translating each point of X by the amounts specified by this tuple we obtain the set {(2,5), (6,8), (5,6)}, which is exactly the set Y. Thus, the two sets X and Y are equivalent and belong to the same class.</p>\n\n<p>Example let say N=2 and K=1 .</p>\n\n<p>There are 9 classes of K-sets. One K-set from each class is given below:</p>\n\n<pre><code>{(0,0), (0,1)}\n{(0,0), (1,0)}\n{(0,0), (1,1)}\n{(0,1), (1,0)}\n{(0,0), (0,1), (1,0)}\n{(0,0), (0,1), (1,1)}\n{(0,0), (1,0), (1,1)}\n{(0,1), (1,0), (1,1)}\n{(0,0), (0,1), (1,0), (1,1)}\n</code></pre>\n\n<p>So answer here will be 9.</p>\n", 'ViewCount': '76', 'ClosedDate': '2014-02-12T09:15:23.047', 'Title': 'Number of K-sets', 'LastActivityDate': '2014-02-12T08:29:00.027', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12759', 'Tags': '<algorithms><computational-geometry><sets><number-theory>', 'CreationDate': '2014-01-11T15:36:25.203', 'Id': '19656'},19630:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There're a lot of examples of code for checking if a number is prime. Why don't people use Fermat's little theorem, i.e. this simple formula </p>\n\n<p>$\\qquad a^{p-1} \\equiv 1 \\pmod p$,</p>\n\n<p>to check if a number is prime?</p>\n", 'ViewCount': '65', 'Title': "Why don't people use Fermat's little theorem to check if number is prime?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:36:55.510', 'LastEditDate': '2014-01-19T15:30:11.473', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8659', 'Tags': '<discrete-mathematics><number-theory><primes>', 'CreationDate': '2014-01-19T13:48:30.600', 'Id': '19825'},19631:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I found an intersting problem. I have to compute <code>n! modulo p</code> and can't figure out a way of doing this. For small <code>n</code>s I can actually compute the factorial, but for large ones, <code>n!</code> doesn't fit a known type.</p>\n\n<p>So, my question is.. how can I compute <code>n! modulo p</code>?</p>\n\n<p><code>p</code> might be prime, but I can't remember the problem exactly.</p>\n", 'ViewCount': '32', 'ClosedDate': '2014-03-27T14:24:28.367', 'Title': 'Computing n! modulo p', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-27T14:22:28.643', 'LastEditDate': '2014-03-27T14:22:28.643', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16193', 'Tags': '<algorithms><number-theory><arithmetic>', 'CreationDate': '2014-03-27T12:49:15.957', 'Id': '23122'},19632:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '65', 'Title': 'Quick calculation for $(x^y) \\bmod z$', 'LastEditDate': '2014-03-30T11:10:13.400', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12905', 'FavoriteCount': '2', 'Body': '<p>What are the possible ways to calculate $(x^y) \\bmod z$ quickly for very large integers?\nIntegers $x,y \\lt 10^{10000}$ and $z \\lt 10^6$.</p>\n', 'Tags': '<integers><number-theory><arithmetic>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-31T02:12:44.727', 'CommentCount': '7', 'AcceptedAnswerId': '23257', 'CreationDate': '2014-03-30T10:50:29.727', 'Id': '23252'},19633:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to craft up a number made of 19 digits so that, after some mathematical operations made 11 times, the resulting sum of the remainders of the first ten operations is equal to the the remainder of the eleventh operation. The eleven calculations are as follows. I need to reverse them in order to be able to craft up the x.</p>\n\n<p>op_10 : (x / 256) mod 256 => This is the remainder that must be equal to the sum of the ten remainders below.</p>\n\n<p>op_0 : (x / 72057594037927936) mod 256 => 1st remainder</p>\n\n<p>op_1 : (x / 281474976710656) mod 256 => 2nd remainder</p>\n\n<p>op_2 : (x / 65536) mod 16 => 3rd remainder</p>\n\n<p>op_3 : (x / 1048576) mod 16 => 4th remainder</p>\n\n<p>op_4 : (x / 16777216) mod 16 => 5th remainder</p>\n\n<p>op_5 : (x / 268435456) mod 16 => 6th remainder</p>\n\n<p>op_6 : (x / 4294967296) mod 16 => 7th remainder</p>\n\n<p>op_7 : (x / 68719476736) mod 16 => 8th remainder</p>\n\n<p>op_8 : (x / 1099511627776) mod 16 => 9th remainder</p>\n\n<p>op_9 : (x / 17592186044416) mod 16 => 10th remainder</p>\n\n<p>Is there such an algorithm?\nx is the number i need to craft up.</p>\n', 'ViewCount': '39', 'Title': 'Reversing Key Algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-31T07:46:16.000', 'LastEditDate': '2014-03-31T07:46:16.000', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16290', 'Tags': '<algorithms><number-theory>', 'CreationDate': '2014-03-30T12:57:15.223', 'Id': '23256'},19634:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm writing an algorithm to solve a research problem involving searching for numbers on very large arrays.</p>\n\n<p>I encountered a sub-problem that requires me to break up sums of numbers which are power of 2, i.e. how to find combinations of these numbers that sum up to a certain value. The sum and the combination size are given. Also only 4 power of 2s can be present in a combination: <code>2,4,8,16</code>.</p>\n\n<p>Lets suppose I have a sum of <code>8</code> and I need to break up into a set of <code>3</code> numbers. The result would invariably be <code>[2,2,4]</code>.</p>\n\n<p>If I need to break up <code>20</code> into 3 power of 2s, I could have <code>[2,2,16]</code> or <code>[4,8,8]</code>.</p>\n\n<p>Naturally larger sets will result in many possible combinations.</p>\n\n<p>My aim is to write an algorithm that obtains all possible combinations as efficiently as possible. I'm not looking for the algorithm itself, but some leads into how to partition the number.\nWhat are some properties of power of 2s that I need to use to partition a sum into a possible combination?</p>\n", 'ViewCount': '77', 'LastEditorDisplayName': 'user16784', 'Title': 'Breaking up sum of power of 2s', 'LastActivityDate': '2014-04-15T18:19:50.530', 'LastEditDate': '2014-04-15T10:51:52.943', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user16784', 'PostTypeId': '1', 'Tags': '<algorithms><number-theory>', 'CreationDate': '2014-04-15T08:41:24.113', 'Id': '23806'}