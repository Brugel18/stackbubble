{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to understand what is wrong with the following proof of the following recurrence </p>\n\n<p>$$\r\nT(n) = 2\\,T\\!\\left(\\left\\lfloor\\frac{n}{2}\\right\\rfloor\\right)+n \r\n$$\n$$\r\nT(n) \\leq 2\\left(c\\left\\lfloor\\frac{n}{2}\\right\\rfloor\\right)+n \\leq cn+n = n(c+1) =O(n)\r\n$$</p>\n\n<p>The documentation says it's wrong because of the inductive hypothesis that\n$$\r\nT(n) \\leq cn\r\n$$\nWhat Am I missing?</p>\n", 'ViewCount': '418', 'Title': 'Error in the use of asymptotic notation', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-26T18:24:32.487', 'LastEditDate': '2012-03-26T18:24:32.487', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '777', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '736', 'Tags': '<algorithms><landau-notation><asymptotics><recurrence-relation>', 'CreationDate': '2012-03-25T21:16:46.657', 'Id': '772'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In algorithm analysis you often have to solve recurrences. In addition to Master Theorem, substitution and iteration methods, there is one using <em>characteristic polynomials</em>.</p>\n\n<p>Say I have concluded that a characteristic polynomial $x^2 - 2x + 2$ has <em>imaginary</em> roots, namely $x_1 = 1+i$ and $x_2 =1-i$. Then I cannot use</p>\n\n<p>$\\qquad c_1\\cdot x_1^n + c_2\\cdot x_2^n$</p>\n\n<p>to obtain the solution, right? How should I proceed in this case?</p>\n', 'ViewCount': '438', 'Title': 'Solving Recurrences via Characteristic Polynomial with Imaginary Roots', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-19T00:28:07.237', 'LastEditDate': '2012-04-01T07:20:09.083', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '852', 'Tags': '<algorithms><algorithm-analysis><recurrence-relation>', 'CreationDate': '2012-03-31T10:13:58.077', 'FavoriteCount': '1', 'Id': '915'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This is the recursive formula for which I\'m trying to find an asymptotic closed form by the <a href="http://en.wikipedia.org/wiki/Master_theorem" rel="nofollow">master theorem</a>:\n$$T(n)=9T(n/27)+(n \\cdot \\lg(n))^{1/2}$$</p>\n\n<p>I started with $a=9,b=27$ and $f(n)=(n\\cdot \\lg n)^{1/2}$  for using the master theorem by $n^{\\log_b(a)}$, and if so $n^{\\log_{27}(9)}=n^{2/3}$ but I don\'t understand how to play with the $(n\\cdot \\lg n)^{1/2}$. </p>\n\n<p>I think that the $(n\\cdot \\lg n)^{1/2}$ is bigger than $n^{2/3}$ but I\'m sure I skip here on something. </p>\n\n<p>I think it fits to the third case of the master theorem.</p>\n', 'ViewCount': '545', 'Title': 'Solve a recurrence using the master theorem', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:23:52.493', 'LastEditDate': '2013-02-02T13:23:52.493', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1297', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '747', 'Tags': '<algorithm-analysis><asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2012-04-16T01:19:14.927', 'Id': '1296'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I applied the Master theorem to a recurrence for a running time I encountered (this is a simplified version):</p>\n\n<p>$$T(n)=4T(n/2)+O(r)$$</p>\n\n<p>$r$ is independent of $n$. Case 1 of the Master theorem applies and tells us that $T(n)=O(n^2)$.</p>\n\n<p>However, this hides a constant dependent on $r$ in the big-oh notation: our recurrence has depth $O(\\log_2 n)$ so at the final level we have $O(4^{\\log_2 n})=O(n^2)$ subproblems, each of which takes $O(r)$ time to be handled. This means the actual running time is $O(n^2 r)$ (or worse: this analysis only talks about the lowest level).</p>\n\n<p>This is my actual recursion:</p>\n\n<p>$$T(n)=r^2T(n/r)+O(nr^2)$$</p>\n\n<p>Is there a method similar to the Master theorem for these kinds of recursions?</p>\n', 'ViewCount': '227', 'Title': 'Master theorem and constants independent of $n$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:24:14.520', 'LastEditDate': '2013-02-02T13:24:14.520', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<algorithm-analysis><asymptotics><recurrence-relation><mathematical-analysis><master-theorem>', 'CreationDate': '2012-04-29T17:39:46.100', 'FavoriteCount': '2', 'Id': '1576'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to find a $\\Theta$ bound for the following recurrence equation:</p>\n\n<p>$$ T(n) = 2 T(n/2) + T(n/3) + 2n^2+ 5n + 42 $$ </p>\n\n<p>I figure Master Theorem is inappropriate due to differing amount of subproblems and divisions. Also recursion trees do not work since there is no $T(1)$ or rather $T(0)$. </p>\n', 'ViewCount': '536', 'Title': 'Solving Recurrence Equations containing two Recursion Calls', 'LastEditorUserId': '8246', 'LastActivityDate': '2013-09-28T12:36:36.840', 'LastEditDate': '2013-09-28T12:36:36.840', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1382', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2012-05-05T23:47:48.517', 'FavoriteCount': '1', 'Id': '1682'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '990', 'Title': 'Master theorem not applicable?', 'LastEditDate': '2013-02-02T13:24:28.657', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1561', 'FavoriteCount': '1', 'Body': '<p>Given the following recursive equation</p>\n\n<p>$$ T(n) = 2T\\left(\\frac{n}{2}\\right)+n\\log n$$ we want to apply the Master theorem and note that</p>\n\n<p>$$ n^{\\log_2(2)} = n.$$</p>\n\n<p>Now we check the first two cases for $\\varepsilon &gt; 0$, that is whether</p>\n\n<ul>\n<li>$n\\log n \\in O(n^{1-\\varepsilon})$ or</li>\n<li>$n\\log n \\in \\Theta(n)$.</li>\n</ul>\n\n<p>The two cases are not satisfied. So we have to check the third case, that is whether</p>\n\n<ul>\n<li>$n\\log n \\in \\Omega(n^{1+\\varepsilon})$ .</li>\n</ul>\n\n<p>I think the third condition is not satisfied either. But why? And what would be a good explanation for why the Master theorem cannot be applied in this case?</p>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><master-theorem>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-24T09:34:21.943', 'CommentCount': '5', 'AcceptedAnswerId': '2388', 'CreationDate': '2012-05-20T20:45:35.817', 'Id': '1957'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>As follows <a href="http://cs.stackexchange.com/questions/1828/polytime-and-polyspace-algorithm-for-determining-the-leading-intersection-of-n-d">from my previous question</a>, I\'ve been playing with the <a href="http://en.wikipedia.org/wiki/Riemann_hypothesis">Riemann hypothesis</a> as a matter of recreational mathematics. In the process, I\'ve come to a rather interesting recurrence, and I\'m curious as to its name, its reductions, and its tractability towards the solvability of the gap between prime numbers.</p>\n\n<p>Tersely speaking, we can define the <em>gap</em> between each prime number as a recurrence of preceding <em>candidate</em> primes. For example, for our base of $p_0 = 2$, the next prime would be:</p>\n\n<p>$\\qquad \\displaystyle p_1 = \\min \\{ x &gt; p_0 \\mid -\\cos(2\\pi(x+1)/p_0) + 1 = 0)  \\}$</p>\n\n<p>Or, as we see by <a href="http://m.wolframalpha.com/input/?i=-cos%28%28x%2b1%29%2a2%2api/2%29%20%2b%201%20=%200">plotting this out</a>: $p_1 = 3$.</p>\n\n<p>We can repeat the process for $n$ primes by evaluating each candidate prime recurring forward. Suppose we want to get the next prime, $p_2$. Our candidate function becomes:</p>\n\n<p>$\\qquad \\displaystyle \\begin{align}\np_2 = \\min\\{ x &gt; p_1 \\mid f_{p_1}(x) + (&amp;(-\\cos(2\\pi(x+1)/p_1) + 1) \\\\\n                                   \\cdot &amp;(-\\cos(2\\pi(x+2)/p_1) + 1)) = 0\\}\n\\end{align}$</p>\n\n<p>Where:</p>\n\n<p>$\\qquad \\displaystyle f_{p_1}(x) = -\\cos(2\\pi(x+1)/p_0) + 1$, as above.</p>\n\n<p>It\'s easy to see that each component function only becomes zero on integer values, and it\'s equally easy to show how this captures our AND- and XOR-shaped relationships cleverly, by exploiting the properties of addition and multiplication in the context of a system of trigonometric equations.</p>\n\n<p>The recurrence becomes:</p>\n\n<p>$\\qquad f_{p_0} = 0\\\\\n\\qquad p_0 = 2\\\\\n\\qquad \\displaystyle\n  f_{p_n}(x) = f_{p_{n-1}}(x) + \\prod_{k=2}^{p_{n-1}} (-\\cos(2\\pi(x+k-1)/p_{n-1}) + 1)\\\\\n \\qquad \\displaystyle\n p_n = \\min\\left\\{ x &gt; p_{n-1} \\mid f_{p_n}(x) = 0\\right\\}$</p>\n\n<p>... where the entire problem hinges on whether we can evaluate the $\\min$ operator over this function in polynomial time. This is, in effect, a generalization of the <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">Sieve of Eratosthenes</a>.</p>\n\n<p>Working Python code to demonstrate the recurrence:</p>\n\n<pre><code>from math import cos,pi\n\ndef cosProduct(x,p):\n    """ Handles the cosine product in a handy single function """\n    ret = 1.0\n    for k in xrange(2,p+1):\n        ret *= -cos(2*pi*(x+k-1)/p)+1.0\n    return ret\n\ndef nthPrime(n):\n    """ Generates the nth prime, where n is a zero-based integer """\n\n    # Preconditions: n must be an integer greater than -1\n    if not isinstance(n,int) or n &lt; 0:\n        raise ValueError("n must be an integer greater than -1")\n\n    # Base case: the 0th prime is 2, 0th function vacuous\n    if n == 0:\n        return 2,lambda x: 0\n\n    # Get the preceding evaluation\n    p_nMinusOne,fn_nMinusOne = nthPrime(n-1)\n\n    # Define the function for the Nth prime\n    fn_n = lambda x: fn_nMinusOne(x) + cosProduct(x,p_nMinusOne)\n\n    # Evaluate it (I need a solver here if it\'s tractable!)\n    for k in xrange(p_nMinusOne+1,int(p_nMinusOne**2.718281828)):\n        if fn_n(k) == 0:\n            p_n = k\n            break\n\n    # Return the Nth prime and its function\n    return p_n,fn_n\n</code></pre>\n\n<p>A quick example:</p>\n\n<pre><code>&gt;&gt;&gt; [nthPrime(i)[0] for i in range(20)]\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]\n</code></pre>\n\n<p>The trouble is, I\'m now in way over my head, both mathematically and as a computer scientist. Specifically, I am not competent with <a href="http://en.wikipedia.org/wiki/Fourier_analysis">Fourier analysis</a>, with defining <a href="http://en.wikipedia.org/wiki/Uniform_space#Uniform_cover_definition">uniform covers</a>, or with the <a href="http://en.wikipedia.org/wiki/Complex_plane">complex plane</a> in general, and I\'m worried that this approach is either flat-out <em>wrong</em> or hides a lurking horror of a 3SAT problem that elevates it to NP-completeness.</p>\n\n<p>Thus, I have three questions here:</p>\n\n<blockquote>\n  <ol>\n  <li>Given my terse recurrence above, is it possible to deterministically compute or estimate the location of the zeroes in polynomial time and space?</li>\n  <li>If so or if not, is it hiding <em>any other</em> subproblems that would make a polytime or polyspace solution intractable?</li>\n  <li>And if by some miracle (1) and (2) hold up, what dynamic programming improvements would you make in satisfying this recurrence, from a high level? Clearly, iteration over the same integers through multiple functions is inelegant and quite wasteful.</li>\n  </ol>\n</blockquote>\n', 'ViewCount': '333', 'Title': 'Proving the (in)tractability of this Nth prime recurrence', 'LastEditorUserId': '958', 'LastActivityDate': '2012-05-24T08:38:32.067', 'LastEditDate': '2012-05-24T08:38:32.067', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '958', 'Tags': '<complexity-theory><reference-request><recurrence-relation><mathematical-analysis>', 'CreationDate': '2012-05-22T00:50:48.443', 'FavoriteCount': '3', 'Id': '1984'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '147', 'Title': 'Finding lambda of Master Theorem', 'LastEditDate': '2013-02-02T13:23:30.387', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'Luc Peetersen', 'PostTypeId': '1', 'OwnerUserId': '1722', 'FavoriteCount': '1', 'Body': '<p>Suppose I have a recurrence like $T(n)=2T(n/4)+\\log(n)$ with $a=2, b=4$ and $f(n)=\\log(n)$.</p>\n\n<p>That should be <a href="http://en.wikipedia.org/wiki/Master_theorem#Case_1" rel="nofollow">case 1 of the Master theorem</a> because $n^{1/2}&gt;\\log(n)$. There is also a lambda in case 1: $f(n)=O(n^{(1/2)-\\lambda})$. Is this correct? And how can I find this lambda?</p>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><master-theorem>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:23:30.387', 'CommentCount': '1', 'AcceptedAnswerId': '2195', 'CreationDate': '2012-06-01T21:00:09.973', 'Id': '2192'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $f$ and $g$ be two functions and $p$ a number. Consider the following program:</p>\n\n<pre><code>Recurs(v,p) :\n  find s &lt; v such that f(s,v) &lt; v/2 and g(s,v-s) &lt; p\n\n  if no such s exists then\n    return v\n  else if s &lt;= v/4 then \n    return v-s U Recurs(s,p)\n  else if s &gt; v/4 then \n    return Recurs(s,p) U Recurs(v-s,p)\nend\n</code></pre>\n\n<p>Can the recurrence for the running time of this recursion be $T(v)=T\\left(\\frac{v}{4}\\right)+T\\left(\\frac{3v}{4}\\right)+1$?</p>\n', 'ViewCount': '154', 'Title': "Is the following recurrence for this program's runtime correct?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-11T14:11:29.740', 'LastEditDate': '2012-06-11T10:38:39.823', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '3', 'OwnerDisplayName': 'raarava', 'PostTypeId': '1', 'OwnerUserId': '1818', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><recurrence-relation>', 'CreationDate': '2012-06-04T03:17:56.457', 'Id': '2295'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I know the answer <em>without</em> nesting limit is the Catalan number. My question is, specifically, is there a recurrence relation that gives the number of expression containing $n$ pairs of matching brackets such that no more than $l$ open brackets are not closed at any given point?</p>\n\n<p>For instance, for $n=3$ and $l=2$ the answer is $4$. All possible combinations are $(())()$, $()(())$, $()()()$, $(()())$. We cannot have $((()))$ since there are three open brackets that are not closed at the middle.</p>\n', 'ViewCount': '182', 'Title': 'What is the number of expressions containing n pairs of matching brackets with nesting limit?', 'LastEditorUserId': '1718', 'LastActivityDate': '2013-01-02T14:13:08.157', 'LastEditDate': '2012-06-28T19:07:37.053', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<formal-languages><combinatorics><recurrence-relation><word-combinatorics>', 'CreationDate': '2012-06-28T17:42:20.740', 'Id': '2532'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Suppose we are given a list of $n$ points, whose $x$ and $y$ coordinates are all non-negative. Suppose also that there are no duplicate points. We can only go from point $(x_i, y_i)$ to point $(x_j, y_j)$ if $x_i \\le x_j$ and $y_i \\le y_j$. The question is: given these $n$ points, what is the maximum number of points that we can reach if we are allowed to draw two paths that connect points using the above rule? Paths must start from the origin and may contain repeated points. $(0, 0)$ is of course not included in the points reached.</p>\n\n<p>An example: given $(2, 0), (2, 1), (1, 2), (0, 3), (1, 3), (2, 3), (3, 3), (2, 4), (1, 5), (1, 6)$, the answer is $8$ since we can take $(0, 0) \\rightarrow (2, 0) \\rightarrow (2, 1) \\rightarrow (2, 3) \\rightarrow (2, 4)$ and $(0, 0) \\rightarrow (1, 2) \\rightarrow (1, 3) \\rightarrow (1, 5) \\rightarrow (1, 6)$.</p>\n\n<p>If we are allowed to draw only one path, I can easily solve the question by dynamic programming that runs in $O(n^2)$. I first sort the points by decreasing $x_i+y_i$. Let $D[i]$ be the maximum number of coins that one can pick up from coins $1$ to $i$ in the sorted list. Then $D[1] = 1$ and $D[i] = \\max\\limits_{1\\le j &lt; i, x_j \\le x_i, y_j \\le y_i} D[j] + 1$. The answer then is just $\\max\\limits_{1\\le i \\le n} D[i] + 1$.</p>\n\n<p>But I cannot come up with a recurrence relation for two paths. If anyone has any idea about such a recurrence relation, I would be happy to hear what they are.</p>\n', 'ViewCount': '199', 'Title': 'Maximum number of points that two paths can reach', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-02T14:30:00.137', 'LastEditDate': '2012-06-30T17:40:21.150', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '2562', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<computational-geometry><dynamic-programming><recurrence-relation>', 'CreationDate': '2012-06-29T23:42:31.997', 'Id': '2553'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've been tasked with solving some recurrence relations, and I've been running into trouble with so called 'chip &amp; conquer' relations.</p>\n\n<p>Here are some example problems:</p>\n\n<p>$$T(n) = T(n-5) + cn^2$$</p>\n\n<p>and</p>\n\n<p>$$T(n) = T(n-2) + \\log{n}$$</p>\n\n<p>I'm supposed to be giving an answer in $\\Theta$ notation. How do I go around and solving relations like these?</p>\n", 'ViewCount': '302', 'Title': "Solving Recurrence Relations 'Chip & Conquer'", 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T05:57:56.653', 'LastEditDate': '2012-07-17T05:57:56.653', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'OwnerDisplayName': 'user906153', 'PostTypeId': '1', 'Tags': '<asymptotics><recurrence-relation><mathematical-analysis>', 'CreationDate': '2012-04-25T02:16:52.133', 'Id': '2671'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In computer science, we have often have to solve <a href="http://en.wikipedia.org/wiki/Recurrence_relation">recurrence relations</a>, that is find a <strong>closed form</strong> for a recursively defined sequence of numbers. When considering runtimes, we are often interested mainly in the sequence\'s <a href="http://en.wikipedia.org/wiki/Asymptotic_analysis"><strong>asymptotic</strong> growth</a>.</p>\n\n<p>Examples are </p>\n\n<ol>\n<li><p>The runtime of a tail-recursive function stepping downwards to $0$ from $n$ whose body takes time $f(n)$:</p>\n\n<p>$\\qquad \\begin{align}\n  T(0) &amp;= 0 \\\\\n  T(n+1) &amp;= T(n) + f(n)    \n \\end{align}$</p></li>\n<li><p>The <a href="http://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci sequence</a>:</p>\n\n<p>$\\qquad \\begin{align}\n  F_0 &amp;= 0 \\\\\n  F_1 &amp;= 1 \\\\\n  F_{n+2} &amp;= F_n + F_{n+1}    \n \\end{align}$</p></li>\n<li><p>The number of <a href="http://en.wikipedia.org/wiki/Dyck_language">Dyck words</a> with $n$ parenthesis pairs:</p>\n\n<p>$\\qquad\\begin{align}\n    C_0 &amp;= 1 \\\\ \n    C_{n+1}&amp;=\\sum_{i=0}^{n}C_i\\,C_{n-i}\n  \\end{align}$</p></li>\n<li><p>The mergesort runtime recurrence on lists of length $n$:</p>\n\n<p>$\\qquad \\begin{align}\n  T(1) &amp;= T(0) = 0 \\\\\n  T(n) &amp;= T(\\lfloor n/2\\rfloor) + T(\\lceil n/2\\rceil) + n-1\n \\end{align}$</p></li>\n</ol>\n\n<p>What are methods to solve recurrence relations? We are looking for</p>\n\n<ul>\n<li>general methods and</li>\n<li>methods for a significant subclass</li>\n</ul>\n\n<p>as well as</p>\n\n<ul>\n<li>methods that yield precise solutions and</li>\n<li>methods that provide (bounds on) asymptotic growth.</li>\n</ul>\n\n<p><sup>This is supposed to become a reference question. Please post one answer per method and provide a general description as well as an illustrative example.</sup></p>\n', 'ViewCount': '1536', 'Title': 'Solving or approximating recurrence relations for sequences of numbers', 'LastEditorUserId': '6716', 'LastActivityDate': '2014-04-24T15:41:56.573', 'LastEditDate': '2013-06-06T16:02:38.220', 'AnswerCount': '8', 'CommentCount': '1', 'Score': '27', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><proof-techniques><combinatorics><recurrence-relation><reference-question>', 'CreationDate': '2012-07-17T18:31:38.607', 'FavoriteCount': '27', 'Id': '2789'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have trouble understanding how to calculate the depth of a sorting network on $n$ inputs.</p>\n\n<p>For example, in case of selection sort, we have:</p>\n\n<p>$\\qquad \\displaystyle D(n)=D(n-1)+2\\\\\\qquad D(2)=1$</p>\n\n<p>which leads to</p>\n\n<p>$\\qquad \\displaystyle D(n)=2n-3=\\Theta(n)$</p>\n\n<p>I have confirmed that the depth of selection sort is equal to $2n-3$ by hand, but I can't understand how the recurrence $D(n)=D(n-1)+2$ is derived.</p>\n", 'ViewCount': '292', 'Title': 'How to calculate the depth of sorting networks?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-03T04:32:08.207', 'LastEditDate': '2012-07-30T07:08:14.057', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'Steven', 'PostTypeId': '1', 'Tags': '<algorithms><algorithm-analysis><recurrence-relation><sorting>', 'CreationDate': '2012-07-29T11:18:33.773', 'FavoriteCount': '1', 'Id': '2950'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '461', 'Title': 'Solving the recurrence relation $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$', 'LastEditDate': '2012-07-31T20:30:24.733', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': '<p>Solving the recurrence relation $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$.<br>\nThe book from which this example is, falsely claims that $T(n) = O(n)$ by guessing $T(n) \\leq cn$ and then arguing  </p>\n\n<p>$\\qquad \\begin{align*} T(n) &amp; \\leq 2(c \\lfloor n/2 \\rfloor ) + n \\\\ &amp;\\leq cn +n \\\\ &amp;=O(n) \\quad \\quad \\quad \\longleftarrow \\text{ wrong!!} \\end{align*}$  </p>\n\n<p>since $c$ is constant.The error is that we have not proved the <em>exact</em> form of the inductive hypothesis.</p>\n\n<p>Above I have exactly quoted what the book says. Now my question is why cannot we write $cn+n=dn$ where $d=c+1$ and now we have $T(n) \\leq dn$ and hence $T(n) = O(n)$?</p>\n\n<p>Note: </p>\n\n<ol>\n<li>The correct answer is $T(n) =O(n \\log n).$  </li>\n<li>The book I am referring here is <em>Introduction to algorithms</em> by Cormen et al., page 86, 3rd edition.</li>\n</ol>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><landau-notation><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-01T07:09:01.457', 'CommentCount': '1', 'AcceptedAnswerId': '2972', 'CreationDate': '2012-07-31T18:15:32.510', 'Id': '2971'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '202', 'Title': 'How to compute linear recurrence using matrix with fraction coefficients?', 'LastEditDate': '2012-08-09T21:16:25.387', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '991', 'FavoriteCount': '1', 'Body': '<p>What I\'m trying to do is generate <a href="http://en.wikipedia.org/wiki/Motzkin_number" rel="nofollow">Motzkin numbers</a> mod a large number $10^{14} + 7$ (not prime), and it needs to compute the $n$th Motzkin number as fast as possible. From Wikipedia, the formula for the $n$th Motzkin number is defined as following:</p>\n\n<p>$\\qquad \\displaystyle \\begin{align}\n  M_{n+1} &amp;= M_n + \\sum_{i=0}^{n-1} M_iM_{n-1-i} \\\\\n          &amp;= \\frac{2n+3}{n+3}M_n + \\frac{3n}{n+3}M_{n-1}\n\\end{align}$ </p>\n\n<p>My initial approach is to use the second formula which is obviously faster, but the problem I ran into is the division since modular arithmetic rule doesn\'t apply.</p>\n\n<pre><code>void generate_motzkin_numbers() {\n    motzkin[0] = 1;\n    motzkin[1] = 1;\n    ull m0 = 1;\n    ull m1 = 1;\n    ull numerator;\n    ull denominator;\n    for (int i = 2; i &lt;= MAX_NUMBERS; ++i) {\n        numerator = (((2*i + 1)*m1 + 3*(i - 1)*m0)) % MODULO;\n        denominator = (i + 2);\n        motzkin[i] = numerator/denominator;\n        m0 = m1;\n        m1 = motzkin[i];\n    }\n}\n</code></pre>\n\n<p>Then I tried the second formula, but the running time is horribly slow because the summation:</p>\n\n<pre><code>void generate_motzkin_numbers_nested_recurrence() {\n    mm[0] = 1;\n    mm[1] = 1;\n    mm[2] = 2;\n    mm[3] = 4;\n    mm[4] = 9;\n    ull result;\n    for (int i = 5; i &lt;= MAX_NUMBERS; ++i) {\n        result = mm[i - 1];\n        for (int k = 0; k &lt;= (i - 2); ++k) {\n            result = (result + ((mm[k] * mm[i - 2 - k]) % MODULO)) % MODULO;\n        }\n        mm[i] = result;\n    }\n}\n</code></pre>\n\n<p>Next, I\'m thinking of using matrix form which eventually can be speed up using exponentiation squaring technique, in other words $M_{n+1}$ can be computed as follows:\n$$M_{n+1} = \\begin{bmatrix} \\dfrac{2n+3}{n+3} &amp; \\dfrac{3n}{n+3} \\\\ 1 &amp; 0\\end{bmatrix}^n \\cdot \\begin{bmatrix} 1 \\\\ 1\\end{bmatrix}$$ \nWith exponentiation by squaring, this method running time is $O(\\log(n))$ which I guess the fastest way possible, where <code>MAX_NUMBERS = 10,000</code>. Unfortunately, again the division with modular is killing me. After apply the modulo to the numerator, the division is no longer accurate. So my question is, is there another technique to compute this recurrence modulo a number? I\'m think of a dynamic programming approach for the summation, but I still think it\'s not as fast as this method.  Any ideas or suggestions would be greatly appreciated. </p>\n', 'Tags': '<algorithms><recurrence-relation><efficiency><integers>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-10T13:32:37.340', 'CommentCount': '6', 'AcceptedAnswerId': '3116', 'CreationDate': '2012-08-09T19:06:02.450', 'Id': '3109'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am currently working my way through <a href="http://aofa.cs.princeton.edu/home/" rel="nofollow">An Introduction to Analysis of Algorithms</a> to stay sharp with recurrences as well as learn generating function techniques. However my analyses and the books analyses for the first few sample problems on ordinary generating functions differ. I\'ve checked and rechecked [my work as well as errata on the webpage], but cannot see how the authors made certain leaps. For example:</p>\n\n<p>Given the recurrence $a_{n} = a_{n-1} + 1$ for $n \\geq 1$ with $a_0 = 0$ and letting $A(z) = \\sum_{n \\geq 0} a_n z^n$ I have the following steps:\n$$ \\begin{align*}\n\\sum_{n \\geq 1} a_n z^n &amp;= \\sum_{n \\geq 1} a_{n-1} z^n + \\sum_{n \\geq 1} z^n \\\\\nA(z) - a_0&amp;= zA(z) + \\frac{z}{1-z} \\\\\nA(z)(1 - z) &amp;= \\frac{z}{1-z} + a_0\\\\\nA(z) &amp;=\\frac{z}{(1-z)^2} + \\frac{a_0}{1-z}\n\\end{align*}$$</p>\n\n<p>Since $a_0 = 0$ we just end up with $$A(z) = \\frac{z}{(1-z)^2} \\\\ a_n = n$$.</p>\n\n<p>However, the authors\' derivation is the following:\n$$ \\begin{align*}\n\\sum_{n \\geq 1} a_n z^n &amp;= \\sum_{n \\geq 1} a_{n-1} z^n + \\frac{1}{1-z} \\\\\nA(z) - 1 &amp;= zA(z) + \\frac{1}{1-z} \\\\\nA(z) &amp;= \\frac{z}{(1-z)^2} \\\\\na_n &amp;= n\\\\\n\\end{align*}$$\nAm I crazy, how did they get $A(z) - 1$ in the 2nd step? They do the exact same thing in the next example for $a_n = 2a_{n-1} + 1$. Is this just a typo? I would expect them to subtract $a_0z^0 = a_0$. Where did that $-1$ come from?</p>\n', 'ViewCount': '100', 'Title': 'Error in Generating Function Solution', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-30T22:19:21.597', 'LastEditDate': '2012-08-29T00:18:51.577', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '3376', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '19', 'Tags': '<recurrence-relation><mathematical-analysis><check-my-proof>', 'CreationDate': '2012-08-28T20:47:04.473', 'Id': '3355'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>what is the complexity of below relation</p>\n\n<p>$ T(n) = 2*T(\\sqrt n) + \\log n$</p>\n\n<p>and $T(2) = 1$</p>\n\n<p>Is it $\\Theta (\\log n * \\log \\log n)$ ?</p>\n', 'ViewCount': '213', 'Title': 'what is the complexity of recurrence relation?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-25T17:33:28.563', 'LastEditDate': '2012-08-30T04:58:10.133', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '3363', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2667', 'Tags': '<asymptotics><recurrence-relation><mathematical-analysis>', 'CreationDate': '2012-08-29T11:06:38.823', 'Id': '3362'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '862', 'Title': 'Changing variables in recurrence relations', 'LastEditDate': '2012-09-09T23:16:22.610', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'goooser', 'PostTypeId': '1', 'OwnerUserId': '2768', 'FavoriteCount': '1', 'Body': '<p>Currently, I am self-studying Intro to Algorithms (CLRS) and there is one particular method they outline in the book to solve recurrence relations. </p>\n\n<p>The following method can be illustrated with this example. Suppose we have the recurrence</p>\n\n<p>$$T(n) = 2T(\\sqrt n) + \\log n$$</p>\n\n<p>Initially they make the substitution m = lg(n), and then plug it back in to the recurrence and get:</p>\n\n<p>$$T(2^m) = 2T(2^{\\frac{m}{2}}) + m$$</p>\n\n<p>Up to this point I understand perfectly. This next step is the one that\'s confusing to me.</p>\n\n<p>They now "rename" the recurrence $S(m)$ and let $S(m) = T(2^m)$, which apparently produces</p>\n\n<p>$$S(m) = 2S(m/2) + m$$</p>\n\n<p>For some reason it\'s not clear to me why this renaming works, and it just seems like cheating. Can anyone explain this better? </p>\n', 'Tags': '<asymptotics><recurrence-relation><mathematical-analysis><landau-notation>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-09T23:16:22.610', 'CommentCount': '0', 'CreationDate': '2012-09-09T20:03:08.237', 'Id': '3482'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '620', 'Title': 'Solving $T(n)= 3T(\\frac{n}{4}) + n\\cdot \\lg(n)$ using the master theorem', 'LastEditDate': '2013-09-28T12:36:33.403', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1758', 'FavoriteCount': '1', 'Body': '<p><em>Introduction to Algorithms</em>, 3rd edition (p.95) has an example of how to solve the recurrence</p>\n\n<p>$$\\displaystyle T(n)= 3T\\left(\\frac{n}{4}\\right) + n\\cdot \\log(n)$$</p>\n\n<p>by applying the Master Theorem.</p>\n\n<p>I am very confused by how it is done. So, $a=3, b=4, f(n) = n\\cdot \\log(n)$<br>\nFirst step is to compare $n^{\\log_b a} = n^{\\log_4 3}= O(n^{0.793})$ with $f(n)$.</p>\n\n<p>I have no clue on how they compared this. The book explains: </p>\n\n<blockquote>\n  <p>$f(n) = \\Omega (n^{\\log_4 3+\\epsilon })$, where $\\epsilon \\approx 0.2$, case 3 applies if we can show that the regularity condition holds for $f(n).$ </p>\n</blockquote>\n\n<p>Followed by: </p>\n\n<blockquote>\n  <p>For sufficiently large n, we have that: $af\\left(\\frac{n}{b}\\right) = 3\\left(\\frac{n}{4}\\right)\\log\\left(\\frac{n}{5}\\right) \\le\\left(\\frac{3}{4}\\right)n \\log n = cf(n)~ for~ c=\\frac{3}{4}.$</p>\n</blockquote>\n\n<p>Where did $3\\left(\\frac{n}{4}\\right)$ come from?</p>\n', 'Tags': '<asymptotics><recurrence-relation><landau-notation><mathematical-analysis><master-theorem>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-28T12:36:33.403', 'CommentCount': '0', 'AcceptedAnswerId': '3505', 'CreationDate': '2012-09-11T03:32:38.143', 'Id': '3504'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m confused to conclude the recursion tree method a guess for the next recurrence:\n$$T(n)=3T\\left (\\left\\lfloor \\frac{n}{2}\\right \\rfloor\\right) +n$$\nI write some costs for the levels of tree, you can see, but I\'m confusing in the final guess. I know for the master theorem that the answer for the guess is like that \n$$\\Theta(n^{\\log_2 3}) $$ but in the steps by tree and I don\'t belive, you can see my error (?). How can I finished or know the outcome for this method to calculate $T(n)$? \nthanks,\n<img src="http://i.stack.imgur.com/T7vlE.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/V00qK.png" alt="Recursion Tree by the my problem">\nAnd the final conclusion is (?)\n$$=2 n^{\\log_2 3}+\\Theta(n^{\\log_2 3})\\leq cn^{\\log_2 3} \\rightarrow \\ \\ T(n)\\in\\Theta(n^{\\log_2 3})$$ with $c=3$ ?</p>\n', 'ViewCount': '124', 'Title': 'Doubt with a problem of grown functions and recursion tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-22T15:42:55.307', 'LastEditDate': '2012-09-17T17:48:41.503', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1152', 'Tags': '<algorithms><asymptotics><runtime-analysis><recurrence-relation>', 'CreationDate': '2012-09-17T02:09:19.717', 'Id': '4583'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '66', 'Title': 'Computing the running time of a divide-by-4-and-conquer algorithm', 'LastEditDate': '2012-09-18T22:12:40.627', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1152', 'FavoriteCount': '1', 'Body': "<p>I write this code in python:</p>\n\n<pre><code>def sub(ma):\n    n = len(ma); m = len(ma[0])\n    if n != m : return\n    n2 = int(ceil(n/2))\n    a = []; b = []; c = []; d = [] \n    for i in range(n2):\n        a.append(ma[i][0:n2])\n        b.append(ma[i][n2:n])\n        c.append(ma[n2+i][0:n2])\n        d.append(ma[n2+i][n2:n])\n    return [a,b,c,d] \n\ndef sum(ma):\n        if len(ma) == 1 : return ma[0][0]\n        div = sub(ma)       \n        return sum(div[0])+sum(div[1])+sum(div[2])+sum(div[3]) \n</code></pre>\n\n<p>Do you know what is a possibly recurrence equation $T(n)$ to the 'sum' method? \nI suppose that is like that\n$$T(n) = 4T(n/2) + f(n)$$\nwhat it is $f(n)$ ?\nThanks, </p>\n", 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><recurrence-relation>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-18T22:12:40.627', 'CommentCount': '0', 'AcceptedAnswerId': '4586', 'CreationDate': '2012-09-17T06:29:26.353', 'Id': '4584'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Substation method fails to prove that $T(n)=\\Theta(n^2) $ for the recursion $T(n)=4T(n/2) + n^2$, since you end up with $T(n) &lt; cn^2 \\leq cn^2 + n^2$.</p>\n\n<p>I don't understand how to subtract off lower-order term to prove that substitution works.  </p>\n\n<p>Came up with: $T(n) \\leq cn^2 - bn^2$</p>\n\n<p>Assume it holds for $T(n/2) \\leq c(n/2)^2 - b(n/2)^2$  </p>\n\n<p>$T(n) \\leq 4(c(n/2)^2 - b(n/2)^2) + n^2 = cn^2- bn^2 + n^2 $ </p>\n\n<p>However, there is no way to solve $cn^2- bn^2 + n^2 \\leq cn^2 - bn^2 $ for $b$</p>\n", 'ViewCount': '455', 'Title': 'Subtracting lower-order term to prove subtitution method works', 'LastEditorUserId': '2499', 'LastActivityDate': '2012-09-26T03:13:49.490', 'LastEditDate': '2012-09-19T12:00:43.927', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '4733', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1758', 'Tags': '<asymptotics><recurrence-relation><landau-notation>', 'CreationDate': '2012-09-19T07:43:01.930', 'Id': '4612'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m going through the MIT Online Course Videos on Intro. to Algorithms at <a href="http://video.google.com/videoplay?docid=-3860843648161712896" rel="nofollow">here</a> at around 38:00.</p>\n\n<p>So we have a recursion formula</p>\n\n<p>$\\qquad T(n) = T(n/10) + T(9n/10) + O(n)$</p>\n\n<p>If we build a recursion tree it looks like </p>\n\n<pre><code>                   T(n)                     -- Level 1       = c*n\n             /               \\\n       T(n/10)             T(9n/10)         -- Level 2       = c*n\n        /   \\             /         \\\n T(n/100)  T(9n/100) T(9n/100)  T(81n/100)  -- Level 3       = c*n\n\n   /                                  \\                      &lt;= c*n\n    .                                .\n    .                                .\n 0(1)                                 0(1)\n</code></pre>\n\n<p>where $c$ is a constant larger than $0$.</p>\n\n<p>Shortest path from the root to the leaf is $\\log_{10}(n)$.</p>\n\n<p>Longest path from the root to the leaf is $\\log_{10/9}(n)$</p>\n\n<p>Therefore, the cost could be calculated as Cost = Cost of each level * number of levels.</p>\n\n<p>With the shortest path cost, we get a lower bound of $cn\\log_{10}(n)$, and with the  longest path cost an upper bound of  $cn\\log_{10/9}(n)$.</p>\n\n<p>And now I have to add the costs of leaf nodes, which leads to my problem. In the video it says the total number of leaves is in $\\Theta(n)$. I have trouble figuring out how he got to $\\Theta(n)$.</p>\n\n<p>The video further says $T(n)$ is bounded by</p>\n\n<p>$\\qquad cn\\log_{10}(n) + O(n) \\leq T(n) \\leq cn\\log_{10/9}(n) + O(n)$</p>\n\n<p>Wouldn\'t it make more sense to say it\'s </p>\n\n<p>$\\qquad cn\\log_{10}(n) + O(n^{\\log_{10}(2)}) \\leq T(n) \\leq cn\\log_{10/9}(n) + O(n^{\\log_{10/9}(2)})$</p>\n\n<p>where $\\Theta(n^{log_{10}(2)})$ represents the leaves on the left and $\\Theta(n^{\\log_{10/9}(2)})$ represents the leaves on the right.</p>\n\n<p>Or is there a way to simplify these terms to $\\Theta(n)$? </p>\n', 'ViewCount': '381', 'Title': 'Finding the number of leaves in a imbalanced recursion tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-21T21:08:01.437', 'LastEditDate': '2012-09-21T21:05:43.703', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '4657', 'Score': '1', 'OwnerDisplayName': 'user1671022', 'PostTypeId': '1', 'Tags': '<algorithm-analysis><asymptotics><recurrence-relation>', 'CreationDate': '2012-09-14T10:17:19.653', 'Id': '4656'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I face a problem with computing a complexity. \nI have this equality : $P(u) = (\\sqrt{u}+1)P(\\sqrt{u}) + \\theta(\\sqrt{u})$</p>\n\n<p>And I want to prove that $P(u) = O(u)$</p>\n\n<p>This is how I process :</p>\n\n<p>I put $m = \\lg\\lg u \\implies P(u) = P(2^{2^{m}}) = (2^{2^{m-1}}+1)P(2^{2^{m-1}}) + \\theta(2^{2^{m-1}})$</p>\n\n<p>Now, I consider $S(m)$ that is : $S(m) = P(2^{2^{m}}) = mS(m-1) + \\theta(m-1)$</p>\n\n<p>And here I have a problem. I obtain a factorial complexity and I don't know how to integrate $\\lg$ to prove the equality $P(u) = O(u)$</p>\n\n<p>Some advice ?</p>\n", 'ViewCount': '79', 'Title': 'Recursive complexity with change of variable', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-04T09:59:27.583', 'LastEditDate': '2012-10-04T09:59:27.583', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '4868', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3050', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2012-10-03T20:46:34.207', 'Id': '4865'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>We got tower $T_1$ with $n$ odd disks (1,3,5,...) and tower $T_2$ with $n$ even disks (2,4,6,...).\nNow we want to move all $2n$ disks to tower $T_3$.\nIf $T(p,q)$ is a recurrence relation of minimum number of moves we make to move $p$ disks from $T_1$ and $q$ disks from $T_2$ to $T_3$, we must find $T(n,n)$.</p>\n\n<p>If anyone has any idea, please share.</p>\n', 'ViewCount': '179', 'Title': 'An Alternative Hanoi Tower problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-07T17:03:01.067', 'LastEditDate': '2012-10-05T11:00:19.797', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '3046', 'Tags': '<algorithms><recurrence-relation><board-games>', 'CreationDate': '2012-10-04T05:27:08.737', 'FavoriteCount': '0', 'Id': '4872'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Prove or disprove the following statements:</p>\n\n<ol>\n<li><p>$T\\left( n \\right) = 2T\\left( {\\frac{n}{2}} \\right) + f\\left( n \\right),f\\left( n \\right) = \\theta \\left( {{n^2}} \\right) $ then $ {\\rm{ }}T\\left( n \\right) = \\theta \\left( {f\\left( n \\right)} \\right) $ for all $ {\\rm{ n = }}{{\\rm{2}}^k}$</p></li>\n<li><p>$T\\left( n \\right) = 2T\\left( {\\frac{n}{2}} \\right) + f\\left( n \\right),f\\left( n \\right) = \\Omega \\left( {{n^2}} \\right) $ then $ {\\rm{ }}T\\left( n \\right) = O\\left( {f\\left( n \\right)} \\right)$ for all $ {\\rm{ n = }}{{\\rm{2}}^k}$</p></li>\n</ol>\n\n<p>I think I should use the third case of the master theorem to check these equations.</p>\n\n<p>But I have not been able to check this constraint for these inequations:</p>\n\n<p>$\\qquad af\\left( {\\frac{n}{b}} \\right) \\le cf\\left( n \\right)$</p>\n\n<p>How do I do that?</p>\n', 'ViewCount': '236', 'Title': 'Problems showing the constraint of master theorem case three holds', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-06T10:31:29.743', 'LastEditDate': '2012-10-08T10:36:30.260', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '240', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2012-10-08T09:10:03.237', 'FavoriteCount': '2', 'Id': '4945'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<blockquote>\n  <p>Let $f(N)$ be the average number of full nodes (nodes with two children) in an $N$-node binary search tree.</p>\n  \n  <ol>\n  <li>Determine the values of $f(0)$ and $f(1)$. </li>\n  <li><p>Given that for $N &gt; 1$, </p>\n  \n  <p>$\\qquad \\displaystyle f(N) = \\frac{N-2}{N} + \\frac{1}{N} \\sum_{i=0}^{N-1} [f(i) + f(N - i - 1)]$,</p>\n  \n  <p>show that $f(N) = \\frac{N - 2}{3}$.</p></li>\n  <li>Using this information, show that the average number of nodes with one child in a binary search tree is $\\frac{N + 1}{3}$.</li>\n  </ol>\n</blockquote>\n\n<p>I know that for (1) both values are $0$. I mainly need help proving (2).\nI also found some hints for (2) and (3) but I can't figure it out:</p>\n\n<p>(2) The root contributes $\\frac{N \u2212 2}{N}$ full nodes on average, because the root is full as long as it does not contain the largest or smallest item. The remainder of the equation is the expected contribution of the subtrees.</p>\n\n<p>(3) The average number of leaves is $\\frac{N + 1}{3}$.</p>\n\n<p>Any help would be appreciated, even just pointing me in the right direction. Thanks!</p>\n", 'ViewCount': '517', 'Title': 'Average number of full nodes in a binary search tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T16:49:13.143', 'LastEditDate': '2012-10-22T15:51:25.087', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user1758064', 'PostTypeId': '1', 'Tags': '<data-structures><combinatorics><recurrence-relation><binary-trees>', 'CreationDate': '2012-10-19T02:17:50.273', 'Id': '6179'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm looking for a $\\Theta$ approximation of\n$$T(n) = T(n-1) + cn^{2}$$</p>\n\n<p>This is what I have so far:</p>\n\n<p>$$\n\\begin{align*}\nT(n-1)&amp; = T(n-2) + c(n-1)^2\\\\\nT(n) &amp;= T(n-2) + c(n-1) + cn^2\\\\[1ex]\nT(n-2) &amp;= T(n-3) + c(n-2)^2\\\\\nT(n) &amp; = T(n-3) + c(n-2)^2 + c(n-1)^2 + cn^2 \\\\[1ex]\nT(n-3) &amp;= T(n-4) + c(n-3)^2 \\\\\nT(n) &amp;= T(n-4) + c(n-3)^2 + c(n-2)^2 + c(n-1)^2 + cn^2\n\\end{align*}\n$$</p>\n\n<p>So, at this point I was going to generalize and substitute $k$ into the equation.</p>\n\n<p>$$T(n)= T(n-k) + (n-(k-1))^2 + c(k-1)^2$$</p>\n\n<p>Now, I start to bring the base case of 1 into the picture. On a couple of previous, more simple problems, I was able to set my generalized k equation equal to 1 and then solve for $k$. Then put $k$ back into the equation to get my ultimate answer.</p>\n\n<p>But I am totally stuck on the $(n-k+1)^2$ part. I mean, should I actually foil all this out? I did it and got $k^2-2kn-2k+n^2 +2n +1 = 1$. At this point I'm thinking I totally must have done something wrong since I've never see this in previous problems.</p>\n\n<p>Could anyone offer me some help with how to solve this one? I would greatly appreciate it. I also tried another approach where I tried to set $n-k = 0$ from the last part of the equation and got that $k = n$. I plugged n back into the equation towards the end and ultimately got $n^2$ as an answer. I have no clue if this is right or not.</p>\n\n<p>I am in an algorithms analysis class and we started doing recurrence relations and I'm not 100% sure if I am doing this problem correct. I get to a point where I am just stuck and don't know what to do. Maybe I'm doing this wrong, who knows. The question doesn't care about upper or lower bounds, it just wants a theta.</p>\n", 'ViewCount': '1572', 'Title': 'Recurrence relation for time complexity $T(n) = T(n-1) + n^2$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-28T00:27:27.063', 'LastEditDate': '2012-10-25T22:53:46.943', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '6275', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4336', 'Tags': '<time-complexity><algorithm-analysis><proof-techniques><recurrence-relation>', 'CreationDate': '2012-10-24T00:56:53.863', 'Id': '6274'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to understand dynamic programming and I am watching this mit video. If you guys could take some time out , can you refer to the slide on 41:36 . Why is the height m+n. I just don\'t get it why is the heigh of this recurrence tree m+n.</p>\n\n<p><a href="http://videolectures.net/mit6046jf05_leiserson_lec15/" rel="nofollow">http://videolectures.net/mit6046jf05_leiserson_lec15/</a></p>\n\n<p>Thank you. </p>\n', 'ViewCount': '170', 'Title': 'Regarding the height of a recursion tree on dynamic programming', 'LastActivityDate': '2012-10-24T05:12:53.063', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6280', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<recurrence-relation><dynamic-programming>', 'CreationDate': '2012-10-24T02:46:20.040', 'Id': '6276'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have the following pseudo code:    </p>\n\n<pre><code>Multiply(y,z)    \n1. if (z==0) return 0     \n2. else if (z is odd)    \n3.    then return (Multiply(2y, floor(z/2)) + y )    \n4. else return (Multiply(2y, floor(z/2)))    \n</code></pre>\n\n<p>Towards analysing this procedure's runtime, this recurrence relation is given as answer:</p>\n\n<p>$\\qquad \\displaystyle T(z) = \\begin{cases} 0 &amp; z=0 \\\\ T(z/2)+1 &amp; z&gt;0\\end{cases}$ </p>\n\n<p>Why is $T(z)=0$ when $z=0$? Shouldn't it be $1$ for this case?        </p>\n\n<p>And, the $+1$ in $T(z/2)\\mathbf{+1}$ is because the worst case is \n<code>(multiply(2y, floor(z/2)) + y</code> (note the <code>+ y</code>). Am I correct?     </p>\n", 'ViewCount': '128', 'Title': 'How does this recurrence relation fit the algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-29T00:23:43.783', 'LastEditDate': '2012-10-28T11:02:22.307', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4379', 'Tags': '<time-complexity><algorithm-analysis><asymptotics><recurrence-relation>', 'CreationDate': '2012-10-28T01:06:28.050', 'Id': '6345'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '957', 'Title': 'Solving a recurrence relation with $\\sqrt{n}$ as parameter', 'LastEditDate': '2012-10-31T23:17:42.550', 'AnswerCount': '3', 'Score': '6', 'OwnerDisplayName': 'KodeSeeker', 'PostTypeId': '1', 'OwnerUserId': '1510', 'Body': "<p>Let $T(n) = \\sqrt{n} T(\\sqrt{n}) + c\\,n$ for $n \\gt 2$ and some positive constant $c$ and $T(2) = 1$.</p>\n\n<p>I know the Master theorem, but I'm not sure as to how we could solve this relation using it. Any insight would be helpful.</p>\n", 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-23T12:49:26.543', 'CommentCount': '5', 'AcceptedAnswerId': '6425', 'CreationDate': '2012-10-30T22:28:19.830', 'Id': '6410'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>$T(n)=2T(n/2) + n\\log^2(n)$.</p>\n\n<p>If I try to substitute $m = \\log(n)$ I end up with </p>\n\n<p>$T(2^m)=2 T(2^{m-1}) + 2^m\\log^{2}(2^m)$.</p>\n\n<p>Which isn't helpful to me. Any clues?</p>\n\n<p>PS. hope this isn't too localized. I specified that the problem was a squared logarithm which should make it possible to find for others wondering about the same thing.</p>\n", 'ViewCount': '187', 'Title': 'Solving recurrence with logarithm squared $T(n)=2T(n/2) + n \\log^2n$', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T14:51:07.147', 'LastEditDate': '2012-11-22T14:51:07.147', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6834', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2826', 'Tags': '<asymptotics><proof-techniques><recurrence-relation>', 'CreationDate': '2012-11-22T09:18:57.203', 'Id': '6833'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm working exercises on solving recurrences, just using subsitution, master theorem is after this chapter. I'm sort of stuck on one of the exercises. It states that:</p>\n\n<p>The solution of $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$ is $O(n \\lg n)$. Show that it's also $\\Omega(n \\lg n)$ and conclude that the solution is $\\Theta(n \\lg n)$.</p>\n\n<p>For showing that it's $O(n \\lg n)$, I've to show that $T(n) \\leq cn \\lg n$. This can be solved by choosing an $m &lt; n$, like $\\lfloor n/2\\rfloor$, and substituting.</p>\n\n<p>But if we arrive at the conclusion that $T(n) \\leq cn \\lg n$ for any appropriate $c &gt; 0$ and $n \\geq n_0$, than how can we say that it is also $\\Omega(n \\lg n)$ which implies that $T(n) \\geq cn \\lg n$?</p>\n\n<p>Some more clarification would be nice!</p>\n", 'ViewCount': '76', 'Title': 'Showing bounds of a recurrence', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-12T19:35:42.130', 'LastEditDate': '2013-01-12T16:31:47.647', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5391', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2013-01-12T10:57:49.360', 'Id': '7904'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Concerning the Master Theorem. I have found the following equation as the base of analysis:  </p>\n\n<p>$\\quad T(n) = aT(n/b) + \\Theta(n^k)$  </p>\n\n<p>but I also found the following:  </p>\n\n<p>$\\quad T(n) = aT(n/b) + \\Theta(n^k\\cdot\\log_p n)$  </p>\n\n<p>where the base $p$ is a real number.  </p>\n\n<p>Can anyone explain the second equation? I understand the proof with the first equation but can not understand the second formula.</p>\n', 'ViewCount': '130', 'Title': 'Explanation of a specific recurrence with respect to Master Theorem', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-01T03:32:14.113', 'LastEditDate': '2013-01-20T15:26:39.403', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6487', 'Tags': '<algorithm-analysis><asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2013-01-20T10:42:04.463', 'Id': '9055'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Several years ago I was self learning lisp by a book which I do not remember. As an example there was a recursively defined sequence which was said to be unknown to be finite or not for every input --- to generate a sequence you were required to provide two(?) initial values. At least that is how I remember.</p>\n\n<p>There was a Wikipedia article on it but I can't find it either. Does anyone know what I'm talking about?</p>\n", 'ViewCount': '26', 'Title': 'Name of a sequence that is unknown to stop on a given input', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-22T08:23:58.323', 'LastEditDate': '2013-01-22T08:23:58.323', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9085', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6507', 'Tags': '<reference-request><recurrence-relation>', 'CreationDate': '2013-01-22T08:14:20.350', 'Id': '9084'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '138', 'Title': 'Example for the analysis of a recursive function', 'LastEditDate': '2013-01-26T18:10:30.180', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5222', 'FavoriteCount': '1', 'Body': "<pre><code>l is a matrix of size [1...n, 1...n]\n\nfunction: rec(i,j)\n  if (i*j == 0)\n    return 1\n  else\n    if (l[i,j] == 0)\n      l[i,j] = 1 * rec(i-1,j) + 2 * rec(i,j-1) + 3 * rec(i-1,j-1)\n    return l[i,j]\nend_function\n\nfor i=1 to n\n  for j=1 to n\n    l[i,j] = 0\n\nrec(n,n)\n</code></pre>\n\n<p>The nested for's are O(n<sup>2</sup>). But i have difficulties to analyse the recursive part. There is another variation of this example with l as 3d. And the essential part of 3drec function is defined as:</p>\n\n<pre><code>if (l[i,j,k] == 0)\n  l[i,j,k] = 2 * rec(i-1,j,k) + 2 * rec(i,j-1,k) + 2 * rec(i,j,k-1)\n</code></pre>\n\n<p>Anyway let's think about the 2d version again. I thought something like that (that's the running time for the whole code including the nested loops):</p>\n\n<p>T(n) = T(n-1, n<sup>2</sup>) + T(n, n-1<sup>2</sup>) + T(n-1<sup>2</sup>, n-1<sup>2</sup>)</p>\n\n<p>And i'm stuck here. Besides i don't know if i did right till this point.</p>\n", 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><recurrence-relation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-26T22:54:57.413', 'CommentCount': '4', 'AcceptedAnswerId': '9172', 'CreationDate': '2013-01-26T01:11:04.723', 'Id': '9162'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have some recurrence relationships I use to compute some coefficients of a series. I want to know what the time complexity of computing these is. Suppose I know the coefficients $a_0,...,a_n$, and I want to compute $c_0,...,c_n$ as follows</p>\n\n<p>$ c_{n}=\\begin{cases}\ne^{b_{0}}, &amp; n=0\\\\\n\\frac{1}{n}\\sum_{k=1}^{n}kb_{k}c_{n-k}, &amp; n\\geq1\n\\end{cases}$</p>\n\n<p>where </p>\n\n<p>$b_{n}=\\begin{cases}\n\\frac{1}{a_{0}}, &amp; n=0\\\\\n-\\frac{1}{a_{0}}\\sum_{i=1}^{n}a_{i}b_{n-i}, &amp; n\\geq1\n\\end{cases}$</p>\n\n<p>So far this is what I have. If we know $b_0,...,b_{k-1}$ then $b_k$ can be computed in $O(k)$ time, so to compute $b_0,...,b_{n}$ takes $\\sum_{k=0}^{n}O(k)=O(n^2)$ time. </p>\n\n<p>Now suppose that we know $b_0,...,b_{k}$ and $c_0,...,c_{k-1}$ then it takes  $O(k)$ time to compute $c_k$. Thus to compute $c_0,...,c_{n}$ it takes $\\sum_{k=0}^{n}O(k)=O(n^2)$. Ofcourse we have to take into account the time it takes to compute  $b_0,...,b_{n}$ which is $O(n^2)$.</p>\n\n<p>So can I conclude that the time it takes to compute $c_0,...,c_{n}$ is </p>\n\n<p>$O(n^2)+O(n^2)=O(n^2)$??</p>\n', 'ViewCount': '37', 'Title': 'Computational complexity of coefficients', 'LastEditorUserId': '6580', 'LastActivityDate': '2013-01-27T19:24:29.233', 'LastEditDate': '2013-01-27T16:42:50.047', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9218', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6580', 'Tags': '<time-complexity><recurrence-relation>', 'CreationDate': '2013-01-27T16:30:50.947', 'Id': '9206'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m having a real hard time solving recurrences using the substitution method.</p>\n\n<p>Show that: $T(n) = T(n/2) + 1$ is $O(\\lg n)$</p>\n\n<p>I thought this to be relatively easy:</p>\n\n<p>We have to show that $T(n) \\leq c \\lg n$</p>\n\n<p>Substitution gives me:</p>\n\n<p>$\\qquad\n  \\begin{align}\n    T(n) &amp;\\leq c \\lg(n/2) + 1 \\\\\n         &amp;= c \\lg n - c \\lg 2 + 1 \\\\\n         &amp;= c \\lg n - c + 1 \\\\\n         &amp;\\leq  c \\lg n\n\\end{align}$ </p>\n\n<p>for every c.</p>\n\n<p>I was under the impression this was it, but when I was looking for an answer, I came around a <a href="http://classes.soe.ucsc.edu/cmps101/Spring11/hw/hw2sol.pdf" rel="nofollow">much more elaborate answer on the web</a>, given  involving subtracting a constant. I don\'t get why that\'s needed, I thought I had shown what was needed.</p>\n\n<p>Any help would be greatly appreciate, starting Monday I\'m enrolled in an algorithms class and I don\'t want to get behind!</p>\n\n<p>We are using the CLRS book (surprise) and though I appreciate the amount of information in it, I\'d rather have some more resources. I\'ve really enjoyed a datastructures class and I really think I can enjoy this as well, but more resources would be very much appreciated.</p>\n', 'ViewCount': '100', 'ClosedDate': '2013-08-07T08:13:19.483', 'Title': 'Solving a simple recurrence', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-07T06:14:56.363', 'LastEditDate': '2013-01-30T20:56:16.523', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5391', 'Tags': '<reference-request><proof-techniques><recurrence-relation>', 'CreationDate': '2013-01-30T20:13:17.710', 'Id': '9329'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm reading Cormen's Introduction to Algorithms 3rd edition, and in examples of Master Method recursion solving Cormen gives two examples</p>\n\n<ol>\n<li>$3T( \\frac{n}{4} ) + n\\log(n)$</li>\n<li>$2T( \\frac{n}{2} ) + n\\log(n)$</li>\n</ol>\n\n<p>For the first example we have $a=3$ and $b=4$  so $n^{\\log_4\n(3)}=n^{0.793}$ and Cormen says that if we choose $\\epsilon = 0.207$ then $f(n) = n\\log(n) = \\Omega(n^{\\log_4(3)  + \\epsilon})$</p>\n\n<p>How? As I understand it if $\\epsilon = 0.207$ then $\\Omega(n^{\\log_4(3)  + \\epsilon})= \\Omega(n)$ so we have $n\\log(n) = \\Omega(n)$  but it's not true; But he proves that $n\\log(n) = \\Omega( n^{\\log_4(3)  + \\epsilon} )$</p>\n\n<p>And then he proves that for the second case $n\\log(n)$ does not apply to masters method 3-rd case the same way as I prove above.</p>\n\n<p>So could somebody explain me in detail how  the third case of the master's theorem applies to  $3T( \\frac{n}{4} ) + n \\log(n)$  but not to $2T( \\frac{n}{2} ) + n\\log(n)$.</p>\n", 'ViewCount': '464', 'Title': 'How to the examples for using the master theorem in Cormen work?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T17:20:19.517', 'LastEditDate': '2013-02-02T13:24:39.077', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '9403', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6664', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2013-02-01T15:58:58.403', 'Id': '9390'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>The Master theorem is a beautiful tool for <a href="http://cs.stackexchange.com/a/2823/98">solving certain kinds of recurrences</a>. However, we often gloss over an integral part when applying it. For example, during the analysis of Mergesort we happily go from</p>\n\n<p>$\\qquad T(n) = T\\left(\\left\\lfloor \\frac{n}{2} \\right\\rfloor\\right) + T\\left(\\left\\lceil \\frac{n}{2} \\right\\rceil\\right) + f(n)$</p>\n\n<p>to </p>\n\n<p>$\\qquad T\'(n) = 2 T\'\\left(\\frac{n}{2}\\right) + f(n)$</p>\n\n<p>considering only $n=2^k$. We assure ourselved that this step is valid -- that is, $T \\in \\Theta(T\')$ -- because $T$ behaves "nicely". In general, we assume $n=b^k$ for $b$ the common denominator.</p>\n\n<p>It is easy to construct recurrences which do not allow this simplification by using vicious $f$. For example, above recurrence for $T\\,$/$\\,T\'$ with</p>\n\n<p>$\\qquad f(n) = \\begin{cases}\n                 1 &amp;, n=2^k \\\\\n                 n &amp;, \\text{else}\n               \\end{cases}$</p>\n\n<p>will yield $\\Theta(n)$ by using the Master theorem in the usual way, but there is clearly a subsequence that grows like $\\Theta(n \\log n)$. See <a href="http://cs.stackexchange.com/a/4980/98">here</a> for another, more contrived example.</p>\n\n<p>How can we make this "nicely" rigorous? I am quite certain that monotonicity is sufficient, but not even the simple Mergesort recurrence is monotone; <a href="http://cs.stackexchange.com/a/2390/98">there is a periodic component</a> (which is dominated asymptotically). Is it enough to investigate $f$, and what are necessary and sufficient conditions on $f$ that ensure the Master theorem works?</p>\n', 'ViewCount': '252', 'Title': 'Rigorous proof for validity of assumption $n=b^k$ when using the Master theorem', 'LastActivityDate': '2013-02-11T00:43:01.050', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '9654', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><proof-techniques><recurrence-relation><master-theorem>', 'CreationDate': '2013-02-07T07:35:33.753', 'FavoriteCount': '3', 'Id': '9569'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have an algorithm where the number of items in my set decrease by $\\sigma/(1+\\sigma)$ on each iteration until all items are exhausted.</p>\n\n<p>$$\n\\begin{align*}\nS_0 &amp;= S \\\\\nS_{k+1} &amp;= S_k - S_k \\frac{\\sigma}{1+\\sigma}\n\\end{align*}\n$$</p>\n\n<p>Here $\\sigma$ is a small value.</p>\n\n<p>How can I find number of iterations? I know it is a geometric series but can't seem to simplify for number of iterations.</p>\n", 'ViewCount': '140', 'Title': 'Finding the number of iterations to a recurrence', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-18T21:56:51.273', 'LastEditDate': '2013-02-18T21:56:51.273', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9886', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5399', 'Tags': '<time-complexity><recurrence-relation><discrete-mathematics>', 'CreationDate': '2013-02-18T05:29:52.657', 'Id': '9885'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to analyze the running time of a bad implementation of generating the $n$th member of the fibonacci sequence (which requires generating the previous 2 values from the bottom up).</p>\n\n<p>Why does this algorithm have a time complexity of $\\Omega(2^{\\frac{n}{2}})$? Where does the exponent come from?</p>\n', 'ViewCount': '852', 'Title': 'Why does a recurrence of $T(n - 1) + T(n - 2)$ yield something in $\\Omega(2^{\\frac{n}{2}})$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-19T23:48:57.897', 'LastEditDate': '2013-02-19T06:22:05.190', 'AnswerCount': '4', 'CommentCount': '5', 'AcceptedAnswerId': '9908', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<algorithms><algorithm-analysis><asymptotics><runtime-analysis><recurrence-relation>', 'CreationDate': '2013-02-18T19:02:47.990', 'Id': '9899'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I would like to find the height of a d-ary heap. Assuming you have an Array that starts indexing at $1$ we have the following:</p>\n\n<p>The parent of a node $i$ is given by: $\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor$</p>\n\n<p>The $d$ children of a parent at node $i$ are given by: $di-d+1, di-d+2,\\ldots di+1$</p>\n\n<p>The height of a heap (which is slightly different than the height of a binary search tree) is a longest path from the root to a leaf. A longest path will always be from the last node in the heap to the root, but how do I calculate this longest path?</p>\n\n<p>My first Idea is to setup a recurrence relation for the height of the tree:</p>\n\n<p>\\begin{equation}\nh(1) = 0\\\\\nh(i) = h\\left(\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor\\right)+1 \n\\end{equation}</p>\n\n<p>This seems overly-complicated and I feel like the answer is much more simple. Is there a better way to find the height of a $d-$ary heap?</p>\n', 'ViewCount': '567', 'Title': 'Finding the height of a d-ary heap', 'LastEditorUserId': '6815', 'LastActivityDate': '2013-02-19T09:44:45.017', 'LastEditDate': '2013-02-18T23:01:14.800', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9929', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<data-structures><recurrence-relation><heaps>', 'CreationDate': '2013-02-18T22:44:05.470', 'Id': '9914'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is there a general method to solve the recurrence of the form:</p>\n\n<p>$T(n) = T(n-n^c) + T(n^c) + f(n)$</p>\n\n<p>for $c &lt; 1$, or more generally</p>\n\n<p>$T(n) = T(n-g(n)) + T(r(n)) + f(n)$</p>\n\n<p>where $g(n),r(n)$ are some sub-linear functions of $n$.</p>\n\n<p><strong>Update</strong>: I have gone through the links the provided below and also sifted through all the recurrence relations in <a href="http://www.cs.illinois.edu/class/fa10/cs573/notes/99-recurrences.pdf">Jeff Erickson\'s notes</a>. This form of the recurrence is not discussed anywhere. Akkra-Bazi method applies only when the split is fractional. Any poignant reference will be apprieciated.</p>\n', 'ViewCount': '146', 'Title': 'Solving divide & conquer reccurences if the split-ratio depends on $n$', 'LastEditorUserId': '5195', 'LastActivityDate': '2013-02-28T04:29:50.800', 'LastEditDate': '2013-02-28T04:29:50.800', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '5195', 'Tags': '<proof-techniques><recurrence-relation>', 'CreationDate': '2013-02-25T16:24:13.697', 'FavoriteCount': '2', 'Id': '10088'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to solve a recurrence by using substitution method. The recurrence relation is:\n$$T(n)=4T(n/2)+n^2$$\nMy guess is $T(n)$ is $\\Theta(n\\log n)$ (and I am sure about it because of master theorem), and to find an upper bound, I use induction. I tried to show that $T(n)\\le cn^2\\log n$ but that did not work, I got $T(n)\\le cn^2\\log n+n^2$.</p>\n\n<p>I then tried to show that, if $T(n)\\le c_1 n^2\\log n-c_2 n^2$, then it is also $\\mathcal O(n^2\\log n)$, but that also did not work and I got $T(n)\\le c_1n^2\\log(n/2)-c_2 n^2+n^2$.</p>\n\n<p>What trick can I use to show that? Thanks.</p>\n', 'ViewCount': '734', 'Title': 'Solving $T(n)=4T(n/2)+n^2$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-15T22:16:54.140', 'LastEditDate': '2013-03-05T06:55:11.717', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7122', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2013-03-03T12:33:28.547', 'FavoriteCount': '0', 'Id': '10227'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I know that master theorem is used for the recurrence relations of the form:</p>\n\n<p>T(n) = aT(n/b) + f(n)</p>\n\n<p>But in my question, i am supposed to solve the following recurrence relation by using master theorem:</p>\n\n<p>T(n) = 2T(n/7) + 5T(n/8) + n</p>\n\n<p>Can i take f(n)=n and since f(n)=\u0398(n<sup>log<sub>b</sub>a</sup>), i say T(n) is O(nlogn)? But if i do this, i neglect the fact that the relation must be of the form T(n) = aT(n/b) + f(n). What should i do? Thanks</p>\n', 'ViewCount': '142', 'Title': 'Usage of master theorem for solving recursions', 'LastActivityDate': '2013-03-03T18:12:02.917', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7122', 'Tags': '<recurrence-relation><master-theorem>', 'CreationDate': '2013-03-03T16:01:53.353', 'FavoriteCount': '3', 'Id': '10234'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '230', 'Title': 'Solve a recurrence by drawing the recursion tree?', 'LastEditDate': '2013-03-05T07:00:38.817', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'imGreg', 'PostTypeId': '1', 'OwnerUserId': '7149', 'FavoriteCount': '1', 'Body': "<p>I'm studying for an entrance exam and I have sample questions. One of the questions is this</p>\n\n<blockquote>\n  <p>Prove that recurrence $T(n) = T(n/5) + T(4n/5)+n/2$\n  has a solution $T(n) = \\omega(n \\log n)$.   </p>\n  \n  <p>Solve by drawing the recursion tree.</p>\n</blockquote>\n\n<p>This is what I drew on my paper: </p>\n\n<pre><code>root:  n/2 =&gt; (4n/5)/2\n\n           =&gt; (n/5)/2\n\nright sub tree:  (4n/5)/2 =&gt; (16n/25)/2\n\n                          =&gt; (4n/25)/2\n\nleft sub tree:   (n/5)/2  =&gt; (4n/25)/2\n\n                          =&gt; (n/25)/2\n</code></pre>\n\n<p>From what I saw online when I was searching for a solution to this question I noticed people were drawing the trees and saying Big O something as an answer. I'm wondering how do they determine that Big O notation is the correct answer for this question or if my tree is correct?</p>\n", 'Tags': '<asymptotics><recurrence-relation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-07T16:51:48.820', 'CommentCount': '2', 'CreationDate': '2013-03-03T04:17:38.587', 'Id': '10242'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a recurrence relation which is like the following:<p></p>\n\n<p>$T(n) = 2T(\\frac{n}{2}) + \\log_{2}n$</p>\n\n<p>I am using recursion tree method to solve this. And at the end, i came up with the following equation:<p></p>\n\n<p>$T(n)=(2\\log_{2}n)(n-1)-(1\\times 2 + 2\\times 2^{2} + \\ldots + k\\times2^{k})$ where $k=\\log_{2}n$</p>\n\n<p>I am trying to find a theta notation for this equation. But i cannot find a closed formula for the sum $(1\\times 2 + 2\\times 2^{2} + \\ldots + k\\times2^{k})$. How can I find a big theta notation for $T(n)$? </p>\n', 'ViewCount': '250', 'Title': 'Need help about solving a recurrence relation', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-07T20:27:23.937', 'LastEditDate': '2013-03-07T00:27:04.883', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7175', 'Tags': '<algorithms><algorithm-analysis><recurrence-relation><recursion>', 'CreationDate': '2013-03-07T00:10:55.800', 'FavoriteCount': '2', 'Id': '10346'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I have a recurrence relation and trying to use master theorem to solve it. The recurrence relation is:</p>\n\n<p>$T(n) = 3T(n/5) + n^{0.5}$</p>\n\n<p>Can I use the master theorem in that relation? If so, can I say that $T(n)$ is $\u0398(n^{0.5})$?</p>\n', 'ViewCount': '24', 'ClosedDate': '2013-03-07T11:23:42.837', 'Title': 'The use of master theorem appriopriately', 'LastEditorUserId': '8246', 'LastActivityDate': '2013-09-28T12:35:50.493', 'LastEditDate': '2013-09-28T12:35:50.493', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7175', 'Tags': '<algorithms><time-complexity><recurrence-relation><recursion><master-theorem>', 'CreationDate': '2013-03-07T09:48:45.607', 'Id': '10356'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I have a recurrence relation, it is like the following:</p>\n\n<p>$T(e^n) = 2(T(e^{n-1})) + e^n$, where $e$ is the base of the natural logarithm.</p>\n\n<p>To solve this and find a $\\Theta$ bound, I tried the following: I put $k=e^n$, and the equation transforms into:</p>\n\n<p>$$T(k)=2T(k/e)+k$$</p>\n\n<p>Then, I try to use the Master Theorem. According to Master Theorem, $a=2$, $b=e\\gt 2$ and $f(k)=k$. So, we have the case where $f(k)=\\Omega(n^{\\log_b a+\u03b5})$ for some $\u03b5\\gt 0$, thus we have $T(k)=\\Theta(f(k))=\\Theta(k)$. Then put $k=n$, we have $T(n)=\\Theta(n)$. Does my solution have any mistakes?</p>\n', 'ViewCount': '81', 'Title': 'Not sure if my solution to following recurrence is correct', 'LastEditorUserId': '8246', 'LastActivityDate': '2013-09-28T12:36:02.527', 'LastEditDate': '2013-09-28T12:36:02.527', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7175', 'Tags': '<algorithms><time-complexity><recurrence-relation><master-theorem><check-my-answer>', 'CreationDate': '2013-03-07T11:52:11.320', 'FavoriteCount': '1', 'Id': '10359'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '207', 'Title': 'Recurrence relation with sum', 'LastEditDate': '2013-03-20T10:17:19.530', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Body': '<p>This is a question about recurrence relation that contains sum inside the recursion.I am totally stuck. Can anyone help?</p>\n\n<p>The problem asks to solve the following recursion $T(n)=\\frac{1}{n} \\sum_{i=1}^{n-1}(T(i)+T(n-i))+cn$. The problem also warns that unwrapping is going to be the wrong approach and the right strategy would be to guess the solution and prove it by induction. As the first step it suggests to start with $nT(n) -(n - 1)T(n -1)$.</p>\n', 'ClosedDate': '2013-03-20T11:54:30.140', 'Tags': '<recurrence-relation>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-20T16:29:27.523', 'CommentCount': '3', 'AcceptedAnswerId': '10628', 'CreationDate': '2013-03-19T21:26:52.603', 'Id': '10625'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Perhaps this is a question for stackoverflow because its practical nature, but I am not aware of any general method to relate recurrence relations and recursive functions.</p>\n\n<p>Having as an example this recurrence relation:</p>\n\n<p>$\\qquad \\begin{align}a_0 &amp;= a_1 = 1 \\\\ 2a_n &amp;= 3a_{n-1}-2a_{n-2}\\end{align}$</p>\n\n<p>I would like to transform it into a recursive <em>function</em> $f$, able to be called to itself a number of times (composite), i.e.  $f \\circ f \\circ f \\circ \\dots \\circ f$  ($n$ times), getting the same result as with the $a_n$ relation.</p>\n\n<p>Any ideas about it?</p>\n', 'ViewCount': '98', 'Title': 'Can a recurrence relation be translated to a composite function of itself?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-21T17:38:28.180', 'LastEditDate': '2013-03-23T16:05:37.757', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10707', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<recurrence-relation><recursion>', 'CreationDate': '2013-03-23T14:46:41.773', 'Id': '10706'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Following method is explained by my senior. I want to know whether I can use it in all cases or not. When I solve it manually, I come to same answer. </p>\n\n<p>$T(n)= 4T(n/2) + \\frac{n^2}{\\lg n}$</p>\n\n<p>In above recurrence master theorem fails. But he gave me this solution, when </p>\n\n<p>for $T(n) = aT(n/b) + \\Theta(n^d \\lg^kn)$ </p>\n\n<p>if $d = \\log_b a$ </p>\n\n<p>if $k\\geq0$ then $T(n)=\\Theta(n^d \\lg^{k+1})$</p>\n\n<p>if $k=-1$ then $T(n)=\\Theta(n^d\\lg\\lg n)$</p>\n\n<p>if $k&lt;-1$ then $T(n)=\\Theta(n^{\\log_ba})$</p>\n\n<p>using above formulae, the recurrence is solved to $\\Theta(n^2\\lg\\lg n)$. When I solved manually, I come up with same answer. If it is some standard method, what it is called ?</p>\n', 'ViewCount': '278', 'Title': 'Finding recurrence when Master Theorem fails', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T21:44:26.690', 'LastEditDate': '2013-04-02T19:09:34.620', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10980', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2013-04-02T17:51:49.660', 'Id': '10977'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given a recursive function $T(n)=T(a_1\\cdot n)+\\dots +T(a_k\\cdot n)+\\Theta(n)$ such that $\\forall a_i: 0&lt;a_i&lt;1$, what is the most general thing I can say about the sum of the cost of the nodes at each level of the recursion tree?  I've looked at a few, and for the ones I've looked at it's always come out to $(a_1+\\dots +a_k)^i$ where $i$ is the level in the tree.</p>\n\n<p>Could anyone explain this?  If it matters it's in the context of trying to prove that $T(n)=\\Theta(n) \\Leftrightarrow a_1+\\dots +a_k &lt; 1$ </p>\n", 'ViewCount': '119', 'Title': 'Cost at Each Level of a Recursion Tree', 'LastEditorUserId': '31', 'LastActivityDate': '2013-04-29T19:50:05.707', 'LastEditDate': '2013-04-29T19:50:05.707', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '11662', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<recurrence-relation>', 'CreationDate': '2013-04-29T09:50:54.520', 'Id': '11654'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '77', 'Title': 'Resolving this recurrence equation', 'LastEditDate': '2013-04-29T12:38:07.347', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Federico Ponzi', 'PostTypeId': '1', 'OwnerUserId': '17193', 'Body': "<p>I have this recurrence equation:</p>\n\n<p>$T(n) = T(n/4) + T(3n/4) + \\mathcal{O}(n)$</p>\n\n<p>$T(1) = 1$</p>\n\n<p>I know that the result is $\\mathcal{O}(n \\log n)$ but i don't know how to proceed.</p>\n", 'ClosedDate': '2013-04-29T18:28:35.180', 'Tags': '<asymptotics><runtime-analysis><recurrence-relation><recursion>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-04-29T12:38:07.347', 'CommentCount': '6', 'AcceptedAnswerId': '11657', 'CreationDate': '2013-04-14T19:02:46.790', 'Id': '11656'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am not sure whether this is the right place to ask this question.</p>\n\n<p>I would like to write a register machine code which when given an input of n in register\n1, returns (also in register 1) the nth Fibonacci number. The Fibonacci numbers are\n0 (the 0th), 1 (the 1st), 1 = 0 + 1 (the 2nd), etc. </p>\n\n<p>I tried to write few lines of the codes, but unable to do the recursive property of Fibonacci sequence. Here is my code:</p>\n\n<p>Let A, B, C be registers.</p>\n\n<ol>\n<li>(-A; 2,-)</li>\n<li>(+C; 1)</li>\n<li>(-C; 4,-)</li>\n<li>(+B; 5)</li>\n<li>(+A; 3)</li>\n</ol>\n\n<p>I know that the fifth line is wrong but have no idea how to fix it. And I want to code to be as simple as possible (i.e. with fewest instructions). Thanks in advance.</p>\n', 'ViewCount': '224', 'Title': 'Register Machine code for Fibonacci Numbers', 'LastActivityDate': '2013-06-12T14:36:21.393', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8141', 'Tags': '<programming-languages><recurrence-relation><recursion>', 'CreationDate': '2013-05-13T05:48:28.760', 'Id': '11984'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '161', 'Title': 'Hanoi tower with forbidden direct move from source to destination', 'LastEditDate': '2013-05-19T07:30:47.883', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8251', 'FavoriteCount': '0', 'Body': "<p>I want to know what is algorithm and time complexity of Hanoi tower with forbidden direct move from source to destination (<em>it means you cannot move disk from source to destination directly and you instead of that should first move disk from source to middle and then from middle to destination</em>) and other rules as normal problem?</p>\n\n<p>I didn't find any article about it.</p>\n", 'Tags': '<algorithms><recurrence-relation><board-games>', 'LastEditorUserId': '8251', 'LastActivityDate': '2013-11-21T05:09:37.510', 'CommentCount': '6', 'AcceptedAnswerId': '12399', 'CreationDate': '2013-05-19T06:20:09.157', 'Id': '12130'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>$$T(n) = 2T(n/2) + \\Theta(n), n &gt; 1$$\n$$T(n) = \\Theta (1), n \\le 1$$</p>\n\n<p>$$G(n) = G(\\lfloor n/2 \\rfloor) + G (\\lceil n/2 \\rceil) + \\Theta(n), n &gt; 1$$\n$$G(n) = \\Theta (1), n \\le 1$$</p>\n\n<p>Prove $T(n)$ and $G(n)$ have the same asymtotic running time.</p>\n\n<p>I tried using the sandwich theorem but got nowhere. Please be really explicit and show all your steps in your answer. Thank you.</p>\n', 'ViewCount': '76', 'Title': 'Compare speed of two algorithms?', 'LastActivityDate': '2013-05-21T13:44:05.233', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8269', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2013-05-20T16:22:48.897', 'Id': '12160'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I met the problem </p>\n\n<blockquote>\n  <p>Show that the solution to $T(n) = 2T(\\lfloor n/2\\rfloor + 17) + n$ is $O(n \\log n)$</p>\n</blockquote>\n\n<p>while reading Introduction to Algorithm. It's a question about the substitution method for solving recurrences.</p>\n\n<p>Should I just assume $T(n/2 + 17) \\leq O((n/2 + 17) \\log(n/2 + 17))$ and then prove $T(n) \\leq O(n \\log n)$? Is this inductive assumption enough to solve it?</p>\n", 'ViewCount': '122', 'ClosedDate': '2013-09-16T08:55:38.767', 'Title': 'How to prove the asymptotic upper bound for $T(n) = 2T(\\lfloor n/2\\rfloor + 17) + n$ is $O(n \\log n)$?', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-06-27T18:45:56.293', 'LastEditDate': '2013-06-27T18:45:56.293', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8838', 'Tags': '<asymptotics><recurrence-relation><induction><divide-and-conquer>', 'CreationDate': '2013-06-24T14:43:28.910', 'Id': '12865'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>If you have a long string of length $n$ and a shorter string of length $m$, what is a suitable recurrence to let you compute all $n-m+1$ <a href="http://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow">Levevenshtein distances</a> between the shorter string and all substrings of the longer string of length $m$?</p>\n\n<p>Can it in fact be done in $O(nm)$ time?</p>\n', 'ViewCount': '132', 'Title': 'Semi-local Levenshtein distance', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-02T09:52:43.530', 'LastEditDate': '2013-09-02T09:52:43.530', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8938', 'Tags': '<recurrence-relation><dynamic-programming><strings><string-metrics><edit-distance>', 'CreationDate': '2013-06-30T11:00:35.020', 'Id': '12986'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '81', 'Title': 'Why is this sequence of recurrence relevant?', 'LastEditDate': '2013-07-11T11:58:16.090', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3003', 'FavoriteCount': '1', 'Body': '<p>I am learning how to solve the time complexity for the recurrence relation</p>\n\n<p>$$\n    T(n) = 2T(n - 1) + n^2\\text{, where }T(1) = 1\n$$</p>\n\n<p>The solution notes that I should begin by considering the following sequence:</p>\n\n<p>$$\n    \\text{Define }T^k(n) = T^{k - 1}(n + 1) - T^{k - 1}(n) \\\\\n    \\text{and let }T^{(0)}(n) = T(n)\n$$</p>\n\n<p>How is the sequence $T^k(n)$ relevant to solving my original recurrence relation? This just seems to be complicating the problem by defining an entirely new sequence. </p>\n', 'Tags': '<proof-techniques><recurrence-relation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-11T11:58:16.090', 'CommentCount': '1', 'AcceptedAnswerId': '13122', 'CreationDate': '2013-07-06T21:41:21.073', 'Id': '13118'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '2139', 'Title': 'Recurrence for recursive insertion sort', 'LastEditDate': '2013-07-09T11:26:11.003', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9051', 'FavoriteCount': '0', 'Body': '<p>I tried this problem from CLRS (Page 39, 2.3-4)</p>\n\n<blockquote>\n  <p>We can express insertion sort as a recursive procedure as follows. In order to sort <code>A[1... n]</code>, we recursively sort <code>A[1... n-1]</code> and then insert <code>A[n]</code> into the sorted array <code>A[1... n-1]</code>. Write a recurrence for the running time of this recursive version of insertion sort.</p>\n</blockquote>\n\n<p>The recurrence I formed was</p>\n\n<p>$$\nT(n) = \\begin{cases}\\Theta(1) &amp; \\textrm{if } n = 1,\\\\\n       T(n-1) + \\Theta(n) &amp; \\textrm{if } n &gt; 1.\n\\end{cases}\n$$</p>\n\n<p><strong>My reasoning</strong></p>\n\n<ul>\n<li>the base case of $n = 1$ the list is sorted so there is no work hence constant time.</li>\n<li>For all other cases the time depends on sorting the sequence <code>A[1...n-1]</code> and then insertion into that sequence. Hence it should be their sum, i.e., $T(n-1) + \\Theta(n)$.</li>\n</ul>\n\n<p>I wanted to know whether the recurrence relation is correct. If not what are the mistakes and how to correctly formulate a recurrence relation?</p>\n', 'Tags': '<algorithm-analysis><recurrence-relation><sorting>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-09T14:06:04.290', 'CommentCount': '2', 'AcceptedAnswerId': '13174', 'CreationDate': '2013-07-09T06:51:21.537', 'Id': '13168'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '151', 'Title': 'Recurrence formula for a known sequence?', 'LastEditDate': '2013-07-13T22:32:30.113', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9000', 'FavoriteCount': '1', 'Body': "<p>Problem: How do we can generate some mathematical close form of the following sequence, which has following 256 entries:</p>\n\n<p>1   7   7   7   7   9   9   9   7   9   9   9   7   9   9   9   7   11  11  11  11  13  13  13  11  13  13  13  11  13  13  13  7   11  11  11  11  13  13  13  11  13  13  13  11  13  13  13  7   11  11  11  11  13  13  13  11  13  13  13  11  13  13  13  7   11  11  11  11  13  13  13  11  13  13  13  11  13  13  13  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  7   11  11  11  11  13  13  13  11  13  13  13  11  13  13  13  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  7   11  11  11  11  13  13  13  11  13  13  13  11  13  13  13  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15  9   13  13  13  13  15  15  15  13  15  15  15  13  15  15  15</p>\n\n<p>Origin/background of Problem:\n                              These number are generated from a divide and conquer algorithm. For example if we have a 8 bit binary-string and we are asked to find the location of 1's in minimal number of questions then, the above sequence is the # of questions asked for each possible binary 8-bit word i.e from 00000000, 00000001 ....11111111 the corresponding # of questions are elements of above sequence i.e 1,7,..15, respectively.</p>\n\n<p>Algorithm:</p>\n\n<p>Lets take 0000 0001, for instance:</p>\n\n<p>1) First question: Is it (i-e 0000 0001) equal to ZERO (i-e 0000 0000) ? The answer is No, for our case. </p>\n\n<p>2) Then divide the original 8 bit word into two 4 bit segments, and again ask the same question for each of the two 4 bit words. So for our case it would be YES for the first segment (0000) and NO for the other segment (0001)?</p>\n\n<p>3) Now, this time I will be questioning only the segment where I got NO. In our case it was 0001. Then, I will now again divide  this 4-bit segment into two segments and pose the same question. Hence, is 00 equal to ZERO? answer : YES. For the other segment , 01, the answer is NO.</p>\n\n<p>4) This is the final step. I will again divide the 2-bit word into two 1-bits, i-e 0 and 1. So, my first question: is 0 equal to 0? answer is YES. And for the other remaining bit, is 1 equal to 0? Answer is NO.</p>\n\n<p>So, I asked a total of 7 questions to find the location of 1 in a binary word of 0000 0001. Similarly, we will go through other binary words.</p>\n", 'Tags': '<combinatorics><recurrence-relation>', 'LastEditorUserId': '9000', 'LastActivityDate': '2013-07-13T22:32:30.113', 'CommentCount': '11', 'AcceptedAnswerId': '13263', 'CreationDate': '2013-07-10T23:28:41.760', 'Id': '13218'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Below is a well-known equation for generalized recurrence relation in a divide and conquer paradigm (as described in CLRS) --</p>\n\n<p>$$T(n) = aT(n/b) + f(n), \\quad \\text{where} \\quad a \\gt 1 \\text{ , } b \\geq 1$$</p>\n\n<p>If we consider a case for merge-sort, the relation will look like this -- </p>\n\n<p>$$T(n) = 2T(n/2) + \\Theta(n) \\qquad \\qquad (i)$$</p>\n\n<p>which is quite straight-forward, i.e. we have $2$ sub-problems of size $n/2$ each, ($1/2$ of the original sub-problem), and $\\Theta(n)$ operations to merge them. </p>\n\n<p>Now if we have a relation like --</p>\n\n<p>$$T(n) = 3T(n/2) + \\Theta(n) \\qquad \\qquad (ii)$$</p>\n\n<p>then we can assume that there are $3$ "overlapping" sub-problems, as each of them with size $n/2$. Let\'s consider again -- </p>\n\n<p>$$T(n) = 2T(n/4) + \\Theta(n) \\qquad \\qquad (iii)$$</p>\n\n<p>now, what does it mean? Are there $2$ sub-problems with size $n/4$? How is it possible? If we divide the whole problem into $4$ equal sizes then we should need something like $4T(n/4)$ instead of $2T(n/4)$ to balance the recurrence tree (each node with 4 leaves), right? Is this relation realistic?</p>\n\n<p>If this is the case, then why there is no constraint like $b &lt; a$ ? Moreover, is there any algorithm that follows the recurrence as in $(ii)$ and $(iii)$?</p>\n', 'ViewCount': '92', 'Title': 'Relation between the number of sub-problems ($a$) and the size of sub-problems ($b$) in a recurrence', 'LastEditorUserId': '7678', 'LastActivityDate': '2013-08-04T05:39:58.010', 'LastEditDate': '2013-08-04T05:39:58.010', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13238', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7678', 'Tags': '<algorithms><algorithm-analysis><recurrence-relation>', 'CreationDate': '2013-07-12T04:38:44.167', 'Id': '13234'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '231', 'Title': 'Selection in expected linear time: Why am I getting $O(n)$ bound instead of $\\Omega(n \\lg n)$?', 'LastEditDate': '2013-07-22T04:53:45.530', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7678', 'Body': '<p>The problem is from CLRS 9.3-1:</p>\n\n<blockquote>\n  <p>In the algorithm <code>SELECT</code>, the input elements are divided into groups of\n  $5$. Argue that <code>SELECT</code> does not run in linear time if groups of $3$ are used.</p>\n</blockquote>\n\n<p>If we do the "divide by $3$" technique, we will come up with this recurrence -- </p>\n\n<p>$$T(n) = \\begin{cases}\n\\Theta(1) &amp; \\text{if $n \\le K$} \\\\\nT(\\lceil n/3 \\rceil)+T(2n/3+4) + O(n) &amp; \\text{if $n \\ge K$} \n\\end{cases}$$</p>\n\n<p>I have solved by substituting $T(n) \\le cn$ and  $O(n) = an$ --</p>\n\n<p>$$\\begin{aligned}\nT(n) &amp; \\le \\lceil n/3 \\rceil + c(2n/3 + 4) + an \\\\\n     &amp; \\le cn/3 + c + 2cn/3 + 4c + an \\\\\n     &amp; = cn + 5c + an \\\\\n     &amp; = (c+a)n + 5c \\\\\n     &amp; = c_1n + c_2 \\le c_1n \\approx O(n)\n\\end{aligned}$$</p>\n\n<p>But the solution says it should be $\\Omega(n \\lg n)$. I understand that substitution like $cn \\lg n$ could give $\\Omega(n \\lg n)$ bound, but what is wrong with $O(n)$ formulation above? </p>\n', 'ClosedDate': '2013-07-22T14:13:11.047', 'Tags': '<algorithm-analysis><recurrence-relation><search-algorithms>', 'LastEditorUserId': '7678', 'LastActivityDate': '2013-07-22T04:53:45.530', 'CommentCount': '2', 'AcceptedAnswerId': '13382', 'CreationDate': '2013-07-22T04:40:51.103', 'Id': '13381'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>One of my courses introduced the following question:</p>\n\n<blockquote>\n  <p>Given the recurrence relation for mergesort:</p>\n  \n  <p>$T(n) = 2T(n/2) + n$</p>\n  \n  <p>How would the following parameter passing strategies influence the relation and running time of the algorithm:</p>\n  \n  <ol>\n  <li><p>A pointer to the array is passed to the sorting function,</p></li>\n  <li><p>The entire array is copied to a separate location before applying the sorting function,</p></li>\n  <li><p>A subsection of the array is copied to a separate location before applying the sorting function on that subsection.</p></li>\n  </ol>\n</blockquote>\n\n<p>For 1., since this is how mergesort is used most of the time, we can solve it easily using the master theorem.</p>\n\n<p>$f(n) = \\Theta(n^{\\log_b a}) = \\Theta(n) \\implies T(n) = \\Theta(n \\log n)$</p>\n\n<p>For 2. however, I am a bit baffled. Although we do an additional work of $O(n)$, we are only doing so <em>once</em> at the beginning of the sort. Hence, doing one additional instance of $O(n)$ work should not influence the order of the running time (because it already <em>is</em> of a larger order). Hence, for both 2. and 3. the running time would remain at $T(n) = \\Theta(n \\log n)$. </p>\n\n<p>Is this reasoning valid? Something tells me that the $O(n)$ copying should have more of an impact, but I can't seem to give myself a good enough reason that it should be responsible to slow it down enough so that it would worse (i.e. $O(n^2)$). </p>\n\n<p>Any thoughts or hints would be quite appreciated!</p>\n", 'ViewCount': '134', 'Title': 'Do different variants of Mergesort have different runtime?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-16T07:58:23.627', 'LastEditDate': '2013-09-16T06:58:55.213', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14349', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10093', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><recurrence-relation><sorting>', 'CreationDate': '2013-09-12T03:25:30.877', 'Id': '14275'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Suppose an algorithm has a runtime recurrence relation:</p>\n\n<p>$   T(n) = \\left\\{\n     \\begin{array}{lr}\n       g(n)+T(n-1) + T(\\lfloor\\delta n\\rfloor ) &amp; : n \\ge n_0\\\\\n       f(n) &amp; : n &lt; n_0\n     \\end{array}\n   \\right.\n$  </p>\n\n<p>for some constant $0 &lt; \\delta &lt; 1$. Assume that $g$ is polynomial in $n$, perhaps quadratic. Most likely, $f$ will be exponential in $n$.</p>\n\n<p>How would one go about analyzing the runtime ($\\Theta$ would be excellent)? The master theorem and the more general Akra-Bazzi method do not seem to apply.</p>\n', 'ViewCount': '175', 'Title': "Asymptotic approximation of a recurrence relation (Akra-Bazzi doesn't seem to apply)", 'LastEditorUserId': '8877', 'LastActivityDate': '2013-11-13T19:26:31.243', 'LastEditDate': '2013-11-13T19:26:31.243', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8877', 'Tags': '<algorithm-analysis><runtime-analysis><recurrence-relation>', 'CreationDate': '2013-09-15T22:17:33.163', 'FavoriteCount': '1', 'Id': '14343'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I already have a solution for this problem but it's just not making sense to me. </p>\n\n<p>Here is the problem (It's from Introduction to Algorithms by CLRS found in CH.4): </p>\n\n<blockquote>\n  <p>Show $T(n) = 2T(\\lfloor n/2 \\rfloor +17)+n$  is $O(n \\log n)$</p>\n</blockquote>\n\n<p>This is what I have so far: </p>\n\n<p>So Assume $T(k) \\leq cn\\lg n$, for $k&lt;n$.</p>\n\n<p>$\\qquad \\begin{align*}\n  T(n) &amp;= 2T(\\lfloor n/2 \\rfloor +17)+n \\\\\n       &amp;\\leq 2c(\\lfloor n/2 \\rfloor +17)\\lg(\\lfloor n/2 \\rfloor + 17) +n \\\\\n       &amp;\\leq 2c(n/2 + 17) \\lg (n/2 + 17) + n \\\\\n       &amp;= c(n + 34) \\lg((n+34)/2)+ n\n\\end{align*}$</p>\n\n<p>And this is where I stop understanding what is going on. Looking at the solution to this problem tells me: </p>\n\n<blockquote>\n  <p>Note that $(n + 34)/2 \\leq (3n)/4$ for $n \\geq 68$\n  so that $\\lg((n + 34)/2) \\leq \\lg((3n)/4) = \\lg(n) + \\lg(3/4)$ for $n \\geq 68$.</p>\n</blockquote>\n\n<p>But it fails to tell me why/how we know that $(n+34)/2 \\leq 3n/4$ for $n \\geq 68$. Where did this number come from and how would I arrive at this if I did not know the solution beforehand? </p>\n", 'ViewCount': '1319', 'Title': 'Solving recurrences using substitution method', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-30T00:18:19.787', 'LastEditDate': '2013-09-16T08:49:52.240', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '14352', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10152', 'Tags': '<asymptotics><proof-techniques><recurrence-relation>', 'CreationDate': '2013-09-16T05:33:59.237', 'Id': '14347'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>We started learning recurrences and I am having trouble with some of the problems. Our professor is having us substitute in $n=2^m$ and $S(m)=T(2^m)$ then writing down equations and summing them all up. I understand the substitution part, but not how to simplify the end result.</p>\n\n<p>One of the problems I am stuck on is $T(n)=2T(n/2)+n^3$ where $T(2)=c$, When I sub in $n=2^m$ and $S(m)=T(2^m)$ I get:</p>\n\n<p>$S(m)=2S(m-1)+(2^m)^3$</p>\n\n<p>$S(m-1)=2S(m-2)+(2^{m-1})^3$</p>\n\n<p>...</p>\n\n<p>$S(3)=2S(2)+(2^{3})^3$</p>\n\n<p>$S(2)=2S(1)+(2^{2})^3$</p>\n\n<p>$S(1)=c$</p>\n\n<p>Now because there is a coefficient on the right side we have to multiply each equation by a power of 2 so we can sum them.</p>\n\n<p>$S(m)=2S(m-1)+(2^m)^3$</p>\n\n<p>$2*S(m-1)=2^2S(m-2)+2*(2^{m-1})^3$</p>\n\n<p>...</p>\n\n<p>$2^{m-3}*S(3)=2^{m-2}S(2)+2^{m-3}(2^{3})^3$</p>\n\n<p>$2^{m-2}*S(2)=2^{m-1}S(1)+2^{m-2}(2^{2})^3$</p>\n\n<p>$2^{m-1}S(1)=c*2^{m-1}$</p>\n\n<p>So sum these and we get:</p>\n\n<p>$S(m)=(2^m)^3+2*(2^{m-1})^3+2^2*(2^{m-2})^3+...+2^{m-3}(2^{3})^3+2^{m-2}(2^{2})^3+c*2^{m-1}$</p>\n\n<p>And this is where I get stuck, how can I simplify this? I tried dividing by $(2^m)^3$ but that came out to a awful mess. The other two I'm having trouble with are $T(n)=16T(n/4)+n^2$ and $T(n)=7T(n/2)+n^2$ Any help would be appreciated.</p>\n", 'ViewCount': '43', 'Title': 'Help with recurrence solutions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-17T07:58:09.693', 'LastEditDate': '2013-09-17T07:58:09.693', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14362', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10170', 'Tags': '<proof-techniques><recurrence-relation>', 'CreationDate': '2013-09-16T18:44:57.610', 'Id': '14361'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Consider the following sequence $a_n$:</p>\n\n<p>\\begin{align*}\n  a_0 &amp;= \\alpha \\\\\n  a_k &amp;= \\beta a_{k-1} + \\kappa\n\\end{align*}</p>\n\n<p>Now consider the implementation of this sequence via lisp:</p>\n\n<pre><code>(defun an (k)\n  (if (= k 0) alpha\n    (+ (* beta (an (- k 1))) kappa)))\n</code></pre>\n\n<p>What is the running time to compute <code>(an k)</code> just as it is written? Also, what would be the maximum stack depth reached? My hypothesis would be that both the running time and stack depth are $O(k)$ because it takes $k$ recursive calls to get to the base case and there is one call per step and one stack push per step.\\\n.</p>\n\n<p>Is this analysis corect?</p>\n', 'ViewCount': '50', 'Title': 'Running time and stack depth of a lisp recurrence', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-18T22:25:04.060', 'LastEditDate': '2013-09-18T22:25:04.060', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14425', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<algorithm-analysis><programming-languages><recurrence-relation>', 'CreationDate': '2013-09-18T19:00:44.293', 'Id': '14419'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '83', 'Title': 'How to solve for recurrence with substitution or other methods?', 'LastEditDate': '2013-09-23T03:11:57.373', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10289', 'Body': "<p>Forgive me if I am new, I am trying to learn how to solve recurrences.</p>\n\n<p>I have the following recurrence:</p>\n\n<p>$$T(n) = 2 T(\\lfloor\\frac{n}{3}\\rfloor) + \\frac{1}{2} T(\\lfloor\\frac{2n}{3}\\rfloor) + n^2 \\text{ if } n&gt;0$$</p>\n\n<p>Now from my understanding is that I am not able to use the following methods.</p>\n\n<ol>\n<li>Master Thereom (because it's not in the form $aT(\\frac{n}{b}) + f(n)$)</li>\n<li>Tree Method (because of the $\\frac{1}{2} T$, you cannot have a node of $\\frac{1}{2}$), please correct me if I am wrong.</li>\n</ol>\n\n<p>So which leaves me with the following method:</p>\n\n<p>Only the substitution method, but what I don't understand that is the fact that for the substitution method, you have to guess for the $f(n)$ to substitute into the recurrence.</p>\n\n<p>So my question is, how does one select the correct $f(n)$ to substitute?</p>\n", 'ClosedDate': '2013-09-23T07:27:35.290', 'Tags': '<asymptotics><recurrence-relation>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-09-23T06:47:52.253', 'CommentCount': '5', 'AcceptedAnswerId': '14547', 'CreationDate': '2013-09-23T02:28:36.440', 'Id': '14543'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am trying to understand how to solve complex recurrence relations and whether there is a general method or technique to help me. That being said I am not talking about recurrence relations that can be solved using the (generalized) <em>Master Theorem</em> or the <em>Akra\u2013Bazzi</em> method.</p>\n\n<p>This is by no means a "I have some homework to solve, please solve it for me" question. It is more at a conceptual level. I want to be able to solve and "see" through these relations with ease.</p>\n\n<p><strong>How do you efficiently calculate the time needed to solve a recurrence relation?</strong></p>\n\n<p>Is it something that, simply put, takes experience and personal intuition? Is there some cannon method that I am not aware of? Moreover, how do you go on to calculate the same relations for cases where you have <em>memoization</em>?</p>\n', 'ViewCount': '136', 'Title': 'Recurrence Relations', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-26T09:43:43.090', 'LastEditDate': '2013-09-26T09:43:43.090', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10341', 'Tags': '<recurrence-relation>', 'CreationDate': '2013-09-26T03:28:08.367', 'Id': '14618'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>How to solve the recurrence relation below?</p>\n\n<p>$$T(n) = \\begin{cases}\n             2T(\\sqrt{n}) + \\log n/\\log\\log n &amp; \\text{if } n &gt; 4\\\\\n             1 &amp; \\text{if } n \\leq 4.\n          \\end{cases}$$</p>\n\n<p>Preferably by the master theorem; otherwise by any method. I know the Master Theorem fails, but is there any extension for these type of problems?</p>\n', 'ViewCount': '86', 'Title': 'Solving a complicated recurrence relation', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-09-28T19:41:22.077', 'LastEditDate': '2013-09-28T17:41:17.130', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14657', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10380', 'Tags': '<recurrence-relation>', 'CreationDate': '2013-09-28T14:41:06.550', 'Id': '14655'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am trying to work out the recurrence relation for Ternary Search. This is what I came up with:</p>\n\n<pre><code>C(n) = C(n/3) + 2\n</code></pre>\n\n<p>However, I talked to my professor and he said it's not correct. He says that we need to take all of their cases into account. This part confuses me a little bit, can you please clear it for me?</p>\n\n<p>Thank you.</p>\n", 'ViewCount': '570', 'Title': 'Ternary Search Recurrence Relation', 'LastActivityDate': '2013-10-07T01:30:55.647', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14872', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<algorithms><recurrence-relation>', 'CreationDate': '2013-10-06T23:59:28.933', 'Id': '14869'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have some difficulty trying to tell which equation to use when I'm given an explanation on how an algorithm operates. Especially divide and conquer.</p>\n\n<p>Normally I see these kind of equations:</p>\n\n<pre><code>C(n) = aC(n/a) + b where a and b are constants\n</code></pre>\n\n<p>Other times I don't see the a in front of C(n/a) as an answer. That really confuses me.</p>\n\n<p>Can you tell me when I will need to use which?</p>\n\n<p>Thanks!</p>\n", 'ViewCount': '66', 'Title': 'Recurrence Equation Question', 'LastActivityDate': '2013-10-10T19:15:54.833', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14990', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<algorithms><recurrence-relation>', 'CreationDate': '2013-10-10T16:58:06.577', 'Id': '14989'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have done an assignment question which asks me to find the average case of pentary search. The one I came up with is:</p>\n\n<pre><code>C(n) = C(n/5) + 14/5\n</code></pre>\n\n<p>However, I got it wrong and the professor didn't really explain why.</p>\n\n<p>Can you help me?</p>\n\n<p>Thanks!</p>\n\n<p>Edit:</p>\n\n<p>Pentary search is dividing the array into 5 parts and look for a specific key.</p>\n\n<p>In perspective:</p>\n\n<p>1|2|3|4|4</p>\n\n<p>These are the number of comparisons made by the computer from pentary search.</p>\n\n<p>Adding all possible comparisons I get 14 over 5 slots. This is why I have 14/5</p>\n", 'ViewCount': '44', 'Title': 'Pentary Search Recurrence Relation', 'LastEditorUserId': '10398', 'LastActivityDate': '2013-10-14T02:40:21.000', 'LastEditDate': '2013-10-14T02:37:23.090', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<recurrence-relation><average-case>', 'CreationDate': '2013-10-14T00:06:20.280', 'Id': '16059'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Following up on <a href="http://cs.stackexchange.com/a/10373/98">vonbrand\'s answer</a> I want to write a small document about stronger master theorems for our students, one of which is the Akra-Bazzi theorem. I have copied the theorem from their paper [1] and found -- besides a small notational confusion\xb2 -- the following problem.</p>\n\n<p>The authors require (emphasis mine):</p>\n\n<blockquote>\n  <p>$g(x)$ is defined for real values $x$, and is <strong>bounded</strong>, positive and nondecreasing function\n  $\\forall x \\geq 0$</p>\n</blockquote>\n\n<p>Here, $g$ is the toll function, that is the recurrence has the form</p>\n\n<p>$\\qquad\\displaystyle T(n) = g(n) + \\sum_{i=1}^k a_i T\\bigl(\\lfloor n b_i^{-1} \\rfloor\\bigr)$.</p>\n\n<p>Now, at the end of their paper (p209) they give multiple examples for applying their result and they use functions in $\\Omega(n)$ which are clearly <em>not</em> bounded.</p>\n\n<p>From skimming the proof they mainly seem to require that integrals of the form</p>\n\n<p>$\\qquad\\displaystyle \\int_a^b \\frac{g(x)}{x^{p+1}} dx$</p>\n\n<p>have finite values. So, requiring $g$ to be bounded <em>on every compact interval</em> might be sufficient; I did not work through the proof in detail. Is it possible they mean that?</p>\n\n<p>My question is: How should the Akra-Bazzi theorem be stated so that it is consistent with proof <em>and</em> examples?</p>\n\n<hr>\n\n<ol>\n<li><a href="http://dx.doi.org/10.1023/A%3A1018373005182">On the solution of linear recurrence equations</a> by M. Akra and L. Bazzi (1998)</li>\n<li>They require $a_i \\in R^{*+}$. Is this some notation I don\'t know, or a typo? I assume the intended meaning is $(0,\\infty) \\subseteq \\mathbb{R}$.</li>\n</ol>\n', 'ViewCount': '69', 'Title': 'Why does Akra-Bazzi need that toll-function g is bounded?', 'LastActivityDate': '2014-01-11T00:22:27.687', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2013-11-11T14:29:28.533', 'Id': '17916'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>While thinking about <a href="http://cs.stackexchange.com/questions/14343/evaluating-recurrence-relation">this question</a> on a recurrence I checked out some stronger master theorems.\nUnfortunately, they do not seem to apply because terms</p>\n\n<p>$\\qquad\\displaystyle T(n) = \\dots + T(n-1) + \\dots$</p>\n\n<p>are not covered.</p>\n\n<ul>\n<li><p>Roura [1] investigates (in the discrete case) recurrences of the form</p>\n\n<p>$\\qquad\\displaystyle T(n) = t_n + \\sum_{1 \\leq d \\leq D} (w_d + r_{d,n}) \\cdot T(z_d n + s_{d,n})$</p>\n\n<p>where $\\sum |r_{d,n}|$ and $\\sum |s_{d,n}|/n$ have to vanish for $n \\to \\infty$ and, sadly, $0 &lt; z_d &lt; 1$. I did not go through the proof, but an application to <a href="http://cs.stackexchange.com/questions/14343/evaluating-recurrence-relation">the example at hand</a> yielded a quite clearly wrong result of $T \\in \\Theta(g)$, so this one does not carry over as is.</p></li>\n<li><p>Akra and Bazzi [2] consider only recurrences of the form</p>\n\n<p>$\\qquad\\displaystyle T(n) = g(n) + \\sum_{i=1}^k a_i T(\\lfloor n/b_i \\rfloor)$</p>\n\n<p>with $b_i \\geq 2$, so above parameter choice is clearly not covered.</p>\n\n<p>Leighton [3] introduces a more general form of Akra-Bazzi for recurrences of the form</p>\n\n<p>$\\qquad\\displaystyle T(x) = g(x) + \\sum_{i=1}^k a_iT(b_ix + h_i(x))$,</p>\n\n<p>but similarly requires that $b_i \\in (0,1)$. It seems to me that existence of $p$ as solution of</p>\n\n<p>$\\qquad\\displaystyle \\sum_{i=1}^k a_i b_i^p = 1$</p>\n\n<p>in Theorem 2 can no longer be guaranteed if there is one $b_i=1$ since all $a_i$ are positive.</p></li>\n<li><p>Drmota and Szpankowski [4] look at recurrences of the form</p>\n\n<p>$\\qquad\\displaystyle T(n) = a_n + \\sum_{j=1}^m b_jT(\\lfloor p_j n + \\delta_j \\rfloor)$</p>\n\n<p>with $0 &lt; p_j &lt; 1$. The proof does not explicitly use $p_j \\neq 1$. I am not too sure about the properties of several Dirichlet series (cf section 4.1) if some $p_j=1$, though.</p></li>\n</ul>\n\n<p>Does any of the theorems hold if there are recursive parameters of the form $T(n-c)$? Can one be adapted to cover such cases, or are there other, more general results that do so?</p>\n\n<hr>\n\n<ol>\n<li><a href="http://dx.doi.org/10.1007/3-540-63165-8_201" rel="nofollow">An improved master theorem for divide-and-conquer recurrences</a> by S. Roura (1997)</li>\n<li><a href="http://dx.doi.org/10.1023/A%3A1018373005182" rel="nofollow">On the solution of linear recurrence equations</a> by M. Akra and L. Bazzi (1998)</li>\n<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.39.1636&amp;rep=rep1&amp;type=pdf" rel="nofollow">Notes on Better Master Theorems for Divide-and-Conquer Recurrences</a> by T. Leighton (1996)</li>\n<li><a href="http://dl.acm.org/citation.cfm?id=2133036.2133064" rel="nofollow">A master theorem for discrete divide and conquer recurrences</a> by  M. Drmota and W. Szpankowski. (2011)</li>\n</ol>\n', 'ViewCount': '49', 'Title': 'Are there master theorems that deal with parameters of the form $n-c$?', 'LastActivityDate': '2013-11-12T14:27:37.343', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2013-11-12T14:27:37.343', 'Id': '17960'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have a practice exam question that I don't know how to set up a recurrence for. It is dealing with a hash table. The question is as follows:</p>\n\n<blockquote>\n  <p>Suppose that a hashing strategy is designed so that it starts with an initial hash table size of $H= 8$. You may assume that only insertions are performed (no deletions).</p>\n  \n  <p>Any time the hash table is going to be more than 50% full (when an attempt is made to add item $\\frac{H}{2} + 1$ to a table of size $H$), the hash table size is doubled to $2\\times H$, and then the $\\frac{H}{2}$ keys in the previous hash table are rehashed using $\\frac{H}{2}$ extraneous key insertions into the new table of size $2 \\times H$. The key insertions used to initially place each key into the hash table are called necessary key insertions (these are not extraneous).</p>\n</blockquote>\n\n<p>The question is asking to derive a recurrence relation $E(H)$ for the number of extraneous key insertions that have occurred in total up until the point in time that the hash table size is $H$ and to explain where the terms in the recurrence relation derive from.</p>\n\n<p>If someone could help me out with this, it would provide very helpful as I am practicing for an exam that I have in a week. Thanks everyone.</p>\n\n<p>I got the result $E(H)=2\\times E(\\frac{H}{2})$ because after each rehash there are $\\frac{H}{2}$ extraneous key insertions being put into the table of size $2\\times H$. So if the size is twice the amount of $H$, I figured the recurrence would be $E(H)=2\\times E(\\frac{H}{2})$. I only posted here because I was hoping someone could assist me with this because this question has me a bit stumped. </p>\n", 'ViewCount': '81', 'Title': 'Recurrence for total number of extraneous key insertions in a hash table', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T08:41:25.867', 'LastEditDate': '2014-03-26T08:41:25.867', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11491', 'Tags': '<data-structures><runtime-analysis><recurrence-relation><hash-tables>', 'CreationDate': '2013-11-20T00:24:50.667', 'Id': '18178'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>consider following code</p>\n\n<pre><code>int f(int x)\n{\n  if(x&lt;1) return 1;\n  else return f(x-1)+g(x);\n}\nint g(int x)\n{\n  if(x&lt;2) return 1;\n  else return f(x-1)+g(x/2);\n}\n</code></pre>\n\n<p><b>Questions:</b></p>\n\n<blockquote>\n  <p>How do I find the growth of <code>f(x)</code>, being that it contains a recursion to another function?</p>\n  \n  <p>Are growth and time complexity of a a function same thing? Are they the same for <code>f(x)</code>?</p>\n</blockquote>\n', 'ViewCount': '147', 'Title': 'Finding growth of "inter-recursive" functions', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-27T07:04:48.907', 'LastEditDate': '2013-11-24T01:34:40.410', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10380', 'Tags': '<algorithm-analysis><recurrence-relation><recursion>', 'CreationDate': '2013-11-23T19:07:15.820', 'FavoriteCount': '1', 'Id': '18283'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This is a practice problem I\'ve come up with in order to study for an exam I have in a couple of hours.</p>\n\n<p>Again, here\'s the problem: Show T(n) = 2T(n-1) + k is O(2^n) where k is some positive constant.</p>\n\n<p>First of all, 2^n is indeed the upperbound, right? Since I\'ve made this problem up myself, I\'m not 100% sure, but from what I have seen, this should be O(2^n).</p>\n\n<p>If so, here\'s my progress:</p>\n\n<p>We want to show P(n) is true for all n > n0, where P(n) is the statement "T(n) &lt;= c * 2^n" (for some fixed c, to be determined)</p>\n\n<p>For now, let\'s fix c at T(1).</p>\n\n<p>Base case: n = 1</p>\n\n<p>We want to show T(1) &lt;= c * 2. Since c = T(1), our equation becomes T(1) &lt;= T(1) * 2, which is trivially true.</p>\n\n<p>Inductive step: Assume P(n - 1) is true for n > 1. We want to show that P(n) holds.</p>\n\n<pre><code>T(n) = 2 T(n - 1) + k, by definition\n    &gt;= 2 (c * 2^(n-1) ) + k = c * 2^n + k\n</code></pre>\n\n<p>Here\'s where I get stuck. How can we possibly show that c * 2^n + k &lt;= c * 2^n for any value of c? Did I make a mistake somewhere?</p>\n', 'ViewCount': '74', 'Title': 'How do I show T(n) = 2T(n-1) + k is O(2^n)?', 'LastActivityDate': '2013-12-12T08:07:34.127', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '18901', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12042', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2013-12-11T21:55:26.153', 'Id': '18900'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Would I use the third case of the <a href="http://en.wikipedia.org/wiki/Master_theorem" rel="nofollow">Master Theorem</a> for the recurrence equation $T(n) = 2T(n/2) + n^{2}\\log n$? </p>\n\n<p>The condition given for the third case by Wikipedia is $f(n) = \\Theta(n^c)$ when $c &gt; \\log_{b}a$.</p>\n', 'ViewCount': '71', 'Title': 'Master theorem for $T(n) = 2T(n/2) + n^{2}\\log n$', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-12-18T01:01:04.520', 'LastEditDate': '2013-12-18T01:01:04.520', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19079', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12197', 'Tags': '<recurrence-relation><master-theorem>', 'CreationDate': '2013-12-18T00:03:19.577', 'Id': '19077'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am getting confused with the solution to this recurrence - \n$T(n) = T(n/2) + n^2$</p>\n\n<p>Recursion tree - </p>\n\n<pre><code>T(n)                      Height lg n + 1\n |\nT(n/2)\n |\nT(n/4)\n</code></pre>\n\n<p>So it turns out to be -</p>\n\n<p>$T(n) = n^2(1 + 1/4 + (1/4)^2) + \\ldots (1/4)^{\\log_2 n - 1})$</p>\n\n<p>$T(n) = 4*n^2(1- (1/4)^{\\log_2 n})/3 + n^2 $</p>\n\n<p>$T(n) = 4*n^2(1 - 1^{\\log_2 n} + 4^{\\log_2 n})/3 + n^2 $</p>\n\n<p>$ T(n) = 4*n^2(1 - 1 + n^{\\log_2 4})/3 + n^2$</p>\n\n<p>$ T(n) = 4*n^2(n^2)/3 + n^2$</p>\n\n<p>$ T(n) = 4/3 * (n^4) + n^2 $</p>\n\n<p>$ T(n) = \\Theta(n^4) $</p>\n\n<p>But according to the Master theorem, $a = 1, b = 2, f(n) = n^2 $, then $n^{\\log_2 1} = 1 $ which is polynomial times less than $ n^2 $ so the solution should be $ \\Theta (n^2) $?</p>\n', 'ViewCount': '113', 'Title': 'Solution to recurrence $T(n) = T(n/2) + n^2$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-29T04:07:39.913', 'LastEditDate': '2013-12-27T15:57:15.230', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '19319', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11750', 'Tags': '<recurrence-relation><recursion><master-theorem>', 'CreationDate': '2013-12-27T01:22:05.733', 'Id': '19318'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I recently was introduced to solving recurrence bounds by substitution but there's something i don't understand about it.</p>\n\n<p>In standard induction proofs you prove a base case, assume it holds for n then show it holds for n+1 and therefore show it applies to integers larger than the base case.</p>\n\n<p>For when you solve recurrences like T(n) = T(n/2) the proof has a base, assumes T(n/2) then proves it holds for T(n). Does this proof not only hold for the numbers that are multiples of two of the base cases? Would this not require an infinitely large number of base cases to show what it holds for?</p>\n\n<p>Could someone please explain this to me?</p>\n", 'ViewCount': '108', 'Title': 'How to apply the substitution method to n/2?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T09:04:11.990', 'LastEditDate': '2014-01-20T08:51:55.257', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Shawn', 'PostTypeId': '1', 'Tags': '<proof-techniques><recurrence-relation><induction>', 'CreationDate': '2014-01-20T03:23:36.953', 'Id': '19840'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a recursive algorithm defined by the following recursion.</p>\n\n<p>$$T(n) = T(n/f(n)) + O(\\log f(n)).$$</p>\n\n<p>I want to find the function $f$ that minimizes $T(n)$. If $f$ is a constant then $T(n) = \\Theta(\\log n)$. If $f = O(n)$ then $T(n) = \\Theta(\\log n)$. Is this true for all functions $f$ that $T(n) = \\Omega(\\log n)$ or can I get asymptotically better behaviour for some $f$? The reason I think there might be is that you can look at an extended binary search where you split your domain into $f(n)$ sections and then examine each section to see if your value is in that section. This recursion can be presented as follows:</p>\n\n<p>$$T(n) = T(n/f(n)) + O(f(n)).$$</p>\n\n<p>Binary search clearly runs in logarithmic time or worse for all values of $f$. This is the same as my recursion except that it is linear in $f$ instead of logarithmic. So you might expect better behaviour. </p>\n', 'ViewCount': '28', 'Title': 'Pick parameter function that minimises whole function', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T02:10:02.690', 'LastEditDate': '2014-01-26T02:10:02.690', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19978', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13133', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2014-01-25T23:10:07.513', 'Id': '19975'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '76', 'Title': 'Why can any polynomial and exponential be represented as a recurrence?', 'LastEditDate': '2014-02-02T13:14:44.100', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Hassan', 'PostTypeId': '1', 'OwnerUserId': '13032', 'Body': '<p>I posted <a href="http://math.stackexchange.com/questions/654458/recurrence-relation-for-polynomial-and-exponential">this question on math.SE</a> but I haven\'t got any reply so I\'m posting here also.</p>\n\n<p>I am reading The Algorithm Design Manual by Steven S Skiena.</p>\n\n<p>In Section 4.10.1 Recurrence Relations, I understand what a recurrence relation is, but after that following statements have been given:</p>\n\n<blockquote>\n  <p>Any polynomial can be represented by a recurrence, such as the linear function:<br>\n  $a_n = a_{n-1} + 1, a_1 = 1 \\implies a_n = n$ </p>\n  \n  <p>Any exponential can be represented by a recurrence:<br>\n  $a_n = 2a_{n-1}, a_1 = 1 \\implies a_n = 2^{n-1}$</p>\n</blockquote>\n\n<p>Can anyone explain me the above statements by proving them for any linear function and exponential function, respectively?</p>\n\n<p>EDITED : After help from <a href="http://cs.stackexchange.com/users/98/raphael">Raphael</a> and <a href="http://cs.stackexchange.com/users/683/yuval-filmus">Yuval Filmus</a> , I concluded following prove. Correct me if I am wrong \n<hr />\nFor any Liner function, General form is $a_n = \\alpha n + \\beta$<br>\n$a_n - a_{n-1} = \\alpha n + \\beta - (\\alpha (n-1) + \\beta)$<br>\n$a_n - a_{n-1} = \\alpha n + \\beta - \\alpha n + \\alpha - \\beta$<br>\n$a_n - a_{n-1} = \\alpha \\implies a_n = a_{n-1} +\\alpha $<br>\nAs relation holds in question,  $a_n = a_{n-1} + 1 \\implies \\alpha = 1 $<br>\nNow,<br>\n$a_{n-1} = a_{n-2} + \\alpha , a_{n-2} = a_{n-3} + \\alpha , a_{n-3} = a_{n-4} + \\alpha , ...$<br>\nTherefore, we can expres $a_{n}$ in terms of $a_{n-2}$ and so on<br>\n$a_{n} = a_{n-2} + \\alpha + \\alpha \\implies a_{n} = a_{n-2} + 2\\alpha $<br>\nWe can generalize<br>\n$a_{n} = \\alpha + (n-1)\\alpha  \\implies a_{n} = n\\alpha $<br>\nAs $\\alpha = 1 \\implies a_{n} = n$\n<hr />\nFor Exponential, General form is $a_n = cb^n$<br>\n$a_n - a_{n-1} = cb^n - cb^{n-1} \\implies a_n - a_{n-1} = cb^n - cb^n . b^{-1}$<br>\n$a_n - a_{n-1} = cb^n\\left(1 - \\dfrac{1}{b}\\right) $<br>\nSubstitute  $a_n = cb^n$<br>\n$a_n - a_{n-1} = a_n\\left(1 - \\dfrac{1}{b}\\right) $<br>\n$a_{n-1} = \\dfrac{a_n}{b} \\implies a_{n} = ba_{n-1}  $<br>\nAs relation holds in question,  $a_n = 2a_{n-1}  \\implies b = 2 $<br>\nNow, $a_n = cb^n \\implies a_1 = cb^1$<br>\nSubstitute $a_1 = 1$ and $b=2 \\implies c = \\dfrac{1}{2}$<br>\nSubstitute c and b in general form i.e. $a_n = cb^n$<br>\n$a_n = \\dfrac{1}{2}2^n \\implies a_n =2^n2^{-1} \\implies a_n = 2^{n-1} $</p>\n', 'Tags': '<recurrence-relation><discrete-mathematics>', 'LastEditorUserId': '13032', 'LastActivityDate': '2014-02-02T13:14:44.100', 'CommentCount': '3', 'AcceptedAnswerId': '20120', 'CreationDate': '2014-01-30T13:11:18.567', 'Id': '20119'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to analyze the runtime of this algorithm:</p>\n\n<pre><code>int fun (int arr[], int n) {\n    int result = 1;\n    int i, j;\n\n    if (n == 1)\n        return 1;\n\n    else {\n            result = fun(arr, 2n/3);\n            for (i = 1; i &lt;= sqrt(n); i=i*2);\n                for (j=0; j&lt;sqrt(n)/i; j++)\n                    result += arr[j];\n\n            return result;\n    }\n}\n</code></pre>\n\n<p>I can see that the runtime recurrence should be something like </p>\n\n<p>$\\qquad\\displaystyle T(n) = T\\left(\\frac{2n}{3}\\right) + \\Theta(X)$</p>\n\n<p>where $X$ is the time of the extra operations per recursion.</p>\n\n<p>I can also see that the extra operations are:</p>\n\n<p>$\\qquad\\begin{align*}\n  \\sum_{i=1}^{\\log(\\sqrt{n})} \\sum_{j=0}^{\\frac{\\sqrt{n}}{i}}1 \n    &amp;= \\sum_{i=1}^{\\log(\\sqrt{n})}\\frac{\\sqrt{n}}{i} \\\\\n    &amp;= \\sqrt{n} \\cdot \\sum_{i=1}^{\\log(\\sqrt{n})} \\frac{1}{i} \\\\\n    &amp;= \\sqrt{n}\\cdot \\log(\\log(\\sqrt{n}))\n\\end{align*}$</p>\n\n<p>So all in all:</p>\n\n<p>$\\qquad\\begin{align*}\n  T(1) &amp;= 1 \\\\\n  T(n) &amp;= T\\left(\\frac{2n}{3}\\right) + \\sqrt{n}\\cdot \\log(\\log(\\sqrt{n}))\n\\end{align*}$</p>\n\n<p>But I could not continue from here to solve this recursion.</p>\n', 'ViewCount': '57', 'Title': 'Runtime analysis of a recursive algorithm with a tricky amount of work per recursive call', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-05T09:42:21.443', 'LastEditDate': '2014-02-05T09:42:21.443', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21313', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10875', 'Tags': '<algorithm-analysis><runtime-analysis><recurrence-relation>', 'CreationDate': '2014-02-05T07:31:18.833', 'Id': '21311'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>The problem statement is as follows:-</p>\n\n<blockquote>\n  <p>In a court case, a judge cited a court of contempt and ordered a fine of $2 for first day.\n  On subsequent days, the fine would be equal to the square of the previous day's fine.\n  e.g. 2, 4, 16, 256 and so on.\n  Find out:-</p>\n  \n  <p>a) What would be the fine on day $n$?</p>\n  \n  <p>b) How many days would it take the fine to reach $D$ dollars?</p>\n</blockquote>\n\n<p>A big Oh answer would be appreciated.</p>\n", 'ViewCount': '55', 'ClosedDate': '2014-02-16T18:08:24.370', 'Title': 'Series where each term is square of previous', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-08T17:02:58.430', 'LastEditDate': '2014-02-08T17:02:58.430', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14505', 'Tags': '<recurrence-relation>', 'CreationDate': '2014-02-08T16:26:20.727', 'Id': '21452'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '37', 'Title': 'Recurrence relation in 2 variables', 'LastEditDate': '2014-02-20T13:39:25.047', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1100', 'FavoriteCount': '1', 'Body': '<p>When analyzing an algorithm, the following recurrence relation popped up:</p>\n\n<p>$T(n,d)=2T(n/2,d)+T(n,d-1)+O(dn)$</p>\n\n<p>where $T(n,1)=O(n \\log{n})$ and $T(1,d)=O(d)$.</p>\n\n<p>By applying the Master Theorem inductively, for any particular $d$, it holds that $T(n,d)=O(n (\\log{n})^d)$. However, it does not necessarily hold that $T(n,d)=O(n (\\log{n})^d)$ because the constant hidden by the $O$-notation depends on the value of $d$.</p>\n\n<p>I was hoping that the technically incorrect bound given by repeated application of the master theorem would be good enough. It turns out that this is actually a terrible, terrible bound. The actual values of $T(n,d)$ are orders of magnitude lower from what the asymptotic bound would predict. Does anyone know how to get a better bound?</p>\n', 'Tags': '<time-complexity><asymptotics><recurrence-relation>', 'LastEditorUserId': '14720', 'LastActivityDate': '2014-02-20T13:39:25.047', 'CommentCount': '3', 'AcceptedAnswerId': '21817', 'CreationDate': '2014-02-19T14:17:23.563', 'Id': '21812'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '44', 'Title': 'How to solve recurrences involving log?', 'LastEditDate': '2014-02-23T20:30:26.173', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'Happy', 'PostTypeId': '1', 'OwnerUserId': '14963', 'FavoriteCount': '1', 'Body': '<p>For example, </p>\n\n<p>$T(n) = \\log {n} \\cdot T(\\frac{n}{\\log{n}}) + \\Theta(n)$</p>\n\n<p>I tried using the substitution method with $ n = 2^m $, but that got me nowhere, since it still ends up with a $m$ <em>and</em> $2^m$. The recurrence tree method also becomes rather complicated. Is there a general approach to follow to solve such recurrences?</p>\n', 'Tags': '<asymptotics><recurrence-relation>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-23T20:30:26.173', 'CommentCount': '2', 'AcceptedAnswerId': '21953', 'CreationDate': '2014-02-11T11:51:01.843', 'Id': '21947'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '32', 'Title': 'Recurrence $T(n) = 2T(\\sqrt{n}) + \\log n$', 'LastEditDate': '2014-02-23T18:05:27.533', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14960', 'Body': "<p>So I have a question for the recurrence $T(n) = 2T(\\sqrt{n}) + \\log n$. We are to use substitution method to figure out the solution. This is an example problem (not a exercise problem) in my book (<em>Introduction to Algorithms</em>, Third Edition pg. 86). I'm having a hard time understanding how they rename $m = \\log n$. </p>\n\n<p>They then get the new equation $T(2^m) = 2T(2^{m/2}) + m$. I see that turning the $m = \\log n$ into $2^m = 2^{\\log n}$ and using the property $a^{\\log b} = b^{\\log a}$ so you get $2^m = n^{\\log 2}$ which goes to $2^m = n$ and hence $\\sqrt{n} = 2^{m/2}$. </p>\n\n<p>My question is, how do you know to guess to substitute $m$ for $\\log n$?</p>\n", 'ClosedDate': '2014-02-23T20:29:06.153', 'Tags': '<recurrence-relation>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-23T18:09:23.443', 'CommentCount': '0', 'AcceptedAnswerId': '21950', 'CreationDate': '2014-02-23T17:56:41.880', 'Id': '21948'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>My question here is dealing with the residual that I get. We are trying to prove $T(n) = 3T(n/3) + n$ is $O(n*\\log n)$. So where I get is $T(n) \\le cn[\\log n - \\log 3] + n$. So my residual is $-cn\\log 3 +  n$. So if I minus it I get $-(cn\\log 3 -n) \\ge 0$ right? How do I figure out what values of c &amp; n are? Do I use the base case? And as long as my negative residual is greater than 0 then my desire is correct because as n grows large then the residual doesn't matter? </p>\n", 'ViewCount': '81', 'ClosedDate': '2014-04-01T22:01:50.313', 'Title': 'Recurrence Problem $T(n) = 3T(n/3) + n$', 'LastActivityDate': '2014-02-24T14:02:24.873', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '21967', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14960', 'Tags': '<complexity-theory><recurrence-relation>', 'CreationDate': '2014-02-23T19:00:59.080', 'Id': '21952'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>$$T(n) = 2\\cdot \\sqrt{n} \\cdot T(\\sqrt{n}) + \\Theta (\\lg n)$$</p>\n\n<p>I have been trying to solve this question but I could not find anything.</p>\n\n<p>My approach:</p>\n\n<p>$n = 2^k$  </p>\n\n<p>$S(k) = T(2^n)$ and $S(k/2) = T(2^{n/2})$</p>\n\n<p>Finally:\n$S(k) = 2^{1+k/2} \\cdot S(k/2) + c \\cdot \\lg(k)  $</p>\n\n<p>After that, I tried to build recursion tree but I can not find the sum. Do you have any ideas?</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '41', 'Title': 'Recursive Algorithm Analysis', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-01T23:16:46.310', 'LastEditDate': '2014-03-01T18:10:05.717', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11588', 'Tags': '<recurrence-relation>', 'CreationDate': '2014-03-01T17:52:12.730', 'Id': '22162'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was working on recurrence relation and came across this example </p>\n\n<p>T(n) = 2T(n/2) + log(n)</p>\n\n<p>What will be the time complexity, ie, big O for this relation.</p>\n\n<p>Thanks for any help in advance.</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-03-04T07:40:38.087', 'Title': 'Time complexity by solving recurrence relation', 'LastActivityDate': '2014-03-04T02:42:47.407', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15253', 'Tags': '<time-complexity><recurrence-relation>', 'CreationDate': '2014-03-04T02:42:47.407', 'Id': '22252'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>$$T(n) = 2\\cdot \\sqrt{n} \\cdot T(\\sqrt{n}) + \\Theta ( n)$$</p>\n\n<p>I have been trying to solve this question but I could not find anything.</p>\n\n<p>I tried to build recursion tree but I can not find the sum. Do you have any ideas?</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '20', 'ClosedDate': '2014-03-05T07:27:54.167', 'Title': 'Time Complexity Problem', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-05T07:57:55.240', 'LastEditDate': '2014-03-05T07:57:55.240', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11588', 'Tags': '<recurrence-relation>', 'CreationDate': '2014-03-05T06:41:44.253', 'Id': '22293'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to wrap my head around recursion and divide and conquer algorithms. Can someone provide a proof and explanation of how many times a list of n elements can be divided in 1/2 on both sides.. In other words the total number of half divisions in a recursive divide procedure on a list of size n. </p>\n', 'ViewCount': '59', 'ClosedDate': '2014-03-27T08:00:03.037', 'Title': 'How many times can you divide a list of n elements in 1/2', 'LastActivityDate': '2014-03-15T22:31:08.997', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '22660', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14847', 'Tags': '<recurrence-relation><recursion><divide-and-conquer>', 'CreationDate': '2014-03-15T19:25:02.470', 'Id': '22656'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '137', 'Title': 'Solve the recurrence $f(n+1)=f(n)^2,\\, f(0)=2$', 'LastEditDate': '2014-03-17T02:31:23.060', 'AnswerCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15733', 'Body': "<p>I have a problem with an exercise asking me to solve the following recurrence:\n$$f(n+1)=f(n)^2, \\quad f(0)=2$$\nCan someone explain how to solve this? I tried but couldn't.</p>\n", 'ClosedDate': '2014-03-17T15:58:41.800', 'Tags': '<algorithms><recurrence-relation>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-17T14:25:31.523', 'CommentCount': '4', 'AcceptedAnswerId': '22659', 'CreationDate': '2014-03-15T19:30:10.380', 'Id': '22657'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '43', 'Title': 'Solve recurrence', 'LastEditDate': '2014-03-16T16:11:33.010', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15733', 'FavoriteCount': '0', 'Body': "<p>![enter image description here][1]</p>\n\n<p>I have a problem to solve this recurrence. I tried by myself but it doesn't look understandable. Solve the following recurrence</p>\n", 'ClosedDate': '2014-03-16T16:14:27.257', 'Tags': '<algorithms><recurrence-relation>', 'LastEditorUserId': '15733', 'LastActivityDate': '2014-03-16T16:11:33.010', 'CommentCount': '6', 'AcceptedAnswerId': '22678', 'CreationDate': '2014-03-16T13:53:38.090', 'Id': '22675'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've searched online for this but I only seem to find answers for a similar equation: </p>\n\n<pre><code>T(n) = T(n/3) + T(2n/3) + cn\n</code></pre>\n\n<p>But the one I'm trying to solve is:</p>\n\n<pre><code>T(n) = T(n/3) + T(2n/3)\n</code></pre>\n\n<p>Base case: We can assume <code>T(a) = Theta(1)</code> for any constant <code>a</code>.</p>\n\n<p>I've succeeded in proving (by induction) that <code>T(n) = O(n*log(n))</code>. I thought the answer should be <code>Theta(n*log(n))</code>, but I cannot prove that <code>T(n) = Omega(n*log(n))</code>.</p>\n\n<p>So my question is - am I correct that the answer is <code>O(n*log(n))</code>, and NOT <code>Theta(n*log(n))</code>? IF that's true that would really be great...</p>\n\n<p>If I'm wrong I will of course explain where I'm stuck in the induction process...</p>\n\n<p>Thanks!</p>\n\n<p>P.S. If you need to, please try to explain using induction, because I haven't learned all methods for solving these problems yet.</p>\n", 'ViewCount': '64', 'ClosedDate': '2014-03-20T09:00:30.173', 'Title': 'Recurrence of T(n) = T(n/3) + T(2n/3)', 'LastActivityDate': '2014-03-19T21:53:26.597', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15868', 'Tags': '<algorithm-analysis><data-structures><runtime-analysis><recurrence-relation>', 'CreationDate': '2014-03-19T14:46:24.537', 'Id': '22809'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I need to make a recursive relationship for a function <code>f(m, n)</code> nonrecursive to make it more efficient and succinct in my code.</p>\n\n<p>I stumbled across an important recurrence relationship dealing with the number of vertices, edges, faces, and solids (<a href="http://en.wikipedia.org/wiki/Polytope" rel="nofollow">m-polytopes</a>) in an n-cube which is based off of a simpler algorithm for an n-simplex which uses Pascal\'s triangle:</p>\n\n<p>For a simplex:\nnCm gives you the number of m-polytopes (m = 1 for points, 2 for lines, 3 for faces) in an n-simplex (1-simplex is a line, 2-simplex is a triangle, 3-simplex is a tetrahedron).</p>\n\n<p>The pattern between the n-simplex m-polytopes and the n-cube m-polytopes are very similar:</p>\n\n<pre><code>Here is the n-cube up to 10\n10-polytopes:                                                            \n9-polytopes:                                                           1\n8-polytopes:                                                     1    16\n7-polytopes:                                               1    14   112\n6-polytopes:                                         1    12    84   448\n5-polytopes:                                   1    10    60   280  1120\n4-polytopes:                             1     8    40   160   560  1792\n3-polytopes:                       1     6    24    80   240   672  1792\n2-polytopes:                 1     4    12    32    80   192   448  1024\n1-polytopes:           1     2     4     8    16    32    64   128   256\nHere is the n-simplex up to 10\n10-polytopes:                                                            \n9-polytopes:                                                           1\n8-polytopes:                                                     1     9\n7-polytopes:                                               1     8    36\n6-polytopes:                                         1     7    28    84\n5-polytopes:                                   1     6    21    56   126\n4-polytopes:                             1     5    15    35    70   126\n3-polytopes:                       1     4    10    20    35    56    84\n2-polytopes:                 1     3     6    10    15    21    28    36\n1-polytopes:     1     1     2     3     4     5     6     7     8     9\n</code></pre>\n\n<p>And here is the c code that generated that:</p>\n\n<pre><code>#include &lt;stdio.h&gt;\n\n#define TOP 10\n\n// nothing to see here\nint factorial(int n)\n{\n    if (n &lt; 2)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n// a recursive implementation for the number of \n// m-polytopes in an n-cube\nint ncubeRecursive(int n, int m)\n{\n    if (n == 0 &amp;&amp; m == 0)\n        return 1;\n    else if(n &lt; 0 || m &lt; 0)\n        return 0;\n    else\n    {\n        return (ncubeRecursive(n - 1, m - 1) + 2 * ncubeRecursive(n - 1, m));\n    }\n}\n// missing a nonrecursive algorithm\n// YOUR JOB TO FIX THIS\n\n\n// a recursive implementation for the number of\n// m-polytopes in an n-simplex\nint nsimplexRecursive(int n, int m)\n{\n    if (n == 0 &amp;&amp; m == 0)\n        return 1;\n    else if(n &lt; 0 || m &lt; 0)\n        return 0;\n    else\n    {\n        return (nsimplexRecursive(n - 1, m - 1) + nsimplexRecursive(n - 1, m));\n    }\n}\n// a nonrecursive algorithm\nint nsimplexNonrecursive(int n, int m)\n{\n    return factorial(n)/(factorial(n - m) * factorial(m));\n}\n\nint main()\n{\n    printf("Here is the n-cube up to %i\\n", TOP);\n    for (int n = TOP; n &gt; 0; --n)\n    {\n        printf("%i-polytopes:", n);\n        for (int m = 0; m &lt; TOP; ++m)\n        {\n            int val = ncubeRecursive(m, n);\n            if (val == 0)\n                printf("%6c", \' \');\n            else\n                printf("%6i", val);\n        }\n        printf("\\n");\n    }\n    printf("Here is the n-simplex up to %i\\n", TOP);\n    for (int n = TOP; n &gt; 0; --n)\n    {\n        printf("%i-polytopes:", n);\n        for (int m = 0; m &lt; TOP; ++m)\n        {\n            int val = nsimplexNonrecursive(m, n);\n            if (val == 0)\n                printf("%6c", \' \');\n            else\n                printf("%6i", val);\n        }\n        printf("\\n");\n    }\n\n    return 0;\n}\n</code></pre>\n\n<p>Does anyone here see a non-recursive pattern? I just don\'t know how to analyze a recursive relationship like this for a function that takes to inputs like <code>f(m, n)</code> instead of just <code>f(x)</code>. </p>\n', 'ViewCount': '44', 'ClosedDate': '2014-03-24T18:49:20.950', 'Title': 'How to make this recursive relationship nonrecursive?', 'LastActivityDate': '2014-03-20T18:03:35.190', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22874', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15918', 'Tags': '<algorithms><combinatorics><computational-geometry><recurrence-relation>', 'CreationDate': '2014-03-20T15:28:41.100', 'Id': '22869'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am trying to find the worst case $\u0398$ bound for the following recurrence equation:\n$$\nT(n)=\\sum_{i=1}^kT(a_i)+n+\\lg k\\sum_{i=1}^ka_i\\quad\nwhere\\quad n=1+\\sum_{i=0}^ka_i\\quad and\\quad\na_0\\ge a_1, a_2, \\dots,a_k\\ge 1\n$$\nBy master theorem, with $k=a_0=a_1=n/3$ and $a_2=a_3=\\dots =a_k=1$, $T(n)=\u0398(n\\lg n)$. Now my freind and I guessed that the worst case of $T(n)$ is also $\u0398(n\\lg n)$, but we are not able to prove it.</p>\n\n<p>My question is, what is the worst case bound of $T(n)$ and how to prove it?</p>\n\n<p><strong>Edit</strong>: By worst case I mean that $T(n)$ to be the <em>maximum</em> of the expression I wrote over all $k\\ge1$ and $a_0\\ge a_1,a_2,\\dots,a_k\\ge1$ such that $n=1+a_0+\\dots+a_k$.</p>\n', 'ViewCount': '56', 'Title': 'Solve the worst case of this recurrence equation', 'LastEditorUserId': '9249', 'LastActivityDate': '2014-03-22T03:43:09.767', 'LastEditDate': '2014-03-22T02:01:10.610', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9249', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2014-03-21T10:35:07.460', 'FavoriteCount': '1', 'Id': '22898'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>How can I find the tightest possible asymptotic bounds on the recurrence T(n) = 3T(n/2)+cn, where <em>c</em> is a positive constant. Must use iteration method.</p>\n', 'ViewCount': '16', 'ClosedDate': '2014-03-26T08:44:43.887', 'Title': 'Iteration method - recurrence', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T08:45:12.010', 'LastEditDate': '2014-03-26T08:45:12.010', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user16139', 'PostTypeId': '1', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2014-03-26T05:02:45.943', 'Id': '23063'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I met a recurrence equation for my algorithm \n$$ f(n) = 2\\cdot \\left( f(n-1) + f(\\frac{n}{2}) \\right)$$\nwith $f(1)=1$, $f(2)=4$, $f(3)=10$. </p>\n\n<p>I guess it is $\\Theta((2+\\epsilon)^n)$, where $\\epsilon$ ban be arbitrarily close to 0. \nI want to have an asymptotic formula of $f(n)$. I do not know how to prove or disprove my guess. </p>\n', 'ViewCount': '37', 'Title': 'Bounding the recurrence $f(n)=2f(n-1)+2f(n/2)$', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-09T20:13:22.223', 'LastEditDate': '2014-04-09T20:13:22.223', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23608', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '646', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2014-04-09T19:27:31.053', 'Id': '23607'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have done the proof until the point when $T(n) \\leq cn^{\\log7}$.</p>\n\n<p>But when it comes to finding the value of constant $c$, I am getting stuck.</p>\n\n<p>The given recurrence relation is $T(n) = 7T(n/2) + n^2$. </p>\n\n<p>Since we already calculated the solution above which is $cn^{\\log 7}$.</p>\n\n<p>Inductive step:</p>\n\n<p>Now we have to prove that $T(n) \\leq c n^{\\log7}$ where $c$ is a positive constant.\nIf we consider that the solution holds good for $n/2$ then we can prove that it works  for $n$ also: \n$$T(n/2) \\leq c(n/2)^{\\log7}.$$\nSubstituting these values in the recurrence relation:</p>\n\n<p>$$\n\\begin{align*}\nT(n) &amp;\\leq 7c/(2)^{\\log7} \\times (n)^{\\log7} + n^2 \\\\\n     &amp;\\leq cn^{\\log7}, \\text{ since $7/(2)^{\\log7}$  is constant so can be ignored and $cn^{\\log7} \\gg n^2$ for large $n$} \\\\\n     &amp;\\leq cn^{\\log7} \\text{ assuming $c$ is a constant $\\geq 1$.}\n\\end{align*}\n$$</p>\n\n<p>Finally to find constant $c$, </p>\n\n<p>$$(7/(2)^{\\log7}) \\times cn^{\\log7} + n^2 \\leq cn^{\\log7}. $$</p>\n\n<p>I am not able to find appropriate $c$ for which the condition holds true. </p>\n', 'ViewCount': '59', 'Title': 'To prove the recurrence by substitution method $T(n) = 7T(n/2) + n^2$', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-18T02:50:15.323', 'LastEditDate': '2014-04-17T17:55:46.163', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16666', 'Tags': '<algorithms><algorithm-analysis><recurrence-relation>', 'CreationDate': '2014-04-17T17:22:36.890', 'Id': '23892'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>The following recurrence relation,</p>\n\n<p>$$T(n)=16T(\\frac{n}{4}) + n^2$$</p>\n\n<p>has been given to me to be solved via the Master Theorem. I'm pretty sure this is a case 2 situation, since</p>\n\n<p>$$\\log_4{16} = 2$$ and </p>\n\n<p>$$\\log_n{n^2} = 2$$ </p>\n\n<p>Where $b = 4$, $a = 16$, and $c = 2$, such that $f(n) = n^c$ </p>\n\n<p>What I'm <em>not</em> sure about is the end runtime complexity. </p>\n\n<p>What I've come up with so far is</p>\n\n<p>$$T(n) = \\theta(n^2log_2{n})$$</p>\n\n<p>...since the Master Theorem states that, for case 2 situations, $f(n)$ must be within the set of $O(n^clog^kn)$, where $k$ is some constant in which $k \\ge 0$.</p>\n\n<p>My reasoning was to substitute 0 for $k$, which led to $\\log_2^1{n}$ in the result, as the result requires that $T(n) = \\theta(n^clog_2^{k+1}{n})$.</p>\n\n<p>In a nutshell, while I know the first portion of the analysis is correct, and that this <em>is</em> a case 2 situation, am I correct in the reasoning behind the logarithmic portion in the ending runtime analysis?</p>\n", 'ViewCount': '32', 'Title': 'Is my analysis of this recurrence relation correct?', 'LastActivityDate': '2014-04-24T06:24:28.710', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17028', 'Tags': '<asymptotics><recurrence-relation><master-theorem>', 'CreationDate': '2014-04-23T23:29:21.213', 'Id': '24066'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Every time I solve these questions, I get stuck at the end where I need to find a closed form for the summation.</p>\n\n<p>Here in this case, I have reached until this point:\n$$\n\\begin{align}\nT(n) &amp;= T(n-2) + 1/\\lg n \\\\\n&amp;= T(n-4)+ 1/\\lg(n-2) + 1/\\lg n  \\\\\n&amp;= T(n-6) + 1/\\lg(n-4) + 1/\\lg(n-2) + 1/\\lg n. \\qquad (1)\n\\end{align}\n$$\nAssuming $T(1) = 1$, I put $n - 6 = 1$ and substituted into (1):</p>\n\n<p>$$ T(6) = T(1) + 1/\\lg3+ 1/\\lg 5+ 1/\\lg7.$$</p>\n\n<p>Now at this point I am not able to find out $\\sum_{i=1}^n 1/\\lg(2i-1)$.</p>\n\n<p>On similar grounds , I become blank for another recurrence relation $T(n) = T(n-1)+1/\\lg n$,\nand my solution drills down up to here:\n$$T(n) = T(1)+ 1/\\lg2 + 1/\\lg3 + 1/\\lg4 + \\cdots.$$</p>\n\n<p>How do I evaluate such sums?</p>\n', 'ViewCount': '43', 'Title': 'Not able to simplify a sum over reciprocals of $\\log i$', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-24T09:00:25.837', 'LastEditDate': '2014-04-24T09:00:25.837', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '16666', 'Tags': '<recurrence-relation><discrete-mathematics>', 'CreationDate': '2014-04-24T00:16:13.233', 'Id': '24067'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>It\'s been a while since I had to solve a recurrence and I wanted to make sure I understood the iterative method of solving these problems. Given:</p>\n\n<p>$$T(n) = 3T(n-2)$$</p>\n\n<p>My first step was to iteratively substitute terms to arrive at a general form:</p>\n\n<p>$$T(n-2) = 3T(n-2 -2) = 3T(n-4)$$\n$$T(n) = 3 *3T(n-4)$$</p>\n\n<p>leading to the general form:</p>\n\n<p>$$ T(n) = 3^k T(n-2k) $$</p>\n\n<p>Now I solve $n-2k = 1$ for $k$, which is the point where the recurrence stops (where $T(1)$) and insert that value ($n/2 - 1/2 = k$) into the general form:</p>\n\n<p>$$T(n) = 3^{n/2-1/2}$$\n$$T(n) = O(3^n)$$</p>\n\n<p>I\'m not sure about that last step:</p>\n\n<p>I would just "argue" that as $n \\to \\infty$ one can ignore $-1/2$ and $n/2 \\to n$ ?\nIs that assumption correct?</p>\n', 'ViewCount': '309', 'Title': 'Solving the recurrence T(n) = 3T(n-2) with iterative method', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T22:03:03.363', 'LastEditDate': '2014-05-02T22:03:03.363', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '24291', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '17242', 'Tags': '<asymptotics><recurrence-relation>', 'CreationDate': '2014-05-01T08:17:13.333', 'Id': '24290'}}