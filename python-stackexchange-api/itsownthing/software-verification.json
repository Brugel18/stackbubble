{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the discussion around <a href="http://cs.stackexchange.com/q/1157/98">this question</a>, Gilles mentions correctly that any correctness proof of an algorithm that uses arrays has to prove that there are no out-of-bounds array accesses; depending on the runtime model, this would cause a runtime error or access to non-array elements.</p>\n\n<p>One common technique to perform such correctness proofs (at least in undergrad studies and probably in automated verification) is by using <a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>. I am not aware that the standard set of rules containes anything relating to arrays; they seem to be restricted to monadic variables.</p>\n\n<p>I can imagine adding axioms of the form</p>\n\n<p>$\\qquad \\displaystyle \\frac{}{\\{0 \\leq i \\lt A.\\mathrm{length} \\land {P[A[i]/E]} \\}\\ A[i] := E;\\ \\{P\\}}$</p>\n\n<p>However, it is not clear to me how you would deal with an array access on the right hand side, i.e. if it is part of a complex expression $E$ in some statement $x := E$.</p>\n\n<blockquote>\n  <p>How can arrays accesses be modelled in Hoare logic so that the absence of invalid accesses can and has to be proven for program correctness?</p>\n</blockquote>\n\n<p>Answers may assume that we disallow array elements to be used in statements other than $A[i] := E$ or as part of some $E$ in $x := E$ as this does not restrict expressiveness; we can always assign a temporary variable the desired value, i.e. write $t := A[i];\\ \\mathtt{if} ( t &gt; 0 ) \\dots$ instead of $\\mathtt{if} ( A[i] &gt; 0 )\\dots$.</p>\n', 'ViewCount': '317', 'Title': 'How to deal with arrays during Hoare-style correctness proofs', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-10T16:17:41.297', 'LastEditDate': '2012-04-10T16:17:41.297', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<proof-techniques><semantics><arrays><hoare-logic><software-verification>', 'CreationDate': '2012-04-10T08:00:09.683', 'FavoriteCount': '1', 'Id': '1200'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '501', 'Title': 'How do you check if two algorithms return the same result for any input?', 'LastEditDate': '2012-05-25T20:16:22.707', 'AnswerCount': '4', 'Score': '9', 'OwnerDisplayName': 'Andres Riofrio', 'PostTypeId': '1', 'OwnerUserId': '1638', 'FavoriteCount': '2', 'Body': u'<p>How do you check if two algorithms (say, Merge sort and Na\xefve sort) return the same result for any input, when the set of all inputs is infinite?</p>\n\n<p><strong>Update:</strong> Thank you <a href="http://cs.stackexchange.com/a/2062/1638">Ben</a> for describing how this is impossible to do algorithmically in the general case. <a href="http://cs.stackexchange.com/a/2063/1638">Dave\'s answer</a> is a great summary of both algorithmic and manual (subject to human wit and metaphor) methods that don\'t always work, but are quite effective.</p>\n', 'Tags': '<computability><formal-methods><software-engineering><software-verification><program-verification>', 'LastEditorUserId': '1638', 'LastActivityDate': '2012-05-25T20:16:22.707', 'CommentCount': '8', 'CreationDate': '2012-05-25T00:03:21.817', 'Id': '2059'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '205', 'Title': 'Introduction into first order logic verification', 'LastEditDate': '2012-08-13T05:27:52.237', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2436', 'FavoriteCount': '1', 'Body': '<p>I am trying to teach myself different approaches to software verification. I have read some articles. As far as I learned, propositional logic with temporal generally uses model checking with SAT solvers (in ongoing - reactive systems), but what about first order Logic with temporal? Does it use theorem provers? Or can it also use SAT?</p>\n\n<p>Any pointers to books or articles for beginners in this matter is much appreciated.</p>\n', 'Tags': '<reference-request><logic><formal-methods><sat-solvers><software-verification>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-13T05:27:52.237', 'CommentCount': '2', 'AcceptedAnswerId': '3114', 'CreationDate': '2012-08-09T20:52:33.677', 'Id': '3110'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<blockquote>\n  <p>"Alan Turing proved in 1936 that a general algorithm to solve the\n  halting problem for <em>all</em> possible program-input pairs cannot exist"</p>\n</blockquote>\n\n<p>Can I find a general algorithm to solve the halting problem for <em>some</em> possible program input pairs? </p>\n\n<p>Can I find a programming language (or languages), where I for every kind of program in this language, it can decide if the program terminates or run forever?</p>\n', 'ViewCount': '654', 'Title': u'Algorithm to solve Turing\'s "Halting problem\u200d\u200b"', 'LastEditorUserId': '41', 'LastActivityDate': '2013-04-05T11:21:40.253', 'LastEditDate': '2012-10-03T19:12:15.243', 'AnswerCount': '6', 'CommentCount': '3', 'Score': '11', 'OwnerDisplayName': 'user11775', 'PostTypeId': '1', 'Tags': '<computability><formal-methods><halting-problem><software-verification>', 'CreationDate': '2011-12-08T17:52:03.623', 'FavoriteCount': '3', 'Id': '4856'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>We only consider the <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="nofollow">reverse Polish notation</a> as an arithmetic expression.</p>\n\n<p>Formally, RNP is a sequence consisted of numbers and arithmetic operators: $+,-,*,/$, and its syntax is:\n$$\\newcommand\\RNF{\\mathrm{RNF}}\\newcommand\\num{\\mathrm{number}}\\newcommand\\op{\\mathrm{operator}}\\RNF=\\num\\,\\big\\vert\\,\\RNF,\\RNF,\\op$$\nand its value\n$$\\newcommand\\eval{\\operatorname{eval}}\\eval\\num=\\num$$\n$$\\eval\\RNF_1,\\RNF_2,\\op=\\eval\\RNF_1\\ \\op\\ \\eval\\RNF_2$$</p>\n\n<p>The following pseudo code to evaluate $\\eval\\RNF$ is quoted from K&amp;R:</p>\n\n<pre><code>while (next operator or operand isn\'t empty)\n  if (it\'s a number)\n    push it\n  else if (it\'s an operator, say +,-,*,/)\n    pop operands\n    do operation\n    push result\n</code></pre>\n\n<p>The algorithm is somewhat straightforward, but it\'s not as evident as considered. I found it difficult to formulate a <a href="http://en.wikipedia.org/wiki/Loop_invariant" rel="nofollow">loop invariant</a> for the outer while-loop, and it\'s quite hard to prove the algorithm through <a href="http://en.wikipedia.org/wiki/Hoare_logic" rel="nofollow">Floyd-Hoare logic</a>.</p>\n\n<p>Through some search work, I found a <a href="http://cs.stackexchange.com/q/3458">related question</a>, about the unambiguity of RPN. Unfortunately, I don\'t think the answer to that question is a rigorous proof.</p>\n', 'ViewCount': '483', 'Title': 'Evaluation of reverse Polish notation', 'LastEditorUserId': '1715', 'LastActivityDate': '2013-02-23T05:29:17.650', 'LastEditDate': '2013-02-23T05:25:43.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10035', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1715', 'Tags': '<algorithms><formal-languages><software-verification>', 'CreationDate': '2013-02-23T04:22:45.387', 'Id': '10034'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am looking for some sort of temporal logic for expressing invariants in interfaces. Since interfaces do not specify data representation, the invariants must rely solely on the publicly available functions of the interface.</p>\n\n<p>For example, suppose we have a simple interface (Java style) Sum:</p>\n\n<pre><code>interface Sum {\n    public void add (int a);\n    public int getSum();\n}\n</code></pre>\n\n<p>I want to express in an invariant that <code>getSum</code> returns the summation of <code>a</code> in all calls to <code>add(a)</code>, without using any data representation of this sum.</p>\n\n<p>The only way I can think of doing this is by using some form of temporal logic. Is there any literature on this subject available I can read? Any pointers would be much appreciated.</p>\n', 'ViewCount': '46', 'Title': 'Temporal logic for interface invariants', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T02:59:49.377', 'LastEditDate': '2013-04-12T07:15:00.573', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '11298', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7690', 'Tags': '<logic><object-oriented><linear-temporal-logic><software-verification>', 'CreationDate': '2013-04-12T00:18:07.817', 'Id': '11247'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '385', 'Title': 'Formal program verification in practice', 'LastEditDate': '2013-08-17T15:04:01.323', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '9667', 'FavoriteCount': '3', 'Body': '<p>As a software engineer, I write a lot of code for industrial products. Relatively complicated stuff with classes, threads, some design efforts, but also some compromises for performance. I do a lot of testing, and I am tired of testing, so I got interested in formal proof tools, such as Coq, Isabelle... Could I use one of these to formally prove that my code is bug-free and be done with it? - but each time I check out one of these tools, I walk away unconvinced that they are usable for everyday software engineering. Now, that could only be me, and I am looking for pointers/opinions/ideas about that :-)</p>\n\n<p>Specifically, I get the impression that to make one of these tools work for me would require a huge investment to properly define to the prover the objects, methods... of the program under consideration. I then wonder if the prover wouldn\'t just run out of steam given the size of everything it would have to deal with. Or maybe I would have to get rid of side-effects (those prover tools seem to do really well with declarative languages), and I wonder if that would result in "proven code" that could not be used because it would not be fast or small enough. Also, I don\'t have the luxury of changing the language I work with, it needs to be Java or C++: I can\'t tell my boss I\'m going to code in OXXXml from now on, because it\'s the only language in which I can prove the correctness of the code... </p>\n\n<p>Could someone with more experience of formal proof tools comment? Again - I would <em>LOVE</em> to use a formal prover tool, I think they are great, but I have the impression they are in an ivory tower that I can\'t reach from the lowly ditch of Java/C++... (PS: I also <em>LOVE</em> Haskell, OCaml... don\'t get the wrong idea: I am a fan of declarative languages and formal proof, I am just trying to see how I could realistically make that useful to software engineering)</p>\n\n<p>Update: Since this is fairly broad, let\'s try the following more specific questions: 1) are there examples of using provers to prove correctness of industrial Java/C++ programs? 2) Would Coq be suitable for that task? 3) If Coq is suitable, should I write the program in Coq first, then generate C++/Java from Coq? 4) Could this approach handle  threading and performance optimizations? </p>\n', 'Tags': '<programming-languages><program-correctness><software-verification>', 'LastEditorUserId': '9667', 'LastActivityDate': '2013-08-22T15:58:29.473', 'CommentCount': '7', 'AcceptedAnswerId': '13842', 'CreationDate': '2013-08-17T01:51:39.910', 'Id': '13785'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $x=(x_1,\\dots,x_n)$ and $y=(y_1,\\dots,y_n)$ be $n$-vectors of boolean variables.  I have a boolean predicate $Q(x,y)$ on $x,y$.  I give my friend Priscilla $Q(x,y)$.  In response, she gives me $P(x)$, a boolean predicate on $x$, and she claims that</p>\n\n<p>$$P(x) \\equiv \\exists y . Q(x,y),$$</p>\n\n<p>or in other words, that</p>\n\n<p>$$\\forall x . [P(x) \\Leftrightarrow \\exists y . Q(x,y)].$$</p>\n\n<p>I would like to verify her claim somehow.  How can Priscilla help me verify this claim?</p>\n\n<p>You can assume that both $P$ and $Q$ are represented as CNF formulas, and that they\'re not too large (polynomial size, or something).</p>\n\n<p>In an ideal world, it\'d be awesome if I could reduce the problem of verifying this claim to SAT: I have a SAT solver, and it\'d be great if I can use the SAT solver to verify this claim.  However, I\'m pretty sure that it\'s not going to be possible to formulate the problem of verifying this claim directly as a SAT instance; <a href="http://cstheory.stackexchange.com/q/11022/5038">testing the validity of a 2QBF formula</a> is almost certainly harder than SAT.  (The $\\Leftarrow$ direction is easy to formulate as a SAT instance, but the $\\Rightarrow$ direction is hard because it inherently involves two alternating quantifiers.)</p>\n\n<p>But suppose Priscilla could give me some additional evidence to support her claim.  Is there some additional evidence or witness Priscilla could give me, which would make it easy for me to verify her claim?  In particular, is there some additional evidence or witness she could give me, which would make it easy for me to formulate the problem of verifying her claim as an instance of SAT (which I can then apply my SAT solver to)?</p>\n\n<p>One unusual aspect of my setting is that I\'m assuming (heuristically) that I have an oracle for SAT.  If you like complexity theory, you can think about it this way: I am taking the role of a machine that can compute things in $P^{NP}$ (i.e., in $\\Delta^P_2$), and I\'m looking to verify Priscilla\'s claim using an algorithm in $P^{NP}$.  My thanks to mdx for this way of thinking about things.</p>\n\n<hr>\n\n<p>My motivation/application: I\'m looking to do formal verification of a system (e.g., symbolic model checking), and a key step in the reasoning involves quantifier elimination (i.e., starting from $Q$, obtain $P$).  I\'m hoping for some clean way to verify that the quantifier elimination was done correctly.</p>\n\n<p>If there\'s no solution that works for all possible $P,Q$, feel free to suggest a solution that is "sound but not complete", i.e., a technique that for many $P,Q$ lets me verify the claimed equivalence. (Even if it fails to verify the claim on some $P,Q$ that do satisfy the claim, I can still try this as a heuristic, as long as it never inappropriately claims to have verified a false claim.  On any given $P,Q$, it might work, or it might not; if it doesn\'t work, I\'m no worse off than where I started.)</p>\n', 'ViewCount': '109', 'Title': 'Verify correctness of quantifier elimination, using SAT', 'LastEditorUserId': '755', 'LastActivityDate': '2013-10-09T00:35:46.483', 'LastEditDate': '2013-10-07T02:09:21.303', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<logic><satisfiability><first-order-logic><software-verification><model-checking>', 'CreationDate': '2013-10-04T20:40:24.817', 'FavoriteCount': '2', 'Id': '14816'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to cobble together a survey of different techniques used in formal verification of software. I need a classification and brief description of various methods. It could be chronological, by application domain, by mathematical model, by process or whatever.</p>\n\n<p>For example, the following paper considers only fully automated techniques that are in vogue:</p>\n\n<p>A survey of automated techniques for formal software verification\n<a href="http://www.eecs.berkeley.edu/~alanmi/publications/other/softver_tutorial.pdf" rel="nofollow">http://www.eecs.berkeley.edu/~alanmi/publications/other/softver_tutorial.pdf</a></p>\n\n<p>I want something a little more comprehensive. A short description of each approach or differences between approaches would also help. It is a little confusing because different authors seem to use different terms/classifications. Sometimes static analysis is taken to include model checking, and deductive verification does not find mention.</p>\n\n<p>EDIT: So far I have model checking, deductive verification, static analysis and program derivation as four broad categories. Could someone explain the main principle of these techniques/differences between them? Or if there are some techniques that are left out by the above classification. I would also like to further divide these categories into sub-categories</p>\n', 'ViewCount': '93', 'ClosedDate': '2013-11-02T22:00:31.233', 'Title': 'Taxonomy of formal methods of program verification', 'LastEditorUserId': '10708', 'LastActivityDate': '2013-10-29T15:09:58.083', 'LastEditDate': '2013-10-29T15:09:58.083', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10708', 'Tags': '<formal-methods><software-verification><program-verification>', 'CreationDate': '2013-10-13T15:57:36.033', 'Id': '16040'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>In my project, there is one important step to automatically verify a timed automata with TCTL formulae. I briefly surveyed the tool UPPAAL that provides a GUI to construct a timed automata and to specify CTL formulae. However, I didn't find the api to invoke.</p>\n\n<p>Is there any tools with api provided for verifying TCTL formulae over timed automata can be imported into my project? Such that I can automatically send the timed automata and the TCTL formulae to the tool and get the satisfaction result.</p>\n\n<p>And, the tool UPPAAL can only verify a CTL subset of TCTL over a timed automata. On this constraint, if I want to verify a TCTL formula with interval constraint $\\Phi$ (such as $\\exists (\\Phi_1 U^J \\Phi_2)$), I have to extend each location $l$ of the automata with an extra clock $z$, and verify each state $l\\{z:=0\\}\\models \\exists (\\Phi_1 U (z\\in J \\wedge \\Phi_2))$. And I have to wrap a CTL detection algorithm for nested formulae. Is there any tool can directly verify TCTL formulae over a timed automata?</p>\n", 'ViewCount': '35', 'Title': 'Is there any open-source tools for verifying TCTL formulae over timed automata can be imported into my project?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:42:29.790', 'LastEditDate': '2014-01-15T08:42:29.790', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12457', 'Tags': '<formal-methods><model-checking><software-verification>', 'CreationDate': '2014-01-15T06:12:27.823', 'Id': '19739'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '150', 'Title': 'Could program verification techniques prevent bugs of the genre of Heartbleed from occurring?', 'LastEditDate': '2014-04-16T12:41:34.870', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'Mok-Kong Shen', 'PostTypeId': '1', 'OwnerUserId': '6437', 'FavoriteCount': '1', 'Body': '<p>On the matter of the Heartbleed bug, Bruce Schneier wrote in his Crypto-Gram of 15th April:\n\'"Catastrophic" is the right word. On the scale of 1 to 10, this is an 11.\' I read several years ago that a kernel of a certain operating system has been rigorously verified with a modern program verification system. Could hence bugs of the genre of Heartbleed be prevented from occurring via application of program verification techniques today or is this yet unrealistic or even principally impossible?</p>\n', 'Tags': '<cryptography><correctness-proof><security><software-verification><program-correctness>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-23T20:21:04.283', 'CommentCount': '1', 'CreationDate': '2014-04-15T14:30:22.640', 'Id': '23856'}},