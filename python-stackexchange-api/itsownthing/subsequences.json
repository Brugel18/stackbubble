{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '736', 'Title': 'Is there an algorithm which finds sorted subsequences of size three in $O(n)$ time?', 'LastEditDate': '2013-05-05T20:08:44.940', 'AnswerCount': '3', 'Score': '17', 'OwnerDisplayName': 'Christopher Done', 'PostTypeId': '1', 'OwnerUserId': '969', 'FavoriteCount': '2', 'Body': u"<p>I want to prove or disprove the existence of an algorithm which, given an array $A$ of integers, finds three indices $i, j$ and $k$ such that $i &lt; j &lt; k$ and $A[i] &lt; A[j] &lt; A[k]$ (or finds that there is no such triple) in linear time.</p>\n\n<p>This is not a homework question; I saw it on a programming forum framed as \u201ctry to implement such an algorithm.\u201d I suspect that it is impossible after various experiments. My intuition tells me so, but that does not really count for anything.</p>\n\n<p>I would like to prove it formally. How do you do it? I would ideally like to see a proof laid out step-by-step, and then if you are so inclined, some explanation of how to go about proving/disproving simple questions like this in general. If it helps, some examples:</p>\n\n<pre><code>[1,5,2,0,3] \u2192 (1,2,3)\n[5,6,1,2,3] \u2192 (1,2,3)\n[1,5,2,3] \u2192 (1,2,3)\n[5,6,1,2,7] \u2192 (1,2,7)\n[5,6,1,2,7,8] \u2192 (1,2,7)\n[1,2,999,3] \u2192 (1,2,999)\n[999,1,2,3] \u2192 (1,2,3)\n[11,12,8,9,5,6,3,4,1,2,3] \u2192 (1,2,3)\n[1,5,2,0,-5,-2,-1] \u2192 (-5,-2,-1)\n</code></pre>\n\n<p>I supposed that one could iterate over $A$, and each time there is an $i &lt; j$ (our current $j$, that is), we make a new triple and push it onto an array. We continue stepping and comparing each triple until one of our triples is complete. So it's like <code>[1,5,2,0,-5,-2,-1] \u2192 1..2.. -5.. -2.. -1</code>, <code>[1,5,2,0,-5,-2,3,-1] \u2192 1..2.. -5.. -2.. 3</code>! But I think this is more complex than mere $\\mathcal{O}(n)$ as the number of triples on our triple array would in the worst case correspond to the size of the input list.</p>\n", 'Tags': '<algorithms><arrays><subsequences>', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-05-22T17:22:29.563', 'CommentCount': '2', 'AcceptedAnswerId': '1073', 'CreationDate': '2012-04-05T20:56:01.307', 'Id': '1071'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>We are given a set $F=\\{f_1, f_2, f_3, \u2026, f_N\\}$ of $N$ Fruits. Each Fruit has price $P_i$ and vitamin content $V_i$; we associated fruit $f_i$ with the ordered pair $(P_i, V_i)$. Now we have to arrange these fruits in such a way that the sorted list contains prices in ascending order and vitamin contents in descending order.</p>\n\n<p><strong>Example 1</strong>: $N = 4$ and $F = \\{(2, 8), (5, 11), (7, 9), (10, 2)\\}$.</p>\n\n<p>If we arrange the list such that all price are in ascending order and vitamin contents in descending order, then the valid lists are the following:</p>\n\n<ul>\n<li>$[(2, 8)]$</li>\n<li>$[(5, 11)]$</li>\n<li>$[(7, 9)]$</li>\n<li>$[(10, 2)]$</li>\n<li>$[(2, 8), (10, 2)]$</li>\n<li>$[(5, 11), (7, 9)]$</li>\n<li>$[(5, 11), (10, 2)]$</li>\n<li>$[(7, 9), (10, 2)]$</li>\n<li>$[(5, 11), (7, 9), (10, 2)]$</li>\n</ul>\n\n<p>From the above lists, I want to choose the list of maximal size. If more than one list has maximal size, we should choose the list of maximal size whose sum of prices is least. The list which should be chosen in the above example is $\\{(5, 11), (7, 9), (10, 2)\\}$.</p>\n\n<p><strong>Example 2</strong>: $N = 10$ and $$F = \\{(99,10),(12,23),(34,4),(10,5),(87,11),(19,10), \\\\(90,18), (43,90),(13,100),(78,65)\\}$$</p>\n\n<p>The answer to this example instance is $[(13,100),(43,90),(78,65),(87,11),(99,10)]$.</p>\n\n<p>Until now, this is what I have been doing:</p>\n\n<ol>\n<li>Sort the original list in ascending order of price;</li>\n<li>Find all subsequences of the sorted list;</li>\n<li>Check whether the subsequence is valid, and compare all valid subsequences.</li>\n</ol>\n\n<p>However, this takes exponential time; how can I solve this problem more efficiently?</p>\n', 'ViewCount': '139', 'Title': 'Find subsequence of maximal length simultaneously satisfying two ordering constraints', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-11T21:21:42.877', 'LastEditDate': '2012-10-11T21:21:42.877', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1289', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1001', 'Tags': '<algorithms><arrays><constraint-programming><subsequences>', 'CreationDate': '2012-04-15T11:03:26.633', 'Id': '1287'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Suppose I have an array of integers having length $N$. How can I output all longest decreasing sequences? (A subsequence consists of elements of the array that do not have to be consecustive, for example $(3,2,1)$ is a decreasing subsequence of $(7,3,5,2,0,1)$.) I know how to calculate the length of longest decreasing sequences, but don't know how to report all longest decreasing sequences.</p>\n\n<p>Pseudocode will be helpful.</p>\n", 'ViewCount': '421', 'Title': 'How to output all longest decreasing sequences', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-11T21:22:02.847', 'LastEditDate': '2012-10-11T21:22:02.847', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '1313', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1001', 'Tags': '<algorithms><arrays><subsequences>', 'CreationDate': '2012-04-15T12:49:34.590', 'Id': '1290'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '761', 'Title': 'How to use a greedy algorithm to find the non-decreasing sequence closest to the given one?', 'LastEditDate': '2012-10-11T21:23:25.513', 'AnswerCount': '3', 'Score': '17', 'PostTypeId': '1', 'OwnerUserId': '1718', 'FavoriteCount': '1', 'Body': "<p>You are given n integers $a_1, \\ldots, a_n$ all between $0$ and $l$. Under each integer $a_i$ you should write an integer $b_i$ between $0$ and $l$ with the requirement that the $b_i$'s form a non-decreasing sequence. Define the deviation of such a sequence to be $\\max(|a_1-b_1|, \\ldots, |a_n-b_n|)$. Design an algorithm that finds the $b_i$'s with the minimum deviation in runtime $O(n\\sqrt[4]{l})$.</p>\n\n<p>I honestly have no clue whatsoever how to even begin to solve this question. It looks like a dynamic programming question to me, but the professor said that this should be solved using a greedy algorithm. It would be much appreciated if someone can point me in the right direction by giving a small hint.</p>\n", 'Tags': '<algorithms><optimization><greedy-algorithms><subsequences>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-11T21:23:25.513', 'CommentCount': '6', 'AcceptedAnswerId': '2242', 'CreationDate': '2012-06-01T15:43:28.810', 'Id': '2188'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>First of all we must read a word, and a desired size.<br>\nThen we need to find the longest palindrome created by characters in this word used in order.<br>\nFor example for size = 7 and word = "abcababac" the answer is 7 ("abababa").   </p>\n\n<p>Postscript: the size of the word is smaller than 3000.</p>\n', 'ViewCount': '3096', 'Title': 'Fastest algorithm for finding the longest palindrome subsequence', 'LastEditorUserId': '39', 'LastActivityDate': '2013-03-22T21:13:31.333', 'LastEditDate': '2012-10-11T21:21:11.817', 'AnswerCount': '3', 'CommentCount': '8', 'Score': '6', 'OwnerDisplayName': 'Lin Yon Xong', 'PostTypeId': '1', 'Tags': '<algorithms><strings><subsequences>', 'CreationDate': '2012-06-18T14:11:18.557', 'FavoriteCount': '1', 'Id': '2466'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I got no responses on stackoverflow, so I\'m asking here:</p>\n\n<p>How useful is the LIS (<a href="http://www.geeksforgeeks.org/archives/9591" rel="nofollow">Longest Increasing Subsequence</a>) problem in tackling other CS problems?  There are a few algorithms, using patience sorting, dynamic programming or with decision trees.  How are these used in real life -- maybe to data streams or something?</p>\n\n<p>To remind you, I put in bold the longest increasing sequence</p>\n\n<p>{<strong>0</strong>, 8, 4, 12, <strong>2</strong>, 10, <strong>6</strong>, 14, 1, <strong>9</strong>, 5, 13, 3, <strong>11</strong>, 7, <strong>15</strong>}.</p>\n\n<p>As a bonus, is there any way to use the result that <a href="http://mathworld.wolfram.com/Erdos-SzekeresTheorem.html" rel="nofollow">a sequence of length mn + 1 will have an increasing subsequence of length m or a decreasing subsequence of length n</a>? E.g. Our list as length 16, so there should be an increasing sequence of length 5 or decreasing sequence of length 5.  In our case <em>0,2,6,9,11,15</em>.</p>\n\n<p>Also an increasing sequence of length 8 or a decreasing sequence of length 3: in our case <em>12,10,1</em>.</p>\n\n<p>CF: <a href="http://stackoverflow.com/q/12458641/737051">http://stackoverflow.com/q/12458641/737051</a></p>\n', 'ViewCount': '242', 'Title': 'Longest Increasing Subsequence', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-11T21:06:52.490', 'LastEditDate': '2012-10-11T21:06:52.490', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'john mangual', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><arrays><subsequences>', 'CreationDate': '2012-10-09T18:03:23.037', 'Id': '4985'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/4994/dynamic-programming-table-for-finding-similar-substrings-is-too-large">Dynamic programming table for finding similar substrings is too large</a>  </p>\n</blockquote>\n\n\n\n<p>Say I have a sequence $S$ of 0s and 1s such as $S = [1, 0, 0, 1, 0, 1]$</p>\n\n<p>How would I efficiently find a pair $(i, j)$ such that $j - i$ is maximum and $(\\sum_{z=i}^j S_z ) \\leq K$</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>The following algorithm solves the above problem in O(n).</p>\n\n<pre><code>def longest_range_min_sum(S, K):\n    longest = 0\n    i = 0\n    running_sum = 0\n    while i + longest &lt; len(S):\n        if S[i + longest] == 1:\n            running_sum += 1\n        if running_sum &gt; K:\n            if S[i] == 1:\n                running_sum -= 1\n            i += 1\n        else:\n            longest += 1\n    return longest\n</code></pre>\n', 'ViewCount': '47', 'ClosedDate': '2012-10-15T11:38:28.413', 'Title': 'Longest range with sum smaller than K', 'LastEditorUserId': '3101', 'LastActivityDate': '2012-10-19T06:53:31.317', 'LastEditDate': '2012-10-19T06:53:31.317', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3101', 'Tags': '<subsequences>', 'CreationDate': '2012-10-14T22:49:57.933', 'Id': '6076'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I recently came across the following interesting problem - one is given a sequence of <code>X</code>s and <code>Y</code>s such as <code>XXYXYXYYXYXXXYX</code>, and consider a sequence to be good if, as you start at the left and move right, the number of <code>X</code>s is greater than or equal to the number of <code>Y</code>s at any point except at the very end, at which the two quantities must be equal.</p>\n\n<p>One must determine the number of points at which changing either a single <code>X</code> to <code>Y</code> or a single <code>Y</code> to <code>X</code> in a given sequence will yield a good sequence.</p>\n\n<p>I initially considered traveling through the sequence linearly and checking if toggling the letter at that point would yield a good sequence, however that approach is on the order of $O(n\\cdot n)=O(n^2)$ in the worst case where n is the length of the sequence. However, I was wondering if there was some faster method to do it.</p>\n\n<p>EDIT: I made the observation that for any sequence, if the number of possible changes is greater than 0, than only one type of change will work (either changing an <code>X</code> to <code>Y</code> or <code>Y</code> to <code>X</code>) given the condition at the end that the number of <code>X</code> and <code>Y</code> must be equal.</p>\n', 'ViewCount': '103', 'Title': 'Improving Time Bound of this Algorithm past $O(n^2)$', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-19T05:59:02.350', 'LastEditDate': '2012-11-19T05:59:02.350', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'Rebecca Kuang', 'PostTypeId': '1', 'Tags': '<algorithms><subsequences>', 'CreationDate': '2012-11-18T16:26:51.083', 'Id': '6751'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm looking for an efficient algorithm to find the longest repeated pattern in a string.</p>\n\n<p>For example, consider the following string of numbers:  </p>\n\n<p><code>5431428571428571428571428571427623874534</code>.</p>\n\n<p>As you can see, <code>142857142857</code> is the longest pattern which is repeated for a couple of times (at least twice) in this string.</p>\n\n<p>The repeated string should not contain any re\nany idea rather than brute-force?  </p>\n", 'ViewCount': '1033', 'Title': 'Find the longest repeated pattern in a string', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T03:33:54.443', 'LastEditDate': '2012-11-22T03:33:54.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'OwnerDisplayName': 'MBZ', 'PostTypeId': '1', 'Tags': '<algorithms><strings><subsequences>', 'CreationDate': '2012-11-08T19:28:56.950', 'FavoriteCount': '1', 'Id': '6776'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1034', 'Title': 'Count unique increasing subsequences of length 3 in $O(n\\log n)$', 'LastEditDate': '2012-12-15T19:21:39.437', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4751', 'FavoriteCount': '3', 'Body': '<p><strong>Problem</strong>: Given an array of $n$ integers, $A[1 \\dots n]$, such that any integer occurs <em>at most</em> 2 times in the array, we have to find the number of <em>unique</em> increasing subsequences of length 3 (duplicate subsequences must be counted only once). In other words, we have to count the number of unique integers $A[i], A[j], A[k]$ such that $A[i] &lt; A[j] &lt; A[k]$ with $i &lt; j &lt; k$.</p>\n\n<p>I have been stuck on this for quite a while now. I did look up <a href="http://cs.stackexchange.com/questions/1071/is-there-an-algorithm-which-finds-sorted-subsequences-of-size-three-in-on-time">this</a> question which tests for the existence of such a triplet. But I think my question is different because it needs the count, and because it needs unique triplets (upto 1 repetition of any number is allowed).</p>\n\n<p><strong>Idea:</strong> $O(n^2)$ algorithm. For each number, we can scan the remaining array and find out how many unique numbers are greater than it and occur after it. This can be done in $O(n^2)$ by naive brute force. For every pair of numbers ($O(n^2)$), we now have the number of possible triplets that can be formed by using the pair as the first two numbers of the triplet (since we know how many are greater than the second number).</p>\n\n<p>Unfortunately, $O(n^2)$ is too slow, and I need a faster solution - $O(n\\log n)$ or $O(n)$. Space complexity also has to be sub-quadratic. I was thinking along the lines of sorting a copy of the array to find out the relative rank of each element, but could not go any further. Any help or hints are greatly appreciated!</p>\n', 'Tags': '<algorithms><arrays><subsequences>', 'LastEditorUserId': '4751', 'LastActivityDate': '2012-12-17T14:22:11.433', 'CommentCount': '10', 'AcceptedAnswerId': '7434', 'CreationDate': '2012-12-15T11:47:23.423', 'Id': '7409'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>I've designed an algorithm to find the longest common subsequence. these are steps:  </p>\n\n<p>Starts with <code>i = 0</code></p>\n\n<ol>\n<li>Picks the first letter from the first string start from ith letter.</li>\n<li>Go to the second string looking for that picked letter.</li>\n<li>If not found return to the first string and picks the next letter and repeat 1 to 3 until it finds a letter that is in the second string.</li>\n<li>Now that found a common letter in the second string, adds that to <code>$common_subsequence</code>.</li>\n<li>Store its position in <code>$index</code>.</li>\n<li>Picks next letter from the first string and do step 2 but this time starts from <code>$index</code>.</li>\n<li>Repeat 3 to 6 until reached end of string 1 or string 2.</li>\n<li>If length <code>$common_subsequence</code> is greater than length of common subsequence so far add that  change lcs to the <code>$common_subsequence</code>.</li>\n<li>Add 1 to the i and repeat 1 to 9 while i is less that length of the first string.</li>\n</ol>\n\n<p>This is an example:<br>\n\u202b\u202a</p>\n\n<pre><code>X=A, B, C, B, D, A, B\u202c\u202c  \n\u202b\u202aY=B, D, C, A, B, A\u202c\u202c \n</code></pre>\n\n<ol>\n<li>First pick <code>A</code>.</li>\n<li>Look for <code>A</code> in <code>Y</code>.</li>\n<li>Now that found <code>A</code> add that to the <code>$common_subsequence</code>.</li>\n<li>Then pick <code>B</code> from <code>X</code>.</li>\n<li>Look for <code>B</code> in <code>Y</code> but this time start searching from <code>A</code>.</li>\n<li>Now pick <code>C</code>. It isn't there in string 2, so pick the next letter in <code>X</code> that is <code>B</code>.<br>\n...<br>\n...<br>\n...  </li>\n</ol>\n\n<p>The complexity of this algorithm is theta(n*m).</p>\n\n<p><em><strong>I implemented it on the two methods. The second one uses a hash table, but after implementing I found that it's much slower compared to the first algorithm. I cant undrestand why.</em></strong></p>\n\n<p>Here is my implementation:  </p>\n\n<p>First algorithm:</p>\n\n<pre><code>import time\ndef lcs(xstr, ystr):\n    if not (xstr and ystr): return # if string is empty\n    lcs = [''] #  longest common subsequence\n    lcslen = 0 # length of longest common subsequence so far\n    for i in xrange(len(xstr)):\n        cs = '' # common subsequence\n        start = 0 # start position in ystr\n        for item in xstr[i:]:\n            index = ystr.find(item, start) # position at the common letter\n            if index != -1: # if common letter has found\n                cs += item # add common letter to the cs\n                start = index + 1\n            if index == len(ystr) - 1: break # if reached end of the ystr\n        # update lcs and lcslen if found better cs\n        if len(cs) &gt; lcslen: lcs, lcslen = [cs], len(cs) \n        elif len(cs) == lcslen: lcs.append(cs)\n    return lcs\n\nfile1 = open('/home/saji/file1')\nfile2 = open('/home/saji/file2')\nxstr = file1.read()\nystr = file2.read()\n\nstart = time.time()\nlcss = lcs(xstr, ystr)\nelapsed = (time.time() - start)\nprint elapsed\n</code></pre>\n\n<p>Second one using hash table:</p>\n\n<pre><code>import time\nfrom collections import defaultdict\ndef lcs(xstr, ystr):\n    if not (xstr and ystr): return # if strings are empty\n    lcs = [''] #  longest common subsequence\n    lcslen = 0 # length of longest common subsequence so far\n    location = defaultdict(list) # keeps track of items in the ystr\n    i = 0\n    for k in ystr:\n        location[k].append(i)\n        i += 1\n    for i in xrange(len(xstr)):\n        cs = '' # common subsequence\n        index = -1\n        reached_index = defaultdict(int)\n        for item in xstr[i:]:\n            for new_index in location[item][reached_index[item]:]:\n                reached_index[item] += 1\n                if index &lt; new_index:\n                    cs += item # add item to the cs\n                    index = new_index\n                    break\n            if index == len(ystr) - 1: break # if reached end of the ystr\n        # update lcs and lcslen if found better cs\n        if len(cs) &gt; lcslen: lcs, lcslen = [cs], len(cs) \n        elif len(cs) == lcslen: lcs.append(cs)\n    return lcs\n\nfile1 = open('/home/saji/file1')\nfile2 = open('/home/saji/file2')\nxstr = file1.read()\nystr = file2.read()\n\nstart = time.time()\nlcss = lcs(xstr, ystr)\nelapsed = (time.time() - start)\nprint elapsed\n</code></pre>\n", 'ViewCount': '314', 'Title': 'Finding the longest common subsequence algorithm using hash table Slow', 'LastActivityDate': '2013-01-09T20:29:18.410', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7853', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5202', 'Tags': '<algorithms><subsequences>', 'CreationDate': '2013-01-09T16:28:54.807', 'Id': '7851'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to know which is the best way to find the longest common subsequence of two strings</p>\n', 'ViewCount': '147', 'Title': 'Find the longest subsequence of two strings', 'LastEditorUserId': '8105', 'LastActivityDate': '2013-05-10T12:19:08.163', 'LastEditDate': '2013-05-10T12:19:08.163', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8105', 'Tags': '<algorithms><algorithm-analysis><dynamic-programming><subsequences>', 'CreationDate': '2013-05-10T01:58:55.797', 'FavoriteCount': '2', 'Id': '11924'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have an issue for which I am looking for an algorithm (if it exists)</p>\n\n<p>What I have:\nAn array of items which have certain properties, e.g. item $A$ has properties $x$ and $y$.</p>\n\n<p>Example: $[ A(x,y), B(x,y), C(x,y), D(x,y), E(x,y) ]$</p>\n\n<p>What I want:\nA result list consisting of elements of the original list, such as $[ A(x,y), C(x,y), E(x,y) ]$, for which the following properties are true:</p>\n\n<ul>\n<li>No reordering of elements, they are in the same order as the original list</li>\n<li>The result has the maximum number of elements, i.e. the longest 'path' possible</li>\n<li>For each pair of consecutive items $(A(x,y), B(x,y))$ in the result, $A.x \\lt B.y$. In other words, an item's $x$ must be less than the next item's $y$.</li>\n</ul>\n\n<p>Complexity: The list in the case I have is about 35 items long, so an algorithm which is $O(n!)$ might not work.</p>\n\n<p>Does such an algorithm exist?</p>\n", 'ViewCount': '102', 'Title': 'Longest subsequence such that A[i].x < A[i+1].y', 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-27T11:03:43.220', 'LastEditDate': '2013-06-20T09:33:57.090', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8755', 'Tags': '<algorithms><sorting><subsequences><lists>', 'CreationDate': '2013-06-19T15:27:23.673', 'FavoriteCount': '1', 'Id': '12764'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Suppose you are given an input set $S$ of $n$ numbers, and a black box that if given any sequence of real numbers and an integer $k$ instantly and correctly answers whether there is a subset of input sequence whose sum is exactly $k$. I want to show how to use the black box $O(n)$ times to find a subset of S that adds up to $k$.</p>\n\n<p>This is what I've done: the first time we enter our set $S$. If it returns yes we can continue, otherwise it isn't possible to form the sequence which sums up to $k$. The next step is to test our set without the first element. If the black box returns yes we can delete it from our set otherwise we know that it is needed. We do this for each element and our $S$ shrinks to a set which sums up to $k$. Can I use induction to prove this?</p>\n", 'ViewCount': '282', 'Title': 'Finding the subset of $S$ that sums up to $k$ using a black box in $O(n)$ time', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-14T22:38:12.713', 'LastEditDate': '2013-09-11T19:01:55.813', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9744', 'Tags': '<algorithms><algorithm-analysis><subsequences>', 'CreationDate': '2013-09-11T18:05:11.860', 'Id': '14270'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Here is my approach </p>\n\n<p>First I compute the longest non decreasing sub-sequence in $N \\log N$ time. Algorithm to do this (that only uses arrays and binary search) can be found here:\n<a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms" rel="nofollow">http://en.wikipedia.org/wiki/Longest_increasing_subsequence#Efficient_algorithms</a></p>\n\n<p>Let\'s suppose the longest subsequence has $L$ elements. Then if $L &lt; N - M$, there isn\'t any way to solve the problem since there\'s no subsequence of length $N - M$ that\'s still sorted.</p>\n\n<p>Otherwise, just remove the $N - L$ elements that aren\'t in the subsequence, and then remove more at random until exactly M total have been removed. In all this is an $N \\log N$ algorithm.</p>\n\n<p>I want to know, is there any more efficient algorithm (i.e. $O( N)$ ) to solve this problem ?</p>\n', 'ViewCount': '193', 'Title': 'Given an array of N integers, how can you find M elements to remove so that the array will end up in sorted order?', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-10-08T23:01:04.927', 'LastEditDate': '2013-10-08T08:47:24.010', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8690', 'Tags': '<algorithms><time-complexity><runtime-analysis><subsequences>', 'CreationDate': '2013-10-08T08:40:39.700', 'FavoriteCount': '1', 'Id': '14899'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have following problem: I have a sorted sequence of $N$ integers (assume they are monotonically increasing).  I want to check whether there is any subsequence of length $\\ge N/4$, such that consecutive elements of the subsequence all differ by the same value.</p>\n\n<p>For example, in the sequence [3,4,5,8,12] there are two such subsequences: [3,4,5] (the difference is 1) and [4,8,12] (the difference is 4).  Thus, the length of longest such subsequence is 3 for this example.  Since $3 \\ge 5/4$, the answer is yes, there is a subsequence of length $\\ge N/4$ with the desired property.</p>\n\n<p>In my real-life situation, the sequence is of length $N\\approx 10^6$, and the elements are all 9-digit numbers.  Is there an efficient algorithm to solve this problem?</p>\n\n<hr>\n\n<p>My naive approach was to create Cartesian product with absolute differences between numbers:</p>\n\n<p>$$\n\\left( \\begin{array}{ccccc}\n0 &amp; 1 &amp; 2 &amp; 5 &amp; 9 \\\\\n1 &amp; 0 &amp; 1 &amp; 4 &amp; 8 \\\\\n2 &amp; 1 &amp; 0 &amp; 3 &amp; 7 \\\\\n5 &amp; 4 &amp; 3 &amp; 0 &amp; 4 \\\\\n9 &amp; 8 &amp; 7 &amp; 4 &amp; 0 \\end{array} \\right) $$</p>\n\n<p>And then focus on top-right part and compute number of occurrences of each difference, so:</p>\n\n<p>$$\n ||\\text{diff-by-1}|| = 2 =&gt; \\text{3 numbers diff by 1}\\\\\n ||\\text{diff-by-4}|| = 2 =&gt; \\text{3 numbers diff by 4}\n$$</p>\n\n<p>This is very simple and very ineffective. It requires lot of comparisons and does not scale (at all): its running time is $\\Theta(N^2)$. In my real life scenario my sequence is ~10^6 long, so this is too slow.</p>\n\n<p>To give you wider picture as maybe there is much better (probabilistic) approach to this problem: after largest sub-sequence is found I want to compute simple ratio: </p>\n\n<p>$$\nr:=\\frac{\\text{largest sub-sequence length}}{\\text{sequence length}}\n$$</p>\n\n<p>and if $r$ is greater then some fixed value I want to raise alarm (or do whatever I have to do ;-)).</p>\n\n<p>Thanks for any help, references, pointers, etc.</p>\n\n<p>BTW: here are things that I was/am looking at:</p>\n\n<ul>\n<li><a href="http://link.springer.com/article/10.1007/s00453-009-9376-2" rel="nofollow">http://link.springer.com/article/10.1007/s00453-009-9376-2</a></li>\n<li><a href="http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem" rel="nofollow">http://en.wikipedia.org/wiki/Longest_increasing_subsequence_problem</a></li>\n<li><a href="http://en.wikipedia.org/wiki/Longest_common_subsequence_problem" rel="nofollow">http://en.wikipedia.org/wiki/Longest_common_subsequence_problem</a></li>\n<li><a href="http://en.wikipedia.org/wiki/Kalman_filter" rel="nofollow">http://en.wikipedia.org/wiki/Kalman_filter</a></li>\n</ul>\n\n<p><strong>Update</strong>: was thinking a little bit more about it and started from the end, so instead of computing all differences between numbers (top-right corner of the matrix) I can derive small $k$ value from "fixed value" I mentioned at the end of original question. For instance if I am going to raise the alarm when 25% of all numbers are in some sequence I need to focus on small "triangles" in matrix and number of computations required is smaller (much smaller). \nWhen I add some sampling then it should be simple enough to implement at scale.</p>\n\n<p><strong>Update 2</strong> - Implemented @D.W. algorithm, sample run below:</p>\n\n<pre><code>    11:51:06 ~$ time nodejs progression.js \n    L: 694000000,694000002,694000006,694000007,694000009,694000010,\n        694000013,694000015,694000018,694000019,694000021,694000022,694000023,\n    694000026,694000028,694000030,694000034,694000036,694000038,694000040,\n    694000043,694000045,694000046,694000048,694000051,694000053,694000055,\n    694000057,694000060,694000061,694000063,694000067,694000069,694000072,\n    694000074,694000076,694000077,694000079,694000080,694000082,694000083,\n    694000084,694000086,694000090,694000091,694000093,694000095,694000099,\n    694000102,694000103,694000105,694000108,694000109,694000113,694000116,\n    694000118,694000122,694000125,694000128,694000131,694000134,694000137,\n    694000141,694000143,694000145,694000148,694000152,694000153,694000154,\n    694000157,694000160,694000162,694000163,694000166,694000170,694000173,\n    694000174,694000177,694000179,694000180,694000181,694000184,694000185,\n    694000187,694000189,694000193,694000194,694000198,694000200,694000203,\n    694000207,694000211,694000215,694000219,694000222,694000226,694000228,\n    694000232,694000235,694000236\n    N: 100\n    P: 0.1\n    L: 10 (min)\n    D: 26 (max)\n    [ 9, 18, 27, 36, 45, 54, 63, 72, 81, 90 ]\n    Found progression of 10 elements, difference: 16 starts: 694000045, ends: 694000189.\n\n    real    0m0.065s\n    user    0m0.052s\n    sys 0m0.004s\n</code></pre>\n', 'ViewCount': '249', 'Title': "Detecting a subsequence that's an arithmetic progression, in a sorted sequence", 'LastEditorUserId': '8380', 'LastActivityDate': '2013-12-16T10:54:37.677', 'LastEditDate': '2013-12-16T10:54:37.677', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '19002', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8380', 'Tags': '<algorithms><decision-problem><subsequences>', 'CreationDate': '2013-12-13T13:35:39.720', 'Id': '18951'}},