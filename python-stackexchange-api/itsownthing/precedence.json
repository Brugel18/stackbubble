385_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In working with <a href="http://en.wikipedia.org/wiki/Parser_combinator" rel="nofollow">parser combinators</a> I have been working with three means of handling <a href="http://en.wikipedia.org/wiki/Order_of_operations#Programming_languages" rel="nofollow">precedence</a> and <a href="http://en.wikipedia.org/wiki/Operator_associativity" rel="nofollow">associtivy</a> for <a href="http://en.wikipedia.org/wiki/Infix_notation" rel="nofollow">infix</a> operators.</p>\n\n<ol>\n<li><a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#classic" rel="nofollow">The classic solution</a>.</li>\n<li><a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#shunting_yard" rel="nofollow">Shunting Yard algorithm</a>.</li>\n<li><a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing" rel="nofollow">Precedence climbing</a>.</li>\n</ol>\n\n<p>I was wondering if there are any more ways to handle the construction of the an AST from infix operators that have precedence and associativity?</p>\n\n<p>I would prefer papers on the method and possibly an example of the code in a functional language.</p>\n\n<p>I recently ran into <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf" rel="nofollow">Mixfix</a> / <a href="http://dl.acm.org/citation.cfm?id=5659" rel="nofollow">distfix</a> but have not yet implemented a working version.</p>\n', 'ViewCount': '19', 'Title': 'For parser combinators what are the algorithms for handling precedence and associtivity?', 'LastEditorUserId': '268', 'LastActivityDate': '2013-11-30T21:15:22.443', 'LastEditDate': '2013-11-30T21:15:22.443', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<parsing><precedence><associtivity><infix><operators>', 'CreationDate': '2013-11-29T21:26:57.407', 'Id': '18478'},385_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Generally (perhaps always) in programming languages, unary operators have the highest precedence.  In some langauges, such as Standard ML, one can dynamically change the precedence of binary operators at run time.</p>\n\n<p>But what if we have a language where binary operators had higher precedence than unary ones?  Do such languages exist?  And how would we interpret certain cases?  For example, let's say binary <code>+</code> had higher precedence than unary prefix <code>@</code>.  In some cases this is obvious because it would mean that</p>\n\n<pre><code>@x+y\n</code></pre>\n\n<p>would parse as</p>\n\n<pre><code>@(x+y)\n</code></pre>\n\n<p>rather than</p>\n\n<pre><code>(@x)+y\n</code></pre>\n\n<p>BUT, how would we parse</p>\n\n<pre><code>x + @y\n</code></pre>\n\n<p>Would it be a syntax error (as in it cannot be parsed) or should it parse as <code>x+(@y)</code>?  I don't mean for this to necessarily be an opinion question; I am more interested to know if any real programming languages exist with high-precedence binary operators, and if so, what do they do.</p>\n", 'ViewCount': '65', 'Title': 'Binary operators with higher precedence than unary operators', 'LastActivityDate': '2013-12-10T23:54:24.810', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18846', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11993', 'Tags': '<parsing><precedence><operators>', 'CreationDate': '2013-12-10T17:23:59.173', 'Id': '18835'},385_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having trouble finding the language represented by the following:</p>\n\n<p>(AA|BB)*</p>\n\n<p>Should the expression be read as... ( A (A|B) B ) *\nor... ( (AA) | (BB) )*</p>\n\n<p>If that isn't clear, should this produce something like... ABABAB or should it produce AABBAABBBBAA</p>\n\n<p>My guess is that AABBAA is part of the represented language, while AB is not.</p>\n", 'ViewCount': '45', 'Title': 'Precedence in regular expressions', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T14:27:36.157', 'LastEditDate': '2014-02-03T09:34:49.770', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '20241', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-languages><terminology><regular-expressions><precedence>', 'CreationDate': '2014-02-03T05:47:10.583', 'Id': '20239'},385_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's say we have the following simple transaction-schedule:</p>\n\n<pre><code> T1  |  T2  |  T3\n-----+------+-----\n w(x)|      |\n     | w(x) |\n     |      | w(x)\n</code></pre>\n\n<p>T1 comes before T2, so in the precedence graph, we draw an arrow from T1 to T2. T2 comes before T3, so we draw an arrow from T2 to T3.</p>\n\n<p>My question is: <em>is it also necessary to draw an arrow from T1 to T3?</em> T1 comes before T3, and the definition of a precedence graph says nothing about not drawing a line from Tx to Ty if there is some arbitrary Tz inbetween.</p>\n\n<p>On the other hand, T1 -> T2 -> T3 implies T1 -> T3, and as the graph gets larger things will get a bit messy. Is it okay to 'reduce' a precedence graph?</p>\n\n<p>If the answer to the above question is yes, here is a follow up - consider the following schedule:</p>\n\n<pre><code> T1  |  T2  |  T3\n-----+------+-----\n w(x)|      |\n w(y)|      |\n     | w(x) |\n     | w(z) | \n     |      | w(y)\n     |      | w(z)\n</code></pre>\n\n<p>In the precedence graph, for the operations on x we draw an arrow from T1 to T2, for y an arrow from T1 to T3, and for z an arrow from T2 to T3. Would you be allowed to omit the arrow 'caused' by element z?</p>\n", 'ViewCount': '31', 'Title': 'Can you reduce a precedence graph or do *all* relevant nodes need to be connected', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-26T16:04:21.830', 'LastEditDate': '2014-03-25T23:12:34.890', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16126', 'Tags': '<database-theory><precedence>', 'CreationDate': '2014-03-25T22:17:08.717', 'Id': '23047'}