{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '893', 'Title': 'Universality of the Toffoli gate', 'LastEditDate': '2012-04-15T18:16:37.757', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '1', 'Body': '<p>Regarding the quantum <a href="https://en.wikipedia.org/wiki/Toffoli_gate" rel="nofollow">Toffoli gate</a>:</p>\n\n<ol>\n<li>is it <em>classicaly</em> universal, and if so, why?</li>\n<li>is it <em>quantumly</em> universal, and why?</li>\n</ol>\n', 'Tags': '<quantum-computing><circuits><turing-completeness>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-15T18:16:37.757', 'CommentCount': '8', 'AcceptedAnswerId': '345', 'CreationDate': '2012-03-13T06:22:59.583', 'Id': '289'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '165', 'Title': 'Depth-2 circuits with OR and MOD gates are not universal?', 'LastEditDate': '2012-05-28T00:53:31.890', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1661', 'FavoriteCount': '1', 'Body': '<p>It is well-known that every boolean function $f:\\{0,1\\}^n\\to \\{0,1\\}$ can be realized using a boolean circuit of depth 2 (over the variables, their negation and constant values) containing AND gates in the first level and one single OR gate in the upper level; this is simply the <a href="http://en.wikipedia.org/wiki/Disjunctive_normal_form" rel="nofollow">DNF representation</a> of $f$.</p>\n\n<p>Another type of gate which is of great interest in circuit complexity is the $MOD_m$ gate. The usual definition is the following:</p>\n\n<p>$$\\mathrm{MOD}_m(x_1,\\dots,x_k)=\\cases{\n  1 &amp; if \\(\\sum x_i \\equiv 0 \\mod m\\) \\\\\n  0 &amp; if \\(\\sum x_i \\not\\equiv 0 \\mod m\\) \\\\\n}$$</p>\n\n<p>These gates sometimes have surprising power; for example, any boolean function can be represented by a depth-2 circuit having only $\\mathrm{MOD}_6$ gates (this is folklore but I can elaborate is someone is interested).</p>\n\n<p>However, another folklore is that circuits with a single OR gate at the top and $\\mathrm{MOD}_m$ gates in the bottom layer (with $m$ being fixed once and for all, and in particular being the same for all the gates) is not universal, i.e. for any value of $m$, there are boolean functions that cannot be computed by $\\mathrm{OR} \\circ \\mathrm{MOD}_m$ circuit.</p>\n\n<p>I\'m looking for a proof for this claim, or at least some direction.</p>\n', 'Tags': '<complexity-theory><logic><circuits>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-28T00:53:31.890', 'CommentCount': '8', 'AcceptedAnswerId': '2109', 'CreationDate': '2012-05-27T10:29:22.540', 'Id': '2103'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Say you have $m$ boolean inputs, and you are given a threshold $n$. You need to construct a boolean circuit  that evaluates to true if at least $n$ of the inputs true. You may use AND, OR, NOT, or XOR gates (restricted to fan-in two, with arbitrary fan-out). Asymptotically how small can you make this circuit? </p>\n\n<p>Any reasonably tight upper bound would be appreciated. I keep on thinking of ways to recursively construct such a circuit but I can't find anything good. Also, any results for any other reasonable basis of allowed gates would also be useful.</p>\n", 'ViewCount': '195', 'Title': 'Circuit size for "at least n inputs are true"', 'LastEditorUserId': '755', 'LastActivityDate': '2013-05-28T06:04:32.053', 'LastEditDate': '2013-05-28T06:04:32.053', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2610', 'Tags': '<complexity-theory><circuits>', 'CreationDate': '2012-08-22T18:03:27.640', 'FavoriteCount': '2', 'Id': '3291'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to figure out why NOT and CNOT gates are not sufficient to create all bijective functions in classical circuits. I have been struggling on this for hours, and just can't make sense of it.</p>\n\n<p>I feel it has something to do with the Toffoli gate, as it contains an (implicit) AND operation, and I feel that's what missing in the NOT and CNOT gates. However I can't find a proper way to actually 'show' this.</p>\n", 'ViewCount': '84', 'Title': 'Universality of NOT and CNOT', 'LastEditorUserId': '683', 'LastActivityDate': '2012-10-18T18:49:28.290', 'LastEditDate': '2012-10-18T18:49:28.290', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '6142', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4238', 'Tags': '<logic><circuits>', 'CreationDate': '2012-10-17T23:01:11.503', 'Id': '6139'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>A threshold gate implementing a linear threshold function on $n$ boolean inputs $x_1, x_2 \\ldots, x_n$ is given by the equation:\n$w_1 x_1 + w_2 x_2 + \\ldots, w_n x_n \\ge t$\nwhere $w_1, \\ldots, w_n, t \\in \\mathbb{R}$. The $w_i$'s are called the weights of the threshold function and $t$ is called the threshold, and naturally, the gate fires a $1$ on an input $x$ if the weighted sum given by the equation above exceeds $t$. </p>\n\n<p>Now, almost everywhere in the literature on threshold circuits, I encounter this fact (which I am guessing, is folklore since I couldn't find a proof anywhere): The $w_i$'s in the linear equation above can be made integers (on $n \\log{n}$ bits), and a threshold circuit made up of these gates will still compute whatever was possible with real weights. I have given this some thought, and I think it must be a simple trick, but I have failed to obtain a proof of this fact. Can somebody help or provide me with a reference? (the only reference I could find was a text by Muroga, which I couldn't procure)</p>\n", 'ViewCount': '59', 'Title': 'Assumption on weights in threshold circuits', 'LastActivityDate': '2012-10-30T14:56:00.480', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6272', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '639', 'Tags': '<complexity-theory><circuits>', 'CreationDate': '2012-10-23T10:38:02.097', 'Id': '6259'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>$\\newcommand{\\np}{\\mathsf{NP}}\\newcommand{\\cc}{\\textrm{Circuit-SAT}}$I am having difficulty understanding the $\\np$-hardness proof for $\\cc$ in <a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">CLRS</a>.</p>\n\n<blockquote>\n  <p>$\\cc = \\{\\langle C \\rangle : C \\text{ is a satisfiable combinatorial boolean circuit} \\}$</p>\n  \n  <p><strong>Lemma:</strong> The $\\cc$ problem is $\\mathsf{NP}$-hard.</p>\n</blockquote>\n\n<p>Can anyone provide an easy-to-understand proof?</p>\n', 'ViewCount': '265', 'Title': 'Circuit Satisfiability problem is NP-Hard?', 'LastEditorUserId': '19', 'LastActivityDate': '2012-12-01T05:56:51.550', 'LastEditDate': '2012-12-01T05:56:51.550', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7034', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<complexity-theory><np-hard><satisfiability><circuits>', 'CreationDate': '2012-11-30T02:16:14.930', 'Id': '7032'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '157', 'Title': 'Building functionally complete boolean circuits out of trinary logic', 'LastEditDate': '2013-02-22T02:18:36.030', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '1', 'Body': '<p>There are some not-very-commonly considered forms of <a href="http://en.wikipedia.org/wiki/Three-valued_logic" rel="nofollow">trinary logic</a> using 3 truth values. Even entire (unusual/rare) <a href="http://en.wikipedia.org/wiki/Ternary_computer" rel="nofollow">ternary computers</a> have been built from it.</p>\n\n<blockquote>\n  <p>Is there some knowledge or reference of how to convert some trinary logic systems into functionally complete boolean circuits/logic?</p>\n</blockquote>\n\n<p>"Functionally complete" means all boolean functions can be computed. I am asking the more general question above in case the following more specific question does not have an answer. The motivation is more this specific following case. Consider the following "trinary truth table" for a single trinary operator.</p>\n\n<pre><code>   a b c\n\na  a c a\nb  c b b\nc  a b c\n</code></pre>\n\n<blockquote>\n  <p>Is it possible to somehow create functionally complete boolean circuits out of the single above trinary truth table operator? Or, maybe it can be definitively proven it\'s not possible?</p>\n</blockquote>\n\n<p>I am also looking for any reference to that or something similar. </p>\n', 'Tags': '<reference-request><logic><reductions><circuits>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-22T02:18:36.030', 'CommentCount': '4', 'AcceptedAnswerId': '9215', 'CreationDate': '2013-01-27T18:15:08.947', 'Id': '9211'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p><strong>Task</strong>:\nDesign a 2 bit comparator.</p>\n\n<p>Input: 2x 2 bit (I take it as 2 2-bit values, let them be unsigned for simplicity) \nOutput: 1 if result input1>input2 is true, 0 otherwise</p>\n\n<p>Develop truth table and derive circuits.</p>\n\n<p><strong>The problem</strong>: I'm completely new to this so I have not even a idea where where to look for the lighthouse. </p>\n\n<p><strong>The question</strong>: I'M NOT LOOKING FOR COMPLETE SOLUTION, instead I'm looking for a guidance through topics/materials which I should check to be able to solve it myself. </p>\n\n<p><strong>Done so far</strong>: I started with understanding logical gates and those seem to be pretty straight forward.</p>\n\n<p>P.S.: Purpose of posting this question is to boost the speed with which I will get to the actual solution. </p>\n\n<p><strong>SOLUTION:</strong>\nf(A,B,C,D) = !AB!C!D + A!C + ABC!D. (! - used for negation or NOR, ABC notations means A AND B AND C). I had three adjacent rectangles two of which were of unit cell size and one of 4 cells size (one cell was actually far away, but there's this toroidally connection property, not sure about terminology). A and B are MSD and LSD of the first number respectfully and B and C are same for second number. <em>As for the circuit image:</em> sorry folks my hand drawing requires strong mental stability.</p>\n", 'ViewCount': '61', 'Title': 'Creating a logical circuit', 'LastEditorUserId': '6793', 'LastActivityDate': '2013-02-09T21:19:13.900', 'LastEditDate': '2013-02-09T21:14:19.490', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '9622', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6793', 'Tags': '<logic><circuits>', 'CreationDate': '2013-02-09T19:50:07.537', 'Id': '9620'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>For example, I know that the non-regular language $a^nb^n$ is in $AC^0$. I would like to know more examples like this.</p>\n', 'ViewCount': '148', 'Title': 'Which non-regular languages are in $AC^0$?', 'LastActivityDate': '2013-02-13T00:40:15.447', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '9720', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '6817', 'Tags': '<complexity-theory><regular-languages><circuits>', 'CreationDate': '2013-02-12T12:32:20.147', 'FavoriteCount': '0', 'Id': '9704'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>It is known that $Parity \\notin AC^0$ (nonuniform), but the proof is rather involved and combinatorial. Are there simpler, but weaker lower bounds, say for $NP \\not \\subseteq AC^0$ or $NEXP \\not \\subseteq AC^0$?</p>\n\n<p>For example, can nontrivial simplifications be obtained in the proof of $NEXP \\not \\subseteq ACC^0$ to deal only with the special case of $AC^0$?</p>\n', 'ViewCount': '110', 'Title': 'Simple lower bounds against AC0', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-14T22:05:44.687', 'LastEditDate': '2013-02-14T21:44:12.463', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9786', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '667', 'Tags': '<complexity-theory><lower-bounds><circuits>', 'CreationDate': '2013-02-14T21:39:13.577', 'Id': '9783'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In boolean circuit complexity, a circuit is just defined by a Directed Acyclic Graphs with designated input and output nodes, where the intermediate nodes compute a specific boolean function. A circuit is called a formula if the underlying graph is a tree. i.e., the fan-out of each node is $1$. Is it true that for a formula, (given that its fan-out is already $1$, by defintion) the fan-in is also constant? </p>\n\n<p>In the usual definition of formulas, this is never spelt out(Its always defined as a circuit where all gates have fan-out $1$). But somehow I seem to carry around this intuitively that formulas are always bounded fan-in. (It might be partly due to the fact that poly-sized boolean formulas correspond to $\\mathsf{NC^1}$ which is a complexity class defined by bounded fan-in circuits of logarithmic depth).</p>\n\n<p>So my question is, if you bound the fan-out of the circuit to be $1$, does it imply even the fan-in should be constant for every gate? I tried to use a counting argument, that says that the indegree and outdegree of the graphs must sum to the same, but somehow a water tight proof eludes me. First of all, is my intuition correct?</p>\n', 'ViewCount': '124', 'Title': 'Formulas vs Circuits', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-21T19:09:38.490', 'LastEditDate': '2013-02-20T07:01:24.137', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6954', 'Tags': '<complexity-theory><logic><circuits>', 'CreationDate': '2013-02-19T19:27:27.227', 'Id': '9940'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>By "number of gates", I am wondering whether these gates include AND/OR gates that can receive several inputs or they just include AND/OR gates that receive two inputs.</p>\n', 'ViewCount': '53', 'Title': 'What does "number of gates" mean in circuit complexity?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-01T16:45:55.577', 'LastEditDate': '2013-03-01T16:45:55.577', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7084', 'Tags': '<complexity-theory><circuits>', 'CreationDate': '2013-03-01T00:26:09.313', 'Id': '10159'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<blockquote>\n  <p>Definition<br>\n  A family of circuits $(C_{1}, C_{2}, \\ldots)$ is uniform if some log\n  space transducer $T$ outputs $\\langle C_{n}\\rangle$ where $T$\'s input is $1^{n}$. (from <a href="http://en.wikipedia.org/wiki/Boolean_circuit#Uniform_Boolean_Circuits" rel="nofollow">http://en.wikipedia.org/wiki/Boolean_circuit#Uniform_Boolean_Circuits</a>)</p>\n</blockquote>\n\n<p>Can anyone exlain this? I know what boolean circuits are, so only explanation needed is what  and transducer exactly are.</p>\n', 'ViewCount': '106', 'Title': 'Definition of uniform boolean circuit', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T04:39:19.890', 'LastEditDate': '2013-03-01T03:49:03.477', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7084', 'Tags': '<complexity-theory><finite-automata><circuits>', 'CreationDate': '2013-03-01T02:09:59.500', 'Id': '10161'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>From <a href="http://rjlipton.wordpress.com/2009/05/27/arithmetic-hierarchy-and-pnp/" rel="nofollow">http://rjlipton.wordpress.com/2009/05/27/arithmetic-hierarchy-and-pnp/</a>,</p>\n\n<blockquote>\n  <p>Define, $M_{[x,c]}$ as the deterministic Turing machine that operates\n  as follows on an input $y$. The machine treats $x$ as a deterministic\n  program, and simulates $x$ on input $y$. At the same time the machine\n  runs a counter that stops its execution after steps $|y|^c$. If the\n  machine accepts before the counter stops, then it accepts; otherwise,\n  it rejects. </p>\n  \n  <p>Let $f(i,c)$ be the smallest natural number so that $M_{[i,c]}$makes a\n  mistake on the input $y$. Then, if $P \\neq NP$ is true, the function\n  $f(i,c)$ is always defined.</p>\n  \n  <p>Theorem: Suppose that there are infinite number of $i$ for which there exists a $c$ so that $$f(i,c) &gt; 2^{2^{|i|+c}}$$ Then, for infinitely many $n$, SAT has circuit size $n^{O(\\log n)}$. </p>\n  \n  <p>Proof: Let $i&gt;1$ and $c$ be so that $$f(i,c) &gt; 2^{2^{|i|+c}}$$ Define\n  $n = 2^{|i|+c-1}$. Note, that $c$ is at most $\\log n$. Then,\n  $M_{[i,c]}$ on all $y$ of length $n$ is correct, since $y \\leq 2^n = 2^{2^{|i|+c-1}} &lt; f(i,c)$.\n  The size of the circuit that simulates this Turing machine on inputs\n  of length $n$ is polynomial in $|i|$, $n$, and the running time of the\n  machine. The machine, by definition, runs in time $|y|^c \\leq n^c \\leq n^{\\log n}$</p>\n</blockquote>\n\n<p>I am not getting this part. Can anyone explain this (to specify, \u201cThe size of the circuit that simulates this Turing machine on inputs of length $n$ is polynomial in $|i|$, $n$, and the running time of the machine\u201d in the quote)? (So the question is how can we relate the running time of Turing machine to the size of the circuit.)</p>\n', 'ViewCount': '60', 'Title': 'How to relate circuit size to the running time of Turing machine', 'LastEditorUserId': '39', 'LastActivityDate': '2013-03-01T22:47:26.920', 'LastEditDate': '2013-03-01T22:47:26.920', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7087', 'Tags': '<complexity-theory><circuits>', 'CreationDate': '2013-03-01T06:53:18.167', 'Id': '10170'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I need to disprove that a <code>PARITY</code> gate can be simulated using a <strong>single</strong> <code>MAJORITY</code> gate, or even a <code>THRESHOLD</code> gate. How do I go about doing this? Some ideas as to how to go about contradiction or otherwise would be helpful.</p>\n\n<p>One possible argument would be monotonicity of <code>MAJORITY</code> and <code>THRESHOLD</code> while <code>PARITY</code> is non-monotone (Page 134 of <a href="http://www.igi.tugraz.at/psfiles/47.pdf" rel="nofollow">this paper</a>). But, I do not find this sufficiently convincing.</p>\n', 'ViewCount': '70', 'Title': 'PARITY using depth one TC0 circuit', 'LastEditorUserId': '2935', 'LastActivityDate': '2013-03-04T15:12:11.170', 'LastEditDate': '2013-03-04T15:12:11.170', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2935', 'Tags': '<complexity-theory><complexity-classes><circuits>', 'CreationDate': '2013-03-04T14:57:01.100', 'Id': '10261'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I can\'t wrap my head around how the SR Latch works. \nSeemingly, you plug an input line from R, and another from S, and you are supposed to get results in $Q$ and $Q\'$. </p>\n\n<p>However, both R and S require input from the other\'s output, and the other\'s output requires input from the other other\'s output. What comes first the chicken or the egg??</p>\n\n<p>When you first plug this circuit in, how does it get started? </p>\n\n<p><img src="http://i.stack.imgur.com/90iGQ.png" alt="SR Latch"></p>\n', 'ViewCount': '244', 'Title': 'How to understand the SR Latch', 'LastActivityDate': '2014-01-12T06:55:15.107', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10667', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<circuits><sequential-circuit>', 'CreationDate': '2013-03-19T13:03:40.427', 'FavoriteCount': '1', 'Id': '10614'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '745', 'Title': 'Why is the name half-adder used to represent the half-adder?', 'LastEditDate': '2013-03-23T18:08:14.133', 'AnswerCount': '3', 'Score': '1', 'OwnerDisplayName': u'De Z\xe9ro Toxin', 'PostTypeId': '1', 'OwnerUserId': '7395', 'FavoriteCount': '1', 'Body': u'<p>I have recently came across half-adders and full adders in my Logic Network lectures. I have somewhat understood the theory, but I am still unable to understand the reason why they called them in that name? I mean, is there any reason why half-adders have the name \u2018half-adders\u2019?</p>\n', 'Tags': '<terminology><circuits>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-17T16:07:16.090', 'CommentCount': '0', 'AcceptedAnswerId': '10712', 'CreationDate': '2013-03-23T14:59:29.613', 'Id': '10710'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have come across about RS Flip Flop &amp; I have tried implementing that on a simulator &amp; using actual logic gates. But I'm still not sure whether I have correctly understood the case unstable or the forbidden case S=1, R=1 in Flip flop. Can anyone tell me what exactly is that?</p>\n\n<p>By the way I have used 2-INPUT NAND Gates to implement the flip Flop. What is the difference between the NAND Gate Flip Flop &amp; NOR Gate Flip Flop, ?</p>\n", 'ViewCount': '126', 'ClosedDate': '2013-04-07T15:18:49.800', 'Title': 'Why S=1, R=1 Is forbidden in RS-Flip Flop', 'LastActivityDate': '2013-04-05T10:15:56.783', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7395', 'Tags': '<logic><circuits><sequential-circuit>', 'CreationDate': '2013-03-27T00:29:49.737', 'Id': '10816'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>From what I have understood :</p>\n\n<ol>\n<li>A Flip Flop is a clocked latch i.e. flip flop = latch + clock</li>\n<li>Latch continuously checks for inputs &amp; changes the output whenever there is a change in input</li>\n<li>Flip Flop also continuously checks input, but changes the output time determined by clock. [so, even though if inputs are changed, it may not change the output at the same time]</li>\n<li>A latch with enable [i.e. gated latch], is different from that of clocked latch. </li>\n</ol>\n\n<p>I am reading from Digital Logic by Morris Mano &amp; Wikipedia.</p>\n', 'ViewCount': '1012', 'Title': 'What is the exact difference between a latch & a flipflop?', 'LastEditorUserId': '6665', 'LastActivityDate': '2014-03-23T06:58:20.183', 'LastEditDate': '2013-04-07T06:07:48.347', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '11092', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<logic><circuits><sequential-circuit>', 'CreationDate': '2013-04-07T05:57:32.400', 'Id': '11090'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '142', 'Title': 'Can a Boolean circuit be considered an algorithm?', 'LastEditDate': '2013-05-28T14:50:54.623', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8367', 'FavoriteCount': '1', 'Body': '<p>Can a Boolean circuit by itself be considered an algorithm (a single step algorithm if you like)? For instance say you have a simple tree circuit with two AND gates as the input gates feeding a single OR gate for a depth two circuit. Now change the AND gates to XOR gates, is it correct to say that I now have a different algorithm for any given input? </p>\n', 'Tags': '<algorithms><terminology><circuits>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-28T14:50:54.623', 'CommentCount': '0', 'AcceptedAnswerId': '12298', 'CreationDate': '2013-05-26T13:26:47.687', 'Id': '12294'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have seen this model question on synchronous circuit , but i could not understand the logic,  can anyone please help me?</p>\n\n<p>"Develop the state diagram for a synchronous sequential circuit which will recognize the bit sequence 1101 (ie, every time the sequence 1101 is detected in the input bit stream, the circuit has to output a 1 and otherwise a 0)."</p>\n\n<p>What is the question here?? do we have consider all possible combinations ( 2^4 - 16 ) to do this ? if so , according to the question , do we have only one occasion where we get the output 1??</p>\n\n<p>please explain it.\n-Regards</p>\n', 'ViewCount': '60', 'Title': 'How to design this synchronous circuit?', 'LastActivityDate': '2013-06-08T16:50:56.530', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7395', 'Tags': '<logic><circuits>', 'CreationDate': '2013-06-08T14:44:11.917', 'Id': '12534'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m sitting an exam on Computer Architecture in a few days and i\'m stuck on a particular type of question.</p>\n\n<p>I\'m asked to:</p>\n\n<p><strong>Provide a detailed schematic for a functional unti that implements the following micro-operations</strong></p>\n\n<p><img src="http://i.stack.imgur.com/Hg1ol.png" alt="enter image description here"></p>\n\n<p>Any help would be great even just a nudge in the right direction.</p>\n', 'ViewCount': '65', 'Title': 'Functional Unit and Micro-operations Schematics', 'LastActivityDate': '2013-08-23T22:27:38.927', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9804', 'Tags': '<circuits><sequential-circuit>', 'CreationDate': '2013-08-23T22:27:38.927', 'Id': '13898'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given $x\\in\\Bbb N$, I would like to find $x\\bmod N$, where $N$ is composite. For example $N=35$, $x=53$ and $x\\bmod N=18$. Is this operation considered monotone in circuit/algebraic complexity language? I also want to have consider $x_1+x_2\\bmod N = x_1\\bmod N+x_2\\bmod N$ and $x_1x_2\\bmod N = (x_1\\bmod N)(x_2\\bmod N)$.</p>\n', 'ViewCount': '77', 'Title': 'Modulo operation in monotone complexity', 'LastEditorUserId': '9753', 'LastActivityDate': '2013-09-18T10:44:49.497', 'LastEditDate': '2013-09-18T10:44:49.497', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14383', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<complexity-theory><circuits>', 'CreationDate': '2013-09-17T14:13:55.767', 'Id': '14379'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to use gates that do addition and multiplication modulo 5 to emulate logic gates.</p>\n\n<p>Assuming false and true are mapped to 0 and 1 respectively (with 2, 3, and 4 being invalid), I figured out I can map the operations like this:</p>\n\n<pre><code>a and b -&gt; a*b (mod 5)\na or b -&gt; 2*(a+b)*(a+b+2) (mod 5)\n</code></pre>\n\n<p>I was wondering if there was a simpler approach.</p>\n\n<p>For the application I have in mind, a toy example of secure multi party computation using secret sharing, I haven't shown/discovered/figured-out yet if it's safe to re-use private values. If I have to recompute a, b, and a+b two times in order to do an <code>or</code>, costs would be exponential in the length of the circuit. (I'm only using tiny circuits so that's not a big deal, but it would be interesting to know if it was just a non-issue via a clever transformation.)</p>\n", 'ViewCount': '59', 'Title': 'Emulating boolean circuits using addition and multiplication (mod 5)', 'LastEditorUserId': '535', 'LastActivityDate': '2013-11-11T07:20:35.247', 'LastEditDate': '2013-11-11T06:06:12.970', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '17909', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '535', 'Tags': '<circuits><modular-arithmetic>', 'CreationDate': '2013-11-11T05:59:47.090', 'Id': '17908'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Sipser example 9.29</p>\n\n<p>He says: "one way to do so (compute the parity function with O(n) gates. One way to do so is build a binary tree that computes the XOR function, where the XOR function is the same as parity on 2 variables, and then implement each XOR gate with two NOTs and two ANDs, and one OR. ... Let A be the language of strings that contain an odd number of 1\'s. Then A has circuit complexity O(n)."</p>\n\n<p>I\'m not seeing the steps that lead to saying that A has circuit complexity of O(n). Why can we say that if we implement a binary tree of XORs we can compute the parity with O(n) gates?</p>\n', 'ViewCount': '57', 'Title': 'Computing parity function on n variables with O(n) gates', 'LastActivityDate': '2013-11-16T19:45:19.503', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18080', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10599', 'Tags': '<complexity-theory><circuits>', 'CreationDate': '2013-11-16T19:33:32.610', 'Id': '18079'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>If we suppose that we are given two numbers $a$ and $b$ to add, what circuit depth do we require to add them?</p>\n\n<p>I'm wondering if $a$ and $b$ are $O(n)$, and thus the amount of bits required to store $a$ and $b$ are $O(\\log_2(n))$, how much time and/or space we must require to add them.  </p>\n\n<p>I'm interested in the general case.  However, I am wondering if there is anything else to be said about the case of adding $a+2a+1$.  It would be spectacular if we could do this addition in constant circuit depth.</p>\n", 'ViewCount': '33', 'Title': 'What circuit depth is required to add?', 'LastActivityDate': '2014-01-03T01:45:41.977', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19472', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1667', 'Tags': '<circuits><binary-arithmetic>', 'CreationDate': '2014-01-03T00:44:01.267', 'Id': '19468'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the book "Computational complexity" of Barak and Arora, on page 112, they state that:</p>\n\n<blockquote>\n  <p>Theorem 6.15: A language has logspace-uniform circuits of polynomial size iff it is in P.</p>\n</blockquote>\n\n<p>The proof of this one is left as an exercise to the reader.  I think both directions are trivial:</p>\n\n<p>=> seems trivial, as a logspace TM that generates a circuit also runs in polynomial time, and hence is a P-uniform circuit, which is part of P.</p>\n\n<p>&lt;= seems trivial, as a language that has a polynomial-time TM can be transformed into a circuit with Cook-Levin\'s theorem in logspace.</p>\n\n<p>However, what I don\'t get is why the theorem 6.15 explicitly states that the circuits must be of <em>"polynomial size"</em>.  How can there exist a logspace-uniform circuit that isn\'t polynomial in size?  The logspace computable function itself cannot exceed a polynomial bound, how can it produce a circuit of superpolynomial size?</p>\n\n<p>Also, this theorem would imply that logspace-uniform circuits comprise the same languages as P-uniform circuits, which seems very unintuitive to me.\nI can\'t find any information on the relation between logspace-uniform and P-space uniform circuits on the web, so my assumption that they are equal is probably false, but I fail to see see why.</p>\n', 'ViewCount': '54', 'Title': 'Relation between logspace-uniform circuits and P-uniform circuits', 'LastActivityDate': '2014-03-22T03:21:45.520', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22923', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15965', 'Tags': '<polynomial-time><circuits>', 'CreationDate': '2014-03-21T11:15:21.080', 'Id': '22900'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '46', 'Title': u'Assume that SAT \u2208 PSIZE, does it imply that NP = coNP?', 'LastEditDate': '2014-03-24T22:45:55.480', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7068', 'FavoriteCount': '1', 'Body': "<p>Assume that $\\mathrm{SAT} \\in \\mathrm{PSIZE}$, does it imply that $\\mathrm{NP} = \\mathrm{coNP}$ ?</p>\n\n<p>I think that I've managed to show that if $\\mathrm{SAT} \\in \\mathrm{PSIZE}$, then both $\\mathrm{NP}$ and $\\mathrm{coNP}$ are contained in $\\mathrm{PSIZE}$, but I can't see how does help me. Any ideas ?</p>\n", 'Tags': '<complexity-theory><time-complexity><complexity-classes><circuits>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T22:45:55.480', 'CommentCount': '8', 'AcceptedAnswerId': '23019', 'CreationDate': '2014-03-24T21:11:49.613', 'Id': '23018'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>There is a basic result in circuit complexity that says:</p>\n\n<blockquote>\n  <p>There exists a language that cannot be solved with circuits of size $o(\\frac{2^n}{n})$.</p>\n</blockquote>\n\n<p>The argument is a simple counting argument on the number of boolean functions and the number of distinct circuits.  See, for example, <a href="http://theory.stanford.edu/~trevisan/cs254-14/lecture03.pdf">these lecture notes</a>.</p>\n\n<p>I believe it is unknown whether or not this bound is tight.  That is, we don\'t know if the following statement is true:</p>\n\n<blockquote>\n  <p>Every language can be solved with circuits of size $O(\\frac{2^n}{n})$.</p>\n</blockquote>\n\n<p>If this statement were true, would it have any interesting implications for complexity theory?</p>\n', 'ViewCount': '33', 'Title': 'Implications of the $\\Omega(\\frac{2^n}{n})$ circuit lower bound being tight', 'LastActivityDate': '2014-04-02T21:09:54.020', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23369', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '16172', 'Tags': '<complexity-theory><lower-bounds><circuits>', 'CreationDate': '2014-04-02T20:16:50.513', 'FavoriteCount': '1', 'Id': '23365'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>For simplicity, we can assume that only NAND gates are allowed.  An asymptotically correct solution is all I really need.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '25', 'ClosedDate': '2014-04-11T19:31:41.863', 'Title': 'How many size $s$ circuits from $\\{0, 1\\}^n \\to \\{0, 1\\}$ are there?', 'LastActivityDate': '2014-04-08T02:48:45.610', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23530', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16172', 'Tags': '<combinatorics><circuits>', 'CreationDate': '2014-04-07T23:58:47.293', 'Id': '23528'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'ve read <a href="http://cs.brown.edu/~jes/book/pdfs/ModelsOfComputation_Chapter2.pdf" rel="nofollow">this</a> which describes how to do do integer arithmetic in circuits. The one thing that it does not describe is how to do these operations with a modulus. How can modular arithmetic be done in circuits? Can someone point me to a resource or describe the modular step here?</p>\n', 'ViewCount': '23', 'Title': 'Circuits for Modular Arithmetic', 'LastActivityDate': '2014-04-08T23:02:21.387', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16568', 'Tags': '<circuits><modular-arithmetic>', 'CreationDate': '2014-04-08T22:03:25.713', 'Id': '23568'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was reading a paper of Buhrman and Homer "Superpolynomial Circuits, Almost Sparse Oracles and the Exponential Hierarchy" (<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.47.2228&amp;rep=rep1&amp;type=pdf" rel="nofollow">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.47.2228&amp;rep=rep1&amp;type=pdf</a>).</p>\n\n<p>On the bottom of page 2 they remark that the results of Kannan imply that $NEXPTIME^{NP}$ does not have polynomial size circuits. I know that in the exponential time hierarchy, $NEXPTIME^{NP}$ is just $\\Sigma_2EXP$, and I also know that Kannan\'s result is that $\\forall c\\mbox{   }\\exists L\\in\\Sigma_2P$ such that $L \\not\\in Size(n^c)$. Of course, Kannan\'s theorem is NOT saying $\\Sigma_2P \\not\\subset P/poly$ (in order for that to be the case we would need to show that $\\exists L\\in\\Sigma_2P$ such that $\\forall c$, $L \\not\\in Size(n^c)$. However, I don\'t see how Kannan\'s result implies that $NEXPTIME^{NP} \\not\\subset P/poly$?</p>\n', 'ViewCount': '7', 'ClosedDate': '2014-04-18T15:13:43.597', 'Title': "Question about Kannan's theorem", 'LastActivityDate': '2014-04-18T14:10:27.167', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16883', 'Tags': '<complexity-theory><circuits><oracle-machines>', 'CreationDate': '2014-04-18T14:10:27.167', 'Id': '23914'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>This circuit should be reasonably efficient in size and depth, but with priority on depth. </p>\n\n<p>If depth was not a concern, then I guess I could make a specialized adder for the least significant bit and then modelled the rest of the circuit as a ripple adder with only that initial, possible carry. The carry has to ripple through the first sequence of consecutive bits set to 1. For example:</p>\n\n<p>$inc(0111) = 1000$<br>\n$inc(0001) = 0010$<br>\n$inc(0100) = 0101$ (no ripple)</p>\n\n<p>But this takes linear time, in the worst case (binary string is $1...1$). How do you optimize for depth? Does the optimal circuit have a $log_2(n)$ depth? </p>\n\n<p>Is perhaps the best strategy to use a parallel prefix circuit? If so, I guess one would make a specialized adder for the least significant bit. Then you have the result of the least significant bit, which is 0 if a carry was generated, 1 otherwise. If a carry was generated, then you need to efficiently ripple it through all the adjacent, consecutive 1-bits. If one is to use a prefix sum, then you need an associative binary operator. It also needs to preserve the value of the bits that are not part of the initial, consecutive 1-bits (from right to left). This might mean that you pass in the carry bit that was (possibly) generated after the increment on the least significant bit, while the rest of the operators gets fed predefined bits which preserve the values of the relevant bits of the number (bit vector).  </p>\n\n<p>At this point, I'm stuck. </p>\n", 'ViewCount': '38', 'Title': 'Create a shallow logic circuit that increments a binary number', 'LastEditorUserId': '11089', 'LastActivityDate': '2014-05-01T22:16:07.173', 'LastEditDate': '2014-05-01T22:16:07.173', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11089', 'Tags': '<logic><circuits>', 'CreationDate': '2014-05-01T20:46:57.177', 'Id': '24307'}},