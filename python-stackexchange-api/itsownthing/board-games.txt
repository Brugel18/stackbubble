{'Body': '<p>I am looking for an efficient algorithm that lets me process the minimax search tree for chess with <a href="http://en.wikipedia.org/wiki/Alpha-beta_pruning" rel="nofollow">alpha-beta pruning</a> on a distributed architecture. The algorithms I have found (PVS, YBWC, DTS see below) are all quite old (1990 being the latest). I assume there have been many substantial advancements since then. What is the current standard in this field?</p>\n\n<p>Also please point me to an idiot\'s explanation of DTS as I can\'t understand it from the research papers that I have read.</p>\n\n<p>The algorithms mentioned above:</p>\n\n<ul>\n<li>PVS: Principle Variation Splitting</li>\n<li>YBWC: Young Brothers Wait Concept</li>\n<li>DTS: Dynamic Tree Splitting</li>\n</ul>\n\n<p>are all are discussed <a href="http://chessprogramming.wikispaces.com/Parallel+Search" rel="nofollow">here</a>.</p>\n', 'ViewCount': '250', 'Title': 'distributed alpha beta pruning', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-03T02:19:30.217', 'LastEditDate': '2012-04-03T02:19:30.217', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '905', 'Tags': '<algorithms><distributed-systems><board-games>', 'CreationDate': '2012-04-02T21:00:57.743', 'Id': '998'}{'Body': '<p>I\'m currently reading about machine learning and wondered how to apply it to playing <a href="http://en.wikipedia.org/wiki/Connect_Four">Connect Four</a>.</p>\n\n<p>My current attempt is a simple multiclass classificator using a sigmoid function model and the one-vs-all method.</p>\n\n<p>In my opinion, the input features have to be the state (disc of player 1, disc of player 2, empty) of the 7x6=42 grid fields. </p>\n\n<p>The output would be the number of the row to put the disc into. Because that is a discrete number between 1 and 7, I guess this can be treated as a multiclass classification problem.</p>\n\n<p>But how do I generate training examples usable in supervised learning? </p>\n\n<p>The main goal is to win the game but the outcome obviously isn\'t known when doing every but the last turn.\nIf I just let two players who decide randomly what to do play against each other thousands of times, will it be sufficient to simply take all turns made by the winner of each game round as training examples? Or do I have to do this in a completly different way?</p>\n\n<p><strong>Edit: As suggested in the comments I read a little about reinforcement learning.</strong>\nFrom what I know understand, Q-Learning should do the trick, i.e. I have to approximate a function Q of the current state and the action to take to be the maximum cumulative reward beginning in that state. Then each step would be to choose the action which results in the maximum value of Q. However, this game has way too many states in order to do this e.g. as a lookup table. So, what is an effective way to model this Q-Function?</p>\n', 'ViewCount': '718', 'Title': 'Machine learning algorithm to play Connect Four', 'LastEditorUserId': '994', 'LastActivityDate': '2012-06-13T08:41:59.500', 'LastEditDate': '2012-04-08T19:08:11.937', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '994', 'Tags': '<machine-learning><board-games>', 'CreationDate': '2012-04-07T20:06:32.017', 'FavoriteCount': '1', 'Id': '1117'}{'Body': '<p>We got tower $T_1$ with $n$ odd disks (1,3,5,...) and tower $T_2$ with $n$ even disks (2,4,6,...).\nNow we want to move all $2n$ disks to tower $T_3$.\nIf $T(p,q)$ is a recurrence relation of minimum number of moves we make to move $p$ disks from $T_1$ and $q$ disks from $T_2$ to $T_3$, we must find $T(n,n)$.</p>\n\n<p>If anyone has any idea, please share.</p>\n', 'ViewCount': '179', 'Title': 'An Alternative Hanoi Tower problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-07T17:03:01.067', 'LastEditDate': '2012-10-05T11:00:19.797', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '3046', 'Tags': '<algorithms><recurrence-relation><board-games>', 'CreationDate': '2012-10-04T05:27:08.737', 'FavoriteCount': '0', 'Id': '4872'}{'Body': '<p>I have just read <a href="http://en.wikipedia.org/wiki/Mental_poker" rel="nofollow">mental poker</a>, described in this <a href="http://people.csail.mit.edu/rivest/ShamirRivestAdleman-MentalPoker.pdf" rel="nofollow">fascinating paper(PDF)</a> by cryptographic greats Adi Shamir, Ron Rivest, and Leonard Adleman.</p>\n\n<p>Assuming I have a website, (TTP) how can I prove to the player that the hand dealt to him is fair? Most importantly how can I prove that I didn\'t bruteforce until an unfair hand is dealt to him to gain house edge, are there any C# implentations of such code?</p>\n', 'ViewCount': '129', 'Title': 'Mental poker: proving dealt hand is fair', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-15T22:49:18.767', 'LastEditDate': '2012-12-08T23:15:38.550', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4939', 'Tags': '<probability-theory><cryptography><board-games>', 'CreationDate': '2012-12-08T21:20:39.903', 'FavoriteCount': '2', 'Id': '7257'}{'Body': '<p>In a bridge game, a deck of 52 cards (13 spades , 13 clubs, 13 diamonds, 13 spades) are dealt to 4 players (13 cards each) then game starts.Game session ends after 13 tricks each having 4 cards.There are 28561 possible non repeated 4 card groups.</p>\n\n<p>What is the best method of generating and storing all possible trick combinations (played according to the bridge rules just for one session) to be further processed by a computer program (i.e., data structures such as game trees, and any open source algorithms written for any computer language if any).</p>\n\n<p>All resources to read to get the theory behind or any references are welcome.\nThank you.</p>\n', 'ViewCount': '407', 'Title': 'Data structures and algorithms for bridge game play?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-30T09:54:03.547', 'LastEditDate': '2013-04-04T06:33:12.213', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5210', 'Tags': '<algorithms><data-structures><combinatorics><board-games>', 'CreationDate': '2012-12-27T12:12:28.953', 'Id': '7618'}{'Body': '<p>I don\'t understand how the star1 variation mentioned in the paper is <a href="http://mlanctot.info/files/papers/mcms-ecai-cgw.pdf" rel="nofollow">Sparse Sampling for Adversarial</a> different than the usual star1 algorithm?</p>\n\n<blockquote>\n  <p>(Taken from the bottom of page 7). This variant can be easily\n  described in terms of the descriptions of Star1. To enable sampling,\n  one need only change the implementation of getOutcomeSet on line 5 of\n  Algorithm 1. Instead of generating the full list of moves, the new\n  function samples c outcomes with replacement and assigns a uniform\n  distribution over the new outcome set of size c.</p>\n</blockquote>\n\n<p>Does the variation only generate some of the possible game states and not all of them? </p>\n\n<p>I think I understand star1 but I don\'t really understand star2 because it is more complicated. I only have a bachelor\'s degree in computers and this theoretical stuff is way above my head. Thanks for any help that I get. :)</p>\n', 'ViewCount': '21', 'Title': 'How does this star1 variation work? (star1 is a stochastic (dice) algorithm for artificial intelligence in adversarial games)', 'LastActivityDate': '2013-03-15T17:39:02.003', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7297', 'Tags': '<artificial-intelligence><board-games>', 'CreationDate': '2013-03-15T17:39:02.003', 'Id': '10536'}{'ViewCount': '155', 'Title': 'Poker with Bluffing (game theory)', 'LastEditDate': '2013-03-27T12:09:43.310', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'drozzy', 'PostTypeId': '1', 'OwnerUserId': '7433', 'Body': '<p>I\'m doing a self-study of <a href="http://rads.stackoverflow.com/amzn/click/0691140510" rel="nofollow">Game Theory Evolving by Gintis</a>, and am stuck on problem 4.16 "Poker with Bluffing".</p>\n\n<p>The first question asks "<em>Show that Ollie has 64 pure strategies and Stan has 8 pure strategies.</em>". But no matter how I try to approach this, I can\'t get more then 4 strategies for Stan!</p>\n\n<p>Here is the game tree for the game in question:\n<img src="http://i.stack.imgur.com/XbN6c.jpg" alt="enter image description here"></p>\n\n<p>The question marks (?) in the figure mean that the payoff depends on who has the higher card.</p>\n\n<p>Here is the game description:</p>\n\n<ul>\n<li>Two players, each with a deck of three cards: H (high), M(medium) or L (low).</li>\n<li>Each puts \\$1 in the pot, chooses random card</li>\n<li>Ollie (P1) either stays or raises</li>\n<li>Stan (P2) simultaneously also stays or raises</li>\n<li>If both raise/stay - highest card wins the pot (tie - they take their money back)</li>\n<li>If Ollie raises, Stan stays  Ollie gets the \\$3 pot.</li>\n<li>If Stan raises and Ollie stays - Ollie gets another chance:\n<br>-> Drop - Stand wins the \\$3 pot\n<br>-> Call - add \\$1 to the pot.</li>\n</ul>\n\n<p>Why does Stand have 8 pure strategies?</p>\n', 'Tags': '<game-theory><board-games>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T21:36:48.740', 'CommentCount': '0', 'AcceptedAnswerId': '10820', 'CreationDate': '2013-03-26T18:46:38.850', 'Id': '10818'}{'ViewCount': '161', 'Title': 'Hanoi tower with forbidden direct move from source to destination', 'LastEditDate': '2013-05-19T07:30:47.883', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8251', 'FavoriteCount': '0', 'Body': "<p>I want to know what is algorithm and time complexity of Hanoi tower with forbidden direct move from source to destination (<em>it means you cannot move disk from source to destination directly and you instead of that should first move disk from source to middle and then from middle to destination</em>) and other rules as normal problem?</p>\n\n<p>I didn't find any article about it.</p>\n", 'Tags': '<algorithms><recurrence-relation><board-games>', 'LastEditorUserId': '8251', 'LastActivityDate': '2013-11-21T05:09:37.510', 'CommentCount': '6', 'AcceptedAnswerId': '12399', 'CreationDate': '2013-05-19T06:20:09.157', 'Id': '12130'}{'Body': '<p>I have made a connect four game in JS and currently have a functioning minimax algorithm. The problem I\'m having is that it is very, very easy to beat, even with a large depth. This is leading me to believe that I need a better heuristic function, but I cannot come up with much better than what I already have. So, I thought I would ask if anyone has any experience, or just a good idea, for a very good heuristic to use. I would also accept improvement ideas on my current heuristic below. Thank you in advance!</p>\n\n<p>EDIT: I\'m going to go ahead and post my total minimax in here (3 functions total), because I have added disjoints and made my 4-in-a-row higher, but my AI is still terrible. I know my 2,3 and 4-in-a-rows work because I tested them, but I can\'t pin-point why I\'m still having trouble even at high depths.</p>\n\n<pre><code>    function getBestMove(currBoard,depth,who) {\n        var opp;\n        //Get opponent for next piece\n        if(who == \'a\') {\n            opp = \'p\';\n        } else {\n            opp = \'a\';\n        }\n\n        var tBoard = new Array(rows);\n        for(var i=0; i&lt;tBoard.length; i++) {\n            tBoard[i] = new Array(cols);\n        }\n\n        var moves = new Array(aiOpenCols.length);\n        //Drop each piece and use minimax function until depth == 0\n        for(var i=0; i&lt;aiOpenCols.length; i++) {\n            for(var j=0; j&lt;rows; j++) {\n                for(var k=0; k&lt;cols; k++) {\n                    tBoard[j][k] = currBoard[j][k];\n                }\n            }\n            tBoard = dropPiece(aiOpenCols[i],who,tBoard);\n            moves[i] = minimax(tBoard,(+depth - 1),opp,aiOpenCols[i]);\n        }\n\n        var bestAlpha = -100000;    //Large negative\n        //Use random column if no moves are "good"\n        var bestMove;// = Math.floor(Math.random() * aiOpenCols.length);\n        //bestMove = +aiOpenCols[bestMove];\n        //Get largest value from moves for best move\n        for(var i=0; i&lt;aiOpenCols.length; i++) {\n            if(+moves[i] &gt; bestAlpha) {\n                bestAlpha = moves[i];\n                bestMove = aiOpenCols[i];\n            }\n        }\n\n        bestMove++; //Offset by 1 due to actual drop function\n        return bestMove;\n    }\n    function minimax(currBoard,depth,who,col) {\n        //Drop current piece, called from getBestMove function\n        currBoard = dropPiece(col,who,currBoard);\n\n        //When depth == 0 return heuristic/eval of board\n        if(+depth == 0) {\n            var ev = evalMove(currBoard);\n            return ev;\n        }\n        var alpha = -100000;    //Large negative\n        var opp;\n        //Get opponent for next piece\n        if(who == \'a\') {\n            opp = \'p\';\n        } else {\n            opp = \'a\';\n        }\n\n        //Loop through all available moves\n        for(var i=0; i&lt;aiOpenCols.length; i++) {\n            var tBoard = new Array(rows);\n            for(var i=0; i&lt;tBoard.length; i++) {\n                tBoard[i] = new Array(cols);\n            }\n            for(var j=0; j&lt;rows; j++) {\n                for(var k=0; k&lt;cols; k++) {\n                    tBoard[j][k] = currBoard[j][k];\n                }\n            }\n            //Continue recursive minimax until depth == 0\n            var next = minimax(tBoard,(+depth - 1),opp,aiOpenCols[i]);\n            //Alpha = max(alpha, -minimax()) for negamax\n            alpha = Math.max(alpha, (0 - +next));\n        }\n        return alpha;\n    }\n    function evalMove(currBoard) {\n        //heuristic function\n        //AI = # of 4 streaks + # of 3 streaks + # of 2 streaks - # of 3 streaks opp - # of 2 streaks opp           \n        var fours = checkFours(currBoard,\'b\');\n        //If win return large positive\n        if(fours &gt; 0) return 100000;\n        var threes = checkThrees(currBoard,\'b\') * 1000;\n        var twos = checkTwos(currBoard,\'b\') * 10;\n        var oppThrees = checkThrees(currBoard,\'r\') * 1000;\n        var oppTwos = checkTwos(currBoard,\'r\') * 10;\n\n        var scores = threes + twos - oppThrees - oppTwos;\n\n        //If opponent wins, return large negative\n        var oppFours = checkFours(currBoard,\'r\');\n        if(+oppFours &gt; 0) {\n            return -100000;\n        } else {\n            return scores;\n        }\n    }\n</code></pre>\n', 'ViewCount': '2190', 'Title': 'Trying to improve minimax heuristic function for connect four game in JS', 'LastEditorUserId': '9365', 'LastActivityDate': '2013-07-27T07:38:13.270', 'LastEditDate': '2013-07-26T19:24:17.710', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9365', 'Tags': '<algorithms><heuristics><board-games>', 'CreationDate': '2013-07-26T14:27:09.390', 'FavoriteCount': '1', 'Id': '13453'}{'Body': "<p>I'm interested in building an AI algorithm to play a board game.  This is a sequential two-player game, where they alternate taking turns, so minimax or alpha-beta algorithms sound natural.</p>\n\n<p>However, the twist here is that the game is randomized.  There is a deck of cards that is shuffled randomly; each turn involves drawing the next card from the deck, then making a move.</p>\n\n<p>What algorithms are appropriate for selecting a move, in a game with randomness?</p>\n\n<p>I understand that one approach is to think of this as a three-player game: in addition to the two players, there is a third player (the dealer) who makes a random move.  For instance, if the two players are Minnie and Maxwell, we might alternate moves in the following order: Dealer (chooses a random card for Minnie), Minnie (selects a move), Dealer (chooses a random card for Maxwell), Maxwell (selects a move), and so on.  I think I've read that alpha-beta search can be adapted to this setting.  However, this doesn't sound too promising to me.  There are perhaps 52 possible outcomes of the moves by Dealer, so the tree will be very bushy (with a large branching factor), causing exponential blowup.  Also, this sort of modified alpha-beta search feels a bit inefficient to me.  Each move likely affects a player's score by only a little bit at a time, so we'd expect that the effects of the randomness to average out over many moves, and there is no need to explore all combinations of possible random outcomes.  To put it another way: the game is more about positional elements and random luck than about tactical/combinatorial elements.</p>\n\n<p>Is there a better algorithm framework for randomized games, that takes into account the stochastic element?  (Bonus points if you can suggest something that takes advantage of the fact the strength of a position changes only slowly over many moves.)</p>\n", 'ViewCount': '130', 'Title': 'Algorithms to play randomized game', 'LastActivityDate': '2013-10-09T11:57:28.203', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><artificial-intelligence><board-games><computer-games>', 'CreationDate': '2013-10-01T06:56:49.967', 'Id': '14729'}{'Body': '<p>Ok, I must admit this a task from my studies but I\'m stuck.</p>\n\n<p>Rules of the game are on <a href="https://en.wikipedia.org/wiki/Hey!_That%27s_My_Fish!" rel="nofollow">Wikipedia.</a> However, we have a modified version: on input we have a board with x fields, there are y penguins on some fields, there may be gaps between fields. All penguins are the same, they can move only to the farthest possible location (in a straight line, can\'t jump over gaps and other penguins). There is one player and he needs to move the penguins in such manner so as to get the maximal number of fish. I have to come up with an algorithm that finds the sequence of moves that leads to the best possible result.</p>\n\n<p>I tried something like guessing the final arrengment of the fields (f.e. all the penguins left on fields with just one fish each) and then reverse-engineer the steps but I didn\'t go any further with my idea.</p>\n\n<p>I also thought it would be probably good to represent this as a graph, possibly with weighted edges and then do some graph search but again, I don\'t know what next.</p>\n\n<p>Finally, there was a thought about using Monte Carlo method. However, this just seems too hardcore for a class project like this and that would be too diffult for me.</p>\n\n<p>Any ideas where should I start?</p>\n', 'ViewCount': '65', 'Title': 'Algorithm playing modification of "Hey, That\'s My Fish!" game', 'LastActivityDate': '2013-10-23T22:03:08.947', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16380', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10941', 'Tags': '<algorithms><board-games>', 'CreationDate': '2013-10-23T21:46:21.323', 'Id': '16377'}{'ViewCount': '638', 'Title': 'Is Dominosa NP-Hard?', 'LastEditDate': '2013-11-12T22:26:57.560', 'AnswerCount': '2', 'Score': '20', 'OwnerDisplayName': 'user987415', 'PostTypeId': '1', 'OwnerUserId': '10573', 'FavoriteCount': '4', 'Body': '<p>Dominosa is a relatively new puzzle game. It is played on an $(n+1)\\times(n+2)$\n  grid. Before the game begins, the domino bones  $\\left(0,0\\right),\\left(0,1\\right),\\ldots,\\left(n,n\\right)$\n  are placed on the grid (constituting a perfect tiling). In the next step, the domino bones are hidden, leaving only the numbers revealed. The purpose of the game is to recover the original arrangement of the domino bones.\nYou can play the game here: <a href="http://www.puzzle-dominosa.com/">http://www.puzzle-dominosa.com/</a>:</p>\n\n<p>Rules:</p>\n\n<blockquote>\n  <p>The rules are simple. You have to find the location of all the dominoes on the grid. A domino is a pair of numbers. You can only have one of each pair.</p>\n</blockquote>\n\n<p>I have some polynomial algorithms that solve a relatively small part of the puzzle. I could also show that typical Dominosa grids have at least $2^{\\frac{n}{2}+o\\left(n\\right)}$ solutions.</p>\n\n<p>Is Dominosa NP-Hard? </p>\n', 'Tags': '<complexity-theory><np-hard><board-games><tiling>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T15:02:32.800', 'CommentCount': '9', 'CreationDate': '2013-09-12T12:18:43.740', 'Id': '16850'}{'Body': "<p>Im designing a program to play Connect 6, a variation of connect 4. I have narrowed down my options to the following:</p>\n\n<p>1) Minimax with Alpha-Beta Proning </p>\n\n<p>2) A Neural Net </p>\n\n<p>3) Machine Learning</p>\n\n<p>My program has one second to make a move, so I can only branch out 2 moves ahead with Minimax. Which solution would best perform under 1 second?</p>\n\n<p>I looked around the web, but couldn't find anything relevant.</p>\n\n<p>Also, are there any other additional resources you suggest I have a look at?</p>\n", 'ViewCount': '333', 'Title': 'Algorithms for Connect 4?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-15T23:35:49.010', 'LastEditDate': '2013-11-15T14:46:39.167', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'OwnerDisplayName': 'asd', 'PostTypeId': '1', 'Tags': '<algorithms><machine-learning><artificial-intelligence><board-games>', 'CreationDate': '2013-11-11T16:49:58.777', 'FavoriteCount': '1', 'Id': '18012'}{'Body': '<p>The algorithm (from <a href="http://en.wikipedia.org/wiki/Mastermind_%28board_game%29" rel="nofollow">here</a>) - </p>\n\n<blockquote>\n  <ol>\n  <li><p>Create a set S of remaining possibilities (at this point there are 1296). The first guess is aabb.</p></li>\n  <li><p>Remove all possibilities from S that would not give the same score of colored and white pegs if they were the answer.</p></li>\n  <li><p>For each possible guess (not necessarily in S) calculate how many possibilities from S would be eliminated for each possible\n  colored/white score. The score of the guess is the least of such\n  values. Play the guess with the highest score (minimax).</p></li>\n  <li><p>Go back to step 2 until you have got it right.</p></li>\n  </ol>\n</blockquote>\n\n<p>I confused about the 3nd step - </p>\n\n<p>what is mean -  </p>\n\n<blockquote>\n  <p>how many possibilities from S would be eliminated for each possible\n  colored/white score</p>\n</blockquote>\n\n<p>what is the "correct answer" and the "guess" here  ? </p>\n\n<p>Can someone clear it some more ? </p>\n', 'ViewCount': '317', 'Title': 'Mastermind (board game) - Five-guess algorithm', 'LastEditorUserId': '4409', 'LastActivityDate': '2013-12-08T23:49:43.557', 'LastEditDate': '2013-12-08T18:02:05.260', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18756', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4409', 'Tags': '<algorithms><game-theory><board-games>', 'CreationDate': '2013-12-08T13:56:57.047', 'Id': '18749'}{'Body': '<p>Hello I am trying to solve the AlienTiles problem described at <a href="http://www.alientiles.com" rel="nofollow">alientiles.com</a> using the A* algorithm but I cannot find any good heuristic function so far.</p>\n\n<p>In AlienTiles you have a board with $N \\times N$ tiles, all coloured red. By clicking on a tile, all tiles in the same row and column advance to the next color, with the colour order being red $\\rightarrow$ green $\\rightarrow$ blue $\\rightarrow$ purple, resetting to red after purple. A goal state is a state where every tile has the same colour, as long as its not red.</p>\n\n<p>Is there any good point to start? I am completely frustrated about how I am supposed to handle the problem. An easy function that I came up with was the distance of the colour of the current tile with the target tile, but it is very slow.</p>\n', 'ViewCount': '145', 'Title': 'Solving AlienTiles with an A* heuristic', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-29T02:29:56.353', 'LastEditDate': '2014-01-28T14:09:31.010', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '20054', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13168', 'Tags': '<algorithms><search-algorithms><heuristics><board-games>', 'CreationDate': '2014-01-27T21:01:28.317', 'Id': '20017'}{'ViewCount': '32', 'Title': 'How do I compute this non terminal positions evaluation, for tic-tac-toe?', 'LastEditDate': '2014-02-15T21:17:43.797', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14704', 'FavoriteCount': '2', 'Body': u'<p>Looking at this <a href="http://www-scf.usc.edu/~csci460/docs/homework/solution2.pdf" rel="nofollow">solution on page 3</a> but having trouble understanding the evaluation function specifically.   </p>\n\n<blockquote>\n  <p>For non terminal positions, we use a linear evaluation function\n  defined as</p>\n  \n  <p>Eval (s) = 3[X2(s)]+X1(s)\u2212(3[O2(s)]+O1(s))</p>\n  \n  <p>We define X n ( s ) as the number of rows, columns, and diagonals in\n  state s with exactly n X\u2019s and no O\u2019s, and similarly define O n ( s )</p>\n</blockquote>\n\n<p>Looking at this state \'s\' for example (these problems accounts for symmetry):</p>\n\n<pre><code>|X| | |\n| |O| |\n| | | |\n</code></pre>\n\n<p>It shows an evaluation of <code>-1</code>  </p>\n\n<p>However, got 0:  </p>\n\n<p>X2(s) = 0 because there are no rows or columns with 2 X\'s.<br>\nX1(s) = 2 because the top row and left column both have 1 X (but the diagonal has an O)</p>\n\n<p>O2(s) = 0 because there are no rows or columns with 2 O\'s.<br>\nO1(s) = 2 because the middle row and middle column both have 1 O (but the diagonal has an X)</p>\n\n<p>Plugging in:  </p>\n\n<pre><code>0+2 - (0+2) = 0\n</code></pre>\n\n<p>So, I thought I am missing symmetry but I just get a bigger scale that still = 0\'s.</p>\n\n<p>I must be overlooking something simple but not sure.</p>\n\n<p>Any help is appreciated.</p>\n', 'Tags': '<heuristics><game-theory><board-games>', 'LastEditorUserId': '14704', 'LastActivityDate': '2014-02-15T22:09:24.987', 'CommentCount': '0', 'AcceptedAnswerId': '21681', 'CreationDate': '2014-02-15T21:12:25.917', 'Id': '21679'}{'ViewCount': '49', 'Title': 'Where is the recursion, in the minimax-decision algorithm?', 'LastEditDate': '2014-02-17T00:11:58.803', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14704', 'FavoriteCount': '2', 'Body': '<p>The below is from an article titled: </p>\n\n<blockquote>\n  <p><strong>Minimax: Recursive Implementation</strong></p>\n</blockquote>\n\n<p><img src="http://i.stack.imgur.com/l00le.png" alt="enter image description here"></p>\n\n<p>To be a recursive function, <a href="https://www.youtube.com/watch?v=72hal4Cp_2I&amp;feature=player_detailpage#t=23" rel="nofollow">you need to call yourself</a>.</p>\n\n<ul>\n<li>What part of this pseudo code is calling itself?</li>\n<li>How does depth-first effect the recursion process?</li>\n<li>There seems to be a return in every line of <code>minimax-value</code>,\nshouldn\'t the return be only on a terminal case?</li>\n<li>Will <code>value[op]</code> contain the moves in order from the root node?</li>\n<li>What does <code>Apply(op,game)</code> do the very first time through?</li>\n</ul>\n\n<p>Any pointers are greatly appreciated.</p>\n', 'Tags': '<heuristics><game-theory><board-games>', 'LastEditorUserId': '14704', 'LastActivityDate': '2014-02-17T05:01:36.407', 'CommentCount': '2', 'AcceptedAnswerId': '21719', 'CreationDate': '2014-02-17T00:04:36.773', 'Id': '21710'}{'ViewCount': '64', 'Title': 'Time complexity of 8-queen, by placeing one by one without attack', 'LastEditDate': '2014-02-22T09:23:17.930', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14922', 'FavoriteCount': '1', 'Body': '<p>I am new to artificial intelligence. I have been trying to analyse the time complexity of 8-queen, by placing one by one without attack.</p>\n\n<p>One approach to achieve goal state is to "add a queen to any square in the leftmost empty column such that it is not attacked by any other queen". And this approach will have a state space of 2057 (also wondering: How to compute this?)</p>\n\n<p>What is the time complexity if I am using Depth First search algorithm (which I think is the most suitable one)? How about the space complexity?</p>\n\n<p>I am puzzled because the brunching of the search tree is reducing greatly when goes deep. $O(8^8)$ looks too much for time complexity, even for worst case.</p>\n', 'Tags': '<time-complexity><search-problem><board-games>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T09:23:17.930', 'CommentCount': '2', 'AcceptedAnswerId': '21908', 'CreationDate': '2014-02-21T20:05:40.270', 'Id': '21905'}{'Body': "<p>In some (historical) papers, chess has been referred to as the drosophila of artificial intelligence. While I suppose that in current research, the mere application of a search algorithm is at best <em>advanced computer science</em>, I believe that there are still area's where can apply (and practice) AI-techniques.</p>\n\n<p>A simple example would be <em>opening book learning</em> where one can <em>teach</em> the program whether to use or to not use certain moves in the opening because the program is unsuited to certain types of position. We can use a form of re-inforcement learning and automate this: I suppose I could play the program against itself and increase the probability of winning lines and decrease the probability of losing lines.</p>\n\n<p>The more complex example is to use a learning <em>evaluation</em> function (for example, one could tweak the values of <em>piece-square tables</em>). However, I'm thinking:</p>\n\n<ul>\n<li>given all the noise due to there being an enormous amount of realistic positions (as opposed to the amount of realistic opening lines)</li>\n<li>and with the cost (duration) of a computer chess game, and the need to play loads.</li>\n</ul>\n\n<p>How can one do this effectively? (or should I look at other techniques, for example neural networks.)</p>\n", 'ViewCount': '25', 'Title': 'How to use Artificial Intelligence in Computer Chess', 'LastEditorUserId': '6980', 'LastActivityDate': '2014-02-24T18:59:10.990', 'LastEditDate': '2014-02-24T18:59:10.990', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '13', 'OwnerDisplayName': 'ljgw', 'PostTypeId': '1', 'Tags': '<artificial-intelligence><board-games>', 'CreationDate': '2014-02-07T08:27:31.867', 'Id': '21970'}