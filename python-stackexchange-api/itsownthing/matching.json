{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a run-time implementation question regarding the 3-dimensional (unweighted 2-)approximation algorithm below:\nHow can I construct the maximum matching M_r in S_r in linear time in line 8?</p>\n\n<p>$X, Y, Z $ are disjoint sets; a matching $M$ is a subset of $S$ s.t. no two triples in $M$ have the same coordinate at any dimension.</p>\n\n<p>$\n\\text{Algorithm: unweighted 3-dimensional matching (2-approximation)} \\\\\n\\text{Input: a set $S\\subseteq X \\times Y \\times Z$ of triples} \\\\\n\\text{Output: a matching M in S}\n$</p>\n\n<pre><code> 1) construct maximal matching M in S;  \n 2) change = TRUE;  \n 3) while (change) {  \n 4)   change = FALSE;  \n 5)   for each triple (a,b,c) in M {  \n 6)     M = M - {(a,b,c)};  \n 7)     let S_r be the set of triples in S not contradicting M;  \n 8)     construct a maximum matching M_r in S_r;  \n 9)     if (M_r contains more than one triple) {  \n10)       M = M \\cup M_r;  \n11)       change = TRUE;  \n12)     } else {  \n13)       M = M \\union {(a,b,c)};  \n14)     }  \n15) }  \n</code></pre>\n\n<hr>\n\n<p>[1] <a href="http://faculty.cse.tamu.edu/chen/courses/cpsc669/2011/notes/ch9.pdf" rel="nofollow">http://faculty.cse.tamu.edu/chen/courses/cpsc669/2011/notes/ch9.pdf</a>, p. 326</p>\n', 'ViewCount': '459', 'Title': '3-dimensional matching approximation algorithm (implementation details)', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T19:29:47.290', 'LastEditDate': '2013-01-13T19:29:47.290', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2574', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2037', 'Tags': '<algorithms><graphs><approximation><matching>', 'CreationDate': '2012-07-01T17:27:37.793', 'Id': '2571'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Am I correct in my observation that the cardinality of the maximum matching $M$ of a bipartite graph $G(U, V, E)$ is always equal to $\\min(|U|, |V|)$?</p>\n', 'ViewCount': '233', 'Title': 'Size of Maximum Matching in Bipartite Graph', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T19:28:25.763', 'LastEditDate': '2013-01-13T19:28:25.763', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4676', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2922', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2012-09-22T20:14:11.160', 'Id': '4675'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let us say you have a group of guys and and a group of girls. Each girl is either attracted to a guy or not, and vice versa. You want to match as many people as possible to a partner they like.</p>\n\n<p>Does this problem have a name? Is it feasibly solvable? Sounds hard to me...</p>\n\n<p>Ps. note that since the attraction is not neccessarily mutual the standard max-flow solution does not work.</p>\n', 'ViewCount': '120', 'Title': 'Matching girls with boys without mutual attraction (variant of maximum bipartite matching)', 'LastActivityDate': '2012-11-21T13:16:46.817', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6811', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2826', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2012-11-21T10:50:19.373', 'Id': '6807'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '437', 'Title': 'Clarification with Kuhn-Munkres/Hungarian Algorithm', 'LastEditDate': '2012-12-12T20:25:07.587', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1025', 'FavoriteCount': '1', 'Body': '<p>I have been attempting to get my mind around the <a href="http://en.wikipedia.org/wiki/Hungarian_algorithm" rel="nofollow">Kuhn-Munkres/Hungarian Algorithm</a>. I have been using the following statement of the algorithm which I found <a href="http://www.math.uwo.ca/~mdawes/courses/344/kuhn-munkres.pdf" rel="nofollow">here</a>.</p>\n\n<p><img src="http://i.stack.imgur.com/sieBq.png" alt="Kuhn-Munkres Algorithm"></p>\n\n<p>Based on my readings on the algorithm, my understanding is that the improvement of the feasible vertex labeling in step 2. is supposed to be such that $G_l \\subset G_l\'$.</p>\n\n<p>The part I\'m getting stuck on is that it seems to me that it is possible for there to be an edge $xy$ in $G_l$ with $y \\in T$ but $x \\not \\in S$ resulting in the fact that\n$$\nl\'(x) + l\'(y) = l(x) + (l(y) + \\alpha_l) \\not = w(xy)\n$$\nand so $ xy \\not \\in G_l\'$ and $G_l \\not \\subset G_l\'$.</p>\n\n<p>Can anyone point out where I\'m going wrong?</p>\n', 'Tags': '<algorithms><bipartite-matching>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-12T20:25:07.587', 'CommentCount': '8', 'AcceptedAnswerId': '7363', 'CreationDate': '2012-12-11T22:26:40.083', 'Id': '7341'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are polynomial time algorithms to find maximum weighted matching in a general graph. Is there any algorithm that also handles negative weights in the general graph and find maximum weighted matching for that graph with negative weights ?</p>\n', 'ViewCount': '148', 'Title': 'Maximum weight matching', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T05:16:27.090', 'LastEditDate': '2013-01-13T05:16:27.090', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'user12902', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><matching>', 'CreationDate': '2012-12-19T17:54:18.953', 'Id': '7526'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have 2 questions regarding Bipartiteness with corresponding examples.</p>\n\n<p>1) Can a non-connected graph be bipartite if it has an isolated vertex? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/AzAxV.png" alt="enter image description here">\n<br/>\nI would say YES with this partition:\nV<sub>1</sub> = {A, D, G}\n; V<sub>2</sub> = {B, C, E, F, H}\n<br/>But what confuses me is that A is isolated.\n<br/>Is that a contradiction to the bipartitiness of G ?</p>\n\n<p>2) Is there a rule about the uniqueness of the partitions ? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/dbQww.png" alt="enter image description here">\n<br/>choice1:\nV<sub>1</sub>= {A, C}; V<sub>2</sub> = {B, D}\n<br/>choice2:\nV<sub>1</sub>= {A, D}; V<sub>2</sub> = {B, C}</p>\n\n<p>Does it matter which one i choose?</p>\n', 'ViewCount': '82', 'Title': 'Graph Bipartiteness', 'LastActivityDate': '2013-01-08T02:45:16.330', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7824', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2013-01-08T02:10:47.957', 'Id': '7823'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '266', 'Title': 'Proof of the Stable Matching Problem', 'LastEditDate': '2013-02-06T04:32:07.017', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6577', 'FavoriteCount': '1', 'Body': u'<p>Looking at the document <em>Fundamentals of Computing Series</em>, <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15251-f10/Site/Materials/Lectures/Lecture21/lecture21.pdf" rel="nofollow">The Stable Marriage Problem</a>.</p>\n\n<p>Theorem 1.2.3 - page 12:</p>\n\n<blockquote>\n  <p>In a man-optimal version of stable matching, each woman has worst\n  partner that she can have in any stable matching.</p>\n</blockquote>\n\n<p>Proof:</p>\n\n<blockquote>\n  <p>Suppose not. Let $M_0$ be the man-optimal stable matching, and\n  suppose there is a stable matching $M\u2019$ and a woman $w$ such\n  that $w$ prefers $m = p_{M_0}(w)$ to $m\' = p_{M\'}(w)$ . But\n  then $(m,w)$ blocks $M\'$ unless $m$ prefers $p_{M\'}(m)$ to \n  $w = p_{M_0}(m)$, in contradiction of the fact that $m$ has no\n  stable partner better than his partner in $M_0$.</p>\n</blockquote>\n\n<p>I\'m having trouble visualizing the definition of the problem and the proof (what is the contradiction?).</p>\n\n<p>First, what is the question implying?  From what I read and the fact that in most stable matching examples, all the women do not end up with the completely last person on their list ... So I\'m a bit confused.</p>\n\n<p>In the proof, here is what I am getting: in $M\'$ we suppose $w$ prefers $m$ to $m\'$.  But then if there is a stable matching containing $(m,w)$ this would leave $w$ with her worst partner and that is a contradiction.  Is this correct?</p>\n\n<p>In addition, if $m$ did prefer $w\'$ it would contradict that it is not his first pick ?</p>\n\n<p>I\'m new to computer science concepts so any help is appreciated.</p>\n', 'Tags': '<algorithms><proof-techniques><matching>', 'LastEditorUserId': '6577', 'LastActivityDate': '2013-02-06T04:32:07.017', 'CommentCount': '0', 'AcceptedAnswerId': '9197', 'CreationDate': '2013-01-27T06:02:59.647', 'Id': '9196'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am a bit confused. Somehow I have a problem connecting two problems together. The Closest String problem and the problem of matching with mismatches. They seam to be related but, I fail to see the connection. The Closest String problem is defined as :</p>\n\n<blockquote>\n  <p><em>Instance:</em> Strings $S_{1},S_{2}...S_{n}$ over alphabet $\\Sigma$ of length $L$ each and a non-negative integers $d$ and $n$.</p>\n  \n  <p><em>Parameters:</em> $n,d$</p>\n  \n  <p><em>Question:</em> Is there a string $s$ of length $L$ such that $\\delta(s,S_{i})\\leq d$ for all $i=1..n$?</p>\n</blockquote>\n\n<p>Note: $\\delta(x,y)\\leq d$ is the Hamming distance between $x$ and $y$.</p>\n\n<p>This problem is proven to be NP-complete.</p>\n\n<p>On the other hand we have a problem of matching with mismatches, which is described as:</p>\n\n<blockquote>\n  <p>The problem of string matching with $d$ mismatches consists of finding all occurrences of a pattern of length $m$ in a text of length $n$ such that in at most $d$ positions the text and the pattern have different symbols. In the following, we assume that $0 &lt; d &lt; m$ and $m\\leq n$. </p>\n</blockquote>\n\n<p>Landau and Vishkin gave the first (to my knowledge) efficient algorithm to solve this problem in $O(kn)$ time.</p>\n\n<p>Now my question is:</p>\n\n<p>Is matching with mismatches, or can it be seen, as a special parametrized case of the Closest String problem and how is this connection made?</p>\n', 'ViewCount': '42', 'Title': 'Is matching with mismatches a special(parametrized) case of Closest String problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-04T15:47:42.317', 'LastEditDate': '2013-02-04T15:47:42.317', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9468', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6697', 'Tags': '<np-complete><decision-problem><matching>', 'CreationDate': '2013-02-04T09:54:26.547', 'Id': '9467'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This <a href="http://www.cs.utexas.edu/~moore/best-ideas/string-searching/index.html">page</a> about Knuth-Moriss-Pratt Algorithm compared to Boyer-Moore describes a possible case where the Boyer-Moore algorithm suffers from small skip distance while KMP could perform better.<br>\nI\'m looking for a good example (text,pattern) that can clearly demonstrate this case.</p>\n', 'ViewCount': '504', 'Title': 'An example where Knuth-Morris-Pratt Algorithm is faster than Boyer-Moore?', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-20T19:23:37.120', 'LastEditDate': '2013-02-10T14:23:12.430', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '736', 'Tags': '<algorithms><substrings><matching>', 'CreationDate': '2013-02-10T10:41:28.470', 'Id': '9635'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '88', 'Title': 'Bipartite graph question', 'LastEditDate': '2013-02-11T22:39:58.533', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2003', 'FavoriteCount': '1', 'Body': "<p>Assume you are given a bipartite graph $G = (U, V, E)$ and you are given an integer $n$. Assume also that for each $v \\in V$, you are given two integers $v_{min}$ and $v_{max}$ (where $v_{min} \\le v_{max}$).</p>\n\n<p>The problem is to find a subset $U'$ of $U$ of size $n$ such that for each $v \\in V$, the number of edges coming into $v$ from $U'$ is between $v_{min}$ and $v_{max}$.</p>\n\n<p>Given a problem like this, can we determine efficiently whether there is a solution? And, if there is a solution, can we find one efficiently?</p>\n\n<p>If we can't do so efficiently, is there an approximation algorithm?</p>\n", 'Tags': '<algorithms><graphs><bipartite-matching>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-11T22:57:36.760', 'CommentCount': '2', 'AcceptedAnswerId': '9694', 'CreationDate': '2013-02-11T22:35:47.340', 'Id': '9693'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '696', 'Title': 'How to find the maximum independent set of a directed graph?', 'LastEditDate': '2013-03-06T01:05:54.933', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5218', 'FavoriteCount': '2', 'Body': u'<p>I\'m trying to solve <a href="http://www.spoj.com/problems/DIVREL/" rel="nofollow">this problem</a>.  </p>\n\n<blockquote>\n  <p><strong>Problem</strong>: Given $n$ positive integers, your task is to select a maximum number of integers so that there are no two numbers $a, b$ in which $a$ is divisible by $b$.</p>\n</blockquote>\n\n<p>I have to find the Maximum independent set and the size of this set.   The size can be found by <a href="http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29" rel="nofollow">K\xf6nig\'s theorem</a>. But how can I find the Maximum Independent Set (i.e. which vertex are part of the set).  </p>\n\n<p>I did some search also and found something <a href="http://apps.topcoder.com/forums/?module=Thread&amp;threadID=647913&amp;start=0&amp;mc=5#1127789" rel="nofollow">here</a>:</p>\n\n<p><code>If removing a vertex does not change minimum path cover then I can get the desired  result without that vertex.</code></p>\n\n<p>But I don\'t understand the underlying theorem. Any help will be greatly helpful.</p>\n', 'Tags': '<algorithms><graph-theory><bipartite-matching>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-06T01:05:54.933', 'CommentCount': '3', 'AcceptedAnswerId': '10303', 'CreationDate': '2013-03-04T22:16:02.387', 'Id': '10274'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a problem that I was able to conceptualize as following:</p>\n\n<h2>Problem</h2>\n\n<p>We have a set of n people. And m subsets representing their ethnicity like White, Hispanic, Asian etc. Given any combination of these people, I want to check if it is a diverse group.</p>\n\n<p>A diverse group is a group that satisfies several requirements, each requirement is of the form "at least $k_i$ persons in the group belong to subset $S_i$". Here is the tricky part, one person can only be used to satisfy one requirement. As in, you can\'t use him/her for multiple requirements.</p>\n\n<h2>Example:</h2>\n\n<p>Given:</p>\n\n<p>At least two people from Hispanic= {a,b,c}</p>\n\n<p>At least two people from African={a,d,e}</p>\n\n<p>Is the group {a,c,d} a diverse group?</p>\n\n<p>The group {a,c,d} is not diverse because you cant count a as Hispanic and African. But, the group {a,c,d,e} is diverse because we have two Hispanics a and c and two African d and e.</p>\n\n<h2>Attempt:</h2>\n\n<p>I think this is an instance of the Assignment problem. The jobs are the ethnicity and we can put as many ethnicity as the requirement dictate. For example, if we need two Hispanic, then we put two Hispanic jobs. However there only some people are able to do a particular job. Is there a name for such a problem? any algorithms somewhere in the internet? If not how would the implementation look like? </p>\n\n<p>This is my attempt so far:</p>\n\n<p>I will construct a bipartite graph with the set of people $P$ on one hand and the set of ethnicity on the other $S$. We will put an edge between a person $p_i$ and an ethnicity $S_i$ if he/she belongs to the ethnicity.\n Now, we will modify the graph, for every ethnicity $S_i$ duplicate it $k_i$ times ($S_{i,1}, S_{i,2}, ... , S_{i,k_i}$). And add new edges accordingly. Find the maximum matching M of this graph. </p>\n\n<p>Now, merge the $S_{i,j}$s into one $S_i$ and there you have a diverse group. However, a maximum matching is only a possible solution to to the problem. And my problem is a decision problem, I want to check if a given group is a solution or not. </p>\n', 'ViewCount': '217', 'Title': 'Assignment problem with no cost', 'LastActivityDate': '2013-03-20T13:40:37.340', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7320', 'Tags': '<graph-theory><bipartite-matching><matching><assignment-problem>', 'CreationDate': '2013-03-17T23:04:11.883', 'FavoriteCount': '1', 'Id': '10591'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I have a graph $G$ with $M(G)$ the (unknown) set of perfect matchings of $G$. Suppose this set is non-empty, then how difficult is it to sample uniformly at random from $M(G)$? What if I am okay with a distribution that is close to uniform, but not quite uniform, then is there an efficient algorithm?</p>\n', 'ViewCount': '113', 'Title': 'Sampling perfect matching uniformly at random', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-26T10:12:47.543', 'LastEditDate': '2013-03-26T10:12:47.543', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '10758', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<algorithms><complexity-theory><matching><sampling>', 'CreationDate': '2013-03-24T21:22:33.253', 'Id': '10756'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $B = G(L, R, E)$ be a bipartite graph. I want to find out whether this graph has a perfect matching. One way to test whether this graph has a perfect matching is Hall's Marriage Theorem, but it is inefficient (i.e $|\\mathcal P(L)| = 2^{|L|}$ tests -- not polynomial). I can always find out whether a perfect matching exists by computing a maximum cardinality matching and testing its perfectness, but this involves computing that perfect matching. </p>\n\n<p>Is there an <em>efficient</em> way of deciding whether a perfect bipartite matching exists without computing the matching it self? Ideally I would want an algorithm which is faster than algorithms like Hopcroft Karp or matrix based matching algorithms, which explicitly find out the matching (i.e so not computing the matching makes sense).</p>\n\n<p>Edit: The italic part.</p>\n", 'ViewCount': '380', 'Title': 'Existence of bipartite perfect matching', 'LastEditorUserId': '7312', 'LastActivityDate': '2013-03-29T13:21:34.500', 'LastEditDate': '2013-03-29T12:55:00.763', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10895', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7312', 'Tags': '<graphs><bipartite-matching>', 'CreationDate': '2013-03-29T12:12:45.210', 'Id': '10891'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the Hopcroft-Karp algorithm for bipartite matching, I don't understand the purpose of the breadth first search.  I think it's used to find a set of vertex disjoint augmenting paths, but I'm not sure what the significance of that is or even what that means.  Why do the augmenting paths have to be the shortest?  And why do they have to be vertex disjoint?</p>\n", 'ViewCount': '169', 'Title': 'In the Hopcroft-Karp algorithm, what is the purpose of the breadth first search?', 'LastActivityDate': '2013-08-17T13:24:49.037', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2013-05-15T02:46:31.397', 'Id': '12030'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Input</strong>: A set of $n$ Users $U=\\{u_1, ..., u_n\\}$ and a set of $m$ products $I=\\{i_1, ..., i_m\\}$. Associated with each pair $u \\in U$ and $i \\in I$  is the probability $p_{u,i}$ of $u$ purchasing the product $i$.<br/>\n  <strong>Task</strong>: Assign each user exactly $k$ products so that the following objective function is maximized:<br/>\n  $$\\sum_{i \\in I(U)} ({1-\\prod_{u\\in U(i)}{(1-p_{u,i})}})$$<br/>\n  Where $I(U)\\subseteq I$ is the set of products assigned to some user, and $U(i) \\subseteq U$ is the set of users to whom a product $i$ is assigned.</p>\n</blockquote>\n\n<p>Question: Is this problem NP-Hard?</p>\n', 'ViewCount': '56', 'Title': 'Hardness of a special case of maximum matching', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-28T07:27:34.407', 'LastEditDate': '2013-05-28T07:27:34.407', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8344', 'Tags': '<complexity-theory><reductions><np-hard><matching>', 'CreationDate': '2013-05-25T02:15:10.840', 'Id': '12260'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am new to this and an amateur... please help.</p>\n\n<p><strong>My Question in practical terms:</strong>\nGiven The three following inputs... determine the number of <em>unique</em> group arrangements as an ordered set.</p>\n\n<p><strong>INPUT:</strong>\n\'a\' = Students\n\'b\' = Groups\n\'c\' = students per group</p>\n\n<p><strong>OUPUT ANSWER:</strong>\n\'z\' as an integer</p>\n\n<p><strong>OUTPUT RULES:</strong>\n - All elements considered are ordered from left to right starting with the smallest number.\n - Order is not important... (1,2,3)=(2,3,1)=(3,2,1)=(3,1,2)=(1,3,2)=(2,1,3)...THEREFORE (1,2,3) is the only unique group that is to be counted.</p>\n\n<hr>\n\n<p><strong>Problem Example #1:</strong>\nI have 12 students that I need to arrange into 4 groups.  I want the 4 groups to each contain 3 students with no student appearing in more than one group. How many arrangements are there? In this instance there are 880 ordered arrangements. \n[Output Format: (1,2,3)(4,5,6)(7,8,9)(10,11,12)]</p>\n\n<p><strong>Problem Example #2:</strong>\nI have 12 students that I need to arrange into 3 groups.  I want the 3 groups to each contain 2 students with no student appearing in more than one group. How many arrangements are there? In this instance there are 13,860 ordered arrangements.\n[Output Format: (1,4)(3,6)(7,11)]</p>\n\n<p><strong>Problem Example #3:</strong>\nI have 24 students that I need to arrange into 3 groups.  I want the 3 groups to each contain 6 students with no student appearing in more than one group. How many arrangements are there? In this instance there are 125,847,260 ordered arrangements.\n[Output Format: (1,2,3,4,5,6)(9,10,11,12,13)(15,16,17,18,19,20)]</p>\n\n<hr>\n\n<p>Unless I am mistaken, these are not \'combinations\' or \'permutation\'s or \'complete sets\' or \'hoyosa index\'.  So, for lack of better terms I am calling them <em>ordered sets within ordered groups</em> for now. </p>\n\n<p>Is there a known formula to generate the answer without generating all possible solutions and searching? </p>\n\n<p><strong>20130822---ADDENDUM---</strong>\nThe numbers provided are accurate. The closest description tat I can call relate this to would be "Independent Edge Set AKA Matching"... except that I BELIEVE matching has a limit of two students per group. Sticking to the "Two Students per group" this can be determined using factorials similar to those you have provided.  HOWEVER, I cannot find a formula that allows for the three INPUTS a,b,c as provided and ONLY accounts for unique ordered sets. </p>\n\n<p>Using Problem Example #2:  12 Students (a), 2 groups (b), 3 students (c), = 13,860 unique ordered sets\nSet #1[(1,2,3,)(4,5,6)]\nSet #2[(1,2,3,)(4,5,7)]\nSet #3[(1,2,3,)(4,5,8)]\n... Set #13,860 [(7,8,9)(10,11,12)]</p>\n', 'ViewCount': '76', 'Title': "Is there a formula to state the number of 'sets' of 'ordered sets within ordered groups'?", 'LastEditorUserId': '9773', 'LastActivityDate': '2013-08-22T17:41:58.063', 'LastEditDate': '2013-08-22T15:45:07.363', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13872', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9773', 'Tags': '<combinatorics><sets><matching>', 'CreationDate': '2013-08-21T22:05:30.310', 'Id': '13861'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is one point I don\'t understand in the DFA construction for mismatch cases.</p>\n\n<p>Here is the lecture note I watched, which describes how to handle mismatched characters during the DFA construction process.</p>\n\n<p><img src="http://i.stack.imgur.com/r4Q1Z.png" alt="enter image description here"></p>\n\n<p>Some information about the presentation screen shot:</p>\n\n<p><code>pat</code> is the pattern, string index starts at 0, <code>dfa</code> is the state transition table, in which the row is indexed by the character(eg, "A","B" or "C"), column by state(1,2,3,...).</p>\n\n<hr>\n\n<p><strong>My question starts</strong>:</p>\n\n<p>In the place in the presentation, where starts with "<em>To compute dfa[c][j]</em>", it says run the simulation using the last j-1 chars.</p>\n\n<p>I am confused:</p>\n\n<p>Why run the simulation using the last <code>j-1</code> chars, rather the last <code>j</code> chars. </p>\n\n<p>What\'s the intuition of this design?</p>\n', 'ViewCount': '277', 'Title': u'Confusion about finite automata construction in Knuth\u2013Morris\u2013Pratt algorithm', 'LastEditorUserId': '4662', 'LastActivityDate': '2013-12-01T06:48:14.043', 'LastEditDate': '2013-10-18T19:04:46.790', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><finite-automata><strings><matching>', 'CreationDate': '2013-10-18T09:15:06.677', 'FavoriteCount': '1', 'Id': '16195'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So say we have a bipartite graph G=(X,Y,E). Let\'s make a game out of it.</p>\n\n<p>I go first. I pick a node in X. You go next. You pick a node in Y that is connected by an edge to the node I picked. Next it\'s my turn. I pick another node in X (must be a new one that hasn\'t been used before) that is also connected to the node in Y you just picked. We continue playing in this manner, until someone cannot pick a node (i.e. all edges out of the current node have already been used). When that happens, the person who cannot pick a next node loses.</p>\n\n<p>I\'m supposed to find a polynomial time algorithm to decide which of the two players (you or me) can force a "win" for a given bipartite graph.</p>\n\n<p>I\'m stumped. I\'ve approached this in many different ways, including the following two:</p>\n\n<p>1) 1) each node in the xy "path" played will use two edges, except for the first and last nodes which will only use one edge. Idea: add one new node on each side of the bipartite graph, and connect to all opposite nodes. Then check for a perfect (or maximal) matching twice, removing the edges used in the first perfect (maximal) matching when finding the second one. I don\'t think this really helps us with the problem, though, as there are many different nodes you could visit next given a current node.</p>\n\n<p>2) A second idea was to work with alternating/augmenting paths (as we "zig-zag" between the two sides). I again got stuck since at any given node there are many possible nodes to visit next.</p>\n\n<p>Does anyone have any suggestions for this problem? I\'m thinking it has to do with matching, but I could be wrong.</p>\n\n<p>Thanks in advance!</p>\n', 'ViewCount': '120', 'Title': 'Bipartite Graph Game', 'LastActivityDate': '2013-11-13T08:27:30.500', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '17976', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10680', 'Tags': '<graph-theory><graphs><combinatorics><computer-networks><bipartite-matching>', 'CreationDate': '2013-11-12T22:58:47.500', 'Id': '17974'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two sets A and B of sizes |A| = n and |B| = m, where m >= n.\nThere are edges from set A to set B.\nI need to find the <code>number</code> of matchings where all of vertices in set A have been matched with one vertex in set B.\nIs it possible to caclulate this quantity ?</p>\n\n<p>(I have very little knowledge of Graph Thory and Bipartite Matching or how it is computed)</p>\n', 'ViewCount': '38', 'Title': 'Number of Matchings in a Bipartite', 'LastActivityDate': '2013-12-25T14:20:27.127', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19276', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graphs><combinatorics><bipartite-matching><matching>', 'CreationDate': '2013-12-25T14:06:18.887', 'Id': '19275'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question was asked in the onsite regionals for ACM ICPC 2013 at Amritapuri.\nIn short, the question asked to find the number of ways to fill a $ 2\\times N$ grid with $M$ colors such that no two cells with the same row or same column have the same color.</p>\n\n<p>The limits given are $1 \\leq N$, and $M \\leq 1000$ with 1000 test cases per input. </p>\n\n<p>Based on the constraints the approach that comes to my mind after a long struggle includes having a precomputed DP table which can be used for every test case. I tried to apply the inclusion-exclusion principle but could not come up with any solution. I also tried to solve it using bipartite perfect matchings, but no success. How should I approach this question?</p>\n', 'ViewCount': '276', 'Title': 'Number of ways to fill a 2xN grid with M colors', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-27T17:23:20.610', 'LastEditDate': '2013-12-27T17:23:20.610', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19291', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><combinatorics><permutations><bipartite-matching>', 'CreationDate': '2013-12-25T20:33:19.390', 'Id': '19288'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In the last 2 paragraphs of the paper about Hopcroft\u2013Karp algorithm to find the maximum cardinality matching in bipartite graph:</p>\n\n<blockquote>\n  <p><a href="https://dl.dropboxusercontent.com/u/64823035/04569670.pdf" rel="nofollow">https://dl.dropboxusercontent.com/u/64823035/04569670.pdf</a></p>\n  \n  <p>The execution time of a phase is O(m+n), where m is the number of\n  edges in G, and n is the number of vertices. Hence the execution time\n  of the entire algorithm is O((m+n)s), where s is the cardinality of a\n  maximum matching.</p>\n  \n  <p>If G has n vertices then m &lt;= n^2 / 4 and s &lt; n / 2 so that the\n  execution time is bounded by O(n^(5/2)).</p>\n</blockquote>\n\n<p>I don\'t understand given:</p>\n\n<pre><code>m &lt;= n^2 / 4\ns &lt;= n / 2\n</code></pre>\n\n<p>why they concluded:</p>\n\n<pre><code>O((m+n)s) = O(n^(5/2))\n</code></pre>\n\n<p>Shouldn\'t it be:</p>\n\n<pre><code>O((m+n)s) = O(n^3)\n</code></pre>\n\n<p>Any idea?</p>\n', 'ViewCount': '78', 'Title': u'Hopcroft\u2013Karp algorithm time complexity', 'LastEditorUserId': '12572', 'LastActivityDate': '2014-01-03T14:30:49.710', 'LastEditDate': '2014-01-03T14:30:49.710', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12572', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal><bipartite-matching>', 'CreationDate': '2014-01-03T13:58:38.513', 'Id': '19486'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have question on understanding the following neighborhood relation within a local-search approximation scheme. \nLet $M$ be a legal matching on any bipartite graph. \nLet $U_k$ be the neighborhood defined as follows:\n$$U_k := \\{M' : |(M' \\backslash M) \\cup (M \\backslash M')| \\leq k\\}$$</p>\n\n<p>Can somebody give me an example or explain this to me? </p>\n\n<p>If i choose a small k-value, the cardinality of $M'$ will be small as well, but how does an algorithm decide which matching pair of nodes to take?</p>\n\n<p>If we define node-values and make it a weighted matching,let say we define a weight function $w_e \\in \\mathbb{R}$ for any edge e in our graph, now the algorithm may use greedy method and take the best possible pair of nodes (with greatest weight). </p>\n\n<p>But I still don't understand the exact set definition of our neighborhood.</p>\n\n<p>I would be grateful for an example, because I'm stumped on this one. </p>\n", 'ViewCount': '59', 'Title': 'Local search: Problem with neighborhood definition', 'LastActivityDate': '2014-01-10T12:36:41.790', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19626', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12731', 'Tags': '<optimization><approximation><heuristics><bipartite-matching>', 'CreationDate': '2014-01-10T11:48:35.183', 'Id': '19625'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Recently i\'ve been dealing with a problem that led me to the following questions:</p>\n\n<ul>\n<li>Is there a good algorithm to enumerate all maximum/perfect matchings in a general graph?</li>\n<li>Is there a good algorithm for finding all maximum/perfect matchings in a general graph?</li>\n<li>Are these two problems equivalent in their complexity?</li>\n</ul>\n\n<p>I\'ve stumbled upon the following references:</p>\n\n<ul>\n<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.8179&amp;rep=rep1&amp;type=pdf" rel="nofollow">Algorithms for Enumerating All Perfect Maximum and Maximal Matchings In Bipartite Graphs</a>- Suggesting an algorithm for enumerating all maximum matchings in a bipartite graph.</li>\n<li><a href="http://www.sciencedirect.com/science/article/pii/0893965994900450" rel="nofollow">Finding All the Perfect Matchings\nin Bipartite Graphs</a>- Suggesting an algorithm for finding all perfect matchings in bipartite graphs</li>\n</ul>\n\n<p>Both algorithms\' complexity depend on the number of perfect matchings in the graph (meaning exponential running time in the worst case).</p>\n\n<p>Moreover, both articles deal with bipartite graphs, I couldn\'t find similar articles dealing with the same problem in general graphs.</p>\n\n<p>I\'d appreciate information and references about the above problems.</p>\n', 'ViewCount': '131', 'Title': 'Counting and finding all perfect/maximum matchings in general graphs', 'LastEditorUserId': '10438', 'LastActivityDate': '2014-01-24T19:06:05.883', 'LastEditDate': '2014-01-24T16:12:01.350', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19926', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<algorithms><complexity-theory><graph-theory><reference-request><matching>', 'CreationDate': '2014-01-23T21:28:38.760', 'Id': '19924'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So the dual problem of max-flow is min-cut. What's the dual problem of stable matching?</p>\n", 'ViewCount': '34', 'Title': "What's the dual problem of stable matching?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T15:47:00.473', 'LastEditDate': '2014-02-05T08:04:12.610', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10191', 'Tags': '<linear-programming><matching><duality>', 'CreationDate': '2014-02-05T02:58:01.200', 'Id': '21308'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G=(L,R,E)$ be a bipartite graph, are there conditions on the degree of the vertices under which the condition of Hall\'s theorem is surely satisfied? (meaning a perfect matching exists in the graph).</p>\n\n<p><a href="http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29" rel="nofollow">Konig\'s theorem</a> proves that every $k$-regular bipratite graph has exactly $k$ edge disjoint perfect matchings, so the answer is obviously yes for any $k$-regular bipartite graph with $k&gt;0$ (it\'s not hard to see why hall\'s condition is satisfied in this case).</p>\n\n<p>Is there a wider rule? </p>\n\n<p>For example: Let $|L|=|R|=n$, What is the minimal degree as a function of $n$ of every vertex in the graph such that the graph must admit a perfect matching?</p>\n\n<p>I\'m also wondering if these conditions will hold in general graphs (satisfying Tutte\'s theorem), and if not, then are there similar conditions for general graphs.</p>\n', 'ViewCount': '92', 'Title': "Degree conditions sufficient for Hall's theorem", 'LastEditorUserId': '10438', 'LastActivityDate': '2014-02-21T12:42:04.250', 'LastEditDate': '2014-02-21T12:42:04.250', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<graph-theory><graphs><matching>', 'CreationDate': '2014-02-19T07:49:04.013', 'Id': '21803'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The Stable Roommates Problem matches 2n participants into n sets of roommates based off of each participant's list of preferences. I was wondering if there was a variant of this problem where the number of roommates is different. For example, matching 10n participants into n sets. Thanks for the help.</p>\n\n<p>Edit: The Hospital Resident problem is also similar to this. Each hospital can take a certain number of residents. The problem is the residents list their preferences by hospital instead of other residents.</p>\n", 'ViewCount': '31', 'Title': 'variant of the stable roommates problem', 'LastEditorUserId': '15410', 'LastActivityDate': '2014-03-08T06:10:34.393', 'LastEditDate': '2014-03-08T06:10:34.393', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15410', 'Tags': '<algorithms><matching>', 'CreationDate': '2014-03-08T05:35:54.230', 'Id': '22391'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is a shop which consists of N items and there are M buyers. Each buyer wants to buy a specific set of items. However, the cost of all transactions is same irrespective of the number of items sold. So, the shopkeeper needs to maximize the number of buyers. The buyers will buy only if all the items are being sold. Items are unique. All items need not be sold.</p>\n\n<p>So, basically, we have a bipartite graph. We need to find a set of edges which maximize the number of nodes on Buyer vertex set such that each node on item set has only one edge. Any suggestions?</p>\n', 'ViewCount': '28', 'Title': 'How to maximize the number of buyers in a shop?', 'LastActivityDate': '2014-03-08T15:42:28.667', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15420', 'Tags': '<graph-theory><greedy-algorithms><bipartite-matching>', 'CreationDate': '2014-03-08T15:42:28.667', 'Id': '22399'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a variant of bidding problem at hand.\nThere are N bidders(~20) who bid for items from a pool of many items(~10K). Each bidder can bid many items. I want to maximize the number of bidders who are satisfied. A bidder is satisfied if he gets all the items that he bid for in the first place. For eg-</p>\n\n<pre><code>Bidders = A,B,C\nItems = 1,2,3,4\n\nBidder    Bids\nA         1,2\nB         2,3\nC         3,4\n</code></pre>\n\n<p><img src="http://i.stack.imgur.com/Xcxlu.png" alt="enter image description here">\nIn this case its only possible to satisfy 2 bidders at max.</p>\n\n<p>I\'ve tried to model the problem to a maxflow problem and have taken several approaches but to no avail\nMy approaches so far-</p>\n\n<ol>\n<li><p>Tried to model this problem as a bipartite matching problem. The only problem being that instead of a one-one mapping I have a one-many mapping with an AND condition. </p></li>\n<li><p>A maxflow problem with edges going from source to each vertex with a capacity of number of bids. Problem here being ensuring that all edges from a bidder are selcted.</p></li>\n<li><p>A maxflow problem with both upper bounded and lower bounded edge capacities.</p></li>\n</ol>\n', 'ViewCount': '155', 'Title': 'Maximum number of matched vertexes in a one-to-many bipartite graph', 'LastActivityDate': '2014-03-12T17:58:04.897', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '22548', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15606', 'Tags': '<algorithms><graph-theory><network-flow><bipartite-matching><max-cut>', 'CreationDate': '2014-03-12T16:10:00.057', 'Id': '22542'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Suppose that I have a set of $N$ points in $k$-dimensional space ($k&gt;1$), such as in <a href="http://cs.stackexchange.com/q/22693/15794">this question</a>, and that I need to find all pairs with a distance\xb9 smaller than a certain threshold $t$.  The brute-force method would require $N(N-1)$ distance calculations, which is not acceptable.  I attack the problem by first sorting the cells in a grid\xb9, such as in <a href="http://cs.stackexchange.com/a/22707/15794">this answer</a>, followed by brute-force within each grid cell and a number of neighbours (which is easily calculated from the cell size $w*h$ and the maximum distance $t$).</p>\n\n<p>My solution seems to work acceptably well for my purposes, and the results appear to be correct.  However I\'m neither a computer scientist nor a mathematician, and I\'m not sure what tools I could use to calculate the optimal cell size.  In fact, I developed the aforementioned possibly naive algorithm because it seemed like a reasonably okay method.  I <em>guess</em> the optimal cell size depends in some way on $N$, $t$, on the cost of the distance function, and on the implementation of the sorting in cells, on the distribution of points, and on other things.  How would I make a guess of the optimal values of $w$ and $h$, with or without a priori knowledge on the approximate number of pairs I expect to find?</p>\n\n<p>Does the answer change if the N points are divided in two sets $S_1$ and $S_2$, and each pair shall consist of one element from each set?</p>\n\n<hr>\n\n<p>\xb9<sup>Not necessarily euclidian.  The points may, for example, be locations on a sphere, i.e. on Earth, with latitude and longitude.</sup></p>\n', 'ViewCount': '172', 'Title': 'How do I choose an optimal cell size when searching for close pairs of points, and using cells to implement this?', 'LastEditorUserId': '15794', 'LastActivityDate': '2014-03-17T23:35:41.607', 'LastEditDate': '2014-03-17T21:42:18.320', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15794', 'Tags': '<algorithms><computational-geometry><matching>', 'CreationDate': '2014-03-17T21:25:27.787', 'FavoriteCount': '1', 'Id': '22722'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am working out with the rooks problem. If there are m rooks on an nxn chessboard,i have to give describe a polynomial (in m and n) time algorithm that \ufb01nds a maximum-sized subset of the rooks such that if we leave this subset on the chessboard and remove all other rooks, then no two rooks attack one another. (Two rooks are said to attack one another if and only if they are either in the same row or in the same column with no other intervening rooks between them.)</p>\n\n<p>My idea for solving this problem is to consider a bipartite graph (X,Y) where X is the rows in the chessboard and Y is the columns. if a row and column have a rook placed at their intersection, then there is an edge between the those vertices from x to y. This can be converted into a maximum flow network and the value of max flow is the max matching. </p>\n\n<p>In order to find a polynomial time algorithm i can run maybe BFS.</p>\n\n<p>I wanted to know that if i build my solution on this idea shall it be correct. Is there a better algorithm (polynomial in m and n)?</p>\n\n<p>Any help is appreciated.</p>\n', 'ViewCount': '34', 'Title': 'maximum bipartite matching', 'LastActivityDate': '2014-03-20T02:28:19.897', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6688', 'Tags': '<network-flow><bipartite-matching>', 'CreationDate': '2014-03-20T01:48:01.570', 'Id': '22840'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I face this problem a lot while searching phone numbers and bank account numbers, when I do remember it partially. </p>\n\n<p>I save a draft in gmail with the content <code>I am mango</code>. Then I search it, by entering just <code>mango</code> and it gets me to the draft. </p>\n\n<p>But when I save a draft with some number such as <code>123987645</code> and try to search by entering <code>12398764</code> i.e just one character missing I fail to find it. Also I failed when I just typed  <code>87645</code>. </p>\n\n<p>Out of curiosity I am asking are the algorithms for finding numbers and text fundamentally different? Or I am missing something?</p>\n', 'ViewCount': '67', 'Title': 'Are algorithms for searching text vs searching numbers fundamentally different?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-23T12:58:54.220', 'LastEditDate': '2014-03-24T12:30:44.410', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<algorithms><search-algorithms><strings><matching>', 'CreationDate': '2014-03-24T12:01:50.507', 'Id': '22997'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there a good general paper about the interpretation or compilation\nof REGEXP in programming languages for pattern matching, with or\nwithout variables? I am not looking for a quick explanation about the\nconstruction of DFAs, but for a real paper on how it is actually done\nin programming languages implementation, and what is considered simple\nor difficult. I expect differences between languages may have an\ninpact. A formal paper on how REGEXP implementation should be done is\nuseful too :-)</p>\n', 'ViewCount': '51', 'Title': 'How are REGEXP implemented in programming languages?', 'LastActivityDate': '2014-03-27T00:44:58.427', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<programming-languages><compilers><regular-expressions><matching><interpreters>', 'CreationDate': '2014-03-26T17:01:44.683', 'Id': '23089'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Students will identify certain students they want to work with. I have therefore decided to split them into two groups where I want to minimize the number of people in Group 1 who want to work with students from Group 2. </p>\n\n<p>I was thinking about creating a source node <em>s</em>, and creating a node for each person ($p_i$) - followed by hooking up the <em>s</em> to each $p_i$. Then I would create, another series of nodes for each person ($q_i$) and hook up each $p_i$ to each $q_i$ if $p_i$ <strong>doesn\'t</strong> want to work with $q_i$. Then, I would hook up each $q_i$ to a terminal node <em>t</em>. Each of the edges would have weight 1.</p>\n\n<p>I was thinking about running Edmonds\u2013Karp on it. Now, the solution would yield the maximum bipartite matching of the group (see e.g. <a href="https://www.youtube.com/watch?v=c9uLwB6aUVQ" rel="nofollow">here</a>). For each active arc from $p_i$  to $q_i$ in the final diagram, I would separate those two students.</p>\n\n<p>However, I have a bad taste in my mouth after running this algorithm; the bad taste stems from modeling the instance with respect to my intention: If I maximize the complement (the desire not to work with someone), do I really minimize the desire of students to work with each other across the two groups?</p>\n\n<p>If my hunch is correct (in that I\'m wrong), please point me in the right direction.</p>\n', 'ViewCount': '53', 'Title': 'How to optimally seperate a student body?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T09:54:48.057', 'LastEditDate': '2014-04-09T09:53:59.487', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23586', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<algorithms><optimization><polynomial-time><bipartite-matching>', 'CreationDate': '2014-04-09T06:15:38.270', 'Id': '23582'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Thanks to Yuval Filmus, I got to read <a href="http://theory.stanford.edu/~trevisan/cs261/lecture14.pdf" rel="nofollow">these lecture notes by Trevisan</a>. At the bottom half of Page 5, </p>\n\n<blockquote>\n  <p>The capacity of cut $S$ is the number of edges that go from $S$ to $\\overline{S}$, that is $\\text{Capacity}(S) = |L_2|+|R_1|+\\text{edges}(L_1, R_2)$.</p>\n</blockquote>\n\n<p>Here, $L_1 = S \\cap L$, $L_2 = L \\setminus S$, $R_1 = S \\cap R$ and $R_2 = R \\setminus S$. Furthermore, $L$ are the left edges and $R$ are the right edges.</p>\n\n<p>I don\'t understand how he arrived at the conclusion that</p>\n\n<blockquote>\n  <p>number of edges that go from $S$ to $\\overline{S} = |L_2|+|R_1|+\\text{edges}(L_1, R_2)$</p>\n</blockquote>\n\n<p>I don\'t understand the meaning of this expression. I drew it out on paper (highlighting all graph elements of the expression) and I still don\'t get it. Could somebody please explain to me how this expression is generated in simple and detailed terms?</p>\n', 'ViewCount': '15', 'Title': "The min cut capacity in a network based on a bipartite graph (Hall's Theorem)", 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-16T11:50:35.420', 'LastEditDate': '2014-04-16T08:33:57.210', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23855', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graph-theory><bipartite-matching>', 'CreationDate': '2014-04-16T05:18:01.800', 'Id': '23843'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29#Proof" rel="nofollow">Wikipedia</a> shows how one can determine the minimum vertex cover in a bipartite graph ($G(X \\cup Y, E)$) in polytime from a maximum flow using alternating paths. However, I read that the (S,T) cut (extracted from the final residual network) can also be used to determine the minimum vertex cover:</p>\n\n<p>$$(X\\cap T)\\cup(Y\\cap S)$$</p>\n\n<p>If this expression is a correct alternative, I don\'t have an intuition for why it\'s true. The best intuition I\'ve been able to come up with is: Select each vertex on the left (X) that has a positive flow leading up to it and select each vertex on the right if there is no flow leading up to it. Why is this set equal to the minimum vertex cover?</p>\n', 'ViewCount': '13', 'Title': 'Determining the minimum vertex cover in a bipartite graph from a maximum flow/matching using the residual network rather than alternating paths', 'LastActivityDate': '2014-04-17T01:33:45.290', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23873', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graphs><network-flow><bipartite-matching>', 'CreationDate': '2014-04-17T00:27:40.150', 'Id': '23871'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a bipartite graph similar to the marriage problem, where there are M males and N females, and a 1:1 matching between males and females is desired (with the remainder of the more populous gender remaining unmatched).</p>\n\n<p>The differences between my problem and existing research I've found:</p>\n\n<ol>\n<li>Want to maximize the number of pairings at the expense of stability. Stability is nice as a secondary objective, but not required.</li>\n<li>Preference lists are not exhaustive. Eg. m_1 only wants n_3 and cannot be matched with any other.</li>\n</ol>\n\n<p>Can anyone point me in some possible directions?</p>\n", 'ViewCount': '33', 'Title': 'Marriage algorithm that maximizes number of pairings', 'LastActivityDate': '2014-04-21T22:40:51.340', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16969', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2014-04-21T22:40:51.340', 'Id': '24008'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '39', 'Title': 'Concrete and simple applications for bipartite graphs', 'LastEditDate': '2014-04-23T19:27:43.003', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16536', 'Body': '<p>I am looking for concrete and simple problems that may be solved using bipartite graphs or bipartite graph properties. Any idea along with explanations are welcome.</p>\n', 'ClosedDate': '2014-04-24T17:37:00.217', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'LastEditorUserId': '16536', 'LastActivityDate': '2014-04-24T17:03:52.407', 'CommentCount': '3', 'AcceptedAnswerId': '24083', 'CreationDate': '2014-04-23T19:20:35.893', 'Id': '24057'}