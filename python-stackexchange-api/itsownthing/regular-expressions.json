{'ViewCount': '658', 'Title': 'How to convert an NFA with overlapping cycles into a regular expression?', 'LastEditDate': '2014-01-25T16:51:44.933', 'AnswerCount': '3', 'Score': '10', 'OwnerDisplayName': 'zell', 'PostTypeId': '1', 'OwnerUserId': '694', 'Body': '<p>If I understand correctly, NFA have the same expressive power as regular expressions. Often, reading off equivalent regular expressions from NFA is easy: you translate cycles to stars, junctions as alternatives and so on. But what to do in this case: </p>\n\n<p><img src="http://i.stack.imgur.com/yCGnv.png" alt="enter image description here"><br>\n<sup>[<a href="https://github.com/akerbos/sesketches/blob/gh-pages/src/cs_689.tikz" rel="nofollow">source</a>]</sup></p>\n\n<p>The overlapping cycles make it hard to see what this automaton accepts (in terms of regular expressions). Is there a trick?</p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:51:44.933', 'CommentCount': '7', 'AcceptedAnswerId': '692', 'CreationDate': '2012-03-23T07:35:51.517', 'Id': '689''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to figure out the simplest way to do this using a regular expression. </p>\n\n<ul>\n<li>Three symbols a, b, c.</li>\n<li>The sequence length is unlimited, i.e. *.</li>\n<li>The symbol a must be somewhere in the sequence at least once, but can appear more than once. </li>\n<li>The sequence may have only a.</li>\n</ul>\n\n<p>More formally, $\\{ w \\in \\{a,b,c\\}^* ~|~ \\#_a(w)\\ge 1 \\}$, where $\\#_a(w)$ is the number\nof $a$s in $w$. </p>\n\n<p>The best I get is</p>\n\n<blockquote>\n  <p>$( ( b \\mid c )^*\\, a\\, ( b \\mid c )^* )^+$</p>\n</blockquote>\n\n<p>Is that the simplest way?</p>\n', 'ViewCount': '89', 'Title': 'Regular Expression for the language that requires one symbol to occur at least once', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-04T17:42:46.137', 'LastEditDate': '2012-04-04T17:41:14.063', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1019', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2012-04-04T01:44:05.020', 'Id': '1017''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Here's a conjecture for regular expressions:</p>\n\n<blockquote>\n  <p>For regular expression $R$, let the length $|R|$ be the number of symbols in it,\n  ignoring parentheses and operators. E.g. $|0 \\cup 1| = |(0 \\cup 1)^*| = 2$</p>\n  \n  <p><strong>Conjecture:</strong> If $|R| &gt; 1$ and $L(R)$ contains every string of length $|R|$ or less, then $L(R) = \\Sigma^*$.</p>\n</blockquote>\n\n<p>That is, if $L(R)$ is 'dense' up to $R$'s length, then $R$ actually generates everything.</p>\n\n<p>Some things that may be relevant:</p>\n\n<ol>\n<li>Only a small part of $R$ is needed to generate all strings. For example in binary, $R = (0 \\cup 1)^* \\cup S$ will work for any $S$.</li>\n<li>There needs to be a Kleene star in $R$ at some point. If there isn't, it will miss some string of size less than $|R|$. </li>\n</ol>\n\n<p>It would be nice to see a proof or counterexample. Is there some case where it's obviously wrong that I missed? Has anyone seen this (or something similar) before?  </p>\n", 'ViewCount': '296', 'Title': '"Dense" regular expressions generate $\\Sigma^*$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-19T21:45:29.463', 'LastEditDate': '2012-04-26T06:49:15.443', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1512', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '1245', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-04-26T04:17:35.663', 'Id': '1511''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My answer : (0+1)* 0 (0+1)* 0 (0+1)*</p>\n\n<p>Why is this incorrect? Can somebody explain to me what the correct answer is and why?</p>\n', 'ViewCount': '1105', 'Title': 'Regular expression for all strings with at least two 0s over alphabet {0,1}', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T14:54:41.603', 'LastEditDate': '2012-05-14T14:54:41.603', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '1444', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-05-10T16:38:29.590', 'Id': '1778''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to convert a user entered regular expression into an NFA so that I can then run the NFA against a string for matching purposes. What is the minimum machine that can be used to parse regular expresssions? </p>\n\n<p>I assume it must be a push down automaton because the presense of brackets means the need to count and a DFA/NFA cannot perform arbitrary counting. Is this assumption correct? For example, the expression a(bc*)d would require a PDA so that the sub-expression in brackets is handled correctly.</p>\n', 'ViewCount': '549', 'Title': 'Does the language of Regular Expressions need a push down automata to parse it?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-22T07:41:16.970', 'LastEditDate': '2012-05-20T12:32:09.750', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1434', 'Tags': '<formal-languages><parsers><regular-expressions><pushdown-automata>', 'CreationDate': '2012-05-20T03:26:18.503', 'FavoriteCount': '3', 'Id': '1939''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '14352', 'Title': 'How to convert finite automata to regular expressions?', 'LastEditDate': '2014-03-22T11:29:26.503', 'AnswerCount': '4', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '18', 'Body': '<p>Converting regular expressions into (minimal) NFA that accept the same language is easy with standard algorithms, e.g. <a href="http://en.wikipedia.org/wiki/Thompson%27s_construction_algorithm" rel="nofollow">Thompson\'s algorithm</a>. The other direction seems to be more tedious, though, and sometimes the resulting expressions are messy.</p>\n\n<p>What algorithms are there for converting NFA into equivalent regular expressions? Are there advantages regarding time complexity or result size?</p>\n\n<p><sup>This is supposed to be a reference question. Please include a general decription of your method as well as a non-trivial example.</sup></p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:29:26.503', 'CommentCount': '2', 'AcceptedAnswerId': '2389', 'CreationDate': '2012-05-23T08:19:27.003', 'Id': '2016''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need help with the following exercise:</p>\n\n<p>Construct an $\\varepsilon$-NFA for the following regular expression $(a|\\varepsilon)(ba)^*(c^*a|bc)^*$.</p>\n\n<p>i already tried this exercise with nerode but i didnt come to a solution please help me\nthank you guys</p>\n\n<p>Source wiki\nNerode : (Given a language L, and a pair of strings x and y, define a distinguishing extension to be a string z such that exactly one of the two strings xz and yz belongs to L. Define a relation RL on strings by the rule that x RL y if there is no distinguishing extension for x and y. It is easy to show that RL is an equivalence relation on strings, and thus it divides the set of all finite strings into equivalence classes.</p>\n\n<p>The Myhill\u2013Nerode theorem states that L is regular if and only if RL has a finite number of equivalence classes, and moreover that the number of states in the smallest deterministic finite automaton (DFA) recognizing L is equal to the number of equivalence classes in RL. In particular, this implies that there is a unique minimal DFA with minimum number of states.)</p>\n', 'ViewCount': '164', 'Title': 'construct regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T13:19:11.120', 'LastEditDate': '2012-05-23T15:44:05.140', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1424', 'Tags': '<formal-languages><finite-automata><regular-expressions>', 'CreationDate': '2012-05-23T14:54:13.360', 'Id': '2024''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '528', 'Title': 'How to simulate backreferences, lookaheads, and lookbehinds in finite state automata?', 'LastEditDate': '2012-06-30T11:18:42.317', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'Aadit M Shah', 'PostTypeId': '1', 'OwnerUserId': '2023', 'Body': "<p>I created a simple regular expression lexer and parser to take a regular expression and generate its parse tree. Creating a non-deterministic finite state automaton from this parse tree is relatively simple for basic regular expressions. However I can't seem to wrap my head around how to simulate backreferences, lookaheads, and lookbehinds.</p>\n\n<p>From what I read in the purple dragon book I understood that to simulate a lookahead $r/s$ where the regular expression $r$ is matched if and only if the match is followed by a match of the regular expression $s$, you create a non-deterministic finite state automaton in which $/$ is replaced by $\\varepsilon$. Is it possible to create a deterministic finite state automaton that does the same?</p>\n\n<p>What about simulating negative lookaheads and lookbehinds? I would really appreciate it if you would link me to a resource which describes how to do this in detail.</p>\n", 'Tags': '<automata><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:41:59.937', 'CommentCount': '0', 'AcceptedAnswerId': '2560', 'CreationDate': '2012-06-29T05:27:14.677', 'Id': '2557''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I wanted to ask if someone can help me to construct a regular expression over the alphabet $\\{a,b,x\\}$ for the language $L$ which is constituted by all strings containing an odd number of $a$'s, and in which between each pair of consecutive $a$'s there is an even number of $b$'s (and an arbirtary number of $x$'s).</p>\n\n<p>For example, $babbxbbxabbxaabxxbax \\in L$, $bab \\in L$, while $abba \\notin L$ and $abbbaa \\notin L$.</p>\n\n<p>What is the approach?</p>\n", 'ViewCount': '183', 'Title': 'A regular expression for a given formal language', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-10T21:20:38.263', 'LastEditDate': '2012-07-09T09:46:21.820', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2650', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-07-09T06:59:11.900', 'Id': '2649''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '138', 'Title': 'regular expression given the language', 'LastEditDate': '2012-07-16T23:36:19.187', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2125', 'FavoriteCount': '1', 'Body': '<p>The language is:\n$$\nL = \\{ (a^n) (b^m) \\mid n + m = 3k, k \\ge 0 \\}\n$$</p>\n\n<p>My attempt at an answer:\n$$\n(a \\cup b)^{3k}\n$$</p>\n\n<p>This will work if the a OR b can change for each instance in the string that is (3k) long. If not, what can I do to fix this?</p>\n', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:36:19.187', 'CommentCount': '4', 'AcceptedAnswerId': '2670', 'CreationDate': '2012-07-10T15:19:01.010', 'Id': '2669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '880', 'Title': 'Are regular expressions $LR(k)$?', 'LastEditDate': '2012-07-18T00:50:56.043', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'Andrea Tucci', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '1', 'Body': '<p>If I have a Type 3 Grammar, it can be represented on a pushdown automaton (without doing any operation on the stack) so I can represent regular expressions by using context free languages. But can I know if a type 3 grammar is $LR(1)$, $LL(1)$, $SLR(1)$, etc. without constructing any parse tables?</p>\n', 'Tags': '<formal-languages><regular-languages><formal-grammars><parsers><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T00:50:56.043', 'CommentCount': '0', 'AcceptedAnswerId': '2715', 'CreationDate': '2012-07-11T12:26:59.840', 'Id': '2713''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I just came across an exercise which is to find a regular expression for the following automata, such that the regular expression and the automata generate the same language.</p>\n\n<p><img src="http://i.stack.imgur.com/4Zk9t.png" alt="NFA"></p>\n\n<p>One solution presents the following expression:</p>\n\n<p>$\\qquad \\displaystyle r_A = a^+b^+(c\\mid ca^*b^+)^*$</p>\n\n<p>However, can this be true? I think not, because the all words created from the regular expression will have at least one $b$ in it, whereas the automata accepts words without $b$, such as $aaa$.</p>\n\n<p>What is your opinion?</p>\n', 'ViewCount': '214', 'Title': 'Does this regular expression equal this automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-23T07:39:49.723', 'LastEditDate': '2012-07-23T07:39:49.723', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1413', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-07-21T13:37:50.370', 'Id': '2851''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>What I mean by a "symbolic regular expression" (if there already is a different name for this I\'m not aware of it) is a regular expression that may include exponents that are symbolic arithmetic expressions.  </p>\n\n<p>Example 1: $a^k|b^*$ means "either $k$ copies of $a$ or zero or more copies of $b$".<br>\nExample 2: $a^{k+1}|a^k$ means "either $k$ or $k+1$ copies of $a$".</p>\n\n<p>What I\'d like to do is disambiguate such regular expressions.  I know that to disambiguate a normal regular expression, you can convert it to an NFA, then a DFA, then back to a regular expression.</p>\n\n<p>The problem is not completely straightforward.  For example, $a^k|a^j$ is ambiguous if $j=k$ and unambiguous otherwise.  Thus, the appropriate output would be, for example,\n$$a^k \\text{ if } k=j, \\qquad a^k|a^j \\text{ otherwise.}$$</p>\n\n<p>Does anyone know if there has been anything written about this problem?</p>\n', 'ViewCount': '135', 'Title': 'How to disambiguate symbolic regular expressions', 'LastActivityDate': '2012-08-09T22:51:51.757', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2242', 'Tags': '<formal-languages><reference-request><regular-languages><regular-expressions><ambiguity>', 'CreationDate': '2012-08-09T22:51:51.757', 'Id': '3112''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can anyone tell me what is the difference between the following regular expressions: $(0^*1^*)^*$ and $(0+1)^*$ ? To me they look like generating the same string.</p>\n', 'ViewCount': '274', 'Title': 'Difference between regular expressions: $(0^*1^*)^*$ and $(0+1)^*$', 'LastEditorUserId': '157', 'LastActivityDate': '2012-09-28T09:32:52.047', 'LastEditDate': '2012-09-28T09:32:52.047', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4766', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2987', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-09-27T14:16:45.693', 'Id': '4761''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '472', 'Title': 'Is $(a^nb^m)^r$ regular?', 'LastEditDate': '2012-10-02T17:43:02.980', 'AnswerCount': '1', 'Score': '7', 'OwnerDisplayName': 'Exci', 'PostTypeId': '1', 'OwnerUserId': '3034', 'Body': "<p>I took my theory of computation exams a few weeks ago, and this was one of the questions:</p>\n\n<blockquote>\n  <p>Assume language $L=\\{(a^nb^m)^r \\mid n,m,r\\ge 0\\}$ </p>\n  \n  <p>Is L regular? If yes provide a regular expression or an automaton for it.</p>\n</blockquote>\n\n<p>After I briefly asked him the answer after the exam, it appears it really is regular (I believe he said the expression is the simple $(a^*b^*)^*$). However I cannot seem to understand why that is. The way I see it, its concatenating $a^nb^m$ <strong>r</strong> times, like this:</p>\n\n<blockquote>\n  <p>$a^nb^ma^nb^ma^nb^m...a^nb^ma^nb^m$, </p>\n</blockquote>\n\n<p>which isn't regular since there is no way for an automaton to recall <strong>n</strong> and <strong>m</strong> every time. Where am I at fault here?</p>\n\n<p>EDIT: I talked to the professor again, he admitted it was a mistake. The language is indeed not regular.</p>\n", 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T17:43:02.980', 'CommentCount': '4', 'AcceptedAnswerId': '4838', 'CreationDate': '2012-10-01T13:02:27.980', 'Id': '4837''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As the title says, I spent a couple of hours last weekend trying to wrap up my mind about the class of languages matched by Perl-compatible regular expressions, <em>excluding any matching operator that allows to execute arbitrary code inside the pattern</em>.</p>\n\n<p>If you don\'t know what PCREs are, please read <a href="http://perldoc.perl.org/perlre.html" rel="nofollow">this</a> and <a href="http://pcre.org/pcre.txt" rel="nofollow">this</a>. </p>\n\n<p>The problem is, the resources available on internet pretty much stop at context-free languages, and PCREs can match more than those (see below); but I really don\'t know where to find more theorems or papers about this kind of stuff.</p>\n\n<p>In particular: PCREs are obviously a superset of regular languages (as the PCRE syntax has all the regular language operators).</p>\n\n<p>Any CFG can be put in Greibach normal form, which removes left recursion. I think this can be used by means of <code>(?(DEFINE)...)</code> groups to "translate" the grammar into matching subroutines, avoiding to choke on left recursion, by translating:</p>\n\n<ul>\n<li>the non-terminal at the head of each production becomes a subroutine <code>(?&lt;HEAD&gt;...)</code></li>\n<li>the body of each production is put in the subroutine; terminals are left as-is, non-terminals become procedure invocations (i.e. <code>(?&amp;NONTERMINAL)</code>); </li>\n<li>all the productions with the same nonterminal as head are ORed together by means of the <code>|</code> operator (plus additional grouping with <code>(?:...)</code>, if necessary)</li>\n<li>the pattern then becomes a <code>(?(DEFINE)...)</code> group containing all the "translated" productions, and an invocation for the procedure of the starting symbol, to match the entire string, i.e. <code>^(?(DEFINE)...)(?&amp;START)$</code></li>\n</ul>\n\n<p>This should deal with any CFG. Therefore, PCREs should be able to match any CFL.</p>\n\n<p>There\'s more: let\'s take the simple language\n$$L = \\{ ww | w \\in \\Lambda^* \\} $$\ni.e. the language of the strings repeated twice. This language is not a CFL -- the pumping lemma for CFLs fails. (Pay particular attention that \n$$ |vxw| \\leq p$$\nmust hold, thus you can\'t just pump the beginnings or the ends of the two repeated strings.)</p>\n\n<p>However, this language is easily matched by a PCRE: <code>^(.*)\\1$</code>. Therefore, we\'re strictly above CFLs.</p>\n\n<p>How much above? Well, as I said, I have no idea. I couldn\'t find any resources about CSLs or all the other classes in between to make up my mind. Any expert willing to discuss this?</p>\n\n<p><strong>Addendum:</strong> I was asked to specify exactly which subset of the PCRE syntax must be allowed. As I wrote at the beginning of the post, I wanted to exclude any operator that allows to execute arbitrary code inside of the pattern, such as <code>??{}</code>. </p>\n\n<p>For the argument\'s sake, I think we can stick with the syntax defined by the <a href="http://pcre.org/pcre.txt" rel="nofollow">pcresyntax(3)</a> man page, which is a reasonable subset of what Perl 5.10-5.12 offers, minus the callouts (as they\'re not inside the pattern). I\'m not sure that adding or removing backtracking control verbs change the language we can recognize; if so, it would be nice to figure out which classes we get with and without those.</p>\n', 'ViewCount': '289', 'Title': 'Which languages do Perl-compatible regular expressions recognize?', 'LastEditorUserId': '3036', 'LastActivityDate': '2013-06-05T22:16:54.157', 'LastEditDate': '2012-10-03T08:03:48.953', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '3036', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2012-10-02T10:21:55.317', 'FavoriteCount': '1', 'Id': '4839''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a>  </p>\n</blockquote>\n\n\n\n<p>Im curious if anyone knows if its possible to write a program to generate a regular expression given a finite automation.  </p>\n\n<p>To make things less complicated I want to limit the number of states to about 4, assume the FA is in minimal form and that the FA has only one FinalState and only one StartState. </p>\n\n<p>Ive been thinking about it for a while now and I think the first obvious thing to do would be to create a transition table for the FA. </p>\n\n<p>So an FA could look like this:</p>\n\n<pre><code>NumberOfStates 4 \nStartState   1 \nFinalState   4 \nStateNumber  NextStateA   NextStateB\n1            2            4\n2            3            2\n3            4            4\n</code></pre>\n\n<p>And would generate the regular expression: b + (ab*a(a + b))</p>\n\n<p>Ive been racking my brain for hours but am stumped on how to go about this. Any ideas is greatly appreciated. </p>\n', 'ViewCount': '142', 'LastEditorDisplayName': 'user3115', 'ClosedDate': '2012-10-10T06:38:21.657', 'Title': 'Program that generates a regular expression from an FA', 'LastActivityDate': '2012-10-10T06:25:59.247', 'LastEditDate': '2012-10-10T05:17:02.773', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2012-10-10T04:58:04.090', 'Id': '4987''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>This is a GRE practice question. </p>\n\n<p>Which of the following regular expressions generate(s) no string with two consecutive 1\u2019s? (Note that \u03b5 denotes the empty string.)</p>\n\n<p>I. (1 + \u03b5)(01 + 0)* </p>\n\n<p>II. (01+10)*</p>\n\n<p>III. (0+1)*(0+\u03b5)</p>\n\n<p>(A) I only</p>\n\n<p>(B) II only</p>\n\n<p>(C) III only</p>\n\n<p>(D) I and II only</p>\n\n<p>(E) II and III only</p>\n\n<p>My understanding is that neither I nor III generates strings with <code>11</code>. In I, a string containing <code>1</code> is either <code>1</code> or <code>1</code> surrounded by <code>0</code>'s. In III, all <code>1</code>'s are preceded by <code>0</code>'s. But the correct answer is A, so III must generate a string with <code>11</code> somehow. Please explain. Thanks!</p>\n", 'ViewCount': '410', 'Title': u'Which of the following regular expressions generate(s) no string with two consecutive 1\u2019s?', 'LastActivityDate': '2012-10-15T12:39:19.830', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '6092', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4198', 'Tags': '<regular-expressions>', 'CreationDate': '2012-10-15T06:57:47.087', 'Id': '6086''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '89', 'Title': 'Language member explanation', 'LastEditDate': '2012-10-26T13:05:31.857', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'wildplace', 'PostTypeId': '1', 'OwnerUserId': '4379', 'Body': '<p>Given the following formal language $L$:</p>\n\n<p>$$    L=\\{ww \\mid w\\in\\{a,b\\}^*\\}$$</p>\n\n<p>Why is $a$ not a member of this language?</p>\n\n<p>So what is $\\{a,b\\}^*$ exactly? I thought it means $(a+b)^*$?</p>\n', 'Tags': '<formal-languages><terminology><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-26T13:05:31.857', 'CommentCount': '1', 'AcceptedAnswerId': '6316', 'CreationDate': '2012-10-25T15:09:04.310', 'Id': '6312''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a beginners question. I and reading the book "Introduction to Computer Theory" by Daniel Cohen. But I end up with confusion regarding simplification of regular expressions and finite automata. I want to create an FA for the regular expression</p>\n\n<p>$\\qquad \\displaystyle (a+b)^* (ab+ba)^+a^+\\;.$</p>\n\n<p>My first question is that how we can simplify this expression? Can we we write the middle part as $(ab+ba)(ab+ba)^*$? will this simplify the expression?</p>\n\n<p>My second question is whether the automaton given below is equivalent to this regular expression? If not, what is the mistake?</p>\n\n<p><img src="http://i.stack.imgur.com/m4Agi.png" alt="enter image description here"></p>\n\n<p>This is not a homework but i want to learn this basic example. And please bear me as a beginner.</p>\n', 'ViewCount': '996', 'Title': 'Simplification of regular expression and conversion into finite automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T17:25:30.637', 'LastEditDate': '2012-11-02T10:10:37.237', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '6450', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<formal-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-11-02T08:12:01.797', 'Id': '6443''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am getting confused by the regular expression $(a\\mid b)^*$ as it for sure matches $aab$ and $ab$.</p>\n\n<p>Does $(a\\mid b)^*$ also match strings like $aa$, $aaaa$, $bb$ or $bbb$, that is those that use only $a$ or $b$?</p>\n', 'ViewCount': '118', 'Title': 'Does $(a \\mid b)^*$ match $a^n$ and $b^n$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-09T16:55:18.487', 'LastEditDate': '2012-11-09T07:55:22.077', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Sudhir', 'PostTypeId': '1', 'Tags': '<formal-languages><terminology><regular-expressions>', 'CreationDate': '2012-11-09T06:03:29.180', 'Id': '6569''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>1.\nL2 = E{0,1)</p>\n\n<p>All the words in L2 with equal number of 0's and 1's and every prex of w has at most two more of either\n0's or 1's.</p>\n\n<p>2.\nAll words that does not contain \u201cbbb\u201d as substring.</p>\n\n<p>i think this is :( e + b + bb)(a + ab + abb)*</p>\n\n<p>Thanks in advance!</p>\n", 'ViewCount': '45', 'Title': 'I need to present a regular expression for the following languages:', 'LastActivityDate': '2012-11-27T21:59:40.960', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'user14988', 'PostTypeId': '1', 'Tags': '<regular-expressions>', 'CreationDate': '2012-11-27T14:38:23.403', 'Id': '6969''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need help with the following question:</p>\n\n<p>Order the following formalisms according to their expressive power:\nplacing A before B means that any language definable by A is definable\nby B. Also state which, if any, of them are equivalent.</p>\n\n<pre><code>\u2022 Turing Machines (TM)\n\u2022 Regular expressions (reg.exp.)\n\u2022 Turing Machines with multiple tapes (TM+)\n\u2022 Pushdown Automata (PDA)\n\u2022 Nondeterministic Finite Automata with \u01eb-transitions (NFA\u01eb)\n\u2022 Nondeterministic Finite Automata (NFA)\n\u2022 LR(1) grammars\n\u2022 Nondeterministic Turing Machines (NTM)\n\u2022 Deterministic Pushdown Automata (DPDA)\n\u2022 Deterministic Finite Automata (DFA)\n\u2022 Context-free Grammars (CFG)\n</code></pre>\n\n<p>Is this the correct answer ? I have a exam next week and need to know If my answer is correct.</p>\n\n<pre><code>NFAe=NFA=DFA=Reg.exp, LR(1)-Grammar=DPDA, CFG=PDA, TM=NTM=TM+\n</code></pre>\n\n<p>Thanks in advance </p>\n', 'ViewCount': '173', 'Title': 'Formal Languages - Expressive power of Formalisms', 'LastActivityDate': '2013-01-01T22:35:50.987', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7683', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><regular-languages><context-free><regular-expressions><pushdown-automata>', 'CreationDate': '2013-01-01T22:22:24.913', 'Id': '7682''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>$L_1=\\{a^ku \\mid u \\in \\{a,b\\}^* $ and $u$ contains at least $k$ a\'s, for $k\\geq 1\\}$.</p>\n\n<p>If it is regular, I haven\'t found its regular expression or any closure property to prove it.</p>\n\n<p>If not, it seems pumping theorem holds for it...</p>\n\n<p>Also, what about the language where the above "at least" is changed to "at most"?</p>\n', 'ViewCount': '249', 'Title': 'Is this language regular or not?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T16:29:46.853', 'LastEditDate': '2013-01-17T16:57:42.763', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<formal-languages><regular-languages><regular-expressions><pumping-lemma>', 'CreationDate': '2013-01-17T15:40:17.740', 'FavoriteCount': '1', 'Id': '8991''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Anyone knows if there is an algorithm for directly write the context-free grammar that generates a given regular expression?</p>\n', 'ViewCount': '1870', 'Title': 'Regular Expression to Context-Free Grammar', 'LastActivityDate': '2013-01-22T11:07:21.357', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '9057', 'Score': '1', 'OwnerDisplayName': 'Marco L.', 'PostTypeId': '1', 'OwnerUserId': '4311', 'Tags': '<formal-grammars><regular-expressions><context-free>', 'CreationDate': '2013-01-19T15:07:19.573', 'FavoriteCount': '1', 'Id': '9050''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The basic idea is to have one or more symbol that clearly indicate the end. For example:</p>\n\n<p>Non-ambiguous:</p>\n\n<blockquote>\n  <p>$ab^*c$<br>\n  $(a|b)c$<br>\n   $ab^+c$<br>\n   $ab?c$<br>\n   $a(b|c)$<br>\n   $c(ab)^*ccc$<br>\n   $acc^*d$<br>\n   $abc|bcd$  </p>\n</blockquote>\n\n<p>Ambiguous:</p>\n\n<blockquote>\n  <p>$abc^*$<br>\n  $abc^+$<br>\n  $abc?$<br>\n  $acc^*$ or $ac^*c$</p>\n</blockquote>\n\n<p>An alternative definition of a non-ambiguous ending would be that the corresponding DFA can have multiple final states, but none of them can have a outgoing transition.</p>\n', 'ViewCount': '194', 'Title': 'Is there a name/interest for regular languages that have a non-ambiguous ending?', 'LastEditorUserId': '1053', 'LastActivityDate': '2013-01-25T16:19:20.677', 'LastEditDate': '2013-01-25T15:20:19.237', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9094', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1053', 'Tags': '<regular-languages><finite-automata><regular-expressions><ambiguity>', 'CreationDate': '2013-01-22T12:50:22.110', 'Id': '9091''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have an alphabet $A = \\{b,B\\}$ and I'm asked to write down the <strong>pattern</strong> of the regular expression $(\\epsilon|bb|b)(B|bb)(b|\\epsilon|b)$. What does the question actually want me to do? I'm not sure. Does it want me to give the possible patterns that can be formed with $b$ and $B$? But then surely the question would not have been phrased the way it is. </p>\n\n<p>I'm just confused about what I need to do here and what is expected of the answer. If anyone could give an example it would be very helpful.</p>\n\n<p>Note: This is not the original question, I changed and simplified it.</p>\n", 'ViewCount': '97', 'Title': 'What is meant by "give pattern of a regular expression"', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T13:03:04.673', 'LastEditDate': '2013-01-24T12:52:30.853', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '9149', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6542', 'Tags': '<formal-languages><terminology><regular-languages><regular-expressions>', 'CreationDate': '2013-01-24T12:03:56.200', 'Id': '9132''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '103', 'Title': 'Regular expression for binary words with few zeros', 'LastEditDate': '2013-02-03T10:21:39.150', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'Jay Satish Teli', 'PostTypeId': '1', 'OwnerUserId': '6687', 'Body': '<p>What is the regular expression for the set of binary strings with the property that</p>\n\n<ol>\n<li>every $0$ is followed by <em>exactly</em> $m$ times $1$ and </li>\n<li>every $0$ is preceded by <em>at least</em> $n$ times $1$? </li>\n</ol>\n\n<p>$m$ and $n$ are integers.</p>\n', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-04T13:35:30.713', 'CommentCount': '2', 'AcceptedAnswerId': '9448', 'CreationDate': '2013-02-03T02:25:16.703', 'Id': '9442''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Recall that a language is $\\omega$-regular if and only if it is recognized by a B\xfcchi automaton. How can I prove that</p>\n\n<p>$\\qquad (E_1 + E_2).F^\\omega$</p>\n\n<p>is equivalent to</p>\n\n<p>$\\qquad {E_1.(F^\\omega)+E_2.(F^\\omega)}$</p>\n\n<p>where  </p>\n\n<ul>\n<li>both expressions are <em>omega</em> regular expressions, and  </li>\n<li>$E_1$, $E_2$ and $F$ are <em>arbitrary regular expressions</em> with \n $\\epsilon \\notin L(F)$.  </li>\n</ul>\n\n<p>One way I could think of is to convert expression to a DFA and check\nif it is equivalent.</p>\n\n<p>Or I will really appreciate a hint on how to do the equivalence\nproof, but how to represent $E_1$, $E_2$ and $F$ in DFA.</p>\n', 'ViewCount': '174', 'Title': 'Distributivity of $\\omega$-regular expressions', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-26T13:23:38.430', 'LastEditDate': '2014-01-26T13:23:38.430', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6688', 'Tags': '<regular-expressions><buchi-automata>', 'CreationDate': '2013-02-03T10:32:22.540', 'Id': '9446''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '310', 'Title': 'Regular expression for $\\{a^k b^m c^n \\mid k+m+n \\text{ is odd} \\}$', 'LastEditDate': '2013-04-12T22:59:44.677', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6667', 'FavoriteCount': '0', 'Body': '<p>I have to make a regular expression from the following laguage:</p>\n\n<blockquote>\n  <p>{$a^kb^mc^n : $ where <em>k</em> + <em>m</em> + <em>n</em> is odd}</p>\n</blockquote>\n\n<p>Is is possible for the sum of three numbers to be odd (other than three consecutive odd numbers)?</p>\n\n<p>I have this so far:</p>\n\n<blockquote>\n  <p>{(abbbccccc) + (abbbbbccc) + (aaabccccc) + (aaabbbbbc) + (aaaaabccc) + (aaaaabbbc)}</p>\n</blockquote>\n\n<p>but I am realizing that there are way more possibilities to this pattern... How can I formulate a string that encompasses all of this?</p>\n', 'Tags': '<formal-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T22:59:44.677', 'CommentCount': '3', 'AcceptedAnswerId': '9480', 'CreationDate': '2013-02-04T16:31:12.427', 'Id': '9478''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is the homework question:</p>\n\n<blockquote>\n  <p>$ \\{w \\in \\{a, b, c\\}^* : \\text{(no symbol occurs twice in succession in w)}\\} $</p>\n</blockquote>\n\n<p>This is my answer:</p>\n\n<blockquote>\n  <p>$$\\{((abc)^*| (acb)^*| (ab)^* | (ac)^*)^* | (bac)^* | (bca)^* | (ba)^* | (bc)^*)^* | ((cab)^* | (cba)^* | (ca)^* | (cb)^*)^* | ((\\epsilon +a) | (\\epsilon + b) | (\\epsilon+c)) \\}\n $$</p>\n</blockquote>\n\n<p>Is there a way to simplify this expression?</p>\n', 'ViewCount': '170', 'Title': 'Simplifying regular expressions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-05T10:17:32.417', 'LastEditDate': '2013-02-05T10:17:32.417', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2013-02-04T22:00:56.437', 'Id': '9492''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Suppose that we expand our idea of context free grammar rules to allow regular expressions of terminals on the right hand side. For example, consider $G_1$:  </p>\n\n<p>$\\begin{align*}\nS &amp; \\rightarrow (a \\mid b) S (c \\mid d) \\\\\nS &amp; \\rightarrow (a \\mid b) A (c \\mid d) \\\\\nA &amp; \\rightarrow (f \\mid g)^*\n\\end{align*}\n$</p>\n\n<p>Then the language of $G_1$ is the following:<br>\n$$L(G_1) = \\{(a \\mid b)^n (f \\mid g)^* (c \\mid d)^n \\mid n &gt; 0\\}$$</p>\n\n<p>Give a standard CFG that has the same language as $G_1$, is your grammar weakly equivalent to $G_1'$, strongly equivalent to $G_1'$, or both? Why?</p>\n\n<p>Secondly, how can I transform any CFG with regular expressions of terminals on the right hand side to a normal context free grammar?</p>\n", 'ViewCount': '211', 'Title': 'CFG with regular expression terminals on RHS', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-08T17:46:50.903', 'LastEditDate': '2013-02-08T17:27:58.183', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Stefan Widmer', 'PostTypeId': '1', 'Tags': '<regular-expressions><automata>', 'CreationDate': '2013-02-06T16:29:43.277', 'Id': '9602''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As far as a I understand, a regular language is a set of words that can be run in a DFA.</p>\n\n<p>$L_1 = \\{ x\\#y \\mid x,y \\in \\{0,1\\}^* \\ \\text{and} \\ |x| = |y| \\}$</p>\n\n<p>$L_2 = \\{ xy  \\mid x,y \\in \\{0,1\\}^* \\ \\text{and} \\ |x| = |y| \\}$</p>\n\n<p>$L_1$ is not regular but $L_2$ is, why is that?\nIs it possible to create a DFA that accepts $L_2$ (it needs to remember the length of $x$) if so, why is it impossible to do it with $L_1$?</p>\n', 'ViewCount': '75', 'ClosedDate': '2013-02-11T06:03:32.250', 'Title': 'Regular languages - models of computation', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-10T21:14:17.917', 'LastEditDate': '2013-02-10T21:14:17.917', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '0', 'OwnerDisplayName': 'user13700', 'PostTypeId': '1', 'Tags': '<regular-expressions>', 'CreationDate': '2013-02-10T19:04:22.560', 'Id': '9645''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m doing an exercise in my <a href="http://rads.stackoverflow.com/amzn/click/0073191469" rel="nofollow">book</a>, the question is to find a string of minimum length in $\\{a, b\\}^*$ not in the language corresponding to the given regular expression.</p>\n\n<p>a. $b^*(ab)^*a^*$</p>\n\n<p>My answer: $aab$</p>\n\n<p>b. $(a^* + b^*)(a^* + b^*)(a^* + b^*)$</p>\n\n<p>My answer: $abab$</p>\n\n<p>c. $a^*(baa^*)^*b^*$</p>\n\n<p>My answer: $bba$</p>\n\n<p>d. $b^*(a + ba)^*b^*$</p>\n\n<p>My answer: $abba$</p>\n\n<p>I came up with my answers by trial and error. I don\'t know for sure if these are the shortest possible strings. Is the best method trial and error, or would there be some better algorithmic way?</p>\n', 'ViewCount': '246', 'Title': 'String of minimum length in $\\{a, b\\}^*$ not in a regular expression', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-06T18:54:15.723', 'LastEditDate': '2013-04-06T18:54:15.723', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10065', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><regular-languages><regular-expressions><check-my-answer>', 'CreationDate': '2013-02-24T20:23:54.390', 'Id': '10064''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m doing an exercise from my book that says:</p>\n\n<blockquote>\n  <p>Let $r$ and $s$ be arbitrary regular expressions over the alphabet $\\Sigma$. Find a simpler equivalent regular expression:</p>\n  \n  <p>a. $r(r^*r + r^*) + r^*$</p>\n  \n  <p>b. $(r + \\Lambda)^*$</p>\n  \n  <p>c. $(r + s)^*rs(r + s)^* + s^*r^*$</p>\n</blockquote>\n\n<p>The book doesn\'t cover how to simplify regular expressions, so I searched online and I presumed you would use the <a href="http://www.nvc.cs.vt.edu/~jzhang/cs5104/Note-41.pdf" rel="nofollow">algebraic laws for regular expressions</a>. I was able to use these laws to come up with something for part a. only:</p>\n\n<p>a. $r(r^*r + r^*) + r^*$</p>\n\n<p>$r(r^+ + r^*)+r^*$</p>\n\n<p>$r(r^+ + r^+ + \\Lambda) + r^*$</p>\n\n<p>$r(r^++\\Lambda)+r^*$</p>\n\n<p>$rr^+ + r\\Lambda + r^*$</p>\n\n<p>$rr^+ + r + r^*$</p>\n\n<p>I don\'t know how to approach b. or c., because b. has $(r + \\Lambda)^*$ and c. has $(r+s)^*$, and I couldn\'t find how to deal with these. Any hints?</p>\n', 'ViewCount': '153', 'Title': 'Finding simpler equivalent regular expressions', 'LastActivityDate': '2013-02-25T04:24:50.563', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10078', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<regular-expressions>', 'CreationDate': '2013-02-25T03:18:06.040', 'Id': '10077''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1427', 'Title': 'DFA to regular expression conversion', 'LastEditDate': '2013-03-02T00:16:02.467', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was looking at the question <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a> to convert DFA to regex.</p>\n\n<p>The question, I was trying to solve is:</p>\n\n<p><img src="http://i.stack.imgur.com/e7YPr.jpg" alt="enter image description here"></p>\n\n<p>I have got the following equations:</p>\n\n<p>$Q_0=aQ_0 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>$Q_1=aQ_1 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>When solved, we will get $Q_0=a^*b(a \\cup b)^* \\cup\\ \\epsilon$</p>\n\n<p>But my doubt is that, in the DFA starting state is also the final state so, even if we dont give any $b$, it will be accepted, if we give some $a$. But in the regex we have $b$, instead of $b^*$. Why is it so? Is it because,we have that regex $\\cup$ $\\epsilon$ ?</p>\n', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'LastEditorUserId': '947', 'LastActivityDate': '2013-03-02T01:00:05.917', 'CommentCount': '2', 'AcceptedAnswerId': '10184', 'CreationDate': '2013-03-01T17:26:49.227', 'Id': '10180''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have two datasets that I am trying to match to one another. One dataset's contents is a subset of the other, but contains typographical errors of varying types and magnitude.</p>\n\n<p>I am applying the following logic to the data linkage process:</p>\n\n<p>Apply regular expressions in an iterative manner with increasing flexibility until a match is found (for example, in one iteration, leave vowels as optional). If two matches are found for one record within one iteration, categorize match as tie and leave unmatched. Apply Python's fuzzy regex to handle scenarios which a rule-based regex can't handle, namely character insertions, deletions, and substitutions within an edit distance of one.</p>\n\n<p>I'm having to discuss this process in detail for specs. However, I'm having trouble deciding how to categorize the process. Would this be considered a deterministic process?</p>\n\n<p>Your help would be appreciated. I do not have a CS background, so I apologize if my question is fairly rudimentary.</p>\n", 'ViewCount': '119', 'Title': 'Distinguishing probabilistic, deterministic, and fuzzy matching methods', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-06T06:58:03.727', 'LastEditDate': '2013-03-06T06:58:03.727', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7160', 'Tags': '<regular-expressions><strings><string-metrics>', 'CreationDate': '2013-03-05T19:59:45.920', 'Id': '10301''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>E.g.</p>\n\n<p><strong>Matching Problem</strong> The DFA of regex <code>good</code> is like a chain.</p>\n\n<pre><code>match:     "good"\nnot match: "people do not give good comments are not good people"\n</code></pre>\n\n<p><strong>Searching Problem</strong> The DFA used in searching regex <code>good</code> could be:</p>\n\n<p><img src="http://i.stack.imgur.com/BcnoQ.jpg" alt="enter image description here"></p>\n\n<pre><code>1 matching:  "good"\n2 matchings: "people do not give good comments are not good people"\n</code></pre>\n\n<p>Here are the questions:</p>\n\n<ol>\n<li>In the above two problems, it seems the searching problem\'s DFA is the matching problem\'s DFA plus some backedges and an additional state (here state <code>0</code>). Is this the difference in general?</li>\n<li>What is the regex of searching problem in this case?</li>\n</ol>\n', 'ViewCount': '139', 'Title': 'Difference between pattern matching and pattern searching in terms of DFA/Regex', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T18:51:02.610', 'LastEditDate': '2013-03-20T11:08:46.557', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'JackWM', 'PostTypeId': '1', 'Tags': '<finite-automata><regular-expressions><search-algorithms>', 'CreationDate': '2013-03-19T00:16:58.863', 'Id': '10632''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '106', 'Title': 'How to find specificity of a regex match?', 'LastEditDate': '2013-03-26T11:20:44.637', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7419', 'FavoriteCount': '1', 'Body': "<p>I'm thinking about a routing system. Imagine I have the two following regexes</p>\n\n<ul>\n<li>pathpart1/pathpart2 => specific match that routes to controller1</li>\n<li>.* => catch-all that routes to controller2</li>\n</ul>\n\n<p>And I let them match on a URL, e.g. 'pathpart1/pathpart2'.</p>\n\n<p>They both match, but I would want to give prevalence to the most specific regex, i.e. the regex where <strong>the cardinality of all possible matches of that regex</strong> is the lowest.</p>\n\n<blockquote>\n  <p>Is there a good way to calculate that the first regex has a low cardinality on its match-set (so I want to to go with that match) and the second has a very high cardinality on its match-set (i.e. it is completely not specific, so a match is basically a catch all last resort)...?</p>\n</blockquote>\n\n<p>I do not know upfront which routes are registered with the router, so I can't loop over them in order of cardinality by hand (i.e. low cardinality first, and the catch-all last if all others don't match).</p>\n", 'Tags': '<algorithms><regular-expressions><strings>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-27T10:20:57.763', 'CommentCount': '0', 'AcceptedAnswerId': '10807', 'CreationDate': '2013-03-25T21:22:07.827', 'Id': '10786''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have two regular languages <em>A</em> and <em>B</em>, and I want to determine whether there is any pair of strings, <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em>, such that (<em>a</em>&nbsp;<em>b</em>) is a prefix of a string in (<em>A</em>&nbsp;<em>B</em>) and the left-most match of <em>B</em> in (<em>a</em>&nbsp;<em>b</em>) includes one or more characters from <em>a</em>.</p>\n\n<p>Raphael\'s formulation is good:</p>\n\n<blockquote>\n  <p>Given two regular language A, B, is there a (non-empty) prefix of a word b in B that is a suffix of a word in A so that the rest of b is a prefix of another word in B?</p>\n</blockquote>\n\n<h1>Example</h1>\n\n<p>For example, let\'s say I have two regular languages, one which describes some properly escaped HTML text, and one which describes an end tag:</p>\n\n<pre><code>A := ([^&amp;&lt;&gt;] | [&amp;] [a-z] [a-z0-9]+ [;])*;\nB := "&lt;/title";\n</code></pre>\n\n<p>By inspection, I can tell that there is no string (<em>a</em>&nbsp;<em>b</em>) in (<em>A</em>&nbsp;<em>B</em>) such that the first match of <em>B</em> includes characters from <em>a</em> because <code>"&lt;"</code> is a prefix of <em>B</em> which cannot occur as a suffix of <em>A</em>.</p>\n\n<p>But given a different grammar:</p>\n\n<pre><code>A\' := (A | "&lt;![CDATA[" ("]"? "&gt;" | "]"* [^\\]&gt;])* "]]&gt;")*;\nB\' := "&lt;/title" ([^&gt;\\"] | [\\"] [^\\"]* [\\"])* "&gt;";\n</code></pre>\n\n<p>then there are strings</p>\n\n<pre><code>a = \'&lt;![CDATA[&lt;/title "]]&gt;"\';\nb = \'&lt;/title&gt;\';\n</code></pre>\n\n<p>where (<em>A</em>&nbsp;<em>B</em>) matches <code>\'&lt;![CDATA[&lt;/title "]]&gt;"&lt;/title&gt;\'</code> and the left-most match of <em>B</em> is <code>\'&lt;/title "]]&gt;"&lt;/title&gt;\'</code> which includes a non-empty suffix of <em>a</em> : <code>\'&lt;/title "]]&gt;"\'</code>.</p>\n\n<h1>Motivation</h1>\n\n<p><em>A</em> in my situation describes the output of an encoder/sanitizer that is derived from a grammar, so an untrusted input is fed to the encoder/sanitizer and I know the output matches <em>A</em> by construction.</p>\n\n<p><em>B</em> is a limit condition in a larger grammar that describes how parsers determine where a chunk of an embedded language ends so they can hand it off to a parser for the embedded language.</p>\n\n<p>My end goal is to be able to determine when I can optimize away runtime checks that ensure that it is safe to embed a particular encoded string.  For these examples, it would be safe to optimize out the first check, but not the second.</p>\n\n<hr>\n\n<p>Is this a solved problem?  Does it have a name?  Any pointers appreciated.</p>\n', 'ViewCount': '76', 'Title': 'For regular languages A and B, determine whether B might match early in (A B)', 'LastEditorUserId': '1298', 'LastActivityDate': '2013-03-28T18:43:58.467', 'LastEditDate': '2013-03-28T18:43:58.467', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><regular-languages><regular-expressions><parsers>', 'CreationDate': '2013-03-27T21:11:15.627', 'Id': '10852''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm reading my textbook and it claims that the regular expression $c^*(b \\cup (ac)^*)^*$ defines the language $L$ over $\\{a,b,c\\}$ which consists of <strong>all</strong> strings that do not contain the substring $bc$. </p>\n\n<p>However, I'm failing to see how that language would contain strings such as $bbbaaa$ or $aaabbb$. Am I missing something or is that regular expression incorrect? The expression I come up with was $ \\left( \\left( \\left( a \\cup b \\right) ^*a \\right) ^* \\left( c \\cup a \\right) ^* \\right) ^*b^* $</p>\n", 'ViewCount': '109', 'Title': "Does $c^*(b \\cup (ac)^*)^*$ define all strings over $\\{a,b,c\\}$ that don't contain the substring $bc$", 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T11:22:02.750', 'LastEditDate': '2013-03-28T10:36:10.927', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '10867', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7461', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-03-28T03:33:26.653', 'Id': '10857''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Earlier I asked the question: <a href="http://cs.stackexchange.com/questions/10848/can-a-turing-machine-decide-if-an-nfa-accepts-a-string-of-prime-length">Can a Turing Machine decide if an NFA accepts a string of prime length?</a>. The answer introduced me to Parikh\'s theorem, which I\'ve been reading about. The concept of Parikh\'s theorem, if we apply it to regular expressions, allows us to break down a regular expression into expressions that only have one level of Kleene-star nesting.</p>\n\n<p>So: $aa(b(cc)^*)^*$ can have a list of expressions created using the same methodology as Parikh\'s theorem where none of the new expressions in the final list has nested Kleene-stars. The linear subsets will use starred expressions </p>\n\n<p>To make it more clear, I\'m referencing this paper: <a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow"><a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow">http://people.inf.ethz.ch/torabidm/par-ext.pdf</a></a>.</p>\n\n<p>I\'m not too concerned with it actually being a regular expression, DFAs or NFAs would work fine. It seems easier to work with as an RE.</p>\n\n<hr>\n\n<p>I want to know if the problem is decidable:</p>\n\n<p><strong>Instance</strong>: A regular expression $R$</p>\n\n<p><strong>Question</strong>: Does there exist some length $l \\ge 1$ such that $R$ accepts every string of that length (ie. if its alphabet is $\\Sigma$, it accepts $\\Sigma^l$, for some $l \\ge 1$.</p>\n\n<hr>\n\n<p>I\'m pretty sure the problem actually is decidable but it\'s a tough one. I\'ve enjoyed pondering it so far and would love to see what someone more experienced than myself can come up with.</p>\n', 'ViewCount': '359', 'Title': 'Can a Turing Machine decide if a regular expression matches all strings of exactly some length $l \\geq 1$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-02T07:22:55.830', 'LastEditDate': '2013-03-29T18:35:42.483', 'AnswerCount': '3', 'CommentCount': '8', 'AcceptedAnswerId': '10880', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7450', 'Tags': '<computability><finite-automata><regular-expressions>', 'CreationDate': '2013-03-28T20:10:53.063', 'Id': '10879''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Here is a DFA from a research project. We created the DFA manually.\nWe are interested in which regex is this DFA corresponding to.\nCertainly, there could be multiple regex corresponding to it; we prefer a simpler one.</p>\n\n<p><img src="http://i.stack.imgur.com/cV5V4.png" alt="enter image description here"></p>\n', 'ViewCount': '165', 'ClosedDate': '2013-03-31T11:28:31.067', 'Title': "What's the regex corresponding to this DFA?", 'LastActivityDate': '2013-03-30T07:21:55.063', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'JackWM', 'PostTypeId': '1', 'Tags': '<regular-expressions>', 'CreationDate': '2013-03-29T04:05:52.840', 'FavoriteCount': '1', 'Id': '10883''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have to write a regular expression that accepts any odd binary number not preceded by a 0. the best I can come up with is $1(0\\cup1)^*1$, but that doesn't match just 1. The best it matches is 11.</p>\n", 'ViewCount': '286', 'Title': 'Regular expression for odd binary numbers without leading zeros', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-03T07:42:55.550', 'LastEditDate': '2013-04-03T07:15:35.700', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10989', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-04-02T23:29:28.500', 'Id': '10983''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have an exam coming up and I need help with the following homework:</p>\n\n<blockquote>\n  <p>Given an NFA $A$ and a regular expression $B$, consider the problem of determining if $L(A) = L(B)$. Is this decidable? Prove your answer.</p>\n</blockquote>\n', 'ViewCount': '135', 'Title': 'Given an NFA A and a regular expression B, is the problem of determining L(A) = L(B) decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:55:24.693', 'LastEditDate': '2013-04-08T14:55:24.693', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7639', 'Tags': '<automata><finite-automata><undecidability><regular-expressions>', 'CreationDate': '2013-04-08T10:13:25.680', 'Id': '11138''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The regular expression $a^{3}b^{+}$ is indeed regular because we can define an automata $M$. But I see that $\\mathcal{L} = \\{a^{3}b^{n}, n \\geq 1\\}$ may generate the same strings, but using the pumping lemma with constant $N$ for a substring $\\alpha\\beta = a^{3}b^{t},|\\alpha\\beta| \\leq N$, let $\\alpha = a$ and $\\beta = a^{2}b^{t}$, therefore $\\gamma = b^{N-t}$, and when $k = 0$, $\\sigma = \\alpha \\beta^{0} \\gamma = \\alpha \\gamma = ab^{N-t}$, which doesn't belong to $\\mathcal{L}$ and the language isn't regular.</p>\n\n<p>So, is really the regex equal to $\\mathcal{L}$? or am I pumping wrong?</p>\n", 'ViewCount': '62', 'Title': 'Is the language $a^{3}b^{+}$ the same as $\\{a^{3}b^{n}, n \\geq 1\\}$ ? and what is the result of pumping this?', 'LastActivityDate': '2013-04-28T04:30:58.543', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11621', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7492', 'Tags': '<regular-languages><finite-automata><regular-expressions><pumping-lemma>', 'CreationDate': '2013-04-28T03:39:32.733', 'FavoriteCount': '1', 'Id': '11619''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can we design a regular expressions without particular substrings.\nThe goal of this is to create language <code>L</code> which won't contain a particular substring (i.e. 110)</p>\n\n<p>for the case of a regular expression without substring $110$, I Was thinking of: $\\require{cancel}\\cancel{(101)^*+}(010)^*+(10)^*+(\\cancel{1}1)^*+(\\cancel{0}0)^*+(01)^*$ but is that over excessive?</p>\n\n<p>Then for example, I crossed out (101)* because obviously if you have two of those 101101, a subset of that will be 110, which we don't want.</p>\n\n<h3>Notes:</h3>\n\n<p>Question has been edited since it gained attention in the past few days. Also see comment for justification.</p>\n", 'ViewCount': '3292', 'Title': 'Regular expression for the strings without a particular substring', 'LastEditorUserId': '6980', 'LastActivityDate': '2014-01-31T12:46:01.967', 'LastEditDate': '2014-01-31T12:46:01.967', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '11791', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-05-04T23:46:05.660', 'Id': '11787''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>So I\'ve been trying to crack this for a long time and almost feel like I am going in loops about this question.</p>\n\n<p>Given the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hL3Ps.png" alt="enter image description here"></p>\n\n<p>Using the GNFA algorithm get the regular expression.</p>\n\n<p>I understand that you would have the following for the first step(adding empty states):\n<img src="http://i.stack.imgur.com/6XXjj.png" alt="enter image description here"></p>\n\n<p>The next step would be removing the state [q1] I would get:\n<img src="http://i.stack.imgur.com/cwjUd.png" alt="enter image description here"></p>\n\n<p>Finally removing [q2] would get:\n<img src="http://i.stack.imgur.com/WW3Fj.png" alt="enter image description here"></p>\n\n<p>However the answers others have got is:\n$(a \\cup bb^*a)^*bb^*$\nWhich does not make sense as I got, $a^*b(b \\cup aa^*b)^*$?\nA GNFA(generalised nondeterministic finite automaton) is described as follows:</p>\n\n<p>A GNFA is similar to an NFA but must obey certain rules: </p>\n\n<ul>\n<li>It has only one accept state</li>\n<li>The initial state has no transitions coming into it</li>\n<li>The accept state has no transitions coming out from it</li>\n<li>A transition can denote any regular expression, rather than just a\nsymbol from the alphabet Note that a symbol is a kind of regular\nexpression.</li>\n</ul>\n\n<p>Furthermore, We may convert an NFA into a GNFA as follows: </p>\n\n<ul>\n<li>Add a new start state with an \u03b5-transition to the old start state</li>\n<li>Add a new accept state with \u03b5-transitions from the old accept states</li>\n<li>If arrows have multiple labels, or if there are multiple arrows\nbetween two states, replace them with the union (or) of those labels</li>\n</ul>\n', 'ViewCount': '2097', 'Title': 'Converting an NFA to regex using GNFA algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:23:30.563', 'LastEditDate': '2013-05-12T10:23:30.563', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '11950', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata><regular-expressions><nondeterminism>', 'CreationDate': '2013-05-10T14:50:56.853', 'Id': '11935''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given two arbitrary regular expressions, is there an "efficient" algorithm to determine whether they match the same set of strings?</p>\n\n<p>More generally, can we compute the size of the intersection of the two match sets?</p>\n\n<p>What algorithms are there to do this, and what complexity class do they live in?</p>\n\n<p>If we disallow the Kleene star, does that alter the picture at all?</p>\n', 'ViewCount': '209', 'Title': 'Algorithm to determine whether two regexes are equivalent', 'LastEditorUserId': '472', 'LastActivityDate': '2013-06-17T16:08:55.307', 'LastEditDate': '2013-06-17T16:08:55.307', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1951', 'Tags': '<algorithms><regular-expressions>', 'CreationDate': '2013-05-25T11:29:02.060', 'Id': '12267''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Of course, converting NFA to DFA is not a problem. But what about the other direction?</p>\n\n<p>My motivation is the notion of minimization regular expressions using the DFA minimization algorithm.</p>\n', 'ViewCount': '123', 'Title': 'Can we minimise regular expressions using known DFA minimisation algorithms?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-11T16:57:51.563', 'LastEditDate': '2013-06-11T16:57:51.563', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '1', 'OwnerDisplayName': 'Jendas', 'PostTypeId': '1', 'OwnerUserId': '6541', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-06-11T08:51:24.510', 'Id': '12612''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to come up with a regular expression for the following language:</p>\n\n<blockquote>\n  <p>The set of all strings with at most one triple of adjacent 0s.</p>\n</blockquote>\n\n<p>What does "triple of adjacent 0s" mean? Does it mean 010101, or something else?</p>\n', 'ViewCount': '98', 'Title': 'A regular expression for strings with at most one triple of adjacent zeroes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-15T15:30:52.710', 'LastEditDate': '2013-06-15T15:30:52.710', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<formal-languages><terminology><regular-expressions>', 'CreationDate': '2013-06-13T17:52:01.333', 'Id': '12660''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '141', 'Title': 'Are HTML and CSS regular languages?', 'LastEditDate': '2013-06-24T17:18:01.450', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8839', 'FavoriteCount': '1', 'Body': '<p>I have a question whether or not CSS and HTML are regular languages.</p>\n\n<p>I believe CSS is a regular language, since it should be possible to create a regular expression to match the structure of CSS.</p>\n\n<p>However, I believe that HTML is <strong>not</strong> a regular language since you have nested attributes that could be defined recursively.</p>\n', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-24T17:18:01.450', 'CommentCount': '7', 'AcceptedAnswerId': '12869', 'CreationDate': '2013-06-24T14:45:41.140', 'Id': '12867''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it possible, in general, to determine whether two regular expressions admit the same set of strings?</p>\n\n<p>Also, in particular, is it possible to determine whether a given regular expression admits the same set of strings as the regular expression ".*" (i.e., accepts anything).</p>\n', 'ViewCount': '157', 'ClosedDate': '2013-06-25T08:16:03.863', 'Title': 'Equivalence of regular expressions', 'LastActivityDate': '2013-06-24T21:24:54.247', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12877', 'Score': '4', 'OwnerDisplayName': 'Paul Reiners', 'PostTypeId': '1', 'OwnerUserId': '2003', 'Tags': '<regular-expressions>', 'CreationDate': '2013-06-24T20:15:54.747', 'Id': '12876''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Full disclosure, I'm interested in what this means about transformations on NFAs, but regex expressions seem like a easy way to ask the question.</p>\n\n<p>If you have a regex that uses the plus operator (match one or more) can it, in the general case, be transformed into a regex that uses only the star operator (match zero or more).</p>\n\n<p>Since all regular expressions can be converted into an NFA, and all NFAs can be converted into a regular expression (assuming the alphabet is the unicode character set lol), if it's true for one, it's true for both.</p>\n\n<p>An hand-contrived example regex:</p>\n\n<pre><code>&lt;[a-zA-Z]+&gt;\n</code></pre>\n\n<p>A regex recognizing the same language, without the + operator:</p>\n\n<pre><code>&lt;[a-zA-Z][a-zA-Z]*&gt;\n</code></pre>\n\n<p>This may seem intuitively true for such a simple example, but I'd like to know for certain that it is generally true. Also, is there an algorithm that can convert an NFA containing a plus-like flow into a star-like flow NFA? Thanks!</p>\n", 'ViewCount': '243', 'Title': 'Can the plus operator in regex be replaced by the star operator?', 'LastActivityDate': '2013-07-27T21:28:16.823', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<automata><regular-expressions>', 'CreationDate': '2013-07-27T21:19:18.777', 'Id': '13470''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do you construct a DFA from a  language that has a + sign? e.g. $L = \\{(a+b)\\}*$</p>\n', 'ViewCount': '1836', 'Title': 'Convert regular expression to DFA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-05T08:26:57.573', 'LastEditDate': '2013-08-05T08:26:57.573', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'messivp', 'PostTypeId': '1', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-08-04T12:27:37.260', 'Id': '13599''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've come across this problem in my studies, and I've abstracted it to the more general case here.</p>\n\n<p>Given a finite alphabet, what is a regular expression that matches all strings over the alphabet, except one particular finite substring?</p>\n\n<p>As an example:</p>\n\n<p>Given $\\Sigma = \\{a, b, c\\}$</p>\n\n<p>What is a regular expression that matches all of $\\Sigma$ except the substring $\nba$?</p>\n\n<p>What I really want is simply $\\Sigma^* - ba$. </p>\n", 'ViewCount': '594', 'Title': 'What is a regular expression that matches all strings over the alphabet except a particular substring?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T15:00:48.047', 'LastEditDate': '2013-09-16T07:17:29.020', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10092', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-09-12T02:24:16.167', 'Id': '14274''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I just started learning about formal lang and automata theory, and recently learned about regex, so I don't know any complicated symbols, so please stick with basic symbols.</p>\n\n<p>The question is: Write a regex for the following language over {0,1} that is a set of all odd length strings that contain exactly two 0's.</p>\n\n<p>I've got the first part finished (the odd part), it should be:</p>\n\n<p>(0+1)[(0+1)(0+1)]* ( + is the same as | (or) I believe, we learnt it as +)</p>\n\n<p>However, when I think about having exactly two 0's it gets really messed up. I can only see that I can use * with 1 only since # of 0's are limited to 2. But if i do (11)* , I can't get the permutation of 0's inside the 1's. (e.g. can't get 10101 with (11)*).</p>\n\n<p>What I know:</p>\n\n<ol>\n<li>Only 1's can use * </li>\n<li>In the regex only two 0's will be used</li>\n<li>The way to make odd length is to add an odd length to an even length\n(even length needs to have empty string within it's set)</li>\n<li>Odd length should not use * since 2 odd = even, so only even length\ncan use *</li>\n</ol>\n\n<p>For possible hints or answer, please use 0,1,+/|,*,(,) only. Some other expressions I will not be able to understand.</p>\n", 'ViewCount': '903', 'Title': "Regex for all odd length string that contains exactly 2 0's with language {0,1}", 'LastActivityDate': '2013-09-23T07:26:39.710', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14494', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<automata><regular-expressions>', 'CreationDate': '2013-09-21T10:42:50.617', 'Id': '14493''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m having trouble with this question about regular expressions:</p>\n\n<blockquote>\n  <p>Let $L_1$ be the language of passwords containing at least one\n  lowercase letter, at least one uppercase letter, and at least one\n  number. Write down a regular expression that describes $L_1$.</p>\n</blockquote>\n\n<p>This is my answer, but I\'m not too sure about it. I let $\\mathcal{A}$ be the alphabet, and attempted to cover all permutations. I think my answer is correct, but is there a simpler way to go about it?\n\\begin{equation*}\n (\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*)\\cup\n (\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*)\n\\end{equation*}</p>\n\n<p>I\'m really stuck on this second part:</p>\n\n<blockquote>\n  <p>Let $L_2$ be the language of "good" password. It is related to L1 by:\n  \\begin{equation*}  L_2=\\{w\\in L_1 : w \\text{ has length } \\geq 8\\} \\end{equation*} Specify a regular expression that describes $L_2$,\n  without writing it down in full. What is the length of this regex?</p>\n</blockquote>\n\n<p>I\'m not sure about how to construct a regular expression using my answer for $L_1$. I thought it might be similar to the first part, where I could specify all the permutations.</p>\n', 'ViewCount': '35', 'Title': 'Constructing regular expressions with given substring requirments', 'LastActivityDate': '2013-09-24T02:21:21.597', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14569', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10190', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2013-09-24T01:20:20.633', 'Id': '14568''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to figure out how to build a regular expression for a language that doesn't contain strings that contain $101$ or $001$. The alphabet is defined as $\\{0, 1\\}$. I'm stuck on trying to figure out the DFA. Any help would be appreciated.</p>\n", 'ViewCount': '747', 'Title': 'Regular expression for a string not containing a set of substrings', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-10-31T15:35:25.667', 'LastEditDate': '2013-10-31T15:35:25.667', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '14838', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2013-10-05T20:26:40.050', 'Id': '14837''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '57', 'Title': 'Regular Expression as basis for creating this grammar', 'LastEditDate': '2013-10-06T03:50:49.073', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': u"<p>I made a right-linear grammar from a regular expression:</p>\n\n<p>The alphabet is:</p>\n\n<p>$\u03a3 = \\{a, b, c\\} $</p>\n\n<p>Regular expression:</p>\n\n<p>$r = cc^{*}(ba)^{*}bb$</p>\n\n<p>My solution, it seems a little too short like I'm leaving something out. Maybe someone can see where I went wrong on the right-linearity:</p>\n\n<p>$ S \\to cA $</p>\n\n<p>$ A \\to b a A | B | cA $</p>\n\n<p>$ B \\to bb $</p>\n", 'Tags': '<formal-languages><automata><formal-grammars><regular-expressions>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-06T03:50:49.073', 'CommentCount': '2', 'AcceptedAnswerId': '14850', 'CreationDate': '2013-10-06T03:27:41.210', 'Id': '14849''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is the problem, given a string with characters from: <code>a-z</code>, <code>.</code>, <code>*</code>, and another string with characters from <code>a-z</code>. where <code>*</code> can delete the character before it, otherwise <code>*</code> is skipped and <code>.</code> can match any single character. the question is whether the first string can match the second one.</p>\n\n<p><strong>Note:</strong> That is the statement of the problem as I found, but in this case the character <code>*</code> performs the same function that <code>?</code> in a regular expression.</p>\n\n<p>Example:</p>\n\n<pre><code>isMatch("a*", "") = true; //"a*" could be "a" or an empty string ""\nisMatch(".", "") = false; \nisMatch("ab*", "a") = true; \nisMatch("a.", "ab") = true; \nisMatch("a", "a") = true;\n</code></pre>\n\n<p>I\'ve already solved this problem using a slightly modified edit distance, which I only know a 2D dynamic programming approach. I wonder whether exists a linear solution for this problem, maybe it is solvable without a dp approach?</p>\n', 'ViewCount': '75', 'Title': 'exact matching between two strings - linear edit distance?', 'LastActivityDate': '2013-10-21T22:57:59.747', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16263', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10254', 'Tags': '<algorithms><dynamic-programming><regular-expressions><strings>', 'CreationDate': '2013-10-20T17:52:06.507', 'FavoriteCount': '1', 'Id': '16260''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Having the grammar <code>G = (V,P,S)</code> with variable <code>V = {S,A}</code> over the alphabet <code>{a,b}</code> with the rules:</p>\n\n<blockquote>\n  <p>S->aA </p>\n  \n  <p>A->Sbb|b</p>\n</blockquote>\n\n<p>How can i recognize which kind of grammar is this? I think that\'s not "regular expression" because in the second rule there are 2 letters (bb) instead of one, so i think it\'s a "context free" grammar. Am i right?</p>\n', 'ViewCount': '45', 'Title': 'Which grammar is this?', 'LastEditorUserId': '7955', 'LastActivityDate': '2013-10-26T14:03:25.130', 'LastEditDate': '2013-10-26T13:35:09.680', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16444', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7955', 'Tags': '<regular-languages><context-free><regular-expressions>', 'CreationDate': '2013-10-26T13:15:25.583', 'Id': '16443''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently studying compilers and am having some issues with understanding regular sets. For example, lets say I had a set of binary strings, (0, 1). Would all integers that are even and positive be considered part of a regular set? Lets say I have that same set, but instead of being even, they are divisible by 5, would it still be a regular set?</p>\n\n<p>I\'ve been looking at <a href="http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf" rel="nofollow">this helpful guide</a> I found online, but I\'m still confused about what can be defined as a regular set.</p>\n', 'ViewCount': '71', 'Title': 'What can be defined as a Regular Set', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-28T07:26:56.920', 'LastEditDate': '2013-10-28T07:26:56.920', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11008', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-10-28T02:13:44.947', 'Id': '16485''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to create a regular expression that will generate the following language under the {a,b,c} alphabet:\nall words that do not contain the substring "bbc"</p>\n\n<p>I am having a really hard time understanding how to approach this question. I have done several other questions where a certain substring must be excluded, but this one really messes with my logic.</p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '83', 'ClosedDate': '2013-11-08T23:00:27.200', 'Title': 'A little help with regular expressions', 'LastActivityDate': '2013-12-09T10:40:08.243', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11200', 'Tags': '<formal-languages><regular-expressions><substrings>', 'CreationDate': '2013-11-05T12:22:33.267', 'Id': '16735''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I had a question on an assignment where we were supposed to write a regular expression for a language where every $a$ in $w$ is immediately preceded and followed by a $b$. My answer was $\\epsilon + (b + bab)^*$. The teacher pointed out that my answer makes an $a$ surrounded by at least two $b$s, which isn't correct. I can't for the life of me figure out how to fix it to make it correct. Can anyone help?</p>\n", 'ViewCount': '55', 'Title': "Regular expression for the language where every a is surrounded by b's", 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T17:56:34.657', 'LastEditDate': '2013-11-12T17:56:34.657', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '17934', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10884', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-11-11T19:55:17.943', 'Id': '17924''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given the language with alphabet: $\\{a, b, c\\}$\nDraw an NFA or DFA for all the strings that have exactly twice substrings $ab$ and at least on $c$.\nI\'m stuck with "exactly twice $ab$". Can somebody give me some ideas. It\'s also very good if you can suggest me the regular expression of this statement.</p>\n', 'ViewCount': '399', 'Title': 'NFA or DFA for strings the contain exactly twice substring ab?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-13T16:08:45.447', 'LastEditDate': '2013-11-12T09:47:18.353', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-11-12T03:43:29.253', 'Id': '17942''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have seen this question: <a href="http://cs.stackexchange.com/questions/2713/are-regular-expressions-lrk">Are regular expressions $LR(k)$?</a> and my question is slightly related.</p>\n\n<p>Suppose I have a regular expression:\nRE=(a*a*)?(a*a*)</p>\n\n<p>and I convert it to a grammar:\nG ::= A B\nA ::= C | (empty)\nC ::= D D\nD ::= aD | empty\nB ::= D D</p>\n\n<p>Can an LALR(1) parser such as Bison generate matches such that I can perform actions such as recording captures, etc... If so, is the cost linear in the size of the input?</p>\n\n<p>If not, is the lower bound on this operation the cost of simulating an NFA generated by the regular expression? I know that DFAs can\'t perform sub-match captures.</p>\n', 'ViewCount': '21', 'Title': 'Can regular expression captures be matched by a CFG being simulated by an $LR(k)$ parser?', 'LastActivityDate': '2013-11-14T05:00:11.847', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5331', 'Tags': '<regular-languages><context-free><regular-expressions><parsers>', 'CreationDate': '2013-11-14T05:00:11.847', 'Id': '18005''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Like the title says, we have the alphabet $\\Sigma = \\{a,b,c\\}$ and the question is asking for the regular expression of the language $L$ that has the property that all strings in $L$ have at least two consecutive $a$'s but no consecutive $b$'s. </p>\n\n<p>By attempt at a solution was this, where $aaa^+$ stands for $aaa(aaa)^*$:</p>\n\n<p>$$(a+c)^*aaa^+(a+c)^*b(a+c)^* + (a+c)^*b(a+c)^*aaa^+(a+c)^*$$</p>\n\n<p>but I know this is wrong since we never get an instance of consecutive $b$'s. Can someone point me in the right direction?</p>\n", 'ViewCount': '142', 'Title': "Regex for the language over $\\{a,b,c\\}$ that contain at least two $a$'s but no two consecutive $b$'s", 'LastActivityDate': '2013-12-07T11:52:03.477', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18702', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11892', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2013-12-07T00:49:53.050', 'Id': '18701''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve had this little doubt bothering me since four semesters now, so I\'ve come here to resolve it. Theoretical CS was probably not the right place to ask.</p>\n\n<p>Coming to the question, my old coursebook (<em>Theory of Computer Science - Automata, Languages and Computation (Eastern Economy Edition)</em> by KLP Mishra) details the conversion of the regular expression -:</p>\n\n<p>$(0 + 1)^* (00 + 11)(0+1)^*$</p>\n\n<p>to a finite automaton. The book details the process as follows:</p>\n\n<p><img src="http://i.stack.imgur.com/BLoTu.jpg" alt="Diagram of Procedure"></p>\n\n<p>I am able to grasp the process uptil step (d). I do not understand how (e) was obtained, and there is no explanation given. I tried to convert (d) to (e) by removing null-moves, but I am not able to get (e) - I obtain a bunch of redundant states (extra initial and final states). </p>\n\n<p>It is not possible to use the DFA minimization procedure to obtain (e) after the null-moves are deleted, simply because this isn\'t a DFA yet - it\'s still an NFA. Note that I\'ve not shown the NFA to DFA conversion procedure, which was on the next page. Could someone point me in the right direction? </p>\n\n<p>There are no steps given to obtain (e) from (d). That\'s what\'s confusing - I know I have  to remove the null-moves but not how to get the neat and \'minimized\' transition system given by (e).</p>\n', 'ViewCount': '239', 'Title': 'Redundant States During Removal of Null-Moves (Regular Expression to DFA)', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-10T17:09:24.310', 'LastEditDate': '2013-12-19T15:36:26.560', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11990', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-12-10T12:40:04.293', 'Id': '18828''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am having a bit of difficulty understanding the order of precedence in boolean logic for the OR operation. Take this example:</p>\n\n<p>Assume the following regular expression:</p>\n\n<pre><code>((a(b+))+(a|c))|a|c\n</code></pre>\n\n<p>Why is it that this accepts the strings:</p>\n\n<pre><code>a\nc\nabba\nabbabbba\nabbabbc\n</code></pre>\n\n<p>etc</p>\n\n<p>But when I flip it around and use the regular expression</p>\n\n<pre><code>a|c|((a(b+))+(a|c))\n</code></pre>\n\n<p>I can now only ever get the following strings when I check it with a RegExp tester:</p>\n\n<pre><code>a\nc\n</code></pre>\n\n<p>I know it is to do with the order of precedence but I don't understand why, please could somebody enlighten me?</p>\n", 'ViewCount': '81', 'Title': 'Why does a regular expression only accept all my required strings when the concatenation is the first of the OR operations?', 'LastActivityDate': '2013-12-11T05:47:49.150', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '18864', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12006', 'Tags': '<formal-languages><automata><regular-expressions>', 'CreationDate': '2013-12-11T02:11:39.407', 'FavoriteCount': '1', 'Id': '18858''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As seen in <a href="http://xkcd.com/1313/">this recent XKCD strip</a> and <a href="http://nbviewer.ipython.org/url/norvig.com/ipython/xkcd1313.ipynb">this recent blog post</a> from Peter Norvig (and a Slashdot story featuring the latter), "regex golf" (which might better be called the regular expression separation problem) is the puzzle of defining the shortest possible regular expression that accepts every word in set A and no word in set B.  Norvig\'s post includes an algorithm for generating a reasonably short candidate, and he notes that his approach involves solving an NP-complete Set Cover problem, but he\'s also careful to point out that his approach doesn\'t consider every possible regular expression, and of course his isn\'t necessarily the only algorithm, so his solutions aren\'t guaranteed to be optimal, and it\'s also possible that some other assuredly polynomial-time algorithm could find equivalent or better solutions.</p>\n\n<p>For concreteness\' sake and to avoid having to solve the optimization question, I think the most natural formulation of Regular Expression Separation would be:</p>\n\n<blockquote>\n  <p>Given two (finite) sets $A$ and $B$ of strings over some alphabet $\\Sigma$, is there a regular expression of length $\\leq k$ that accepts every string in $A$ and rejects every string in $B$?</p>\n</blockquote>\n\n<p>Is anything known about the complexity of this particular separation problem?  (Note that since I\'ve specified $A$ and $B$ as finite sets of strings, the natural notion of size for the problem is the total lengths of all strings in $A$ and $B$; this swamps any contribution from $k$). It seems highly likely to me that it <em>is</em> NP-complete (and in fact, I would expect the reduction to be to some sort of cover problem) but a few searches haven\'t turned up anything particularly useful.</p>\n', 'ViewCount': '286', 'Title': 'Is regex golf NP-Complete?', 'LastEditorUserId': '242', 'LastActivityDate': '2014-01-22T00:39:07.057', 'LastEditDate': '2014-01-14T17:52:01.430', 'AnswerCount': '1', 'CommentCount': '17', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '242', 'Tags': '<complexity-theory><np-complete><regular-expressions>', 'CreationDate': '2014-01-13T09:26:28.640', 'FavoriteCount': '2', 'Id': '19686''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I know that <code>(1 + 0)*</code> is the set of all bit strings; but isn't  <code>1* + 0*</code> the same thing?</p>\n", 'ViewCount': '797', 'Title': 'Difference between 1* + 0* and (1 + 0)*', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T13:43:32.987', 'LastEditDate': '2014-02-03T09:31:45.900', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '20236', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<formal-languages><terminology><regular-languages><regular-expressions>', 'CreationDate': '2014-02-03T03:58:32.153', 'Id': '20235''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having trouble finding the language represented by the following:</p>\n\n<p>(AA|BB)*</p>\n\n<p>Should the expression be read as... ( A (A|B) B ) *\nor... ( (AA) | (BB) )*</p>\n\n<p>If that isn't clear, should this produce something like... ABABAB or should it produce AABBAABBBBAA</p>\n\n<p>My guess is that AABBAA is part of the represented language, while AB is not.</p>\n", 'ViewCount': '45', 'Title': 'Precedence in regular expressions', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T14:27:36.157', 'LastEditDate': '2014-02-03T09:34:49.770', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '20241', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-languages><terminology><regular-expressions><precedence>', 'CreationDate': '2014-02-03T05:47:10.583', 'Id': '20239''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm working on homework for my formal languages and automata course. The text we are using is the first edition of Hopcroft and Ullman (1979). </p>\n\n<p>Specifically, I'm unsure how to justify that my regular expression for exercise 2.10 (c) is correct. The question asks for a regular expression for the set of all strings <strong>not</strong> containing the substring 101 (over the alphabet $\\{0, 1\\}$). Additionally, it asks for justification that the regular expression you write is correct. </p>\n\n<p>I came up with the regular expression \n$$0^*1^*0^* + (1 + 00 + 000)^* + 0^+1^+0^+.$$</p>\n\n<p>As for the justification, what exactly are they looking for?</p>\n", 'ViewCount': '69', 'ClosedDate': '2014-02-23T08:31:47.153', 'Title': 'Proving a regular expression is correct', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T22:51:10.453', 'LastEditDate': '2014-02-09T22:51:10.453', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14510', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-02-08T21:35:14.527', 'Id': '21458''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have the following context-free language:</p>\n\n<pre><code>S -&gt; ASa | b\nA -&gt; aA | a\n</code></pre>\n\n<p>I don't understand why this is not regular. I first said that it's generated by the regular expression <code>a+ba+</code>. The following is regular however</p>\n\n<pre><code>S -&gt; ASa | b\nA -&gt; aA | e\n</code></pre>\n\n<p>e stands for the empty string. I don't understand their differences.</p>\n", 'ViewCount': '67', 'Title': 'Context-free language and regular expressions', 'LastActivityDate': '2014-02-14T12:23:00.497', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '12066', 'Tags': '<regular-languages><context-free><regular-expressions>', 'CreationDate': '2014-02-14T09:43:23.857', 'Id': '21629''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am looking at the answer in solution manual which asked , all the words that don't have both substring bba and abb.</p>\n\n<p>and the answer was <code>a*(baa*)*b+b*(a*ab)*a*</code></p>\n\n<p>and I'm like wait a minute is that right ? but that can't make abb, which is in the language. So it's gotta wrong.</p>\n\n<p>so I came up with my own , would this be all the words that don't have both substring bba and abb ?</p>\n\n<pre><code>(b+^)(ab+a)*+b*\n</code></pre>\n\n<p>^ is an empty string by the way</p>\n", 'ViewCount': '72', 'Title': "how did they get this answer for the words that don't have bba and abb?", 'LastActivityDate': '2014-02-17T04:55:38.583', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<regular-expressions>', 'CreationDate': '2014-02-16T20:46:30.253', 'Id': '21707''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>If we were to have a trap state in a DFA and we are converting it to a regular expression, how exactly would I incorporate that into the regex? Let's say our language only accepts a*, and my DFA has a start state/final state with a <em>a</em> loop, and once I get a <em>b</em> it goes into a trap. Would the regex simply be <em>a</em>* meaning we ignore the <em>b</em>? </p>\n", 'ViewCount': '35', 'Title': 'About trap states when converting DFA to regular expression', 'LastActivityDate': '2014-02-23T10:07:50.357', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14951', 'Tags': '<regular-expressions>', 'CreationDate': '2014-02-23T01:03:33.783', 'Id': '21934''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was going through the text Introduction to Theory of Computation by Michael Sipser. It is written that $R\\circ\\emptyset$ may not equal to $R$. I thought $R\\circ\\emptyset=\\emptyset$ always. $R$ is any regular expression.</p>\n\n<p>Couldnt find any example that contradicts that</p>\n', 'ViewCount': '51', 'Title': 'Why $R\\circ\\emptyset$ is not always equal to $\\emptyset$', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-26T17:00:53.427', 'LastEditDate': '2014-02-26T17:00:53.427', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22013', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><regular-expressions>', 'CreationDate': '2014-02-25T03:50:57.280', 'Id': '22012''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to find a <code>regular expression</code> and <code>finite automaton</code> that each define $L_1 \\cap L_2$, where $L_1 = (ab^*)^*$ and $L_2 = b(a+b)^*$.</p>\n\n<p>How would I start doing this problem?</p>\n\n<p>So I would draw a FA and when I draw it I would have a complement meaning take anywhere you have a plus, get rid of it and anywhere you didn't have a plus add one in. Am I on the right track?</p>\n", 'ViewCount': '53', 'Title': 'find a regular expression and FA that each define $L_1 \\cap L_2$', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-02T15:56:22.643', 'LastEditDate': '2014-03-02T01:54:43.447', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15179', 'Tags': '<finite-automata><regular-expressions>', 'CreationDate': '2014-03-01T23:21:21.307', 'Id': '22174''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm studying for my exam and I came across the following exam question from last year, the only way I know how to solve this is build a regex that accounts for all six different series of letters so for example to recognize a string that has the letters a,b and c occur in that order:</p>\n\n<p>$(a+b+c)^*a(a+b+c)^*b(a+b+c)^*c$</p>\n\n<p>The question:\nGive a regular expression r over the alphabet A = {a, b, c} such that the\nlanguage determined by r consists of all strings that contain at least one occurrence of each symbol in A. Brie\ufb02y explain your answer.</p>\n", 'ViewCount': '114', 'Title': 'Regular expression to show that all strings contain each symbol atleast once', 'LastActivityDate': '2014-03-03T23:35:17.363', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22243', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15249', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2014-03-03T23:04:17.677', 'Id': '22242''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having trouble generating the set of strings, which a regular expressions describe.\nA typical regular expression can look like this:</p>\n\n<pre><code>[atom_0] atom_1 (atom_2 | atorm_3 | ... | atom_n-1) &lt;var&gt; [atom_n]\n</code></pre>\n\n<p>Or any other combination of the following:</p>\n\n<pre><code>[], means, that the atom inside of it can be omitted\n(), one of the atoms (seperated by | (stands for OR)) inside the braces can be chosen \n&lt;&gt;, variable.\natom, it can be thought as a constant, which is hard coded.\n</code></pre>\n\n<p>For example: </p>\n\n<pre><code>The [yellow] (dog | cat) named &lt;animalName&gt;\n</code></pre>\n\n<p>This expression describes the following set of strings:</p>\n\n<pre><code>The yellow dog named &lt;animalName&gt;;\nThe yellow cat named &lt;animalName&gt;;\nThe dog named &lt;animalName&gt;;\nThe cat named &lt;animal Name&gt;;\n</code></pre>\n\n<p>The strings can vary, depending on the variable <code>&lt;animalName&gt;</code>, but say, we have two names for <code>&lt;variableName&gt;</code> : <code>Petsy</code> and <code>Rony</code>, then w'll have:</p>\n\n<pre><code>The yellow dog named Petsy;\nThe yellow cat named Petsy;\nThe dog named Petsy;\nThe cat named Petsy;\nThe yellow dog named Rony;\nThe yellow cat named Rony;\nThe dog named Rony;\nThe cat named Rony;\n</code></pre>\n\n<p>Right now, I'm thinking that I could build a tree (or graph) from the expression and then a DFS or BFS can do the job.</p>\n\n<p>Any comments or document/article references would be helpful to me.</p>\n", 'ViewCount': '67', 'Title': 'Generating all strings that a regular expressions describe', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T22:34:20.143', 'LastEditDate': '2014-03-22T11:24:02.187', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22936', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15992', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-03-22T08:30:22.847', 'Id': '22931''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there a good general paper about the interpretation or compilation\nof REGEXP in programming languages for pattern matching, with or\nwithout variables? I am not looking for a quick explanation about the\nconstruction of DFAs, but for a real paper on how it is actually done\nin programming languages implementation, and what is considered simple\nor difficult. I expect differences between languages may have an\ninpact. A formal paper on how REGEXP implementation should be done is\nuseful too :-)</p>\n', 'ViewCount': '51', 'Title': 'How are REGEXP implemented in programming languages?', 'LastActivityDate': '2014-03-27T00:44:58.427', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<programming-languages><compilers><regular-expressions><matching><interpreters>', 'CreationDate': '2014-03-26T17:01:44.683', 'Id': '23089''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In proving Parikh's Theorem, my Theory of Computer Science textbook defines a linear set as:</p>\n\n<p>$u_0 + \\langle u_1, \\dots, u_m \\rangle = \\{u_0 + a_1u_1 + \\dots + a_mu_m \\mid a_1, \\dots, a_m \\in \\mathbb{N}\\}$ where $u_i$ are vectors of natural numbers.</p>\n\n<p>and a semi-linear set as a union of finitely many linear sets. It goes on to say ''For every semilinear set $S \\subset N^k$, it is not hard to construct a regular set $R \\subset \\Sigma^*$ such that $\\psi(R) = S$'' (where $\\psi$ is the Parikh map, taking strings over an alphabet $\\Sigma$ to vectors where the first entry is the number of the first letter, the second entry is the number of the second letter, etc. So $\\psi(\\{a, ab, ba, aaa\\})) = \\{(1), (1, 1), (3)\\}$.)</p>\n\n<p>I was trying to think why regular languages would be semi-linear instead of just linear, and it seems like the + (or) operation in regular expressions is to blame. Is this correct: are languages described by regular expressions which use only concatenation and $^*$ linear?</p>\n", 'ViewCount': '38', 'Title': 'Regular expressions and semi-linear sets', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-14T04:01:26.270', 'LastEditDate': '2014-04-14T02:45:44.470', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23775', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15627', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-04-14T01:59:01.303', 'Id': '23768''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>conversion of dfa to regular expressions\ni need the c or c++ code to convert deterministic finite automata to regular expressions using recursion\nthe program must take finite automata as input and the corresponding output must be the regular expressions of the respective finit automata</p>\n', 'ViewCount': '28', 'ClosedDate': '2014-04-27T19:12:58.220', 'Title': 'c program to convert dfa to regular expression using recursion', 'LastActivityDate': '2014-04-27T14:46:46.343', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17119', 'Tags': '<regular-expressions>', 'CreationDate': '2014-04-27T14:46:46.343', 'Id': '24151''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need help with this exercise. </p>\n\n<p>Indicate the regular expression for the following Languages. Explain your  expression in one sentence and indicate the basis form of the alphabet. Indicate also every assumption you make.</p>\n\n<p>i) Sums of positive fixed-point decimal numbers. The following Strings should exist in the Language: </p>\n\n<p>e.g: 3.14 or also 3 + 4.2 + 7 + 1</p>\n\n<p>I have a couple more exersices that are pretty similar but I guess if I get to understand this exercise I could try to do the others faster.</p>\n\n<p>I appreciate the help in advance. </p>\n', 'ViewCount': '31', 'ClosedDate': '2014-04-29T22:32:59.837', 'Title': 'regular expression: sum of positive fixed point decimal numbers', 'LastActivityDate': '2014-05-01T21:12:01.907', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '24227', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16960', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2014-04-29T16:13:53.143', 'Id': '24226''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to write a regular expression for some particular license plates. They consist of one up to three capital letters, a hyphen, one up to two capitol letters and one up to four numbers. The license plate should not exceed the 8 symbols.</p>\n\n<p>Example: AA-AA123</p>\n\n<p>What I have until now is the following:</p>\n\n<p>because there has to be at least one letter before the hyphen, I have this expression for the first letter:\n$$\nP = (A\\cup B \\cup...\\cup Z)\n$$</p>\n\n<p>For the second letter:\n$$\nD = (A\\cup B \\cup...\\cup Z\\cup empty)\n$$\nempty indicates the possibility that there could not be a letter.</p>\n\n<p>For the numbers is basically almost the same procedure:\n$$\nE = (1\\cup 2 \\cup...\\cup 9)\n$$\n$$\nF = (1\\cup 2 \\cup...\\cup 9 \\cup empty)\n$$</p>\n\n<p>now for my explicit expression I think the answer would be:\n$$\nK= PDD^* - PDEF^*F^*\n$$</p>\n\n<p>but I'm not quite sure. I think this means I have 8 symbols, at least one letter before the hyphen but I could have up to three, the hyphen (that is a must), at least one letter after the hyphen but up to two and at least one number but I could have up to 4.</p>\n\n<p>Something tells me I have something wrong here, I'm still new in the regular expressions world and I appreciate any help I could get in advance.</p>\n", 'ViewCount': '71', 'Title': 'regular expression in license plates', 'LastActivityDate': '2014-05-01T20:37:52.770', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16960', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2014-05-01T11:14:52.227', 'Id': '24293''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}