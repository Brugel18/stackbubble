{'ViewCount': '1377', 'Title': 'What is the significance of context-sensitive (Type 1) languages?', 'LastEditDate': '2012-03-07T16:09:28.450', 'AnswerCount': '9', 'Score': '23', 'PostTypeId': '1', 'OwnerUserId': '26', 'FavoriteCount': '1', 'Body': '<p>Seeing that in the <a href="http://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky Hierarchy</a> Type 3 languages can be recognised by a state machine with no external memory (i.e., a finite automaton), Type 2 by a state machine with a <em>single</em> stack (i.e. a push-down automaton) and Type 0 by a state machine with <em>two</em> stacks (or, equivalently, a tape, as is the case for Turing Machines), how do Type 1 languages fit into this picture? And what advantages does it bring to determine that a language is not only Type 0 but Type 1?</p>\n', 'Tags': '<formal-languages><applied-theory><computability><automata><formal-grammars>', 'LastEditorUserId': '69', 'LastActivityDate': '2012-03-08T02:30:13.020', 'CommentCount': '9', 'AcceptedAnswerId': '31', 'CreationDate': '2012-03-06T20:06:29.977', 'Id': '14''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '3821', 'Title': 'Language theoretic comparison of LL and LR grammars', 'LastEditDate': '2013-06-06T14:05:27.163', 'AnswerCount': '1', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '13', 'Body': '<p>People often say that <a href="https://en.wikipedia.org/wiki/LR_parser">LR(k)</a> parsers are more powerful than <a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a> parsers. These statements are vague most of the time; in particular, should we compare the classes for a fixed $k$ or the union over all $k$? So how is the situation really? In particular, I am interested in how LL(*) fits in.</p>\n\n<p>As far as I know, the respective sets of grammars LL and LR parsers accept are orthogonal, so let us talk about the languages generated by the respective sets of grammars. Let $LR(k)$ denote the class of languages generated by grammars that can be parsed by an $LR(k)$ parser, and similar for other classes.</p>\n\n<p>I am interested in the following relations:</p>\n\n<ul>\n<li>$LL(k) \\overset{?}{\\subseteq} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{\\subseteq} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{=} LL(*)$</li>\n<li>$LL(*) \\overset{?}{\\circ} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n</ul>\n\n<p>Some of these are probably easy; my goal is to collect a "complete" comparison. References are appreciated.</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T14:05:27.163', 'CommentCount': '2', 'AcceptedAnswerId': '48', 'CreationDate': '2012-03-07T00:32:31.947', 'Id': '43''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>EPAL, the language of even palindromes, is defined as the language generated by the following unambiguous context-free grammar:</p>\n\n<blockquote>\n  <p>$S \\rightarrow a a$</p>\n  \n  <p>$S \\rightarrow b b$</p>\n  \n  <p>$S \\rightarrow a S a$</p>\n  \n  <p>$S \\rightarrow b S b$</p>\n</blockquote>\n\n<p>EPAL is the 'bane' of many parsing algorithms: I have yet to encounter any parsing algorithm for unambiguous CFGs that can parse any grammar describing the language. It is often used to show that there are unambiguous CFGs that cannot be parsed by a particular parser. This inspired my question:</p>\n\n<blockquote>\n  <p>Is there some parsing algorithm accepting only unambiguous CFGs that works on EPAL?</p>\n</blockquote>\n\n<p>Of course, one can design an ad-hoc two-pass parser for the grammar that parses the language in linear time. I'm interested in parsing methods that have not been designed specifically with EPAL in mind.</p>\n", 'ViewCount': '150', 'Title': 'Is there any nongeneral CFG parsing algorithm that recognises EPAL?', 'LastActivityDate': '2013-01-24T01:25:28.517', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '141', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<formal-languages><formal-grammars><parsers>', 'CreationDate': '2012-03-07T16:56:52.460', 'FavoriteCount': '0', 'Id': '102''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1455', 'Title': 'Are there inherently ambiguous and deterministic context-free languages?', 'LastEditDate': '2012-03-15T11:35:41.913', 'AnswerCount': '1', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '1', 'Body': '<p>Let us call a context-free language deterministic if and only if it can be accepted by a deterministic push-down automaton, and nondeterministic otherwise.</p>\n\n<p>Let us call a context-free language inherently ambiguous if and only if all context-free grammars which generate the language are ambiguous, and unambiguous otherwise.</p>\n\n<p>An example of a deterministic, unambiguous language is the language: $$\\{a^{n}b^{n} \\in \\{a, b\\}^{*} | n \\ge 0\\}$$\nAn example of a nondeterministic, unambiguous language is the language: \n$$\\{w \\in \\{a, b\\}^{*} | w = w^{R}\\}$$</p>\n\n<p>From <a href="http://en.wikipedia.org/wiki/Ambiguous_grammar#Inherently_ambiguous_languages">Wikipedia</a>, an example of an inherently ambiguous context-free language is the following union of context-free languages, which must also be context-free: \n$$L = \\{a^{n}b^{m}c^{m}d^{n} \\in \\{a, b, c, d\\}^{*} | n, m \\ge 0\\} \\cup \\{a^{n}b^{n}c^{m}d^{m} \\in \\{a, b, c, d\\}^{*} | n, m \\ge 0\\}$$</p>\n\n<p>Now for the questions:</p>\n\n<ol>\n<li>Is it known whether there exists a deterministic, inherently ambiguous context-free language? If so, is there an (easy) example?</li>\n<li>Is it known whether there exists a nondeterministic, inherently ambiguous context-free language? If so, is there an (easy) example?</li>\n</ol>\n\n<p>Clearly, since an inherently ambiguous context-free language exists ($L$ is an example), the answer to one of these questions is easy, if it is known whether $L$ is deterministic or nondeterministic. I also assume that it\'s true that if there\'s a deterministic one, there\'s bound to be a nondeterministic one as well... but I\'ve been surprised before. References are appreciated, and apologies in advance if this is a well-known, celebrated result (in which case, I\'m completely unaware of it).</p>\n', 'Tags': '<formal-languages><automata><formal-grammars><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-15T11:35:41.913', 'CommentCount': '0', 'AcceptedAnswerId': '111', 'CreationDate': '2012-03-07T20:56:08.960', 'Id': '109''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '530', 'Title': 'Determining capabilities of a min-heap (or other exotic) state machines', 'LastEditDate': '2012-04-01T14:08:05.903', 'AnswerCount': '2', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '2', 'Body': '<p><em>See the end of this post for some clarification on the definition(s) of min-heap automata.</em></p>\n\n<p>One can imagine using a variety of data structures for storing information for use by state machines. For instance, push-down automata store information in a stack, and Turing machines use a tape. State machines using queues, and ones using two multiple stacks or tapes, have been shown to be equivalent in power to Turing machines.</p>\n\n<p>Imagine a min-heap machine. It works exactly like a push-down automaton, with the following exceptions:</p>\n\n<ol>\n<li>Instead of getting to look at the last thing you added to the heap, you only get to look at the smallest element (with the ordering defined on a per-machine basis) currently on the heap.</li>\n<li>Instead of getting to remove the last thing you added to the heap, you only get to remove one of the smallest element (with the ordering defined on a per-machine basis) currently on the heap.</li>\n<li>Instead of getting to add an element to the top of the heap, you can only add an element to the heap, with its position being determined according to the other elements in the heap (with the ordering defined on a per-machine basis).</li>\n</ol>\n\n<p>This machine can accept all regular languages, simply by not using the heap. It can also accept the language $\\displaystyle \\{a^{n}b^{n} \\in \\{a, b\\}^{*} \\mid n \\ge 0\\}$ by adding $a$\'s to the heap, and removing $a$\'s from the heap when it reads $b$\'s. It can accept a variety of other context-free languages. However, it cannot accept, for instance, $\\displaystyle \\{w \\in \\{a, b\\}^{*} \\mid w = w^{R}\\}$ (stated without proof). EDIT: or can it? I don\'t think it can, but I\'ve been surprised before, and I\'m sure I\'ll keep being surprised when my assumptions to keep making of me an... well.</p>\n\n<blockquote>\n  <p>Can it accept any context-sensitive or Turing-complete languages?</p>\n</blockquote>\n\n<p>More generally, what research, if any, has been pursued in this direction? What results are there, if any? I am also interested in other varieties of exotic state machines, possibly those using other data structures for storage or various kinds of restrictions on access (e.g., how LBAs are restricted TMs). References are appreciated. I apologize in advance if this question is demonstrating ignorance.</p>\n\n<hr>\n\n<p><strong>Formal Definition:</strong></p>\n\n<p>I provide some more detailed definitions of min-heap automata here in order to clarify further discussion in questions which reference this material.</p>\n\n<p>We define a <em>type-1 nondeterministic min-heap automaton</em> as a 7-tuple $$(Q, q_0, A, \\Sigma, \\Gamma, Z_0, \\delta)$$ where...</p>\n\n<ol>\n<li>$Q$ is a finite, non-empty set of states;</li>\n<li>$q_0 \\in Q$ is the initial state;</li>\n<li>$A \\subseteq Q$ is the set of accepting states;</li>\n<li>$\\Sigma$ is a finite, non-empty input alphabet;</li>\n<li>$\\Gamma$ is a finite, non-empty input alphabet, where the weight of a symbol $\\gamma \\in \\Gamma$, $w(\\gamma) \\in \\mathbb{N}$, is such that $w(\\gamma_1) = w(\\gamma_2) \\iff \\gamma_1 = \\gamma_2$;</li>\n<li>$Z_0 \\notin \\Gamma$ is the special bottom-of-the-heap symbol;</li>\n<li>$\\delta : Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\times (\\Gamma \\cup \\{Z_0\\}) \\rightarrow \\mathcal{P}({Q \\times \\Gamma^*})$ is the transition function.</li>\n</ol>\n\n<p>The transition function works by assuming an initially empty heap consisting of only $Z_0$. The transition function may add to the heap an arbitrary collection (finite, but possibly empty or with repeats) of elements $\\gamma_1, \\gamma_2, ..., \\gamma_k \\in \\Gamma$. Alternatively, the transition function may remove an instance of the element $\\gamma$ with the lowest weight $w(\\gamma)$ of all elements remaining on the heap (i.e., the element on top of the heap). The transition function may only use the top-most (i.e., of minimal weight) symbol instance in determining any given transition.</p>\n\n<p>Further, define a <em>type-1 deterministic min-heap automaton</em> to be a type-1 nondeterministic min-heap automaton which satisfies the following property: for all strings $x{\\sigma}y \\in \\Sigma$ such that $|x| = n$ and $\\sigma \\in \\Sigma$, $|\\delta^{n+1}(q_0, x{\\sigma}y, Z_0)| \\leq 1$.</p>\n\n<p>Define also a <em>type-2 nondeterministic min-heap automaton</em> exactly the same as a type-1 nondeterministic min-heap automaton, except for the following changes:</p>\n\n<ol>\n<li>$\\Gamma$ is a finite, non-empty input alphabet, where the weight of a symbol $\\gamma \\in \\Gamma$, $w(\\gamma) \\in \\mathbb{N}$, is such that $w(\\gamma_1) = w(\\gamma_2)$ does not necessarily imply $\\gamma_1 = \\gamma_2$; in other words, different heap symbols can have the same weight.</li>\n<li>When instances of distinct heap symbols with same weight are added to the heap, their relative order is preserved according to a last-in, first-out (LIFO) stack-like ordering.</li>\n</ol>\n\n<p>Thanks to Raphael for pointing out this more natural definition, which captures (and extends) the context-free languages. </p>\n\n<hr>\n\n<p><strong>Some results demonstrated so far:</strong></p>\n\n<ol>\n<li>Type-1 min-heap automata recognize a set of languages which is neither a subset nor a superset of the context-free languages. [<a href="http://cs.stackexchange.com/a/114/98">1</a>,<a href="http://cs.stackexchange.com/a/115/98">2</a>]</li>\n<li>Type-2 min-heap automata, by their definition, recognize a set of languages which is a proper superset of the context-free languages, as well as a proper superset of the languages accepted by type-1 min-heap automata.</li>\n<li>Languages accepted by type-1 min-heap automata appear to be closed under union, concatenation, and Kleene star, but not under complementation [<a href="http://cs.stackexchange.com/a/415/98">1</a>], intersection, or difference;</li>\n<li>Languages accepted by type-1 nondeterministic min-heap automata appear to be a proper superset of languages accepted by type-1 deterministic min-heap automata.</li>\n</ol>\n\n<p>There may be a few other results I have missed. More results are (possibly) on the way.</p>\n\n<hr>\n\n<p><strong>Follow-up Questions</strong></p>\n\n<ol>\n<li><a href="http://cs.stackexchange.com/q/390/98">Closure under reversal?</a> -- Open</li>\n<li><a href="http://cs.stackexchange.com/q/393/98">Closure under complementation?</a> -- No!</li>\n<li><a href="http://cs.stackexchange.com/q/394/98">Does nondeterminism increase power?</a> -- Yes?</li>\n<li><a href="http://cs.stackexchange.com/q/933/69">Is $HAL \\subsetneq CSL$ for type-2?</a> -- Open</li>\n<li><a href="http://cs.stackexchange.com/q/934/69">Does adding heaps increase power for type-1?</a> -- $HAL^1 \\subsetneq HAL^2 = HAL^k$ for $k &gt; 2$ (?)</li>\n<li><a href="http://cs.stackexchange.com/q/944/69">Does adding a stack increase power for type-1?</a> -- Open</li>\n</ol>\n', 'Tags': '<formal-languages><automata>', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-01T14:08:05.903', 'CommentCount': '3', 'AcceptedAnswerId': '114', 'CreationDate': '2012-03-07T21:23:29.537', 'Id': '110''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '649', 'Title': 'What are the conditions for a NFA for its equivalent DFA to be maximal in size?', 'LastEditDate': '2012-03-15T10:17:50.310', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '1', 'Body': "<p>We know that DFAs are equivalent to NFAs in expressiveness power; there is also a known algorithm for converting NFAs to DFAs (unfortunately I do now know the inventor of that algorithm), which in worst case gives us $2^S$ states, if our NFA had $S$ states.</p>\n\n<p>My question is: what is determining the worst case scenario?</p>\n\n<hr>\n\n<p>Here's a transcription of an algorithm in case of ambiguity:</p>\n\n<p>Let $A = (Q,\\Sigma,\\delta,q_0,F)$ be a NFA. We construct a DFA $A&#39; = (Q&#39;,\\Sigma,\\delta&#39;,q&#39;_0,F&#39;)$ where </p>\n\n<ul>\n<li>$Q&#39; = \\mathcal{P}(Q)$, </li>\n<li>$F&#39; = \\{S \\in Q&#39; | F \\cap S \\neq \\emptyset \\}$,</li>\n<li>$\\delta&#39;(S,a) =\\bigcup_{s \\in S} (\\delta(s,a) \\cup \\hat \\delta(s,\\varepsilon))$, and</li>\n<li>$q&#39;_0 = \\{q_0\\} \\cup \\hat \\delta(q_0, \\varepsilon)$,</li>\n</ul>\n\n<p>where $\\hat\\delta$ is the extended transition function of $A$.</p>\n", 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T10:45:27.090', 'CommentCount': '1', 'AcceptedAnswerId': '131', 'CreationDate': '2012-03-08T10:20:46.940', 'Id': '130''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '510', 'Title': 'A sufficient and necessary condition about regularity of a language', 'LastEditDate': '2012-03-15T11:35:19.527', 'AnswerCount': '5', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p>Which of the following statements is correct?   </p>\n  \n  <ol>\n  <li>sufficient and necessary conditions about regularity of a language exist but not discovered yet.</li>\n  <li><p>There\'s no sufficient and necessary condition about regularity of a\n  language.</p></li>\n  <li><p>Pumping lemma is a necessary condition for non-regularity of a\n      language.</p></li>\n  <li>Pumping lemma is a sufficient condition for non-regularity of a\n  language.</li>\n  </ol>\n</blockquote>\n\n<p>I know <a href="http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages#Converse_of_lemma_not_true" rel="nofollow">#(4) is correct and #(3) is false</a> because "the converse of this statement is not true: a language that satisfies these conditions may still be non-regular", but what can be said about (1) and (2)?</p>\n', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-15T11:35:19.527', 'CommentCount': '6', 'AcceptedAnswerId': '162', 'CreationDate': '2012-03-09T13:03:34.620', 'Id': '156''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '539', 'Title': 'What are the possible sets of word lengths in a regular language?', 'LastEditDate': '2012-03-10T15:16:58.000', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Given a language $L$, define the length set of $L$ as the set of lengths of words in $L$:\n$$\\mathrm{LS}(L) = \\{|u| \\mid u \\in L \\}$$</p>\n\n<p>Which sets of integers can be the length set of a regular language?</p>\n', 'Tags': '<formal-languages><computability><regular-languages><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-10T15:16:58.000', 'CommentCount': '2', 'AcceptedAnswerId': '175', 'CreationDate': '2012-03-09T16:46:44.240', 'Id': '164''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '274', 'Title': 'Is there a "natural" undecidable language?', 'LastEditDate': '2012-12-13T02:16:00.593', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '2', 'Body': '<p>Is there any "natural" language which is undecidable?</p>\n\n<p>by "natural" I mean a language defined directly by properties of strings, and not via machines and their equivalent. In other words, if the language looks like\n$$ L = \\{ \\langle M \\rangle \\mid \\ldots \\}$$\nwhere $M$ is a TM, DFA (or regular-exp), PDA (or grammar), etc.., then $L$ <strong>is not</strong> natural. However $L = \\{xy \\ldots \\mid x \\text{ is a prefix of y} \\ldots \\}$ is natural.</p>\n', 'Tags': '<formal-languages><automata><computability><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:16:00.593', 'CommentCount': '0', 'AcceptedAnswerId': '179', 'CreationDate': '2012-03-10T05:08:27.597', 'Id': '178''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Let $L_1$, $L_2$, $L_3$, $\\dots$ be an in\ufb01nite sequence of context-free languages, each of\nwhich is de\ufb01ned over a common alphabet $\u03a3$. Let $L$ be the in\ufb01nite union of $L_1$, $L_2$, $L_3$, $\\dots $;\ni.e., $L = L_1 \\cup L_2 \\cup L_3 \\cup \\dots $. </p>\n\n<p>Is it always the case that $L$ is a context-free language? </p>\n', 'ViewCount': '676', 'Title': u'Is an in\ufb01nite union of context-free languages always context-free?', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-25T15:12:25.303', 'LastEditDate': '2012-04-25T15:12:25.303', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '208', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2012-03-10T18:10:35.290', 'Id': '206''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '188', 'Title': 'Parsing arbitrary context-free grammars, mostly short snippets', 'LastEditDate': '2012-03-12T17:43:05.270', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '2', 'Body': "<p>I want to parse user-defined domain specific languages. These languages are typically close to mathematical notations (I am not parsing a natural language). Users define their DSL in a BNF notation, like this:</p>\n\n<pre><code>expr ::= LiteralInteger\n       | ( expr )\n       | expr + expr\n       | expr * expr\n</code></pre>\n\n<p>Input like <code>1 + ( 2 * 3 )</code> must be accepted, while input like <code>1 +</code> must be rejected as incorrect, and input like <code>1 + 2 * 3</code> must be rejected as ambiguous.</p>\n\n<p>My parser must work on any context-free grammar, even ambiguous ones, and must accept all unambiguous input. I need the parse tree for all accepted input. For invalid or ambiguous input, I ideally want good error messages, but to start with I'll take what I can get.</p>\n\n<p>I will typically invoke the parser on relatively short inputs, with the occasional longer input. So the asymptotically faster algorithm may not be the best choice. I would like to optimize for a distribution of around 80% inputs less than 20 symbols long, 19% between 20 and 50 symbols, and 1% rare longer inputs. Speed for invalid inputs is not a major concern. Furthermore, I expect a modification of the DSL around every 1000 to 100000 inputs; I can spend a couple of seconds preprocessing my grammar, not a couple of minutes.</p>\n\n<p>What parsing algorithm(s) should I investigate, given my typical input sizes? Should error reporting be a factor in my selection, or should I concentrate on parsing unambiguous inputs and possibly run a completely separate, slower parser to provide error feedback?</p>\n", 'Tags': '<formal-languages><parsers><compilers>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-24T01:22:22.403', 'CommentCount': '9', 'AcceptedAnswerId': '237', 'CreationDate': '2012-03-12T11:27:50.537', 'Id': '234''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '7833', 'Title': 'How to prove that a language is not context-free?', 'LastEditDate': '2013-06-06T13:59:18.867', 'AnswerCount': '5', 'Score': '39', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '16', 'Body': '<p>We learned about the class of context-free languages $\\mathrm{CFL}$. It is characterised by both <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammars</a> and <a href="https://en.wikipedia.org/wiki/Pushdown_automata">pushdown automata</a> so it is easy to show that a given language is context-free.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for <em>all</em> grammars (or automata) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n', 'Tags': '<formal-languages><context-free><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-12-04T20:04:21.587', 'CommentCount': '0', 'AcceptedAnswerId': '276', 'CreationDate': '2012-03-12T23:57:46.817', 'Id': '265''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '336', 'Title': 'Decidable non-context-sensitive languages', 'LastEditDate': '2012-03-13T02:01:32.497', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '95', 'FavoriteCount': '1', 'Body': '<p>It is arguable that most languages created to describe everyday problems are context-sensitives. In the other hand, it is possible and not hard to find some languages that are not recursive or even not recursively-enumerable.</p>\n\n<p>Between these two types are the recursive non-context-sensitive languages. Wikipedia gives one example <a href="http://en.wikipedia.org/wiki/Context-sensitive_language">here</a>:</p>\n\n<blockquote>An example of recursive language that is not context-sensitive is any recursive language whose decision is an EXPSPACE-hard problem, say, the set of pairs of equivalent regular expressions with exponentiation.</blockquote>\n\n<p>So the question: What others problems exists that are decidable but yet non-context-sensitive? Is this class of problems the same as decidable EXPSPACE-hard?</p>\n', 'Tags': '<formal-languages><complexity-theory><formal-grammars>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-13T03:17:33.480', 'CommentCount': '1', 'AcceptedAnswerId': '280', 'CreationDate': '2012-03-13T01:19:52.050', 'Id': '273''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>Originally <a href="http://math.stackexchange.com/questions/22614/help-understand-texthandle-in-parsing-problem">http://math.stackexchange.com/questions/22614/help-understand-texthandle-in-parsing-problem</a> but unaswered there</em></p>\n\n<p>The BNF is defined as followed:</p>\n\n<pre><code>S -&gt; aAb | bBA \nA -&gt; ab | aAB\nB -&gt; bB | b\n</code></pre>\n\n<p>The sentence is:</p>\n\n<pre><code>aaAbBb\n</code></pre>\n\n<p>And this is the parse tree:\n<img src="http://i.stack.imgur.com/gpdeo.png" alt="enter image description here"></p>\n\n<p><strong>Phrases:</strong> aaAbBb, aAbB, bB<br>\n<strong>Simple Phrases:</strong> bB<br>\n<strong>Handle:</strong> ?    </p>\n\n<p>From the book, <code>handle</code> is defined as followed:\n<code>B</code> is the handle of the right sentential from $y = aBw$ if and only if:<br>\n$S \\to_{rm} \\cdot aAw \\to_{rm} aBw$</p>\n\n<p>So in my case, what\'s the handle? Any idea?  </p>\n', 'ViewCount': '213', 'Title': 'Understanding $\\text{handle}$ in parsing problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-29T12:53:46.907', 'LastEditDate': '2012-06-29T12:53:46.907', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<formal-languages><compilers><parsers>', 'CreationDate': '2012-03-13T06:36:58.727', 'Id': '290''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1152', 'Title': 'Show that $\\{xy \\mid |x| = |y|, x\\neq y\\}$ is context-free', 'LastEditDate': '2012-03-17T09:44:30.983', 'AnswerCount': '2', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '3', 'Body': "<p>I remember coming across the following question about a language that supposedly is context-free, but I was unable to find a proof of the fact. Have I perhaps misremembered the question?</p>\n\n<p>Anyway, here's the question:</p>\n\n<blockquote>\n  <p>Show that the language $L = \\{xy \\mid |x| = |y|, x\\neq y\\}$ is context free.</p>\n</blockquote>\n", 'Tags': '<formal-languages><context-free>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-09-23T14:09:34.027', 'CommentCount': '1', 'AcceptedAnswerId': '313', 'CreationDate': '2012-03-13T12:37:34.093', 'Id': '307''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I came across this figure which shows that context-free and regular languages are (proper) subsets of efficient problems (supposedly $\\mathrm{P}$). I perfectly understand that efficient problems are a subset of all decidable problems because we can solve them but it could take a very long time. </p>\n\n<p>Why are <em>all</em> context-free and regular languages efficiently decidable? Does it mean solving them will not take a long time (I mean we know it without more context)?</p>\n\n<p><img src="http://i.stack.imgur.com/xdEBQ.jpg" alt="enter image description here"></p>\n', 'ViewCount': '1486', 'Title': 'Are all context-free and regular languages efficiently decidable?', 'LastEditorUserId': '51', 'LastActivityDate': '2012-03-13T17:33:24.600', 'LastEditDate': '2012-03-13T17:33:24.600', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><regular-languages><context-free><efficiency>', 'CreationDate': '2012-03-13T15:59:26.123', 'Id': '315''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>A deterministic finite automaton (DFA) is a state machine model capable of accepting all and only regular languages. DFAs can be (and usually are) defined in such a way that each state must provide some transition for all elements of the input alphabet; in other words, the transition function $\\delta : Q \\times \\Sigma \\rightarrow Q$ should be a (total) function.</p>\n\n<p>Imagine what we will call a doubly deterministic finite automaton (DDFA). It is defined similarly to a DFA, with two exceptions: first, instead of the transition leading from one state to one other state for every possible input symbol, it must lead to two distinct states; second, in order to accept a string, all potential paths must satisfy either one or the other of the following conditions:</p>\n\n<ol>\n<li>All potential paths through the DDFA lead to an accepting state (we will call this a type-1 DDFA).</li>\n<li>All potential paths through the DDFA lead to the same accepting state (we will call this a type-2 DDFA).</li>\n</ol>\n\n<p>Now for my question:</p>\n\n<blockquote>\n  <p>What languages do type-1 and type-2 DDFAs accept? Specifically, is it the case that $L(DFA) \\subsetneq L(DDFA)$, $L(DDFA) = L(DFA)$, or $L(DDFA) \\subsetneq L(DFA)$? In the case that $L(DDFA) \\neq L(DFA)$, is there an easy description of $L(DDFA)$? </p>\n</blockquote>\n\n<p>Proofs (or at least moderately fleshed-out sketches) are appreciated, if they aren't too complicated.</p>\n", 'ViewCount': '133', 'Title': 'Languages accepted by modified versions of finite automata', 'LastActivityDate': '2012-03-14T18:00:07.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '385', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2012-03-14T14:59:22.810', 'Id': '374''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '228', 'Title': 'Is this language defined using twin primes regular?', 'LastEditDate': '2012-03-14T15:49:25.680', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '2', 'Body': '<p>Let</p>\n\n<p>$\\qquad L = \\{a^n \\mid \\exists_{p \\geq n}\\ p\\,,\\ p+2 \\text{ are prime}\\}.$</p>\n\n<p>Is $L$ regular?</p>\n\n<p>This question looked suspicious at the first glance and I\'ve realized that it is connected with the <a href="https://en.wikipedia.org/wiki/Twin_prime">twin prime conjecture</a>. My problem is that the conjecture has not been resolved yet, so I am not sure how can I proceed with deciding that the language is regular. </p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-14T20:25:40.660', 'CommentCount': '2', 'AcceptedAnswerId': '377', 'CreationDate': '2012-03-14T15:42:01.860', 'Id': '376''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a>.</em></p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that the regular languages are closed under a variety of operations (we may limit ourselves to basic operations such as union, intersection, complement, difference, concatenation, Kleene star, and reversal), whereas the context-free languages have different closure properties (these are closed under union, concatenation, Kleene star, and reversal).</p>\n\n<blockquote>\n  <p>Is HAL closed under reversal?</p>\n</blockquote>\n', 'ViewCount': '386', 'Title': 'Proving closure under reversal of languages accepted by min-heap automata', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T04:30:39.730', 'LastEditDate': '2012-04-24T07:15:47.070', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><closure-properties>', 'CreationDate': '2012-03-14T20:17:55.613', 'Id': '390''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a></em>.</p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that the regular languages are closed under a variety of operations (we may limit ourselves to basic operations such as union, intersection, complement, difference, concatenation, Kleene star, and reversal), whereas the context-free languages have different closure properties (these are closed under union, concatenation, Kleene star, and reversal).</p>\n\n<blockquote>\n  <p>Is HAL closed under complementation?</p>\n</blockquote>\n', 'ViewCount': '323', 'Title': 'Proving closure under complementation of languages accepted by min-heap automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-24T07:15:31.283', 'LastEditDate': '2012-04-24T07:15:31.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '415', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><closure-properties>', 'CreationDate': '2012-03-14T21:51:34.593', 'Id': '393''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '724', 'Title': 'Computational power of deterministic versus nondeterministic min-heap automata', 'LastEditDate': '2012-03-16T18:25:40.237', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '0', 'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a>.</em></p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that deterministic and nondeterministic finite automata have equivalent computational capabilities, as do deterministic and nondeterministic Turing machines. However, the computational capabilities of deterministic push-down automata are less than those of nondeterministic push-down automata.</p>\n\n<blockquote>\n  <p>Are the computational capabilities of deterministic min-heap automata less than, or are they equal to, those of nondeterministic min-heap automata?</p>\n</blockquote>\n', 'Tags': '<formal-languages><automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-16T18:25:40.237', 'CommentCount': '0', 'AcceptedAnswerId': '406', 'CreationDate': '2012-03-14T21:52:44.340', 'Id': '394''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The following DFA is a lexical analyzer which is supposed to recognize comments. The lexical analyzer will ignore the comment and goes back to the state one. I\'m told that there\'s something wrong with it but I can\'t figure it out. What\'s the problem?</p>\n\n<p><img src="http://i.stack.imgur.com/EeIdO.png" alt="enter image description here"></p>\n\n<p>FWIW, those tiny signs are stars which are necessary for C-style comment: "/* comment */"<br>\n  The loop in the state three is "except *"</p>\n', 'ViewCount': '489', 'Title': 'A DFA for recognizing comments', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:19.720', 'LastEditDate': '2012-03-25T15:53:37.777', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '398', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><automata><finite-automata><compilers>', 'CreationDate': '2012-03-14T22:46:16.420', 'Id': '396''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can every <a href="http://en.wikipedia.org/wiki/Linear_grammar" rel="nofollow">linear grammar</a> be converted to a linear <a href="http://en.wikipedia.org/wiki/Greibach_normal_form" rel="nofollow">Greibach normal form</a>, a form in which all productions look like $A \\rightarrow ax$ where $a \\in T$ and $x \\in V \\cup \\{\\lambda\\}$?</p>\n\n<p>($T$ is the set of terminals, $V$ is the set of non-terminals, $\\lambda$ is the empty sequence.)</p>\n', 'ViewCount': '230', 'Title': 'Can every linear grammar be converted to Greibach form?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T03:09:38.617', 'LastEditDate': '2012-03-27T03:09:38.617', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '591', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-03-21T07:15:34.200', 'Id': '588''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was given the question </p>\n\n<blockquote>\n  <p>Where does the following language fit in the Chomsky hierarchy?</p>\n  \n  <p>Nonnegative solutions $(x,y)$ to the Diophantine equation $3x-y=1$.</p>\n</blockquote>\n\n<p>I understand languages like $L = \\{ 0^n1^n \\mid n \\ge 1\\}$, but this language confuses me. What do the words in the language look like? How could I represent it using a grammar or regular expression?</p>\n', 'ViewCount': '204', 'Title': 'How can solutions of a Diophantine equation be expressed as a language?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T16:32:48.977', 'LastEditDate': '2012-03-25T16:32:48.977', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><computability>', 'CreationDate': '2012-03-21T18:09:06.090', 'Id': '618''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have the following language</p>\n\n<p>$\\qquad \\{0^i 1^j 2^k \\mid 0 \\leq i \\leq j \\leq k\\}$</p>\n\n<p>I am trying to determine which Chomsky language class it fits into. I can see how it could be made using a context-sensitive grammar so I know it is atleast context-sensitive. It seems like it wouldn't be possible to make with a context-free grammar, but I'm having a problem proving that.</p>\n\n<p>It seems to pass the fork-pumping lemma because if $uvwxy$ is all placed in the third part of any word (the section with all of the $2$s). It could pump the $v$ and $x$ as many times as you want and it would stay in the language. If I'm wrong could you tell me why, if I'm right, I still think this language is not context-free, so how could I prove that?</p>\n", 'ViewCount': '951', 'Title': 'How can I prove this language is not context-free?', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-20T20:06:21.393', 'LastEditDate': '2013-03-20T20:06:21.393', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><context-free><formal-grammars><pumping-lemma>', 'CreationDate': '2012-03-21T18:21:10.833', 'Id': '619''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>Note this is a question related to study in a CS course at a university, it is NOT homework and can be found <a href="http://www.cs.ucf.edu/~dmarino/ucf/transparency/cot4210/exam/">here</a> under Fall 2011 exam2.</em></p>\n\n<p>Here are the two questions I\'m looking at from a past exam.  They seem to be related, the first:</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{CFG}} = \\{ &lt; \\! G \\! &gt; \\mid G \\text{ is a Context Free Grammar with } |\\mathcal{L}(G)|&lt;\\infty \\} $</p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{CFG}}$ is a decidable language.   </p>\n</blockquote>\n\n<p>and...</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{TM}} = \\{ &lt; \\! M\\!&gt; \\mid M \\text{ is a Turing Machine with } |\\mathcal{L}(M)|&lt;\\infty \\}$ </p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{TM}}$ is an undecidable language.   </p>\n</blockquote>\n\n<p>I am a bit lost on how to tackle these problems, but I have a few insights which I think may be in the right direction.  The first thing is that I am aware of is that the language $A_{\\mathrm{REX}}$, where </p>\n\n<blockquote>\n  <p>$\\qquad A_{\\mathrm{REX}} = \\{ &lt;\\! R, w \\!&gt; \\mid R \\text{ is a regular expression with } w \\in\\mathcal{L}(R)\\}$</p>\n</blockquote>\n\n<p>is a decidable language (proof is in Michael Sipser\'s <i>Theory of Computation</i>, pg. 168).  The same source also proves that a Context Free Grammar can be converted to a regular expression, and vice versa.  Thus $A_{\\mathrm{CFG}}$, must also be decidable as it can be converted to a regular expression.  This, and the fact that $A_{\\mathrm{TM}}$ is <b>un</b>-decidable, seems to be related to this problem.</p>\n\n<p>The only thing I can think of is passing G to Turing machines for $A_{\\mathrm{REX}}$ (after converting G to a regular expression) and $A_{\\mathrm{TM}}$.  Then accepting if G does and rejecting if G doesn\'t.  As $A_{\\mathrm{TM}}$ is undecidable, this will never happen.  Somehow I feel like I\'m making a mistake here, but I\'m not sure of what it is.  Could someone please lend me a hand here? </p>\n', 'ViewCount': '639', 'Title': 'Decidablity of Languages of Grammars and Automata', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T02:52:20.370', 'LastEditDate': '2012-03-27T02:52:20.370', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '629', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><computability><context-free><regular-languages><turing-machines>', 'CreationDate': '2012-03-21T20:07:51.783', 'Id': '627''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Write $\\bar n$ for the decimal expansion of $n$ (with no leading <code>0</code>). Let $a$ and $b$ be integers, with $a &gt; 0$. Consider the language of multiples of $a$ plus a constant:</p>\n\n<p>$$M = \\{ \\overline{a\\,x+b} \\mid x\\in\\mathbb{N} \\}$$</p>\n\n<p>Is $M$ regular? context-free?</p>\n\n<p>(Contrast with <a href="http://cs.stackexchange.com/questions/641/language-of-the-graph-of-an-affine-function">Language of the graph of an affine function</a>)</p>\n\n<p><sub> I think this would make a good homework question, so answers that start with a hint or two and explain not just how to solve the question but also how to decide what techniques to use would be appreciated. </sub></p>\n', 'ViewCount': '522', 'Title': 'Language of the values of an affine function', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-20T16:01:38.250', 'LastEditDate': '2012-03-22T09:26:48.400', 'AnswerCount': '5', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<formal-languages><context-free><regular-languages><integers>', 'CreationDate': '2012-03-22T01:54:55.207', 'FavoriteCount': '1', 'Id': '640''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Write $\\bar n$ for the decimal expansion of $n$ (with no leading <code>0</code>). Let <code>:</code> be a symbol distinct from any digit. Let $a$ and $b$ be integers, with $a &gt; 0$. Consider the language of solutions of the Diophantine equation $y=ax+b$:</p>\n\n<p>$$L = \\{ \\bar{x} \\mathtt: \\bar{y} \\mid y = a\\,x + b \\}$$</p>\n\n<p>Is $L$ regular? context-free?</p>\n\n<p>(Contrast with <a href="http://cs.stackexchange.com/questions/640/language-of-the-multiples-of-an-integer">Language of the values of an affine function</a>)</p>\n\n<p><sub>(Follows on <a href="http://cs.stackexchange.com/questions/618/how-can-solutions-of-a-diophantine-equation-be-expressed-as-a-language">How can solutions of a Diophantine equation be expressed as a language?</a>)</sub></p>\n\n<p><sub> I think this would make a good homework question, so answers that start with a hint or two and explain not just how to solve the question but also how to decide what techniques to use would be appreciated. </sub></p>\n', 'ViewCount': '158', 'Title': 'Language of the graph of an affine function', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-22T19:27:05.530', 'LastEditDate': '2012-03-22T15:52:06.720', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '667', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<formal-languages><regular-languages><context-free><integers>', 'CreationDate': '2012-03-22T01:55:17.983', 'Id': '641''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '2944', 'Title': 'Are Turing machines more powerful than pushdown automata?', 'LastEditDate': '2012-03-25T15:41:43.987', 'AnswerCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': "<p>I've came up with a result while reading some automata books, that Turing machines appear to be more powerful than pushdown automata. Since the tape of a Turing machine can always be made to behave like a stack, it'd seem that we can actually claim that TMs are more powerful. </p>\n\n<p>Is this true?</p>\n", 'Tags': '<formal-languages><computability><automata><turing-machines><pushdown-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-16T18:31:50.493', 'CommentCount': '4', 'AcceptedAnswerId': '670', 'CreationDate': '2012-03-22T20:00:29.897', 'Id': '669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '658', 'Title': 'How to convert an NFA with overlapping cycles into a regular expression?', 'LastEditDate': '2014-01-25T16:51:44.933', 'AnswerCount': '3', 'Score': '10', 'OwnerDisplayName': 'zell', 'PostTypeId': '1', 'OwnerUserId': '694', 'Body': '<p>If I understand correctly, NFA have the same expressive power as regular expressions. Often, reading off equivalent regular expressions from NFA is easy: you translate cycles to stars, junctions as alternatives and so on. But what to do in this case: </p>\n\n<p><img src="http://i.stack.imgur.com/yCGnv.png" alt="enter image description here"><br>\n<sup>[<a href="https://github.com/akerbos/sesketches/blob/gh-pages/src/cs_689.tikz" rel="nofollow">source</a>]</sup></p>\n\n<p>The overlapping cycles make it hard to see what this automaton accepts (in terms of regular expressions). Is there a trick?</p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:51:44.933', 'CommentCount': '7', 'AcceptedAnswerId': '692', 'CreationDate': '2012-03-23T07:35:51.517', 'Id': '689''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Note that by "two-way pushdown automaton", I mean a pushdown automaton that can move its reading head both ways on the input tape.</p>\n\n<p>I recently had the question of determining the computational power of two-way PDAs in the Chomsky hierarchy. I don\'t entirely understand two-way PDAs, but I can see how with the ability to read in both directions on the input, it could handle languages of the form $L=\\{0^n 1^n 2^n\\}$. I can\'t say that for sure, but it seems that would make it powerful enough to least handle context-sensitive languages. </p>\n\n<p>This is all a guess because I don\'t know exactly how they work. Can someone explain the process of how a two-way PDA operates, maybe even on my example?</p>\n\n<p>UPDATE: </p>\n\n<blockquote>\n  <p>The model is a generalization of a pushdown automaton in that two-way motion is allowed on the input tape which is assumed to have endmarkers. </p>\n</blockquote>\n', 'ViewCount': '1078', 'Title': 'How does a two-way pushdown automaton work?', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-02T15:40:37.177', 'LastEditDate': '2012-04-02T15:40:37.177', 'AnswerCount': '1', 'CommentCount': '12', 'AcceptedAnswerId': '705', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><computability><automata><pushdown-automata>', 'CreationDate': '2012-03-23T15:39:20.283', 'Id': '699''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G$ be a context-free grammar. A string of terminals and nonterminals of $G$ is said to be a <em>sentential form</em> of $G$ if you can obtain it by applying productions of $G$ zero or more times to the start symbol of $S$. Let $\\operatorname{SF}(G)$ be the set of sentential forms of $G$.</p>\n\n<p>Let $\\alpha \\in \\operatorname{SF}(G)$ and let $\\beta$ be a substring of $\\alpha$ - we call $\\beta$ a <em>fragment</em> of $\\operatorname{SF}(G)$. Now let </p>\n\n<p>$\\operatorname{Before}(\\beta) = \\{ \\gamma \\ |\\ \\exists \\delta . \\gamma \\beta \\delta \\in \\operatorname{SF}(G) \\}$ </p>\n\n<p>and </p>\n\n<p>$\\operatorname{After}(\\beta) = \\{ \\delta \\ |\\ \\exists \\gamma . \\gamma \\beta \\delta \\in \\operatorname{SF}(G) \\}$.</p>\n\n<blockquote>\n  <p>Are $\\operatorname{Before}(\\beta)$ and $\\operatorname{After}(\\beta)$ context-free languages? What if $G$ is unambiguous? If $G$ is unambiguous, are $\\operatorname{Before}(\\beta)$ and $\\operatorname{After}(\\beta)$ also describable by an unambiguous context-free language?</p>\n</blockquote>\n\n<p>This is a followup to <a href="http://cs.stackexchange.com/questions/666/is-there-a-string-stack-data-structure-that-supports-these-string-operations">my earlier question</a>, after <a href="http://cs.stackexchange.com/questions/757/does-every-large-enough-string-have-repeats">an earlier attempt</a> to make my question easier to answer failed. A negative answer will make the encompassing question I\'m working on very hard to answer.</p>\n', 'ViewCount': '305', 'Title': 'Are the Before and After sets for context-free grammars always context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:53:00.780', 'LastEditDate': '2014-01-25T16:53:00.780', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '804', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties>', 'CreationDate': '2012-03-26T17:48:12.210', 'Id': '802''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '388', 'Title': 'Are there other ways to describe formal languages other than grammars?', 'LastEditDate': '2012-03-27T12:11:18.230', 'AnswerCount': '4', 'Score': '15', 'OwnerDisplayName': 'mtanti', 'PostTypeId': '1', 'OwnerUserId': '832', 'FavoriteCount': '2', 'Body': "<p>I'm looking for mathematical theories that deal with describing formal languages (set of strings) in general and not just grammar hierarchies.</p>\n", 'Tags': '<formal-languages><formal-grammars>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-27T13:25:40.327', 'CommentCount': '1', 'AcceptedAnswerId': '821', 'CreationDate': '2012-03-26T19:23:50.510', 'Id': '813''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have asked a series of questions concerning capabilities of a certain class of exotic automata which I have called <em>min-heap automata</em>; the original question, and links to others, can be found <a href="http://cs.stackexchange.com/q/110/69">here</a>.</p>\n\n<p>This question concerns the computational power of type-2 min-heap automata, which were suggested by Raphael as a more natural kind of computing device. The class of languages which can be accepted by such automata is a proper superset of the set of context-free languages; which leads me to my question.</p>\n\n<blockquote>\n  <p>Is $HAL_2$ (the set of languages accepted by nondeterministic type-2 min-heap automata) a proper subset of $CSL$ (the set of context-sensitive languages), or not? Note that it is already known (shown by Raphael in the linked question) that there are $CSL$ languages not in in $HAL_2$.</p>\n</blockquote>\n\n<p>This is one of the last questions I intend to ask about these automata. If a good answer can be found to these (and other) questions, my curiosity will be completely satisfied. Thanks in advance and for all the hard work so far.</p>\n', 'ViewCount': '59', 'Title': 'Computational power of nondeterministic type-2 min-heap automata', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-01T13:42:32.693', 'LastEditDate': '2012-04-01T13:42:32.693', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-04-01T04:01:58.047', 'FavoriteCount': '1', 'Id': '933''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have asked a series of questions concerning capabilities of a certain class of exotic automata which I have called <em>min-heap automata</em>; the original question, and links to others, can be found <a href="http://cs.stackexchange.com/q/110/69">here</a>.</p>\n\n<p>This question concerns the power of type-1 min-heap automata, which represent my initial idea for how these machines would operate. The class of languages which can be accepted by such automata is incomparable (i.e., neither a proper subset nor a proper superset) of the set of context-free languages.</p>\n\n<p>Push down automata, which possess a single stack for data storage, accept the set of context-free languages, in the same way that min-heap automata, which possess a single heap for data storage, accept the set $HAL_1$ of languages accepted by nondeterministic type-1 min-heap automata. Push-down automata with two stacks are equivalent to Turing machines in computational power; they can simulate Turing machines, and vice versa; which leads me to my question:</p>\n\n<blockquote>\n  <p>Does adding another heap to non-deterministic type-1 min-heap automata make them equivalent in terms of computing ability to Turing machines, in the sense that they are able to simulate Turing machines? If not, does it increase their computational power at all, in the sense that nondeterministic type-1 min-heap automata can accept a set of languages which is a proper subset of $HAL_1$? If so, does adding additional heaps increase computational power, i.e., can nondeterministic min-heap automata with $k+1$ heaps accept more languages than automata with $k$ heaps, for any $k$? </p>\n</blockquote>\n\n<p>This is one of the last questions I plan to ask about these automata; if good answers can be had for these (and other) questions, my curiosity will be completely satisfied. Thanks in advance and for all the hard work so far.</p>\n', 'ViewCount': '108', 'Title': 'Computational power of nondeterministic type-1 min-heap automata with multiple heaps', 'LastActivityDate': '2012-12-02T00:05:45.090', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '941', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-04-01T04:04:37.637', 'FavoriteCount': '1', 'Id': '934''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have asked a series of questions concerning capabilities of a certain class of exotic automata which I have called min-heap automata; the original question, and links to others, can be found <a href="http://cs.stackexchange.com/q/110/69">here</a>.</p>\n\n<p>Two of my last questions seem to have been quickly dispatched; one completely, and the other mostly (I have edited it to make it more viable). In either event, I actually had one other question I meant to ask, and would be interested to lay this subject to rest for good and all. So here it is:</p>\n\n<blockquote>\n  <p>A two-stack PDA can simulate a Turing machine. A $k$-heap nondeterministic type-1 min-heap automaton cannot (it seems; see the linked question). What about a $k$-tape nondeterministic type-1 min-heap automaton augmented with a stack (similar to that of a PDA)? Can it simulate a Turing machine? If not, does an augmented $(k+1)$-heap nondeterministic type-1 min-heap automaton accept a class of languages which is a proper superset of languages accepted by augmented automata with only $k$ heaps?</p>\n</blockquote>\n\n<p>Thanks, and I promise this is the last of these questions.</p>\n', 'ViewCount': '91', 'Title': 'Power of nondeterministic type-1 min-heap automaton with both a heap and a stack', 'LastActivityDate': '2012-04-01T14:04:34.520', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-04-01T14:04:34.520', 'Id': '944''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is it true that the set $\\{ 0^{n^2} \\mid n \\in\\mathbb{N} \\}$ is not regular because it does not grow linearly?</p>\n\n<blockquote>\n  <p>Regular sets are called regular because if you have a regular set then you can always pump it up (pumping lemma) in regular intervals and get other things in the set. They string out at very linear intervals. That's why anything that grows in other than linear intervals is not regular.</p>\n</blockquote>\n\n<p>Therefore, $\\{ a^{n^2} b^n \\mid n \\in\\mathbb{N} \\}$ is not regular, right? Also, I know that $\\{ a^n b^n \\mid n \\in\\mathbb{N} \\}$ is not regular, but what about $\\{ a^{cn} b^{dn} \\mid n \\in\\mathbb{N} \\}$ for any integer coefficients $c$ and $d$?</p>\n", 'ViewCount': '91', 'Title': 'Regular sets have linear growth?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-04-03T18:03:34.037', 'LastEditDate': '2012-04-03T18:00:52.383', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '922', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-04-03T17:38:06.640', 'Id': '1006''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to figure out the simplest way to do this using a regular expression. </p>\n\n<ul>\n<li>Three symbols a, b, c.</li>\n<li>The sequence length is unlimited, i.e. *.</li>\n<li>The symbol a must be somewhere in the sequence at least once, but can appear more than once. </li>\n<li>The sequence may have only a.</li>\n</ul>\n\n<p>More formally, $\\{ w \\in \\{a,b,c\\}^* ~|~ \\#_a(w)\\ge 1 \\}$, where $\\#_a(w)$ is the number\nof $a$s in $w$. </p>\n\n<p>The best I get is</p>\n\n<blockquote>\n  <p>$( ( b \\mid c )^*\\, a\\, ( b \\mid c )^* )^+$</p>\n</blockquote>\n\n<p>Is that the simplest way?</p>\n', 'ViewCount': '89', 'Title': 'Regular Expression for the language that requires one symbol to occur at least once', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-04T17:42:46.137', 'LastEditDate': '2012-04-04T17:41:14.063', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1019', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2012-04-04T01:44:05.020', 'Id': '1017''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to use pumping lemma to prove that $L = \\{(01)^m 2^m \\mid m \\ge0\\}$ is not regular.</p>\n\n<p>This is what I have so far: Assume $L$ is regular and let $p$ be the pumping length, so $w = (01)^p 2^p$. Consider any pumping decomposition $w = xyz$ such that  $|y| &gt;0$ and $|xy| \\le p$.</p>\n\n<p>I'm not sure what to do next.</p>\n\n<p>Am I on the right track? Or am I way off?</p>\n", 'ViewCount': '1479', 'Title': 'Using Pumping Lemma to prove language is not regular', 'LastEditorUserId': '31', 'LastActivityDate': '2012-04-04T15:06:30.917', 'LastEditDate': '2012-04-04T09:40:24.787', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '934', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-04-04T06:45:22.807', 'FavoriteCount': '1', 'Id': '1027''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '11911', 'Title': 'How to prove that a language is not regular?', 'LastEditDate': '2013-06-06T13:54:20.203', 'AnswerCount': '5', 'Score': '26', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '21', 'Body': '<p>We learned about the class of regular languages $\\mathrm{REG}$. It is characterised by any one concept among regular expressions, finite automata and left-linear grammars, so it is easy to show that a given language is regular.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for all regular expressions (or for all finite automata, or for all left-linear grammars) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n\n<p><em><sup>This is intended to be a reference question collecting usual proof methods and application examples. See <a href="http://cs.stackexchange.com/q/265/98">here</a> for the same question on context-free languages.</sup></em></p>\n', 'Tags': '<formal-languages><regular-languages><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-07-01T12:50:16.730', 'CommentCount': '4', 'AcceptedAnswerId': '1033', 'CreationDate': '2012-04-04T10:30:32.163', 'Id': '1031''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '399', 'Title': 'Number of words in the regular language $(00)^*$', 'LastEditDate': '2012-04-04T20:15:01.173', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '92', 'FavoriteCount': '2', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Regular_language#The_number_of_words_in_a_regular_language">According to Wikipedia</a>, for any regular language $L$ there exist constants $\\lambda_1,\\ldots,\\lambda_k$ and polynomials $p_1(x),\\ldots,p_k(x)$ such that for every $n$ the number $s_L(n)$ of words of length $n$ in $L$ satisfies the equation </p>\n\n<p>$\\qquad \\displaystyle s_L(n)=p_1(n)\\lambda_1^n+\\dots+p_k(n)\\lambda_k^n$.</p>\n\n<p>The language $L =\\{ 0^{2n} \\mid n \\in\\mathbb{N} \\}$ is regular ($(00)^*$ matches it). $s_L(n) = 1$ iff n is even, and $s_L(n) = 0$ otherwise.</p>\n\n<p>However, I can not find the $\\lambda_i$ and $p_i$ (that have to exist by the above). As $s_L(n)$ has to be differentiable and is not constant, it must somehow behave like a wave, and I can\'t see how you can possibly do that with polynomials and exponential functions without ending up with an infinite number of summands like in a Taylor expansion. Can anyone enlighten me?</p>\n', 'Tags': '<formal-languages><regular-languages><combinatorics><word-combinatorics>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-04-15T14:41:18.683', 'CommentCount': '3', 'AcceptedAnswerId': '1040', 'CreationDate': '2012-04-04T15:53:43.390', 'Id': '1039''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '428', 'Title': 'Number of words of a given length in a regular language', 'LastEditDate': '2012-04-05T02:09:41.130', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Is there an algebraic characterization of the number of words of a given length in a regular language?</p>\n\n<p><a href="http://en.wikipedia.org/wiki/Regular_language#The_number_of_words_in_a_regular_language">Wikipedia</a> states a result somewhat imprecisely:</p>\n\n<blockquote>\n  <p>For any regular language $L$ there exist constants $\\lambda_1,\\,\\ldots,\\,\\lambda_k$ and polynomials $p_1(x),\\,\\ldots,\\,p_k(x)$\n  such that for every $n$ the number $s_L(n)$ of words of length $n$ in $L$ satisfies the equation\n  $s_L(n)=p_1(n)\\lambda_1^n+\\dotsb+p_k(n)\\lambda_k^n$.</p>\n</blockquote>\n\n<p>It\'s not stated what space the $\\lambda$\'s live in ($\\mathbb{C}$, I presume) and whether the function is required to have nonnegative integer values over all of $\\mathbb{N}$. I would like a precise statement, and a sketch or reference for the proof.</p>\n\n<p>Bonus question: is the converse true, i.e. given a function of this form, is there always a regular language whose number of words per length is equal to this function?</p>\n\n<p><sub> This question generalizes <a href="http://cs.stackexchange.com/questions/1039/question-about-the-number-of-words-in-a-regular-language">Question about the number of words in a regular language</a> </sub>  </p>\n', 'Tags': '<formal-languages><regular-languages><word-combinatorics>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-09-22T06:53:52.867', 'CommentCount': '7', 'AcceptedAnswerId': '14481', 'CreationDate': '2012-04-04T20:13:16.497', 'Id': '1045''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/640/language-of-the-values-of-an-affine-function">Language of the values of an affine function</a>  </p>\n</blockquote>\n\n\n\n<p>Let $C_n = \\{x\\mid x \\text{ is a binary number that is a multiple of } n\\}$. Show that for each $n$, the language $C_n$ is regular.</p>\n\n<p>Just provide a generic recipe (i.e., a formal definition for arbitrary $n$).</p>\n', 'ViewCount': '96', 'ClosedDate': '2012-04-05T14:34:36.797', 'Title': 'Multiples of n is a regular language', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-05T03:20:45.850', 'LastEditDate': '2012-04-05T03:20:45.850', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'user8978', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-04-05T02:59:27.360', 'Id': '1050''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to count the number of strings $s$ over a finite alphabet $A$, that contain no repeats, and by that I mean for any substring $t$ of $s$, $1&lt; |t| &lt; |s|$, there is no disjoint copy of $t$ in $s$.  For exapmle, let $A=\\{a,b\\}$.  Then $aaa$ <em>is</em> one of the strings I want to count, since for the substring $aa$, there are no disjoint copies.  However, $abab$ contains such a repeat.</p>\n\n<p>If someone's already figured out a useful formula, please link.  Otherwise, I will refer back to this post in any article I write, if I use someone's answer.</p>\n\n<p>Here is another example.  Let's try to construct a long string over $\\{a,b\\}$, that contains no repeats:</p>\n\n<p>aaa (can't be a)  <br>\n&nbsp;&nbsp; aaab (a or b)  <br>\n&nbsp;&nbsp;&nbsp;&nbsp; aaabbb (can't be b) <br>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aaabbba (can't be b or a) <br>\n&nbsp;&nbsp; aaaba (can't be a or b)  <br></p>\n\n<p>If we built a tree, we could count the number of nodes, but I want a formula.</p>\n\n<p><strong>Edit:</strong>\nWell, it's not as daunting as I first thought if we convert this to a bin-choosing problem.  A set of strings of length k with at least one repeat is equal to the set that is the union of all permutations of the cartesian product:\n$A \\times A \\times \\cdots\\times A \\text{(k-4 times)} \\times R \\times R$ where $R$ is the required repeat.  I don't know if that's helpful, but it sounded pro :)  Anyway, let their be |A| bins, choose any two (even if the same one) to be the repeat, then choose $k-4$ more and multiply (the first 4 are already chosen, see?).  Now I just need to find that formula from discrete math.</p>\n", 'ViewCount': '172', 'Title': 'What is a formula for the number of strings with no repeats?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-19T15:45:22.733', 'LastEditDate': '2012-04-18T05:46:10.587', 'AnswerCount': '1', 'CommentCount': '17', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1118', 'Tags': '<formal-languages><combinatorics><strings><word-combinatorics>', 'CreationDate': '2012-04-17T01:49:50.663', 'Id': '1315''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '535', 'Title': 'How to prove regular languages are closed under left quotient?', 'LastEditDate': '2012-04-18T05:56:10.247', 'AnswerCount': '1', 'Score': '8', 'OwnerDisplayName': 'corium', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '1', 'Body': '<p>L is a regular language over the alphabet $\\sum = \\{a,b\\}$. The left quotient of L regarding $w \\in \\sum^*$ is the language \n$$w^{-1} L := \\{v: wv \\in L\\}$$</p>\n\n<p>How can I prove that $w^{-1}$ L is regular?</p>\n', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T05:56:10.247', 'CommentCount': '0', 'AcceptedAnswerId': '1327', 'CreationDate': '2012-04-17T20:58:50.560', 'Id': '1326''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '6747', 'Title': 'How to prove a language is regular?', 'LastEditDate': '2013-06-06T13:56:25.667', 'AnswerCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '4', 'Body': '<p>There are many methods to prove that <a href="http://cs.stackexchange.com/q/1031/157">a language is not regular</a>, but what do I need to do to prove that some language <em>is</em> regular?</p>\n\n<p>For instance, if I am given that $L$ is regular, \nhow can I prove that the following $L&#39;$ is regular, too?</p>\n\n<p>$\\qquad \\displaystyle L&#39; := \\{w \\in L: uv = w \\text{ for } u \\in \\Sigma^* \\setminus L \\text{ and } v \\in \\Sigma^+ \\}$</p>\n\n<p>Can I draw a nondeterministic finite automaton to prove this?</p>\n', 'Tags': '<formal-languages><regular-languages><automata><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-09-20T17:34:26.467', 'CommentCount': '4', 'AcceptedAnswerId': '1333', 'CreationDate': '2012-04-18T05:21:31.750', 'Id': '1331''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In my computability class we were given a practice final to go over and I'm really struggling with one of the questions on it.</p>\n\n<blockquote>\n  <p>Prove the following statement:</p>\n  \n  <p>If $L_1$ is a regular language, then so is</p>\n  \n  <p>$L_2 = \\{ uv |$ $u$ is in $L_1$ or $v$ is in $L_1 \\}$.</p>\n</blockquote>\n\n<p>You can't use the pumping lemma for regular languages (I think), so how would you go about this? I'm inclined to believe that it's false because if $u$ is in $L_1$, what if $v$ is non-regular? Then it would be impossible to write a regular expression for it. The question is out of 5 marks though and that doesn't seem like enough of an answer for it.</p>\n", 'ViewCount': '301', 'Title': 'Proving a specific language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T12:07:26.237', 'LastEditDate': '2012-04-22T12:07:26.237', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'user1217222', 'PostTypeId': '1', 'OwnerUserId': '16846', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-04-21T16:17:21.963', 'Id': '1414''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So I have a problem that I\'m looking over for an exam that is coming up in my Theory of Computation class.  I\'ve had a lot of problems with the <em>pumping lemma</em>, so I was wondering if I might be able to get a comment on what I believe is a valid proof to this problem.  From what I have seen online and in our review I don\'t think this is the customary answer to this problem so I want to know if I am applying the concepts behind the pumping lemma successfully.  The problem is <em>not</em> a homework problem and can be found on my professor\'s previous exams <a href="http://www.cs.ucf.edu/~dmarino/ucf/transparency/cot4210/exam/" rel="nofollow">here</a> under the fourth problem of his exam given in Fall of 2011, which is...</p>\n\n<blockquote>\n  <p>Let $L = \\{0^p \\mid \\text{\\(p\\) is a prime number}\\}$. Prove that $L$ is not context-free using the pumping lemma for context-free languages.</p>\n</blockquote>\n\n<p>So here is my proof:</p>\n\n<blockquote>\n  <p>Assume that the pumping length is $m$, where $m+1$ is a prime number.  I shall also assume that there is a string $uvxyz = 0^{(m/2)}00^{m/2} \\in L$.  There are two possible positions that do not violate conditions 2 and  3 of the pumping lemma for context languages, being $|vy| &gt; 0$ and $|vxy| \\leq m$.  These are:</p>\n  \n  <ol>\n  <li><p>$u = 0^{(m/2)}, v = 0, x = 0^{m/2}$, pumping by one results in $0^{m/2}000^{m/2}$.  Since m/2 + m/2 is m, which is one less than the prime number m+1, it is an even number.  m+2 is also an even number and since $|0^{m/2}000^{m/2}| = m + 2$, this number of zeroes is also even and thus cannot be prime, resulting in a contradiction.  </p></li>\n  <li><p>The other placement is to place the string on the symmetric opposite or $x = 0^{m/2}, y = 0, z = 0^{m/2}$.  This results in the same contraction as in case 1.</p></li>\n  </ol>\n</blockquote>\n\n<p>The string cannot be placed in the center such that $v = 0^{m/2}, x = 0, y = 0^{m/2}$ as this would violate condition three or $|vxy| \\leq m$, since $|vxy| = m + 1 &gt; m$.</p>\n\n<p>So my question is essentially, is this a valid proof and if not what is wrong with it?</p>\n', 'ViewCount': '744', 'Title': 'Prime number CFG and Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T21:46:05.933', 'LastEditDate': '2012-04-22T21:46:05.933', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><proof-techniques><context-free><pumping-lemma>', 'CreationDate': '2012-04-22T20:31:51.403', 'FavoriteCount': '2', 'Id': '1450''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '597', 'Title': 'Words that have the same right- and left-associative product', 'LastEditDate': '2012-04-24T06:17:40.090', 'AnswerCount': '4', 'Score': '7', 'OwnerDisplayName': 'Ismael Mezquino', 'PostTypeId': '1', 'OwnerUserId': '1217', 'FavoriteCount': '1', 'Body': '<p>I have started to study non deterministic automata using the book of <a href="https://en.wikipedia.org/wiki/Introduction_to_Automata_Theory,_Languages,_and_Computation" rel="nofollow">Hopcroft and Ullman</a>. I\'m stuck in a problem that I found very interesting:</p>\n\n<blockquote>\n  <p>Give a non deterministic finite automaton accepting all the strings that\n  have the same value when evaluated left to right as right to left by\n  multiplying according to the following table:</p>\n  \n  <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \r\n    \\times &amp; a &amp; b &amp; c \\\\\r\n    \\hline \r\n    a &amp; a &amp; a &amp; c \\\\\r\n    b &amp; c &amp; a &amp; b \\\\\r\n    c &amp; b &amp; c &amp;a\r\n   \\end{array}$</p>\n</blockquote>\n\n<p>So if we have the string $abc$,<br>\nthe product from left to right is $(a \\times b) \\times c=a \\times c=c$ and<br>\nthe product from right to left is $a \\times (b \\times c)=a \\times b=a$</p>\n\n<p>So $abc$ should not be acceptable for the automata. To me its obvious that any string $aa^*$ or $bb^*$ or $cc^*$ is an aceptable string (their right and left evaluation work on the same partial strings). It is easy to give an NFA that describes the left to right evaluation but the problem is that if the machine try to compute the <em>right to left</em> evaluation I think it needs to know the length of the string (so infinite memory is necessary).</p>\n\n<p>So how can a non deterministic automata evaluate from right to left in order to compare with the left to right evaluation?</p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-25T17:11:22.873', 'CommentCount': '0', 'AcceptedAnswerId': '1479', 'CreationDate': '2012-04-23T18:12:11.180', 'Id': '1467''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>So I'm really struggling with the pumping lemma.  I think most of my problems come from not understanding how you can and can't split the string in a pumping lemma question.  Here is an example, take the problem prove that $L = \\{w | w$ contains more $0$'s than $1$'s over the language $\\{0,1\\} \\}$ is not regular via the pumping lemma.</p>\n\n<p>So I choose the string $01^{p}0^{p}$.  Since this is a regular language pumping lemma problem I know that: </p>\n\n<ol>\n<li>for each $i &gt; 0, xy^{i}z \\in A$,</li>\n<li>$|y^{i}| &gt; 0$, and</li>\n<li>$|xy| &lt; p$</li>\n</ol>\n\n<p>I am little uncertain about other possibilites though, such as if $x$, or $z$ can be null (obviously $y$ can't by condition 2).  I assume that this isn't possible since I don't think the preceding or trailing whitespace is considered part of the string, but I'm not sure.  <strong>Is it possible for $x$ or $z$ to be null?</strong></p>\n", 'ViewCount': '122', 'Title': 'Null Characters and Splitting the String in the Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-23T22:21:55.283', 'LastEditDate': '2012-04-23T22:21:55.283', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1470', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><regular-languages><proof-techniques><pumping-lemma>', 'CreationDate': '2012-04-23T19:29:10.360', 'Id': '1469''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Here's a conjecture for regular expressions:</p>\n\n<blockquote>\n  <p>For regular expression $R$, let the length $|R|$ be the number of symbols in it,\n  ignoring parentheses and operators. E.g. $|0 \\cup 1| = |(0 \\cup 1)^*| = 2$</p>\n  \n  <p><strong>Conjecture:</strong> If $|R| &gt; 1$ and $L(R)$ contains every string of length $|R|$ or less, then $L(R) = \\Sigma^*$.</p>\n</blockquote>\n\n<p>That is, if $L(R)$ is 'dense' up to $R$'s length, then $R$ actually generates everything.</p>\n\n<p>Some things that may be relevant:</p>\n\n<ol>\n<li>Only a small part of $R$ is needed to generate all strings. For example in binary, $R = (0 \\cup 1)^* \\cup S$ will work for any $S$.</li>\n<li>There needs to be a Kleene star in $R$ at some point. If there isn't, it will miss some string of size less than $|R|$. </li>\n</ol>\n\n<p>It would be nice to see a proof or counterexample. Is there some case where it's obviously wrong that I missed? Has anyone seen this (or something similar) before?  </p>\n", 'ViewCount': '296', 'Title': '"Dense" regular expressions generate $\\Sigma^*$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-19T21:45:29.463', 'LastEditDate': '2012-04-26T06:49:15.443', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1512', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '1245', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-04-26T04:17:35.663', 'Id': '1511''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'd love your help with the following question:</p>\n\n<blockquote>\n  <p>Let $G$ be context free grammar in the <strong>Chomksy normal form</strong> with $k$\n  variables.</p>\n  \n  <p>Is the language $B = \\{ w \\in L(G) : |w| &gt;2^k \\}$ regular ?</p>\n</blockquote>\n\n<p>What is it about the amount of variables and the Chomsky normal form that is supposed to help me solve this question? I tried to look it up on the web, but besides information about the special form itself, I didn't find an answer to my question.</p>\n\n<p>The answer for the question is that $B$ might be regular.</p>\n", 'ViewCount': '275', 'Title': 'Chomsky normal form and regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-27T15:37:47.150', 'LastEditDate': '2012-04-27T15:37:47.150', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1532', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'CreationDate': '2012-04-27T12:13:32.993', 'Id': '1525''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I would like your help with the following question:</p>\n\n<blockquote>\n  <p>Let $L$ be a language, and operator $A(L)=\\{\\,ww^Rw \\mid w \\in L\\ \\wedge\\ |w| \\lt 2007\\,\\}$ where $x^R$ is the  reversed string of $x$. Which of the\n  following statements are correct?</p>\n  \n  <ol>\n  <li>If $L$ is regular so $A(L)$ is regular.</li>\n  <li>If $L$ is a CFL which is not regular then $A(L)$ is CFL which is not regular.</li>\n  <li>If $L$ is a CFL which is not regular, then $A(L)$ is a CFL which may or may not be regular.</li>\n  <li>If $L$ is not a CFL then $A(L)$ is not CFL.</li>\n  </ol>\n</blockquote>\n\n<p>What does the fact that $|w|&lt; 2007$ help me with the decision? \nFor (2) I can choose $O^n1^n$ and I get that $0^n1^{2n}0^{2n}1^n$, which is not regular, but for (3),(4) I can't find an examples to refute it. The answer is 3, but I can't understand why, since $A(L)= ww^R \\circ  w$  but $ww^R$ is not regular.</p>\n", 'ViewCount': '180', 'Title': 'Closure against the operator $A(L)=\\{ww^Rw \\mid w \\in L \\wedge |w| \\lt 2007\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-28T09:52:19.380', 'LastEditDate': '2012-04-28T09:52:19.380', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1537', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2012-04-27T18:59:52.513', 'Id': '1536''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'd really love your help with the following:</p>\n\n<p>For <em>any</em> fixed $L_2$ I need to decide whether there is closure under the following operators:</p>\n\n<ol>\n<li><p>$A_r(L)=\\{x \\mid \\exists  y \\in L_2 : xy \\in L\\}$</p></li>\n<li><p>$A_l(L)=\\{x \\mid \\exists  y \\in L : xy \\in L_2\\}$.</p></li>\n</ol>\n\n<p>The relevant options are:</p>\n\n<ol>\n<li><p>Regular languages are closed under $A_l$ resp. $A_r$, for any language $L_2$ </p></li>\n<li><p>For some languages $L_2$, regular languages are closed under $A_l$ resp. $A_r$, and for some languages $L_2$, regular languages are not closed under $A_l$ resp. $A_r$.</p></li>\n</ol>\n\n<p>I believed that the answer for (1) should be (2), because when I get a word in $w \\in L$ and $w=xy$ I can build an automaton that can guess where $x$ turning to $y$, but then it needs to verify that $y$ belongs to $L_2$ and if it won't be regular, how would it do that?<br>\nThe answer for that is (1).</p>\n\n<p>What should I do in order to analyze those operators correctly and to determine if the regular languages are closed under them or not?</p>\n", 'ViewCount': '517', 'Title': 'Closure against right quotient with a fixed language', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-29T11:50:36.987', 'LastEditDate': '2012-04-29T11:50:36.987', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1554', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-04-28T10:33:42.823', 'Id': '1547''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Do there exist undecidable languages such that their union/intersection/concatenated language is decidable? What is the physical interpretation of such example because in general, undecidable languages are not closed under these operations?</p>\n\n<p>What can we say about the kleene closure? Do we have examples for it too?  I.e. can the closure of an undecidable language be decidable?</p>\n\n<p>Also, can we generalize such undecidable classes?</p>\n', 'ViewCount': '834', 'LastEditorDisplayName': 'user1291', 'Title': "operations that aren't closed for undecidable languages", 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T08:52:26.420', 'LastEditDate': '2012-05-09T08:52:26.420', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'OwnerDisplayName': 'user1284', 'PostTypeId': '1', 'Tags': '<formal-languages><undecidability><closure-properties>', 'CreationDate': '2012-04-28T11:50:33.113', 'Id': '1549''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I wonder whether the following language is a context free language:\n$$A = \\{w \\in \\{a,b,c\\}^* \\mid \\#_a(w) + 2\\#_b(w) = 3\\#c(w)\\}$$\nwhere $\\#_x(w)$ is the number of occurrences of $x$ in $w$.\nI can't find any word that would be useful to refute by the pumping lemma, on the other hand I haven't been able to find a context free grammar generating it. It looks like it has to remember more than one PDA can handle.</p>\n\n<p>What do you say?</p>\n", 'ViewCount': '194', 'Title': 'Is $A=\\{ w \\in \\{a,b,c\\}^* \\mid \\#_a(w)+ 2\\#_b(w) = 3\\#_c(w)\\}$ a CFG?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-04-30T02:27:53.983', 'LastEditDate': '2012-04-29T00:10:24.487', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '1557', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2012-04-28T20:50:19.557', 'Id': '1556''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can I prove that the language that the operator $A$ defines for regular language $L$ is a context free language.</p>\n\n<p>$A(L)= \\{ w_1w_2: |w_1|=|w_2|$ and $w_1, w_2^R \\in L \\}$, where $x^R$ is the reversed form of $x$. </p>\n\n<p>I understand that since $L$ is regular so does $L^R$.also on my way for a CFG I can reach $w_1$ by the CFG of $L$ concatenation with the one of $L^R$ for making $w_2$. so far I have a CFG, but what promises me that $|w_1|=|w_2|$? how can I generate a grammar that will also keep that in addition to the other conditions?</p>\n', 'ViewCount': '253', 'Title': 'Why does $A(L)= \\{ w_1w_2: |w_1|=|w_2|$ and $w_1, w_2^R \\in L \\}$ generate a context free language for regular $L$?', 'LastEditorUserId': '1183', 'LastActivityDate': '2012-05-03T07:50:41.343', 'LastEditDate': '2012-05-01T08:07:29.893', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '1593', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'CreationDate': '2012-04-30T16:31:10.080', 'Id': '1592''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I read <a href="http://cs.stackexchange.com/questions/1027/using-pumping-lemma-to-prove-language-is-not-regular">on the site</a> on how to use the pumping lemma but still I don\'t what is wrong with way I\'m using it for proving that the following language is not a regular language:</p>\n\n<p>$L = \\{a^ib^jc^k \\mid \\text{if } i=1 \\text{ then } j=k \\}$</p>\n\n<p>for $i\\neq1$ the language is obviously regular but in the case which $i=1$ , we get that the language is $a^1b^nc^n$, now for every division $w=xyz$ such that $|y|&gt;0 , |xy|&lt; p$ where p is the pumping constant I get the word $a^1b^pc^p$ would be out of the language. since  $|xy|&lt; p$\n, $y$ may contains only $a&#39;s$ or $b&#39;s$ or both. if $x= \\epsilon$ and $y=a$, pump it once and you\'re out of the language, if it contains only $b&#39;s$, pump it once and your\'e out of the language, and if it contains both, pump it and you\'re out of the language again.</p>\n\n<p>so, why does this language considered as not regular and cannot be proved for its irregularity by the pumping lemma? please point out my mistake.  </p>\n', 'ViewCount': '1107', 'Title': 'Irregularity of $\\{a^ib^jc^k \\mid \\text{if } i=1 \\text{ then } j=k \\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T13:23:03.370', 'LastEditDate': '2012-05-09T13:23:03.370', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '1678', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-05-01T16:26:23.790', 'Id': '1616''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '258', 'Title': 'The operator $A(L)= \\{w \\mid ww \\in L\\}$', 'LastEditDate': '2012-05-04T21:50:54.007', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'FavoriteCount': '1', 'Body': "<p>Consider the operator $A(L)= \\{w \\mid ww \\in L\\}$. Apparently, the class of context free languages is not closed against $A$. Still, after a lot of thinking, I can't find any CFL for which $A(L)$ wouldn't be CFL. </p>\n\n<p>Does anyone have an idea for such a language?</p>\n", 'Tags': '<formal-languages><context-free><closure-properties>', 'LastEditorUserId': '89', 'LastActivityDate': '2012-05-05T12:31:21.947', 'CommentCount': '2', 'AcceptedAnswerId': '1657', 'CreationDate': '2012-05-03T11:55:44.033', 'Id': '1652''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '542', 'Title': 'Please explain this formal definition of computation', 'LastEditDate': '2012-05-05T20:24:28.687', 'AnswerCount': '3', 'Score': '5', 'OwnerDisplayName': 'Stefano Borini', 'PostTypeId': '1', 'OwnerUserId': '1377', 'FavoriteCount': '2', 'Body': "<p>I am trying to attack TAOCP once again, given the sheer literal heaviness of the volumes I have trouble committing to it seriously. In TAOCP 1 Knuth writes, page 8, basic concepts::</p>\n\n<blockquote>\n  <p>Let $A$ be a finite set of letters. Let $A^*$ be the set of all strings in $A$ (the set of all ordered sequences $x_1$ $x_2$ ... $x_n$ where $n \\ge 0$ and $x_j$ is in $A$ for $1 \\le j \\le n$). The idea is to encode the states of the computation so that they are represented by strings of $A^*$ . Now let $N$ be a non-negative integer and Q (the state) be the set of all $(\\sigma, j)$, where $\\sigma$ is in $A^*$ and j is an integer $0 \\le j \\le N$; let $I$ (the input) be the subset of Q with $j=0$ and let $\\Omega$ (the output) be the subset with $j = N$. If $\\theta$ and $\\sigma$ are strings in $A^*$, we say that $\\theta$ occurs in $\\sigma$ if $\\sigma$ has the form $\\alpha \\theta \\omega$ for strings $\\alpha$ and $\\omega$. To complete our definition, let $f$ be a function of the following type, defined by the strings $\\theta_j$, $\\phi_j$ and the integers $a_j$, $b_j$ for $0 \\le j \\le N$:</p>\n  \n  <ul>\n  <li>$f((\\sigma, j)) = (\\sigma, a_j)$ if $\\theta_j$ does not occur in $\\sigma$</li>\n  <li>$f((\\sigma, j)) = (\\alpha \\psi_j \\omega, b_j)$ if $\\alpha$ is the shortest possible string for which $\\sigma = \\alpha \\theta_j \\omega$</li>\n  <li>$f((\\sigma,N)) = (\\sigma, N)$</li>\n  </ul>\n</blockquote>\n\n<p>Not being a computer scientist, I have trouble grasping the whole passage. I kind of get the idea that is behind a system of opcodes, but I haven't progressed effectively in understanding. I think that the main problem is tat I don't know how to read it effectively. </p>\n\n<p>Would it be possible to explain the passage above so that I can understand it, and give me a strategy in order to get in the logic in interpreting these statements?</p>\n", 'Tags': '<formal-languages><turing-machines><computation-models>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-10T13:45:00.413', 'CommentCount': '8', 'CreationDate': '2012-05-04T22:03:23.210', 'Id': '1666''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Consider this example (taken from this document: <a href="http://www.cs.nott.ac.uk/~txa/g51mal/notes-3x.pdf" rel="nofollow">Showing that language is not regular</a>):</p>\n\n<p>$$L = \\{1^n \\mid n\\text{ is even}\\} $$</p>\n\n<p>According to the Pumping Lemma, a language $L$ is regular if :</p>\n\n<ul>\n<li>$y \\ne \u03b5$</li>\n<li>$|xy| \\lt n$</li>\n<li>$\\forall k \\in N, xy^kz \\in L$</li>\n</ul>\n\n<p>In the above example, $n$ must be even. Suppose we have $n = 4$, we can express: $$xy^kz$$ such that: $x = 1$, $z = 1$, and with $k = 2$, we have $y^k = y^2 = 11$, so we get the string $1111$. However, since all $k$ must be satisfied, if $k = 1$, the string is $111$, it does not belong to $L$. Yet, I was told that the above example is a regular language. How can it be?</p>\n', 'ViewCount': '1940', 'Title': 'Why is this example a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T14:46:55.897', 'LastEditDate': '2012-05-10T14:46:55.897', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1707', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<formal-languages><regular-languages><proof-techniques>', 'CreationDate': '2012-05-07T03:45:04.323', 'Id': '1706''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Define $\\mathrm{Prefix}  (L) = \\{x\\mid \\exists y .xy \\in L \\}$. I'd love your help with proving that $\\mathsf{RE}$ languages are closed under $\\mathrm{Prefix}$.</p>\n\n<p>I know that recursively enumerable languages are formal languages for which there exists a Turing machine  that will halt and accept when presented with any string in the language as input, but may either halt and reject or loop forever when presented with a string not in the language.</p>\n\n<p>Any help for how should I approach to this kind of a proof?</p>\n", 'ViewCount': '755', 'Title': 'Proving that recursively enumerable languages are closed against taking prefixes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T09:56:00.747', 'LastEditDate': '2012-05-10T15:21:06.183', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '1732', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><turing-machines><closure-properties>', 'CreationDate': '2012-05-08T15:36:31.447', 'Id': '1731''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Lets $L_z \\ := \\{ a^i b^i c^i : 0 \\leq i &lt; z \\}$</p>\n\n<p>$\\{a,b,c\\} \\in \\sum^*$</p>\n\n<p>there is a DFA with $\\frac{z(z+1)}{2}+1$ states - How can I prove this?</p>\n\n<p>And I need largest possible number $n_z$, for which i can prove that every NFA, which accepts $L_z$, have $n_z$ states, at least!</p>\n\n<p>But first I need to show that $n_z = \\frac{z(z+1)}{2}$\n right?</p>\n', 'ViewCount': '249', 'Title': 'DFA with limited states', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-19T15:56:15.823', 'LastEditDate': '2012-05-08T23:09:26.217', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '1743', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-05-08T22:59:08.823', 'Id': '1740''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '309', 'Title': 'Non-regular Languages?', 'LastEditDate': '2012-05-09T14:33:33.083', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Body': u'<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Why $L_a$ and  $L_b$  are not reguluar?</p>\n\n<p>$L_a = \\{ e^i f^{n-i} g^j h^{n-j} : n \\in N, 1 \\leq i, j \\leq n \\}$. </p>\n\n<p>$L_b= \\{nm^{i_1} nm^{i_2}...bn^{i_z}: z \\in N, (i_1,...,i_n) \\in N^z, 1 \\leq j \\leq z, i_j \u2260 j \\}$.</p>\n', 'ClosedDate': '2012-05-09T19:58:17.077', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-10T02:21:47.107', 'CommentCount': '8', 'AcceptedAnswerId': '1756', 'CreationDate': '2012-05-09T13:39:25.267', 'Id': '1753''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '546', 'Title': "Why is a regular language called 'regular'?", 'LastEditDate': '2012-05-14T15:15:21.780', 'AnswerCount': '2', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '1434', 'FavoriteCount': '3', 'Body': '<p>I have just completed the first chapter of the <a href="http://www-math.mit.edu/~sipser/book.html"><em>Introduction to the Theory of Computation</em></a> by <em>Michael Sipser</em> which explains the basics of finite automata. </p>\n\n<p>He defines a regular language as anything that can be described by a finite automata. But I could not find where he explains why a regular language is called "regular?"  What is the origin of the term "regular" in this context?</p>\n\n<p>NOTE: I am a novice so please try to explain in simple terms!</p>\n', 'Tags': '<formal-languages><regular-languages><terminology><finite-automata><history>', 'LastEditorUserId': '1298', 'LastActivityDate': '2012-05-14T15:15:21.780', 'CommentCount': '1', 'AcceptedAnswerId': '1772', 'CreationDate': '2012-05-10T02:07:18.947', 'Id': '1771''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My answer : (0+1)* 0 (0+1)* 0 (0+1)*</p>\n\n<p>Why is this incorrect? Can somebody explain to me what the correct answer is and why?</p>\n', 'ViewCount': '1105', 'Title': 'Regular expression for all strings with at least two 0s over alphabet {0,1}', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T14:54:41.603', 'LastEditDate': '2012-05-14T14:54:41.603', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '1444', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-05-10T16:38:29.590', 'Id': '1778''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Suppose that $L(M) = L$ where $M$ is a $TM$ that moves only to the right side.</p>\n\n<p>I need to Show that $L$ is regular.</p>\n\n<p>I'd relly like some help, I tried to think of any way to prove it but I didn't reach to any smart conclusion. what is it about the only side right moves and the regularity? </p>\n", 'ViewCount': '216', 'Title': '$L(M) = L$ where $M$ is a $TM$ that moves only to the right side so $L$ is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T14:56:52.800', 'LastEditDate': '2012-05-14T14:56:52.800', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '1784', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><turing-machines>', 'CreationDate': '2012-05-10T20:04:18.130', 'Id': '1779''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m looking for intuition about when a language is regular and when it is not. For example, consider:</p>\n\n<p>$$ L = \\{ 0^n 1^n \\mid n \\geq 1 \\} = \\{ 01, 0011, 000111, \\ldots \\}$$</p>\n\n<p>which is not a regular language. Intuitively it seems a very simple language, there doesn\'t seem to be anything complicated going on. What is the difference between $L$ and a regular language like:</p>\n\n<p>$$L\' = \\{ w \\mid w \\text{ does not contain } 11 \\} = \\{0,10\\}^*\\cdot (1 \\mid \\varepsilon).$$</p>\n\n<p>I know how to <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">prove that $L$ is not regular</a>, using the Pumping Lemma. Here I am looking for <strong>intuition</strong> about what makes a language regular.</p>\n', 'ViewCount': '524', 'Title': 'Why is $L= \\{ 0^n 1^n | n \\geq 1 \\}$ not regular language?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-22T20:37:44.957', 'LastEditDate': '2012-05-22T20:37:44.957', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<formal-languages><regular-languages><intuition>', 'CreationDate': '2012-05-14T02:35:11.657', 'Id': '1830''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There is a problem which I cannot solve. If you give a tip I will be very glad.</p>\n\n<p>Prove that following language is <em>not</em> context free:</p>\n\n<p>$L= \\{ a^nb^m | \\gcd(n,m) = 1 \\}$.</p>\n\n<p>It can be proven using the pumping lemma, but how?</p>\n\n<p>If I start with some prime numbers $m$ and $n$ where $m&gt;n&gt;2$ and pump it up from $uVxYz$, there are three possible outcomes: $a^{n + k} b^m$, $a^{n +k}b^{m +k}$, $a^n b^{m +k}$. Since I do not know whether $k$ is even or odd I cannot say something. It is certain that $a^n$ and $b^m$ will be odd. However after adding $k$ to some of them, how can I say something about whether their gcd is 1 or not?</p>\n', 'ViewCount': '433', 'Title': 'A context free grammar proof', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-15T08:50:48.623', 'LastEditDate': '2012-05-15T08:50:48.623', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1494', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2012-05-14T19:42:42.550', 'Id': '1842''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m am stuck solving the next exercise:</p>\n\n<p>Argue that if $L$ is context-free and $R$ is regular, then $L / R = \\{ w \\mid \\exists x \\in R \\;\\text{s.t}\\; wx \\in L\\} $ (i.e. the <a href="https://en.wikipedia.org/wiki/Right_quotient" rel="nofollow">right quotient</a>) is context-free.</p>\n\n<p>I know that there should exist a PDA that accepts $L$ and a DFA that accepts $R$. I\'m now trying to combine these automata to a PDA that accepts the right quotient. If I can build that I proved that $L/R$ is context-free. But I\'m stuck building this PDA.</p>\n\n<p>This is how far I\'ve made it:   </p>\n\n<blockquote>\n  <p>In the combined PDA the states are a cartesian product of the states of the seperate automata. And the edges are the edges of the DFA but only the ones for which in the future a final state of the original PDA of L can be reached. But don\'t know how to write it down formally.</p>\n</blockquote>\n', 'ViewCount': '637', 'Title': 'If $L$ is context-free and $R$ is regular, then $L / R$ is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-17T23:12:15.793', 'LastEditDate': '2012-05-17T19:38:52.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1526', 'Tags': '<formal-languages><context-free><finite-automata><closure-properties><pushdown-automata>', 'CreationDate': '2012-05-17T16:19:42.050', 'FavoriteCount': '1', 'Id': '1886''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Grammars seem to be used for different purposes.  In formal languages, they are used to describe sequences of symbols.  In programming language theory, they are used to describe objects in a term algebra (possibly enriched with some implicit, extra structure such as variable scoping rules).  My question is, are these two kinds of grammars the <em>same notation reused for unrelated purposes</em>, or are they <em>describing the same things</em>?  If they are unrelated, then do we have nomenclature to distinguish them?</p>\n\n<p>For instance, the grammar</p>\n\n<pre><code>e ::= 1 | e e\n</code></pre>\n\n<p>could be describing a set of strings that includes "1", "1 1", and "1 1 1", or it could be describing a set of terms that includes "1", "1 1", "(1 1) 1", and "1 (1 1)".</p>\n', 'ViewCount': '256', 'Title': 'Grammar in formal languages versus programming language theory', 'LastActivityDate': '2012-05-18T07:05:13.300', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'Heatsink', 'PostTypeId': '1', 'OwnerUserId': '2488', 'Tags': '<formal-languages><programming-languages>', 'CreationDate': '2012-05-18T00:37:41.757', 'Id': '1907''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to convert a user entered regular expression into an NFA so that I can then run the NFA against a string for matching purposes. What is the minimum machine that can be used to parse regular expresssions? </p>\n\n<p>I assume it must be a push down automaton because the presense of brackets means the need to count and a DFA/NFA cannot perform arbitrary counting. Is this assumption correct? For example, the expression a(bc*)d would require a PDA so that the sub-expression in brackets is handled correctly.</p>\n', 'ViewCount': '549', 'Title': 'Does the language of Regular Expressions need a push down automata to parse it?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-22T07:41:16.970', 'LastEditDate': '2012-05-20T12:32:09.750', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1434', 'Tags': '<formal-languages><parsers><regular-expressions><pushdown-automata>', 'CreationDate': '2012-05-20T03:26:18.503', 'FavoriteCount': '3', 'Id': '1939''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>For the purpose of proving that they are not regular, what closure properties can I use to transform the languages</p>\n\n<ol>\n<li>$L_a = \\{ a^*cw \\mid  w \\in \\{a,b \\}^* \\land  |w|_a = |w|_b \\}$ and</li>\n<li>$L_b = \\{ab^{i_1}ab^{i_2}\\ldots ab^{i_n} \\mid  i_j\u2208\\mathbb N \\land \\exists j\u2208[1,n]  \\ i_j \\not= j \\}$</li>\n</ol>\n\n<p>to  $L := \\{ a^nb^n \\mid n\\in \\mathbb N \\}$, respectively?</p>\n\n<p>I tried: </p>\n\n<ol>\n<li><p>$L_a = \\{ a^*cw \\mid w \\in \\{a,b \\}^* \\land  |w|_a = |w|_b \\}$ </p>\n\n<p>$L_a' = \\{ \\{a,d\\}^*cw \\mid w \\in \\{a,b,d \\}^* \\land  |w|_a + |w|_d = |w|_b \\}$ (union?)</p>\n\n<p>$L_a'' = \\{ d^*cw \\mid w \\in \\{a,b \\}^* \\land |w|_a = |w|_b \\}$\n(concatenation?)</p>\n\n<p>$L_a''' = \\{ w \\mid w \\in \\{a,b \\}^* \\land |w|_a = |w|_b \\}$\n(homomorphism?)</p></li>\n<li><p>$L_b = \\{ab^{i_1}ab^{i_2}\\ldots ab^{i_n} \\mid i_j\u2208\\mathbb N \\land\\exists j\u2208[1,n] \\ i_j \\not= j \\}$</p>\n\n<p>$L_b' = \\{ab^{i_1}ab^{i_2}\\ldots ab^{i_n} \\mid i_j\u2208\\mathbb N \\land\\forall j\u2208[1,n] \\ i_j = j \\}$  (complement?)</p>\n\n<p>$L_b'' = \\{ac^{i_1}ac^{i_2}\\ldots ac^{i_n} \\mid i_j\u2208\\mathbb N \\land\\forall j\u2208[1,n] \\ i_j = j \\}$ (homomorphism?)</p></li>\n</ol>\n", 'ViewCount': '256', 'Title': 'Use closure properties to transform languages to $L := \\{ a^nb^n : n\\in \\mathbb N \\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-28T22:52:22.653', 'LastEditDate': '2012-05-24T00:03:27.303', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '1952', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2012-05-20T14:26:20.813', 'Id': '1949''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I would like to use your help with the following problem:</p>\n\n<p>$L=\\{\u27e8M\u27e9 \u2223 L(M) \\mbox{ is context-free} \\}$. Show that $L \\notin RE \\cup  CoRE$.</p>\n\n<p>I know that to prove $L\\notin RE$, it is enough to find a language $L'$ such that $L'\\notin RE$ and show that there is a reduction from $L'$ to $L$ $(L'\\leq _M L)$.</p>\n\n<p>I started to think of languages which I already know that they are not in $RE$, and I know that $Halt^* =\\{\u27e8M\u27e9 \u2223 M\\mbox{ halts for every input} \\} \\notin RE$. I thought of this reduction from $Halt^*$ to $L$: $f(\u27e8M\u27e9)=(M')$. for every $\u27e8M\u27e9$: if $M$ halts for every input  $L(M')=0^n1^n$ otherwise it would be $o^n1^n0^n$, but this is not correct, Isn't it? How can I check that $M$ halts for every input to begin with? and- is this the way to do that?</p>\n", 'ViewCount': '295', 'Title': u'Proof that $\\{\u27e8M\u27e9 \u2223 L(M) \\mbox{ is context-free} \\}$ is not (co-)recursively enumerable', 'LastEditorUserId': '1589', 'LastActivityDate': '2012-05-22T01:10:33.537', 'LastEditDate': '2012-05-21T21:24:16.623', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1985', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<formal-languages><computability><context-free><turing-machines>', 'CreationDate': '2012-05-21T19:28:38.840', 'Id': '1979''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '985', 'Title': 'Prove that regular languages are closed under the cycle operator', 'LastEditDate': '2012-05-22T07:23:51.960', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '2', 'Body': u"<p>I've got in a few days an exam and have problems to solve this task.</p>\n\n<p>Let $L$ be a regular language over the alphabet $\\Sigma$. We have the operation \n$\\operatorname{cycle}(L) = \\{ xy \\mid x,y\\in \\Sigma^* \\text{ and } yx\\in L\\}$\nAnd now we should show that $\\operatorname{cycle}(L)$ is also regular.</p>\n\n<p>The reference is that we could construct out of a DFA $D=(Q,\\Sigma,\\delta, q_0, F)$ with $L(D) = L$ a $\\epsilon$-NFA $N$ with $L(N) = \\operatorname{cycle}(L)$ and  $2 \xb7 |Q|^2 + 1$ states. </p>\n", 'Tags': '<formal-languages><regular-languages><finite-automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:35:34.333', 'CommentCount': '2', 'AcceptedAnswerId': '1989', 'CreationDate': '2012-05-22T05:28:58.017', 'Id': '1986''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1041', 'Title': 'Is there an undecidable finite language of finite words?', 'LastEditDate': '2012-05-24T13:02:04.297', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1396', 'FavoriteCount': '2', 'Body': '<p>Is there <em>a need</em> for $L\\subseteq \\Sigma^*$ to be <em>infinite</em> to be undecidable?</p>\n\n<p>I mean what if we choose a language $L\'$ be a <em>bounded finite version of</em> $L\\subseteq \\Sigma^*$, that is $|L\'|\\leq N$, ($N \\in \\mathbb{N}$), with $L\' \\subset L$.  Is it possible for $L\'$ to be an undecidable language?  </p>\n\n<p>I see that there is a problem of "How to choose the $N$ words that $\\in$ $L\' "$ for which we have to establish a rule for choosing which would be the first $N$ elements of $L\'$, a kind of "finite" Kleene star operation. The aim is to find undecidability language without needing an infinite set, but I can\'t see it.</p>\n\n<p><strong>EDIT Note:</strong> </p>\n\n<p>Although I chose an answer, many answers <strong>and all comments</strong> are important.</p>\n', 'Tags': '<formal-languages><computability><undecidability>', 'LastEditorUserId': '1396', 'LastActivityDate': '2013-01-02T01:05:19.163', 'CommentCount': '11', 'AcceptedAnswerId': '2014', 'CreationDate': '2012-05-22T13:11:23.497', 'Id': '1990''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>From this statement </p>\n\n<blockquote>\n  <p>As there is no surjection from $\\mathbb{N}$ onto $\\mathcal{P}(\\mathbb{N})$, thus there must exist an undecidable language.</p>\n</blockquote>\n\n<p>I would like to understand why similar reasoning does not work with a <em>finite</em> set $B$ which also has no surjection onto $\\mathcal{P}(B)$!  (with $|B|=K$ and $K \\in \\mathbb{N}$)</p>\n\n<p>Why is there a minimum need for the infinite set? </p>\n\n<p><strong>EDIT Note:</strong> </p>\n\n<p>Although I chose an answer, many answers <strong>and all comments</strong> are important.</p>\n', 'ViewCount': '161', 'Title': 'Why absence of surjection with the power set is not enough to prove the existence of an undecidable language?', 'LastEditorUserId': '1396', 'LastActivityDate': '2012-05-24T13:02:44.670', 'LastEditDate': '2012-05-24T13:02:44.670', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1997', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2012-05-22T14:23:03.890', 'Id': '1993''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is the set of LL(*) grammars the same as the set of context-free grammars?</p>\n', 'ViewCount': '69', 'Title': 'Is the set of LL(*) grammars the same as the set of CFG grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-22T20:08:48.947', 'LastEditDate': '2012-05-22T19:17:30.513', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'OwnerDisplayName': 'ninjagecko', 'PostTypeId': '1', 'OwnerUserId': '1030', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-04-10T04:04:27.197', 'Id': '2002''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '14352', 'Title': 'How to convert finite automata to regular expressions?', 'LastEditDate': '2014-03-22T11:29:26.503', 'AnswerCount': '4', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '18', 'Body': '<p>Converting regular expressions into (minimal) NFA that accept the same language is easy with standard algorithms, e.g. <a href="http://en.wikipedia.org/wiki/Thompson%27s_construction_algorithm" rel="nofollow">Thompson\'s algorithm</a>. The other direction seems to be more tedious, though, and sometimes the resulting expressions are messy.</p>\n\n<p>What algorithms are there for converting NFA into equivalent regular expressions? Are there advantages regarding time complexity or result size?</p>\n\n<p><sup>This is supposed to be a reference question. Please include a general decription of your method as well as a non-trivial example.</sup></p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:29:26.503', 'CommentCount': '2', 'AcceptedAnswerId': '2389', 'CreationDate': '2012-05-23T08:19:27.003', 'Id': '2016''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2008/construction-of-a-regular-expression">Construction of a regular expression</a>  </p>\n</blockquote>\n\n\n\n<p>can someone help me with the following exercise?\nIn the formation of a regular expression from a finite automaton $A$ with three states they have been calculated the following parts, in which 1,2 and 3 been renamed, 1 is the start state and 2,3 are accepting states:<br>\n$L^2 _{1,1} = b^*(aab^*)^*$<br>\n$L^2 _{1,2} = b^*a(ab^*a)^*$<br>\n$L^2 _{1,3} = b^*a(ab^*a)^*b$<br>\n$L^2 _{3,2} = b^*ba(ab^*a)^*$<br>\n$L^2 _{3,3} = |\\epsilon|a|b^*ba(ab^*a)^*b$<br>\nAnd now the question is to perform the remaining construction of a regular expression for $L(A)$</p>\n\n<p>i already tried this exercise with nerode but i didnt come to a solution please help me<br>\nthank you guys</p>\n', 'ViewCount': '42', 'ClosedDate': '2012-05-23T15:21:08.820', 'Title': 'regular expression', 'LastActivityDate': '2012-05-23T14:39:29.493', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1424', 'Tags': '<formal-languages>', 'CreationDate': '2012-05-23T14:39:29.493', 'Id': '2022''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need help with the following exercise:</p>\n\n<p>Construct an $\\varepsilon$-NFA for the following regular expression $(a|\\varepsilon)(ba)^*(c^*a|bc)^*$.</p>\n\n<p>i already tried this exercise with nerode but i didnt come to a solution please help me\nthank you guys</p>\n\n<p>Source wiki\nNerode : (Given a language L, and a pair of strings x and y, define a distinguishing extension to be a string z such that exactly one of the two strings xz and yz belongs to L. Define a relation RL on strings by the rule that x RL y if there is no distinguishing extension for x and y. It is easy to show that RL is an equivalence relation on strings, and thus it divides the set of all finite strings into equivalence classes.</p>\n\n<p>The Myhill\u2013Nerode theorem states that L is regular if and only if RL has a finite number of equivalence classes, and moreover that the number of states in the smallest deterministic finite automaton (DFA) recognizing L is equal to the number of equivalence classes in RL. In particular, this implies that there is a unique minimal DFA with minimum number of states.)</p>\n', 'ViewCount': '164', 'Title': 'construct regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T13:19:11.120', 'LastEditDate': '2012-05-23T15:44:05.140', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1424', 'Tags': '<formal-languages><finite-automata><regular-expressions>', 'CreationDate': '2012-05-23T14:54:13.360', 'Id': '2024''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '336', 'Title': 'Is there a context free, non-regular language $L$, for which $L^*$ is regular?', 'LastEditDate': '2012-05-25T21:02:11.603', 'AnswerCount': '1', 'Score': '6', 'OwnerDisplayName': 'ybz', 'PostTypeId': '1', 'OwnerUserId': '4832', 'Body': '<p>I know that there are non-regular languages, so that $L^*$ is regular, but all examples I can find are context-sensitive but not context free.</p>\n\n<p>In case there are none how do you prove it?</p>\n', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-25T21:02:11.603', 'CommentCount': '1', 'AcceptedAnswerId': '2083', 'CreationDate': '2012-01-08T15:33:04.230', 'Id': '2081''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1182', 'Title': 'Context-free grammar for $\\{ a^n b^m a^{n+m} \\}$', 'LastEditDate': '2012-05-28T12:21:03.760', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '1', 'Body': "<p>I've got a problem with this task. I should declare a context-free grammar for this language:</p>\n\n<p>$\\qquad \\displaystyle L := \\{\\, a^nb^ma^{n+m} : n,m \\in \\mathbb{N}\\,\\}$</p>\n\n<p>My idea is: We need a start symbol, for example $S$. I know that I can generate the first $a$ and the last $a$ by $S \\to a a$. I don't know what is the next idea to solve this task.</p>\n", 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-28T15:46:56.970', 'CommentCount': '5', 'AcceptedAnswerId': '2129', 'CreationDate': '2012-05-28T11:53:46.383', 'Id': '2127''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '110', 'Title': 'generation of linear grammar', 'LastEditDate': '2012-05-29T23:39:47.980', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '1', 'Body': '<p>We have the following linear grammar:\n$$E \\rightarrow aO | bO | bbE | bb$$\n$$O \\rightarrow aE | bE | abaE | aba$$\nDoes the linear grammar generate a regular language, if yes why ?\nOur alphabet is $\\Sigma$ = {a,b} and our nonterminals are E and O. We begin by E.</p>\n', 'Tags': '<formal-languages><formal-grammars>', 'LastEditorUserId': '769', 'LastActivityDate': '2012-05-31T03:10:12.657', 'CommentCount': '6', 'AcceptedAnswerId': '2180', 'CreationDate': '2012-05-29T23:06:52.830', 'Id': '2166''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>$L=\\{&lt;\\!M,x\\!&gt;\\, \\mid M's \\text{ transition function can only move right and   } M\\text{ halts on } x \\}$. I need to show that $L$ is recursive/decidable.</p>\n\n<p>I thought of checking the encoding of $M$ first and determine whether its transition function moves only right (Can I do that?). If so then try to simulate $M$ on $x$ for $|Q|+1$ steps, if it stops then $&lt;\\!M,x\\!&gt;\\, \\in L$ otherwise it is not.</p>\n\n<p>Is this correct?</p>\n", 'ViewCount': '237', 'Title': 'Show that the halting problem is decidable for one-pass Turing machines', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T09:58:30.713', 'LastEditDate': '2012-06-03T15:42:33.780', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2213', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<formal-languages><computability><turing-machines><check-my-proof>', 'CreationDate': '2012-06-03T14:32:39.493', 'Id': '2212''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Given a language $L = \\{a^pb^{2p} \\mid p \\ge 1\\}$, how could I show, using the Pumping Lemma that $L$ is not regular?</p>\n', 'ViewCount': '42', 'ClosedDate': '2012-06-04T08:25:58.397', 'Title': 'Show that a language is not regular using the Pumping Lemma', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-04T23:28:19.053', 'LastEditDate': '2012-06-04T23:28:19.053', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1738', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-06-04T02:01:08.937', 'Id': '2216''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '451', 'Title': 'Automata that recognizes Kleene closure of permutations of three symbols', 'LastEditDate': '2012-06-05T20:22:44.813', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1758', 'FavoriteCount': '1', 'Body': u'<p>This is an automata theory homework question.</p>\n\n<p>I need to create DFA that meets the following criteria:  </p>\n\n<ul>\n<li><p>Alphabet $\\Sigma = \\{ a, b, c \\}$</p></li>\n<li><p>Machine accepts empty string and strings of length that is a multiple of three, with every block of three containing one $a$, one $b$ and one $c$.</p></li>\n</ul>\n\n<p>So far, I came up with this machine, it is obvious:</p>\n\n<p><img src="http://i.stack.imgur.com/r3rCz.jpg" alt="the machine"></p>\n\n<p>However, I can\'t get it to accept empty string. Does it mean there is a transition q0 \u2192 q3?</p>\n\n<p><strong>Update1:</strong>  Following corrections by Dave Clarke I made some corrections.</p>\n\n<ol>\n<li>A regular expression for this machine is $(www)^*$ where $w = \\{abc,acb,\u2026\\}$. Therefore to represent multiple of three, I need to copy this (on the picture) machine 3 times. Final state should have arrows pointing to the first copy, for transitions marked \'a\', \'b\',\'c\'.  </li>\n<li>As it was pointed out, since this is DFA, I need to add missing states. This can be accomplished by adding "dead" states.  </li>\n<li>Empty string should correspond to $\\varepsilon$-transition from qStarting \u2192 qFinal.</li>\n</ol>\n\n<p><strong>Update2:</strong> \nAs it was pointed out, my regular expression is wrong ! It should be $(w)^*$. Here is the final machine, that I think should be correct.(I didn\'t include "dead" state)<img src="http://i.stack.imgur.com/L3xZX.jpg" alt="enter image description here"></p>\n', 'Tags': '<formal-languages><automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-06T11:21:21.587', 'CommentCount': '11', 'AcceptedAnswerId': '2234', 'CreationDate': '2012-06-05T17:19:48.020', 'Id': '2233''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="nofollow">parsing expression grammar</a> (PEG) grammar and the name of the start production, I would like to label each node with the set of characters that can follow it.  I would be happy with a good approximation that is conservative -- if a character can follow a node then it must appear in the follower set.</p>\n\n<p>The grammar is represented as a tree of named productions whose bodies contain nodes representing</p>\n\n<ol>\n<li>Character</li>\n<li>Concatenation</li>\n<li>Union</li>\n<li>Non-terminal references</li>\n</ol>\n\n<p>So given a grammar in ABNF style syntax:</p>\n\n<pre><code>A := B (\'a\' | \'b\');\nB := (\'c\' | \'d\') (B | ());\n</code></pre>\n\n<p>where adjacent nodes are concatenated, <code>|</code> indicates union, single quoted characters match the character they represent, and upper case names are non-terminals.</p>\n\n<p>If the grammar\'s start production is <code>A</code>, the annotated version might look like</p>\n\n<pre><code>A := \n  (\n    (B /* [ab] */)\n    (\n      (\'a\' /* eof */)\n    | \n      (\'b\' /* eof */)\n    /* eof */\n    )\n  /* eof */\n  );\n\nB :=\n  (\n    (\n      (\'c\' /* [abcd] */)\n      |\n      (\'d\' /* [abcd] */)\n    /* [abcd] */\n    )\n    (\n      (B /* [ab] */)\n      |\n      ( /* [ab] */)\n    /* [ab] */\n    )\n  );\n</code></pre>\n\n<p>I want this so that I can do some simplification on a PEG grammar.  Since order is important in unions in PEG grammars, I want to partition the members of unions based on which ones could accept the same character so that I can ignore order between partition elements.</p>\n\n<p>I\'m using OMeta\'s grow-the-seed scheme for handling direct left-recursion in PEG grammars, so I need something that handles that.  I expect that any scheme for handling scannerless CF grammars with order-independent unions that is conservative or correct would be conservative for my purposes.</p>\n\n<p>Pointers to algorithms or source code would be much appreciated.</p>\n', 'ViewCount': '87', 'Title': 'Computing follow sets conservatively for a PEG grammar', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-16T18:02:43.013', 'LastEditDate': '2012-06-09T18:04:51.030', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '2297', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><reference-request><formal-grammars><parsers>', 'CreationDate': '2012-06-08T21:42:44.733', 'Id': '2292''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '214', 'Title': 'Recursive, Recursively Enumerable and None of the Above', 'LastEditDate': '2013-01-17T04:12:54.550', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1577', 'FavoriteCount': '1', 'Body': '<p>Let </p>\n\n<ul>\n<li>$A = \\mathrm{R}$ be the set of all languages that are recursive,</li>\n<li>$B = \\mathrm{RE} \\setminus \\mathrm{R}$ be the set of all languages that are recursively enumerable but not recursive and</li>\n<li>$C = \\overline{\\mathrm{RE}}$ be the set of all languages that are not recursively enumerable.</li>\n</ul>\n\n<p>It is clear that for example $\\mathrm{CFL} \\subseteq A$.</p>\n\n<p>What is a simple example of a member of set B?</p>\n\n<p>What is a simple example of a member of set C?</p>\n\n<p>In general, how do you classify a language as either A, B or C?</p>\n', 'Tags': '<formal-languages><computability>', 'LastEditorUserId': '-1', 'LastActivityDate': '2013-01-17T04:12:54.550', 'CommentCount': '2', 'AcceptedAnswerId': '2307', 'CreationDate': '2012-06-09T22:56:54.363', 'Id': '2304''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it theoretically possible to specify a programming language for which no implementation could exist? A programming language is a way of defining functions. An implementation means a method to execute a given program in that language on a given input to the output of the function corresponding to the program on that input.</p>\n\n<p>What is are the minimal requirements of such a language?</p>\n', 'ViewCount': '250', 'Title': 'Can you specify a programming language without implementation?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-03T23:24:03.857', 'LastEditDate': '2012-06-14T16:16:48.313', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '5', 'OwnerDisplayName': 'meisam', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><programming-languages>', 'CreationDate': '2011-07-18T15:21:14.573', 'FavoriteCount': '2', 'Id': '2348''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This standard definition of pumping lemma from Wikipedia.</p>\n\n<blockquote>\n  <p>Let $L$ be a regular language. Then there exists an integer $p\\ge  1$ (depending only on $L$) such that every string $w$ in $L$ of length at least $p$ ($p$ is called the "pumping length") can be written as $w = xyz$ (i.e., $w$ can be divided into three substrings), satisfying the following conditions: </p>\n  \n  <ol>\n  <li>$|y| \\ge 1$  </li>\n  <li>$|xy| \\le p$ and  </li>\n  <li>for all $i \\ge 0$, $xy^iz \\in L$.<br>\n  $y$ is the substring that can be pumped (removed or repeated any number of times, and the resulting string is always in $L$).  </li>\n  </ol>\n</blockquote>\n\n<p>What confuses me about the definition of pumping lemma are two requirements: $|y| \\ge 1$  and $i \\ge 0$, $xy^iz$. The way I read it, that we are required to have $y$ length be equal to one or great, and at the same time, we can completely skip it, since $i \\ge 0$, i.e. effectively  $|y| = 0 $.\nIntuitively, it makes sense that we should be able to skip $y$ and still have string be in $L$.  </p>\n', 'ViewCount': '143', 'Title': 'Length of mid part of the string in Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-19T23:21:13.503', 'LastEditDate': '2012-06-13T10:05:01.987', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1758', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-06-13T07:56:54.557', 'FavoriteCount': '1', 'Id': '2357''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '475', 'Title': 'How to feel intuitively that a language is regular', 'LastEditDate': '2012-06-16T16:14:26.113', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1877', 'FavoriteCount': '2', 'Body': '<p>Given a language $ L= \\{a^n b^n c^n\\}$, how can I say directly, without looking at production rules, that this language is not regular?</p>\n\n<p>I could use pumping lemma but some guys are saying just looking at the grammar that this is not regular one. How is it possible?</p>\n', 'Tags': '<formal-languages><regular-languages><pumping-lemma><intuition>', 'LastEditorUserId': '851', 'LastActivityDate': '2012-06-22T14:12:38.223', 'CommentCount': '5', 'AcceptedAnswerId': '2396', 'CreationDate': '2012-06-16T15:32:24.460', 'Id': '2393''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to proof that if $L_1 \\subset L_2$ and $L_1$ is not regular then $L_2$ it not regular. This is my proof. Is it valid? </p>\n\n<p>Since $L_1$ is not regular, there does not exists a finite automata $M_1$ such that $L_1$ is the language of $M_1$. Pick $x\\in L_1$. So $x \\in L_2$ and suppose that $L_2$ is regular. Then there exists a finite automata $M_2$ such that $L_2$ is the language of $M_2$. Since $x \\in L_2$ and $L_2$ is regular, there exists a state $s\\in S$ such that from the initial state in $M_2$ there is a path $x$ to this final state $s$. Since this holds for all $x \\in L_1$, we can construct a finite automata which language is $L_1$, so $L_1$ is regular, so we reached a contradiction, so $L_2$ is not regular.</p>\n\n<p>Can this be done easier?</p>\n', 'ViewCount': '463', 'Title': 'Are supersets of non-regular languages also non-regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-29T12:06:06.380', 'LastEditDate': '2012-06-28T16:53:23.070', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata><check-my-proof>', 'CreationDate': '2012-06-28T16:24:12.253', 'Id': '2528''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know the answer <em>without</em> nesting limit is the Catalan number. My question is, specifically, is there a recurrence relation that gives the number of expression containing $n$ pairs of matching brackets such that no more than $l$ open brackets are not closed at any given point?</p>\n\n<p>For instance, for $n=3$ and $l=2$ the answer is $4$. All possible combinations are $(())()$, $()(())$, $()()()$, $(()())$. We cannot have $((()))$ since there are three open brackets that are not closed at the middle.</p>\n', 'ViewCount': '182', 'Title': 'What is the number of expressions containing n pairs of matching brackets with nesting limit?', 'LastEditorUserId': '1718', 'LastActivityDate': '2013-01-02T14:13:08.157', 'LastEditDate': '2012-06-28T19:07:37.053', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<formal-languages><combinatorics><recurrence-relation><word-combinatorics>', 'CreationDate': '2012-06-28T17:42:20.740', 'Id': '2532''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Let $L_1$ be regular, $L_1 \\cap L_2$ regular, $L_2$ not regular. Show that $L_1 \\cup L_2$ is not regular or give a counterexample.</p>\n</blockquote>\n\n<p>I tried this: Look at $L_1 \\backslash (L_2 \\cap L_1)$. This one is regular. I can construct a finite automata for this ($L_1$ is regular, $L_2 \\cap L_1$ is regular, so remove all the paths (finite amount) for $L_1 \\cap L_2$ from the finite amount of paths for $L_1$. So there is a finite amount of paths left for this whole thing. This thing is disjoint from $L_2$, but how can I prove that the union of $L_1 \\backslash (L_1 \\cap L_2)$ (regular) and $L_2$ (not regular) is not regular?</p>\n', 'ViewCount': '2072', 'Title': 'Proof that union of a regular and a not regular language is not regular', 'LastEditorUserId': '667', 'LastActivityDate': '2014-04-19T06:24:37.110', 'LastEditDate': '2012-07-17T18:05:14.560', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-06-28T20:00:17.477', 'Id': '2537''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '232', 'Title': 'Is this language Context-Free?', 'LastEditDate': '2012-07-05T08:32:15.243', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2076', 'FavoriteCount': '2', 'Body': "<p>Is the language</p>\n\n<p>$$L = \\{a,b\\}^* \\setminus \\{(a^nb^n)^n\\mid n \\geq1 \\}$$</p>\n\n<p>context-free? I believe that the answer is that it is not a CFL, but I can't prove it by Ogden's lemma or Pumping lemma.</p>\n", 'Tags': '<formal-languages><context-free><pumping-lemma>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-05T09:41:53.560', 'CommentCount': '2', 'AcceptedAnswerId': '2627', 'CreationDate': '2012-07-05T05:40:38.400', 'Id': '2623''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I wanted to ask if someone can help me to construct a regular expression over the alphabet $\\{a,b,x\\}$ for the language $L$ which is constituted by all strings containing an odd number of $a$'s, and in which between each pair of consecutive $a$'s there is an even number of $b$'s (and an arbirtary number of $x$'s).</p>\n\n<p>For example, $babbxbbxabbxaabxxbax \\in L$, $bab \\in L$, while $abba \\notin L$ and $abbbaa \\notin L$.</p>\n\n<p>What is the approach?</p>\n", 'ViewCount': '183', 'Title': 'A regular expression for a given formal language', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-10T21:20:38.263', 'LastEditDate': '2012-07-09T09:46:21.820', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2650', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-07-09T06:59:11.900', 'Id': '2649''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '138', 'Title': 'regular expression given the language', 'LastEditDate': '2012-07-16T23:36:19.187', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2125', 'FavoriteCount': '1', 'Body': '<p>The language is:\n$$\nL = \\{ (a^n) (b^m) \\mid n + m = 3k, k \\ge 0 \\}\n$$</p>\n\n<p>My attempt at an answer:\n$$\n(a \\cup b)^{3k}\n$$</p>\n\n<p>This will work if the a OR b can change for each instance in the string that is (3k) long. If not, what can I do to fix this?</p>\n', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:36:19.187', 'CommentCount': '4', 'AcceptedAnswerId': '2670', 'CreationDate': '2012-07-10T15:19:01.010', 'Id': '2669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $\\Sigma$ be a given alphabet. Is there a way to code up Deterministic Finite state Automata (DFA) over $\\Sigma$ as strings of $\\Sigma$ in such a way that the corresponding subset of $\\Sigma^*$ is a regular language?</p>\n\n<p>For example for Turing machines, the set of codes of Turing machines over a fixed alphabet is decidable, and we can speak of decidable sets of Turing machines (through their codes).</p>\n\n<p>Of course we can also speak of regular sets of DFA's (through their codes). Is the set of all DFA's regular in this sense?</p>\n", 'ViewCount': '143', 'Title': 'Is the set of codes of Deterministic Finite-State Automata a regular language?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-06-13T13:23:28.980', 'LastEditDate': '2012-07-17T05:57:31.880', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'OwnerDisplayName': 'user1491069', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-07-09T16:26:02.807', 'Id': '2682''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '3538', 'Title': 'Left recursion and left factoring -- which one goes first?', 'LastEditDate': '2014-01-23T17:17:37.047', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '2', 'Body': '<p>if I have a grammar having a production that contains both left recursion and left factoring like </p>\n\n<p>$\\qquad \\displaystyle F \\to FBa \\mid cDS \\mid c$ </p>\n\n<p>which one has priority, left recursion or left factoring?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:37.047', 'CommentCount': '3', 'AcceptedAnswerId': '2720', 'CreationDate': '2012-07-11T16:32:10.717', 'Id': '2696''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '880', 'Title': 'Are regular expressions $LR(k)$?', 'LastEditDate': '2012-07-18T00:50:56.043', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'Andrea Tucci', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '1', 'Body': '<p>If I have a Type 3 Grammar, it can be represented on a pushdown automaton (without doing any operation on the stack) so I can represent regular expressions by using context free languages. But can I know if a type 3 grammar is $LR(1)$, $LL(1)$, $SLR(1)$, etc. without constructing any parse tables?</p>\n', 'Tags': '<formal-languages><regular-languages><formal-grammars><parsers><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T00:50:56.043', 'CommentCount': '0', 'AcceptedAnswerId': '2715', 'CreationDate': '2012-07-11T12:26:59.840', 'Id': '2713''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Please note that I am aware the undecidability of the conversion of context-free grammer to regular grammer. But given the non-embedding property of the input context-free grammer, is there any algorithm to convert it to regular grammer, or DFA directly?</p>\n', 'ViewCount': '216', 'Title': 'How to convert a non-embedding context free grammer to regular grammer?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-15T07:28:33.087', 'LastEditDate': '2012-07-18T01:57:35.887', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2775', 'Score': '2', 'OwnerDisplayName': 'dalibocai', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><context-free>', 'CreationDate': '2012-01-20T15:38:28.743', 'Id': '2774''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/LR_parser#LR_and_Other_Kinds_of_Parsers">the Wikipedia article</a>, the L in $LR(k)$ means "left-to-right scan", and the "R" means "rightmost derivation."  However, in <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf">Knuth\'s original paper on $LR(k)$ grammars</a>, he defines $LR(k)$ (on page 610) as a language that is "translatable from left to right with bound $k$."</p>\n\n<p>I am guessing that this new terminology was chosen to complement $LL(k)$ parsing\'s "left-to-right scan, leftmost derivation."  That said, I don\'t know when the terminology changed meaning.</p>\n\n<p>Does anyone know where the newer acronym for $LR(k)$ comes from?</p>\n', 'ViewCount': '115', 'Title': 'When did $LR(k)$ acquire the meaning "left-to-right scan, rightmost derivation?"', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:09:46.040', 'LastEditDate': '2012-07-17T22:09:46.040', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><reference-request><terminology><formal-grammars><parsers>', 'CreationDate': '2012-07-17T19:10:32.620', 'FavoriteCount': '1', 'Id': '2791''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How would you prove that the following language is not context-free?</p>\n\n<p>$$ L= \\{a^n b^m |\\, gcd(n,m)=1 \\}$$</p>\n\n<p>I suspect the solution uses the pumping lemma, but I'm not sure how to apply it.</p>\n", 'ViewCount': '500', 'Title': 'Proof that a language involving $gcd$ is not context-free', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-18T10:15:27.367', 'LastEditDate': '2012-07-17T22:06:59.037', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'Eren Bellisoy', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-04-05T19:17:28.377', 'Id': '2795''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Show that if $A$ is a context-free language and $B$ is finite, then $A - B$ is a context-free language.</p>\n</blockquote>\n\n<p>I'm just not sure how to use their properties to formally show this. Thanks for all the help in advance.</p>\n", 'ViewCount': '65', 'Title': 'Showing $A-B$ is a CFL where $A$ is a CFL and $B$ is finite', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-21T05:01:43.487', 'LastEditDate': '2012-07-21T05:01:43.487', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2125', 'Tags': '<formal-languages><context-free><proof-techniques>', 'CreationDate': '2012-07-20T17:58:00.223', 'Id': '2843''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Assume $L$ is a regular language over an ordered alphabet.  Is the language built by taking every word in $L$ and sorting it always a regular language?</p>\n', 'ViewCount': '213', 'Title': 'Are regular languages closed under sort?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-23T11:22:45.557', 'LastEditDate': '2012-07-23T03:13:48.003', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2862', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2242', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-07-22T23:51:05.643', 'Id': '2861''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf" rel="nofollow">Knuth\'s original paper on $LR(k)$ grammars</a>, he proved that the decision problem "Given a CFG $G$, is there a $k$ such that $G$ is an $LR(k)$ grammar?" is undecidable.</p>\n\n<p>Is there a similar result showing that it is undecidable whether a given CFG is an $LL(k)$ grammar for some choice of $k$?  Or is this problem known to be decidable?</p>\n', 'ViewCount': '175', 'Title': 'Determining whether a CFG is $LL(k)$ for any $k$?', 'LastEditorUserId': '2131', 'LastActivityDate': '2012-12-10T22:55:35.893', 'LastEditDate': '2012-12-10T22:55:35.893', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4928', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><computability><formal-grammars><context-free><parsing>', 'CreationDate': '2012-07-23T23:15:59.023', 'Id': '2889''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Consider the context free grammar:</p>\n\n<p>$\\qquad \\begin{align}\n    \\mathrm{bill} &amp;\\to \\mathrm{items}\\ \\mathrm{total}\\ \\mathrm{vat} \\\\\n    \\mathrm{items} &amp;\\to \\mathrm{item} \\mid \\mathrm{item}\\ \\mathrm{items} \\\\\n    \\mathrm{item} &amp;\\to name\\ \\mathrm{price} \\mid name\\ \\mathrm{quantity}\\ \\mathrm{price} \\\\\n    \\mathrm{quantity} &amp;\\to integer \\\\\n    \\mathrm{price} &amp;\\to integer \\\\\n    \\mathrm{total} &amp;\\to integer \\mid TOTAL\\ \\mathrm{price}  \\\\\n    \\mathrm{vat} &amp;\\to VAT\\ \\mathrm{price}  \n\\end{align}$</p>\n\n<p>How do I factor the grammar?</p>\n\n<p>This was asked in a past exam, and I don't know how to get started.</p>\n\n<p>Also, if you have any links that could help me understand this more it would be much appreciated!</p>\n", 'ViewCount': '126', 'Title': 'Factor a grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-06T11:26:18.517', 'LastEditDate': '2012-08-01T22:11:53.953', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'jamie jenkins', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><context-free>', 'CreationDate': '2012-08-01T20:13:21.343', 'FavoriteCount': '1', 'Id': '2989''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $\\mathrm{MIN}_{\\mathrm{DFA}}$ collection of all the codings of DFAs such that they are minimal regarding their states number. I mean if $\\langle A \\rangle \\in \\mathrm{MIN}_{\\mathrm{DFA}}$ then for every other DFA $B$ with less states than $A$, $L(A)\\ne L(B)$ holds. I'm trying to figure out how come that $\\mathrm{MIN}_{\\mathrm{DFA}} \\in R$? How come it is decidable?</p>\n\n<p>What is about this kind of DFAs that is easy to decide?</p>\n", 'ViewCount': '131', 'Title': 'Is the set of minimal DFA decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T14:43:53.250', 'LastEditDate': '2012-08-05T14:43:53.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3046', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-08-05T13:05:39.717', 'Id': '3044''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In the article <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm" rel="nofollow">Parsing Expressions by Recursive Descent by Theodore Norvell (1999)</a> the author starts with the following grammar for arithmetic expressions:</p>\n\n<pre><code>E --&gt; E "+" E | E "-" E | "-" E | E "*" E | E "/" E | E "^" E | "(" E ")" | v\n</code></pre>\n\n<p>which is quite bad, because it\'s ambiguous and left-recursive. So he starts from removing the left recursion from it, and his result is as such:</p>\n\n<pre><code>E --&gt; P {B P}\nP --&gt; v | "(" E ")" | U P\nB --&gt; "+" | "-" | "*" | "/" | "^"\nU --&gt; "-"\n</code></pre>\n\n<p>But I can\'t figure out how did he get to this result. When I try to remove the left recursion myself, I\'m doing it the following way:</p>\n\n<ol>\n<li><p>Firs, I group together the productions which doesn\'t have left recursion in one group, and other (left-recursive) in another group:</p>\n\n<pre><code>E --> E "+" E | E "-" E | E "*" E | E "/" E | E "^" E     // L-recursive\nE --> v | "(" E ")" | "-" E</code></pre></li>\n<li><p>Next, I name them and factor for easier manipulations:</p>\n\n<pre><code>E --> E B E  // L-recursive; B stands for "Binary operator"\nE --> P  // not L-recursive; P stands for "Primary Expression"\nP --> v | "(" E ")" | U E   // U stands for "Unary operator"\nB --> "+" | "-" | "*" | "/" | "^"\nP --> "-"</code></pre>\n\n<p>Now I need to deal only with the first two productions, which are now easier to deal with.</p></li>\n<li><p>I rewrite those first two productions by starting from the non-L-recursive production (which is simply <code>P</code>, the Primary expression) and following it by the optional Tail <code>T</code>, which I define as the rest of the original production less the first left-recursive nonterminal (that is, just <code>B E</code>) followed by the Tail <code>T</code>, <strong>or</strong> which could be empty:</p>\n\n<pre><code>E --> P T\nT --> B E T |</code></pre>\n\n<p>(note the empty alternative for the tail).</p></li>\n<li><p>These two productions I can now rewrite in EBNF like this:</p>\n\n<pre><code>E --> P {B E}</code></pre>\n\n<p>which is nearly what the author get, but I have <code>E</code> instead of <code>P</code> there inside the zero-or-more repetition pattern (the Tail). The other productions I get quite the same as he have got:</p>\n\n<p><pre><code>P --> v | "(" E ")" | U E\nB -> "+" | "-" | "*" | "/" | "^"\nU -> "-"</pre></code></p>\n\n<p>but here too I have <code>E</code> instead of <code>P</code> in the first production for <code>P</code>.</p></li>\n</ol>\n\n<p>So, my question is: What am I missing? What algebraic transformation on the syntax I need to proceed now to get the same exact form as the autor gets? I tried substitutions for <code>E</code>, but it only leads me into loops. I suspect that I need somehow to substitute <code>P</code> for <code>E</code>, but I don\'t know any legal transformation to justify it. Maybe you know what\'s the last missing step?</p>\n', 'ViewCount': '343', 'Title': 'Arithmetic expressions grammar transformation', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:22:47.697', 'LastEditDate': '2014-01-23T17:22:47.697', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'SasQ', 'PostTypeId': '1', 'OwnerUserId': '2381', 'Tags': '<formal-languages><context-free><formal-grammars><left-recursion>', 'CreationDate': '2012-08-05T20:59:01.593', 'Id': '3053''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>What I mean by a "symbolic regular expression" (if there already is a different name for this I\'m not aware of it) is a regular expression that may include exponents that are symbolic arithmetic expressions.  </p>\n\n<p>Example 1: $a^k|b^*$ means "either $k$ copies of $a$ or zero or more copies of $b$".<br>\nExample 2: $a^{k+1}|a^k$ means "either $k$ or $k+1$ copies of $a$".</p>\n\n<p>What I\'d like to do is disambiguate such regular expressions.  I know that to disambiguate a normal regular expression, you can convert it to an NFA, then a DFA, then back to a regular expression.</p>\n\n<p>The problem is not completely straightforward.  For example, $a^k|a^j$ is ambiguous if $j=k$ and unambiguous otherwise.  Thus, the appropriate output would be, for example,\n$$a^k \\text{ if } k=j, \\qquad a^k|a^j \\text{ otherwise.}$$</p>\n\n<p>Does anyone know if there has been anything written about this problem?</p>\n', 'ViewCount': '135', 'Title': 'How to disambiguate symbolic regular expressions', 'LastActivityDate': '2012-08-09T22:51:51.757', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2242', 'Tags': '<formal-languages><reference-request><regular-languages><regular-expressions><ambiguity>', 'CreationDate': '2012-08-09T22:51:51.757', 'Id': '3112''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<pre><code>S --&gt; Ta | b | Sc\nT --&gt; Tc | \u03bb\n</code></pre>\n\n<p>This isn't an LL grammar but I need it to be so I can do a parse table. The problem is that no matter how much I try I never manage to do make it an LL grammar. Can someone please help by making it a LL grammar? It isn't that big and I'm very confused.</p>\n", 'ViewCount': '88', 'Title': "What's wrong with this LL grammar? (very short)", 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-07T18:46:26.553', 'LastEditDate': '2012-08-14T14:07:17.107', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'Pablo Miranda', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing>', 'CreationDate': '2012-08-14T05:23:10.337', 'Id': '3172''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have been taking a compiler course of Stanford on coursera. I have a slight misunderstanding on the parsing table of the following grammar:</p>\n\n<p>S -> Sa | b</p>\n\n<p>According to the professor parsing table looks like this:</p>\n\n<ul>\n<li><p>If the leftmost nonterminal is S and the input is 'a', the production is nothing.</p></li>\n<li><p>If the leftmost nonterminal is S and the input is 'b', the production is both <code>Sa</code> and <code>b</code>.</p></li>\n</ul>\n\n<p>So if input is just <code>b</code>, then it is correct, it will go directly to production <code>b</code>.\nBut how will it go to production <code>Sa</code> for input <code>b</code>?</p>\n", 'ViewCount': '321', 'Title': 'LL(1) parsing table of left-recursive grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:11.390', 'LastEditDate': '2014-01-23T17:17:11.390', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Batman', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing><left-recursion>', 'CreationDate': '2012-08-14T07:11:18.640', 'Id': '3173''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need to show that </p>\n\n<p>$\\qquad \\displaystyle S = \\{(10^p)^m \\mid p \\geq 0, m \\geq 0\\}$</p>\n\n<p>is not a regular language using pumping lemma.</p>\n\n<p>Can I multiply the product of the powers and express it to: $S = \\{ 1^m 0^{pm} \\mid \\dots \\}$ and apply the pumping lemma where I pump 1's then say that the language doesn't accept the new string? </p>\n", 'ViewCount': '162', 'Title': 'Pumping Lemma: is it valid to "multiply the product of powers" in this case?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-15T18:46:39.087', 'LastEditDate': '2012-08-14T23:41:26.947', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'thokthak', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-03-20T03:46:48.117', 'Id': '3190''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2623/is-this-language-context-free">Is this language Context-Free?</a>  </p>\n</blockquote>\n\n\n\n<p>The language is defined by\n$$(a+b)^*-\\{(a^nb^n)^n\\mid n \\geq1 \\}$$</p>\n\n<p>is Context-Free Language? I believe that the answer is that it is not a CFL\'s, but I can\'t prove it by Ogden lemma or pumping lemma.</p>\n\n<p>chazisop, (a+b)* means {a,b}*. That\'s all strings that you can form with the symbols a or b or both.</p>\n', 'ViewCount': '78', 'ClosedDate': '2012-08-15T06:10:52.610', 'Title': 'Is this language Context-Free?', 'LastActivityDate': '2012-08-15T02:56:42.430', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '9', 'OwnerDisplayName': 'Frank Duque', 'PostTypeId': '1', 'OwnerUserId': '2077', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-07-03T22:02:38.647', 'Id': '3193''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '5374', 'Title': 'How to show that a "reversed" regular language is regular', 'LastEditDate': '2013-03-06T13:33:29.817', 'AnswerCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2576', 'FavoriteCount': '2', 'Body': '<p>I\'m stuck on the following question:</p>\n\n<p>"Regular languages are precisely those accepted by finite automata. Given this fact, show that if the language $L$ is accepted by some finite automaton, then $L^{R}$ is also accepted by some finite; $L^{R}$ consists of all words of $L$ reversed."</p>\n', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'LastEditorUserId': '2100', 'LastActivityDate': '2013-10-03T14:07:16.580', 'CommentCount': '13', 'AcceptedAnswerId': '3253', 'CreationDate': '2012-08-18T15:54:03.993', 'Id': '3251''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '203', 'Title': 'Formally describing a new domain specific programming language', 'LastEditDate': '2012-08-24T20:38:02.907', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2409', 'FavoriteCount': '5', 'Body': "<p>I am about to implement a domain specific language for representation of social learning conventions. Part of the implementation is a formal description of a language - its 'calculus', symbols and logical expressions.</p>\n\n<p>My approach would be to describe the language by describing its grammar but there are also concepts such as relations, dialogs, expectations that require more theoretic approach and the description of the logic. </p>\n\n<p>I would like to ask for an example and a literature recommendation (papers, books) that would help me with this description. I feel relatively competent approaching this task so I am not asking for a total hand holding, but help from a theoretician in this area would be GREATLY appreciated. </p>\n", 'Tags': '<formal-languages><programming-languages><semantics>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-08-25T08:20:35.950', 'CommentCount': '2', 'AcceptedAnswerId': '3320', 'CreationDate': '2012-08-24T14:56:26.330', 'Id': '3313''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I got one grammar:</p>\n\n<pre><code>re2: re1 $\n\nre1: expr == expr | expr != expr | expr &lt; expr | expr &lt;= expr | expr &gt;= expr | expr &gt; expr | expr\n\nexpr: expr + term | expr - term | term\n\nterm: term * factor | term / factor | factor\n\nfactor: (expr) | num | id\n\nnum: (0|1|2|3|4|5|6|7|8|9)num | \u03b5\n\nid: (a|b|....|z|A|B|....|Z|)id | \u03b5\n\nHere are the FOLLOW sets:\n\nFOLLOW(r2) = {}\nFOLLOW(r1) = {$}\nFOLLOW(expr) = {=,!,&lt;,&gt;,+,-,)}\nFOLLOW(term) = FOLLOW(factor) = FOLLOW (id) = FOLLOW (num) = {=,!,&lt;,&gt;,+,-,),*,/}\n</code></pre>\n\n<p>Now this grammar clearly got reduce-reduce conflict from\nnum: \u03b5 and id: \u03b5 because FOLLOW(num) \u2229 FOLLOW(id) != empty set</p>\n\n<p>Now let's say I fix the grammar by  doing the following (I assume it is mistake in the grammar because (\u03b5 == \u03b5) makes no sense):</p>\n\n<pre><code>num: (0|1|2|3|4|5|6|7|8|9)num | (0|1|2|3|4|5|6|7|8|9)\nid: (a|b|....|z|A|B|....|Z|)id | (a|b|....|z|A|B|....|Z|) \n</code></pre>\n\n<p>Now my question is, is this grammar SLR i.e can it be parsed by SLR parser? I know by building the parser I can find out but on exam I can not make the whole parser and then determine (I would lose lot of time).</p>\n", 'ViewCount': '344', 'Title': 'Ambiguous grammar? Could the grammar be parsed by SLR parser?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-05T22:08:40.713', 'LastEditDate': '2012-08-25T04:03:25.147', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'user1377320', 'PostTypeId': '1', 'OwnerUserId': '2634', 'Tags': '<formal-languages><formal-grammars><compilers><parsing>', 'CreationDate': '2012-08-24T22:55:28.367', 'Id': '3325''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I tried to find a simple example for a language that is not parseable with an LL(1) parser. I finally found this language.</p>\n\n<p>$$L=\\{a^nb^m|n,m\\in\\mathbb N\\land n\\ge m\\}$$</p>\n\n<p>Is my hypothesis true or is this language parseable with an LL(1) parser?</p>\n\n<p>One can use this simple grammar to describe $L$ (of course it is isn't LL(1) parseable):</p>\n\n<pre><code>S -&gt; \u03b5\nS -&gt; A\nA -&gt; aA\nA -&gt; aAb\nA -&gt; a\nA -&gt; ab\n</code></pre>\n", 'ViewCount': '604', 'Title': 'Is this language LL(1) parseable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-29T09:51:17.570', 'LastEditDate': '2012-08-28T23:14:02.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '3359', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<formal-languages><formal-grammars><context-free><parsers>', 'CreationDate': '2012-08-28T12:40:52.453', 'Id': '3350''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Construct an NFA over $\\{0, 1\\}$ whose language contains only words that do not end with $10$.</p>\n</blockquote>\n\n<p>This is one of the first problems in the book, so it's supposedly easy. I just can't figure it out. It's easy using a DFA, but I'm not so sure using an NFA. Maybe I'm not understanding a particular concept in the NFA.</p>\n", 'ViewCount': '398', 'Title': 'NFA for binary words that do not end in 10', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-30T16:21:24.157', 'LastEditDate': '2012-08-30T15:48:21.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user10537', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-08-30T01:16:20.547', 'FavoriteCount': '0', 'Id': '3368''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is homework and I'm looking for a push in the right direction. Proofs were never something I was properly taught, so now they're kind of a weak point.</p>\n\n<p>Here's the problem:</p>\n\n<blockquote>\n  <p>The following grammar generates numbers in binary notation ($C$ is the\n  start symbol):</p>\n  \n  <p>$\\qquad \\begin{align}C &amp;\\to C 0 \\mid A 1 \\mid 0 \\\\\n                       A &amp;\\to B 0 \\mid C 1 \\mid 1 \\\\\n                       B &amp;\\to A 0 \\mid B 1\n          \\end{align}$</p>\n  \n  <ol>\n  <li><p>Prove that the alternating sums of the digits of the generated\n  numbers are multiples of $3$. The alternating sum of $w=w_0\\dots w_n$ is defined as $\\sum_{i=0}^n (-1)^i \\cdot w_i$. As an example, $C$\n  generates $1001$ via $C \\Rightarrow A1 \\Rightarrow B01 \\Rightarrow A001 \\Rightarrow 1001$ with alternating sum of $0$;\n  clearly, $0$ is a multiple of $3$.</p></li>\n  <li><p>Prove that all such numbers (i.e.,\n  numbers whose alternating sum is a multiple of 3) are generated by the\n  grammar.</p></li>\n  </ol>\n</blockquote>\n\n<p>I'm thinking I need to show that the grammar can only generate strings which are made up of repeated subsequences of digits which always add up to 0, 3, or -3. But I'm not sure how to show that it can only generate those three subsequences.</p>\n\n<p>I also have worked out these thoughts:</p>\n\n<ul>\n<li><p>Consider that any even number of consecutive 1s is irrelevant, as they cancel each other out.</p></li>\n<li><p>Consider that all zeros are in of themselves irrelevant, as they add nothing.</p></li>\n<li><p>Consider then that the only relevant pattern is that of alternating 1s and zeros, and where this pattern starts and ends.</p></li>\n</ul>\n", 'ViewCount': '795', 'Title': 'Proving a grammar only generates words whose alternating digit sums is are multiples of three', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T11:59:01.517', 'LastEditDate': '2012-09-03T07:35:35.117', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2716', 'Tags': '<formal-languages><regular-languages><formal-grammars><proof-techniques>', 'CreationDate': '2012-09-02T20:45:42.667', 'Id': '3406''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I just started reading "Parsing Techniques, A Practical Guide", Second Edition, by Dick Grune and Ceriel J.H. Jacobs. </p>\n\n<p>On page 12, the authors start describing a set of rules that can be used to generate the set of all enumerations of names of the type "tom, dick and harry": the rules allow single names (e.g. "tom") as well as repetitions ("tom, harry, dick, dick and harry"); multiple names in an enumeration are separated by commas except the last two names which are separated by "and", so the following aren\'t valid: ("tom, harry, dick") or ("harry and tom and dick"). </p>\n\n<p>A few pages later, and after having defined some more terms and formalisms, the authors come up with the following replacement rules (parse structure grammar) to generate the sentences of the desired type:</p>\n\n<pre><code>0. Name -&gt; tom | dick | harry\n1. Sentence-&gt; Name | List End\n2. List -&gt; Name | Name, List\n3. , Name End -&gt; and Name\n</code></pre>\n\n<p>In the above, <strong>Sentence</strong> is the start symbol.</p>\n\n<p>However it seems to me that these rules can generate incorrect sentences: if we replace <strong>Sentence</strong> by <strong>List End</strong> and <strong>List</strong> by <strong>Name</strong> we end up with <strong>Name End</strong> for which no replacement rule is defined.</p>\n\n<p>It seems to me that the 2nd line in the rules above, if replaced by</p>\n\n<pre><code>Sentence -&gt; Name | Name, List End\n</code></pre>\n\n<p>would fix this problem. </p>\n\n<p>Am I correct that the authors have made an oversight, and is my modification correct? Or have I misunderstood something?</p>\n\n<p>I don\'t have a CS background and this is the first time I\'m reading about parsing, so please keep that in consideration in your replies. Thanks!</p>\n', 'ViewCount': '254', 'Title': 'Is this phrase structure grammar from my textbook correct?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-05T12:46:51.640', 'LastEditDate': '2012-09-05T07:47:54.720', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3428', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2736', 'Tags': '<formal-languages><formal-grammars><parsing>', 'CreationDate': '2012-09-05T03:34:36.257', 'Id': '3427''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Lets say I have given following grammar which generates arithmetic expressions in reverse polish notation:</p>\n\n<p>$G=({E},{a,+,*},P,E)$<br>\n$P={ E \\rightarrow EE+ | EE* | a }$  </p>\n\n<p>I know this grammar is unambiguous. </p>\n\n<p>What I do not understand is how I can prove this.</p>\n\n<p>I already searched a lot to in google, etc. but everyone only says, that reverse polish notation are unambiguous, but not WHY.</p>\n\n<p>Can you give me any hints?</p>\n', 'ViewCount': '239', 'Title': 'Unambiguity of Reverse Polish Notation', 'LastActivityDate': '2012-09-07T05:27:26.807', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '3459', 'Score': '1', 'OwnerDisplayName': 'xaedes', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-06-26T16:04:04.717', 'FavoriteCount': '2', 'Id': '3458''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I try to teach myself the usage of bison. The manpage bison(1) says about bison:</p>\n\n<blockquote>\n  <p>Generate a deterministic LR or generalized LR (GLR) parser employing LALR(1), IELR(1), or canonical LR(1) parser tables.</p>\n</blockquote>\n\n<p>What is an IELR-parser? All relevant articles I found on the world wide web are paywalled.</p>\n', 'ViewCount': '372', 'Title': 'What is an IELR(1)-parser?', 'LastEditorUserId': '3094', 'LastActivityDate': '2013-06-27T08:08:03.550', 'LastEditDate': '2012-12-05T12:26:17.283', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<formal-languages><terminology><formal-grammars><parsers>', 'CreationDate': '2012-09-07T15:07:37.423', 'FavoriteCount': '1', 'Id': '3461''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '165', 'Title': 'Is a single symbol, not in a set, a language?', 'LastEditDate': '2013-05-24T08:02:35.497', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Pampero', 'PostTypeId': '1', 'OwnerUserId': '2830', 'Body': "<p>I was reading about Turing machines and realized I'm not sure about the difference between the following scenario. Given the alphabet $\\Sigma = \\{a, b \\}$, we have the following assertions:</p>\n\n<ol>\n<li>$a \\in R $</li>\n<li>$\\{a\\} \\in R$</li>\n</ol>\n\n<p>I think that assertion $1$ is incorrect because $a$ is just a symbol, not a language. On the other hand $\\{a\\}$ is the language which contains only the $a$ symbol. Given that information, we can prove that $\\{a\\} \\in R$ by trivially building a TM. Here, $R$ denotes the set of recursive languages.</p>\n\n<p>Is my reasoning wrong? Thanks in advance.</p>\n", 'Tags': '<formal-languages><terminology><computability>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-24T14:39:13.220', 'CommentCount': '5', 'AcceptedAnswerId': '3538', 'CreationDate': '2012-09-14T14:41:42.840', 'Id': '3537''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>is the following true \n$ (L^R)^* = (L^*)^R $ </p>\n\n<p>I tried the following to prove it true.\nlet u,v belong to L then $ L^* = \\{ u,v, uu, vv, uv, vu ... \\} $\nand $ (L^*)^R = \\{ u^R, v^R, u^Ru^R, v^Rv^R, v^Ru^R, u^Rv^R ... \\} $</p>\n\n<p>now $ L^R = \\{ u^R, v^R \\} $ so \n$(L^R)^* = \\{ u^R, v^R, u^Ru^R, v^Rv^R, u^Rv^R, v^Ru^R ... \\} $</p>\n', 'ViewCount': '156', 'Title': 'Is star closure of reverse of language equivalent to reverse of closure of that language', 'LastEditorUserId': '2667', 'LastActivityDate': '2012-09-15T12:04:45.153', 'LastEditDate': '2012-09-15T11:00:47.203', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '3561', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2667', 'Tags': '<formal-languages><automata>', 'CreationDate': '2012-09-15T08:08:09.913', 'Id': '3559''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Are there any grammar classes which are true subsets of Chomsky level 2 but not equal to level 1?</p>\n', 'ViewCount': '166', 'Title': 'Are there grammar classes between Chomsky level 1 and 2?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T22:32:01.063', 'LastEditDate': '2012-09-18T22:05:21.370', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'crudolf', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-09-17T08:03:56.280', 'Id': '4607''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to define a semantics of a DSL through transition semantics. For my DSL I defined the syntax and implemented a code generator. Although I can provide a demo by giving examples, I want to write the semantics of my DSL to provide a formal specification of it. </p>\n\n<p>However I don't know how to do it!. Can someone provide me with an example?</p>\n", 'ViewCount': '207', 'Title': 'Looking for a simple example of Transition Semantics', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-21T13:13:12.907', 'LastEditDate': '2012-09-21T13:13:12.907', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '4', 'OwnerDisplayName': 'asghar ashgari', 'PostTypeId': '1', 'OwnerUserId': '2904', 'Tags': '<formal-languages><semantics>', 'CreationDate': '2012-09-20T09:58:10.913', 'Id': '4627''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m being asked to create a "top down grammar" for a certain language (I\'m pretty sure there\'s no such thing as a "top down grammar" but I think it means write a grammar that an LL(k) parser can parse).</p>\n\n<p>I\'m pretty sure the language is not LL(1), but I can remove left-recursion and common prefixes from it and still have an unambiguous grammar. But I\'m a little confused about the significance of that. If I successfully removed left-recursion and common prefixes and the grammar is still unambiguous, is the language LL(k)? And does that mean it can be parsed by a top-down parser?</p>\n', 'ViewCount': '205', 'Title': 'Can an LL(k) parser parse any grammar without left recursion or common prefixes?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-09T19:24:19.990', 'LastEditDate': '2012-10-09T03:45:47.377', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Aurast', 'PostTypeId': '1', 'Tags': '<formal-languages><compilers><parsing>', 'CreationDate': '2012-09-18T15:04:43.747', 'Id': '4630''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m reviewing for my midterm and wanted to post this to see if anyone can spot any errors. Im supposed to make a PDA that recognizes this CFG:</p>\n\n<p>$\\qquad\\begin{align}\n  S &amp;\\to R1R1R1 \\\\\n  R &amp;\\to 0R \\mid 1R \\mid \\varepsilon\n\\end{align}$</p>\n\n<p>Here is my solution; I\'m aware that I forgot to draw the second circle around my accepting state.</p>\n\n<p><img src="http://i.stack.imgur.com/vNLh0.png" alt="enter image description here"></p>\n', 'ViewCount': '447', 'Title': 'Converting a context free grammar to a PDA -- is my solution correct?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-22T19:14:08.240', 'LastEditDate': '2012-09-21T21:12:00.730', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'jfisk', 'PostTypeId': '1', 'Tags': '<formal-languages><automata><context-free><pushdown-automata>', 'CreationDate': '2011-11-05T19:34:40.697', 'Id': '4654''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '61', 'Title': u'B\xfcchi automaton with modified acceptance condition', 'LastEditDate': '2012-09-22T20:45:12.463', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'vh4x0r', 'PostTypeId': '1', 'OwnerUserId': '2935', 'Body': u'<p>Consider a B\xfcchi automaton $\\mathcal{A}$ with the modified acceptance condition, that an $\\omega$-word $\\mathcal{w}$ is accepted by $\\mathcal{A}$ iff every run $\\rho$ of $\\mathcal{A}$ on $\\mathcal{w}$ is accepting (rather than at least one run being accepting). I need to show that this automaton also accepts only $\\omega$-regular languages. How do I go about doing that?</p>\n', 'Tags': '<formal-languages><automata><buchi-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-23T21:47:02.687', 'CommentCount': '2', 'AcceptedAnswerId': '4697', 'CreationDate': '2012-09-20T15:44:40.677', 'Id': '4672''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to prove that the complement of $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties.</p>\n\n<p>I understand pumping lemma can be used to prove that $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not a regular language. I also understand regular languages are closed under complement operation. However, does that also imply that a non-regular language's complement is also non-regular?</p>\n", 'ViewCount': '779', 'Title': 'Prove that the complement of  $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-12T19:48:30.280', 'LastEditDate': '2012-09-28T11:33:15.257', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2978', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-09-26T20:53:42.597', 'FavoriteCount': '1', 'Id': '4752''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can anyone tell me what is the difference between the following regular expressions: $(0^*1^*)^*$ and $(0+1)^*$ ? To me they look like generating the same string.</p>\n', 'ViewCount': '274', 'Title': 'Difference between regular expressions: $(0^*1^*)^*$ and $(0+1)^*$', 'LastEditorUserId': '157', 'LastActivityDate': '2012-09-28T09:32:52.047', 'LastEditDate': '2012-09-28T09:32:52.047', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4766', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2987', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-09-27T14:16:45.693', 'Id': '4761''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '266', 'Title': 'Time complexity of an enumeration of SUBSET SUM instances', 'LastEditDate': '2012-10-04T17:08:49.840', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>An instance of the <strong><a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">SUBSET SUM</a></strong> problem (given $y$ and $A = \\{x_1,...,x_n\\}$ is there a non-empty subset of $A$ whose sum is $y$) can be represented on a one-tape Turing Machine with a list of comma separated numbers in binary format.\nIf $\\Sigma = \\{0,1,\\#\\}$ a reasonable format could be:</p>\n\n<p>$( 1 \\; (0|1)^* \\; \\#)^* \\#$</p>\n\n<p>Where the first required argument is the value $y$ and $\\#\\#$ encodes the end of the input. For example:</p>\n\n<pre><code> 1  0  0  #  1  0  #  1  #  #\n^^^^^^^^     ^^^^     ^\n   y          x1     x2\nInstance: y=4, A={2,1}\n</code></pre>\n\n<p>I would like to enumerate the SUBSET SUM instances.</p>\n\n<blockquote>\n<b>Question</b>: What is the (best) time complexity that can be achieved by a Turing Machine $TM_{Enum}$ that on input $m$ (which can be represented on the tape with a string of size $\\log m + 1$) - outputs the $m$-th SUBSET SUM instance in the above format?\n</blockquote>\n\n<p><strong>EDIT</strong>:</p>\n\n<p>Yuval\'s answer is fine, this is only a longer explanation.</p>\n\n<p>Without loss of  generality we set that $y &gt; 0$ and $0 &lt; x_1 \\leq x_2 \\leq ...  \\leq x_n$, $n \\geq 0$</p>\n\n<p>And we can represent an instance of subset sum using this encoding:</p>\n\n<p>$y \\# x_1\\# d_2\\# ...\\# d_{n} \\#\\#$ where $d_i \\geq 1, x_i = x_{i-1} + d_i - 1 \\; , i \\geq 2$</p>\n\n<p>Using a binary representation for $y,x_1, d_2, d_3, ...$ we have the following representation:</p>\n\n<p>$1 \\; ((0|1)^* \\# 1)^* \\; \\#\\#$</p>\n\n<p>Equivalent to $1 \\; (0|1|\\#1)^* \\; \\#\\#$. There is always a leading 1 and a trailing ## so we can consider only the $(0|1|\\#1)^*$ part.</p>\n\n<p>So the decoder TM on input $m$ in binary format should:</p>\n\n<ul>\n<li>output the leading 1</li>\n<li>convert $m$ to base 3 mapping digit 2 to $\\#1$</li>\n<li>when outputing the i-th intermediate $\\#$ calculate $x_i = d_i + x_{i-1}-1$</li>\n<li>output the trailing $\\#\\#$</li>\n</ul>\n\n<p>No duplicate instances are generated.</p>\n', 'Tags': '<algorithms><formal-languages><turing-machines><enumeration>', 'LastEditorUserId': '140', 'LastActivityDate': '2012-10-04T17:08:49.840', 'CommentCount': '7', 'AcceptedAnswerId': '4870', 'CreationDate': '2012-09-29T14:53:22.363', 'Id': '4794''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I would like to ask how to determine the number of states when designing a Turing machine from the description for a language? For example:</p>\n\n<p>$\\qquad \\displaystyle L = \\{wcw \\mid w \\in \\{0,1\\}^*\\}.$</p>\n\n<p>I mean how to know how many states are there in the set $Q$, with the information from the description of that language. </p>\n', 'ViewCount': '293', 'Title': 'How to calculate the number of states in designing a Turing machine?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-10-02T12:33:15.027', 'LastEditDate': '2012-09-30T00:56:55.650', 'AnswerCount': '3', 'CommentCount': '5', 'Score': '5', 'OwnerDisplayName': 'Chau', 'PostTypeId': '1', 'Tags': '<formal-languages><turing-machines><descriptive-complexity>', 'CreationDate': '2012-09-29T14:26:38.203', 'Id': '4801''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '472', 'Title': 'Is $(a^nb^m)^r$ regular?', 'LastEditDate': '2012-10-02T17:43:02.980', 'AnswerCount': '1', 'Score': '7', 'OwnerDisplayName': 'Exci', 'PostTypeId': '1', 'OwnerUserId': '3034', 'Body': "<p>I took my theory of computation exams a few weeks ago, and this was one of the questions:</p>\n\n<blockquote>\n  <p>Assume language $L=\\{(a^nb^m)^r \\mid n,m,r\\ge 0\\}$ </p>\n  \n  <p>Is L regular? If yes provide a regular expression or an automaton for it.</p>\n</blockquote>\n\n<p>After I briefly asked him the answer after the exam, it appears it really is regular (I believe he said the expression is the simple $(a^*b^*)^*$). However I cannot seem to understand why that is. The way I see it, its concatenating $a^nb^m$ <strong>r</strong> times, like this:</p>\n\n<blockquote>\n  <p>$a^nb^ma^nb^ma^nb^m...a^nb^ma^nb^m$, </p>\n</blockquote>\n\n<p>which isn't regular since there is no way for an automaton to recall <strong>n</strong> and <strong>m</strong> every time. Where am I at fault here?</p>\n\n<p>EDIT: I talked to the professor again, he admitted it was a mistake. The language is indeed not regular.</p>\n", 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T17:43:02.980', 'CommentCount': '4', 'AcceptedAnswerId': '4838', 'CreationDate': '2012-10-01T13:02:27.980', 'Id': '4837''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As the title says, I spent a couple of hours last weekend trying to wrap up my mind about the class of languages matched by Perl-compatible regular expressions, <em>excluding any matching operator that allows to execute arbitrary code inside the pattern</em>.</p>\n\n<p>If you don\'t know what PCREs are, please read <a href="http://perldoc.perl.org/perlre.html" rel="nofollow">this</a> and <a href="http://pcre.org/pcre.txt" rel="nofollow">this</a>. </p>\n\n<p>The problem is, the resources available on internet pretty much stop at context-free languages, and PCREs can match more than those (see below); but I really don\'t know where to find more theorems or papers about this kind of stuff.</p>\n\n<p>In particular: PCREs are obviously a superset of regular languages (as the PCRE syntax has all the regular language operators).</p>\n\n<p>Any CFG can be put in Greibach normal form, which removes left recursion. I think this can be used by means of <code>(?(DEFINE)...)</code> groups to "translate" the grammar into matching subroutines, avoiding to choke on left recursion, by translating:</p>\n\n<ul>\n<li>the non-terminal at the head of each production becomes a subroutine <code>(?&lt;HEAD&gt;...)</code></li>\n<li>the body of each production is put in the subroutine; terminals are left as-is, non-terminals become procedure invocations (i.e. <code>(?&amp;NONTERMINAL)</code>); </li>\n<li>all the productions with the same nonterminal as head are ORed together by means of the <code>|</code> operator (plus additional grouping with <code>(?:...)</code>, if necessary)</li>\n<li>the pattern then becomes a <code>(?(DEFINE)...)</code> group containing all the "translated" productions, and an invocation for the procedure of the starting symbol, to match the entire string, i.e. <code>^(?(DEFINE)...)(?&amp;START)$</code></li>\n</ul>\n\n<p>This should deal with any CFG. Therefore, PCREs should be able to match any CFL.</p>\n\n<p>There\'s more: let\'s take the simple language\n$$L = \\{ ww | w \\in \\Lambda^* \\} $$\ni.e. the language of the strings repeated twice. This language is not a CFL -- the pumping lemma for CFLs fails. (Pay particular attention that \n$$ |vxw| \\leq p$$\nmust hold, thus you can\'t just pump the beginnings or the ends of the two repeated strings.)</p>\n\n<p>However, this language is easily matched by a PCRE: <code>^(.*)\\1$</code>. Therefore, we\'re strictly above CFLs.</p>\n\n<p>How much above? Well, as I said, I have no idea. I couldn\'t find any resources about CSLs or all the other classes in between to make up my mind. Any expert willing to discuss this?</p>\n\n<p><strong>Addendum:</strong> I was asked to specify exactly which subset of the PCRE syntax must be allowed. As I wrote at the beginning of the post, I wanted to exclude any operator that allows to execute arbitrary code inside of the pattern, such as <code>??{}</code>. </p>\n\n<p>For the argument\'s sake, I think we can stick with the syntax defined by the <a href="http://pcre.org/pcre.txt" rel="nofollow">pcresyntax(3)</a> man page, which is a reasonable subset of what Perl 5.10-5.12 offers, minus the callouts (as they\'re not inside the pattern). I\'m not sure that adding or removing backtracking control verbs change the language we can recognize; if so, it would be nice to figure out which classes we get with and without those.</p>\n', 'ViewCount': '289', 'Title': 'Which languages do Perl-compatible regular expressions recognize?', 'LastEditorUserId': '3036', 'LastActivityDate': '2013-06-05T22:16:54.157', 'LastEditDate': '2012-10-03T08:03:48.953', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '3036', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2012-10-02T10:21:55.317', 'FavoriteCount': '1', 'Id': '4839''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can you show that the Language accepted by an NFA and the reverse NFA is the same?</p>\n\n<p>For a language $L$, there is an $L^R=\\{ w^R \\mid w \\in L\\}$</p>\n\n<p>Let's say that $w^R$ is the string obtained by reversing the string $w$.</p>\n\n<p>I know that it involves using induction on the length of the input, but I would really appreciate some help.</p>\n", 'ViewCount': '339', 'Title': 'How do you prove that two languages are equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T22:29:06.833', 'LastEditDate': '2012-10-02T20:02:27.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3040', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-10-02T18:37:35.743', 'Id': '4845''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I have a homework assignment where I need to convert a grammar into LL(1). I've already removed the left recursion, but I'm having trouble doing left-factoring. All of the examples I've found are simple, and look something like this:</p>\n\n<p><code>A -&gt; aX | aY</code><br>\nbecomes:<br>\n<code>A -&gt; aZ</code><br>\n<code>Z -&gt; X | Y</code></p>\n\n<p>I understand that. However, my grammar looks more like this:</p>\n\n<pre><code>X -&gt; aE | IXE | (X)E\nE -&gt; IE | BXE | \u03f5\nI -&gt; ++ | --\nB -&gt; + | - | \u03f5\n</code></pre>\n\n<p>I'm not sure how to apply the simpler example to this. I've been trying for at least a couple of hours and I've lost track of all of the things I've tried. Generally, my attempts have looked something like this:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nE  -&gt; IE | BIX'E | BX'E | \u03f5\n</code></pre>\n\n<p>And I then try to convert the E rules into ones having only one production starting with + or -:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; IE | B'IX'E | IX'E | B'X'E | X'E | \u03f5\n</code></pre>\n\n<p>And then...</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; +P | -M | \u03f5\nP  -&gt; +E | IX'E | +X'E | X'E\nM  -&gt; -E | IX'E | -X'E | X'E\n</code></pre>\n\n<p>And so on. But I continually end up with a lot of extra nonterminals, and some very long productions / chains of productions, without actually having left-factored it. I'm not sure how to approach this - I can't seem to eliminate <i>some</i> nonterminal having multiple productions starting with a + and with a -.</p>\n", 'ViewCount': '2109', 'Title': 'Left-Factoring a grammar into LL(1)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:21:31.690', 'LastEditDate': '2014-01-23T17:21:31.690', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '4873', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3049', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-10-03T19:44:14.687', 'Id': '4862''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a formula $ \\neg((q \\implies \\neg q) \\vee p \\vee (\\neg q \\implies (r \\wedge p))) $.</p>\n\n<p>As it contains 3 subformulas between the $\\vee$'s, how can i put it into a parse tree, as a parse tree contains 2 branches from each node.</p>\n", 'ViewCount': '242', 'Title': 'How to make a parse tree for the following propositional logic formula?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T09:21:21.817', 'LastEditDate': '2012-10-07T16:22:33.433', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '4921', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3088', 'Tags': '<formal-languages><logic><binary-trees><parsing>', 'CreationDate': '2012-10-07T12:33:25.243', 'Id': '4918''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '702', 'Title': 'Closure of Deterministic context-free languages under prefix', 'LastEditDate': '2012-10-07T17:36:51.877', 'AnswerCount': '3', 'Score': '2', 'OwnerDisplayName': 'Sam Jones', 'PostTypeId': '1', 'OwnerUserId': '769', 'Body': "<p>For a formal language $L \\subseteq \\Sigma^{*}$ I define the set Pref(L) to be:</p>\n\n<p>$\\text{pref}(L) = \\{\\alpha \\in \\Sigma^{*} : \\exists \\beta \\in \\Sigma^{*} \\text{ such that } \\alpha \\beta \\in L\\}$</p>\n\n<p>ie. the set of all (not necessarily proper) prefixes of words in $L$. I know that if $L$ is context-free then pref(L) is context-free but if $L$ is deterministic context-free then is pref(L) deterministic context-free?</p>\n\n<p>I am sure this is known but I cannot find the answer anywhere and it's not in Hopcroft and Ullman.</p>\n", 'Tags': '<formal-languages><context-free><closure-properties>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-18T13:23:08.777', 'CommentCount': '6', 'AcceptedAnswerId': '4925', 'CreationDate': '2012-01-15T21:51:40.653', 'Id': '4924''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There are two context-sensitive languages, $L_1$ and $L_2$. Which of the following statements about them are decidable respectively undecidable?</p>\n\n<ol>\n<li>$L_1 = \\emptyset$</li>\n<li>$L_1 = \\Sigma^*$</li>\n<li>$L_1 \\cap L_2 = \\emptyset$</li>\n<li>$\\overline{L_1}$ is also a context-sensitive language.</li>\n<li>$L_1 = L_2$</li>\n</ol>\n', 'ViewCount': '238', 'Title': 'Which properties of context sensitive languages are decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-10T14:20:05.680', 'LastEditDate': '2012-10-10T14:17:55.793', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4997', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3138', 'Tags': '<formal-languages><undecidability><context-sensitive>', 'CreationDate': '2012-10-10T09:17:09.567', 'Id': '4992''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '188', 'Title': 'Represent string as concatenations', 'LastEditDate': '2012-10-18T02:50:57.417', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '220', 'FavoriteCount': '1', 'Body': "<p>If $S_1,S_2$ are set of strings, then $S_1S_2 = \\{s_1s_2|s_1\\in S_1, s_2\\in S_2\\}$. $S^0=\\{\\epsilon\\}$, $\\epsilon$ is the empty string. $S^n = S^{n-1}S$. </p>\n\n<p>Two related problems about represent string as concatenation of other strings. </p>\n\n<ol>\n<li><p>Given a finite set $S$ of strings, how to decide if there exist a string can be written as concatenations of elements in $S$ in two different ways?</p></li>\n<li><p>Given a finite set $S$ of strings and $n$, how can one compute the smallest set of strings $T$, such that $S\\subset T^n$?</p></li>\n</ol>\n\n<p>(Bonus: what about infinite $S$, at least when it's regular? For the second problem when $S$ is infinite, we might ask to find a minimal $T$ under set inclusion.)</p>\n", 'Tags': '<algorithms><formal-languages><strings>', 'LastEditorUserId': '220', 'LastActivityDate': '2012-10-20T12:24:21.363', 'CommentCount': '6', 'AcceptedAnswerId': '6190', 'CreationDate': '2012-10-16T22:30:32.147', 'Id': '6114''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>$L_0 = \\{ \\langle M, w, 0 \\rangle \\mid \\text{$M$ halts on $w$}\\}$ <br>\n  $L_1 = \\{ \\langle M, w, 1 \\rangle \\mid \\text{$M$ does not halt on  $w$}\\}$</p>\n  \n  <p>$L = L_0 \\cup L_1$</p>\n</blockquote>\n\n<p>I need to determine where in the hierarchy of languages (recursive, recursively enumerable, not recursively enumerable) $L$ and its complement $\\overline L$ belong. I reasoned as follows</p>\n\n<p>$L = \\{ \\langle M, w, x\\rangle  \\mid \\text{$M$ halts on $w$ when $x=0$, $M$ doesn't halt on $w$ when $x = 1$, $x \\in \\{0, 1\\}$}\\}$</p>\n\n<p>$L$ is clearly not recursively enumerable as a Turing machine wouldn't be able accept in all cases.  It can accept only in case the input refers to $L_0$, but can't in case the input refers to $L_1$.</p>\n\n<p>$\\overline L = \\overline L_0 \\cap \\overline L_1 = \\emptyset$<br>\nThus $\\overline L$ is recursive.</p>\n\n<p>Is my reasoning ok? This is a question from a previous exam paper.</p>\n", 'ViewCount': '121', 'Title': 'Determining the classification of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-26T14:27:29.443', 'LastEditDate': '2012-10-26T14:27:29.443', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6310', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><turing-machines><undecidability><halting-problem>', 'CreationDate': '2012-10-25T13:39:53.527', 'Id': '6309''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '89', 'Title': 'Language member explanation', 'LastEditDate': '2012-10-26T13:05:31.857', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'wildplace', 'PostTypeId': '1', 'OwnerUserId': '4379', 'Body': '<p>Given the following formal language $L$:</p>\n\n<p>$$    L=\\{ww \\mid w\\in\\{a,b\\}^*\\}$$</p>\n\n<p>Why is $a$ not a member of this language?</p>\n\n<p>So what is $\\{a,b\\}^*$ exactly? I thought it means $(a+b)^*$?</p>\n', 'Tags': '<formal-languages><terminology><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-26T13:05:31.857', 'CommentCount': '1', 'AcceptedAnswerId': '6316', 'CreationDate': '2012-10-25T15:09:04.310', 'Id': '6312''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can one formally prove</p>\n\n<p>$L \\cdot L^{*} = L^{+}$</p>\n\n<p>It looks obvious to me since with the concatenation you get rid of $\\varepsilon$, but I cannot think of a formal proof through induction or something.</p>\n', 'ViewCount': '102', 'Title': 'How to prove $L \\cdot L^{*} = L^{+}$', 'LastActivityDate': '2012-10-31T01:59:17.723', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '6398', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4403', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-10-30T18:00:23.283', 'Id': '6391''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Show that $L_2=\\{a^nb^k|n\\not= k-1\\}$ is not regular by Pumping Lemma.</p>\n', 'ViewCount': '38', 'ClosedDate': '2012-10-31T06:35:19.720', 'Title': 'Show that a language is not regular by Pumping Lemma', 'LastActivityDate': '2012-10-31T05:13:17.603', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3146', 'Tags': '<formal-languages><automata><regular-languages><pumping-lemma>', 'CreationDate': '2012-10-31T05:13:17.603', 'Id': '6400''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to teach myself computability theory with a textbook. According to my book, a function $f$ over an alphabet $A=\\{a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\\}$ is only computable iff the language</p>\n\n<p>$$\nL = \\{s\\#^j\\sigma : s\\in A^*, \\sigma \\in A, \\text{ the }j\\text{'th symbol of } f(s)\\text{ is } \\sigma\\}$$</p>\n\n<p>is decidable. Why is that? Couldn't a function $f$ be not computable even if $L$ is decidable?</p>\n", 'ViewCount': '102', 'Title': 'Can $f$ be not computable even if $L$ is decidable?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-31T21:55:23.710', 'LastEditDate': '2012-10-31T21:55:23.710', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6407', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4414', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2012-10-31T21:31:58.657', 'Id': '6406''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '310', 'Title': 'Context Free Grammar for language', 'LastEditDate': '2012-11-02T07:05:25.063', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4365', 'FavoriteCount': '1', 'Body': "<p>The language is $L = \\{a^{i} b^{j} c^{k} \\;|\\; k \\neq 2j\\}$. I'm trying to write a grammar for this language, what I have so far is:</p>\n\n<p>$S \\rightarrow AT_{1} \\;|\\; AT_{2} \\;|\\; AT_{3} \\;|\\; AB \\;|\\; AC$</p>\n\n<p>$A \\rightarrow aA \\;|\\; \\varepsilon$ </p>\n\n<p>$B \\rightarrow bB \\;|\\; \\varepsilon$</p>\n\n<p>$C \\rightarrow cC \\;|\\; \\varepsilon$</p>\n\n<p>$T_{1} \\rightarrow bbB'T_{1}c \\;|\\; \\varepsilon $   (for $2j &gt; k$)(1)</p>\n\n<p>$B' \\rightarrow bB' \\;|\\; b$</p>\n\n<p>$T_{2} \\rightarrow bT_{2}ccC'\\;|\\; \\varepsilon$ (for $2j &lt; k$)</p>\n\n<p>$C' \\rightarrow cC' \\;|\\; c$</p>\n\n<p>$T_{3} \\rightarrow bT_{3}c \\;|\\; \\varepsilon$ (for $j = k$)</p>\n\n<p>the problem that I am having is, the string $bbccc$  can't be generated although valid, in that case $j = 2$ and $k = 3$  so $2\\times 2 &gt; 3$  corresponding to production rule (1), how can I fix this?</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T11:05:27.533', 'CommentCount': '4', 'AcceptedAnswerId': '6439', 'CreationDate': '2012-11-01T04:09:50.207', 'Id': '6415''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been studying for an exam I have tomorrow, and I was looking through some previous sample exam questions, when I came across this problem:</p>\n\n<blockquote>\n  <p>Give a non-regular language $L$ such that $L \\cup L^R$ is regular.</p>\n</blockquote>\n\n<p>I've been sitting here and thinking and thinking, and I can't seem to come up with a situation where this is valid. I've determined a few things based on my understanding of non-regular languages, as well as the problem itself:</p>\n\n<ul>\n<li>$L$ must be infinite.</li>\n<li>$L$ must involve some kind of counting.</li>\n<li>$L$ must contain multiple letters (i.e. it cannot be composed of entirely $a$s).</li>\n</ul>\n\n<p>Given this, I went through a few basic possibilities:</p>\n\n<ul>\n<li>$a^ib^i$ : This would result in $L \\cup L^R$ being irregular also.</li>\n<li>$(ab)^i(ba)^i$ (or something else palindromic) : Again, this would result in $L \\cup L^R$ being irregular also. (Any palindrome would, as $L = L^R$.)</li>\n<li>$a^pb^q$ (where $p$ and $q$ are prime) : This, too, would result in $L \\cup L^R$ being irregular also, though it would be a very much broader language, which I think is a step in the right direction.</li>\n</ul>\n\n<p>After I got this far, I think the key is in creating some language that, when unioned with itself, forms something akin to $a^*b^*$ or $(ab)^*$. The broader the words within the language, the easier it seems to define. But I can't seem to quite wrap my head around doing this.</p>\n\n<p>Does anyone have a hint/spoiler or possible solution to this?</p>\n\n<p><em>(NB: My professor does not post solutions.)</em></p>\n", 'ViewCount': '169', 'Title': 'Find non-regular $L$ such that $L \\cup L^R$ is regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T14:28:03.440', 'LastEditDate': '2012-11-01T14:28:03.440', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '6421', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2827', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-11-01T05:15:17.320', 'Id': '6418''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '114', 'Title': 'Proving the language of words with equal numbers of symbols non-context-free', 'LastEditDate': '2012-11-01T14:33:00.413', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Body': u'<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/265/how-to-prove-that-a-language-is-not-context-free">How to prove that a language is not context-free?</a>  </p>\n</blockquote>\n\n\n\n<p>I\'m having a hard time figuring this out, any help is appreciated. </p>\n\n<p>Let EQUAL be the language of all words over $\\Sigma = \\{a,b,c\\}$ that have the same number of $a$\u2019s, $b$\u2019s and $c$\u2019s</p>\n\n<p>$\\qquad \\text{EQUAL} = \\{ w \\in \\Sigma^* \\mid |w|_a = |w|_b = |w|_c \\}$</p>\n\n<p>The order of the letters doesn\'t matter. How can you prove that EQUAL is non-context-free?</p>\n', 'ClosedDate': '2012-11-01T14:35:50.797', 'Tags': '<formal-languages><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T14:33:00.413', 'CommentCount': '2', 'AcceptedAnswerId': '6426', 'CreationDate': '2012-11-01T06:28:49.280', 'Id': '6419''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a beginners question. I and reading the book "Introduction to Computer Theory" by Daniel Cohen. But I end up with confusion regarding simplification of regular expressions and finite automata. I want to create an FA for the regular expression</p>\n\n<p>$\\qquad \\displaystyle (a+b)^* (ab+ba)^+a^+\\;.$</p>\n\n<p>My first question is that how we can simplify this expression? Can we we write the middle part as $(ab+ba)(ab+ba)^*$? will this simplify the expression?</p>\n\n<p>My second question is whether the automaton given below is equivalent to this regular expression? If not, what is the mistake?</p>\n\n<p><img src="http://i.stack.imgur.com/m4Agi.png" alt="enter image description here"></p>\n\n<p>This is not a homework but i want to learn this basic example. And please bear me as a beginner.</p>\n', 'ViewCount': '996', 'Title': 'Simplification of regular expression and conversion into finite automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T17:25:30.637', 'LastEditDate': '2012-11-02T10:10:37.237', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '6450', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<formal-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-11-02T08:12:01.797', 'Id': '6443''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So I\'ve been scratching my head over this problem for a couple of days now.  Given some language $A$ and $B$ that is regular, show that the language $L$ which consists of all strings in $A$ whose length is equal to some string in $B$ is a regular language.</p>\n\n<p>In equation form:</p>\n\n<p>$$L = \\{x \\in A \\mid \\exists y \\in B \\text{ s.t. } |x| = |y| \\}$$</p>\n\n<p>My initial thought was to try and come up with some DFA for both languages $A$ and $B$ and map the two states to each other and hopefully get a 1:1 ratio that way I can generate a new DFA which proves that $L$ is regular.  But then I realized that $A$ and $B$ don\'t have to be over the same set of symbols.  </p>\n\n<p>I think the correct way to solve this is to use the closure properties of regular language, but I\'m not sure of how to begin/use the properties for "lengths" of strings instead of strings themselves.  </p>\n\n<p>Could someone point me in the right direction?</p>\n', 'ViewCount': '255', 'Title': 'Proving the language which consists of all strings in some language is the same length as some string in another language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-08T04:07:41.613', 'LastEditDate': '2012-11-05T08:20:14.120', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4463', 'Tags': '<formal-languages><regular-languages><finite-automata><proof-techniques><closure-properties>', 'CreationDate': '2012-11-05T05:52:51.367', 'Id': '6484''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '519', 'Title': 'what is semantics?', 'LastEditDate': '2012-11-12T17:00:04.110', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2879', 'FavoriteCount': '2', 'Body': '<p>There are many popular languages. But, computer scientists tell us that in order to understand the behaviour of programs in those languages definitely and unambiguously argue upon program behavior (e.g. prove their identity), we need to translate them into another, well understood language. They call such language "a semantics". Authors propose one of many semantics. They explain the meaning of their constructions and how you can translate your language into their. Once you do that, everybody will understand your program certainly, they say. </p>\n\n<p>Looks good, yet, I do not understand something. Do they tell us that they introduce another language to understand the first one? Why do we understand it better than the original one? Why this semantics is better than that? Why not to learn semantics of C right away instead of inventing another language, for describing semantics of C? The same applies to the syntax. Why don\'t I ask the same question regarding the syntax?</p>\n\n<p><strong>PS</strong> In the comments I hear that semantics does not mean another language or translation into it. But Formal Semantics for VHDL says that if you understand something in only one way then you do not understand it and "meaning of meaning" can be specified if we supply a language with a mechanism that translates it into another (known) language. That is, "semantics is a Relation between formal systems". Hennessy, in <a href="https://www.scss.tcd.ie/Matthew.Hennessy/slexternal/resources/sembookWiley.pdf" rel="nofollow">Semantics of Programming Languages</a>, says that semantics allows for formal processing of the program "meaning", when semantics is supplied as BNF or Syntax Diagram. What is a formal system if not a language? </p>\n\n<p><strong>PS2</strong> Can I say that HW synthesis of given HDL program into interconnection of gates, is a process of semantics extraction? We translate (high-level) description into the (low-level) language that we understand, afterwards.</p>\n', 'Tags': '<formal-languages><semantics>', 'LastEditorUserId': '2879', 'LastActivityDate': '2012-11-12T17:00:04.110', 'CommentCount': '8', 'AcceptedAnswerId': '6518', 'CreationDate': '2012-11-06T16:41:54.460', 'Id': '6517''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '550', 'Title': 'Inherent ambiguity of the language $L_2 = \\{a^nb^mc^m \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^m \\;|\\; m,n \\geq 1\\}$', 'LastEditDate': '2012-11-09T06:57:09.207', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4422', 'FavoriteCount': '0', 'Body': "<p>I went through a question asking me to choose the inherently ambiguous language among a set of options.</p>\n\n<p>$$L_1 = \\{a^nb^mc^md^n \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^md^m \\;|\\; m,n \\geq 1\\}$$\n$$and$$\n$$L_2 = \\{a^nb^mc^m \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^m \\;|\\; m,n \\geq 1\\}$$</p>\n\n<p>The solution said that $L_1$ is ambiguous while $L_2$ isn't. It generated the following grammar for $L_1$</p>\n\n<p>$S \\rightarrow S_1\\;|\\;S_2$</p>\n\n<p>$S_1 \\rightarrow AB$</p>\n\n<p>$A \\rightarrow aAb\\;|\\;ab$</p>\n\n<p>$B \\rightarrow cBd\\;|\\;cd$</p>\n\n<p>$S_2 \\rightarrow aS_2d\\;|\\;aCd$</p>\n\n<p>$C \\rightarrow bCc\\;|\\;bc$</p>\n\n<p>Now for the string <code>abcd</code>, it will generate two parse trees; so it is ambiguous.</p>\n\n<p>But a similar grammar can be created for $L_2$ too</p>\n\n<p>$S \\rightarrow S_1|S_2$</p>\n\n<p>$S_1 \\rightarrow Ac$</p>\n\n<p>$A \\rightarrow aAb\\;|\\;\\epsilon$</p>\n\n<p>$S_2 \\rightarrow aB$</p>\n\n<p>$B \\rightarrow bBc\\;|\\;\\epsilon$</p>\n\n<p>And it will also generate two parse trees for <code>abc</code>. Why isn't it ambiguous then?</p>\n\n<p>If you need,\n$L_2$ can be written as $\\{a^nb^pc^m\\;|\\; n=p \\;\\; or \\;\\; m=p\\}$</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free><ambiguity>', 'LastEditorUserId': '4422', 'LastActivityDate': '2012-11-09T06:57:09.207', 'CommentCount': '4', 'AcceptedAnswerId': '6573', 'CreationDate': '2012-11-09T04:40:14.713', 'Id': '6568''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am getting confused by the regular expression $(a\\mid b)^*$ as it for sure matches $aab$ and $ab$.</p>\n\n<p>Does $(a\\mid b)^*$ also match strings like $aa$, $aaaa$, $bb$ or $bbb$, that is those that use only $a$ or $b$?</p>\n', 'ViewCount': '118', 'Title': 'Does $(a \\mid b)^*$ match $a^n$ and $b^n$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-09T16:55:18.487', 'LastEditDate': '2012-11-09T07:55:22.077', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Sudhir', 'PostTypeId': '1', 'Tags': '<formal-languages><terminology><regular-expressions>', 'CreationDate': '2012-11-09T06:03:29.180', 'Id': '6569''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m unclear about the use of the phrases "infinite" language or "finite" language in computer theory.</p>\n\n<p>I think the root of the trouble is that a language like $L=\\{ab\\}^*$ is <strong>infinite</strong> in the sense that it can generate an infinite (but countable) number of strings. Yet, it can still be recognized by a <strong>finite</strong> state automaton. </p>\n\n<p>It also doesn\'t help that the Sipser book doesn\'t really make this distinction (at least as far as I can tell). A question about infinite/finite languages and their relationship to regular languages came up in a sample exam.</p>\n', 'ViewCount': '3132', 'Title': 'Infinite Language vs. finite language', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-12T16:08:33.073', 'LastEditDate': '2012-11-11T00:49:47.817', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4547', 'Tags': '<formal-languages><terminology><regular-languages>', 'CreationDate': '2012-11-10T23:43:32.613', 'FavoriteCount': '2', 'Id': '6609''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '533', 'Title': 'How do I show that whether a PDA accepts some string $\\{ w!w \\mid w \\in \\{ 0, 1 \\}^*\\}$ is undecidable?', 'LastEditDate': '2012-11-12T11:36:31.860', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2860', 'FavoriteCount': '1', 'Body': "<p>How do I show that the problem of deciding whether a PDA accepts some string of the form $\\{ w!w \\mid w \\in \\{ 0, 1 \\}^*\\}$ is undecidable?</p>\n\n<p>I have tried to reduce this problem to another undecidable one such as whether two context-free grammars accept the same language. However, I'm not sure how to use it as a subroutine.</p>\n", 'Tags': '<formal-languages><automata><context-free><undecidability><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-23T22:02:29.330', 'CommentCount': '0', 'AcceptedAnswerId': '6630', 'CreationDate': '2012-11-12T05:00:51.627', 'Id': '6626''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/4752/prove-that-the-complement-of-0n1n-mid-n-geq-0-is-not-regular-using">Prove that the complement of  $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties</a>  </p>\n</blockquote>\n\n\n\n<p>Is $L=\\{ a^nb^m \\mid n,m \\ge 0, n\\ne m\\}$ a regular language?  </p>\n\n<p>I think it is but can\'t prove it.</p>\n', 'ViewCount': '324', 'ClosedDate': '2012-11-19T22:15:48.150', 'Title': 'Is $\\{a^nb^m \\mid n,m\\ge 0, n\\ne m\\}$ regular or not?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-14T21:30:01.330', 'LastEditDate': '2012-11-14T14:32:35.997', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4586', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-11-14T06:00:37.603', 'Id': '6656''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently working on this question as part of some homework, it has me stumped.</p>\n\n<p><img src="http://i.stack.imgur.com/taFpH.png" alt="FSA Question"></p>\n\n<p>I\'m familiar with finite state automata (FSA), I know how they work and I\'ve read everything I can find on Google, but nothing\'s helped me come any closer to a solution.</p>\n\n<p>If I don\'t know the length of the input string, or I\'m not searching for a particular pattern, how can I design a machine that will always land on the final state? </p>\n\n<p>I\'ve tried drawing some, but that always end up being a little off. </p>\n', 'ViewCount': '71', 'Title': 'Finite State Automata for recognising consecutive characters', 'LastEditorUserId': '1636', 'LastActivityDate': '2012-11-17T09:02:53.670', 'LastEditDate': '2012-11-17T09:02:53.670', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6709', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4623', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2012-11-17T05:05:50.290', 'Id': '6704''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I gotta make a CFG and PDA for the grammar that has perfectly nested parentheses and brackets.</p>\n\n<p>$\\qquad\\begin{align}\n S &amp;\\to [S] \\\\\n S &amp;\\to (S) \\\\\n S &amp;\\to SS \\\\\n S &amp;\\to \\varepsilon\n\\end{align}$</p>\n\n<p>Not sure if this is correct, or how to make the PDA from it?</p>\n', 'ViewCount': '219', 'Title': 'CFG and PDA for the grammar that has perfectly nested parentheses and brackets', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T18:12:47.330', 'LastEditDate': '2012-11-19T18:12:47.330', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4632', 'Tags': '<formal-languages><automata><formal-grammars><context-free><pushdown-automata>', 'CreationDate': '2012-11-17T18:39:11.147', 'Id': '6719''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am having diffuculties understanding the principle of lookahead in LR(1) - items. How do I compute the lookahead sets ? </p>\n\n<p>Say for an example that I have the following grammar:</p>\n\n<p>S -> AB\nA -> aAb | b\nB -> d</p>\n\n<p>Then the first state will look like this:</p>\n\n<pre><code>S -&gt; .AB , {look ahead}\nA -&gt; .aAb, {look ahead}\nA -&gt; .b, {look ahead}\n</code></pre>\n\n<p>I now what look aheads are, but I don't know how to compute them. I have googled for answers but there isn't any webpage that explains this in a simple manner.</p>\n\n<p>Thanks in advance </p>\n", 'ViewCount': '500', 'Title': 'LR(1) - Items, Look Ahead', 'LastActivityDate': '2014-01-28T11:28:50.617', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6772', 'Score': '2', 'OwnerDisplayName': 'mrjasmin', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><formal-grammars><context-free><parsing>', 'CreationDate': '2012-11-19T18:00:06.743', 'Id': '6771''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am studying formal languages and playing with writing my own parsers for them. I have a context free grammar parser already that works well. I am wondering if anyone can point me towards actually implemented examples of rewriters. For example, suppose I had the rules</p>\n\n<p>WORD: [A-Z]+</p>\n\n<p>QUOTE: "</p>\n\n<p>And I wanted to input a lot of words,put quotes around each one, and write out the string. Or go back and forth. Something like this:</p>\n\n<p>(WORD [\' \'])+   &lt;--> (QUOTE WORD QUOTE [\' \'])+</p>\n\n<p>That seems kind of possible to implement automatically without ambiguity, but I was hoping someone had seen something along that line that already exists.</p>\n', 'ViewCount': '107', 'Title': 'Example of a parsing/rewriting system?', 'LastActivityDate': '2012-11-22T06:56:28.430', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4657', 'Tags': '<formal-languages><parsers><term-rewriting>', 'CreationDate': '2012-11-21T11:23:56.357', 'Id': '6808''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '659', 'Title': u'G\xf6delization in Turing Machine', 'LastEditDate': '2012-11-25T07:38:35.780', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': u"<p>I was looking at G\xf6delization in Theory of Computation course. I could understand the G\xf6del numbering concepts, but couldn't understand its importance in Theory of Computation. Could anyone please point to some good materials or point out its importance.</p>\n", 'Tags': '<formal-languages><turing-machines>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-25T15:51:21.857', 'CommentCount': '0', 'AcceptedAnswerId': '6889', 'CreationDate': '2012-11-25T07:12:46.033', 'Id': '6883''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So I would like to show that the class of Recursively Enumerable languages are closed under the shrink operation. In other words, $\\text{shrink}_a(L) = \\{\\text{shrink}_a(w)\\mid w\\in L\\}$ and where $\\text{shrink}_a(w)$ is the string formed from $w$ by replacing every maximal substring of two or more $a$\'s by a single a. For example, $\\text{shrink}_a(baaab) = bab$.</p>\n\n<p>So I was browsing around for other examples to study, and I came across the following proof for the <strong>prefix</strong> operation: <a href="http://cs.stackexchange.com/questions/1731/proving-that-recursively-enumerable-languages-are-closed-against-taking-prefixes">Proving that recursively enumerable languages are closed against taking prefixes</a> (the proof given by the user Wu Yin). I thought that this was a very cool way of proving something like this, instead of just directly building an alternate TM. I\'m curious to know, can anyone come up with a proof that is of a similar style and flavor to the one pointed above? I would be very curious to see a similar bijective proof regarding countable/uncountable sets!!</p>\n\n<p>This has reminded me that there can be many ways to prove something, so I wanted to see what kind of flavor other people\'s proofs might have to this sample problem. I find that too often, students (and myself included) get caught up in a single procedure for finding solutions to a particular type of problem and neglect to see other ways of showing the same result.</p>\n', 'ViewCount': '195', 'Title': 'Seeking Alternate Proof Regarding Closure Of Recursively Enumerable Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-28T17:38:40.397', 'LastEditDate': '2012-11-26T11:46:51.627', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '6920', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<formal-languages><computability><proof-techniques><closure-properties>', 'CreationDate': '2012-11-26T06:27:42.250', 'Id': '6907''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>$L_1$ is a recursively enumerable language over some alphabet\n  $\\Sigma$. An algorithm effectively enumerates its words as $w_1, w_2, ...$. <br> $L_2$ is another language over $\\Sigma \\cup \\{\\#\\}$ as\n  $\\{w_i\\#w_j : w_i, w_j \\in L_1, i &lt; j\\}$<br> Consider the following\n  assertions.</p>\n  \n  <ol>\n  <li>$L_1$ is recursive implies $L_2$ is recursive</li>\n  <li>$L_2$ is recursive implies $L_1$ is recursive</li>\n  </ol>\n  \n  <p>Which statements is/are true?</p>\n</blockquote>\n\n<p>I reasoned both the statements to be true.</p>\n\n<p>Statement 1 is true. $L_1$ is recursive means it can lexicographically enumerate its strings. The membership question for $L_2$ can be easily settled using the decider and lexicographic enumerator of $L_1$.</p>\n\n<p>Statement 2 is true. The algorithm which decides $L_2$ can be modified to accept if the input string matches either $w_i$ or $w_j$. This settles the membership question for $L_1$.</p>\n\n<p>The given solution to this question however says that statement 2 is false. Could you let me know if my reasoning has gone wrong someplace?</p>\n', 'ViewCount': '163', 'Title': 'Decidability of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-27T21:39:04.723', 'LastEditDate': '2012-11-26T14:57:24.467', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '6930', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><computability>', 'CreationDate': '2012-11-26T13:17:04.930', 'Id': '6917''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Identify the language given by $L = \\{ x \\in (0,1)^* : x \\neq ww^R, w \\in (0,1)^*\\}$. Note: $w^R$ is the reverse of the string $w$.</p>\n\n<p>Closure property can/should be applied only in the cases when the actual language is not specified. Otherwise, you may arrive at wrong conclusions. The language in question is fully specified, so I doubt whether one can directly apply closure property on $ww^R$, which you say, is its complement or vice versa. The given answer is CFL. But I don't seem to have arrived at it satisfactorily.</p>\n", 'ViewCount': '541', 'Title': 'Is the complement of $ww^R$ context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-05T15:18:31.827', 'LastEditDate': '2012-12-01T14:28:40.913', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4763', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2012-11-27T18:33:56.610', 'Id': '6960''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to study for an exam and having difficulty with the following practice questions. Any help would be appreciated.</p>\n\n<ol>\n<li>Give a language $L$ such that $L$ is not recursive but $\\text{prefix}(L)$ is regular.</li>\n<li>Give two languages $L_1$ and $L_2$, such that $L_1$ and $L_2$ are not recursive, but $L_1\\cap L_2$ is recursive.</li>\n<li>Give a language $L$ such that $L$ is regular but $\\text{unary}(L)$ is not context-free.</li>\n</ol>\n", 'ViewCount': '119', 'Title': 'Recursive and regular languages', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-27T21:28:14.270', 'LastEditDate': '2012-11-27T20:39:13.353', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4767', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2012-11-27T20:16:52.957', 'Id': '6965''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Consider the following language over the alphabet $\\mathcal{A} = \\{a,b,c\\}$:\n$$L = \\left\\{w \\in \\mathcal{A}^* \\mid \\text{\\(|w|\\) is odd and the middle character in \\(w\\) occurs nowhere else in \\(w\\)} \\right\\}$$</p>\n\n<p>I am trying to come up with a grammar for $L$, but I'm getting nowhere. I came up with some sample strings from the language which would be accepted: <code>b</code>, <code>abcab</code>, <code>accbcaa</code> \nI understand the length of the string has to be odd, and the middle character cannot be repeated anywhere in the string.</p>\n\n<p>Therefore, the above three strings are accepted. However, something like <code>aabbb</code> will not accepted, because even though the length is odd, the middle character is repeated.</p>\n\n<p>Can someone help with a grammar for $L$?</p>\n", 'ViewCount': '135', 'Title': 'Grammar for a language: odd length, middle character not repeated', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-29T20:59:19.760', 'LastEditDate': '2012-11-29T20:59:19.760', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4767', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-11-29T17:30:13.993', 'Id': '7019''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for a proof for the following problem:</p>\n\n<blockquote>\n  <p>For languages $L$ and $R$, if $L$ is <a href="http://en.wikipedia.org/wiki/Deterministic_context-free_language" rel="nofollow">deterministic context-free</a>\n  and $R$ is regular, then $LR$ is a deterministic context-free\n  language.</p>\n</blockquote>\n\n<p>Note: $RL$ may not satisfy this condition, e.g. if $L=\\{wcw^R\\mid w\\in (a|b)^*\\}$, and $R=\\{a\\}^*$.</p>\n', 'ViewCount': '316', 'Title': 'Deterministic context-free languages are closed under regular right-product', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-30T20:19:21.433', 'LastEditDate': '2012-11-30T20:19:21.433', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4486', 'Tags': '<formal-languages><context-free><closure-properties><pushdown-automata>', 'CreationDate': '2012-11-30T10:53:41.263', 'Id': '7041''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have found an efficient algorithm for verifying if a string $\\omega$ is of the form $0^n1^n$, where $n \\in \\mathbb{N}$.</p>\n\n<ol>\n<li>Scan across $\\omega$. If a 1 appears before a 0, then reject.</li>\n<li><p>Repeat so long as some 0s and some 1s remain on the tape.</p>\n\n<ol>\n<li>Scan across $\\omega$. If the total number of 0s and 1s remaining is odd, reject.</li>\n<li>Scan across $\\omega$. Cross out every other 0 starting with the first 0.</li>\n<li>Scan across $\\omega$. Cross out every other 1 starting with the first 1.</li>\n</ol></li>\n<li><p>If no 0s and 1s remain in $\\omega$, accept. Otherwise, reject.</p></li>\n</ol>\n\n<p>I generally see how this algorithm is efficient. It gets rid of half of all 1s and 0s every iteration. How does it work though? Why must we reject if the total number of 0s and 1s remaining in $\\omega$ is odd?</p>\n', 'ViewCount': '55', 'Title': 'How does this algorithm for verifying if a string is $0^n1^n$ work?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-01T13:59:35.667', 'LastEditDate': '2012-12-01T13:59:35.667', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7057', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<algorithms><formal-languages>', 'CreationDate': '2012-11-30T22:54:59.930', 'Id': '7055''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have devised the following TM for the language EQUAL. </p>\n\n<p>EQUAL accepts all strings with the same number of a\'s and b\'s. It is context free but non regular. </p>\n\n<p>Using the TM I devised, how can I show that EQUAL is recursive? How can I show that it crashes when the input is not in EQUAL.</p>\n\n<p><img src="http://i.stack.imgur.com/81uEa.png" alt="enter image description here"></p>\n', 'ViewCount': '247', 'LastEditorDisplayName': 'user3115', 'Title': 'Show the Language is Recursive', 'LastActivityDate': '2012-12-02T20:07:52.897', 'LastEditDate': '2012-12-02T19:25:52.953', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7110', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><turing-machines>', 'CreationDate': '2012-12-01T00:44:52.273', 'Id': '7061''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '24', 'Title': 'CFL complement Theory Of Computation', 'LastEditDate': '2012-12-01T10:31:47.943', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'user1771809', 'PostTypeId': '1', 'OwnerUserId': '4763', 'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/6960/complement-of-cfl">complement of CFL</a>  </p>\n</blockquote>\n\n\n\n<p>Identify the language given by $L=\\{x \\in \\{0,1\\}^* \\mid x\\neq ww^R , w\\in\\{0,1\\}^*\\}$.\nNote: $w^R$ is the reverse of the string $w$.</p>\n\n<p>Closure property can/should be applied only in the cases when the actual language is not specified. Otherwise, you may arrive at wrong conclusions. The language in question is fully specified, so I doubt whether one can directly apply closure property on $w=w^R$, which you say, is its complement or vice versa.C\nThe given answer is CFL. But I dont seem to have arrived at it satisfactorily.</p>\n', 'ClosedDate': '2012-12-01T14:27:13.350', 'Tags': '<formal-languages><context-free>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-01T10:31:47.943', 'CommentCount': '3', 'CreationDate': '2012-11-26T13:31:52.810', 'Id': '7070''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Let $P$ be a regular language and $Q$ be a context-free language such\n  that $Q \\subseteq P$(For example, let $P =  a^*b^*$ and $Q = \\{ a^nb^n | n \\ge 0\\}$). Then which of the following is always regular?</p>\n  \n  <ol>\n  <li>$P \\cap Q$</li>\n  <li>$P - Q$</li>\n  <li>$\\Sigma^* - Q$</li>\n  <li>$\\Sigma^* - P$</li>\n  </ol>\n</blockquote>\n\n<p><strong>Option 1</strong> <br>\n$P \\cap Q = Q$ as $P \\subseteq Q$. Thus $P \\cap Q$ is context-free.</p>\n\n<p><strong>Option 2</strong> <br>\nI was not able to generally reason here. I used the example mentioned in the question.<br>\nLet  $P =  a^*b^* $ and $Q = \\{ a^nb^n | n \\ge 0\\}$. <br>\n$P - Q = \\{a^nb^m | n \\neq m\\}$ which is not regular but only context-free.</p>\n\n<p><strong>Option - 3</strong><br>\nLet $\\Sigma = \\{ a, b\\}$ and $Q = \\{ a^nb^n | n \\ge 0\\}$. <br>\nAgain $\\Sigma^* - Q =  \\{a^nb^m | n \\neq m\\} $ which is not regular but only  context-free.</p>\n\n<p>Thus, the 4th option must be right, $\\Sigma^* - P$ is regular. I am however unable to understand this result intuitively. Could somebody explain?</p>\n', 'ViewCount': '104', 'Title': 'Closure properties of languages', 'LastEditorUserId': '2980', 'LastActivityDate': '2012-12-27T06:01:51.860', 'LastEditDate': '2012-12-27T06:01:51.860', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7119', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2012-12-03T09:28:15.073', 'Id': '7118''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need to know what class of CFL is closed under i.e. what set is complement of CFL.\nI know CFL is not closed under complement, and I know that P is closed under complement. Since CFL $\\subsetneq$ P I can say that complement of CFL is included in P(right?). There is still a question whether complement of CFL is proper subset of P or the whole P. I would appreciate any ideas on how to show that complement of CFL is the whole P(if that's the case of course). </p>\n", 'ViewCount': '1022', 'Title': 'What is complement of Context-free languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-05T02:26:08.850', 'LastEditDate': '2012-12-04T16:52:22.483', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7146', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4859', 'Tags': '<complexity-theory><formal-languages><context-free><closure-properties><sets>', 'CreationDate': '2012-12-04T01:48:38.370', 'Id': '7144''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is the language $L=\\{ xyx^Ry^R \\mid x,y \\text{ is an element of }\\{0,1\\}^*\\}$ context-free? </p>\n\n<p>Note: $x^R$ is the reverse of $x$.</p>\n\n<p><strong>My Work:</strong> I think this is a context free language. Since a <a href="http://en.wikipedia.org/wiki/Pushdown_automaton" rel="nofollow">pushdown automaton</a> (PDA) accepts <a href="http://en.wikipedia.org/wiki/Context-free_language" rel="nofollow">context-free languages</a>, I am trying to draw a PDA for this language. When I draw a PDA, how does the PDA tell $x$ and $y$ apart? \nOr is this not a context-free language? (then I can use pumping length to prove this)</p>\n', 'ViewCount': '166', 'Title': 'Is $L=\\{ xyx^Ry^R \\mid x,y \\text{ is an element of }\\{0,1\\}^*\\}$ context-free?', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-12-06T16:19:30.307', 'LastEditDate': '2012-12-05T19:03:40.913', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4884', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2012-12-05T18:14:43.460', 'FavoriteCount': '1', 'Id': '7188''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1168', 'Title': 'Construct a PDA for the complement of $a^nb^nc^n$', 'LastEditDate': '2013-11-20T12:31:53.400', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4886', 'FavoriteCount': '1', 'Body': "<p>I am wondering if this is even possible, since $\\{a^n b^n c^n  \\mid n \\geq 0\\} \\not\\in \\mathrm{CFL}$. Therefore a PDA that can distinguish a word $w\\in\\{a^n b^n c^n  \\mid n \\geq 0\\}$ from the rest of $\\{a^*b^*c^*\\}$ might as well accept it, which sounds contradictory to me.</p>\n\n<p>I guess I need to take advantage of the non-deterministic nature of PDAs but I'm out of ideas. If you could offer some advice I would very much appreciate it.</p>\n", 'Tags': '<formal-languages><automata><context-free><pushdown-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-20T12:31:53.400', 'CommentCount': '3', 'AcceptedAnswerId': '7191', 'CreationDate': '2012-12-05T18:20:04.433', 'Id': '7190''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given languages $L_1,L_2$, defines $X(L_1,L_2)$ by</p>\n\n<p>$\\qquad X(L_1,L_2) = \\{w \\mid w \\not\\in L_1 \\cup L_2 \\}$</p>\n\n<p>If $L_1$ and $L_2$ are regular, how can we show that $X(L_1,L2)$ is also regular?</p>\n', 'ViewCount': '140', 'LastEditorDisplayName': 'user3115', 'Title': 'Show that the language of strings not in the union of two regular languages is regular', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T19:17:11.917', 'LastEditDate': '2012-12-12T19:17:11.917', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-12-06T01:56:03.217', 'Id': '7202''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I got this question on my final exam: Is the following language context-free?</p>\n\n<p>$$ L = \\{w\\bar w^R \\mid  w\\in \\{0,1\\}^*   \\}$$</p>\n\n<p><strong>Notation</strong>: \nThe string $\\bar w$  is obtained from $w$ by replacing all 0s with 1's and all 1's with 0's.  The string $\\bar w^R$ is $\\bar w$ in reverse order.</p>\n\n<hr>\n\n<blockquote>\n  <p>I've thought about it being a context-free language, but I notice that\n  when you pump the string in the middle, the string will still be in the\n  language. (using pumping lemma)</p>\n</blockquote>\n\n<p>I think it's context free. \nThis is the context free grammar:</p>\n\n<p>$$\nS \\to 0S1 \\mid  1S0 \\mid \\varepsilon $$\n(It's basically a palindrome, but both sides are exact opposites.)</p>\n", 'ViewCount': '149', 'Title': 'Is this a Context Free Language?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-06T15:36:31.313', 'LastEditDate': '2012-12-07T07:41:18.067', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4912', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2012-12-07T06:01:39.430', 'Id': '7224''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The right quotient of two languages is defined as</p>\n\n<p>$$L_1/L_2=\\{ x \\mid  xy \\in L_1 \\text{ and } y \\in L_2 \\}.$$</p>\n\n<p><strong>Example</strong>:<br>\n$L_1=\\{ab,aab,baa\\}$ and \n$L_2=\\{b\\}.$ </p>\n\n<p>I read somewhere that $L_1/L_2=\\{a,aa,\\varepsilon\\}$ but I cannot understand why $\\varepsilon$ is contained in the quotient. </p>\n', 'ViewCount': '47', 'Title': 'When is epsilon a part of the result of computing the right quotient?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-07T17:34:01.033', 'LastEditDate': '2012-12-07T17:32:22.510', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4763', 'Tags': '<formal-languages>', 'CreationDate': '2012-12-07T17:04:57.900', 'Id': '7233''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '597', 'Title': 'Proofs using the regular pumping lemma', 'LastEditDate': '2012-12-07T18:53:34.130', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4918', 'FavoriteCount': '0', 'Body': '<p>I have two questions:</p>\n\n<ol>\n<li><p>I consider the following language \n$$L_1= \\{ w\\in \\{0,1\\}^* \\mid \\not \\exists u\\in \\{0,1\\}^* \\colon w= uu^R\\}.$$\nIn other words $w$ is not palindrome with even length. I proved that this language is NOT regular by proving that its complement is not regular. My question is how to prove it using the pumping lemma without using going over the complement.</p></li>\n<li><p>Let\n$$L_2=\\{w\\in\\{0,1\\}^* \\mid \\text{$w$ has same number of 101 substrings and 010 substrings}\\}. $$  I proved that this language is not regular by using equivalence classes. How I can prove it using the pumping lemma?</p></li>\n</ol>\n\n<p>Thanks alot for edit:)</p>\n', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'LastEditorUserId': '4918', 'LastActivityDate': '2012-12-08T11:56:42.303', 'CommentCount': '2', 'AcceptedAnswerId': '7252', 'CreationDate': '2012-12-07T18:16:08.453', 'Id': '7235''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '135', 'Title': 'Pumping lemma for a finite language', 'AnswerCount': '2', 'Score': '0', 'OwnerDisplayName': 'MIkhail', 'PostTypeId': '1', 'OwnerUserId': '7925', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1847/pumping-lemma-for-simple-finite-regular-languages">Pumping lemma for simple finite regular languages</a>  </p>\n</blockquote>\n\n\n\n<p>The pumping lemma says that for any regular language $L$, there exists a constant $p$ such that any word $w$ in $L$ with length at least $p$ can be split into three substrings, $w = xyz$, where the middle portion $y$ must not be empty, such that the words $xz, xyz, xyyz, xyyyz, \\ldots$ constructed by repeating $y$ an arbitrary number of times (including zero times) are still in $L$.</p>\n\n<p>Consider a regular Language which contains only one string - the alphabet $a$. ie, $L = \\{a\\}$.</p>\n\n<p>Now, in this $L$, what would be the value of $p$, and possible values of $x$, $y$ , $z$?</p>\n\n<p>I am confused to the boundary cases of the pumping lemma.</p>\n', 'ClosedDate': '2012-12-10T15:34:22.783', 'Tags': '<formal-languages>', 'LastActivityDate': '2012-12-07T21:30:07.363', 'CommentCount': '0', 'AcceptedAnswerId': '7239', 'CreationDate': '2012-12-07T02:56:01.330', 'Id': '7238''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider the following language:\n$$ L_1=\\{uu^rv \\mid u,v\\in\\{0,1\\}^+\\}.$$\nthat means that neither $u$ nor $v$ can be $\\varepsilon$. As usual $u^r$ refers to $u$ reflected.</p>\n\n<p>I think that this language is not regular, but i am not sure. Any ideas? </p>\n', 'ViewCount': '222', 'Title': 'Is this language regular?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-09T18:26:17.210', 'LastEditDate': '2012-12-09T16:36:03.470', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7272', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4918', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-12-09T16:32:14.680', 'Id': '7271''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '101', 'Title': 'Present syntax rules in a more succinct way', 'LastEditDate': '2013-01-03T13:47:19.787', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'SoftTimur', 'PostTypeId': '1', 'OwnerUserId': '5008', 'Body': '<p>I am resuming syntax rules for a small language:</p>\n\n<p>\\begin{eqnarray*}\ne_C &amp;::=&amp; \\epsilon \\mid constant \\\\\n\\textit{prefix-op} &amp;::=&amp; - \\\\\n\\textit{infix-op} &amp;::=&amp; + \\mid - \\mid * \\\\\ne_E &amp;::=&amp; e_C \\mid \\textit{prefix-op} \\; e_E \\mid e_E \\; \\textit{infix-op} \\; e_E \\mid \\textit{function}_E (e_{E,0}, e_{E,1},\\ldots) \\mid \\textit{specialE} \\\\\ne_V &amp;::=&amp; e_C \\mid \\textit{prefix-op} \\; e_V \\mid e_V \\; \\textit{infix-op} \\; e_V \\mid \\textit{function}_V (e_{V,0}, e_{V,1}, \\ldots) \\mid \\textit{specialV}\n\\end{eqnarray*}</p>\n\n<p>The expressions $e_E$ and $e_V$ have something common: $e_C$. Some of their operators look same: $\\textit{prefix-op}$ and  $\\textit{infix-op}$. Their functions $\\textit{function}_E$ and $\\textit{function}_V$ are 2 different sets, and $\\textit{specialE}$ and $\\textit{specialV}$ are totally different.</p>\n\n<p>I am wondering if it is still possible to present this syntax more succinct, more compact in a conventional way... Could anyone help?</p>\n', 'Tags': '<formal-languages><formal-grammars><semantics>', 'LastEditorUserId': '5008', 'LastActivityDate': '2013-01-03T13:47:19.787', 'CommentCount': '0', 'AcceptedAnswerId': '7303', 'CreationDate': '2012-12-10T09:33:16.420', 'Id': '7300''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $A$ and $B$ be two deterministic finite automata. How do we prove that $L_E = \\{ \\langle A, B \\rangle : L(A) = L(B) \\}$ is neither regular nor context-free?</p>\n\n<p>Intuitively, I feel that $L_E$ should not be context-free because we must try each string $\\in \\Sigma^*$ (where $\\Sigma$ is the alphabet) and check if the string $\\in L(A)$ or $\\in L(B)$. However, this reasoning sounds informal to me. How do I formalize this proof?</p>\n', 'ViewCount': '95', 'Title': 'How do we prove that $L_E = \\{ \\langle A, B \\rangle : L(A) = L(B) \\}$ is neither regular nor context-free?', 'LastActivityDate': '2012-12-16T00:48:52.713', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7418', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2012-12-15T19:18:15.340', 'Id': '7416''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to create a DFA that can recognize strings with alphabet $\\{a,b,c\\}$ where $a$ and $c$ appear even number of times and where $b$ appears odd number of times.</p>\n\n<p>I am wondering that this may only be expressed with other methods such as Turing machine or context-free languages.</p>\n\n<p>You might find it fun to think of the solution.</p>\n', 'ViewCount': '199', 'Title': 'Does this DFA have a solution?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-16T16:29:32.997', 'LastEditDate': '2012-12-16T16:29:32.997', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7430', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5079', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-12-16T04:36:17.710', 'Id': '7429''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $A$ and $B$ be Turing-recognizable languages. Must language $C = A \\cap B$ be Turing-recognizable too?</p>\n\n<p>I have a hunch that it should be because we can construct an enumerator for $C$ by enumerating all the languages in $A$ and then all the languages in $B$.</p>\n\n<p>However, I also know that Turing-recognizable languages are not closed under complement, and $\\overline{\\bar{A} \\cup \\bar{B}} = A \\cap B = C$, which seems to suggest that Turing-recognizable languages are not closed under intersection.</p>\n\n<p>There is clearly a contradiction somewhere in my reasoning. Where is it?</p>\n', 'ViewCount': '936', 'Title': 'Are Turing-recognizable languages closed under intersection?', 'LastActivityDate': '2012-12-17T17:24:09.790', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7468', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<formal-languages>', 'CreationDate': '2012-12-17T17:07:03.210', 'Id': '7466''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In other words, $L$ is the language of Turing machines that recognize the language consisting of only themselves.</p>\n\n<p>Why is $L$ not Turing-recognizable? $L$ is clearly not decidable by Rice's Theorem, but how do I go one step further and also prove that no machine can enumerate $L$?</p>\n", 'ViewCount': '107', 'Title': 'Why is $L = \\{ \\langle M \\rangle : L(M) = \\{ \\langle M \\rangle \\} \\}$ not Turing-recognizable?', 'LastActivityDate': '2012-12-19T02:32:08.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7477', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<formal-languages>', 'CreationDate': '2012-12-17T18:12:24.103', 'Id': '7469''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp;A1B \\\\\nA \\rightarrow &amp; 0A \\mid \\varepsilon \\\\\nB \\rightarrow &amp; 0B \\mid 1B \\mid \\varepsilon \\\\\n\\end{align}\n$$</p>\n\n<p>How can I show that this grammar is unambiguous? I need to find a grammar for the same language that is ambiguous, and demonstrate it.</p>\n\n<p>I know if I was asked to prove that the language is ambigious then I should find two different parse trees for same string, but I don't know what to do.</p>\n", 'ViewCount': '848', 'Title': 'How to show that given language is unambiguous', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-30T18:31:28.237', 'LastEditDate': '2012-12-22T07:00:56.657', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7519', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5137', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><ambiguity>', 'CreationDate': '2012-12-20T00:20:48.643', 'Id': '7518''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a language which is made out of and has a grammar only operating on well parenthesized words or words of one symbol. I want to know if the problem of belonging to this language is decidable.</p>\n\n<p><strong>Example.</strong> Consider the following grammar:\n$$a \\to a(aa) \\\\ a \\to b \\\\a (a(a(ab))) \\to b$$\nI'll denote by $L(x)$ the language generated by the above grammar and rule $S \\to x$.</p>\n\n<p>Trivially, $b \\in L(a)$, using rule 2.<br>\nAlso $b \\in L(a(aa))$ by the sequence of productions $a(aa) \\to a(a(a(aa))) \\to a(a(a(ab))) \\to b$.<br>\nHowever $b \\notin L(aa)$ because after applying rule 1 any number of times and then rule 2, symbol $a$ will be repeated $2n + 1$ times and rule 3 can only remove $4m$ of them.</p>\n\n<p>Note, the grammar is actually dealing with trees. Parentheses denote a subtree and symbols denote leaves. Hopefully the notation is clear enough. The language seems much weaker than RE but stronger than context free.</p>\n", 'ViewCount': '72', 'Title': 'About complexity of a language', 'LastActivityDate': '2012-12-23T15:08:22.480', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '7563', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5167', 'Tags': '<formal-languages><computability>', 'CreationDate': '2012-12-23T11:51:17.500', 'Id': '7561''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1710', 'Title': 'Recursive and recursively enumerable language definition for a layman', 'LastEditDate': '2012-12-24T23:01:49.360', 'AnswerCount': '5', 'Score': '2', 'OwnerDisplayName': 'Sampath Kumar Rao', 'PostTypeId': '1', 'OwnerUserId': '5182', 'Body': "<p>I've come across many definitions of recursive and recursively enumerable languages. But I couldn't quite understand what they are .</p>\n\n<p>Can some one please tell me what they are in simple words?</p>\n\n<p>Thanks in advance.</p>\n", 'Tags': '<formal-languages><turing-machines>', 'LastEditorUserId': '3011', 'LastActivityDate': '2014-02-15T04:39:15.940', 'CommentCount': '0', 'AcceptedAnswerId': '7586', 'CreationDate': '2012-12-23T12:56:04.283', 'Id': '7585''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need help with the following question:</p>\n\n<p>Order the following formalisms according to their expressive power:\nplacing A before B means that any language definable by A is definable\nby B. Also state which, if any, of them are equivalent.</p>\n\n<pre><code>\u2022 Turing Machines (TM)\n\u2022 Regular expressions (reg.exp.)\n\u2022 Turing Machines with multiple tapes (TM+)\n\u2022 Pushdown Automata (PDA)\n\u2022 Nondeterministic Finite Automata with \u01eb-transitions (NFA\u01eb)\n\u2022 Nondeterministic Finite Automata (NFA)\n\u2022 LR(1) grammars\n\u2022 Nondeterministic Turing Machines (NTM)\n\u2022 Deterministic Pushdown Automata (DPDA)\n\u2022 Deterministic Finite Automata (DFA)\n\u2022 Context-free Grammars (CFG)\n</code></pre>\n\n<p>Is this the correct answer ? I have a exam next week and need to know If my answer is correct.</p>\n\n<pre><code>NFAe=NFA=DFA=Reg.exp, LR(1)-Grammar=DPDA, CFG=PDA, TM=NTM=TM+\n</code></pre>\n\n<p>Thanks in advance </p>\n', 'ViewCount': '173', 'Title': 'Formal Languages - Expressive power of Formalisms', 'LastActivityDate': '2013-01-01T22:35:50.987', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7683', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><regular-languages><context-free><regular-expressions><pushdown-automata>', 'CreationDate': '2013-01-01T22:22:24.913', 'Id': '7682''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need some help with deciding if a given language is regular, context-free or not context-free.</p>\n\n<p>Lets' say I have the following languages over the alphabet $\\mathcal{A} = \\{a,b,c,d\\}$:\n$$ \\begin{align}\n  L_1 &amp;= \\{ w \\in \\mathcal{A}^* \\mid \\text{\\(\\#a(w)\\) is even and \\(\\#b(w) = 1 \\mathrel{\\mathrm{mod}} 3\\)  and  \\(w \\not\\in \\mathcal{A}^* abc \\mathcal{A}^* \\)} \\} \\\\\n  L_2 &amp;= \\{ w \\in \\mathcal{A}^* \\mid \\text{\\(\\#a(w)\\) is even and \\(\\#b(w) \\lt \\#c(w)\\)} \\} \\\\\n  L_3 &amp;= \\{ w \\in \\mathscr{A}^* \\mid \\#a(w) \\lt \\#b(w) \\lt \\#c(w) \\} \\\\\n\\end{align} $$</p>\n\n<p>This is my solution:</p>\n\n<p>$L_1 = L_4 \\cap L_5 \\cap L_6$ where\n$$ \\begin{align}\n  L_4 &amp;= \\{ w \\mid \\text{\\(w\\) does not have a substring \\(abc\\)} \\} \\\\\n  L_5 &amp;= \\{ w \\mid \\#a(w) \\text{ is even} \\} \\\\\n  L_6 &amp;= \\{ w \\mid \\#b(w) = 1 \\mathrel{\\mathrm{mod}} 3 \\} \\\\\n\\end{align} $$</p>\n\n<p>A DFA can be constructed for $L_5$, because $L_5$ does not need infinite memory, so $L_5$ is regular. For $L_6$ the same reasoning as above. And for $L_4$ we can construct a DFA that simply does not accept $abc$, hence regular.</p>\n\n<p>$L_1$ is regular because regular languages are closed under intersection.</p>\n\n<p>For $L_2$ we can divide the language thus: $L_2 = L_5 \\cap L_7$ where</p>\n\n<p>$$ \\begin{align}\n  L_5 &amp;= \\{ w \\mid \\#a(w) \\text{ is even} \\} \\\\\n  L_7 &amp;= \\{ w \\mid \\#b(w) \\lt \\#c(w) \\} \\\\\n\\end{align} $$</p>\n\n<p>We now that a DFA can be constructed for $L_5$, hence $L_5$ is regular.\n$L_7$ is context-free because we can construct a PDA where the stack counts the number of $a$s and $b$s.</p>\n\n<p>$L_2$ is hence context-free because the intersection of a regular language and a context-free language result in a context-free language.</p>\n\n<p>For $L_3$ we can see that it's not context-free because where are limited to 1 stack.</p>\n\n<p>Is my reasoning right?</p>\n", 'ViewCount': '255', 'Title': 'Deciding whether a Language is Context-free/Regular/Non Context-Free', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-25T13:29:45.240', 'LastEditDate': '2013-03-26T12:54:48.303', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-01-03T14:34:12.090', 'Id': '7732''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '166', 'Title': 'Pumping lemma for Context-Free Languages', 'LastEditDate': '2013-01-03T22:12:16.170', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4658', 'FavoriteCount': '2', 'Body': "<p>I have a question about a specific pumping lemma problem for Context-Free Languages.</p>\n\n<p>Suppose we have the following Language:</p>\n\n<blockquote>\n  <p>$L = \\{a^{i}b^{j}c^{k}d^{l} \\mid 0 &lt; i &lt; k \\wedge j &gt; l &gt; 0 \\}$</p>\n</blockquote>\n\n<p>Here is my attemp to prove that the language is not context-free:</p>\n\n<p>Assume $L$ is context-free. Let $n&gt;0$ be the pumping length given by the lemma.</p>\n\n<p>Let $z = a^{n}b^{n+1}c^{n+1}d^{n}$, then $z \\in L$. </p>\n\n<p>Than according to the lemma, $z$ can be written as $z = uvwxy$ where the following properties hold:</p>\n\n<ol>\n<li>$|vx| \\geq 1$</li>\n<li>$|vwx| \\leq n$</li>\n<li>for every $i \\geq 0$, $uv^{i}wx^{i}y \\in L$.</li>\n</ol>\n\n<p>We have 6 different possibilities for $vwx$:</p>\n\n<ol>\n<li>$vwx = a^{i}$ where $i \\leq n$</li>\n<li>$vwx = a^{i}{b^j}$ where $i+j \\leq n$</li>\n<li>$vwx = b^i$ and $i \\leq n$</li>\n<li>$vwx = b^{i}c^{j}$ and $i+j \\leq n$</li>\n<li>$vwx = c^{i}$ with $i \\leq n$</li>\n<li>$vwx = c^{i}d^{j}$ and $i+j \\leq n$ </li>\n</ol>\n\n<p>Is this right so far? The thing that I'm unsure of is if my different cases for $vwx$ are right. </p>\n\n<p>How do I choose the pumping length for case 2? If I choose $i$ = 2, what if $i$ is zero ? Then I don't have any contradiction.</p>\n\n<p>Thanks in advance</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free><pumping-lemma>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-01-03T22:51:38.927', 'CommentCount': '2', 'AcceptedAnswerId': '7741', 'CreationDate': '2013-01-03T21:26:59.443', 'Id': '7740''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a problem finding the right string to pump for the following language:</p>\n\n<p>$$L_1 = \\{a^{p+q}b^rc^sd^{q+r}e^s \\mid p, q, r, s \\ge 0\\}$$</p>\n\n<p>Which string should I choose to pump? The problem is that I don't know how to handle the fact that I have $p+q$ and $q+r$?</p>\n\n<p>Can I choose:\n$$Z = a^{2n}b^nc^nd^{2n}e^s$$</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '126', 'Title': 'Pumping lemma problem - Choosing the right string to pump', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-04T09:46:44.527', 'LastEditDate': '2013-01-04T09:28:43.907', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7752', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><automata><context-free><pumping-lemma>', 'CreationDate': '2013-01-04T09:22:51.140', 'Id': '7751''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1416', 'Title': 'Explaining why a grammar is not LL(1)', 'LastEditDate': '2014-01-04T15:36:22.460', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'FavoriteCount': '1', 'Body': u'<p>I need some help with explaining why a grammar is not LL(1).</p>\n\n<p>Let us take the following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp; aB \\mid bA \\mid \\varepsilon \\\\\nA \\rightarrow &amp; aS \\mid bAA \\\\\nB \\rightarrow &amp; b \\\\\n\\end{align}\n$$</p>\n\n<p>This is my attempt:</p>\n\n<p>For the grammar to be LL(1) it is a necessary condition that for any strings $c_1\u03b3$ and $c_2\u03b2$, derivable from $S \\rightarrow aB$ and $A \\rightarrow aS$ respectively, we have $c_1 \\ne c_2$. </p>\n\n<p>But, $S \\rightarrow aB$ and $A \\rightarrow aS$, hence $c_1 = c_2$ and the grammar is not LL(1).</p>\n\n<p>Is my reasoning right?</p>\n\n<p>Thanks in advance.</p>\n', 'Tags': '<formal-languages><regular-languages><context-free><pushdown-automata>', 'LastEditorUserId': '10637', 'LastActivityDate': '2014-01-04T15:36:22.460', 'CommentCount': '1', 'AcceptedAnswerId': '7789', 'CreationDate': '2013-01-04T16:14:19.883', 'Id': '7761''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need some help with the following question:</p>\n\n<p>One of the languages</p>\n\n<p>$$L_1 = \\{a^pb^{q+r}c^sd^{q+t}e^{p+r} \\mid p, q, r, s \\ge 0\\ , s &gt; t\\}$$\n$$L_2 = \\{a^{p+q}b^rc^sd^{q+r}e^s \\mid p, q, r, s \\ge 0\\}$$</p>\n\n<p>is context-free and the other is not. Build a context-free grammar for the one that is. For the other one provide a proof that it is not regular, or that it is not context-free.</p>\n\n<p>How do I approach this problem ? I think that L2 is context-free because no comparisions are made. L1 is not context-free. </p>\n\n<p>Thanks in advance </p>\n', 'ViewCount': '100', 'Title': 'Pumping lemma problem', 'LastActivityDate': '2013-01-04T20:59:08.373', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7770', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><automata><context-free><pumping-lemma>', 'CreationDate': '2013-01-04T19:08:16.647', 'Id': '7767''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>An ambiguous Language is a formal language for which there exists a string that can have more than one meaning (several possible meanings or interpretations). Multiple synthesis structures for a string. </p>\n\n<p><strong>[Question]</strong><br>\nAre <a href="https://en.wikipedia.org/wiki/Roman_numerals" rel="nofollow">Roman numbers</a> an example of an ambiguous language?  </p>\n\n<p>Because there can be more then one representation for some number such as 1999, which \ncan be written as <code>MDCCCCLXXXXVIIII</code>, <code>MCMXCIX</code>, or <code>MIM</code>.    </p>\n\n<p>I am confused. Sometimes I feel not, some time yes!    </p>\n\n<p><strong>EDIT</strong><br>\n[ANSWER]</p>\n\n<p>Although there can be more than one representation of same magnitude in Roman Number System. That is basically Non-Positional Number System. But its possible to write <a href="http://compilers.iecc.com/comparch/article/07-03-118" rel="nofollow"><strong>Unambiguous Grammar for that can generate all possible/valid pattern in Roman Number System</strong></a>.   </p>\n\n<p><a href="http://www.boost.org/doc/libs/1_48_0/libs/spirit/doc/html/spirit/qi/tutorials/roman_numerals.html" rel="nofollow"><strong>Here is again a beautiful link</strong></a> that describe <code>symbol table</code>, <code>rule</code>  , <code>Grammar</code> for Roman number.  </p>\n\n<p>I am not sure about this but some authors says that: "<em>Roman numbers can be recognized by a regular expression, so you don\'t really need a context-free grammar.</em>" and a regular language can\'t be ambiguous. </p>\n', 'ViewCount': '823', 'Title': 'Is the language of Roman numerals ambiguous?', 'LastEditorUserId': '917', 'LastActivityDate': '2014-02-14T23:21:53.167', 'LastEditDate': '2013-12-09T11:57:11.067', 'AnswerCount': '5', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'Grijesh Chauhan', 'PostTypeId': '1', 'OwnerUserId': '5000', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-01-05T05:42:55.883', 'Id': '7777''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Have read in Compiler textbook that type inference is context sensitive. Can anyone explain why is it so? This means that we need context sensitive grammar in semantic analysis phase of a compiler with this feature? How is it done in popular programming languages like C?</p>\n', 'ViewCount': '104', 'Title': 'Type inference in compiler is context sensitive?', 'LastActivityDate': '2013-01-06T09:52:09.023', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<formal-languages><programming-languages><context-free><compilers><context-sensitive>', 'CreationDate': '2013-01-06T03:14:11.183', 'Id': '7796''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The <em>cyclic shift</em>  (also called <em>rotation</em> or <em>conjugation</em>) of a language $L$ is defined as $\\{ yx \\mid xy \\in L \\}$. According to <a href="http://en.wikipedia.org/wiki/Context-free_language">wikipedia</a> (and <a href="http://en.wikipedia.org/wiki/Cyclic_shift">here</a>) the context-free languages are closed under this operation, with references to papers from Oshiba and from Maslov. Is there an easy proof of this fact? </p>\n\n<p>For regular languages the closure is discussed in this form as "<a href="http://cs.stackexchange.com/questions/1986/prove-that-regular-languages-are-closed-under-the-cycle-operator">Prove that regular languages are closed under the cycle operator</a>".</p>\n', 'ViewCount': '628', 'Title': 'Easy proof for context-free languages being closed under cyclic shift', 'LastEditorUserId': '472', 'LastActivityDate': '2013-01-22T09:07:11.380', 'LastEditDate': '2013-01-16T02:25:42.500', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7857', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2013-01-08T12:59:17.587', 'Id': '7831''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '90', 'Title': 'What are some good hints for proving non-regularity with the pumping lemma?', 'LastEditDate': '2013-01-16T08:36:49.623', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6439', 'FavoriteCount': '2', 'Body': "<p>My CS Theory Professor said that when proving that a language is not regular by the Pumping Lemma, that there are some 'tricks' for solving languages more complicated that something like $L = \\{a^{n} b^{n}\\mid n \\in\\mathbb{N}\\}$. Although I know that these come with practice, I wondered if this community would have some input on the matter?</p>\n\n<p>If you don't quite know what I am asking, think to calculus, when your professor used something that HE knew would get you from point a to point b that if YOU don't know, you cannot solve the problem. </p>\n", 'Tags': '<formal-languages><proof-techniques><pumping-lemma>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-16T08:36:49.623', 'CommentCount': '2', 'AcceptedAnswerId': '8958', 'CreationDate': '2013-01-16T04:19:34.293', 'Id': '8957''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>$L_1=\\{a^ku \\mid u \\in \\{a,b\\}^* $ and $u$ contains at least $k$ a\'s, for $k\\geq 1\\}$.</p>\n\n<p>If it is regular, I haven\'t found its regular expression or any closure property to prove it.</p>\n\n<p>If not, it seems pumping theorem holds for it...</p>\n\n<p>Also, what about the language where the above "at least" is changed to "at most"?</p>\n', 'ViewCount': '249', 'Title': 'Is this language regular or not?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T16:29:46.853', 'LastEditDate': '2013-01-17T16:57:42.763', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<formal-languages><regular-languages><regular-expressions><pumping-lemma>', 'CreationDate': '2013-01-17T15:40:17.740', 'FavoriteCount': '1', 'Id': '8991''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>First, I have tried to build a DFA over the alphabet $\\sum = \\{0,\\dots, 9\\}$ that accepts all decimal representations of natural numbers divisible by 3, which is quite easy because of the digit sum. For this I choose the states $Q = \\mathbb{Z}/3\\mathbb{Z}\\cup\\{q_0\\}$ ($q_0$ to avoid the empty word), start state $q_0$, accept states $\\{[0]_3\\}$ and $\\delta(q, w) =\\begin{cases} [w]_3 &amp;\\mbox{if } q = q_0 \\\\\n[q + w]_3 &amp; \\mbox{else } \\end{cases}$</p>\n\n<p>Of course, it doesn't work that way for natural numbers divisible by 43. For 43 itself, I would end in $[7]_{43}$, which wouldn't be an accepting state. Is there any way I can add something there or do you have other suggestions on how to do this? Thanks.</p>\n", 'ViewCount': '486', 'Title': 'DFA that accepts decimal representations of a natural number divisible by 43', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-20T15:16:39.223', 'LastEditDate': '2013-01-20T15:13:05.993', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'Zlatansbraten', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-01-19T23:50:17.853', 'FavoriteCount': '1', 'Id': '9049''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>If I have a collection of oracle machines, can I decide every language? (I got this question from a former university exam and it sparked my interest).</p>\n\n<p>I thought if my collection has to be countable than I can't decide every language, since there's an uncountable amount of languages.</p>\n\n<p>But if my collection can be of any kind I figured could just add an oracle machine for every language with an oracle for that language, which would be sort of a trivial - brute force approach (the size of the collection would be uncountable than).</p>\n\n<p>Is there an issue with my approach / did I miss something? What happens if I have a countable number of oracles that can be used?</p>\n", 'ViewCount': '96', 'Title': 'Can a collection of oracle machines decide every language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T11:15:14.517', 'LastEditDate': '2013-01-21T11:15:14.517', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6490', 'Tags': '<formal-languages><computability>', 'CreationDate': '2013-01-20T20:14:03.270', 'Id': '9061''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '504', 'Title': 'Prove that the language of unary not-prime numbers satisfies the Pumping Lemma', 'LastEditDate': '2013-01-24T06:32:08.353', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6518', 'FavoriteCount': '1', 'Body': "<p>Here is a question from Daniel I. A. Cohen's book <em>Introduction to Computer Theory</em>:</p>\n\n<blockquote>\n  <p>Consider the language:  </p>\n  \n  <p>$\\quad \\mathrm{PRIME}' = \\{ a^n \\mid n \\text{ is not a prime} \\} = \\{ \\varepsilon, a, aaaa, aaaaaa, aaaaaaaa, \\ldots \\}$</p>\n  \n  <ol>\n  <li>Prove that $\\mathrm{PRIME}'$ is non-regular.  </li>\n  <li>Prove, however, that $\\mathrm{PRIME}'$ does satisfy the pumping lemma.  </li>\n  </ol>\n</blockquote>\n\n<p>Part 1. is really easy to prove. I start my proof of part 2. like this:</p>\n\n<ol>\n<li>We pick $m$ s.t. $m \\geq 4$.  </li>\n<li>The opponent picks $w = a^{n^2}$, where $n$ is any prime number greater than m.</li>\n</ol>\n\n<p>Now I don't know how to decompose $w$ into $xyz$. Any help would be appreciated.</p>\n\n<hr>\n\n<p><strong>Update</strong>: According to the answers below, $\\mathrm{PRIME}'$ doesn't satisfy the Pumping Lemma we commonly talk about (requiring $|xy| \\leq m$). I have checked the book at the library and found there are two versions of the Pumping Lemma in it. The weaker one, which clearly this question refers to, doesn't require a fixed pumping length.</p>\n", 'Tags': '<formal-languages><automata><pumping-lemma>', 'LastEditorUserId': '6518', 'LastActivityDate': '2013-01-25T16:18:09.903', 'CommentCount': '2', 'AcceptedAnswerId': '9108', 'CreationDate': '2013-01-23T08:42:08.650', 'Id': '9104''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have an alphabet $A = \\{b,B\\}$ and I'm asked to write down the <strong>pattern</strong> of the regular expression $(\\epsilon|bb|b)(B|bb)(b|\\epsilon|b)$. What does the question actually want me to do? I'm not sure. Does it want me to give the possible patterns that can be formed with $b$ and $B$? But then surely the question would not have been phrased the way it is. </p>\n\n<p>I'm just confused about what I need to do here and what is expected of the answer. If anyone could give an example it would be very helpful.</p>\n\n<p>Note: This is not the original question, I changed and simplified it.</p>\n", 'ViewCount': '97', 'Title': 'What is meant by "give pattern of a regular expression"', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T13:03:04.673', 'LastEditDate': '2013-01-24T12:52:30.853', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '9149', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6542', 'Tags': '<formal-languages><terminology><regular-languages><regular-expressions>', 'CreationDate': '2013-01-24T12:03:56.200', 'Id': '9132''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a regular language $L$, then it is easy to prove that there is a constant $N$ such that is $\\sigma \\in L$, with $\\lvert \\sigma \\rvert \\ge N$ there exist strings $\\alpha$, $\\beta$ and $\\gamma$ such that $\\lvert \\alpha \\beta \\rvert \\le N$ and $\\lvert \\beta \\rvert \\ne \\epsilon$, and for all $k$ it is $\\alpha \\beta^k \\gamma \\in L$. It is widely stated that the converse isn\'t true, but I haven\'t seen any clear example. Any suggestions? Clearly the proof that the offending language isn\'t regular has to use stronger methods than the typical "doesn\'t satisfy the pumping lemma". I\'d be interested in simple examples, to present in introductory formal languages classes.</p>\n', 'ViewCount': '406', 'Title': "Languages that satisfy the pumping lemma but aren't regular?", 'LastActivityDate': '2013-01-27T14:39:52.710', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9182', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6447', 'Tags': '<formal-languages><proof-techniques>', 'CreationDate': '2013-01-27T00:42:15.890', 'FavoriteCount': '1', 'Id': '9181''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '44', 'Title': 'How i can use Mathematical induction to prove CFG production?', 'LastEditDate': '2013-01-28T10:23:01.200', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'M.B', 'PostTypeId': '1', 'OwnerUserId': '6594', 'Body': '<p>If I have production $G_n$</p>\n\n<blockquote>\n  <p>$S \\rightarrow A_i b_i \\quad$ for $1 \\le i \\le n$</p>\n  \n  <p>$A_i \\rightarrow a_j A_i \\mid a_j\\quad$   for $1 \\le i$ and $i \\ne j$</p>\n</blockquote>\n\n<ol>\n<li>Prove $G_n$ is sub-productions from $2n^2 - n$</li>\n<li>Prove $G_n$ is $LR(0)$ production from $2^n + n^2 + n$</li>\n</ol>\n', 'ClosedDate': '2013-04-14T19:11:20.580', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T10:23:01.200', 'CommentCount': '5', 'CreationDate': '2013-01-27T17:06:45.810', 'Id': '9230''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have seen a few years back a nice and simple algorithm that, given a (finite) set of words in some alphabet, builds a context-free grammar for a language including these words and in some sense "natural" (e.g., the grammar doesn\'t produce all words in the alphabet). The algorithm is very simple,  it has something like 3--4 rules for grammar transformation attempted on each new word. Any help in finding it would be appreciated.</p>\n', 'ViewCount': '181', 'Title': 'Construct a context-free grammar for a given set of words', 'LastEditorUserId': '6591', 'LastActivityDate': '2013-12-10T07:31:05.390', 'LastEditDate': '2013-01-28T15:39:42.217', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '9268', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6591', 'Tags': '<algorithms><formal-languages><reference-request><formal-grammars><machine-learning>', 'CreationDate': '2013-01-28T10:01:35.720', 'Id': '9246''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am studying formal language theory and have been asked to prove the following:</p>\n\n<p>$\\forall L, L^*=(L^*)^*$</p>\n\n<p>I've started with</p>\n\n<p>$def. L^* = \\bigcup_{i \\in \\mathbb{N}} L_i, L_0=\\{{\\epsilon}\\}, L_1=\\{L\\}, L_{i+1}=\\{uv|u\\in L_i, v\\in L\\}$</p>\n\n<p>$then (L^*)^* = \\bigcup_{i \\in \\mathbb{N}} L_i^*, L_0^*=\\{{\\epsilon}\\}, L_1^*=\\{L^*\\}, L_{i+1}^*=\\{uv|u\\in L_i^*, v\\in L^*\\}$</p>\n\n<p>$L^*L_0^*\\in(L^*)^* = L^*\\epsilon^* = L^*$ $\\therefore L^* \\subseteq (L^*)^*$ </p>\n\n<p>$L^*L_0^* = L^*, L^*L^*_1 = L^* (def), L^*L_{i+1}^*=L^*_iL^*=L^*L^*$ but the * operator is closed under concatenation, thus, $L^*L^* \\in L^* \\therefore (L^*)^* \\subseteq L^*$</p>\n\n<p>$\\therefore L^* = (L^*)^*$</p>\n\n<p>I simply don't have an intuition on whether this attempt at a proof is correct and I would appreciate any insight about it since the subsequent problems are to show $L^+=(L^+)^+$ and then to argue whether $(L^*)^+=(L^+)^*$</p>\n", 'ViewCount': '131', 'Title': 'How to show that L*=(L*)*?', 'LastEditorUserId': '6551', 'LastActivityDate': '2013-01-30T15:33:46.357', 'LastEditDate': '2013-01-30T15:33:46.357', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '9255', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Tags': '<formal-languages>', 'CreationDate': '2013-01-28T15:29:34.660', 'Id': '9253''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For a language $L$ with pumping length $p$, and a string $s\\in L$, the pumping lemmas are as follows:</p>\n\n<p><strong>Regular version</strong>:\nIf $|s| \\geq p$, then $s$ can be written as $xyz$, satisfying the following conditions:</p>\n\n<ol>\n<li>$|y|\\geq 1$</li>\n<li>$|xy|\\leq p$</li>\n<li>$ \\forall i\\geq 0: xy^iz\\in L$</li>\n</ol>\n\n<p><strong>Context-free version</strong>:\nIf $|s| \\geq p$, then $s$ can be written as $uvxyz$, satisfying the following conditions:</p>\n\n<ol>\n<li>$|vy|\\geq 1$</li>\n<li>$|vxy|\\leq p$</li>\n<li>$ \\forall i\\geq 0: uv^ixy^iz\\in L$</li>\n</ol>\n\n<p>My question is this: <strong>Can someone give a concise and clear explanation of how regularity (context-freeness) imply the first and second conditions above?</strong> The pumping length is determined by (finite) properties (finite number of states or finite properties of production rules, respectively), the third properties guarantee that a state (production rule) can be skipped or repeated arbitrarily many times, but where do the first and second conditions originate? How are they justified?</p>\n', 'ViewCount': '127', 'Title': 'Where do the length restrictions of the pumping lemma come from?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-18T22:42:40.240', 'LastEditDate': '2013-01-30T20:26:09.033', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2013-01-30T19:10:37.243', 'Id': '9323''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/307/show-that-xy-mid-x-y-x-neq-y-is-context-free">Show that $\\{xy \\mid |x| = |y|, x\\neq y\\}$ is context-free</a>  </p>\n</blockquote>\n\n\n\n<p>Do there exist context-free grammars for the following two languages:</p>\n\n<ol>\n<li><p>The set of all strings of the form $xx$ where $x$ is a sequence of $0$\'s and $1$\'s. (For instance $0110101101$.)</p></li>\n<li><p>The set of all strings of the form $xy$ where $x$ and $y$ are sequences of $0$\'s and $1$\'s, $x$ and $y$ have the same length and $x\\neq y$.</p></li>\n</ol>\n', 'ViewCount': '53', 'ClosedDate': '2013-01-31T09:44:27.620', 'Title': 'Are these two languages context free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-31T09:40:26.160', 'LastEditDate': '2013-01-31T09:40:26.160', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'user13526', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-01-30T21:17:08.720', 'Id': '9337''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Speaking in terms of automata and regular languages, how would it be possible for a string repeating some $w$ twice equal a string repeating that same $w$ thrice? That is, why is the language</p>\n\n<p>$\\qquad L = \\{w \\in \\Sigma^ * \\mid ww = www\\}$</p>\n\n<p>not empty? The only thing I can think of is $w = abab, ww = abababab, www = abababababab$, but I don't think this is correct.</p>\n", 'ViewCount': '5901', 'Title': 'How can $ww = www$ hold for any word $w$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:49:11.747', 'LastEditDate': '2013-02-02T13:49:11.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '9401', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-02-01T16:48:32.013', 'Id': '9396''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '144', 'Title': 'Give a grammar to show whether a language is regular or context-free', 'LastEditDate': '2013-02-02T14:17:23.077', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6680', 'FavoriteCount': '0', 'Body': "<p>I have to generate a grammar for the language $L = \\{ w \\in \\{ a, b\\}^* \\mid |w| \\in 2\\mathbb{N},  w \\neq w^R\\}$ and give the type of the language.</p>\n\n<p>I've generated the grammar</p>\n\n<p>$\\qquad \\begin{align}\n  S &amp;\\to aSa \\mid bSb \\mid aAb \\mid bAa \\\\\n  A &amp;\\to abA \\mid baA \\mid aaA \\mid bbA \\mid \\varepsilon\n\\end{align}$</p>\n\n<p>This grammar is a context free grammar. I now can say that $L$ is a context free language. But how can I say for sure that this language isn't regular ?</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T14:17:23.077', 'CommentCount': '1', 'AcceptedAnswerId': '9422', 'CreationDate': '2013-02-02T10:40:02.157', 'Id': '9418''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '103', 'Title': 'Regular expression for binary words with few zeros', 'LastEditDate': '2013-02-03T10:21:39.150', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'Jay Satish Teli', 'PostTypeId': '1', 'OwnerUserId': '6687', 'Body': '<p>What is the regular expression for the set of binary strings with the property that</p>\n\n<ol>\n<li>every $0$ is followed by <em>exactly</em> $m$ times $1$ and </li>\n<li>every $0$ is preceded by <em>at least</em> $n$ times $1$? </li>\n</ol>\n\n<p>$m$ and $n$ are integers.</p>\n', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-04T13:35:30.713', 'CommentCount': '2', 'AcceptedAnswerId': '9448', 'CreationDate': '2013-02-03T02:25:16.703', 'Id': '9442''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '310', 'Title': 'Regular expression for $\\{a^k b^m c^n \\mid k+m+n \\text{ is odd} \\}$', 'LastEditDate': '2013-04-12T22:59:44.677', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6667', 'FavoriteCount': '0', 'Body': '<p>I have to make a regular expression from the following laguage:</p>\n\n<blockquote>\n  <p>{$a^kb^mc^n : $ where <em>k</em> + <em>m</em> + <em>n</em> is odd}</p>\n</blockquote>\n\n<p>Is is possible for the sum of three numbers to be odd (other than three consecutive odd numbers)?</p>\n\n<p>I have this so far:</p>\n\n<blockquote>\n  <p>{(abbbccccc) + (abbbbbccc) + (aaabccccc) + (aaabbbbbc) + (aaaaabccc) + (aaaaabbbc)}</p>\n</blockquote>\n\n<p>but I am realizing that there are way more possibilities to this pattern... How can I formulate a string that encompasses all of this?</p>\n', 'Tags': '<formal-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T22:59:44.677', 'CommentCount': '3', 'AcceptedAnswerId': '9480', 'CreationDate': '2013-02-04T16:31:12.427', 'Id': '9478''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a question about the regular operation \'star\' in computational theory.</p>\n\n<p>IF $A$ is $\\{ good , bad \\}$ then</p>\n\n<p>$A^* = \\{ \\varepsilon , good, bad , goodgood, goodbad, badgood , \\dots \\}$</p>\n\n<p>What is the exact "regular operation" mean then ?</p>\n\n<p>Can we use $^*$ operation only for regular language ? I don\'t think so.</p>\n\n<p>$L = \\{0^n1^n \\mid n \\ge 0 \\}$ is a famous example of a non-regular language, but it seems we can create $L^*$?</p>\n', 'ViewCount': '601', 'Title': 'Star operation in CS theory', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-10T13:47:34.400', 'LastEditDate': '2013-02-10T13:47:34.400', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6807', 'Tags': '<formal-languages>', 'CreationDate': '2013-02-10T13:06:35.393', 'Id': '9637''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is the language $\\lbrace (aaaaa)^n aa (aaaaa)^n \\mid n \\in \\mathbb{N} \\rbrace$ regular? It looks like I need infinitely many states so it is not regular.</p>\n', 'ViewCount': '132', 'Title': 'Is $(aaaaa)^n aa (aaaaa)^n$ a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-11T21:20:39.350', 'LastEditDate': '2013-02-11T12:04:30.787', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6807', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-02-11T11:00:21.433', 'FavoriteCount': '1', 'Id': '9670''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there an algorithm which decides whether a regular tree grammar $G$ is ambiguous, i.g. there exists a tree $t\\in L(G)$ which can be parsed by the grammar in more than one ways, using only leftmost derivations?</p>\n\n<p>Is there a proof available about the decidability, or a cite to a paper which proposes such an algorithm?</p>\n', 'ViewCount': '241', 'Title': 'Is the ambiguity of a regular tree grammar decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:40:05.507', 'LastEditDate': '2013-02-14T06:40:05.507', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6866', 'Tags': '<formal-languages><computability><formal-grammars><ambiguity><tree-grammars>', 'CreationDate': '2013-02-13T15:29:34.530', 'Id': '9745''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do you say $\\delta\\colon Q \\times \\Sigma \\to Q$ in English? Describing what $\\times$" and $\\to$ mean would also help.</p>\n', 'ViewCount': '92', 'Title': u'How does "\u03b4:Q\xd7\u03a3\u2192Q" read in the definition of a DFA (deterministic finite acceptor)?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-02-14T12:56:41.347', 'LastEditDate': '2013-02-14T09:28:07.567', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '9762', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6871', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2013-02-14T07:45:04.143', 'Id': '9761''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<ol>\n<li>Is every language with a finite number of strings regular?</li>\n<li>Is the language of all strings regular?</li>\n</ol>\n\n<p>I am new to this topic and got confused. Can any one please help me with this?</p>\n', 'ViewCount': '220', 'Title': 'Is every language with a finite number of strings regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T07:40:04.690', 'LastEditDate': '2013-02-15T07:40:04.690', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6875', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-02-14T15:29:44.697', 'Id': '9773''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For regular languages $R, S$ and $T$, which of the following are true?</p>\n\n<ol>\n<li>$R \\cup S = S \\cup R$</li>\n<li>$(R \\cup S) \\cdot T = RT \\cup ST  $</li>\n<li>$R^* \\cdot S^* = (R \\cup S)^*$</li>\n</ol>\n', 'ViewCount': '56', 'Title': 'Regular language properties', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T07:38:26.373', 'LastEditDate': '2013-02-15T07:38:26.373', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6875', 'Tags': '<formal-languages><regular-languages><sets>', 'CreationDate': '2013-02-14T16:39:40.447', 'Id': '9775''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '696', 'Title': 'Context Free Grammar for language $L=\\{a^ib^j \\mid i,j \\ge 0; i \\ne 2j\\}$', 'LastEditDate': '2013-02-16T14:40:19.113', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6885', 'FavoriteCount': '0', 'Body': "<p>Can someone help with this:  </p>\n\n<p>$L=\\{a^ib^j \\mid i,j \\ge 0 \\text{ and } i \\ne 2j\\}$  </p>\n\n<p>I'm trying to write a grammar for this language?\nI don't know how to do this.\nI tried this:<br>\n$S \\rightarrow aaAb \\mid aA \\\\\nA \\rightarrow aA \\mid a$</p>\n", 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T14:40:19.113', 'CommentCount': '3', 'AcceptedAnswerId': '9811', 'CreationDate': '2013-02-15T11:14:40.920', 'Id': '9804''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a homework problem I have spent several hours on. A "hint" is given that we may use this fact: If $n,j,k \\in \\mathbb{N}$ satisfy $ n \\geq 2$ and $1 \\leq j+k \\leq n$, then $n^2+j$ does not evenly divide $n^3+k$.</p>\n\n<p>I cannot find any way to apply this fact. It leads me to believe I should use the string $0^{p^2}1^{p^3}$ or something like that, but I am really just not sure. The pumping lemma has given me trouble since the non regular language version.</p>\n\n<p>Even small hints greatly appreciated at this point.</p>\n', 'ViewCount': '115', 'Title': 'Prove that $\\{0^n 1^{n\\cdot m} : n,m \\in \\mathbb{N}\\}$ is not context-free', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-02-15T17:25:06.790', 'LastEditDate': '2013-02-15T17:21:10.057', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'user13760', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2013-02-15T14:56:39.073', 'Id': '9808''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '305', 'Title': 'Is $A$ regular if $A^{2}$ is regular?', 'LastEditDate': '2013-02-17T09:57:18.313', 'AnswerCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4752', 'FavoriteCount': '3', 'Body': '<p>If $A^2$ is regular, does it follow that $A$ is regular?</p>\n\n<p>My attempt on a proof:</p>\n\n<blockquote>\n  <p>Yes, for contradiction assume that $A$ is not regular.  Then $A^2 = A \\cdot A$. </p>\n  \n  <p>Since concatenation of two non-regular language is not regular $A^2$ cannot be regular.  This contradicts our assumption.  So $A$ is regular.  So if $A^2$ is regular then $A$ is regular.</p>\n</blockquote>\n\n<p>Is the proof correct?</p>\n\n<p>Can we generalize this to $A^3$, $A^4$, etc...?  And also if $A^*$ is regular then $A$ need not be regular?</p>\n\n<p>Example: $A=\\lbrace 1^{2^i} \\mid i \\geq 0\\rbrace$ is not regular but $A^*$ is regular.</p>\n', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-17T19:46:06.063', 'CommentCount': '4', 'AcceptedAnswerId': '9832', 'CreationDate': '2013-02-16T07:41:52.540', 'Id': '9829''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Can someone help with this:</p>\n\n<p>$L=\\{a^ib^j \\mid i,j \\ge 1 \\text{ and } i \\ne j \\text{ and } i&lt;2j\\}$</p>\n\n<p>I'm trying to write a grammar for this language?\nI tried this:</p>\n\n<p>$S \\to S_1 \\mid S_2 \\\\\nS_1 \\to aXb \\\\\nX \\to aXb \\mid aaXb \\mid aab \\\\\nS_2 \\to aYb \\\\\nY \\to aYb \\mid Yb \\mid b \\\\\n$</p>\n\n<p>What do you think?</p>\n", 'ViewCount': '308', 'Title': 'Context Free Grammar for language L', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-14T21:09:44.067', 'LastEditDate': '2013-04-06T18:56:00.993', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6885', 'Tags': '<formal-languages><context-free><formal-grammars><check-my-answer>', 'CreationDate': '2013-02-16T11:00:00.360', 'Id': '9831''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If I have an infinite language $L$ which fulfills the Pumping lemma for regular languages, does $L^*$ also fulfill the same conditions?</p>\n', 'ViewCount': '70', 'Title': 'Is pumping lemma for regular languages "closed" against Kleene star?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T15:04:08.253', 'LastEditDate': '2013-02-16T15:04:08.253', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6885', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-02-16T12:20:29.337', 'Id': '9834''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to determine if the following languages are regular / context free and to explain.  Please help me with that.</p>\n\n<p>$$L_1 = \\{ a^{i_{1}}b a^{i_{2}}b a^{i_{3}}b a^{i_{4}}b a^{i_{5}}b\na^{i_{6}}b a^{i_{7}}b a^{i_{8}}b a^{i_{9}}b a^{i_{10}}b \\mid i_1 &gt; i_2\n&gt; i_3 &gt; i_4 &gt; i_5 &gt; i_6 &gt; i_7 &gt; i_8 &gt; i_9 &gt; i_{10} ; i_1 &lt; 100 \\}$$</p>\n\n<p>$$L_2 = \\{ a^{i_{1}}b a^{i_{2}}b a^{i_{3}}b a^{i_{4}}b a^{i_{5}}b\na^{i_{6}}b a^{i_{7}}b a^{i_{8}}b a^{i_{9}}b a^{i_{10}}b \\mid i_1 &gt; i_2\n&gt; i_3 &gt; i_4 &gt; i_5 &gt; i_6 &gt; i_7 &gt; i_8 &gt; i_9 &gt; i_{10} ; i_2 &lt; 100 \\}$$</p>\n\n<p>$$L_3 = \\{ a^{i_{1}}b a^{i_{2}}b a^{i_{3}}b a^{i_{4}}b a^{i_{5}}b\na^{i_{6}}b a^{i_{7}}b a^{i_{8}}b a^{i_{9}}b a^{i_{10}}b \\mid i_1 &gt; i_2\n&gt; i_3 &gt; i_4 &gt; i_5 &gt; i_6 &gt; i_7 &gt; i_8 &gt; i_9 &gt; i_{10} ; i_3 &lt; 100 \\}$$</p>\n', 'ViewCount': '87', 'Title': 'Regular and context free languages', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T15:15:18.507', 'LastEditDate': '2013-02-16T15:15:18.507', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-3', 'PostTypeId': '1', 'OwnerUserId': '6885', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-02-16T12:33:05.323', 'Id': '9835''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a language for sensor networks (generates C code) and I want to define the formal semantics of it.</p>\n\n<p>The language has this form:</p>\n\n<pre><code>{STATE name_state:\nEVERY time\nSELECT {variable [, variable] ...}\n[SENDIF send_condition]\n[CHANGEIF change_condition GOTO new_state];\n} ...\n\nSTART IN initial_state;\n</code></pre>\n\n<ul>\n<li>The initial state of the program is specified by the START IN instruction.</li>\n<li>Each state is defined by the STATE instruction.</li>\n<li>In the specification of each state the clauses EVERY and SELECT are compulsory and the clauses SENDIF and CHANGEIF are optional.</li>\n<li>The CHANGEIF clause is only not specified when there is a single state.</li>\n</ul>\n\n<p>What type of formal semantics is more convenient to use?</p>\n', 'ViewCount': '96', 'Title': 'Formally describing a sensor network language', 'LastActivityDate': '2013-02-20T19:27:47.843', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '9981', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6624', 'Tags': '<formal-languages><programming-languages><semantics>', 'CreationDate': '2013-02-18T19:20:41.680', 'Id': '9902''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '162', 'Title': 'Are all possible programming languages a formal system?', 'LastEditDate': '2013-02-20T20:18:28.103', 'AnswerCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6674', 'FavoriteCount': '0', 'Body': '<p>Based on the Wikipedia page for <a href="http://en.wikipedia.org/wiki/Formal_system" rel="nofollow">a formal system</a>, will all programming languages be contained within the following rules?</p>\n\n<ul>\n<li><strong>A finite set of of symbols.</strong></li>\n</ul>\n\n<p>(This seems obvious since the computer is a discrete machine with finite memory and therefore a finite number of ways to express a symbol.)</p>\n\n<ul>\n<li><p><strong>A grammar.</strong></p></li>\n<li><p><strong>A set of axioms.</strong></p></li>\n<li><p><strong>A set of inference rules.</strong></p></li>\n</ul>\n\n<p>Are all <em>possible</em> languages constrained by these rules? Is there a notable proof?</p>\n\n<p>EDIT:</p>\n\n<p>I\'ve been somewhat convinced that my question may actually be: can programming languages be represented by something other than a formal system?</p>\n', 'Tags': '<formal-languages>', 'LastEditorUserId': '6674', 'LastActivityDate': '2013-02-21T00:41:48.877', 'CommentCount': '9', 'AcceptedAnswerId': '9997', 'CreationDate': '2013-02-20T18:24:37.480', 'Id': '9977''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '417', 'Title': 'If $L$ is a subset of $\\{0\\}^*$, then how can we show that $L^*$ is regular?', 'LastEditDate': '2013-02-21T19:19:14.377', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '6977', 'FavoriteCount': '1', 'Body': '<p>Say, $L \\subseteq \\{0\\}^*$. Then how can we prove that $L^*$ is regular?</p>\n\n<p>If $L$ is regular, then of course $L^*$ is also regular. If $L$ is finite, then it is regular and again $L^*$ is regular.\nAlso I have noticed that, for $L = \\{0^p \\mid p \\text{ is a prime}\\}$, $L$ is not regular, $L \\subseteq \\{0\\}^*$ and $L^*$ is regular.</p>\n\n<p>But how to show this for any subset $L$ of $\\{0\\}^*$ ?</p>\n', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-21T23:18:20.877', 'CommentCount': '0', 'AcceptedAnswerId': '10018', 'CreationDate': '2013-02-21T17:20:50.127', 'Id': '10013''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $T$ be a Turing machine whose accepted language is $L(T)$. Let $X$ be another language. How do you approach a proof like $L(T)\\subseteq X?$</p>\n', 'ViewCount': '262', 'Title': 'Proof-sketch on the language accepted by a Turing machine', 'LastEditorUserId': '6989', 'LastActivityDate': '2013-02-23T16:47:28.233', 'LastEditDate': '2013-02-22T22:28:28.367', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10032', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6989', 'Tags': '<formal-languages><turing-machines><proof-techniques>', 'CreationDate': '2013-02-22T22:04:26.177', 'Id': '10031''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We only consider the <a href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="nofollow">reverse Polish notation</a> as an arithmetic expression.</p>\n\n<p>Formally, RNP is a sequence consisted of numbers and arithmetic operators: $+,-,*,/$, and its syntax is:\n$$\\newcommand\\RNF{\\mathrm{RNF}}\\newcommand\\num{\\mathrm{number}}\\newcommand\\op{\\mathrm{operator}}\\RNF=\\num\\,\\big\\vert\\,\\RNF,\\RNF,\\op$$\nand its value\n$$\\newcommand\\eval{\\operatorname{eval}}\\eval\\num=\\num$$\n$$\\eval\\RNF_1,\\RNF_2,\\op=\\eval\\RNF_1\\ \\op\\ \\eval\\RNF_2$$</p>\n\n<p>The following pseudo code to evaluate $\\eval\\RNF$ is quoted from K&amp;R:</p>\n\n<pre><code>while (next operator or operand isn\'t empty)\n  if (it\'s a number)\n    push it\n  else if (it\'s an operator, say +,-,*,/)\n    pop operands\n    do operation\n    push result\n</code></pre>\n\n<p>The algorithm is somewhat straightforward, but it\'s not as evident as considered. I found it difficult to formulate a <a href="http://en.wikipedia.org/wiki/Loop_invariant" rel="nofollow">loop invariant</a> for the outer while-loop, and it\'s quite hard to prove the algorithm through <a href="http://en.wikipedia.org/wiki/Hoare_logic" rel="nofollow">Floyd-Hoare logic</a>.</p>\n\n<p>Through some search work, I found a <a href="http://cs.stackexchange.com/q/3458">related question</a>, about the unambiguity of RPN. Unfortunately, I don\'t think the answer to that question is a rigorous proof.</p>\n', 'ViewCount': '483', 'Title': 'Evaluation of reverse Polish notation', 'LastEditorUserId': '1715', 'LastActivityDate': '2013-02-23T05:29:17.650', 'LastEditDate': '2013-02-23T05:25:43.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10035', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1715', 'Tags': '<algorithms><formal-languages><software-verification>', 'CreationDate': '2013-02-23T04:22:45.387', 'Id': '10034''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m doing an exercise in my <a href="http://rads.stackoverflow.com/amzn/click/0073191469" rel="nofollow">book</a>, the question is to find a string of minimum length in $\\{a, b\\}^*$ not in the language corresponding to the given regular expression.</p>\n\n<p>a. $b^*(ab)^*a^*$</p>\n\n<p>My answer: $aab$</p>\n\n<p>b. $(a^* + b^*)(a^* + b^*)(a^* + b^*)$</p>\n\n<p>My answer: $abab$</p>\n\n<p>c. $a^*(baa^*)^*b^*$</p>\n\n<p>My answer: $bba$</p>\n\n<p>d. $b^*(a + ba)^*b^*$</p>\n\n<p>My answer: $abba$</p>\n\n<p>I came up with my answers by trial and error. I don\'t know for sure if these are the shortest possible strings. Is the best method trial and error, or would there be some better algorithmic way?</p>\n', 'ViewCount': '246', 'Title': 'String of minimum length in $\\{a, b\\}^*$ not in a regular expression', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-06T18:54:15.723', 'LastEditDate': '2013-04-06T18:54:15.723', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10065', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><regular-languages><regular-expressions><check-my-answer>', 'CreationDate': '2013-02-24T20:23:54.390', 'Id': '10064''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Are there languages generated by linear grammer which aren't regular?</p>\n", 'ViewCount': '114', 'Title': "Are there languages generated by linear grammar which aren't regular?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-25T13:57:55.043', 'LastEditDate': '2013-02-25T13:56:10.727', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10080', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><formal-grammars><context-free>', 'CreationDate': '2013-02-25T12:46:21.063', 'Id': '10079''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '84', 'Title': 'Priority in formal grammar', 'LastEditDate': '2013-02-28T11:20:49.453', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4409', 'FavoriteCount': '1', 'Body': '<p>From my recitation class, I have the following exercise:</p>\n\n<blockquote>\n  <p>$\\mathrm{EXP} = 0 \\mid 1 \\mid b \\mathrm{EXP} \\mid \\mathrm{EXP} a \\mid \\mathrm{EXP} m \\mathrm{EXP}$</p>\n  \n  <p>The above grammar is ambiguous.</p>\n  \n  <p>Make an unambiguous grammar which produce same language as the above.</p>\n  \n  <p>In the new grammar, $a$ has priority over $b$ and $b$ has priority over $m$.\n  Also $m$ is associative.</p>\n</blockquote>\n\n<p>Can you explain what the phrases</p>\n\n<ul>\n<li>"has priority over" and</li>\n<li>"$m$ is associative"</li>\n</ul>\n\n<p>mean?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsing><ambiguity>', 'LastEditorUserId': '4409', 'LastActivityDate': '2013-02-28T14:58:59.373', 'CommentCount': '1', 'AcceptedAnswerId': '10151', 'CreationDate': '2013-02-27T19:11:49.933', 'Id': '10142''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '135', 'Title': 'Is The Following Language Regular?', 'LastEditDate': '2013-02-28T00:14:10.330', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Body': '<p>Let $L_{1}$ and $L_{2}$ be 2 languages over the same alphabet $\\Sigma$.  </p>\n\n<p>$$A(L_1,L_2)=\\{x\\in \\Sigma^*|\\exists y,z\\in L_2\\text{ such that } yxz\\in L_1\\}$$</p>\n\n<p>Assume that $L_{1}$ is regular and $L_{2}$ is context-free. The language $A(L_{1},L_{2})$:</p>\n\n<ol>\n<li>is always a regular language</li>\n<li>is always not a regular language</li>\n<li>can sometimes be a regular language</li>\n<li>cannot be context free</li>\n</ol>\n\n<p>They say that the correct answer is 1.</p>\n', 'ClosedDate': '2013-03-01T08:12:00.193', 'Tags': '<formal-languages><regular-languages><automata><context-free><finite-automata>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T03:38:56.220', 'CommentCount': '4', 'AcceptedAnswerId': '10163', 'CreationDate': '2013-02-27T23:51:15.260', 'Id': '10147''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I encountered this problem involving manipulating a context-free language. Let $L$ be a context-free language. Define $L^{\\#} = \\{ x : x^i \\in L$ for every $i=0,1,2,...\\}$. Is $L^{\\#}$ always context-free?<br>\nMy guess is that it will preserve context-freeness. Can anyone provide an elementary proof of this?</p>\n', 'ViewCount': '97', 'Title': 'Does the following transformation preserve context-freeness?', 'LastActivityDate': '2013-03-07T17:20:18.937', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7098', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-03-01T18:41:45.137', 'FavoriteCount': '0', 'Id': '10183''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My question: do the non-regular languages have closure properties? For example, if the reverse of L is non-regular, then L is non-regular ? thank you :-) </p>\n', 'ViewCount': '1305', 'Title': 'Are the non-regular languages closed under reverse, union, concatenation, etc?', 'LastEditorUserId': '4287', 'LastActivityDate': '2013-03-03T01:36:10.540', 'LastEditDate': '2013-03-03T01:36:10.540', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7107', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-03-02T12:03:38.260', 'FavoriteCount': '1', 'Id': '10205''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $\\operatorname{value}(x)$ be the result when the symbols of $x$ are multiplied from left to right according to\n <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; a &amp; c \\\\\n    b &amp; c &amp; a &amp; b \\\\\n    c &amp; b &amp; c &amp; a\n   \\end{array}$</p></p>\n\n<p> Is $L=\\{xy \\mid |x|=|y| \\land \\operatorname{value}(x) = \\operatorname{value}(y)\\}$ regular?</p>\n\n<p> Is $L=\\{xy \\mid \\operatorname{value}(x)= \\operatorname{value}(y)\\}$ regular?</p>\n', 'ViewCount': '143', 'Title': 'Are these two languages regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-05T07:03:47.100', 'LastEditDate': '2013-03-05T07:03:47.100', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7135', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-03-04T06:58:57.633', 'Id': '10251''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '141', 'Title': 'How to show that the complement of a language in $\\mathsf P$ is also in $\\mathsf P$?', 'LastEditDate': '2013-03-04T13:30:31.070', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7140', 'Body': u'<p>If $L$ is a binary language (that is, $L \\subseteq \\Sigma = \\{0,1\\}^\u2217$) and $\\overline{L}$ is the complement of $L$:</p>\n\n<p>How can I show that if $L \\in \\mathsf P$, then $\\overline{L} \\in \\mathsf P$ as well?</p>\n', 'ClosedDate': '2013-03-04T19:39:55.200', 'Tags': '<complexity-theory><formal-languages><time-complexity><complexity-classes>', 'LastEditorUserId': '2152', 'LastActivityDate': '2013-03-04T17:31:28.363', 'CommentCount': '2', 'AcceptedAnswerId': '10270', 'CreationDate': '2013-03-04T12:32:28.090', 'Id': '10257''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If $L$ is a binary language ($\\Sigma = (0, 1)^*$) and $\\overline{L}$ is the complement of $L$, the set of binary strings not in $L$.</p>\n\n<p>How can I show that, if $L$ is in the complexity class $P$, then so is $\\overline{L}$?</p>\n', 'ViewCount': '84', 'Title': 'Show complement of language in same complexity class?', 'LastActivityDate': '2013-03-04T16:51:16.363', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10268', 'Score': '0', 'OwnerDisplayName': 'Calum Murray', 'PostTypeId': '1', 'OwnerUserId': '7140', 'Tags': '<complexity-classes><formal-languages>', 'CreationDate': '2013-03-04T12:00:27.847', 'Id': '10265''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need a hint for writing a context-free grammar for the language $L=\\{1^k0^{2k}:k\\in \\mathbb N\\}$. I'm starting to doubt that it can be done for general $k$.</p>\n", 'ViewCount': '80', 'Title': 'Context free grammar for $1^k0^{2k}$', 'LastActivityDate': '2013-03-05T07:11:27.230', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-03-04T23:16:42.733', 'FavoriteCount': '1', 'Id': '10275''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Here is the question:</p>\n\n<p>Show that $L = \\{0^m1^n : m &gt; 1, n &gt; 1, n &lt; m \\}$ is not regular.</p>\n\n<p>I am not sure what superscripts mean in this situation? Does it mean something like this:</p>\n\n<p>$0^5 = 00000$ or $1^7 = 1111111$.</p>\n', 'ViewCount': '53', 'Title': 'Formal Language Syntax', 'LastEditorUserId': '683', 'LastActivityDate': '2013-03-06T23:44:22.213', 'LastEditDate': '2013-03-06T19:32:26.397', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10331', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-03-06T19:26:52.783', 'Id': '10329''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>So I have been given the task of creating an PDA that recognises the language </p>\n\n<p>$\\{a^{2n} b^{3n} \\mid n = 0,1,2,\\dots\\}$.</p>\n\n<p>Am I right in thinking that it needs to have at least 3 times number of $b$'s than $a$'s? </p>\n\n<p>So for example:\n$aabbb$ would be accepted\n$aaabb$ would NOT be accepted\nHowever, how do I show that using JFlap because I am unfamiliar with the software?</p>\n", 'ViewCount': '687', 'Title': 'Constructing PDA for $a^{2n} b^{3n}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-11T21:22:30.850', 'LastEditDate': '2013-03-11T07:20:49.087', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '10433', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<formal-languages><pushdown-automata>', 'CreationDate': '2013-03-10T14:50:24.700', 'Id': '10423''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '90', 'Title': 'Proving that a specific language is a CFL, and that another language is not a CFL', 'LastEditDate': '2013-03-11T02:12:00.413', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7220', 'FavoriteCount': '0', 'Body': "<p>I have two languages $C_1$ and $C_2. \\left(\\Sigma=\\{0,1\\}\\right)$:</p>\n\n<p>$C_1=\\left\\{xyz\\mid x,z \\in \\Sigma^*, y \\in \\Sigma^*1\\Sigma^*, \\text{ where } |x|=|z| \\geq |y|\\right\\}$, and $C_2=\\left\\{xyz\\mid x,z \\in \\Sigma^*, y \\in \\Sigma^*1\\Sigma^*1\\Sigma^*, \\text{ where } |x|=|z| \\geq |y|\\right\\}$</p>\n\n<p>I want to show that $C_1$ is a CFL, while $C_2$ is not a CFL.  I'm trying to create a grammar / pushdown automata that accepts $L(C_1)$, but the $|x|=|z| \\geq |y|$ part is throwing me off.  I plan on using the pumping lemma for $C_2$, but I'm not sure which string to pump.  </p>\n", 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-11T05:34:59.417', 'CommentCount': '4', 'AcceptedAnswerId': '10440', 'CreationDate': '2013-03-10T21:21:27.903', 'Id': '10437''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '74', 'Title': 'Is the following language context free?', 'LastEditDate': '2013-03-12T05:01:27.690', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'user979616', 'PostTypeId': '1', 'OwnerUserId': '7151', 'Body': "<p>Is $L = \\{ a^nb^nc^j \\mid n \\le j\\}$ a context-free language? I'm getting really stuck generating a grammar for it. Any help would be appreciated.  </p>\n", 'Tags': '<formal-languages><formal-grammars><context-free>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-12T10:50:47.000', 'CommentCount': '1', 'AcceptedAnswerId': '10466', 'CreationDate': '2013-03-11T17:03:44.577', 'Id': '10465''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '942', 'Title': 'The importance of normal forms like Chomsky normal form for CFGs', 'LastEditDate': '2013-03-12T11:20:21.347', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '0', 'Body': '<p>I understand that context-free grammars can be used to represent context-free languages.It might have ambiguities. We also have normal forms like <a href="https://de.wikipedia.org/wiki/Chomsky-Normalform" rel="nofollow">Chomsky</a> and <a href="https://de.wikipedia.org/wiki/Greibach-Normalform" rel="nofollow">Greibach</a> normal form. I couldn\'t understand the need of that. </p>\n\n<p>Why they are important in the theory of languages? All the textbooks I referred to tell about these normal forms but not telling anything about their importance. </p>\n', 'Tags': '<formal-languages><context-free><formal-grammars><normal-forms>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-29T19:33:05.130', 'CommentCount': '1', 'AcceptedAnswerId': '10478', 'CreationDate': '2013-03-12T06:32:28.983', 'Id': '10468''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '578', 'Title': 'Show that the Kleene star of any unary language is regular', 'LastEditDate': '2013-03-17T00:28:59.150', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'Martin', 'PostTypeId': '1', 'OwnerUserId': '8978', 'Body': "<p>An exercise asks me to show that the Kleene star of any unary language $L$ is regular. $E$ is the alphabet, $E = \\{ 1 \\}$</p>\n\n<p>Here's my reasoning :</p>\n\n<ul>\n<li>$L$ is regular $\\implies$ $L^*$ is regular (closure property)</li>\n<li>$L$ is not regular\n<ul>\n<li>$L$ contains the word of length 1 $\\implies$ $L^* = E^* \\cup \\{\\epsilon\\}$ $\\implies$ $L^*$ is regular (since $E^*$ is regular, and the union of two regular languages is regular)</li>\n<li>$L$ does not contain the word of length 1 -> ... ?</li>\n</ul></li>\n</ul>\n\n<p>This is where I'm stuck. I don't know what to do if $L$ does not contain the word of length 1. I do not think that there exists a relation between $L^*$ and $(L \\text{ complement})^*$.</p>\n\n<p>Does anyone have any idea to continue this proof ? Thank you.</p>\n", 'ClosedDate': '2013-03-17T09:21:32.963', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-17T00:28:59.150', 'CommentCount': '0', 'AcceptedAnswerId': '10556', 'CreationDate': '2013-03-16T14:52:57.753', 'Id': '10555''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '98', 'Title': 'Deciding whether a given language is regular', 'LastEditDate': '2013-03-16T19:59:08.193', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Yotam', 'PostTypeId': '1', 'OwnerUserId': '7303', 'Body': "<p>I am struggling with a homework assignment. This next question seems to be pretty easy, once I get what I feel like I'm missing now. Anyway, here goes:</p>\n\n<blockquote>\n  <p>Decide if the following language is regular or not and prove your\n  claim.</p>\n  \n  <p>$$L=\\{a^{i_{1}}ba^{i_{2}}ba^{i_{3}}ba^{i_{4}}ba^{i_{5}}ba^{i_{6}}ba^{i_{7}}b|i_{1}&gt;i_{2}&gt;i_{3}&gt;i_{4}&gt;i_{5}&gt;i_{6}&gt;i_{7};i_{1}&lt;100\\}$$</p>\n</blockquote>\n\n<p>So, how do I go about doing so? Is there a thumb rule that might help? I was trying to use the pumping lemma to prove that it is not regular, but couldn't do it. I'm not even sure it really is not regular.</p>\n\n<p>Any suggestions? </p>\n", 'ClosedDate': '2013-03-17T18:08:26.427', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-16T19:59:08.193', 'CommentCount': '4', 'AcceptedAnswerId': '10559', 'CreationDate': '2013-03-16T17:56:32.230', 'Id': '10557''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>This is a question from the Dragon book (I apologize for translation mistakes, I don\xb4t have the English version on hand):</p>\n\n<blockquote>\n  <p>What language is generated by this grammar?</p>\n  \n  <p>$S \\rightarrow a S b S \\mid b S a S  \\mid \\epsilon$</p>\n</blockquote>\n\n<p>I don\'t know what I\'m supposed to do here. The definition in the book about languages says this (and that\'s pretty much it in the chapter): </p>\n\n<blockquote>\n  <p>a language is the set of all words that can be produced by any parse\n  tree.</p>\n</blockquote>\n\n<p>So, if I want to make "any" parse tree out of this grammar, I can recursively keep building it, using just the first two rules. I searched a bit and got the impression that every rule has to be used once, but I\'m not sure. It would be very helpful if someone were able to provide some tips on solving these sorts of problems.</p>\n', 'ViewCount': '1096', 'Title': 'Finding the language generated by a context-free grammar', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-19T12:05:36.463', 'LastEditDate': '2013-03-19T12:05:36.463', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6520', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-03-18T21:49:48.777', 'Id': '10605''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let \n$A= \\{L \\mid L \\;\\text{is one-counter and \\(\\bar{L}\\) is also one-counter} \\}$</p>\n\n<p>Clearly, $\\text{Deterministic one-counter} \\subseteq A$</p>\n\n<p>Is it the case that $ A = \\text{Deterministic one-counter}$?</p>\n\n<p>I know that for context-free languages the analogue is not the case. For example,\nlet $P =\\{ ww^r\\}$.\nThen both $P$ and $\\bar{P}$ are context-free but $P$ is not deterministic.\nHence $A$ defines a (strict) subset of the context-free languages.</p>\n\n<p>The question is: can we construct a similar one-counter example for which the same holds?</p>\n', 'ViewCount': '143', 'Title': 'Is there a strictly non-deterministic one-counter language whose complement is one-counter?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-18T15:27:47.923', 'LastEditDate': '2013-03-20T10:50:55.130', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4980', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-03-19T15:44:35.443', 'Id': '10621''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '160', 'Title': 'Is $L= \\{ a^ib^j \\mid j\\neq i \\ and \\ j\\neq2i \\ \\} $ context free?', 'LastEditDate': '2013-03-20T05:31:10.373', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4980', 'FavoriteCount': '1', 'Body': "<p>$L = \\{ a^ib^j \\mid j\\neq i \\ and \\ j\\neq2i \\ \\} $</p>\n\n<p>Is this language a context free language?\nIf yes give a PDA. If no, give a proof.</p>\n\n<p>The pumping lemma for context free languages doesn't seem to work here.</p>\n\n<p>Let $p&gt;1$ be the pumping length. Let the string be divided into five parts according to pumping lemma as $w = uvxyz$.</p>\n\n<p>For any string of the form $a^ib^j \\ s.t.$: </p>\n\n<ol>\n<li><p>$ j\\lt i-1$ choose $v=a, \\ x=\\epsilon, \\ y=\\epsilon$</p></li>\n<li><p>$ j\\gt 2i+1$ choose $v=\\epsilon, \\ x=\\epsilon, \\ y=b$</p></li>\n<li><p>$ j = i-1$ choose $v=a, \\ x=\\epsilon, \\ y=b$</p></li>\n<li><p>$ j =  2i+1$ choose $v=a, \\ x=\\epsilon, \\ y=b$</p></li>\n<li><p>$ j\\gt i,\\ j\\lt 2i $ choose $v=a, \\ x=\\epsilon, \\ y=b$</p></li>\n</ol>\n", 'Tags': '<formal-languages><context-free><pushdown-automata>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-20T05:31:10.373', 'CommentCount': '1', 'AcceptedAnswerId': '10638', 'CreationDate': '2013-03-20T04:55:41.533', 'Id': '10635''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A class of languages $\\mathcal{C}$ is <em>closed under countable union</em> (<em>cucu</em>) if for all series of languages in $\\mathcal{C}$ ($(L_i)_{i\\in\\mathbb{N}} \\in \\mathcal{C}^\\mathbb{N}$) the language $\\bigcup_{i\\in\\mathbb{N}}L_i = \\{x\\mid \\exists i\\in\\mathbb{N}: x \\in L_i\\}$ is an element of $\\mathcal{C}$.</p>\n\n<p>As we know most (if not all but $\\mathsf{ALL} = \\wp(\\Sigma^*)$) interesting complexity classes are not closed under countable union as every Language $L$ is the countable union of some singleton Laguages $\\{w_i\\}$.</p>\n\n<p>However there are some classes of <strong>decidable</strong> languages which are cucu like:</p>\n\n<ul>\n<li>$\\{\\{w\\in\\Sigma^*\\mid |w| \\leq i\\}\\mid i\\in\\mathbb{N}\\}$</li>\n<li>$\\{n\\text{-}\\mathrm{SAT}\\mid n\\in\\mathbb{N}\\}$</li>\n<li>every $\\mathcal{C}$ s.t. every $L \\in \\mathcal{C}$ is cofinite</li>\n</ul>\n\n<hr/>\n\n<p>My questions:</p>\n\n<ol>\n<li>Let $\\mathcal{C},\\mathcal{C\'} \\subset \\mathsf{REC}$ be two classes of decidable languages s.t. both are cucu. Is $\\mathcal{C} \\cup \\mathcal{C\'}$ cucu?</li>\n<li>Is there some "real" complexity class (i.e. defined by some machine model, grammar type, $\\lambda$-calculus restriction etc.) that is cucu? (You may restrict it artificially (e.g. NFA, where each final state has a path to another final state), if it fits otherwise.)</li>\n<li><strong>Edit</strong> (after Yuval Filmus\' answer): Given $\\mathcal{C},\\mathcal{C\'}$, as in (1), does the closure of  $\\mathcal{C} \\cup \\mathcal{C\'}$ under countable union only contain decidable languages?</li>\n</ol>\n\n<p>(1) is the main question, (2+3) only addenda.</p>\n', 'ViewCount': '127', 'Title': 'Does closure against countable union survive union of classes?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T20:53:05.277', 'LastEditDate': '2013-03-20T20:53:05.277', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10649', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6716', 'Tags': '<formal-languages><closure-properties>', 'CreationDate': '2013-03-20T14:20:03.700', 'Id': '10648''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Why is $A(L) = \\{x \\in L \\mid x = x^R \\}$ context-free if $L$ is a regular language? </p>\n\n<p>Trying to understand the approach to determining whether a regular language is context-free.</p>\n', 'ViewCount': '128', 'Title': 'Why is the subset of palindromes of a regular language context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-21T10:30:15.167', 'LastEditDate': '2013-03-21T10:28:57.977', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10677', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2013-03-21T02:15:36.403', 'Id': '10675''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>Recently, I asked a <a href="http://math.stackexchange.com/q/334581/17111">question</a> on Math SE. No response yet. This question is related to that question, but more technical details toward computer science.</em></p>\n\n<p>Given two DFAs $A = (Q, \\Sigma, \\delta, q_1, F_1)$ and $B = (Q, \\Sigma, \\delta, q_2, F_2)$ where the set of states, the input alphabet and the transition function of $A$ and $B$ are the same, the initial states and the final(accepting) states could be different. Let $L_1$ and $L_2$ be the languages accepted by $A$ and $B$, respectively.</p>\n\n<p>There are four cases:</p>\n\n<ol>\n<li>$q_1 = q_2$ and $F_1 = F_2$.</li>\n<li>$q_1 \\neq q_2$ and $F_1 = F_2$.</li>\n<li>$q_1 = q_2$ and $F_1 \\neq F_2$.</li>\n<li>$q_1 \\neq q_2$ and $F_1 \\neq F_2$.</li>\n</ol>\n\n<p>My question is</p>\n\n<blockquote>\n  <blockquote>\n    <p>What are the differences between $L_1$ and $L_2$\n     in cases 2, 3 and 4?</p>\n  </blockquote>\n</blockquote>\n\n<p>I have a more specific question along this line,</p>\n\n<p>The transition monoid of an automaton is the set of all functions on the set of states\ninduced by input strings. See <a href="http://en.wikipedia.org/wiki/Semiautomaton">the page</a> for more details. The transition monoid can be regarded as a monoid acting on the set of states. See this <a href="http://en.wikipedia.org/wiki/Semigroup_action">Wiki page</a> for more details.</p>\n\n<p>In many literatures, an automaton is called strongly connected when the monoid action is transitive, i.e. there is always at least one transition (input string) from one state to another state.</p>\n\n<blockquote>\n  <blockquote>\n    <p>If $A$ and $B$ are strongly connected automata, what are the differences between $L_1$ and $L_2$ in cases 2, 3 and 4 above?</p>\n  </blockquote>\n</blockquote>\n\n<p>Any literatures discussing these issues in details?</p>\n\n<p>I have searched many books and articles and found nothing helpful so far. I believe I don\'t have the appropriate key words yet. Thus I am seeking help. Any pointers/references will be appreciated very much.</p>\n', 'ViewCount': '170', 'Title': 'Difference between the languages accepted by two DFAs with different initial state/accepting states?', 'LastActivityDate': '2013-03-24T11:48:30.127', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10737', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '630', 'Tags': '<formal-languages><reference-request><finite-automata>', 'CreationDate': '2013-03-24T03:40:45.747', 'FavoriteCount': '1', 'Id': '10733''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '405', 'Title': 'Star free language vs. regular language', 'LastEditDate': '2013-03-27T15:46:17.093', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7410', 'FavoriteCount': '2', 'Body': u'<p>I was wondering, since $a^*$ is itself a star-free language, is there a regular language that is not a star-free language? Could you give an example?</p>\n\n<hr>\n\n<p><em>(from <a href="http://en.wikipedia.org/wiki/Star-free_language#cite_ref-Law235_1-0" rel="nofollow">wikipdia</a>)</em> Lawson defines star-free languages as:</p>\n\n<blockquote>\n  <p>A regular language is said to be star-free if it can be described by a regular expression constructed from the letters of the alphabet, the empty set symbol, all boolean operators \u2013 including complementation \u2013 and concatenation but no Kleene star.</p>\n</blockquote>\n\n<hr>\n\n<p>Here is the proof of $a^*$ being star-free:</p>\n\n<blockquote>\n  <p>$\\emptyset$ is star-free $\\Longrightarrow$<br>\n  $\\Sigma^*=\\bar{\\emptyset}$ is star-free $\\Longrightarrow$<br>\n  $A\\subseteq\\Sigma\\Rightarrow\\Sigma^*A\\Sigma^*$ is star-free $\\Longrightarrow$<br>\n  $A\\subseteq\\Sigma\\Rightarrow\\ A^*=\\overline{\\Sigma^*\\overline{A}\\Sigma^*}$ is star-free</p>\n</blockquote>\n', 'Tags': '<formal-languages><regular-languages><automata>', 'LastEditorUserId': '7410', 'LastActivityDate': '2013-08-16T16:56:08.473', 'CommentCount': '0', 'AcceptedAnswerId': '10769', 'CreationDate': '2013-03-25T11:21:07.097', 'Id': '10768''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have two regular languages <em>A</em> and <em>B</em>, and I want to determine whether there is any pair of strings, <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em>, such that (<em>a</em>&nbsp;<em>b</em>) is a prefix of a string in (<em>A</em>&nbsp;<em>B</em>) and the left-most match of <em>B</em> in (<em>a</em>&nbsp;<em>b</em>) includes one or more characters from <em>a</em>.</p>\n\n<p>Raphael\'s formulation is good:</p>\n\n<blockquote>\n  <p>Given two regular language A, B, is there a (non-empty) prefix of a word b in B that is a suffix of a word in A so that the rest of b is a prefix of another word in B?</p>\n</blockquote>\n\n<h1>Example</h1>\n\n<p>For example, let\'s say I have two regular languages, one which describes some properly escaped HTML text, and one which describes an end tag:</p>\n\n<pre><code>A := ([^&amp;&lt;&gt;] | [&amp;] [a-z] [a-z0-9]+ [;])*;\nB := "&lt;/title";\n</code></pre>\n\n<p>By inspection, I can tell that there is no string (<em>a</em>&nbsp;<em>b</em>) in (<em>A</em>&nbsp;<em>B</em>) such that the first match of <em>B</em> includes characters from <em>a</em> because <code>"&lt;"</code> is a prefix of <em>B</em> which cannot occur as a suffix of <em>A</em>.</p>\n\n<p>But given a different grammar:</p>\n\n<pre><code>A\' := (A | "&lt;![CDATA[" ("]"? "&gt;" | "]"* [^\\]&gt;])* "]]&gt;")*;\nB\' := "&lt;/title" ([^&gt;\\"] | [\\"] [^\\"]* [\\"])* "&gt;";\n</code></pre>\n\n<p>then there are strings</p>\n\n<pre><code>a = \'&lt;![CDATA[&lt;/title "]]&gt;"\';\nb = \'&lt;/title&gt;\';\n</code></pre>\n\n<p>where (<em>A</em>&nbsp;<em>B</em>) matches <code>\'&lt;![CDATA[&lt;/title "]]&gt;"&lt;/title&gt;\'</code> and the left-most match of <em>B</em> is <code>\'&lt;/title "]]&gt;"&lt;/title&gt;\'</code> which includes a non-empty suffix of <em>a</em> : <code>\'&lt;/title "]]&gt;"\'</code>.</p>\n\n<h1>Motivation</h1>\n\n<p><em>A</em> in my situation describes the output of an encoder/sanitizer that is derived from a grammar, so an untrusted input is fed to the encoder/sanitizer and I know the output matches <em>A</em> by construction.</p>\n\n<p><em>B</em> is a limit condition in a larger grammar that describes how parsers determine where a chunk of an embedded language ends so they can hand it off to a parser for the embedded language.</p>\n\n<p>My end goal is to be able to determine when I can optimize away runtime checks that ensure that it is safe to embed a particular encoded string.  For these examples, it would be safe to optimize out the first check, but not the second.</p>\n\n<hr>\n\n<p>Is this a solved problem?  Does it have a name?  Any pointers appreciated.</p>\n', 'ViewCount': '76', 'Title': 'For regular languages A and B, determine whether B might match early in (A B)', 'LastEditorUserId': '1298', 'LastActivityDate': '2013-03-28T18:43:58.467', 'LastEditDate': '2013-03-28T18:43:58.467', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><regular-languages><regular-expressions><parsers>', 'CreationDate': '2013-03-27T21:11:15.627', 'Id': '10852''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm reading my textbook and it claims that the regular expression $c^*(b \\cup (ac)^*)^*$ defines the language $L$ over $\\{a,b,c\\}$ which consists of <strong>all</strong> strings that do not contain the substring $bc$. </p>\n\n<p>However, I'm failing to see how that language would contain strings such as $bbbaaa$ or $aaabbb$. Am I missing something or is that regular expression incorrect? The expression I come up with was $ \\left( \\left( \\left( a \\cup b \\right) ^*a \\right) ^* \\left( c \\cup a \\right) ^* \\right) ^*b^* $</p>\n", 'ViewCount': '109', 'Title': "Does $c^*(b \\cup (ac)^*)^*$ define all strings over $\\{a,b,c\\}$ that don't contain the substring $bc$", 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T11:22:02.750', 'LastEditDate': '2013-03-28T10:36:10.927', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '10867', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7461', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-03-28T03:33:26.653', 'Id': '10857''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Can a two-stack PDA accept language $L=\\{a^nb^mc^nd^m \\mid n \\geq m\\}$, which has no context-free grammar?</p>\n\n<p>I don't believe this has a context-free grammar, but please correct me if I'm wrong.</p>\n", 'ViewCount': '397', 'Title': 'Can a two-stack PDA accept language $a^nb^mc^nd^m$ which is not context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:15:49.030', 'LastEditDate': '2013-04-02T07:15:49.030', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10894', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><automata><machine-models>', 'CreationDate': '2013-03-29T13:13:58.140', 'Id': '10892''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This question is on the GRE Computer Science test booklet (not homework). I tried applying closure properties of regular languages but no success.</p>\n\n<p>Suppose $L$ is a regular language over $\\Sigma = \\{0, 1\\}$. Show that the language </p>\n\n<p>$\\qquad L' = \\{w \\in L \\mid |w| \\in 2\\mathbb{N}\\}$ </p>\n\n<p>is also regular.</p>\n\n<p>What I find surprising is that the booklet mentions that the language $\\{w \\in L \\mid |w| = 2^k, k \\in \\mathbb{N}\\}$ is not necessarily a regular language. </p>\n", 'ViewCount': '460', 'Title': 'Proof that regular languages are closed against taking the even-length subset', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-01T23:26:38.987', 'LastEditDate': '2013-04-02T08:16:56.630', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '5', 'OwnerDisplayName': 'Dmitrii I.', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-03-30T22:49:33.747', 'Id': '10927''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>My problem with CFG is, I am to generally create ones that don't have requirements such as:</p>\n\n<p>$\\qquad \\{a^m b^n \\mid m \\le n \\le 2m \\}$</p>\n\n<p>I have no clue where to begin, and how to approach it. I was wondering if you can provide some hints for such daunting problems, along with how to solve that problem.</p>\n\n<p>This is not homework, this is merely me trying to learn it. I solved many problems that did not have such requirements, but those problem are the ones where I am forced to look at the solution.</p>\n", 'ViewCount': '116', 'Title': 'Context free grammar construction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:53:53.193', 'LastEditDate': '2013-04-02T07:53:53.193', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '3', 'OwnerDisplayName': 'CSTHEORY', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-03-31T00:16:38.500', 'Id': '10928''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have to write a regular expression that accepts any odd binary number not preceded by a 0. the best I can come up with is $1(0\\cup1)^*1$, but that doesn't match just 1. The best it matches is 11.</p>\n", 'ViewCount': '286', 'Title': 'Regular expression for odd binary numbers without leading zeros', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-03T07:42:55.550', 'LastEditDate': '2013-04-03T07:15:35.700', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10989', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-04-02T23:29:28.500', 'Id': '10983''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This was given as a homework problem but I have already submitted the assignment.  I'd like to resolve it at this point for my own satisfaction.</p>\n\n<p>Given that $L_1$ is a linear language and $L_2$ is a regular language, show that $L=L_1L_2$ is a linear language.</p>\n\n<p>Recall that a linear grammar $G=(\\Sigma, V, P, \\sigma)$ has productions $A\\to yBz$ for some $y,z \\in \\Sigma^*$ and $A,B \\in V$.</p>\n\n<p>I use the theorem that every regular language can be represented by a right linear grammar.</p>\n\n<p>Then I use the theorem that every right linear grammar is the reverse of a left linear grammar (being a little careful about what I mean by reverse)... $L(rev(G))=rev(L(G))$...</p>\n\n<p>Next each left linear grammar is the reverse of a regular language, but the reverse of a regular language is regular, so left linear grammars also represent regular languages.</p>\n\n<p>So our productions in $L_2$ are of the form $x \\to Ca \\mid a$ for some $C \\in V_{L_2}$ and $a \\in \\Sigma_{L_2}$.</p>\n\n<p>Now on to the show...</p>\n\n<p>What we are looking for is $L = L_1.L_2$, $L$ is linear (to show).</p>\n\n<p>So this has the form $S \\to yBzCa \\mid yBzaa$</p>\n\n<p>So far so good, the second production is linear and within our expectations for set inclusion.</p>\n\n<p>I'm having a devil of a time reducing $yBzCa$ however ...</p>\n\n<p>If I introduce $V\\to BzC$ that linearizes $S$ but $V$ is not linear ... </p>\n\n<p>If I give $T\\to z$ to get $V\\to BTC$ I'm not much better off </p>\n\n<p>If I use $V_1\\to Bz$ (ok linear!) but then $V\\to V_1C$ (not linear)</p>\n\n<p>What is the piece of the puzzle I'm missing?</p>\n\n<p>I have a suspicion that my woes are because I failed to have a production that is $B\\implies^*a$ for some terminal $a \\in \\Sigma_{L_1}$ but I haven't observed that in the definitions thus far... and further unless B only goes to a terminal I'm in the same mess (if $B\\to t$ where $t \\in \\Sigma_{L_2} \\bigcup {\\epsilon} $ then I think I'm finished but how do I justify it?</p>\n", 'ViewCount': '99', 'Title': 'How can I show a linear languages are closed against concatenating with regular ones?', 'LastEditorUserId': '6551', 'LastActivityDate': '2013-04-04T10:55:25.213', 'LastEditDate': '2013-04-03T18:51:26.803', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10988', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Tags': '<formal-languages><context-free><closure-properties><check-my-proof>', 'CreationDate': '2013-04-03T02:16:07.357', 'Id': '10985''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to give a PDA and CFG for a language that contains all binary strings that start and end with the same symbol. I\'ve created the CFG with no problem, but I\'m stuck with the PDA and don\'t quite know how to accomplish it.</p>\n\n<p>The best I can figure is that I need to use non-determinism, but I don\'t quite know how to apply it in this circumstance.</p>\n\n<p>Here\'s the CFG that I came up with:</p>\n\n<p>\\begin{align*}\nA &amp;\\to 1B1 \\mid 0B0 \\mid \\epsilon\\\\\nB &amp;\\to 1B \\mid 0B\\mid \\epsilon\n\\end{align*}</p>\n\n<p>The PDA, insofar as I managed to come up with:</p>\n\n<p><img src="http://i.stack.imgur.com/sjkIy.jpg" alt="enter image description here"></p>\n\n<p>The notation here, just in case it\'s not universal: $a,b \\to c$ means "When you see symbol $a$, pop symbol $b$ off the stack and push symbol $c$ onto the stack."</p>\n\n<p>Any pointers on how to accomplish this?</p>\n', 'ViewCount': '426', 'Title': 'Give CFG and PDA for the words that start and end with the same symbol', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-04T12:02:49.387', 'LastEditDate': '2013-04-04T06:41:56.223', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11006', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<formal-languages><context-free><pushdown-automata>', 'CreationDate': '2013-04-04T01:15:46.140', 'Id': '11004''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am asked to construct a PDA to accept the language:</p>\n\n<p>$\\qquad \\{w \\in \\{0, 1\\}^* : \\#_{0}(w) \\ge \\#_{1}(w)\\}$</p>\n\n<p>I am wondering how to interpret the $\\#$ symbols and everything. Could someone please explain what exactly this means and how to construct it?</p>\n', 'ViewCount': '37', 'Title': 'How to interpret this formal language definition?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-04T06:38:34.707', 'LastEditDate': '2013-04-04T06:36:25.633', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<formal-languages><terminology>', 'CreationDate': '2013-04-04T01:28:55.580', 'Id': '11005''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $L$ be a regular language.<br>\nIs the language $L_2 = \\{y : \\exists x,z\\ \\ s.t.|x|=|z|\\ and\\ xyz \\in L \\}$ regular?</p>\n\n<p>I know it\'s very similar to the <a href="http://cs.stackexchange.com/questions/7588/regularity-of-middles-of-words-from-regular-language">question here</a>, but the catch is that it\'s not a simple substring of a word in a regular language, but rather an "exact middle" - we have to count the prefix and suffix length.</p>\n\n<p>Therefore, I assume it\'s not regular, but I couldn\'t find a way to prove it. I also couldn\'t think of any way to modify the NFA of $L$ to accept $L_2$.</p>\n', 'ViewCount': '145', 'Title': 'Regularity of the exact middle of words from a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-04T23:21:21.383', 'LastEditDate': '2013-04-04T23:21:21.383', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7577', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-04-04T15:05:08.010', 'FavoriteCount': '1', 'Id': '11018''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have an exercise in my book to come up with a pushdown automaton accepting a language.</p>\n\n<p>The exercise is to come up with a state diagram for the PDA accepting the language of all odd-length strings over $\\{a, b\\}$ with middle symbol $a$.</p>\n\n<p>Here\'s what I have so far...</p>\n\n<p><img src="http://i.stack.imgur.com/mNXvh.png" alt="enter image description here"></p>\n\n<p>I wasn\'t sure how many states I needed, but I was thinking 3. State $q_0$ for pushing symbols onto the stack until reaching the middle symbol, $q_1$ for after middle symbol is found, and state $q_2$ the accepting state. I think in $q_1$ I need to cancel out input symbols from the stack with the input. I don\'t know how to account for the string being odd length, also.</p>\n\n<p>Is there a smart, systematic way to do this?</p>\n', 'ViewCount': '446', 'Title': 'How to generate a pushdown automata for accepting a language?', 'LastActivityDate': '2013-04-04T19:13:35.593', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11028', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><automata><pushdown-automata>', 'CreationDate': '2013-04-04T18:48:13.270', 'Id': '11023''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to brush up on my regular grammar knowledge to prepare for an interview, and I just am not able to solve this problem at all. This is NOT for homework, it is merely me trying to solve this.</p>\n\n<p>I want to give a regular grammar for the language of the finite automaton whose screenshot is below, please help me, and if you can, a step by step answer would be of great assistance. Thank you!\n<img src="http://i.stack.imgur.com/y3WlZ.png" alt="screenshot"></p>\n', 'ViewCount': '186', 'Title': 'Giving a regular grammar for the language', 'LastEditorUserId': '917', 'LastActivityDate': '2013-04-05T11:50:25.610', 'LastEditDate': '2013-04-05T11:50:25.610', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'CSTHEORY', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-04-04T16:09:45.593', 'Id': '11024''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm a bit confused as to how to represent the Chomsky form for the language L that generates all strings with the alphabet {a}</p>\n\n<p>My approach was</p>\n\n<pre><code>S -&gt; AB | e\nA -&gt; a\n</code></pre>\n\n<p>Now here's the part I'm confused, how do I represent B? If B -> a then I get only even strings, if B -> e then it's not in normal form. :| Any help would be appreciated. </p>\n", 'ViewCount': '30', 'Title': 'Chomsky form for language of single alphabet member', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T11:19:25.227', 'LastEditDate': '2013-04-07T11:19:25.227', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11062', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7600', 'Tags': '<formal-languages><regular-languages><formal-grammars><normal-forms>', 'CreationDate': '2013-04-05T16:11:19.500', 'Id': '11061''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>$L = \\{a^n b^m | m \\not= n^2 \\}$ \nI guess I need to use Pumping Lemma for CFL in order to prove this. But I'm stuck.</p>\n\n<p>Assuming that $ a^n b^m = uvxyz$, we know that $v$ or $y$ can not have both $a$ and $b$ symbols in them. Otherwise pumping would generate strings not of the form $a^i b^j$.</p>\n\n<p>Hence both $v$ and $y$ must consist only of one kind of symbol each.\nBeyond this I wonder what string in $L$ has to be chosen in order to pump and obtain something of the form $a^n b^{n^2}$.</p>\n\n<p><em><strong>Alternative idea :</em></strong> Assuming that $L$ is context-free, then I must have a PDA accepting it by final state. Can I say that this PDA can be adjusted* to accept $L'$ i.e., all $a^n b^{n^2}$ ? However I know that $L'$ is not a CFL. Hence, contradiction ?</p>\n\n<p>*Adjusted = Make the non-final state on reading $a^n b^{n^2}$ as final and the rest as all non-final.</p>\n", 'ViewCount': '223', 'Title': 'Why is the following language not context-free?', 'LastEditorUserId': '7620', 'LastActivityDate': '2013-04-10T11:05:56.600', 'LastEditDate': '2013-04-08T15:54:42.337', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7620', 'Tags': '<formal-languages><context-free><automata><finite-automata><pumping-lemma>', 'CreationDate': '2013-04-07T18:09:51.310', 'Id': '11106''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The context-free languages are <em>not</em> closed under complement, we know that.</p>\n\n<p>As far as I understand, context-free languages that are a subset of $a^*b^*$ for some letters $a,b$ are closed under complement(!?)</p>\n\n<p>Here is my argument. Each CF language $L$ has a semi-linear Parikh image $\\pi(L) = \\{ (m,n) \\mid a^mb^n \\in L \\}$. Semilinear sets are closed under complement. The set of vectors that represent the semi-linear set can easily be transformed into a linear grammar.</p>\n\n<p><strong>Question.</strong> Is there an easily accessible reference to this fact?</p>\n\n<p>Technically these languages are called <em>bounded</em>, i.e., a subset of $w_1^* \\dots w_k^*$ for some words $w_1,\\dots,w_k$.</p>\n\n<p>My motivation for this question is from a recent <a href="http://cs.stackexchange.com/questions/11106/why-is-the-following-language-not-context-free">question</a> on the context-freeness of $\\{ a^nb^m \\mid n^2 \\neq m \\}$. Its complement within $a^*b^*$ seems easier to handle.</p>\n', 'ViewCount': '277', 'Title': 'Are context-free languages in $a^*b^*$ closed under complement?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T19:08:24.873', 'LastEditDate': '2013-04-07T20:00:05.160', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11142', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<formal-languages><reference-request><context-free><closure-properties>', 'CreationDate': '2013-04-07T19:05:16.153', 'Id': '11110''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Please help me understand, and if possible, tips, to determine a pumping length $p$. </p>\n\n<p>Suppose I have the example :</p>\n\n<p>Let $G$ be a Context-Free-Grammar with a set of variables $\\{S,A,B,C\\}$, set of terminals $\\{0,1\\}$, start variable $S$, and rules</p>\n\n<p>$S \\to ABA \\mid SS$<br>\n$A \\to S0 \\mid 1C1$<br>\n$B \\to S1 \\mid  0$<br>\n$C \\to 0$</p>\n\n<p>Now given the above, how do I find the pumping length $p$?<br>\nPlease explain how you actually got it from the grammar.</p>\n', 'ViewCount': '587', 'Title': 'How to find the pumping length of a context-free language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T13:13:54.443', 'LastEditDate': '2013-04-10T09:01:09.590', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7613', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-04-10T03:14:51.387', 'Id': '11183''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is the language $ L = \\{0^n 1^m \\mid n \\text{ and } m \\text{ are co-prime}\\}$ context-free ?</p>\n\n<p>I guess that it's not context free because it seems too complicated for a PDA to decided whether 2 numbers are co-prime or not.</p>\n\n<p>I tried using the pumping lemma to no avail.</p>\n\n<p>Any help would be gladly appreciated.</p>\n\n<p>Edit:</p>\n\n<p>Here is one of my failed attempts with the pumping lemma:</p>\n\n<p>Let $N$ be a constant. Take a prime $p$ such that $p &gt; N!$ and then take the word $z = 0^p 1^{p+N!} \\in L$. Let $ z = uvwxy $ be a decomposition of $z$ satisfying the conditions in the pumping lemma.</p>\n\n<p>If $ vx $ contains only zeros then $ |vx| = k $ is an integer between $1$ and $N$. Define $m$ as $m = N!/k$. For $i = m+1$ the word $ uv^iwx^iy = 0^{p+N!}1^{p+N!} \\not\\in L $</p>\n\n<p>However, I've failed to find such an integer $i$ for the other decomposition cases.</p>\n", 'ViewCount': '283', 'Title': 'Is the language $\\{0^n 1^m \\mid n \\text{ and } m \\text{ are co-prime}\\}$ context-free?', 'LastEditorUserId': '7068', 'LastActivityDate': '2013-04-12T20:05:43.350', 'LastEditDate': '2013-04-12T10:49:52.740', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-04-11T18:04:33.373', 'FavoriteCount': '3', 'Id': '11237''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have this problem:</p>\n\n<blockquote>\n  <p>Let $L_1$ and $L_2$ be two regular languages.  Show that $L_3 = \\{xx^r : x \\in L_1, x^r \\in L_2 \\}$ is a context-free language.</p>\n</blockquote>\n\n<p>I am unsure how to prove that some language is context-free. Could someone please provide the steps?</p>\n', 'ViewCount': '90', 'Title': 'Proving $\\{xx^R \\mid x\\in L_1, x^R\\in L_2\\}$ is context-free', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-12T07:21:14.713', 'LastEditDate': '2013-04-12T02:45:42.930', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11242', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-04-11T20:45:46.487', 'Id': '11240''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Specifying formal languages by giving formal grammars is a frequent task: we need grammars not only to describe languages, but also to parse them, or even <a href="http://scholar.google.com/scholar?q=secondary%20structure%20prediction%20stochastic%20grammars" rel="nofollow">do proper science</a>. In all cases, it is important that the grammar at hand is <em>correct</em>, that is generates exactly the desired words.</p>\n\n<p>We can often argue on a high-level why the grammar is an adequate representation of the desired language, omitting a formal proof. But what if we are in doubt or need a formal proof for some reason? What are techniques we can apply?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '417', 'Title': 'How to show that L = L(G)?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T13:55:49.570', 'LastEditDate': '2013-06-06T13:55:49.570', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<formal-languages><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-04-14T19:02:14.270', 'Id': '11315''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>$L = \\{a^i b^j a^k \\ | \\ k &gt; i + j\\}$</p>\n  \n  <p>Use the pumping lemma to show that this language cannot be accepted by an FA.</p>\n</blockquote>\n\n<p><strong>Proof:</strong></p>\n\n<p>Suppose $L$ can be accepted by an FA.</p>\n\n<p>Suppose a string $s = xyz \\in L$, where</p>\n\n<p>$$\\begin{align} \n&amp;x=a^n \\\\\n&amp;y=b \\\\\n&amp;z=a^{n+2} \n\\end{align}\n$$.</p>\n\n<p>Then a string $t = a^n b^i a^{n+2}$ should also be in $L$ for $i \\ge 0$, $n+i&lt;n+2$ and should also be accepted by an FA. But if $i=3$,</p>\n\n<p>$$\\begin{align} n+i = n + 3 \\\\&gt;n + 2 \\end{align}$$</p>\n\n<p>and $t \\not \\in L$, which is a contradiction. Thus, $L$ cannot be accepted by an FA.</p>\n\n<hr>\n\n<p>Is this proof thorough? I am worried about the line $n+i&lt;n+2$, because it doesn't work for all values of $i$. Should I pick a string that works for all possible cases?</p>\n", 'ViewCount': '201', 'Title': 'Using pumping lemma to show $L = \\{a^i b^j a^k \\ | \\ k > i + j\\}$ cannot be accepted by an FA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T11:33:14.773', 'LastEditDate': '2013-04-15T11:33:14.773', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11318', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><regular-languages><pumping-lemma><check-my-answer>', 'CreationDate': '2013-04-14T19:11:26.940', 'Id': '11317''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I understand that any CFL can be accepted by a PDA by final state or empty store but I have been rather stumped by this question.\nThe question states that the PDA has at most 2 states. Clearly 1 will be the start state while the other will be the final state (they cannot be the same since otherwise the empty string will be accepted). My initial idea was to take a grammar for $L$ in GNF (Greibach Normal Form) (refer to Ran's answer below for details on how a CFG in GNF can be converted to a PDA having 1 state and no $\\epsilon$-transitions that accepts by empty store) and then give a PDA for this that meets the specification. But the problem is that I cannot find a way to do this without having an $\\epsilon$-move at the final step when I have to move to the final state after the stack is empty. Any help would be greatly appreciated.</p>\n\n<p>The PDA can be specified as $M = (K, \\Sigma,\\delta, q_0, Z_0, \\{q_f\\} )$ where\n$q_0$ is the initial state, $Z_0$ is the initial stack symbol and $q_f$ is the final state. The exact question is</p>\n\n<blockquote>\n  <p>Show that if $L$ is a CFL and $\\epsilon$ does not belong to $L$, then there is a PDA $M$ accepting $L$ by final state such that $M$ has at most 2 states and makes no $\\epsilon$-moves.</p>\n</blockquote>\n\n<p>Thus, the PDA should</p>\n\n<ol>\n<li>accept by final state</li>\n<li>have at most 2 states</li>\n<li>make no $\\epsilon$-moves</li>\n</ol>\n", 'ViewCount': '357', 'Title': 'Designing a PDA w/o $\\epsilon$-moves and $\\leq 2$ states to accept an $\\epsilon$-free CFL by final state', 'LastEditorUserId': '7731', 'LastActivityDate': '2013-04-23T19:03:27.153', 'LastEditDate': '2013-04-16T03:57:47.927', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11335', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7731', 'Tags': '<formal-languages><context-free><automata><pushdown-automata>', 'CreationDate': '2013-04-15T01:15:08.810', 'Id': '11321''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a context-free language $L$, define the language $p(L)$ as containing all permutations of strings in $L$ (i.e. all strings in $L$ such that the order of symbols is not important). Is $p(L)$ context-free?</p>\n\n<p>I found two papers dealing with similar, but not identical, questions:</p>\n\n<ul>\n<li><p><a href="http://www.sciencedirect.com/science/article/pii/S0304397505008571" rel="nofollow">Generating all permutations by context-free grammars in Chomsky normal form</a> by Asveld (2003) deals with finite languages.</p></li>\n<li><p><a href="http://www.sciencedirect.com/science/article/pii/0020019082901090" rel="nofollow">Permutations are not context-free: An application of the interchange lemma</a> by Main (1982) deals with "permutation languages", i.e. sets of strings of the form $w x p(x) z$, where $p(x)$ is a any permutation of $x$. Also, the result is limited to alphabets with 16 symbols.</p></li>\n</ul>\n', 'ViewCount': '240', 'Title': 'Are permutations of context-free languages context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T14:34:16.553', 'LastEditDate': '2013-04-15T12:28:57.093', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11332', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<formal-languages><context-free><closure-properties><permutations>', 'CreationDate': '2013-04-15T12:09:49.237', 'Id': '11329''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="http://www.cs.utexas.edu/~ml/nldata/geoquery.html" rel="nofollow">GeoQuery</a> is a dataset used for benchmarking semantic parsers. It contains 880 queries about USA geography. The queries are in Prolog format, for example:</p>\n\n<blockquote>\n  <p>answer(A,longest(A,(river(A),traverse(A,B),const(B,countryid(usa)))))</p>\n</blockquote>\n\n<p>(this represents a question for the longest river that passes through the us).</p>\n\n<p>I have read <a href="http://www.citeulike.org/user/erelsegal-halevi/tag/geoquery" rel="nofollow">several papers about the GeoQuery</a>, but they don\'t seem to give a formal definition of the grammar underlying the dataset. The email address in the dataset page seem to be dysfunctional. So, my question (addressed primarily to researchers who have worked with the GeoQuery dataset before) is twofold:</p>\n\n<ul>\n<li>Is there a formal definition of the GeoQuery language?</li>\n<li>Is this language context-free?</li>\n</ul>\n\n<p>EDIT:</p>\n\n<p>It seems that, if the number of variables (A, B, C...) is unlimited, then GeoQuery is not context-free, because a CFG cannot make sure that two variables in different places are identical (this is similar to the {ww} language, which is not context-free).</p>\n\n<p>But what if we limit ourselves to A, B and C?</p>\n', 'ViewCount': '51', 'Title': 'The grammar of the GeoQuery language', 'LastEditorUserId': '1342', 'LastActivityDate': '2013-04-16T10:02:47.367', 'LastEditDate': '2013-04-16T10:02:47.367', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<formal-languages><context-free><semantics><natural-lang-processing>', 'CreationDate': '2013-04-15T13:22:36.020', 'Id': '11331''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For a regular language $L$, let $c_n(L)$ be the number of words in $L$ of length $n$. Using Jordan canonical form (applied to the unannotated transition matrix of some DFA for $L$), one can show that for large enough $n$,\n$$ c_n(L) = \\sum_{i=1}^k P_i(n) \\lambda_i^n, $$\nwhere $P_i$ are complex polynomials and $\\lambda_i$ are complex "eigenvalues". (For small $n$, we may have additional terms of the form $C_k[n=k]$, where $[n=k]$ is $1$ if $n=k$ and $0$ otherwise. These correspond to Jordan blocks of size at least $k+1$ with eigenvalue $0$.)</p>\n\n<p>This representation seems to imply that if $L$ is infinite then asymptotically, $c_n(L) \\sim C n^k \\lambda^n$ for some $C,\\lambda&gt;0$. However, this is patently false: for the language $L$ over $\\{0,1\\}$ of all words of even length, $c_{2n}(L) = 2^{2n}$ but $c_{2n+1}(L) = 0$. This suggests that for some $d$ and for all $a \\in \\{0,\\ldots,d-1\\}$, either $c_{dm+a}(L) = 0$ for large enough $m$ or $c_{dm+a} \\sim C_a (dm+a)^{k_a} \\lambda_a^{dm+a}$. This is proved in <a href="http://algo.inria.fr/flajolet/Publications/FlSe02.ps.gz">Flajolet &amp; Sedgewick</a> (Theorem V.3), who attribute the proof to Berstel.</p>\n\n<p>The proof provided by Flajolet and Sedgewick is somewhat technical; so technical, in fact, that they only sketch it. I attempted a more elementary proof using Perron-Frobenius theory. We can regard the transition graph of the DFA as a digraph. If the digraph is primitive then the result follows almost directly from the Perron-Frobenius theorem. If the digraph is irreducible but imprimitive with index $r$, then by considering the "$r$th power" of the DFA (each transition corresponds to $r$ symbols), we get the same result. The difficult case is when the digraph is reducible. We can reduce to the case of a path of strongly connected components, and then we get the result by estimating sums of the form\n$$ \\sum_{m_1+\\cdots+m_k=m} \\prod_{i=1}^k \\lambda_i^{m_i}. $$\n(Each such sum corresponds to a particular way of accepting a word, going through the different components in a certain way.) This sum, in turn, can be estimated by pinpointing the largest term, which corresponds to $m_i \\propto \\log \\lambda_i$. For every eigenvalue which is repeated $r$ times, we get an extra factor of $\\Theta(m^{r-1})$.</p>\n\n<p>The proof has its rough edges: in the reducible case, we need to pass from terms asymptotic to $C \\lambda_i^m$ to the sum mentioned above, and then we need to estimate the sum.</p>\n\n<p>The proof by Flajolet and Sedgewick is perhaps simpler, but less elementary. Its starting point is the rational generating function of $c_n(L)$, and it involves induction on the number of pole magnitudes (!). The basic idea is that all eigenvalues of maximal modulus are roots of unity (if normalized by their modulus), due to a (moderately easy) theorem of Berstel. Choosing an appropriate $d$ and looking at words of length $dm+a$, all these eigenvalues become real. Considering the partial fraction expansion, we get that if the eigenvalue of maximal modulus "survives", then it determines the asymptotics, which are of the form $Cn^k\\lambda^n$. Otherwise, we find a new rational generating function which corresponds just to words of this length (using an Hadamard product), and repeat the argument. The aforementioned quantity keeps decreasing, and so eventually we find the desired asymptotics; $d$ might have to grow in the process, to reflect everything that happens in the inductive steps.</p>\n\n<blockquote>\n  <p>Is there a simple and elementary proof for the asymptotic property of $c_n(L)$?</p>\n</blockquote>\n', 'ViewCount': '449', 'Title': 'Asymptotics of the number of words in a regular language of given length', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-27T16:50:23.943', 'LastEditDate': '2013-04-16T09:30:24.363', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '22', 'PostTypeId': '1', 'OwnerUserId': '683', 'Tags': '<formal-languages><reference-request><regular-languages><asymptotics><combinatorics>', 'CreationDate': '2013-04-16T01:37:16.013', 'FavoriteCount': '6', 'Id': '11350''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '408', 'Title': 'Is the intersection of two context free languages recursively enumerable?', 'LastEditDate': '2013-04-21T14:01:43.797', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Stephen', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Body': '<p>I read a quotation attributed to Sheila Greibach that says that the intersection of two context free grammars is recursively enumerable.</p>\n\n<p>I could not, however, find a citation for this quotation (and searching has failed to turn up a restatement of this result somewhere else).</p>\n\n<p>Can anyone provide a proof or a citation to the original proof for this result?  Can anyone state that it is false?</p>\n', 'Tags': '<formal-languages><computability><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:01:43.797', 'CommentCount': '2', 'AcceptedAnswerId': '11394', 'CreationDate': '2013-04-16T23:24:53.927', 'Id': '11393''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is the language $L = \\{ a^ib^j \\mid i\\ \\nmid\\ j \\ \\} $ context free ?</p>\n\n<p>If we fix $n \\in N$ then we know that the language $L = \\{ a^ib^j \\mid \\ \\forall \\ 1 \\le k \\le n \\ , \\ \\  j\\neq ki \\} $ is context free (as it can be presented as a finite union of context free languages in a similar way to the example here: <a href="http://cs.stackexchange.com/questions/10635/is-l-aibj-mid-j-neq-i-and-j-neq2i-context-free?rq=1">Is $L= \\{ a^ib^j \\mid j\\neq i \\ and \\ j\\neq2i \\ \\} $ context free?</a>)</p>\n\n<p>I think that it\'s not context free but have failed to prove it.\nBy reading other questions on this site I noticed this interesting observation: CFL\'s in $a^*b^*$ are closed under complement as can be seen here: <a href="http://cs.stackexchange.com/questions/11110/are-context-free-languages-in-ab-closed-under-complement">Are context-free languages in $a^*b^*$ closed under complement?</a> </p>\n\n<p>So our language $L$ is context free if and only if $ \\bar L = \\{ a^ib^j \\mid \\ \\ i\\ \\mid\\ j \\ \\} $ is context free. I tried using the pumping lemma but  to no avail.</p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '241', 'Title': 'Is the language $L = \\{ a^ib^j \\mid i\\ \\nmid\\ j \\ \\} $ context free?', 'LastActivityDate': '2013-11-21T01:06:06.003', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11634', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-04-19T10:08:37.820', 'FavoriteCount': '2', 'Id': '11405''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Prove that context free languages aren't closed under this operation: $ A(L) = \\{ zyx \\mid x,y,z \\in \\{0,1 \\}^*, xyz \\in L \\} $</p>\n\n<p>Obviously, we need to find a context free language $L$ such that $A(L)$ isn't context free. Here are some of my failed attempts:</p>\n\n<p>Take the language $ L = \\{\\ 0^n1^n \\mid n \\in N \\} $ and then (since the intersection of a context free language with a regular language is context free) we get: $ A(L) \\cap 1^*0^*1^*0^*  = \\{\\ 1^{m}0^{n-k}1^{n-m}0^{k} \\mid n,k,m \\in N, m,k\\le n \\} $ which might look promising at first, but unfortunately this language is context free...</p>\n\n<p>I also tried my luck with the following languages:<br>\n$ L = \\{\\ 0^n1^m0^m1^n \\mid n,m \\in N \\} $<br>\n$ L = \\{\\ ww^R \\mid w \\in \\{0,1 \\}^* \\} $  </p>\n\n<p>but these languages didn't help me either...</p>\n", 'ViewCount': '160', 'Title': 'Prove that context free languages are not closed under swapping prefixes and suffixes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T06:23:56.547', 'LastEditDate': '2013-04-24T06:23:56.547', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11526', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><closure-properties><pumping-lemma>', 'CreationDate': '2013-04-23T18:47:53.523', 'Id': '11525''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is the following language context free: $L = \\{ uxvy \\mid u,v,x,y \\in \\{ 0,1 \\}^+, |u| = |v|, u \\neq v, |x| = |y|, x \\neq y\\} $ ?</p>\n\n<p>I think that it's not context free but I'm having a hard time proving it. I tried intersecting this language with a regular language (like  $ \\ 0^*1^*0^*1^* $ for example) then use the pumping lemma and \\ or homomorphisms but I always get a language that is too complicated to characterize and write down. </p>\n", 'ViewCount': '797', 'Title': 'Is this strange language context free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-20T18:37:10.130', 'LastEditDate': '2013-06-13T05:51:03.333', 'AnswerCount': '3', 'CommentCount': '16', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><context-free><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-04-26T17:56:00.657', 'FavoriteCount': '10', 'Id': '11585''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Is $L=\\{ xyx \\mid x,y \\in \\{a,b\\}^* \\text {and } |x| \\ge 1 \\}$ context-free?</p>\n  \n  <p>If yes, please explain how we can write grammar or create a PDA for it. If not a CFL, then prove it through pumping lemma.</p>\n</blockquote>\n\n<p>I have tried to apply the pumping lemma with $w = a^nb^naba^nb^n$ as the word in $L$, but without success.</p>\n', 'ViewCount': '161', 'Title': u'Is {xyx | |x|\u22651} context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:15:37.917', 'LastEditDate': '2013-05-12T10:15:37.917', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7943', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2013-04-28T09:08:31.110', 'Id': '11629''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm stuck on this question about context-free languages and was hoping for some clarification.</p>\n\n<blockquote>\n  <p>$\\qquad L = \\{a^i b^j c^k \\mid  i=j, i=k\\}$ </p>\n  \n  <p>is <em>not</em> context-free. Show that its complement <em>is</em> context-free.</p>\n</blockquote>\n\n<p>I understand that the complement basically means everything not in $L$, that is $A^* \\setminus L$. However, I have no  idea how to actually take a complement for a language like  this.</p>\n", 'ViewCount': '1075', 'Title': 'How to take complement of a language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-01T10:54:01.700', 'LastEditDate': '2013-04-30T21:56:57.737', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'OwnerDisplayName': 'user2063561', 'PostTypeId': '1', 'Tags': '<formal-languages><terminology><context-free>', 'CreationDate': '2013-04-30T07:58:49.617', 'Id': '11672''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '156', 'Title': 'What type of formal notation is being used here to represent functional algorithms?', 'LastEditDate': '2013-05-03T02:16:49.393', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7129', 'FavoriteCount': '1', 'Body': '<p>Interested in learning more about algorithm design in functional programming, I picked up Andrew Bird\'s <a href="http://rads.stackoverflow.com/amzn/click/0521513383" rel="nofollow">Pearls of Functional Algorithm Design</a>.  I have experience with a number of programming languages, but my only experience with functional programming is in Scala.  I understood that I would have to pick-up Standard ML and Haskell from the description of the book, but when I started reading the first section, I wasn\'t familiar with some of the operators being used.</p>\n\n<p>Here are some examples of function definitions from the first chapter of the book (free to preview on Amazon):</p>\n\n<hr>\n\n<p><img src="http://i.stack.imgur.com/mVx5z.png" alt="weird syntax"></p>\n\n<p>I have seen "^" and "v" used to represent "and" and "or," but some of the other syntax (like <code>False (0,n)</code>) still throws me off.</p>\n\n<p><img src="http://i.stack.imgur.com/aSG9Z.png" alt="more weird syntax"></p>\n\n<p>In this one, I\'m not sure what the <code>accumArray(+)...</code> is referring to.  I\'m thinking it\'s like a fold method using addition, but I don\'t understand the rest of the line.</p>\n\n<p><img src="http://i.stack.imgur.com/JPWEZ.png" alt="kinda weird"></p>\n\n<p>Here, the author has done a good job of describing that \\\\ is <a href="http://en.wikipedia.org/wiki/Set_difference#Relative_complement" rel="nofollow">set difference</a> and the two vertical lines crossed with a horizontal one is <a href="http://en.wikipedia.org/wiki/Union_%28set_theory%29" rel="nofollow">union</a>.  However, I\'ve never seen anything like that union symbol before.</p>\n\n<hr>\n\n<p>I don\'t want to know what each of these examples means as much as I want to know <strong>what library of formal representation is Bird using to represent these algorithms</strong>, and also, if a specific programming language (Haskell/SML?) syntax is being used as well in conjunction with these special symbols.</p>\n', 'Tags': '<algorithms><formal-languages><functional-programming><notation>', 'LastEditorUserId': '7129', 'LastActivityDate': '2013-05-03T02:16:49.393', 'CommentCount': '5', 'AcceptedAnswerId': '11710', 'CreationDate': '2013-05-01T17:48:19.410', 'Id': '11707''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am studying parsing, i.e. bottom-up parsing. it is said that there some rules which are used by weak precedence grammar. What does weak precedence grammar mean? What about precedence relation?</p>\n\n<p>Any help will be appreciated. If it is possible, could you give an example. Thanks</p>\n', 'ViewCount': '59', 'Title': 'Weak Precedence Grammar and Parsing', 'LastActivityDate': '2013-05-29T22:21:32.073', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11753', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7957', 'Tags': '<formal-languages><terminology><context-free><parsers>', 'CreationDate': '2013-05-02T11:42:03.387', 'Id': '11730''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $\\mbox{bin}(n)$ denote the binary representation of an integer $n$.  Let $L = \\{ \\mbox{bin}(n^2) \\mid n \\in \\mathbb{N} \\}$.</p>\n\n<blockquote>\n  <p>Is $L$ a regular language?</p>\n</blockquote>\n\n<p>I think one can prove that $L$ is not regular by using the pumping lemma, but I don't know how to use it here.</p>\n", 'ViewCount': '259', 'Title': 'Is the language of binary representation of perfect squares regular?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-05-05T16:48:05.990', 'LastEditDate': '2013-05-05T08:33:29.370', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '7', 'OwnerDisplayName': 'user15735', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-05-03T17:53:37.580', 'FavoriteCount': '3', 'Id': '11770''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm doing some research regarding NFAs and inclusion problems with them. I know that in general, the inclusion problems, and converting to an unambiguous NFA, are both PSPACE-complete.</p>\n\n<p>I'm wondering, are there any sub-classes of NFA for which these can be decided efficiently? In particular, the NFAs I'm looking at accept finite language where all words have the same Parikh vector.</p>\n", 'ViewCount': '107', 'Title': 'Classes of NFAs which allow efficient subset testing or unambiguity conversions', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-06-13T16:33:18.830', 'LastEditDate': '2013-05-06T23:38:41.717', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-05-06T22:26:42.443', 'FavoriteCount': '1', 'Id': '11841''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>As per the title I was wondering if it's possible for a language $L \\subseteq \\Sigma^{*}$ to have $\\Sigma^{*}$ as its syntactic monoid and if so could one give an example of such a language? I first thought that this was probably an easy question with a simple answer but I haven't been able to make much progress with it, maybe it has a simple answer and I am just overlooking it?</p>\n\n<p>If we look at the syntactic congruence $\\sigma_L = \\{(w,z) \\in \\Sigma^{*} \\times \\Sigma^{*}: (\\forall u, v \\in \\Sigma^{*}) \\; uwv \\in L \\Leftrightarrow uzv \\in L\\}$ we see that in order to have $w \\cong_{\\sigma_{L}} z \\Leftrightarrow w = z$ we must have that $(\\forall w, z \\in \\Sigma^{*} \\; w \\not = z) \\; (\\exists u, v \\in \\Sigma^{*})\\; uwv \\in L \\Leftrightarrow uzv \\notin L$. Which seems like quite a strong condition. It's also clear that such a language couldn't be regular as it is known that a language is regular if and only if it has a finite syntactic monoid.</p>\n", 'ViewCount': '144', 'Title': 'Can a language have $\\Sigma^{*}$ as its syntactic monoid?', 'LastEditorUserId': '769', 'LastActivityDate': '2013-05-13T22:26:23.117', 'LastEditDate': '2013-05-13T15:44:37.470', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '11993', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '769', 'Tags': '<formal-languages>', 'CreationDate': '2013-05-08T11:05:09.900', 'Id': '11889''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I\'ve been reading some formal language theory papers, and I\'ve come across a term that I don\'t understand.</p>\n\n<p>The paper will often refer to a set being "effectively closed under intersection" or other operations. What does "effectively" mean here? How does this differ from normal closure?</p>\n\n<p>For reference, the paper I\'m seeing these in is:</p>\n\n<p>M. Daley and I. McQuillan. Formal modelling of viral gene compression. International Journal of Foundations of Computer Science, 16(3):453\u2013469, 2005.</p>\n', 'ViewCount': '125', 'Title': 'What does it mean to say that a language is "effectively closed" under an operation?', 'LastActivityDate': '2013-05-09T20:16:49.303', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11922', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><terminology><computability><automata><closure-properties>', 'CreationDate': '2013-05-09T19:51:28.577', 'Id': '11920''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am doing homework in Formal Languages. I urgently need a language which can be recognised by 2 PDA's but not with 1 PDA. Thanks</p>\n", 'ViewCount': '598', 'Title': 'PDA with 2 stacks', 'LastActivityDate': '2013-05-11T22:39:06.897', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11928', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '7957', 'Tags': '<formal-languages><pushdown-automata>', 'CreationDate': '2013-05-10T06:38:48.983', 'FavoriteCount': '1', 'Id': '11925''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Consider formal language $L$ over finite alphabet $\\Sigma$ consisting of all words over $\\Sigma$ that have non-trivial period (non empty prefix that is also a suffix). Is $L$ always context free?</p>\n</blockquote>\n\n<p>Maybe pumping lemma will do? I was advised to try with a word $a^Nb^Na^Nb^N$ but if I pump only second block of $a$ then this word still is in $L$, because it has non empty prefix $a^Nb^N$ that is also a suffix.</p>\n', 'ViewCount': '72', 'Title': 'Is $L$ always context free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:11:19.127', 'LastEditDate': '2013-05-12T10:08:58.070', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8041', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-05-10T09:54:06.687', 'Id': '11929''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am converting NFA <b>with $\\varepsilon$-moves </b> to the NFA <b>without </b> $\\varepsilon$-null moves. I understand that if, there is a $\\varepsilon$-move between, $q_i$ and $q_j$, then all edges from $q_j$ have to be repeated from $q_i$. And if the $q_j$ is a final state, then $q_i$ will also be a final state.</p>\n\n<p>But, if $q_j$ does not contain any transition, i.e., there are no edges starting from $q_j$, then what has to be done? </p>\n', 'ViewCount': '673', 'Title': 'How to convert NFA with null moves to NFA without null moves?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-05-16T16:06:25.040', 'LastEditDate': '2013-05-14T06:58:57.550', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8155', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-05-14T05:56:21.350', 'Id': '12003''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Where can I find a proof of this? Thanks!</p>\n', 'ViewCount': '918', 'Title': 'Proof that the regular languages are closed under string homomorphism', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-10-03T14:16:12.663', 'LastEditDate': '2013-05-16T02:20:15.170', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user16022', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-05-14T01:07:04.453', 'FavoriteCount': '2', 'Id': '12017''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '712', 'Title': 'Example of a non-context free language that nonetheless CAN be pumped?', 'LastEditDate': '2013-05-17T06:43:11.733', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8197', 'FavoriteCount': '2', 'Body': "<p>So basically L satisfies the conditions of the pumping lemma for CFL's but is not a CFL (that is possible according to the definition of the lemma).</p>\n", 'Tags': '<formal-languages><context-free><pumping-lemma>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-17T06:43:11.733', 'CommentCount': '3', 'AcceptedAnswerId': '12044', 'CreationDate': '2013-05-15T16:01:57.900', 'Id': '12041''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to (intuitively) understand the two terms "decidability" and "verifiability".</p>\n\n<p>I have done a reasonable amount of searching and going through the various texts I can put my hands on. However, their intuitive understanding seems to escape me, specially for the second one.</p>\n\n<p>Out of the many definitions found, the following one found in <a href="http://kilby.stanford.edu/~rvg/154/handouts/decidability.html" rel="nofollow">this page</a>, clearly explained decidability to me.</p>\n\n<blockquote>\n  <p>A language is called decidable if there exists a method - any method\n  at all - to determine whether a given word belongs to that language or\n  not.</p>\n</blockquote>\n\n<p>However, I fail to find a parallel definition for verifiability.</p>\n\n<p>In the <a href="http://rads.stackoverflow.com/amzn/click/0534950973" rel="nofollow">Theory of Computation book by Sipser</a>, we find,</p>\n\n<blockquote>\n  <p>P = the class of languages for which membership can be <em>decided</em>\n  quickly. </p>\n  \n  <p>NP = the class of languages for which membership can be\n  <em>verified</em> quickly.</p>\n</blockquote>\n\n<p>In light of the above, I want to understand verifiability. </p>\n\n<p>Please provide as many examples as you can, at one moment, I try catch the meaning, in the next one, I get confused again.</p>\n', 'ViewCount': '154', 'Title': 'Please explain "decidability" and "verifiability"', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-17T18:15:56.733', 'LastEditDate': '2013-05-17T06:41:56.163', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12079', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7200', 'Tags': '<complexity-theory><formal-languages><terminology><computability>', 'CreationDate': '2013-05-16T13:44:06.820', 'Id': '12068''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So, I have a book here, which has an example for context sensitive grammar, and the grammar is the famous $0^n1^n2^n$ , and it has:</p>\n\n<p>$$ \\begin{align}\nS  &amp;\\rightarrow 0BS2 \\mid 012 \\\\\nB0 &amp;\\rightarrow 0B \\\\\nB1 &amp;\\rightarrow 11 \\\\\n\\end{align} $$</p>\n\n<p>I agree that the above works, but what is wrong with just saying:\n$S\\rightarrow 0S12 |\\epsilon$</p>\n\n<p>The above also generators the same number of $0$s as $1$s and $2$s.</p>\n', 'ViewCount': '60', 'Title': 'Can this grammar be simplified?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-19T14:56:16.890', 'LastEditDate': '2013-05-19T14:56:16.890', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8104', 'Tags': '<formal-languages><formal-grammars><context-sensitive>', 'CreationDate': '2013-05-17T18:13:47.270', 'Id': '12090''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was wondering when languages which contained the same number of instances of two substrings would be regular. I know that the language containing equal number of 1s and 0s is not regular, but is a language such as $L$, where $L$ = $\\{ w \\mid$ number of instances of the substring "001" equals the number of instances of the substring "100" $\\}$ regular? Note that the string "00100" would be accepted.</p>\n\n<p>My intuition tells me it isn\'t, but I am unable to prove that; I can\'t transform it into a form which could be pumped via the pumping lemma, so how can I prove that? On the other hand, I have tried building a DFA or an NFA or a regular expression and failed on those fronts also, so how should I proceed? I would like to understand this in general, not just for the proposed language.</p>\n', 'ViewCount': '249', 'Title': 'Is the language of words containing equal number of 001 and 100 regular?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-06-01T15:26:45.267', 'LastEditDate': '2013-05-30T23:55:28.277', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8257', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-05-19T21:07:17.520', 'Id': '12139''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If A many-one reduces to B, does the complement of A many-one reduce to the complement of B? My gut says no but I am having a hard time finding a counterexample.</p>\n', 'ViewCount': '115', 'Title': 'If A many-one reduces to B, does the complement of A many-one reduce to the complement of B?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-06-20T02:38:20.557', 'LastEditDate': '2013-05-21T01:57:38.250', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8273', 'Tags': '<complexity-theory><formal-languages><reductions>', 'CreationDate': '2013-05-20T20:07:12.047', 'Id': '12168''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Exactly as stated in the subject. I look for grammar which use letters $a, b ,c$ that numbers of letters $c$ is greater than number of letters $b$.</p>\n\n<p>Example: $acbccba$ is generated by the grammar.</p>\n\n<p>I thought about:</p>\n\n<p>$S \\rightarrow aS \\mid bS \\mid SCS$</p>\n\n<p>$ C \\rightarrow cb \\mid ca$</p>\n\n<p>but not sure if it works. Could you help me, please.</p>\n', 'ViewCount': '207', 'Title': 'Grammar that numbers of letters `c` is greater than number of letters `b`', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-12-07T12:49:27.610', 'LastEditDate': '2013-05-21T13:10:00.820', 'AnswerCount': '5', 'CommentCount': '8', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8277', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-05-21T08:30:31.687', 'FavoriteCount': '0', 'Id': '12179''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can I deal with recursive terminals in CFG when converting it to CNF? For example,</p>\n\n<p>S -> MN</p>\n\n<p>M -> AM | A</p>\n\n<p>N -> BN | B</p>\n\n<p>A -> a</p>\n\n<p>B -> b</p>\n\n<p>How can I reduce terminals M and N?</p>\n', 'ViewCount': '95', 'Title': 'CNF: Recursion in CFG', 'LastActivityDate': '2013-05-23T11:33:44.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7809', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-05-22T23:30:34.303', 'Id': '12221''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider the following <em>universe problem</em>.</p>\n\n<blockquote>\n  <p><strong>The universe problem.</strong> Given a finite set $\\Sigma$ for a class of languages, and an automaton accepting the language $L$, decide if $L=\\Sigma^*$.</p>\n</blockquote>\n\n<p>In [1], it is stated and proved that the universe problem is undecidable for a particular class of one-counter automata. This result then follows for the class of all non-deterministic one-counter automata. I\'m wondering if it is known whether this problem is still undecidable when we restrict the size of the input alphabet of the automaton. </p>\n\n<p>I think that with alphabet size 1 the problem becomes decidable, but what about size 2? And if that turns out to be decidable what is the smallest value of $n \\in \\mathbb{N}$ such that the problem is undecidable.</p>\n\n<p>I think it\'s probable that the answer to this question is known but I\'m having trouble finding an answer. If it is already known then I would appreciate a reference.</p>\n\n<hr>\n\n<p>[1] <a href="http://link.springer.com/article/10.1007%2FBF01744294">Ibarra, O. H. (1979). Restricted one-counter machines with undecidable universe problems. Mathematical systems theory, 13(1), 181-186</a></p>\n', 'ViewCount': '126', 'Title': 'Is the universe problem for one-counter automata with restricted alphabet size undecidable?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T15:29:14.707', 'LastEditDate': '2013-05-23T17:42:41.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12235', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '769', 'Tags': '<formal-languages><reference-request><automata><undecidability><decision-problem>', 'CreationDate': '2013-05-23T16:56:50.530', 'Id': '12233''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to find two languages, $L_1, L_2 \\in RE \\setminus R$, such that $L_1 \\cup L_2 \\in R$.</p>\n\n<p>I have already proved that if $L_1\\cap L_2 \\in R$ <strong>and</strong> $L_1 \\cup L_2 \\in R$, such $L_1, L_2$ don't exist (because otherwise we'll be able to construct a Turing Machine $M_1$ which will decide $L_1$, for instance).</p>\n\n<p>However, I cannot prove that it's impossible in the case $L_1\\cap L_2 \\in RE \\setminus R$, and I can't find such languages.</p>\n", 'ViewCount': '290', 'Title': 'Is it possible that the union of two undecidable languages is decidable?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-26T05:45:47.917', 'LastEditDate': '2013-05-26T05:45:47.917', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '12253', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7611', 'Tags': '<formal-languages><turing-machines><undecidability>', 'CreationDate': '2013-05-24T18:46:22.450', 'Id': '12252''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Hello for a homework I have to show that deciding whether a regex over $\\Sigma = \\{0,1\\}$ descibes $\\Sigma^*$ is $\\mathsf{coNP}$ complete (this is irrelevant for the question though).</p>\n\n<p>The thing which irrs me is that I think this problem is in $\\mathsf{P}$.</p>\n\n<p>Here is my argumentation:</p>\n\n<p>Let $R$ be a regex, then we have $$L(R) = \\{0,1\\}^* \\Leftrightarrow \\overline{L(R)} = \\varnothing$$</p>\n\n<p>Given $R$ we can consruct an NFA with $\\epsilon$ moves for $L(R)$ in poly. time; eliminating the $\\epsilon$ moves (again poly. time: $O(|Q| \\cdot |\\delta| \\cdot |\\Sigma|)$) we obtain an NFA $M$.</p>\n\n<p>By toggling the accepting states of $M$ we can construct an NFA which accepts $\\overline {L(R)}$, whose emptiness we can check with a BFS (again in poly. time).</p>\n\n<p>$\\leadsto \\mathsf{RegExpEq_{*}} \\in \\mathsf{P}$</p>\n\n<p>Where does my argumentation shatter? If both my argumentation and the question is correct, then $\\mathsf{P} = \\mathsf{coNP}$ which seems highly doubtful.</p>\n', 'ViewCount': '64', 'Title': "$\\mathsf{RegExpEq_*} \\in \\mathsf{coNPC}$ but why isn't in $\\mathsf{P}$", 'LastEditorUserId': '8368', 'LastActivityDate': '2013-06-23T12:02:53.363', 'LastEditDate': '2013-05-26T14:56:26.050', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12297', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8368', 'Tags': '<complexity-theory><formal-languages>', 'CreationDate': '2013-05-26T14:49:42.683', 'Id': '12296''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it theoretically possible to have a nondeterministic finite state machine without any initial state or does it need at least one initial state?</p>\n', 'ViewCount': '122', 'Title': 'Nondeterministic finite state machine without any initial state possible', 'LastActivityDate': '2013-05-29T15:15:48.100', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8414', 'Tags': '<formal-languages><regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2013-05-28T18:27:39.930', 'Id': '12338''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="http://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://www.cs.rpi.edu/~moorthy/Courses/modcomp/fall2005/slides/DPDA.ppt&amp;ei=qI6mUeD6KaKOigLr-YH4Cg&amp;usg=AFQjCNHdu1SacbRI9CaOjOvXxzNziaHtEQ&amp;sig2=DLSgGZ-VegxX1lFVSTZTCw&amp;bvm=bv.47244034,d.cGE">These lecture slides</a> sketch a proof that $L=\\{ a^n b^n \\mid n \\geq 0 \\} \\cup  \\{ a^n b^{2n} \\mid n \\geq 0 \\}$\ncannot be accepted by any Deterministic Pushdown Automaton. Unfortunately, the slides give no references as to where the proof comes from.</p>\n\n<p>I was wondering, does anybody know of an academic paper or textbook that gives a full proof? I\'d love to be able to cite it, but I haven\'t been able to find one.</p>\n', 'ViewCount': '143', 'Title': 'Paper with proof that $L=\\{ a^n b^n \\mid n \\geq 0 \\} \\cup \\{ a^n b^{2n} \\mid n \\geq 0 \\}$ is not Deterministic Context Free?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-29T20:10:06.177', 'LastEditDate': '2013-11-29T20:10:06.177', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12367', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><reference-request><automata><pushdown-automata><nondeterminism>', 'CreationDate': '2013-05-29T23:32:51.367', 'Id': '12365''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '163', 'Title': 'Is $L = \\{a^jb^ia^{j-i}\\mid i,j \\ge 0\\ , j > i\\}$ context-free?', 'LastEditDate': '2013-05-31T17:13:01.660', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7917', 'FavoriteCount': '1', 'Body': "<p>I'm exercising for an upcoming exam and I find this exercise:</p>\n\n<blockquote>\n  <p>Say whether or not the language \n  $$L = \\{a^jb^ia^{j-i}\\mid i,j \\ge 0\\ , j &gt; i\\}$$\n  is a context-free language. Justify your answer.</p>\n</blockquote>\n\n<p>I have already tried (using the pumping lemma for CFL) with two different words:\n$$w1 = \\  a^pb^{p-1}a$$\n$$w2 = \\  a^{2p}b^pa^p$$</p>\n\n<p>but I'm stuck when the case is that $vwx$ (considering $uvwxy = w$) take letters from both the first group of $\\bf{a}$ and the group of $\\bf{b}$.<br>\nHave I chosen a wrong format for the word or am I simple missing some trivial condition?</p>\n", 'Tags': '<formal-languages><context-free><pumping-lemma>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-01T15:22:31.090', 'CommentCount': '2', 'AcceptedAnswerId': '12375', 'CreationDate': '2013-05-30T09:06:03.837', 'Id': '12370''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '171', 'Title': 'What does the R superscript notation mean in regular/formal languages?', 'LastEditDate': '2013-06-02T03:05:54.667', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8482', 'FavoriteCount': '1', 'Body': "<p>What does the capital R superscript notation mean in regular languages?  I am working on a homework assignment and don't recall my professor mentioning what the what the R superscript means.  For example in this syntax:</p>\n\n<p>$L = \\{ww^R\\mid w \\in \\Sigma^{\\ast} \\}$</p>\n", 'Tags': '<formal-languages><regular-languages><formal-grammars><notation>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-02T03:05:54.667', 'CommentCount': '0', 'AcceptedAnswerId': '12422', 'CreationDate': '2013-06-02T02:11:28.330', 'Id': '12421''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Constructivist logic is a system which removes the Law of the Excluded Middle, as well as \nDouble Negation, as axioms. It\'s described on Wikipedia <a href="http://en.wikipedia.org/wiki/Constructivist_logic">here</a> and <a href="http://en.wikipedia.org/wiki/Mathematical_constructivism">here</a>. In particular, the system doesn\'t allow for proof by contradiction.</p>\n\n<p>I\'m wondering, is anyone familiar with how this affects results regarding Turing Machines and formal languages? I notice that almost every proof that a language is undecidable relies on proof by contradiction. Both the Diagonalization argument and the concept of a reduction work this way. Can there ever be a "constructive" proof of the existence of an undecidable language, and if so, what would it look like?</p>\n', 'ViewCount': '504', 'Title': 'Do undecidable languages exist in constructivist logic?', 'LastActivityDate': '2013-07-11T06:23:13.290', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '12502', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><turing-machines><logic><proof-techniques><undecidability>', 'CreationDate': '2013-06-06T16:25:28.620', 'FavoriteCount': '2', 'Id': '12492''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My question refers to the draft of <a href="http://www.liafa.jussieu.fr/~jep/PDF/MPRI/MPRI.pdf" rel="nofollow">Mathematical Foundations of Automata Theory</a>, IV.2.1 (pages 89ff in the pdf). I will repeat everything necessary nevertheless:</p>\n\n<p>Let $M,N$ be monoids and $\\varphi: M \\rightarrow N $ a monoid morphism. We say that a subset $L$ of $M$ is recognizable by $\\varphi$ if there is a subset $P$ of $N$ such that $L = \\varphi^{-1}(P)$. As is known, the rational languages are precisely the recognizable subsets of $\\Sigma^\\ast$.</p>\n\n<p>Furthermore, we define an equivalence relation $R_\\varphi$ by $u R_\\varphi v :\\Leftrightarrow \\varphi(u)=\\varphi(v)$. \nThis relation is a congruence relation, that is $\\forall s,t,u,v \\in M:s R_\\varphi t \\Rightarrow usv~R_\\varphi~utv$.</p>\n\n<p>We say that a congruence relation $R$ <em>saturates</em> $L$ if for all $u \\in L$, $uRv$ implies $v \\in L$.\nThen in the above document, the following proposition (IV.2.2, page 90) is stated:</p>\n\n<p>Let $\\varphi : M \\rightarrow N$ be a monoid morphism and let\n$L$ be a subset of $M$. The following conditions are equivalent:</p>\n\n<p>(1) $L$ is recognised by $\\varphi$</p>\n\n<p>(2) $L$ is saturated by $R_\\varphi$</p>\n\n<p>(3) $\\varphi^{-1}(\\varphi(L))=L$</p>\n\n<p>Proof. (1) implies (2). If $L$ is recognised by $\\varphi$, then $L=\\varphi^{-1}(P)$ for some subset $P$ of $N$. Thus if $x \\in L$ and $x R_\\varphi y$, one has $\\varphi(x) \\in P$ and since $\\varphi(x)=\\varphi(y), y \\in \\varphi^{-1}(P)=L$.</p>\n\n<p>(2) implies (3). If $x \\in \\varphi^{-1}(\\varphi(L))$, there is $y \\in L$ such that $\\varphi(x) = \\varphi(y)$, that is $x R_\\varphi y$. Thus, $x \\in L$, and $\\varphi^{-1}(\\varphi(L)) \\subseteq L$ follows. "$\\supseteq$" is trivial.</p>\n\n<p>(3) implies (1). Let $P:=\\varphi(L)$, then $\\varphi^{-1}(P)=L$. </p>\n\n<p>I want to weaken the assumptions made in the proposition. Namely, assume tgat the  $N$ in the above definitions is a proper groupoid (in fact, I need to deal with loops), that is, associativity and identity are lost. Further, $\\varphi$ need not be a morphism (the relation $R_\\varphi$, defined in the same way as above, a priori need not be a congruence anymore) and we restate (1) accordingly (as formally, the notion of a "recognable subset" is not defined for groupoids).\nThen my questions are</p>\n\n<blockquote>\n  <p>(1) Is $R_\\varphi$ still a congruence if we demand $\\varphi$ \n  to be a morphism of groupoids (loops)?</p>\n  \n  <p>(2) Does the proposition still hold? Does it if we assume that $R_\\varphi$ is  <em>not</em> a congruence?</p>\n  \n  <p>(3) What other sources (preferably monographs) are there that you recommend as comprehensive introductions to algebraic automata theory, esp. concerned with the role of monoids, semigroups (and maybe more general structures as groupoids) and their connection with automata and languages?</p>\n</blockquote>\n\n<p>Personally, I think they are both true, as for (2), neither the morphism properties, nor associativity nor congruences seem to be used in the proof. And for (1), I don\'t see where one would need associativity to prove it. \nBut it may well be that I overlooked something (which is why I ask...).</p>\n', 'ViewCount': '77', 'Title': 'Quasigroups, congruences and recognizable subsets', 'LastActivityDate': '2013-06-08T16:55:03.373', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '12536', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><check-my-proof>', 'CreationDate': '2013-06-07T19:09:01.057', 'Id': '12515''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $L$ be a star-free language over finite alphabet $\\Sigma$.  A <em>substitution</em> will be a map $\\sigma : \\Sigma \\to \\mathcal{P}(\\Sigma^*)$.  It seems obvious that if $\\sigma(a)$ is star-free for every $a \\in \\Sigma$, then $\\sigma(L)$ will be star-free.<br>\n($\\sigma(L) = \\{ w_1 ... w_n | w_i \\in \\sigma(a_i) \\land a_1 \\ldots a_n \\in L \\}$)\nTake a star-free regular expression for $L$, and substitute star-free expressions for $L_i$\nfor each $a_i$ in that expression.  The result will still be a star-free expression.</p>\n\n<p>Now, my question is this: why is the following not a counterexample?\n$\\Sigma = \\{ 0, 1 \\}$. $L = 1^*$ and $\\sigma(1) = 0^* 1 0^* 1 0^*$.\nBoth of these languages are star-free:\n$L = L( (\\emptyset^c 0 \\emptyset^c )^c )$ and similar tricks can be given to show that $\\sigma(1)$ is star-free.</p>\n\n<p>Now, the reason it seems like a counterexample: a word in $L$ contains only 1s. The substitution replaces each 1 with a word from a language whose words contain exactly 2 1s.\nSo won't $\\sigma(L)$ be the set of words with an even number of 1s, which is known to be non-star-free?</p>\n\n<p>(Note: my proof suggestion of closure under substitution is a bit sketchy.  The star-free expression for $1^*$ only has 0s in it.  But I could then substitute \nthe star-free expression for $\\sigma(1)$ under a complement, no?)</p>\n", 'ViewCount': '78', 'Title': 'Closure of Star-Free Languages under Substitution', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:40:43.930', 'LastEditDate': '2013-06-10T09:40:43.930', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12550', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8590', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-06-08T21:54:25.707', 'Id': '12546''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a question from <a href="http://cs.anu.edu.au/courses/COMP3630/comp3630exams.pdf" rel="nofollow">a 2007 exam paper for a course I\'m studying</a>, question 2 on page 2.</p>\n\n<blockquote>\n  <p>Theorem: Let $L$ be a context-free language. Let $L_{even}$ be the subset of $L$ consisting of all the strings in $L$ that have even length. Then $L_{even}$ is context-free.</p>\n</blockquote>\n\n<p>The question is to prove this theorem using two of three different methods: using grammars, PDAs, or a theorem about language intersections.</p>\n\n<p>I can very easily find a proof using PDAs (maintain your current odd/even status using the stack), and intersections (intersect with $\\Sigma^*_{even}$, which is regular) - but I can\'t think of how to do it using properties of grammars. I suspect either Chomsky or Greibach Normal Forms comes in handy here but I\'m not sure how.</p>\n', 'ViewCount': '89', 'Title': 'Proving that CFLs are closed under even-ness using grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T10:36:08.340', 'LastEditDate': '2013-06-10T10:33:55.813', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '12557', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8591', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties>', 'CreationDate': '2013-06-09T02:53:21.853', 'Id': '12554''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have the following formal grammar: $$G= (\\{S,A,B\\},\\{a,b\\},R,S)$$ $$R=\\{S \\rightarrow A\\ |B, A \\rightarrow \\varepsilon\\ | aA\\ |bA, B \\rightarrow \\varepsilon\\ |Bb\\ | b\\}$$</p>\n\n<p>Now, we see, the production rules $A \\rightarrow \\varepsilon$ and  $B \\rightarrow \\varepsilon$ implies that this grammar is not context-sensitiv ($CSG$). But on the other hand, we see this grammar satisfies the conditions for a context-free ($CFG$) grammar, because every production rule has just one NON-terminal on the left side.</p>\n\n<p>We know, according to the Chomsky hierarchy, a contest-free grammar imples a contest-sensitive grammar: $CFG \\implies CSG$</p>\n\n<p>Now i am confused, is my grammar context-free or it is not, even if it satisfies the conditions? Can it be $CFG$ without being $CSG$?</p>\n', 'ViewCount': '291', 'Title': 'Is this formal grammar context-free (CFG) but not context-sensitive (CSG)?', 'LastActivityDate': '2013-06-11T19:48:57.843', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12627', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6828', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-06-11T13:48:24.840', 'Id': '12620''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $L$ be a language such that $\\overline{L}^R$ (the reversal of the complement of $L$) is context-free. Is then also $\\overline{(L^R)} \\in \\mathrm{CFL}$?</p>\n', 'ViewCount': '59', 'Title': 'Is CFL closed against exchanging complementation and reversal?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-15T15:22:42.030', 'LastEditDate': '2013-06-15T15:22:42.030', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'Guy', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2013-06-11T18:02:04.590', 'Id': '12631''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '124', 'Title': 'Myhill-Nerode style characterization of CFL?', 'LastEditDate': '2013-11-02T13:57:51.987', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5323', 'FavoriteCount': '2', 'Body': '<p>Define the <em>Nerode equivalence</em> over a language $L \\subseteq \\Sigma^{*}$ as $u \\sim_L v$ iff $uw \\in L \\Leftrightarrow vw \\in L$ for every $w \\in \\Sigma^{*}$.</p>\n\n<p>The Nerode equivalence ${\\sim}_L$ has finitely many equivalence classes precisely when $L$ can be recognized by a finite-state automaton.  This is the <a href="http://en.wikipedia.org/wiki/Myhill%E2%80%93Nerode_theorem" rel="nofollow">Myhill-Nerode theorem</a>.</p>\n\n<blockquote>\n  <p>Is there a similar characterization of context-free languages?</p>\n</blockquote>\n\n<hr>\n\n<h1>Motivation:</h1>\n\n<p>The Nerode equivalence classes each correspond to a distinct state in any automaton that recognizes $L$.  Each CFL can be recognized by an NPDA, which has a finite number of states but also a potentially unbounded stack of alphabet symbols.  The stack keeps track of one possible way that a string can be parsed.  The number of equivalence classes may be infinite since the stack can store an unbounded number of symbols.</p>\n\n<p>I am asking: is there always a way to clump together equivalence classes so that each clump represents one state of the PDA, with each class within the clump representing equivalent states of the stack for that PDA state?</p>\n\n<p>For instance, the language of properly nested parentheses only needs states to handle <code>pop</code> and <code>push</code>, as the stack will keep track of the current nesting depth.  If such clumping can always be done, then whether the number of clumps is finite determines whether the language is context-free.</p>\n\n<hr>\n\n<p>As pointed out by @sdcvvc in a comment, a form of this question was asked as <a href="http://math.stackexchange.com/questions/118362">http://math.stackexchange.com/questions/118362</a> although Yuval Filmus\'s answer to the related question at <a href="http://cs.stackexchange.com/questions/12041/example-of-a-non-context-free-language-that-nonetheless-can-be-pumped/12044#12044">Example of a non-context free language that nonetheless CAN be pumped?</a> is more relevant.</p>\n', 'Tags': '<formal-languages><context-free><pushdown-automata>', 'LastEditorUserId': '5323', 'LastActivityDate': '2013-11-02T13:57:51.987', 'CommentCount': '1', 'AcceptedAnswerId': '12645', 'CreationDate': '2013-06-12T21:49:16.247', 'Id': '12643''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to come up with a regular expression for the following language:</p>\n\n<blockquote>\n  <p>The set of all strings with at most one triple of adjacent 0s.</p>\n</blockquote>\n\n<p>What does "triple of adjacent 0s" mean? Does it mean 010101, or something else?</p>\n', 'ViewCount': '98', 'Title': 'A regular expression for strings with at most one triple of adjacent zeroes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-15T15:30:52.710', 'LastEditDate': '2013-06-15T15:30:52.710', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<formal-languages><terminology><regular-expressions>', 'CreationDate': '2013-06-13T17:52:01.333', 'Id': '12660''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>let\n$$ L=\\{xy\\mid |x|=|y|,x\\neq y \\} $$ \nthen what we can say about $L$? regular, context-free, or ?</p>\n', 'ViewCount': '26', 'ClosedDate': '2013-06-13T19:15:56.310', 'Title': 'Proving that language is regular or context-free', 'LastActivityDate': '2013-06-13T19:11:45.443', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4486', 'Tags': '<formal-languages>', 'CreationDate': '2013-06-13T19:11:45.443', 'Id': '12663''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Productions of the form A-> A are removed immediately, but what if the production is of the form A -> AA? </p>\n\n<p>example: \nA -> AA | a</p>\n', 'ViewCount': '236', 'Title': 'Removing identical variables in CFG Unit Productions', 'LastActivityDate': '2013-06-18T18:46:38.790', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12748', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8739', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-06-18T18:26:15.943', 'Id': '12746''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to find out whether the language $J_1=\\{0^n1^n0^n \\mid n \\in \\mathbb{N}\\}$ and $J^{c}_{1}$ is recursively enumerable.</p>\n\n<p>I already know that $J_1$ is RE, because I have found Turing machine which accepts $J_1$.\nI would also like to prove this for  $J^{c}_{1}$ by using the following theorem:\n$J\\in RE \\wedge J^{c} \\in RE \\Leftrightarrow J \\in Rec$.</p>\n\n<p>So I have to prove that $J_1 \\in Rec$. I have already tried but I am stuck. Can anybody please help me?</p>\n', 'ViewCount': '79', 'Title': 'Is the language $0^n 1^n 0^n$ recursive?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-22T11:30:44.293', 'LastEditDate': '2013-06-22T11:30:44.293', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8766', 'Tags': '<formal-languages><computability>', 'CreationDate': '2013-06-21T16:27:52.773', 'Id': '12818''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '141', 'Title': 'Are HTML and CSS regular languages?', 'LastEditDate': '2013-06-24T17:18:01.450', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8839', 'FavoriteCount': '1', 'Body': '<p>I have a question whether or not CSS and HTML are regular languages.</p>\n\n<p>I believe CSS is a regular language, since it should be possible to create a regular expression to match the structure of CSS.</p>\n\n<p>However, I believe that HTML is <strong>not</strong> a regular language since you have nested attributes that could be defined recursively.</p>\n', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-24T17:18:01.450', 'CommentCount': '7', 'AcceptedAnswerId': '12869', 'CreationDate': '2013-06-24T14:45:41.140', 'Id': '12867''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am a CS undergraduate (but I don\'t know much about AI though, did not take any courses on it, and definitely nothing about NN until recently) who is about to do a school project in AI, so I pick a topics regarding grammar induction (of context-free language and perhaps some subset of context-sensitive language) using reinforcement learning on a neural network. I started to study previous successful approach first to see if they can be tweaked, and now I am trying to understand the approach using supervised learning with Long Short Term Memory.\nI am reading <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.4170" rel="nofollow">"Learning to Forget: Continual Prediction with LSTM"</a>. I am also reading the paper on peephole too, but it seems even more complicated and I\'m just trying something simpler first. I think I get correctly how the memory cell and the network topology work. What I do not get right now is the training algorithm. So I have some questions to ask:</p>\n\n<ul>\n<li><p>How exactly does different input get distinguished? Apparently the network is not reset after each input, and there is no special symbol to delimit different input. Does the network just receive a continuous stream of strings without any clues on where the input end and the next one begin?</p></li>\n<li><p>What is the time lag between the input and the corresponding target output? Certainly some amount of time lag are required, and thus the network can never be trained to get a target output from an input that it have not have enough time to process. If it was not Reber grammar that was used, but something more complicated that could potentially required a lot more information to be stored and retrieved, the amount of time need to access the information might varied depending on the input, something that probably cannot be predicted while we decide on the time lag to do training.</p></li>\n<li><p>Is there a more intuitive explanation of the training algorithm? I find it difficult to figure out what is going on behind all the complicated formulas, and I would need to understand it because I need to tweak it into a reinforced learning algorithm later.</p></li>\n<li><p>Also, the paper did not mention anything regarding noisy <strong>training</strong> data. I have read somewhere else that the network can handle very well noisy testing data. Do you know if LSTM can handle situation where the training data have some chances of being corrupted/ridden with superfluous information?</p></li>\n</ul>\n', 'ViewCount': '184', 'Title': 'Intuitive description for training of LSTM (with forget gate/peephole)?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-26T10:53:14.773', 'LastEditDate': '2013-06-26T10:53:14.773', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8835', 'Tags': '<formal-languages><machine-learning><artificial-intelligence><neural-networks>', 'CreationDate': '2013-06-24T17:04:54.560', 'Id': '12871''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently doing some research on operations on languages, specifically prefix, suffix, infix and outfix.</p>\n\n<p>For example, for a language $L$, the prefix set of $L$ is: </p>\n\n<p>$pref(L) = \\{x \\mid xy \\in L, y \\in \\Sigma^* \\}$</p>\n\n<p>Infix is</p>\n\n<p>$inf(L) = \\{w \\mid xwy \\in L, x,y \\in \\Sigma^* \\}$</p>\n\n<p>and outfix is:</p>\n\n<p>$outf(L) = \\{xy \\mid xwy \\in L, w \\in \\Sigma^* \\}$</p>\n\n<p>I\'m wondering, is there a name for the "class" of operations which contains all of these? I think I might have seen "bitfix" used in a paper somewhere, but it seems to mean something different.</p>\n', 'ViewCount': '258', 'Title': 'Is there a name for the class of operations containing prefix, suffix, etc?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-02T14:42:39.707', 'LastEditDate': '2013-09-02T10:15:58.383', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><terminology>', 'CreationDate': '2013-06-26T21:30:39.757', 'Id': '12921''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>So, it's fairly easy to prove that if $L \\in DCFL$, then $L \\Sigma^* \\in DCFL$. Basically, you take the DPDA accepting $L$. You remove all transitions on final states, and then for each $a \\in \\Sigma$ and each final state $q$, you add a transition looping from $q$ to $q$ on $a$.</p>\n\n<p>I'm using this in a paper, and I'd love to not have to actually prove this construction is valid. It's easy, but it's about a half-page long. Since DPDAs have been studied almost exhaustively, I was wondering, does anybody know of a paper that proves this property?</p>\n", 'ViewCount': '138', 'Title': 'Reference request: proof that if $L \\in DCFL$, then $L \\Sigma^* \\in DCFL$', 'LastActivityDate': '2013-07-10T20:22:04.583', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13215', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><reference-request><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-07-09T17:23:08.623', 'Id': '13179''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm doing some research with NFAs, and I'm wondering there are algorithms which quasi-efficiently minimize them. I realize that this problem is $PSPACE$ hard, so I'm not looking for a polynomial time algorithm.</p>\n\n<p>What I mean by this is an algorithm which may run in exponential time in the worst cases, but which uses some sort of heuristic to speed up the process, albiet not enough to make it exponential.</p>\n\n<p>I'm only using this to try to get a better idea of what the minimal NFAs of certain languages look like. I'm not using it in any production code, so it doesn't need to be blazingly fast.</p>\n\n<p>For example, the Antichains algorithm for NFAs does equivalence testing which is usually fast but sometimes has exponential explosion. I'm looking for something similar, but for minimization.</p>\n\n<p>Note that I'm NOT looking for things like equivalences, etc. which run efficiently but don't produce a minimal NFA.</p>\n\n<p>Bonus points to anyone who find one with an implementation, and quadruple bonus points if it's in Prolog or Python.\nIf the tool I'm looking for doesn't exist, I'd be happy if anyone gave any old implementation of NFA minimization.</p>\n", 'ViewCount': '152', 'Title': 'Are there algorithms to exactly minimize NFAs which are sometimes efficient?', 'LastActivityDate': '2014-02-05T14:19:54.790', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<algorithms><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-07-10T17:56:35.363', 'FavoriteCount': '1', 'Id': '13206''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I just not sure does empty set have a context-free grammar in Chomsky normal form?</p>\n\n<p>That is, for $B=\\emptyset$, then a context-free grammar is $S \\to S$, I think which doesn't have a Chomsky normal form. I am not sure. Can some one explain?</p>\n", 'ViewCount': '227', 'Title': 'Does the empty language have a CFG in CNF?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-12T10:58:36.480', 'LastEditDate': '2013-07-12T10:52:16.447', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'user67584', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-07-10T03:51:41.247', 'Id': '13235''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is somewhat related to <a href="http://cs.stackexchange.com/questions/13206/are-there-algorithms-to-exactly-minimize-nfas-which-are-sometimes-efficient?noredirect=1#comment27879_13206">another question I asked</a>, but I feel it\'s different enough to warrant its own question.</p>\n\n<p>I\'m doing research where I\'m trying to find the structure of complements of a certain class of finite languages. It\'s easy for me to get the minimal DFAs accepting these languages, but I\'d like to examine what kind of structure NFAs accepting these langauges have, particularly how nondeterminism helps with state-size of the automata (the DFAs are exponentially large).</p>\n\n<p>The problem is, the main NFA reduction technique uses equivalences, which won\'t produce any reduction if I start with a minimal DFA (since it\'s basically using the same technique). If I start with a non-minimal DFA, it just spits out the minimal DFA.</p>\n\n<p>What I\'m wondering is, are there algorithms which can start with a DFA, and shrink it into a smaller NFA by introducing nondeterminism? Are there "standard techniques" to do this?</p>\n\n<p>I have found <a href="http://www.csd.uwo.ca/faculty/ilie/TisF04.pdf">preorder reductions</a>, which look promising but hard to implement. I\'m open to many suggestions.</p>\n', 'ViewCount': '205', 'Title': 'Algorithm to shrink a DFA by introducing nondeterminism?', 'LastActivityDate': '2013-07-17T13:39:28.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '13266', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><automata><finite-automata><discrete-mathematics><nondeterminism>', 'CreationDate': '2013-07-12T16:19:26.300', 'FavoriteCount': '1', 'Id': '13249''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can I solve $\\mathcal{O}$-notations without using Java or any other programming language?</p>\n\n<p>I only want to use pen and paper.</p>\n', 'ViewCount': '325', 'ClosedDate': '2013-07-17T09:17:35.527', 'Title': "How to do Big 'O' notations", 'LastEditorUserId': '16189', 'LastActivityDate': '2014-03-27T17:04:35.730', 'LastEditDate': '2014-03-27T17:04:35.730', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '9210', 'Tags': '<algorithms><formal-languages><terminology><regular-languages><asymptotics>', 'CreationDate': '2013-07-17T05:51:43.213', 'Id': '13305''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I\'m looking for a context-sensitive grammar that describes the following language: \n$L = \\{ ww \\mid w \u2208 \\{a,b\\}^{\\ast}, |w| \u2265 1\\}$ .</p>\n\n<p>I\'ve got problems with the fact that no rules such as $X \\to \\varepsilon$ are allowed and therefore I can\'t place any nonterminal indicating the "middle" of the word. Is there any trick to the problem? </p>\n', 'ViewCount': '147', 'Title': 'Context-sensitive grammar for the language of words concatenated with themselves', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T11:23:29.890', 'LastEditDate': '2013-07-19T10:47:36.873', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9231', 'Tags': '<formal-languages><formal-grammars><context-sensitive>', 'CreationDate': '2013-07-18T06:25:58.770', 'FavoriteCount': '1', 'Id': '13327''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is $L = \\{A^n B^n C^n \\mid n \\in \\mathbb{N}\\}$ a context-free language, e.g. $AAAABBBBCCCC \\in L$</p>\n\n<p>If so, what's that context-free grammar that produces it?</p>\n", 'ViewCount': '783', 'ClosedDate': '2013-07-22T13:58:52.000', 'Title': 'Context Free Grammar for $\\{A^nB^nC^n | n \\in \\mathbb{N}\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-22T13:59:24.893', 'LastEditDate': '2013-07-22T13:59:24.893', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '0', 'OwnerDisplayName': 'Nick Mpora', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-07-21T23:54:55.160', 'Id': '13383''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>For a language L we define:  </p>\n\n<p>$\\qquad A(L) = \\{ x \\in L \\mid \\text{ no proper prefix of x is in L} \\} $</p>\n\n<p>Are regular / context free languages closed under this operation ?</p>\n\n<p>For regular languages I thought about taking the DFA that accepts the language L and create a new NFA by making all accepting states sinks (so the only way of being accepted by the automata is that when reading the last letter we reach an accepting state for the first time).</p>\n\n<p>Can't we make the same thing with a pushdown automata for context free languages ?</p>\n\n<p>Edit (as Raphael pointed out, the example below is wrong):</p>\n\n<p>But here is a strange language that I think implies the opposite:<br>\n$L = \\{ 0^{i}1^{j}2^{n} \\mid i \\le n \\ \\text{ or }\\ j \\le n \\} $<br>\n$A(L) = \\{ 0^{i}1^{j}2^{n} \\mid n = \\min(i,j) \\} $</p>\n\n<p>$L$ is context free but $A(L)$ isn't. Obviously, at least one of the things I wrote above is wrong. Anyone have any clue what is going on here ?</p>\n", 'ViewCount': '404', 'Title': 'Are regular and context free languages closed against making them prefix-free?', 'LastEditorUserId': '7068', 'LastActivityDate': '2013-07-22T19:55:09.470', 'LastEditDate': '2013-07-22T18:20:01.553', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '13389', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2013-07-22T13:54:58.530', 'Id': '13388''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I realize non-deterministic pushdown automata can be an improvement over deterministic ones as they can "choose" among several states and there are some context-free languages which cannot be accepted by a deterministic pushdown.</p>\n\n<p>Still, I do not understand <em>how</em> exactly they "choose". For palindormes for example every source I found just says the automaton "guesses" the middle of the word. What does that mean?</p>\n\n<p>I can think of several possible meanings:</p>\n\n<ol>\n<li><p>It goes into one state randomly and therefore might not accept a\nword, which actually is in the language</p></li>\n<li><p>It somehow goes\n"every possible way", so if the first one is wrong it tests if any\nof the other might be right</p></li>\n<li><p>There is some mechanism I am not\naware of, that chooses the middle of the word and is therefore not\nrandom, but the automaton always finds the right middle.<br></p></li>\n</ol>\n\n<p>This is just an example; what I want to know is how it works for any automaton that has several following states for one and the same state before it.</p>\n', 'ViewCount': '118', 'Title': 'Push Down Automatons "guess" - what does that mean?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-07-23T19:18:13.910', 'LastEditDate': '2013-07-23T19:13:48.330', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9308', 'Tags': '<formal-languages><automata><pushdown-automata><nondeterminism>', 'CreationDate': '2013-07-23T17:57:55.890', 'Id': '13400''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm wondering, what is the time-complexity of determining emptiness for 2-way DFAs? That is, finite automata which can move backwards on their read-only input tape.</p>\n\n<p>According to Wikipedia, they are equivalent to DFAs, though the equivalent DFA might be exponentially larger. I've found state complexity for their complements and intersections, but not for their emptiness-testing.</p>\n\n<p>Does anyone know of a paper where I could find this?</p>\n", 'ViewCount': '135', 'Title': 'What is the complexity of the emptiness problem for 2-way DFAs?', 'LastActivityDate': '2013-07-30T14:30:26.037', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13482', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><reference-request><automata><finite-automata>', 'CreationDate': '2013-07-26T22:35:28.517', 'Id': '13456''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for references for the following problem: \nI have a very special class of regular languages and my aim is to express (and to justify my conjecture) that this class itself is very small in some way (as a subset of the regular languages) and that the languages contained in this class are rather "bloated". </p>\n\n<p>For the latter point, I could prove that all languages in the class have a large diameter with respect to many common metrics on strings. However, I want to consider the following: Given a language from the class, we know it has a large diameter, but does it also have a large "volume" (that is, measure), or put differently, if I choose randomly a finite word, is there anything meaningful to say about how "probable" it is that the word belongs to the language? Of course, we can lift the problem: Picking a random language, how probable is it to get a language in the class?</p>\n\n<p>Are there any references or standard approaches for looking at classes of (regular) languages from this point of view (or is this considered as generally uninteresting)?</p>\n', 'ViewCount': '113', 'Title': 'Measures and probability in formal language theory', 'LastActivityDate': '2013-08-07T07:33:27.500', 'AnswerCount': '2', 'CommentCount': '11', 'AcceptedAnswerId': '13652', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><regular-languages><probability-theory>', 'CreationDate': '2013-08-06T12:18:54.883', 'FavoriteCount': '1', 'Id': '13631''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It seems that on this site, people will often correct others for confusing "algorithms" and "problems." What are the difference between these? How do I know when I should be considering algorithms and considering problems? And how do these relate to the concept of a language in formal language theory?</p>\n', 'ViewCount': '453', 'Title': 'What is the difference between an algorithm, a language and a problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-15T20:11:23.283', 'LastEditDate': '2013-08-08T10:47:58.127', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<algorithms><complexity-theory><formal-languages><terminology><reference-question>', 'CreationDate': '2013-08-08T06:10:27.963', 'FavoriteCount': '6', 'Id': '13669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For my Bachelor\'s thesis, I consider the class of languages recognized by symmetrical DFAs, that is, deterministic (complete) finite automata satisfying the following condition: </p>\n\n<p>Let $A$ be a complete DFA over the alphabet $\\Sigma$. If, for every $a\\in \\Sigma$ and every transition $u \\stackrel{a}{\\longrightarrow}v$ in $A$, there is a transition $v \\stackrel{a}{\\longrightarrow}u$ in $A$, we call $A$ a <em>symmetrical</em> DFA (<em>SDFA</em>). If $A$ is not complete, we call it a <em>partial</em> SDFA. We can regard an SDFA as an undirected, labeled graph in a natural way. </p>\n\n<p>I could find an algebraic characterization of the class of languages recognized by (complete as well as partial) SDFAs and deduce some closure properties. However, neither me nor my supervisor are aware of previous results concerning this particular class of regular languages (barring results like Reingold\'s $\\mathsf{SL = L}$ which might seem related). </p>\n\n<p>Motivated by a <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory?noredirect=1#comment29176_13631">comment</a> that J.-E. Pin passed on <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory">a related question I asked</a>, my question is now:</p>\n\n<blockquote>\n  <p>Are there results concerning these automata?</p>\n</blockquote>\n', 'ViewCount': '130', 'Title': 'Results on the languages recognized by undirected DFAs', 'LastActivityDate': '2013-08-16T06:31:23.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13760', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><regular-languages><finite-automata>', 'CreationDate': '2013-08-15T10:27:23.167', 'Id': '13759''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I wanted to define syntax for a graph path considering it may branch out anywhere.</p>\n\n<p>For instance, I have a path going from <code>a</code> to <code>e</code> following <code>b, c, d</code>: <code>a, b, c, d, e</code>.</p>\n\n<p>Let\'s consider it (may) branches from b now: <code>a, b, (x | y), d, e</code> which actually means three different paths: </p>\n\n<p>1) <code>a, b, d, e</code></p>\n\n<p>2) <code>a, b, x, d, e</code></p>\n\n<p>3) <code>a, b, y, d, e</code></p>\n\n<p>So, each parenthesis actually means "the path might either go through any of the nodes defined in the parenthesis connecting the node just before parenthesis and right after parenthesis or through none of the nodes defined in the parenthesis".</p>\n\n<p>With more inner parenthesis, a single string line may generate even more paths. For instance: <code>a, b, (x | (z | t) | y), d, e</code> which means these five paths:</p>\n\n<p>1) <code>a, b, d, e</code></p>\n\n<p>2) <code>a, b, x, d, e</code></p>\n\n<p>3) <code>a, b, y, d, e</code></p>\n\n<p>4) <code>a, b, z, d, e</code></p>\n\n<p>5) <code>a, b, t, d, e</code></p>\n\n<p>6) <code>a, b, z, y, d, e</code></p>\n\n<p>7) <code>a, b, t, y, d, e</code></p>\n\n<p>8) <code>a, b, x, z, d, e</code></p>\n\n<p>9) <code>a, b, x, t, d, e</code></p>\n\n<p>So, how can I define this syntax mathematically?</p>\n', 'ViewCount': '95', 'ClosedDate': '2013-08-29T23:27:41.833', 'Title': 'How can I define this syntax?', 'LastEditorUserId': '6899', 'LastActivityDate': '2013-08-17T13:31:05.470', 'LastEditDate': '2013-08-17T13:31:05.470', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6899', 'Tags': '<formal-languages><parsing>', 'CreationDate': '2013-08-16T16:42:46.340', 'Id': '13779''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>If the set of regular languages is closed under the concatenation operation and is also closed under the reverse operation ($x^R$ is the reverse of $x$) then is the language generated by $$\\{ww^R|w\\in\\Sigma^*\\}$$ for some input alphabet $\\Sigma$, also regular? If not, why not?</p>\n\n<p>I've been trying to find a proof for this using the pumping lemma, but it seems that selecting any substring towards the middle of the string being pumped could also be of the form $\\{ww^R|w\\in\\Sigma^*\\}$, causing the original string to remain in its original form.</p>\n\n<p>Here's a try:</p>\n\n<p>$\\textbf{Theorem:}$ The language, $A$, generated by $\\{ww^R|w\\in\\Sigma^*\\}$ is not regular.</p>\n\n<p>$\\textbf{Proof:}$ Assume $A$ is regular (We will use the Pumping Lemma for Regular Languages to show a contradiction). Let the input string $s$ be $ww^R$ and let $p = |w|$.</p>\n\n<p>When splitting $s$ into substrings $x, y, z$ such that $s=xyz$ we see that $xy$ must be a substring of $w$ by the third condition of the Pumping Lemma ($|xy|\\le p$).</p>\n\n<p>By the first condition of the Pumping Lemma, we see that all strings of the form $xy^iz$ must be in $A$ for all $i \\ge 0$. Taking $i$ to be zero, we obtain the string $xw^R$. $|x| &lt; |w^R|$ so $xy^0z \\notin A$.</p>\n\n<p>QED? What if $xw^R$ can still be split so that for some substring $k$, $kk^R = xw^R$?</p>\n\n<p>I think I may be overthinking this but it's really bugging me.</p>\n", 'ViewCount': '629', 'Title': 'Is the language that accepts strings concatenated with their reverse regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T20:59:40.083', 'LastEditDate': '2013-08-22T14:52:13.693', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '13806', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9727', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2013-08-18T21:36:02.120', 'Id': '13804''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to think if we can have an injective mapping $\\mathcal{f}$, say something like $\\Sigma_{bool}= \\{0,1\\}^* $ to $\\Sigma_{5} = \\{0,1,2,3,4\\}^* $ such that $|x| \\leq 2.|\\mathcal{f}(x)|$</p>\n\n<p>The motivation here is simple, consider I have a word $110110110110110110110$, so i can compress and represent that as $(110)^7$ or $110,111$ so what can i do if i am allowed to use symbols from $\\Sigma_5$?</p>\n\n<p>I hope my question made sense :)</p>\n', 'ViewCount': '81', 'Title': 'To what factor can I compress information from binary to Quinary', 'LastEditorUserId': '9612', 'LastActivityDate': '2013-08-20T14:39:13.760', 'LastEditDate': '2013-08-20T14:39:13.760', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13831', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<formal-languages><data-compression>', 'CreationDate': '2013-08-19T12:04:59.993', 'Id': '13817''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I do not understand the proof for this. I know that every word in $(A^*)^*$ is made up of words from $A^*$, and that this is made up from words in $A$. But how does this help with showing that $(A^*)^*$ is a subset of $A^*$.</p>\n', 'ViewCount': '84', 'Title': 'Show that A** subset of A*, where A is a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-26T13:32:58.017', 'LastEditDate': '2013-08-26T08:27:54.990', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '13919', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-08-25T02:20:16.007', 'Id': '13918''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Definitions:</p>\n\n<ul>\n<li><em>Alphabet</em> $\u03a3$: finite, non-empty set</li>\n<li><em>Language</em>: subset of $\u03a3^*$</li>\n<li><em>Grammar</em>: <a href="http://en.wikipedia.org/wiki/Unrestricted_grammar" rel="nofollow">Unrestricted grammar (Chomsky Type 0)</a></li>\n<li><em>Language of a grammar</em>: all words that can be produced by applying $P$ multiple times, starting from $S$</li>\n</ul>\n\n<p>Grammars are finite, therefore there are only countable infinite of them. But there are uncountably infinite many languages. Each grammar can only describe one language. Therefore, there are <strong>languages without grammars</strong>.</p>\n\n<p>Can you give an <strong>example</strong> for such a language without grammar?</p>\n\n<p>I searched the internet, but strangely, I could not even find the question in context of formal language.</p>\n', 'ViewCount': '136', 'Title': 'Formal language without grammar', 'LastEditorUserId': '9827', 'LastActivityDate': '2013-08-26T20:09:51.233', 'LastEditDate': '2013-08-26T20:09:51.233', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '13936', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9827', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-08-25T16:39:41.640', 'Id': '13923''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For a language to be regular it needs to be recognized by DFA/NFA.</p>\n\n<p>Let $L = \\{ xy^rzyx^r \\mid |x| , |y|, |z| \\ge 1 \\}$ over the alphabet $\\{0,1\\}$.</p>\n\n<p>$x^r$ means the reverse of $x$.</p>\n\n<p>A DFA has no memory, so how can it handle the reverse check?</p>\n', 'ViewCount': '126', 'Title': 'Why is this language involving reversal regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T10:48:00.090', 'LastEditDate': '2013-08-27T10:48:00.090', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '13959', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9851', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-08-27T07:32:03.760', 'Id': '13956''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>If you could include your thought process in determining why it's regular it would help me a lot.</p>\n\n<ul>\n<li><p>$L_1 = (0^*(10)^*11)$</p></li>\n<li><p>$L_2 = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing machine that halts on all inputs from }L_1 \\}$</p></li>\n<li><p>$L_3 = \\{ x \\in \\{0,1\\}^* \\mid \\exists y \\in L_2. xy \\in L_1 \\}$</p></li>\n</ul>\n\n<p>Why is $L_3$ regular? It's a set of strings, I need to determine if there's a DFA that can accept it. Do I even care about $L_2$ and $L_1$ in this case?</p>\n", 'ViewCount': '99', 'Title': 'Why is this language regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T11:33:04.927', 'LastEditDate': '2013-08-27T11:19:56.530', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '13971', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9844', 'Tags': '<formal-languages><computability><regular-languages>', 'CreationDate': '2013-08-27T08:42:44.590', 'Id': '13960''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need help with deciding if $L$ is context-free.</p>\n\n<p>$$L = \\{a^pb^{q+r}c^sd^{q+t}e^{p+r} \\mid p, q, r, s \\ge 0\\ , s &gt; t\\}$$</p>\n\n<p>Can be rewritten into:</p>\n\n<p>$$L = \\{a^pb^qb^rc^sd^qd^te^pe^r \\mid p, q, r, s \\ge 0\\ , s &gt; t\\}$$</p>\n\n<p>When we see the first occurrence of $c$, we push the $c$:s onto the stack. But we can't make difference between $d^q$ and $d^t$,  so comparing $s &lt; t$ is impossible when popping the $d$:s. </p>\n\n<p>Hence $L$ is not Context-Free.</p>\n\n<p>Is my reasoning right ?</p>\n", 'ViewCount': '109', 'Title': 'Deciding if language is Context-Free', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-08-28T10:32:22.617', 'LastEditDate': '2013-08-28T01:33:18.760', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '13982', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-08-28T00:05:59.243', 'Id': '13981''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>This is a homework question, so I am only looking for hints.</em></p>\n\n<p>I got a question in an assignment which states :</p>\n\n<blockquote>\n  <p>Design a DFA that accepts strings having 1 as the 4th character from the end, on the alphabet {0,1}</p>\n</blockquote>\n\n<p>I have been at this for a few hours now, and I think that designing such a DFA is not possible. However, I am not sure how to move forward in this direction to write up a somewhat formal proof. </p>\n\n<p>So, what should I try to do to prove or disprove my hypothesis?</p>\n', 'ViewCount': '1136', 'Title': 'Designing a DFA that accepts strings such that nth character from last satisfies condition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-29T22:28:11.637', 'LastEditDate': '2013-08-29T14:39:17.470', 'AnswerCount': '4', 'CommentCount': '3', 'AcceptedAnswerId': '14021', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2044', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-08-29T01:49:33.573', 'Id': '14008''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am preparing for my exam in formal languages and I need some help with one question from one old exam.</p>\n\n<p><img src="http://i.stack.imgur.com/mHEZ6.png" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/eXL8R.png" alt="enter image description here"></p>\n\n<p>I know that the number of equivalence classes of some regular language L, is the number of states of the minimal DFA for that language.</p>\n\n<p>But how do I give a DFA for one of the equivalence classes ? </p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '346', 'Title': 'DFA - Equivalence classes', 'LastActivityDate': '2013-08-30T10:45:40.983', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14028', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2013-08-29T19:57:52.213', 'Id': '14026''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In trying to gain a better understanding of finite state machines, I stumbled across this idea and have been confused as to how to approach this case in terms of a DFA.</p>\n\n<blockquote>\n  <p>The set of binary strings of length at least 3 where every substring\n  of length 3 contains at least two 0s.</p>\n</blockquote>\n\n<p>So in other words, something like 100100010 should be in the language (L) for this DFA but something like 11001010 would not be in the language.</p>\n\n<p>I know that you can start off by writing/drawing smaller DFAs for the substrings that are the pattern 000, 010, 100, 001, etc, but I cannot seem to get a hold of how it should look all together.</p>\n\n<p>Any help in understanding this would be appreciated.</p>\n', 'ViewCount': '224', 'Title': 'DFA drawing for binary string with substrings of minimum length 3 with at least two zeroes in each substring', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-02T09:56:55.093', 'LastEditDate': '2013-09-02T09:56:55.093', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '14055', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2013-08-31T03:05:59.700', 'Id': '14050''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know that in an infinite language there are infinite number of strings.  I want to know what type of the languages are C, C++ and JAVA? I can have infinite number of variables in all these languages, so I think all these languages are infinite. Please correct me if I am wrong.     </p>\n', 'ViewCount': '177', 'Title': 'How do I find if a programming language is infinite or finite?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-03T10:03:15.900', 'LastEditDate': '2013-09-03T06:50:25.873', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<formal-languages><computability>', 'CreationDate': '2013-09-02T13:18:59.083', 'Id': '14084''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to figure out the result of the concatenation among different language types (regular, context free, ...). I think the result strongly depends on the nature of the languages which will be concatenated, but I have some doubts on determining the category the result belongs to. Maybe troughout an example it will be easier to solve all my doubts and let you understand better the nature of my question. For instance, let $L = \\left \\{ 0^{n}\\cdot 1^{n} \\mid n \\geq 0 \\right \\}$ and $L^{R} = \\left \\{ 1^{n}\\cdot 0^{n} \\mid n \\geq 0 \\right \\}$</p>\n\n<p>Those two languages are obviosly not regular (it's easy to apply the Pumping Lemma here)\nbut what happens if I define this result language $L{}' = L \\cdot \\left \\{ 0, 1 \\right \\}^{*} \\cdot L^{R}$</p>\n\n<p>I think it should be still not regular, since we can apply again the pumping lemma by letting be $p$ the length of the pumping and $w=0^{p}1^{2p}0^{p}$, w is in $L'$. The contination is easily.</p>\n\n<p>But is it good to consider that w of $L'$? </p>\n", 'ViewCount': '56', 'Title': 'Concatenation among different language types', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-06T09:50:31.623', 'LastEditDate': '2013-09-06T08:52:51.910', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9989', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2013-09-05T11:29:43.487', 'Id': '14145''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '299', 'Title': 'Determine if this language is regular', 'LastEditDate': '2013-09-06T16:06:37.390', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9819', 'FavoriteCount': '1', 'Body': "<p>Let $L = \\{xyx \\mid \\text{ for some }x,y \\in \\{0,1\\}^+\\}$. Is this language regular?</p>\n\n<p>So I was trying to construct a DFA, but I don't how to do this with this language.</p>\n", 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-06T16:06:37.390', 'CommentCount': '4', 'AcceptedAnswerId': '14170', 'CreationDate': '2013-09-06T01:42:17.333', 'Id': '14159''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Part (a): Let $L = \\{x \\in \\{0,1\\}^* \\mid  \\#0(x) \\neq 4\\times\\#1(x)\\}$, where $\\#0(x)$ means the number of 0 in string $x$ and $\\#1(x)$ means the number of 1 in string $x$.</p>\n\n<p>So I want to use the pumping lemma. But I'm having a hard time choosing a string so that I can show that it is not regular.</p>\n\n<p>I've been thinking about how I could use something like the string, s, = $0^{3p}1^p$. But I do not see how you use that fact (I would like to show that xyyz would equal $0^{4p}1^p$). This route seems unfruitful. So any help would be nice.</p>\n\n<p>Part (b): Let $L = \\{x \\in \\{0,1\\}^* \\mid \\exists k \\in \\mathbb{N}, \\#0(x) + \\#1(x) = 2k\\}$. </p>\n\n<p>Again stuck on this problem. My original approach was to leverage the fact that the parity is the same on the 0s and 1s (if one is even, then so does the other and vice versa. Same for odd parity.)</p>\n\n<p>Again, this does not seem to be working.</p>\n", 'ViewCount': '142', 'Title': 'Decide if L is regular or not and argue it. Trying to use Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-10T14:22:35.517', 'LastEditDate': '2013-09-09T10:25:55.990', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14182', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-09-07T01:03:54.217', 'Id': '14180''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>as the title states, I am trying to figure out if my approach to solving mapping reduction from $E_{TM}$ to some other language is correct. As you surely know, $E_{TM} = \\left \\{ &lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M)= \\emptyset \\right \\} $. What i am trying to check is whatever a string <strong>x</strong> is in L(M). My idea is to analyse $&lt;M&gt;$ in oder to check if there are any transition to $q_{accept}$, if so then L(M) cannot be empty. Now let\'s take another language, for instance let $REVERSE_{TM} = \\left \\{&lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M) = L(M)^{R} \\right \\} $ or even $REGULAR_{TM} = \\left \\{&lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M) \\ is \\ regular \\right \\} $.\nLet\'s prove that $E_{TM} \\leq_{m} REVERSE_{TM} $. Since i need to convert an istance <em>"yes"</em> <strong>w</strong> of $E_{TM}$ trought a function <strong>f</strong>, to <strong>f(w)</strong> which is an instance <em>"yes"</em> of $REVERSE_{TM}$. $f(&lt;M&gt;) = &lt;M^{\'}&gt;$, where $&lt;M^{\'}&gt;$ is a TM whose behaviour on input x is</p>\n\n<ol>\n<li><p>if $x \\neq x^{R}$ then accept.</p></li>\n<li><p>if $x = x^{R}$ then,</p>\n\n<ul>\n<li><p>analyse $&lt;M&gt;$ and if there are no transitions to $q_{accept}$ then accept</p></li>\n<li><p>else do not accept x </p></li>\n</ul></li>\n</ol>\n\n<p>Which language does M\' recognize? It should recognize $ \\Sigma^{*} $ if $L(M) = \\emptyset $ meanwhile it should match $ \\left \\{ x \\in \\Sigma^{*} \\mid x \\neq x^{R} \\right \\} $.\nWe know that $(\\Sigma^{*})^{R} = \\Sigma^{*}$, so $&lt;M\'&gt; \\in REVERSE_{TM} &lt;=&gt; L(M) = \\emptyset$. I think this mapping reduction should be correct but is it correct to let M\' analyse M in order to figure out if L(M) is really empty (if it\'s empty there should be no transition to $q_{accept}$) ? Or is there another way to solve these reduction from $E_{TM}$ ? </p>\n', 'ViewCount': '68', 'Title': 'Correct approach to Mapping Reduction from $E_{TM}$', 'LastActivityDate': '2013-09-07T14:27:57.417', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9989', 'Tags': '<formal-languages><turing-machines><reductions>', 'CreationDate': '2013-09-07T14:27:57.417', 'Id': '14194''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is very much clear to me that an FSM has limited memory (sufficient to store present state). How do I prove that (intutively or otherwise) that a CFL has more memory than a DFA or NFA (thus making a CFL more powerful than FA) ?   </p>\n', 'ViewCount': '96', 'ClosedDate': '2013-09-09T12:44:25.257', 'Title': 'How do I prove that Context Free languages have more memory than FSM', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T12:42:27.433', 'LastEditDate': '2013-09-09T12:42:27.433', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-09-09T09:10:17.783', 'Id': '14230''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've come across this problem in my studies, and I've abstracted it to the more general case here.</p>\n\n<p>Given a finite alphabet, what is a regular expression that matches all strings over the alphabet, except one particular finite substring?</p>\n\n<p>As an example:</p>\n\n<p>Given $\\Sigma = \\{a, b, c\\}$</p>\n\n<p>What is a regular expression that matches all of $\\Sigma$ except the substring $\nba$?</p>\n\n<p>What I really want is simply $\\Sigma^* - ba$. </p>\n", 'ViewCount': '594', 'Title': 'What is a regular expression that matches all strings over the alphabet except a particular substring?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T15:00:48.047', 'LastEditDate': '2013-09-16T07:17:29.020', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10092', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-09-12T02:24:16.167', 'Id': '14274''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a regular language $L$. Let $D(L)$ be a minimal DFA for $L$ and $N(L)$ be a minimal NFA for $L$ (minimal in the sense of the smallest possible number of states for an automaton that recognizes the given language). Write $|A|$ for the size (number of states) of the automaton $A$. In general, $|N(L)|$ can be a lot smaller than $|D(L)|$ (down to $\\lg |D(L)|$, since determinization is exponential in the worst case).</p>\n\n<p>I am interested in languages for which the minimal NFA is guaranteed to be at least a fraction of the size of the DFA: $|N(L)| \\ge k |D(L)|$. What families of regular languages have this property? In other words, for what family of languages $(L_n)$ such that $|D(L_n)| = n$ is $|N(L_n)| = \\Omega(n)$?</p>\n', 'ViewCount': '176', 'Title': u'For what kinds of languages is min |NFA| = \u03a9(min |DFA|)?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-27T21:37:07.360', 'LastEditDate': '2013-09-13T16:00:09.733', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10106', 'Tags': '<formal-languages><automata><finite-automata><descriptive-complexity>', 'CreationDate': '2013-09-12T16:37:35.247', 'FavoriteCount': '1', 'Id': '14285''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Here is a question that I encountered in one of my exams:</p>\n\n<blockquote>\n  <p>Find one context-free grammar that recognizes the language:\n  $\\qquad L = \\{a^n(b^mc^m)^pd^n \\mid m, n, p \\geq 0\\} $</p>\n</blockquote>\n\n<p>Can you find such a grammar? I even doubt its existence, but I have not been able to prove that. </p>\n', 'ViewCount': '208', 'Title': 'Does this language have a context-free grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T08:07:16.830', 'LastEditDate': '2013-09-16T08:06:35.013', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10135', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-09-14T12:32:22.343', 'Id': '14305''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '184', 'Title': 'Prove or disprove whether L is regular', 'LastEditDate': '2013-09-16T08:18:17.317', 'AnswerCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Body': "<p>Let $\\Sigma = \\{0,1\\}$. For every word $w \\in \\Sigma^*$, let $|w|_0$ and $|w|_1$ denote the count of 0's and 1's, respectively, in $w$. Let $L$ be the language\n$$L = \\{ w \\in \\Sigma^* \\mid |w|_0 \\gt |w|_1 + 2 \\text{ or } |w|_1 \\gt |w|_0 + 2\\}$$\nProve or disprove whether $L$ is regular.</p>\n", 'ClosedDate': '2013-09-16T08:21:43.223', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T08:18:17.317', 'CommentCount': '2', 'AcceptedAnswerId': '14324', 'CreationDate': '2013-09-15T06:14:55.630', 'Id': '14323''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Given languages X, Y and Z, each with alphabet, define X/Y/Z \n as:</p>\n\n<pre><code>     X/Y/Z = { w \u2208 \u03a3* | \u2203u \u2208 Y and \u2203v \u2208 Z; such that wuv \u2208 X }.\n</code></pre>\n\n<p>Prove that if X is context-free, and Y and Z are regular, then X/Y/Z\nis context-free.</p>\n', 'ViewCount': '140', 'Title': 'Prove that X/Y/Z is context-free', 'LastActivityDate': '2013-09-16T15:40:05.847', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-09-15T12:23:15.787', 'FavoriteCount': '0', 'Id': '14333''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose I have a DFA recognizing a regular language $L$, how do I prove that \n$$\\text{lefthalf}(L)= \\{ w_1 \\mid \\exists w_2 \\in \\Sigma^* ,w_1w_2 \\in L \\land \\|w_1\\| = \\|w_2\\| \\}$$ is also a regular language?</p>\n', 'ViewCount': '86', 'ClosedDate': '2013-09-18T09:23:28.010', 'Title': 'Proving that a derived language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T09:19:49.913', 'LastEditDate': '2013-09-18T09:19:49.913', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10191', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-09-18T03:02:09.353', 'Id': '14397''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '197', 'Title': 'Bridge theorems for group theory and formal languages', 'LastEditDate': '2013-09-18T15:00:13.363', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '3', 'Body': '<blockquote>\n  <p>Is there some natural or notable way to relate or link math <a href="http://en.wikipedia.org/wiki/Group_theory" rel="nofollow">groups</a> and CS <a href="http://en.wikipedia.org/wiki/Formal_language" rel="nofollow">formal languages</a> or some other core CS concept e.g. Turing machines?</p>\n</blockquote>\n\n<p>I am looking for references/applications. However note that I am aware of the link between semigroups and CS languages (namely via <a href="http://en.wikipedia.org/wiki/Semiautomaton" rel="nofollow">finite automata</a>). (Does this literature on semiautomata ever look at "group-automata"?)</p>\n\n<p>I have seen one paper many years ago that might come close, that converts TM transition tables into a binary operation, possibly sometimes a group in some cases, conceivably based on some kind of symmetry in the TM state table. It didn\'t explore that in particular, but also didn\'t rule it out.</p>\n\n<p>Also, in particular, regarding the large body of math research on <a href="http://en.wikipedia.org/wiki/Classification_of_finite_simple_groups" rel="nofollow">classification of finite groups</a>, does or could it have any meaning or interpretation in TCS? What is the "algorithmic lens" view of this massive edifice of mathematical research? What is it "saying" about a possible hidden structure in computation?</p>\n\n<p>This question is partly inspired by some other notes e.g.:</p>\n\n<ul>\n<li><p><a href="http://cstheory.stackexchange.com/questions/10916/uses-of-algebraic-structures-in-theoretical-computer-science?lq=1">Use of algebraic structures in TCS</a></p></li>\n<li><p><a href="http://rjlipton.wordpress.com/2013/06/20/three-theorems-about-growth/" rel="nofollow">RJ Lipton on Gromov\'s theorem</a></p></li>\n</ul>\n', 'Tags': '<formal-languages><reference-request><automata><discrete-mathematics><group-theory>', 'LastEditorUserId': '699', 'LastActivityDate': '2013-09-19T08:20:39.707', 'CommentCount': '4', 'AcceptedAnswerId': '14417', 'CreationDate': '2013-09-18T03:16:40.020', 'Id': '14398''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>What are the common ways to check if a given language is regular, context free, or context sensitive?</p>\n\n<p>Any surveys or notes would also be helpful. There's no need to describe your suggestions. \neg. it is sufficient to say a language is regular if it can be recognized by a DFA.</p>\n", 'ViewCount': '77', 'ClosedDate': '2013-09-20T15:23:50.653', 'Title': 'Class of a Language', 'LastActivityDate': '2013-09-19T07:26:47.073', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10214', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-09-19T01:51:19.630', 'Id': '14428''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '199', 'Title': 'Fundamental algorithms in formal language-automata theory', 'LastEditDate': '2013-09-20T18:45:15.127', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10249', 'Body': "<p>I'm willing to take a course in formal languages and automata theory , where we will explore side by side a functional programming language to implement the different algorithms we will encounter ,despite i am new to the language , i am assuming i've learned what's nessecary to move to the theoretical part , so i'm wondering what are the must-knows of FL &amp; AT to a programmmer , that is what are the most fundamentals algorithms one necesserily have to know while studying formal languages and automata theory ?</p>\n", 'ClosedDate': '2013-10-01T07:02:02.177', 'Tags': '<algorithms><formal-languages><automata>', 'LastEditorUserId': '10249', 'LastActivityDate': '2013-09-22T04:53:51.763', 'CommentCount': '0', 'AcceptedAnswerId': '14489', 'CreationDate': '2013-09-20T18:38:20.970', 'Id': '14480''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '551', 'Title': 'Undecidable among these for turing machine', 'LastEditDate': '2013-09-21T17:23:03.633', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10264', 'FavoriteCount': '2', 'Body': "<p>Below are two questions I found in Theory of Computation book but couldn't find its correct answers, can anyone please give correct answers with explanation?</p>\n\n<ol>\n<li>It is undecidable, whether\n<ol>\n<li>an arbitrary Turing machine(TM) has 15 states</li>\n<li>an arbitrary TM halts after 10 steps</li>\n<li>an arbitrary TM ever prints a specific letter</li>\n<li>an arbitrary TM accepts a string w in 5 steps</li>\n</ol></li>\n<li>Which one of the following is not decidable?\n<ol>\n<li>given a TM M, a string s and an integer k, M accepts s with k steps</li>\n<li>equivalence of two given TMs</li>\n<li>language accepted by a given DFSA(Deterministic finite state automata) is nonempty</li>\n<li>language accepted by a CFG(Context free grammar) is nonempty  </li>\n</ol></li>\n</ol>\n\n<p>Update: In first question I think 1.2 is right because halting is undecidable for Turing machine but not sure whether remaining options are decidable or not.<br>\nIn second question I think 2 is right, but not sure about the decidability of non emptiness of CFG and DFSA.</p>\n", 'Tags': '<formal-languages><turing-machines><undecidability>', 'LastEditorUserId': '10264', 'LastActivityDate': '2013-09-27T20:19:53.660', 'CommentCount': '16', 'AcceptedAnswerId': '14644', 'CreationDate': '2013-09-21T16:00:54.280', 'Id': '14498''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<ul>\n<li>Given any <em>Context-Free-Grammar, $G$</em>, and another in <em>Chomsky Normal Form, $G_c$</em>, how can we check if both $G$ and $G_c$ generate the same language?</li>\n</ul>\n\n<p>One of the trivial ways I know of is to convert $G$ into a CNF form. which motivates my second question,</p>\n\n<ul>\n<li>Can two different <em>Context-Free-Grammars</em> in CNF, $G_c$ and $G_c^\\prime$, generate the same language? (I would appreciate a proof of it)</li>\n</ul>\n', 'ViewCount': '77', 'Title': 'Equivalence of Context-Free-Grammar and Context-Free-Grammar in CNF', 'LastActivityDate': '2013-09-22T11:13:46.963', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-09-22T09:22:18.547', 'FavoriteCount': '1', 'Id': '14513''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In my descriptive complexity class, we've been asked to find a formula that characterises the language $(aa)^*$ (over the alphabet $\\{a\\}$) with a first order formula over the language $\\{&lt;, P_a\\}$.</p>\n\n<p>This was the first class, so I will recall what we've learned to be sure that I understood. To a $L$-formula $\\phi$ we associate a language $\\mathcal L(\\phi)$ which is the class of all $L$-structures in which $\\phi$ is valid.</p>\n\n<p>In my case, we then are looking for a $\\{&lt;, P_a\\}$-formula for which words of even length are models. I guess I have to say in $\\phi$ that $&lt;$ is a total order, so that I can interpret the models as words, and that $\\forall x, P_a(x)$ to say that all points are labelled as 'a'. But how to say that there has to be an even number of points in the model? The definition of having an even number of points seems recursive, so I get the impression that a formula for $(aa)^*$ should be of infinite length in first-order logic..</p>\n", 'ViewCount': '115', 'Title': 'Characterising $(aa)^*$ in first order logic', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-23T11:22:12.363', 'LastEditDate': '2013-09-23T07:23:27.313', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14548', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10157', 'Tags': '<formal-languages><regular-languages><logic><first-order-logic>', 'CreationDate': '2013-09-23T06:16:13.087', 'Id': '14545''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let L be language of balanced parentheses.</p>\n\n<p>(a) Prove If there are equal number of ('s and )'s and every prefix of w contains at least as many ('s as )'s, then w is in L.</p>\n\n<p>(b) Prove If w is in L, then there are equal number of ('s and )'s and every prefix of w contains at least as many ('s as )'s.</p>\n\n<p>After much thought, I don't seek what I'm supposed to be doing. All I know is that I'm supposed to be using induction.</p>\n\n<p>Here is the grammar that generates L: $S\\to SS|(S)|\\epsilon$</p>\n", 'ViewCount': '320', 'Title': 'Language of balanced parentheses; Biconditional proof about parentheses', 'LastEditorUserId': '9819', 'LastActivityDate': '2013-09-23T20:10:26.890', 'LastEditDate': '2013-09-23T20:10:26.890', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<formal-languages><context-free><induction>', 'CreationDate': '2013-09-23T16:09:40.090', 'Id': '14557''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m having trouble with this question about regular expressions:</p>\n\n<blockquote>\n  <p>Let $L_1$ be the language of passwords containing at least one\n  lowercase letter, at least one uppercase letter, and at least one\n  number. Write down a regular expression that describes $L_1$.</p>\n</blockquote>\n\n<p>This is my answer, but I\'m not too sure about it. I let $\\mathcal{A}$ be the alphabet, and attempted to cover all permutations. I think my answer is correct, but is there a simpler way to go about it?\n\\begin{equation*}\n (\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*) \\cup\n (\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*)\\cup\n (\\mathcal{A}^*\\mathcal{A}_{UC}\\mathcal{A}^*\\mathcal{A}_{No}\\mathcal{A}^*\\mathcal{A}_{LC}\\mathcal{A}^*)\n\\end{equation*}</p>\n\n<p>I\'m really stuck on this second part:</p>\n\n<blockquote>\n  <p>Let $L_2$ be the language of "good" password. It is related to L1 by:\n  \\begin{equation*}  L_2=\\{w\\in L_1 : w \\text{ has length } \\geq 8\\} \\end{equation*} Specify a regular expression that describes $L_2$,\n  without writing it down in full. What is the length of this regex?</p>\n</blockquote>\n\n<p>I\'m not sure about how to construct a regular expression using my answer for $L_1$. I thought it might be similar to the first part, where I could specify all the permutations.</p>\n', 'ViewCount': '35', 'Title': 'Constructing regular expressions with given substring requirments', 'LastActivityDate': '2013-09-24T02:21:21.597', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14569', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10190', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2013-09-24T01:20:20.633', 'Id': '14568''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am currently studying the pumping lemma for regular languages and I am trying to come up with an example where even if the language can be pumped it is not regular. \nWhich condition of the lemma should be broken such that I can find a language like that?</p>\n', 'ViewCount': '37', 'ClosedDate': '2013-09-29T18:31:33.740', 'Title': 'Pumping a Language does not imply regular', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-28T12:01:23.383', 'LastEditDate': '2013-09-28T12:01:23.383', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10376', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-09-28T11:20:58.553', 'Id': '14653''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to prove that the language: \\begin{equation*}\nL = \\{ w \\in \\{ 0, 1 \\}^* : w  \\text{ contains more 0's than 1's} \\}\n\\end{equation*} is irregular using the Myhill-Nerode theorem. I've been through all the basic examples in the book, and thought I understood them, but I'm having trouble with this one.</p>\n\n<p>So far, I've been thinking about letting $ x_i = 1^i 0^i $ and $x_j = 1^{j+1} 0^{j-1}$, then if I let $ w_{ij} = 0$, only $x_iw_{ij} \\in L$. That seems to be sufficient, but it seems weak compared to some of the other examples.</p>\n\n<p>Am I on the right track here? I would really appreciate any hints/suggestions.</p>\n", 'ViewCount': '107', 'Title': 'Proving a Language is Irregular using Myhill-Nerode', 'LastActivityDate': '2013-09-30T21:57:24.197', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14707', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10410', 'Tags': '<formal-languages>', 'CreationDate': '2013-09-30T14:32:57.017', 'Id': '14701''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is the set of all syntactically valid C programs countable or uncountable?</p>\n', 'ViewCount': '182', 'Title': 'Is the set of all valid C programs countable?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-04T21:11:39.313', 'LastEditDate': '2013-10-04T21:11:39.313', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<formal-languages><programming-languages><uncountability>', 'CreationDate': '2013-10-03T14:11:27.090', 'Id': '14782''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $\\Sigma$ and $\\Delta$ be alphabets. Consider a\nfunction $\\varphi: \\Sigma \\rightarrow \\Delta^*$. Extend $\\varphi$ to\na function from $\\Sigma^* \\rightarrow \\Delta^*$ such that:\n\\begin{eqnarray*}\n\\varphi(\\varepsilon) &amp; = &amp; \\varepsilon \\\\\n\\varphi(w\\sigma ) &amp; = &amp; \\varphi(w)\\varphi(\\sigma ), \\textrm{ for any }\nw \\in  \\Sigma ^*, \\sigma  \\in  \\Sigma\n\\end{eqnarray*}\nAny function $\\varphi:\\Sigma^* \\rightarrow \\Delta^*$ defined in this way\nfrom a function $\\varphi: \\Sigma \\rightarrow \\Delta^*$ is called a\n<strong>homomorphism</strong>. We can extend this definition to languages as follows:\nfor any language $L$ and homomorphism $\\varphi$, let \n$$\\varphi(L)=\\{\\varphi(w) : w\\in L\\}.$$</p>\n\n<p>Are regular languages are closed under inverse homomorphism?</p>\n', 'ViewCount': '381', 'Title': 'Are regular languages closed under inverse homomorphism?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-04T18:57:57.430', 'LastEditDate': '2013-10-04T18:57:57.430', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-10-03T14:21:55.540', 'Id': '14785''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m trying to make a regular grammar for this language:</p>\n\n<p><img src="http://i.stack.imgur.com/obVZM.gif" alt="enter image description here"></p>\n\n<p>Where the alphabet is $ \\Sigma $ = $\\{a,b,c\\}$</p>\n\n<p>It seemed like it would go well with a right-linear grammar.  This may be disastrously wrong, but here\'s how I started:</p>\n\n<p>$S \\to aA$</p>\n\n<p>$A \\to aA | cB $</p>\n\n<p>$B \\to bC | C $</p>\n\n<p>$C \\to cD |$ $\\lambda$</p>\n\n<p>$D \\to cC$</p>\n\n<p>EDIT:\nCorrected for errors. Added $D$ for regular grammar.</p>\n', 'ViewCount': '71', 'Title': 'Making a regular grammar for this language', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-05T21:58:33.130', 'LastEditDate': '2013-10-05T21:58:33.130', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14836', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><regular-languages><formal-grammars>', 'CreationDate': '2013-10-05T19:10:54.813', 'Id': '14832''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '57', 'Title': 'Regular Expression as basis for creating this grammar', 'LastEditDate': '2013-10-06T03:50:49.073', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': u"<p>I made a right-linear grammar from a regular expression:</p>\n\n<p>The alphabet is:</p>\n\n<p>$\u03a3 = \\{a, b, c\\} $</p>\n\n<p>Regular expression:</p>\n\n<p>$r = cc^{*}(ba)^{*}bb$</p>\n\n<p>My solution, it seems a little too short like I'm leaving something out. Maybe someone can see where I went wrong on the right-linearity:</p>\n\n<p>$ S \\to cA $</p>\n\n<p>$ A \\to b a A | B | cA $</p>\n\n<p>$ B \\to bb $</p>\n", 'Tags': '<formal-languages><automata><formal-grammars><regular-expressions>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-06T03:50:49.073', 'CommentCount': '2', 'AcceptedAnswerId': '14850', 'CreationDate': '2013-10-06T03:27:41.210', 'Id': '14849''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I used this generalized transition graph with 3 states and got an equivalent generalized\ntransition graph with 2 states:</p>\n\n<p>GTG:</p>\n\n<p><img src="http://i.stack.imgur.com/LSUfs.jpg" alt="enter image description here"></p>\n\n<p>Equivalent with 2 states:</p>\n\n<p><img src="http://i.stack.imgur.com/nenwS.jpg" alt="enter image description here"></p>\n\n<p>I\'m not sure about the regular expressions linking the nodes $q0$ and $q2$, if someone can clarify where I may have gone wrong here.</p>\n', 'ViewCount': '44', 'Title': 'Reducing states of a GTG', 'LastActivityDate': '2013-10-06T09:56:23.350', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14856', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><graphs><automata><formal-grammars>', 'CreationDate': '2013-10-06T04:19:51.400', 'Id': '14852''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I know that an \u03b5-NFA (NFA with epsilon transitions) is not an NFA or a DFA and an NFA is not a DFA.</p>\n\n<p>HOWEVER, say you have a complete DFA. Isn\'t that theoretically an NFA and an \u03b5-NFA? Just because it doesn\'t have \u03b5 transitions, does it mean it is not \u03b5-NFA? If a question asks you to turn a DFA into an \u03b5-NFA, can\'t you just write the complete DFA as an answer? What properties make DFA different from \u03b5-NFA and NFA?</p>\n\n<p>The same question applies to NFA \u2192 \u03b5-NFA, isn\'t NFA a more "primitive" version of \u03b5-NFA? It\'s just NFA without the \u03b5...</p>\n', 'ViewCount': '453', 'Title': u'DFA/NFA/\u03b5-NFA: subsetting each other or different sets?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-09T12:53:54.957', 'LastEditDate': '2013-10-09T12:53:54.957', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '14912', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2013-10-08T14:12:16.447', 'Id': '14908''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Here is a simple transition system of beverage vending machine:\n<img src="http://i.stack.imgur.com/bgJM8.png" alt="beverage vending machine"> </p>\n\n<p>The exemplary execution fragments can look like this:</p>\n\n<p><img src="http://i.stack.imgur.com/F0kPo.png" alt="enter image description here"></p>\n\n<p>Now, imagine we have multi-process TS where processes are identical and communicate over channels. I don\'t understand the semantics of how to present an execution fragment that runs across multiple processes. Should I specify the whole execution in one line? If yes how do I denote that the state belongs to some certain process? Or maybe I present execution fragment on each process in the separate line? I\'d love to see a "meta-example" of how that could look like. </p>\n\n<p>I am referring to this specific <a href="http://www-i2.informatik.rwth-aachen.de/i2/fileadmin/user_upload/documents/MC11/sheet02.pdf" rel="nofollow">exercise sheet</a>, task 3.) b). The figures are from the book "Principles of Model Checking" by Christel Baier and Joost-Pieter Katoen p. 22 and p. 25.  </p>\n', 'ViewCount': '65', 'Title': 'Example of execution fragment of multi-process transition system', 'LastActivityDate': '2013-10-08T17:15:44.600', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10582', 'Tags': '<formal-languages><automata><model-checking><denotational-semantics>', 'CreationDate': '2013-10-08T17:15:44.600', 'Id': '14915''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm working on a proof that deals with a modified PDA, which is identitical to a PDA, but with transitions: \\begin{equation*}\na,b \\to c\n\\end{equation*} where $a$ is a context free grammar, instead of just a symbol. The modified PDA then reads a prefix $w'$ of $w$, the suffix of the input stream, where $w' \\in L(a)$.</p>\n\n<p>I'm try to prove that the language recognized by this modified PDA is context free, but I'm really stuck. I have no idea how to even get started. If someone could point me in the right direction, I would really appreciate it.</p>\n", 'ViewCount': '65', 'Title': 'Proving a PDA with CFG Transitions recognizes Context Free Languages', 'LastActivityDate': '2013-10-08T22:55:32.770', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14930', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10596', 'Tags': '<formal-languages><automata>', 'CreationDate': '2013-10-08T22:29:05.633', 'Id': '14927''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having a lot of trouble constructing a PDA for the language: \\begin{equation*}\n\\{a^m b^n : m &lt; 2n &lt; 3m \\}\n\\end{equation*}</p>\n\n<p>I know if I push a symbol for each $a$ I see, then pop 2 symbols for each $b$ I see, then I should run out to satisfy the $m &lt; 2n$ part of the inequality. But I really don't understand how to include the requirement $2n &lt; 3m$. I'm assuming it has something to do with clever branching based on non-determinism, but I can't wrap my head around it. Any help would really appreciated.</p>\n", 'ViewCount': '664', 'Title': 'Constructing a PDA for the language $\\{a^m b^n : m < 2n < 3m \\}$', 'LastEditorUserId': '9950', 'LastActivityDate': '2013-10-10T01:43:41.060', 'LastEditDate': '2013-10-10T01:43:41.060', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14962', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10448', 'Tags': '<formal-languages><automata><pushdown-automata>', 'CreationDate': '2013-10-09T00:28:08.143', 'Id': '14935''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was reading a proof that said that if $A \\le_{m} \\bar{A}$, then it can be inferred that $\\bar{A} \\le_{m} A$ as well. Is this a logical conclusion, and if so, why? I didn't think this followed with languages A and B, but if B is A's complement, can one make such a statement?</p>\n", 'ViewCount': '78', 'Title': 'If A is reducible to its complement, is the converse true as well?', 'LastActivityDate': '2013-10-10T05:23:05.013', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10621', 'Tags': '<formal-languages>', 'CreationDate': '2013-10-09T23:34:42.470', 'Id': '14967''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This almost makes sense to me, but I feel like I'm missing something.</p>\n\n<p>I know that for a decidable language, there must exist some total computable function $f$ that can take in any $x \\in \\sum^{*}$ and tell us whether or not $x$ is accepted (while my textbook is unclear, I would infer from this that decidable languages and computable functions are equivalent?)</p>\n\n<p>So I can see that $L$ is decidable if and only if some computable function can determine if $x \\in L$ or not, which implies the existence of a function $f(x)$ that outputs $x$ if $x \\in L$, and nothing otherwise (this makes sense in my head at least...correct me if I'm wrong). How would I use what's given to show that this is true for any recognizable $L$ though? Computable functions have finite steps have to halt, from my understanding, so how that they be used to check if $x$ belongs to a recognizable but undecidable language?</p>\n", 'ViewCount': '184', 'Title': 'How to show that a non-empty $L$ is recognizable iff there exists a total computable function whose range equals $L$', 'LastActivityDate': '2013-10-10T01:57:40.203', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10621', 'Tags': '<formal-languages>', 'CreationDate': '2013-10-10T01:23:17.253', 'Id': '14971''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a question from the exam of our "Automata and Formal Languages" course. There is a question where asked to prove or disprove that any "relative complement" operation between two context sensitive languages will also produce a context sensitive language. </p>\n\n<p>From the context sensitive closure properties <a href="http://en.wikipedia.org/wiki/Context-sensitive_language" rel="nofollow">Wikipedia</a>, and <a href="http://www.princeton.edu/~achaney/tmve/wiki100k/docs/Context-sensitive_language.html" rel="nofollow">princeton.edu</a>. \nI know that those languages are closed under intersection and complement.   </p>\n\n<p>I have spent too much time on finding the formal prove of those statements. Where / How can I find the proofs? Or how to prove them by myself? Can anyone point me to a reference ? Can any one post here the proofs ? </p>\n', 'ViewCount': '482', 'Title': 'How to prove that context sensitive languages are closed under intersection and complement?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-14T12:05:26.827', 'LastEditDate': '2013-10-14T12:05:26.827', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '15016', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10674', 'Tags': '<formal-languages><closure-properties><context-sensitive>', 'CreationDate': '2013-10-12T11:14:06.500', 'Id': '15014''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In class, it was alluded to that a language: \\begin{equation*}\n\\{s_0 w s_1 : s_0s_1\\in L_1, w\\in L_2 \\}\n\\end{equation*} would be context free, if $L_1$ and $L_2$ are context free.</p>\n\n<p>Intuitively, that doesn't make sense to me. I tried doing my own research and attempted a proof using the pumping lemma, but didn't get anywhere. Maybe I misunderstood? If that is correct, how could I prove it (or convince myself). </p>\n", 'ViewCount': '75', 'Title': 'Is $\\{s_0 w s_1 : s_0s_1\\in L_1, w\\in L_2 \\}$ context free if $L_1$ and $L_2$ are?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-14T22:13:02.620', 'LastEditDate': '2013-10-14T08:53:30.113', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16054', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10410', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2013-10-13T18:47:16.867', 'Id': '16048''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We define a <em>regular tree language</em> as in the book <a href="http://tata.gforge.inria.fr/" rel="nofollow">TATA</a>: It is the set of trees accepted by a non-deterministic finite tree automaton (Chapter 1) or, equivalently, the set of trees generated by a regular tree grammar (Chapter 2). Both formalisms hold close resemblances to the well-known string analogues.</p>\n\n<blockquote>\n  <p>Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?</p>\n</blockquote>\n\n<p>Obviously there are tree languages such that the height of a tree is linear in its size; and in the book <a href="http://algo.inria.fr/flajolet/Publications/books.html" rel="nofollow">Analytic Combinatorics</a> it is shown e.g. that binary trees of size $n$ have average height $2\\sqrt{ \\pi n}$. If I understand Proposition VII.16 (p.537) of the mentioned book correctly, then there is a wide subset of regular tree languages that have average height of $\\Theta(\\sqrt{n})$, namely those in which the tree language is also a <em>simple variety of trees</em> fulfilling some extra conditions.</p>\n\n<p>So I was wondering whether there is a regular tree language showing a different average height or if there is a true dichotomy for regular tree languages.</p>\n', 'ViewCount': '316', 'Title': 'Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T08:11:24.593', 'LastEditDate': '2013-10-18T08:11:24.593', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '10734', 'Tags': '<formal-languages><regular-languages><combinatorics><trees><tree-grammars>', 'CreationDate': '2013-10-14T14:19:09.910', 'FavoriteCount': '4', 'Id': '16073''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '47', 'Title': 'Deciding the class of certain languages', 'LastEditDate': '2013-10-14T20:20:11.933', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Body': "<p>I am preparing for my exam in Formal languages and Automata theory and I'm looking at some old exam questions right now. I need help with the following question: </p>\n\n<blockquote>\n  <p>For each of the following languages answer whether it is regular, context-free but not regular, or not context-free. A brief, informal explanation is sufficient.</p>\n  \n  <p>$$\n  L_3 = \\left\\{ w \\in \\{a,b,c,d\\}^* \\Bigg| \\begin{array}{l}\n      \\text{\\(w\\) does not have a substring \\(aba\\),} \\\\\n      \\text{each \\(a\\) in \\(w\\) is immediately followed by \\(b\\),} \\\\\n      \\text{and \\(\\#c(w)\\) is odd}\n    \\end{array} \\right\\}\n$$\n  $$ \\begin{align}\n  L_4 &amp;= \\{ a^ib^jc^ka^ib^l \\mid j \\gt l \\text{ and } i,l,k \\gt 0 \\} \\\\\n  L_5 &amp; \\text{ is the image of \\(L_4\\) under the homomorphism }\n  h:\\{a,b,c,d\\}^* \\to \\{0,1,2\\}^* \\\\ &amp; \\text{ such that }\n  h(a) = h(b) = 10 \\text{ and } h(c) = 210 \\text{ and } h(d) = \\epsilon \\\\\n  L_6 &amp; \\text{ is the image of \\(L_4\\) under the homomorphism }\n  h:\\{a,b,c,d\\}^* \\to \\{0,1,2\\}^* \\\\ &amp; \\text{ such that } \n  h(a) = h(b) = 210 \\text{ and } h(c) = h(d) = \\epsilon \\\\\n\\end{align} $$</p>\n</blockquote>\n\n<p>Here is my attempt:</p>\n\n<p>$L_3$ is regular. It's the intersection between 3 regular languages. Regular languages are closed under intersection, so the resulting language is regular. The language where $w$ does not have a substring $aba$ is just the complement of the language $aba$, regular languages are closed under complement, so the resulting language is regular. The language with an odd number of $c$ is regular. Hence the resulting language when taking the intersection between these languages is regular.</p>\n\n<p>$L_4$ is not context-free. When reading the first $a$'s we will push the $a$'s onto the stack. Then we will read the first $b$'s and push them onto the stack. Then we will read the $c$'s. When we now read a second group of $a$'s, we will not be able to compare the number with the first $a$'s, because $b$'s are on the top of the stack and if we pop them then we will not be able to compare the number $b$'s in the beginning and the end. Hence, $L_4$ is not context-free. </p>\n\n<p>$L_5$ is context-free but not regular. The language in question looks like this:\n$$ 10^{i+j} 210^k10^{i+l} \\text{ where } j \\gt l \\text{ and } i,l, k \\gt 0 $$\nA grammar can be constructed which generates at least one more $10$ in the beginning of the string than $10$ after $210$.</p>\n\n<p>$L_6$ is regular because it's given by the regular expression:\n$$ 210^{2i + j + l} \\text{ where } 2i+j+l \\text{ is any number } \\gt 0$$</p>\n\n<p>Is this correct? Note that informal explanations is sufficient in the answer and that no grammars has to be given.</p>\n", 'ClosedDate': '2013-10-30T10:12:35.357', 'Tags': '<formal-languages><context-free><automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-14T20:20:11.933', 'CommentCount': '1', 'AcceptedAnswerId': '16075', 'CreationDate': '2013-10-14T14:29:02.520', 'Id': '16074''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m referring to regular expressions as language: \\begin{equation*}\n \\Sigma = \\{ ``a", ``b", ``(", ``)", ``*", ... \\}\n\\end{equation*} and \\begin{equation*}\n L = \\Sigma^* \\text{, which form a legal regular expression}\n\\end{equation*} I am not referring to their computational power. I did some research, but wasn\'t able to find anything relevant. Intuitively, I would imagine they\'re context-free, but am not sure how to attempt a proof.</p>\n\n<p>I am trying to use this as a lemma, so a reference, or recommendation for how to attempt a proof would be extremely helpful.</p>\n', 'ViewCount': '98', 'Title': 'Where in the Chomsky Hierarchy are Regular Expressions as a language?', 'LastActivityDate': '2013-10-15T19:40:06.070', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16110', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10596', 'Tags': '<formal-languages><reference-request><regular-languages>', 'CreationDate': '2013-10-15T19:28:55.387', 'Id': '16109''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm enrolled to a Formal Language And Automata course, and we have to prove this equation on sets of strings:\n$$(L_1\\cap L_2)\\cdot L_3 \u2260 (L_1\\cdot L_3) \\cap (L_2\\cdot L_3)$$</p>\n\n<p>I've tried a lot of sets for e.g.\n$L1 = \\{a,b,c,d\\}$,\n$L2 = \\{a,f,g\\}$,\n$L3 = \\{s,d,h\\}$.\nbut always the LHS comes out equal to the RHS instead of unequal.\nAny idea how to prove this?</p>\n", 'ViewCount': '125', 'Title': 'Concatenation of the intersection of two languages', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-24T22:40:51.497', 'LastEditDate': '2013-10-23T08:44:31.133', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16337', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10918', 'Tags': '<formal-languages><sets>', 'CreationDate': '2013-10-22T12:58:06.627', 'Id': '16334''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $C$ be an infinite set of characters.  I'd like an abstract machine which can recognize sequences consisting of $k$ (constant) of repetitions of a char from $C$.</p>\n\n<p>For example, if ${x,y,z} \\subset C$, and $k = 3$, it should recognize $xxx$ but not $ddd$ or $xyz$.  (The same char must be repeated.)</p>\n\n<p>Since $C$ is infinite, a finite state machine <em>cannot</em> recognize this.  A Turing machine trivially can.  But we don't anything like the power of a Turing machine; simply extending the FSM with a single register that points to a member of $C$ is enough.</p>\n\n<p>My question is: What's the simplest formal abstract machine that is powerful enough to recognize this? Is there a standard extension to FSM's that enables them to recognize this? If I have more complicated versions of this machine (e.g. <em>Move from state 2 to state 3 if you encounter a $k$ repetition of a $C$ char</em>), what's the best way to express them?</p>\n", 'ViewCount': '108', 'Title': 'Abstract machine that can recognize repetition', 'LastActivityDate': '2013-12-22T22:31:30.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<formal-languages><computability><turing-machines><automata><finite-automata>', 'CreationDate': '2013-10-23T13:09:59.097', 'Id': '16362''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently studying compilers and am having some issues with understanding regular sets. For example, lets say I had a set of binary strings, (0, 1). Would all integers that are even and positive be considered part of a regular set? Lets say I have that same set, but instead of being even, they are divisible by 5, would it still be a regular set?</p>\n\n<p>I\'ve been looking at <a href="http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf" rel="nofollow">this helpful guide</a> I found online, but I\'m still confused about what can be defined as a regular set.</p>\n', 'ViewCount': '71', 'Title': 'What can be defined as a Regular Set', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-28T07:26:56.920', 'LastEditDate': '2013-10-28T07:26:56.920', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11008', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-10-28T02:13:44.947', 'Id': '16485''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>The following is a homework assignment. I am looking for criticism / feedback on my solution, and I have a specific question.</p>\n\n<blockquote>\n  <p>Suppose $L$ is a language over $\\Sigma$, and $x_1, x_2, ... , x_n$ are\n  strings that are pairwise $L$-distinguishable. How many distinct\n  strings are necessary in order to distinguish between the $x_i$'s? In\n  other words, what is the smallest number $k$ such that for some set\n  $\\{z_1, z_2, ...,z_k\\}$, any two distinct $x_i$'s are distinguished,\n  relative to $L$, by some $z_l$? Prove your answer.</p>\n</blockquote>\n\n<p>The book gives a hint, which reads as follows:</p>\n\n<blockquote>\n  <p>Here is a way of thinking about the question that may make it easier. Think of the $x_i$\u2019s as points on a piece of paper, and think of the $z_l$\u2019s as cans of paint, each $z_l$ representing a different primary color. Saying that $z_l$ distinguishes $x_i$ and $x_j$ means that one of those two points is colored with that primary color and the other isn\u2019t. We allow a single point to have more than one primary color applied to it, and we assume that two distinct combinations of primary colors produce different resulting colors. Then the question is, how many different primary colors are needed in order to color the points so that no two points end up the same color?</p>\n</blockquote>\n\n<p>I have surely addressed this question Here is my answer.</p>\n\n<blockquote>\n  <p><strong>Solution</strong>: Coloring $n$ points so that no two points end up the same color requires $\\lceil \\log_2 n \\rceil$ primary colors.</p>\n  \n  <p>First enumerate the points using binary representations, and let each digit correspond to a primary color. Then we identify the combination of colors for a given point as all primary colors whose corresponding digit is 1. Each of the points has a unique representation, so each combination of primary colors will be unique. </p>\n</blockquote>\n\n<p>What do you think of this response? Do you think it needs further explanation? </p>\n\n<p>Also, I am having trouble translating this argument into the context of the original question. How can I better see that the problems are the same?</p>\n", 'ViewCount': '76', 'ClosedDate': '2014-01-28T22:49:25.240', 'Title': 'Smallest Number of Strings to Distinguish $n$ Pairwise $L$-distinguishable Strings', 'LastActivityDate': '2014-01-28T21:15:17.440', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11000', 'Tags': '<formal-languages><computation-models>', 'CreationDate': '2013-10-30T16:59:24.170', 'Id': '16580''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The question is to design a CFG for the language of words that have as many c's as the difference of numbers of a's and b's, that is</p>\n\n<p>$\\qquad\\displaystyle L = \\{(a^l)(b^m)(c^n) \\mid l, m \\in \\mathbb{N}; n = |l-m|\\}$.</p>\n\n<p>I have so far go to create the cfg for $(a^l)(b^m)$ but don't know how to do the one for $(c^n)$. It looks complicated as to find the value of n, we need to take the abs value for the difference between l and m. Can someone help?</p>\n\n<p>And, here is the cfg I got so far for $(a^l)(b^m)$.</p>\n\n<p>$S \\to aS \\mid bT|\\epsilon $</p>\n\n<p>$T \\to bT \\mid \\epsilon$</p>\n\n<p>I hope this is correct.</p>\n", 'ViewCount': '127', 'Title': "Designing a CFG that produces as many c's as the difference of numbers of a's and b's", 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T10:03:20.963', 'LastEditDate': '2013-11-02T09:57:25.863', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '16624', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11110', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-10-31T22:27:49.183', 'Id': '16608''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been trying to get a CFG for the language of all words with unequal numbers of a and b, i.e.</p>\n\n<p>$\\qquad \\displaystyle \\{u \\in \\{a, b\\}^* \\mid \\text{number of occurrences of $a$ and $b$ in $u$ are unequal} \\}$,</p>\n\n<p>but it seems that I keep getting specific cases instead of the general case.</p>\n\n<p>Here are some that I have tried:</p>\n\n<p>(S being the start Variable)</p>\n\n<pre><code>S -&gt; A | a | b\nA -&gt; aV | bT\nV -&gt; aV | bL\nL -&gt; aV\nT -&gt; bT | aM\nM -&gt; aT\n</code></pre>\n\n<p>This one's problem is that you can't create 2 of the same string if it's the lesser amount of alphabet.</p>\n\n<p>So I've tried</p>\n\n<pre><code>S-&gt; A | B\nA -&gt; aV | a\nV -&gt; aV | aVb | bVa\nB -&gt; bT | b\nT -&gt; bT | aTb | bTa\n</code></pre>\n\n<p>This one also has problem because if you have a you need to have b on the opposite end.</p>\n\n<p>Additionally, I know this is one of the huge problem in my process is that you start with 'a' or 'b' and use that as a flag for if there is more 'a' or there is more 'b'... </p>\n\n<p>I've been trying to think the way where you can input an alphabet (i.e <code>S -&gt; aV | bV</code>) so that I can start with any variable and I use cases or condition to go to different variable, but I end up with infinite variable situation.</p>\n", 'ViewCount': '241', 'Title': 'Context-free grammar for language with unequal numbers of a and b', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T09:52:27.167', 'LastEditDate': '2013-11-02T09:52:27.167', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<formal-languages><context-free><automata>', 'CreationDate': '2013-11-02T06:30:01.203', 'Id': '16642''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am stuck and having a hard time with this question. I want to construct a CFG for the language $$L = \\{{a^lb^mc^n | l,m\\in N, n=|l-m|\\}}$$\nI know that the language consists of strings where:\n<br>1. number of a's = number of b's, so c=0\n<br>2. number of a's more than number of b's, c=l-m\n<br>3. number of a's less than number of b's, c=-(l-m)\n<br>\nI started with\n$$S-&gt;ab$$\n$$S-&gt;aSb$$\nThis generates all of case one, where number of a's = number of b's and c=0. I know that I could increment a's and c's by having aSc but I cant put that in the second line because it could generate a(aSc)b which is not in the language. </p>\n", 'ViewCount': '288', 'ClosedDate': '2013-11-03T22:53:27.903', 'Title': 'Constructing Context Free Grammar', 'LastActivityDate': '2013-11-03T20:53:04.023', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16679', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><computability><context-free>', 'CreationDate': '2013-11-03T19:19:09.937', 'Id': '16678''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I can't figure out a proof that recursive languages are closed under concatenation. I know this is easy for most of the people but unfortunately my professor is not very good at explaining the material. If anybody can provide any hints on how to do it I would greatly appreciate it.</p>\n", 'ViewCount': '106', 'Title': 'Proof that recursive languages are closed under concatenation', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-19T21:27:20.623', 'LastEditDate': '2014-04-19T21:27:20.623', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<formal-languages><computability><closure-properties>', 'CreationDate': '2013-11-03T22:38:03.393', 'Id': '16680''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How to prove that if a language A is not regular then A* isn't regular either?</p>\n\n<p>I have tried the usual methods with no result.</p>\n", 'ViewCount': '157', 'Title': 'Is the class of non-regular languages closed against Kleene star?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-04T19:22:08.677', 'LastEditDate': '2013-11-04T19:22:08.677', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11166', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-11-04T07:58:34.270', 'Id': '16695''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I would have a brief question about how to construct a Turing machine that is accepting <em>only</em> this language:</p>\n\n<p>$\\qquad\\displaystyle L_2 = \\{a^i b^j \\mid i \\geq j \\}$.</p>\n\n<p>I can't come up with any mechanism that would preserve that there are greater or equal number of 'a's than 'b's. Could you suggest me something?</p>\n", 'ViewCount': '406', 'Title': 'Turing machine for $a^i b^j$ with $i \\geq j$', 'LastEditorUserId': '630', 'LastActivityDate': '2014-02-03T11:19:19.737', 'LastEditDate': '2013-11-05T03:58:44.963', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11176', 'Tags': '<formal-languages><turing-machines><automata>', 'CreationDate': '2013-11-04T17:05:54.830', 'FavoriteCount': '0', 'Id': '16713''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to create a regular expression that will generate the following language under the {a,b,c} alphabet:\nall words that do not contain the substring "bbc"</p>\n\n<p>I am having a really hard time understanding how to approach this question. I have done several other questions where a certain substring must be excluded, but this one really messes with my logic.</p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '83', 'ClosedDate': '2013-11-08T23:00:27.200', 'Title': 'A little help with regular expressions', 'LastActivityDate': '2013-12-09T10:40:08.243', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11200', 'Tags': '<formal-languages><regular-expressions><substrings>', 'CreationDate': '2013-11-05T12:22:33.267', 'Id': '16735''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have an assignment where i need to create a Turing machine that decides an infinite language $L\\subset \\{0,1\\}^*$ for which all $L'\\subseteq L$, if $|L'|=\\infty$, then $L'$ is not a regular language.</p>\n\n<p>I think this is not possible due to Rice's Theorem. It's not possible to tell for a Turing Machine if a language is regular or not.</p>\n\n<p>Moreover, on any given input, the machine can loop so it cannot decide an infinite language $L$.</p>\n\n<p>Is this the right answer? It seems too easy to be the answer... Any input would be appreciable. Thanks in advance.</p>\n", 'ViewCount': '311', 'Title': 'Can a Turing Machine decide only non-regular languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T11:27:53.427', 'LastEditDate': '2013-11-08T11:27:53.427', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '16786', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<formal-languages><regular-languages><turing-machines><automata>', 'CreationDate': '2013-11-05T17:52:50.853', 'Id': '16745''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to be able to describe the idea behind the pushdown automaton (no tables or diagrams). </p>\n\n<p>So, I already know that $L = \\{ ww \\mid w \\text{ in } (0,1)^*\\}$ is not context free. Since CFL are not closed under complement its complement $L'$ is a CFL. \nI also read somewhere that any odd word is part of $L'$ (what about even length words?). So a pushdown automaton description could be: read one letter and put into stack, then read next letter and remove previous letter from stack. Do this until the end. If one letter is left in the stack at the end then word is odd length thus accept, else reject?</p>\n", 'ViewCount': '423', 'Title': 'Pushdown automaton for complement of $L = \\{ ww \\mid w \\text{ in } (0,1)^*\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T22:45:29.333', 'LastEditDate': '2013-11-08T11:45:37.150', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16755', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10713', 'Tags': '<formal-languages><context-free><automata><pushdown-automata>', 'CreationDate': '2013-11-05T23:35:45.853', 'Id': '16753''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have the following grammar G:\n$$\n\\begin{align*}\n&amp;S \\to aB|bA \\\\\n&amp;A \\to a|aS|bAA \\\\\n&amp;B \\to b|bS|aBB\n\\end{align*}\n$$</p>\n\n<p>I am going to prove that this language L(G) consists of words with the same number of a's and b's by strong induction.</p>\n\n<p><strong>Inductive hypothesis</strong>: $S$ produces $m$ $a$'s and $m$ $b$'s, $A$ produces $m+1$ $a$'s and $m$ $b$'s, $B$ produces $m$ $a$'s and $m+1$ $b$'s for some integer $m$. </p>\n\n<p><strong>Base</strong>: The smallest string produced by $S$ is $ab$ or $ba$. The smallest string produced by $A$ and $B$ is $a$ and $b$ respectively. All three satisfy the IH. </p>\n\n<p><strong>Induction</strong>: Assume the inductive hypothesis is satisfied for all strings of length $k$ or less. </p>\n\n<p>For strings of length $k+1$:</p>\n\n<p><strong>(1)</strong>. $A\\to aS$; then $S$ inductively derived a string of length $k-1$ with same number of $a$'s as $b$'s. Since $A$ is initiated by $S\\to bA$, we concatenate that $b$ plus the $a$ in $aS$ and we get a string of length $k+1$ with same number of $a$'s as $b$'s.</p>\n\n<p><strong>(2)</strong>. $A\\to bAA$; then each $A$ on the right hand side has one more $a$ than $b$. Since $A$ is initiated by $S\\to bA$, we concatenate that $b$ plus the $b$ in $bAA$ and we get a string of length $k+1$ with the same number of $a$'s as $b$'s.  </p>\n\n<p>Can I continue for $B\\to bS$ and $B\\to aBB$? Am I totally wrong here? </p>\n", 'ViewCount': '104', 'Title': "Is my proof for a context free language correct? Same number of a's as b's", 'LastEditorUserId': '11155', 'LastActivityDate': '2013-11-07T05:05:43.043', 'LastEditDate': '2013-11-07T05:05:43.043', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques>', 'CreationDate': '2013-11-07T02:26:03.960', 'Id': '16787''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '66', 'Title': 'Do these languages both have DPDA?', 'LastEditDate': '2013-11-09T15:24:56.840', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10030', 'Body': "<p>We have these languages:\n$$L_1 = \\{a^nb^na^mb^m \\ | n \\ge 0, m \\ge 1\\}$$\n$$L_2 = \\{a^nb^na^mb^{2m} \\ | n \\ge 0, m \\ge 1\\}$$</p>\n\n<p>are both these languages NCFG?</p>\n\n<p>I guess that both of them are NCFG because of $n \\ge 0$ ,at start we can't distinguish whether it is $a$ for the first part or the second part and hence we should act non deterministic.</p>\n", 'ClosedDate': '2013-11-11T13:54:24.870', 'Tags': '<formal-languages><context-free><automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T15:24:56.840', 'CommentCount': '5', 'AcceptedAnswerId': '16849', 'CreationDate': '2013-11-09T12:50:19.650', 'Id': '16846''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I missed a question about a CFG on an assignment, but the grader wouldn't explain what was wrong with my answer and instead provided me the answer from the book.</p>\n\n<p>Here is the language: </p>\n\n<p>$\\qquad\\displaystyle L = \\{a^n b^m c^k : n = m \\lor m \\neq k\\}$</p>\n\n<p>And my CFG. </p>\n\n<pre><code>S \u2192 AB|CD|CE\nA \u2192 aAb|\u03bb\nB \u2192 Bc|\u03bb\nC \u2192 aC|\u03bb\nD \u2192 bDc|Dc|c\nE \u2192 bEc|bE|b\n</code></pre>\n\n<p>Can somebody explain why this grammar doesn't work for the given language?</p>\n", 'ViewCount': '55', 'Title': 'Does this CFG produce this language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T20:33:53.077', 'LastEditDate': '2013-11-09T19:58:29.333', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11285', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-11-09T19:08:29.113', 'Id': '17853''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a professor who is really poor at explaining the material, which is what makes answering his questions very hard. Here is the question:</p>\n\n<blockquote>\n  <p>Recursive language with non-recursive subsets. Does one exist?</p>\n</blockquote>\n\n<p>I'm sure it is a very simple and easy answer but I can't figure it out. Don't give me the answer just point me in the right direction and I'm sure I'll figure it out.</p>\n", 'ViewCount': '77', 'Title': 'Recursive language with non-recursive subsets', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T10:14:36.530', 'LastEditDate': '2013-11-10T10:14:36.530', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2013-11-10T00:38:17.997', 'Id': '17860''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been thinking about this one for a while:</p>\n\n<blockquote>\n  <p>Consider the language of TMs which do not recognize themselves: $L_{s}=\\{ \\langle M\\rangle ~|~ M \\text{ does not accept } \\langle M\\rangle \\}$. If $N$ is a TM where $L(N) \\subseteq L_s$, then is $\\langle N\\rangle \\in L_s$?</p>\n</blockquote>\n\n<p>Intuitively, I'm pretty sure it is true. I pictured $N$ as a compiler, and imagined some machine $P$ that $N$ compiled. It seemed that if $P$ was not able to bootstrap, then $N$ wouldn't be able to either. But I'm having trouble thinking about this problem more formally. </p>\n\n<p>Am I on the right track? A hint would be really helpful.</p>\n", 'ViewCount': '37', 'Title': 'If the language of a TM is TMs which cannot self recognize, can the original TM?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T10:23:15.397', 'LastEditDate': '2013-11-10T10:23:15.397', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17868', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10410', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-11-10T06:20:57.600', 'Id': '17867''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to prove that the following language is undecidable:$$\n   \\{ \\langle M, w \\rangle ~|~ M \\text{ is a TM where its head moves left a finite number of times on } w \\}\n$$</p>\n\n<p>But I'm having a bit of trouble. I know I have to do some type of reduction, but I'm not really sure what. Can a Turing Machine be simulated by one which only moves left? if so, then I think I could show $A_{TM}$ reduces to it. Any hints would be appreciated.</p>\n", 'ViewCount': '122', 'Title': 'Proving that the language of TMs which only moves left is undecideable', 'LastActivityDate': '2013-11-10T23:50:37.143', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17896', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11304', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-11-10T23:13:53.543', 'FavoriteCount': '1', 'Id': '17892''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m looking for the name of the following concept.</p>\n\n<p>Given a monoid $(M,\\oplus)$, and a finite set of generators $x_1,\\ldots,x_n$. The generators are the alphabets.</p>\n\n<p>We define the regular expression on the <a href="http://en.wikipedia.org/wiki/Word_%28group_theory%29" rel="nofollow">words</a> formed by the generators. We treat those words just like strings. </p>\n\n<p>For words $x$ and $y$, we write $x\\equiv y$ if $x$ and $y$ represent the same element in $M$.</p>\n\n<p>If $R$ is a regular expression, we define $L(R)$ to be the set of strings matched by $R$ and $L_M(R)$ as</p>\n\n<p>$$L_M(R) = \\{w\'|w\'\\equiv w,w\\in L(R)\\}$$.</p>\n\n<p>I\'m interested to know if there exist known literature on $L_M(R)$. </p>\n\n<p>Many problems related to $L_M(R)$ are undecidable, because the word problem on $M$ might be undecidable. I wonder if $M$ has a decidable word problem, does it imply we can decide if $L_M(R)=L_M(R\')$ for 2 regular expressions $R$ and $R\'$.</p>\n', 'ViewCount': '72', 'Title': 'Regular expression over a monoid', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-11T17:56:45.023', 'LastEditDate': '2013-11-11T10:28:52.773', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17918', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '220', 'Tags': '<formal-languages><reference-request>', 'CreationDate': '2013-11-11T00:20:41.683', 'Id': '17897''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '227', 'Title': 'Complements of Linear Bounded Automata?', 'LastEditDate': '2013-11-11T02:08:06.417', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11306', 'FavoriteCount': '1', 'Body': "<p>Would switching the accept and reject states of an LBA A create a new LBA we'll say A' in which the language of A' is the complement of the language of A? I believe the answer is yes just by working out an example...but I'm not sure on a solid proof...nor am I sure if the fact that I am working with an LBA vs a regular turing machine makes a difference in this case. </p>\n", 'Tags': '<formal-languages><turing-machines><linear-bounded-automata>', 'LastEditorUserId': '11306', 'LastActivityDate': '2013-11-20T21:18:16.770', 'CommentCount': '3', 'AcceptedAnswerId': '18208', 'CreationDate': '2013-11-11T00:39:57.630', 'Id': '17898''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '172', 'Title': 'How do I find the shortest representation for a subset of a powerset?', 'LastEditDate': '2013-11-12T12:05:50.837', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1575', 'FavoriteCount': '1', 'Body': "<p>I'm looking for an efficient algorithm for the following problem or a proof of NP-hardness.</p>\n\n<p>Let $\\Sigma$ be a set and $A\\subseteq\\mathcal{P}(\\Sigma)$ a set of subsets of $\\Sigma$. Find a sequence $w\\in \\Sigma^*$ of least length such that for each $L\\in A$, there is a $k\\in\\mathbb{N}$ such that $\\{ w_{k+i} \\mid 0\\leq i &lt; |L| \\} = L$.</p>\n\n<p>For example, for $A = \\{\\{a,b\\},\\{a,c\\}\\}$, the word $w = bac$ is a solution to the problem, since for $\\{a,b\\}$ there's $k=0$, for $\\{a,c\\}$ there's $k=1$.</p>\n\n<p>As for my motivation, I'm trying to represent the set of edges of a finite automaton, where each edge can be labeled by a set of letters from the input alphabet. I'd like to store a single string and then keep a pair of pointers to that string in each edge. My goal is to minimize the length of that string.</p>\n", 'Tags': '<algorithms><formal-languages><encoding-scheme>', 'LastEditorUserId': '1575', 'LastActivityDate': '2013-11-18T21:37:48.757', 'CommentCount': '11', 'AcceptedAnswerId': '18093', 'CreationDate': '2013-11-11T10:54:26.300', 'Id': '17914''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there an algorithm/systematic procedure to test whether a language is context-free?</p>\n\n<p>In other words, given a language specified in algebraic form (think of something like $L=\\{a^n b^n a^n : n \\in \\mathbb{N}\\}$), test whether the language is context-free or not.  Imagine we are writing a web service to help students with all their homeworks; you specify the language, and the web service outputs "context-free" or "not context-free".  Is there any good approach to automating this?</p>\n\n<p>There are of course techniques for manual proof, such as the pumping lemma, Ogden\'s lemma, Parikh\'s lemma, the Interchange lemma, and <a href="http://cs.stackexchange.com/q/265/755">more here</a>.  However, they each require manual insight at some point, so it\'s not clear how to turn any of them into something algorithmic.</p>\n\n<p>I see <a href="http://cs.stackexchange.com/a/282/755">Kaveh has written elsewhere</a> that the set of non-context-free languages is not recursively enumerable, so it seems there is no hope for any algorithm to work on all possible languages.  Therefore, I suppose the web service would need to be able to output "context-free", "not context-free", or "I can\'t tell".  Is there any algorithm that would often be able to provide an answer other than "I can\'t tell", on many of the languages one is likely to see in textbooks?  How would you build such a web service?</p>\n\n<hr>\n\n<p>To make this question well-posed, we need to decide how the user will specify  the language.  I\'m open to suggestions, but I\'m thinking something like this:</p>\n\n<p>$$L = \\{E : S\\}$$</p>\n\n<p>where $E$ is a word-expressions and $S$ is a system of linear inequalities over the length-variables, with the following definitions:</p>\n\n<ul>\n<li><p>Each of $x,y,z,\\dots$ is a word-expression.  (These represent variables that can hold any word in $\\Sigma^*$.)</p></li>\n<li><p>Each of $a,b,c,\\dots$ is a word-expression.  (Implicitly, $\\Sigma=\\{a,b,c,\\dots\\}$, so $a,b,c,\\dots$ represent a single symbol in the underlying alphabet.)</p></li>\n<li><p>Each of $a^\\eta,b^\\eta,c^\\eta,\\dots$ is a word-expression, if $\\eta$ is a length-variable.</p></li>\n<li><p>The concatenation of word-expressions is a word-expression.</p></li>\n<li><p>Each of $m,n,p,q,\\dots$ is a length-variable.  (These represent variables that can hold any natural number.)</p></li>\n<li><p>Each of $|x|,|y|,|z|,\\dots$ is a length-variable.  (These represent the length of a corresponding word.)</p></li>\n</ul>\n\n<p>This seems broad enough to handle many of the cases we see in textbook exercises.  Of course, you can substitute any other textual method of specifying a language in algebraic form, if you like.</p>\n', 'ViewCount': '119', 'Title': 'Algorithm to test whether a language is context-free', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T14:39:17.787', 'LastEditDate': '2013-11-12T14:39:17.787', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><formal-languages><context-free><decision-problem>', 'CreationDate': '2013-11-11T19:42:12.637', 'FavoriteCount': '3', 'Id': '17921''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I had a question on an assignment where we were supposed to write a regular expression for a language where every $a$ in $w$ is immediately preceded and followed by a $b$. My answer was $\\epsilon + (b + bab)^*$. The teacher pointed out that my answer makes an $a$ surrounded by at least two $b$s, which isn't correct. I can't for the life of me figure out how to fix it to make it correct. Can anyone help?</p>\n", 'ViewCount': '55', 'Title': "Regular expression for the language where every a is surrounded by b's", 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T17:56:34.657', 'LastEditDate': '2013-11-12T17:56:34.657', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '17934', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10884', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-11-11T19:55:17.943', 'Id': '17924''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given the language with alphabet: $\\{a, b, c\\}$\nDraw an NFA or DFA for all the strings that have exactly twice substrings $ab$ and at least on $c$.\nI\'m stuck with "exactly twice $ab$". Can somebody give me some ideas. It\'s also very good if you can suggest me the regular expression of this statement.</p>\n', 'ViewCount': '399', 'Title': 'NFA or DFA for strings the contain exactly twice substring ab?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-13T16:08:45.447', 'LastEditDate': '2013-11-12T09:47:18.353', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-11-12T03:43:29.253', 'Id': '17942''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been thinking about how to show this but I'm stuck.</p>\n\n<p>I'm required to prove this:</p>\n\n<blockquote>\n  <p>Show that the language $$\\mathrm{TOT}= \\{\\langle M \\rangle : M\\text{ is a Turing Machine that halts with all inputs} \\}$$ is not recursively enumerable nor its complement. ($\\langle M \\rangle$ is an encoded Turing Machine with only zeros and ones).</p>\n</blockquote>\n\n<p>I think we have to proceed by contradiction, assuming that $\\mathrm{TOT}$ is recursively enumerable, so there must be a Turing Machine that we will call $T$ such that it can process any possible encoding $\\langle M \\rangle$ of a TM $M$ and only accept those machines that halt with all inputs.</p>\n\n<p>So in order to confirm that $\\mathrm{TOT}$ is r.e., $T$ should be able to do this for every $M$ that halts with all inputs. My idea is to show that this is not possible because the set $\\mathrm{TOT}$ is not countable, so maybe I can show this using the diagonalization argument, but I'm not sure.</p>\n\n<p>So what is the correct way to prove this?</p>\n\n<p>Thanks</p>\n", 'ViewCount': '28', 'ClosedDate': '2013-11-13T22:14:17.077', 'Title': 'Show that the language of all total Turing machines is neither r.e. nor co-r.e', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:13:18.120', 'LastEditDate': '2013-11-13T22:13:18.120', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11349', 'Tags': '<formal-languages><computability><turing-machines>', 'CreationDate': '2013-11-13T02:20:56.380', 'Id': '17977''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Is there an algorithm/systematic procedure to test whether a language is regular?</p>\n\n<p>In other words, given a language specified in algebraic form (think of something like $L=\\{a^n b^n : n \\in \\mathbb{N}\\}$), test whether the language is regular or not.  Imagine we are writing a web service to help students with all their homeworks; the user specifies the language, and the web service responds with "regular",  "not regular", or "I don\'t know".  (We\'d like the web service to answer "I don\'t know" as infrequently as possible.)  Is there any good approach to automating this?  Is this tractable?  Is it decidable (i.e., is it possible to guarantee that we never need to answer "I don\'t know")?  Are there reasonably efficient algorithms for solving this problem, and be able to provide an answer other than "don\'t know" for many/most languages that are likely to arise in practice?</p>\n\n<p>The classic method for proving that a language is not regular is the pumping lemma.  However, it looks like requires manual insight at some point (e.g., to choose the word to pump), so I\'m not clear on whether this can be turned into something algorithmic.</p>\n\n<p>A classic method for proving that a language is regular would be to use the  Myhill\u2013Nerode theorem to derive a finite-state automaton.  This looks like a promising approach, but it does requires the ability to perform basic operations on languages in algebraic form.  It\'s not clear to me whether there\'s a systematic way to symbolically perform all of the operations that may be needed, on languages in algebraic form.</p>\n\n<hr>\n\n<p>To make this question well-posed, we need to decide how the user will specify  the language.  I\'m open to suggestions, but I\'m thinking something like this:</p>\n\n<p>$$L = \\{E : S\\}$$</p>\n\n<p>where $E$ is a word-expression and $S$ is a system of linear inequalities over the length-variables, with the following definitions:</p>\n\n<ul>\n<li><p>Each of $x,y,z,\\dots$ is a word-expression.  (These represent variables that can take on any word in $\\Sigma^*$.)</p></li>\n<li><p>Each of $x^r,y^r,z^r,\\dots$ is a word-expression.  (Here $x^r$ represents the reverse of the string $x$.)</p></li>\n<li><p>Each of $a,b,c,\\dots$ is a word-expression.  (Implicitly, $\\Sigma=\\{a,b,c,\\dots\\}$, so $a,b,c,\\dots$ represent a single symbol in the underlying alphabet.)</p></li>\n<li><p>Each of $a^\\eta,b^\\eta,c^\\eta,\\dots$ is a word-expression, if $\\eta$ is a length-variable.</p></li>\n<li><p>The concatenation of word-expressions is a word-expression.</p></li>\n<li><p>Each of $m,n,p,q,\\dots$ is a length-variable.  (These represent variables that can take on any natural number.)</p></li>\n<li><p>Each of $|x|,|y|,|z|,\\dots$ is a length-variable.  (These represent the length of a corresponding word.)</p></li>\n</ul>\n\n<p>This seems broad enough to handle many of the cases we see in textbook exercises.  Of course, you can substitute any other textual method of specifying a language in algebraic form, if you have a better suggestion.</p>\n', 'ViewCount': '209', 'Title': 'Algorithm to test whether a language is regular', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-17T20:52:53.740', 'LastEditDate': '2013-11-14T22:53:44.637', 'AnswerCount': '1', 'CommentCount': '13', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><formal-languages><regular-languages><decision-problem>', 'CreationDate': '2013-11-14T07:13:17.670', 'FavoriteCount': '1', 'Id': '18010''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This sub-problem is motivated by <a href="http://cs.stackexchange.com/q/18010/755">Algorithm to test whether a language is regular</a>.</p>\n\n<p>Suppose we have two languages $L_1,L_2$ that are expressed in "algebraic" form, as formalized below.  I want to determine whether $L_1 = L_2$.</p>\n\n<p>Is this decidable?  If yes, can anyone suggest an algorithm for this?  If not, can anyone suggest a semi-algorithm (one that returns "equal", "not equal", or "I\'m not sure"; where we want it to return "not sure" as rarely as possible).</p>\n\n<p>Motivation: A solution to this sub-problem would be helpful for solving <a href="http://cs.stackexchange.com/q/18010/755">Algorithm to test whether a language is regular</a></p>\n\n<hr>\n\n<p><strong>Algebraic form.</strong> Here\'s one possible definition of what I mean by a representation of a language in algebraic form.  Such a language is given by</p>\n\n<p>$$L = \\{E : S\\}$$</p>\n\n<p>where $E$ is a word-expression and $S$ is a system of linear inequalities over the length-variables, with the following definitions:</p>\n\n<ul>\n<li><p>Each of $x,y,z,\\dots$ is a word-expression.  (These represent variables that can take on any word in $\\Sigma^*$.)</p></li>\n<li><p>Each of $x^r,y^r,z^r,\\dots$ is a word-expression.  (Here $x^r$ represents the reverse of the string $x$.)</p></li>\n<li><p>Each of $a,b,c,\\dots$ is a word-expression.  (Implicitly, $\\Sigma=\\{a,b,c,\\dots\\}$, so $a,b,c,\\dots$ represent a single symbol in the underlying alphabet.)</p></li>\n<li><p>Each of $a^\\eta,b^\\eta,c^\\eta,\\dots$ is a word-expression, if $\\eta$ is a length-variable.</p></li>\n<li><p>The concatenation of word-expressions is a word-expression.</p></li>\n<li><p>Each of $m,n,p,q,\\dots$ is a length-variable.  (These represent variables that can take on any natural number.)</p></li>\n<li><p>Each of $|x|,|y|,|z|,\\dots$ is a length-variable.  (These represent the length of a corresponding word.)</p></li>\n</ul>\n\n<p>My goal is something rich enough to capture many of the examples we see in textbook exercises.  (Feel free to suggest modifications to this formalization if it makes the equality-testing problem easier while still remaining expressive enough to capture many of the examples we see in textbooks.)</p>\n\n<hr>\n\n<p><strong>Some easier cases.</strong> If the original problem is too hard, here are some sub-cases that would still be interesting:</p>\n\n<ul>\n<li><p>If $L_1,L_2$ are two languages specified in "algebraic" form as above, and $L_1\\ne L_2$, let $d(L_1,L_2)$ denote the length of the shortest word that is an element of one of $L_1,L_2$ but not the other.  Can we upper-bound $d(L_1,L_2)$ as a function of the length of the descriptions of $L_1,L_2$?  Is it guaranteed to always be polynomial? at most singly-exponential?</p>\n\n<p>Motivation: If we could prove it is always polynomial, this might help us exhibit a witness that $L_1 \\ne L_2$.</p></li>\n<li><p>If we omit the reversal operation (we do not allow $x^r,y^r,\\dots$), does the problem become easier?</p></li>\n</ul>\n', 'ViewCount': '77', 'Title': 'Test whether two languages are equal, when give in algebraic form', 'LastActivityDate': '2013-11-16T03:08:21.470', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><formal-languages><regular-languages><decision-problem>', 'CreationDate': '2013-11-16T03:08:21.470', 'Id': '18062''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to create a PDA for $\\{xy \\mid |x|=|y| \\text{ and } x \\ne y\\}$ over the alphabet $\\Sigma = \\{a, b\\}$. But I don't know how the PDA will know if the two strings $x$ and $y$ are not equal. Please help me create this PDA step by step.</p>\n", 'ViewCount': '67', 'ClosedDate': '2013-11-18T21:20:33.997', 'Title': u'Creating PDA for {xy such that |x|=|y| and x \u2260 y}', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-18T20:07:00.127', 'LastEditDate': '2013-11-18T13:11:33.327', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11417', 'Tags': '<formal-languages><pushdown-automata>', 'CreationDate': '2013-11-16T10:53:57.390', 'Id': '18069''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '186', 'Title': 'CFG for $\\{a^ib^jc^k \\mid i \\neq j+k\\}$', 'LastEditDate': '2013-11-18T21:33:21.273', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11155', 'FavoriteCount': '1', 'Body': "<p>I am trying to design a context-free grammar for the language $L = \\{a^ib^jc^k \\mid i\\neq j+k\\}$ over the alphabet $\\Sigma = \\{a,b,c\\}$.</p>\n\n<p>I know that I can split this up into the union of two cfg's $S_1$ and $S_2$,\n<br>where $S_1$ is the case where $\\#_a \\lt \\#_b + \\#_c$, \n<br>and $S_2$ is the case where $\\#_a \\gt \\#_b + \\#_c$.</p>\n\n<p>I keep producing the grammar that generates this language <strong>but</strong> not in the correct order, that is I am having a hard time keeping the $a$'s on the left, $b$'s in the middle, and $c$'s to the right. Is this even context free?</p>\n", 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-18T21:40:01.583', 'CommentCount': '1', 'AcceptedAnswerId': '18129', 'CreationDate': '2013-11-18T20:40:51.630', 'Id': '18126''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am wondering this statement above [the title] is true or not.</p>\n\n<p>Here is what I've already had : non-recursive means undecidable.</p>\n\n<p>I've read this Are all infinite languages undecidable?</p>\n\n<p>which says:</p>\n\n<p>If a Language is undecidable(non-recursive), there must be some strings make the TM fail to halt.SO IT MUST HAVE INFINITE OF THEM WHICH MAKE THE TM FAILS TO HALT.</p>\n\n<p>How could this prove my statement[title]? Can anyone explain it to me a bit more clearly?</p>\n\n<p>Thanks</p>\n\n<p>TM means Turing machine. And too be clear My question is : Does ALL non-recursive languages are Infinite?</p>\n", 'ViewCount': '120', 'Title': 'Prove that all non-recursive languages are infinite', 'LastActivityDate': '2013-11-20T18:37:22.500', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18205', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11506', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-11-20T18:22:01.607', 'Id': '18203''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>First I apologize if I confused therms DFA and FSM, to me it seems that is the same thing. The question is simple: Are the flowcharts (sequence, branching and jumping) equivalent to DFA resp. FSM? I am a bit confused about this. There are classes where using logical synthesis, Karunaugh maps, state encodings, flip flops etc. one is able to construct hardware consisting of logic gates and flip-flops which realizes the desired DFA. Basically all processes that runs on the computer (no matter if is written in C# or Assembler), are at the lowest level realized through logical gates, zeros and ones. So it seems that programs firstly needs to be converted (by compiler I suppose) to some form as I've described. This might imply that every problem that is solvable using C# is solvable using FSM. But this is in contradiction to Chomsky hierarchy and all this theory related stuff, which says that you cannot do the same magic with regular expressions (which are based on FSM) that you can do on Turing machine (which is equivalent of any programming language, if I am wrong correct me please). Moreover, if flowcharts (or even C#, Java ... source codes) were equivalent to FSM why we do not have all software formally verified so far? There is mathematical apparatus for FSM and related stuff, so why do not formally verify everything and ensure the correctness? What I am missing here?</p>\n", 'ViewCount': '59', 'Title': 'Flowcharts vs DFA resp FSM equivalency', 'LastActivityDate': '2013-11-20T23:19:14.123', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11513', 'Tags': '<formal-languages><turing-machines><finite-automata><computer-architecture>', 'CreationDate': '2013-11-20T23:19:14.123', 'FavoriteCount': '1', 'Id': '18210''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given the language $L_1 = \\{a^i b^j c^k \\mid i \\neq j \\vee i \\neq k\\}$, I need to determine whether it is context-free by using the pumping lemma. I must do the same for the complement of this language.</p>\n\n<p>I started off by breaking $L_1$ into two parts, $L_1 = L_2 \\cup L_3$, where $L_2 = \\{a^i b^j c^k \\mid i \\neq j\\}$ and $L_3 = \\{a^i b^j c^k \\mid i \\neq k\\}$, and I proved that both the languages are not context free, hence the union which is $L_1$ is also not context-free. Is this approach of mine correct? </p>\n\n<p>Also would the complement of $L_1$ be $L_1' = \\{a^i b^j c^k \\mid i = j \\wedge i = k\\}$ and break down $L_1'$ into two parts $L_2'$ and $L_3'$ and by the closed under intersection rule for context-free languages we know $L_1' = L_2' \\cap L_3'$ is not context free. </p>\n\n<p>This how I approached both the parts, and I would like to know if my approach is correct or wrong. Help would be really appreciated.</p>\n", 'ViewCount': '104', 'Title': 'Context free language and the complement of it', 'LastEditorUserId': '69', 'LastActivityDate': '2013-11-26T00:20:07.597', 'LastEditDate': '2013-11-25T22:49:06.590', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18341', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11110', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2013-11-25T22:30:27.523', 'Id': '18337''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '90', 'Title': 'Turing machine with possible transitions to the final state', 'LastEditDate': '2013-11-29T02:15:18.813', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': '<p><img src="http://i.stack.imgur.com/aRAVI.png" alt="enter image description here"></p>\n\n<p>Let\'s say we want to draw the transition graph of a Turing Machine that accepts that language L and then write the sequence of moves done by the TM when the input sequence is $w = abbcbba$ so I had some thoughts on how this could be built.</p>\n\n<p>$q0 - q1: a,a,R$</p>\n\n<p>$q1-q2: b,b,R$</p>\n\n<p>$q2 (loop): b,b,R$</p>\n\n<p>$q2-q3: c,c,R$</p>\n\n<p>$q3-q4: b,b,R$</p>\n\n<p>But then I\'m getting stuck here, I could see $b,b,R$ to the final state and then add a separate node to account for the case $m=3$, but I\'m teaching this to myself so maybe someone can step in here and get me back on track.</p>\n\n<p>EDIT:</p>\n\n<p>This might work:</p>\n\n<p><img src="http://i.stack.imgur.com/qqxDM.jpg" alt="enter image description here"></p>\n', 'ClosedDate': '2014-01-23T18:49:36.310', 'Tags': '<formal-languages><turing-machines><automata>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-11-29T02:15:18.813', 'CommentCount': '1', 'AcceptedAnswerId': '18456', 'CreationDate': '2013-11-28T19:46:19.570', 'Id': '18452''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How would I find an LL(1) grammar for the language:</p>\n\n<blockquote>\n  <p>L=a<sup>m</sup> b<sup>n</sup> c<sup>m+n</sup></p>\n</blockquote>\n\n<p>Where m and n are elements of the naturals? My context-free grammar is:</p>\n\n<blockquote>\n  <p>S &rarr; aSc | B</p>\n  \n  <p>B &rarr; bBc | A</p>\n  \n  <p>A &rarr; bc</p>\n</blockquote>\n\n<p>Is my grammar LL(1) parsable?</p>\n', 'ViewCount': '99', 'ClosedDate': '2014-02-02T11:19:15.587', 'Title': 'Finding an LL(1) grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T16:06:25.357', 'LastEditDate': '2013-12-02T12:09:50.653', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11752', 'Tags': '<formal-languages><context-free><formal-grammars><parsers>', 'CreationDate': '2013-12-02T03:37:45.623', 'Id': '18523''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There are <a href="http://cs.stackexchange.com/q/265/755">many techniques</a> to prove that a language is <em>not</em> context-free, but how do I prove that a language <em>is</em> context-free?</p>\n\n<p>What techniques are there to prove this?  Obviously, one way is to exhibit a context-free grammar for the language.  Are there any systematic techniques to find a context-free grammar for a given language?</p>\n\n<p>For regular languages, there <em>are</em> <a href="http://cs.stackexchange.com/q/1331/755">systematic ways</a> to derive a regular grammar / finite-state automaton: for instance, the Myhill-Nerode theorem provides one way.  Is there any corresponding technique for context-free languages?</p>\n\n<hr>\n\n<p>My motivation here is to (hopefully) build up a reference question that contains a list of techniques that are often helpful, when trying to prove that a given language is context-free.  Since we have many questions here that are special cases of this, it would be nice if we could document the general approach or general techniques that one can use when facing this sort of problem.</p>\n', 'ViewCount': '156', 'Title': 'How to prove that a language is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T19:22:09.170', 'LastEditDate': '2014-01-17T22:55:11.557', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-12-02T04:18:45.460', 'FavoriteCount': '1', 'Id': '18524''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently learning about Rice\'s Theorem, and I\'m having a bit of trouble understanding when I can and cannot use it. It\'s my understanding that Rice\'s Theorem can only be applied to something if it is a property of the language (i.e. $L(M)$) and not if it is a property of the machine (i.e $M$). Is this correct, or am I missing some detail?</p>\n\n<p>If the above is the case, then am I correct in thinking that I can apply Rice\'s Theorem to, say "$L(M)$ is infinite" or "$L(M)$ is not context-free", but not something like "$M$ is the only machine accepting $L(M)$"?</p>\n', 'ViewCount': '44', 'ClosedDate': '2013-12-02T16:55:33.870', 'Title': "Using Rice's Theorem Correctly", 'LastActivityDate': '2013-12-02T05:09:35.690', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11597', 'Tags': '<formal-languages><turing-machines><undecidability>', 'CreationDate': '2013-12-02T05:09:35.690', 'Id': '18526''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having trouble understanding some language notation, primarily what rules I can take away from it. The language is as follows:</p>\n\n<p>$\\qquad L = \\{a^n b^m b^p c^p b^{n-m} \\mid n &gt; 0, m &lt; n, p &gt; 2\\}$</p>\n\n<p>My goal is to create a context free grammar from this, but I can't get my ahead around the rules in place here. In plain English, it's clear that any string for this language must have a positive number of a's in it, but what is going on with the multiple b's? Do I take this as the string must be in some form like so:  </p>\n\n<p>$\\qquad aaa-b-bbb-ccc-bb$  (n=3, m=1, p=3)</p>\n\n<p>where the bunches of b's are just distinct sequences? Or is there something else I should be doing in order to satisfy this? </p>\n", 'ViewCount': '49', 'Title': 'Interpreting a Language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-03T16:54:26.753', 'LastEditDate': '2013-12-03T08:55:48.557', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11775', 'Tags': '<formal-languages>', 'CreationDate': '2013-12-03T02:27:34.353', 'Id': '18556''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '134', 'Title': 'Partition an infinite regular language into 2 disjoint infinite regular languages', 'LastEditDate': '2013-12-05T18:01:50.127', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11713', 'FavoriteCount': '1', 'Body': "<p>Given any infinite regular language $L$, how can I prove that $L$ can be partitioned into 2 disjoint infinite regular languages $L_1, L_2$? That is: $L_1 \\cup L_2 = L$, $L_1 \\cap L_2 = \\varnothing$, and $L_1$ and $L_2$ are both both infinite and regular.</p>\n\n<p>So far, I thought of:</p>\n\n<ol>\n<li><p>using the pumping lemma such that \n$$ \\begin{gather}\n  L_1 &amp;= \\{ xy^nz \\mid \\text{\\(n\\) is even} \\} \\\\\n  L_2 &amp;= \\{ xy^mz \\mid \\text{\\(m\\) is odd} \\} \\\\\n\\end{gather} $$\nbut couldn't prove that they are dijoint or covering $L$ completely. </p></li>\n<li><p>Using the regular language partitions $\\Sigma^*$ into dijoint equivalence classes, but I haven't figured out how to determine if an equivalence class is regular or infinite.</p></li>\n</ol>\n", 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-05T18:01:50.127', 'CommentCount': '0', 'AcceptedAnswerId': '18613', 'CreationDate': '2013-12-04T14:40:00.883', 'Id': '18610''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given the following:</p>\n\n<p>$$\\{ w\\#x \\mid w^R \\text{ is a substring of $x$, with $x$ and $w \\in \\Sigma^*$} \\}$$</p>\n\n<p>What does $w\\#x$ denote?</p>\n', 'ViewCount': '115', 'Title': 'What does the symbol # mean when it comes to languages', 'LastEditorUserId': '9612', 'LastActivityDate': '2013-12-07T10:37:19.277', 'LastEditDate': '2013-12-07T10:37:19.277', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18631', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-languages><terminology><context-free><automata>', 'CreationDate': '2013-12-05T06:38:57.007', 'Id': '18630''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given $A,B$ regular languages with $A \\prec B$. Prove the existence of $C\\in L_{\\text{regular}}$ so that: $A \\prec C \\prec B$.</p>\n\n<p>Here, $A\\prec B$ stands for: $A\\subset B $ and $B\\setminus A $ is infinite.  </p>\n\n<p>I tried to go for: $C=\\overline{B} \\cup A$ and some other options but it didn't work out.</p>\n", 'ViewCount': '93', 'Title': 'Prove the existence of regular $C$ so that: $A \\prec C \\prec B $', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-12-06T00:27:44.990', 'LastEditDate': '2013-12-06T00:27:44.990', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18654', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11841', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-12-05T15:55:23.273', 'Id': '18646''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm learning about Logic; I've devised a few sentences to convert into logic to test myself and see if i've grasped the topic. It would be of great help if you could tell me if i'm doing it right!</p>\n\n<ul>\n<li>Every student who likes chocolate is smart:</li>\n</ul>\n\n<p>(Every student) (who likes chocolate) (is smart)</p>\n\n<p>\u2200x \u2208D, [Like (Student (x), chocolate) \u2192 Smart(x)]</p>\n\n<ul>\n<li>There exists a barber that shaves all men who do not shave themselves.</li>\n</ul>\n\n<p>(There exists a barber) (that shaves all men) (if and only if they do not shave themselves)</p>\n\n<p>\u2203x \u2208D, [Shaves (x, \u2200y) \u2192 Shave (y, y)]</p>\n\n<p>Thank you</p>\n", 'ViewCount': '60', 'Title': 'Converting English into Logic', 'LastActivityDate': '2013-12-05T23:34:42.517', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18667', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11856', 'Tags': '<formal-languages><logic>', 'CreationDate': '2013-12-05T21:55:26.813', 'Id': '18664''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m a little confused by <a href="http://en.wikipedia.org/wiki/Regular_Language" rel="nofollow">Wikipedia\'s definition of a regular language</a>:</p>\n\n<blockquote>\n  <p>The collection of regular languages over an alphabet $\\Sigma$ is defined recursively as follows:</p>\n  \n  <ul>\n  <li>The empty language $\\emptyset$ is a regular language.</li>\n  <li>For each $a \\in \\Sigma$ ($a$ belongs to $\\Sigma$), the singleton language ${a}$ is a regular language.</li>\n  <li>If $A$ and $B$ are regular languages, then $A \\cup B$ (union), $A \\cdot B$ (concatenation), and $A^\\ast$ (Kleene star) are regular languages.</li>\n  <li>No other languages over $\\Sigma$ are regular.</li>\n  </ul>\n</blockquote>\n\n<p>This seems defines a regular language as any set that contains a finite number of unique elements, though the set can be countably infinite (it\'s worth noting that the article doesn\'t explicitly state that $\\left\\vert{\\Sigma}\\right\\vert$ is finite in the definition), i.e., a regular language is any set $S$</p>\n\n<p>$$\n\\left\\vert{S}\\right\\vert \\le \\left\\vert{\\infty}\\right\\vert, {S} \\in \\Sigma \\\\  \n\\left\\vert{\\Sigma}\\right\\vert \\lt \\left\\vert{\\infty}\\right\\vert\n$$</p>\n\n<p>I think this is correct because the union, concatenation or Kleene star of a singleton that is part of a finite set or the empty set must be also part of that set, even when operated on recursively. </p>\n\n<p>It\'s been a fair while since I did any maths, and even longer since I\'ve touched set theory. Have I completely misread Wikipedia\'s definition? If so, how? If I haven\'t how is a regular language different from my definition?</p>\n', 'ViewCount': '92', 'Title': 'Definition of a regular language', 'LastActivityDate': '2013-12-08T21:31:20.787', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11934', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-12-08T20:31:03.053', 'Id': '18758''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I've been trying for quite some extended time to find a construction so that I can formally demonstrate that a deterministic PDA is closed under complementation. However, it happens that every idea I got has something that at the end does not fit. Could you give me a hand?</p>\n\n<p>The main problem happens with the <strong>\u03b5-moves</strong>. A PDA could finish reading its input in a non-final (rejecting state) but can still move to a final (accepting) state through an <strong>\u03b5-move</strong> and end up accepting the string. This means that just adding a dead state and complementing the states does not work. I already solved the problem of possible infinite sequences of <strong>\u03b5-moves</strong>, so that is not a main part of my question.</p>\n\n<p><strong>EDIT:</strong> As far as I understand, if the DPDA reaches <em>end of input</em> and is in an accepting state and moves to a rejecting state through an <strong>\u03b5-move</strong> it would still accept it (as it reached a final state with no input symbol left to read).</p>\n\n<p>Please let me know if I can be more clear.</p>\n", 'ViewCount': '148', 'Title': 'Demonstrate that DPDA is closed under complement by construction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-28T10:53:54.807', 'LastEditDate': '2014-03-26T08:26:09.787', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2013-12-10T00:34:01.010', 'Id': '18800''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Others have studied the following question: given a set of words $w_1,w_2,\\dots \\in \\Sigma^*$, find a regular grammar (or a context-free grammar) that generates all of those words, is "natural" in some sense, and is as small as possible.  In the special case where we have a single word $w \\in \\Sigma^*$, if the grammar generates exactly the word $w$, we can think of this as a compression algorithm that compresses the word $w$ to the grammar produced by this inference algorithm.  Of course, each word is a one-dimensional sequence of symbols.</p>\n\n<p>Now consider a two-dimensional array of symbols, say an array $A[1\\ldots m, 1\\ldots n]$ where each $A[i,j] \\in \\Sigma$.  Is there any corresponding algorithm that could be used to find a grammar of some sort that generates $A$?  Could this be used as a compression algorithm for compressing images, i.e., one that compresses a two-dimensional image to its corresponding grammar?</p>\n\n<p>I\'m not even sure what kind of grammar would be suitable.  Is there an analog of regular or context-free grammars that generates a two-dimensional output instead of a one-dimensional output?  I\'ve done some searching, and haven\'t found anything obvious.</p>\n\n<ul>\n<li><p>Of course we could linearize the image, by concatenating the rows of the array, to get a one-dimensional sequence, and then apply any of the above techniques -- but this does not preserve locality.  In other words, elements that are vertically adjacent will no longer be near each other after this transformation.  So this transformation does not seem useful.</p></li>\n<li><p>Perhaps we could build a quad-tree over the array and then consider tree automata over that quad-tree?  Is there a grammar inference algorithm for such tree automata over quad-trees?</p></li>\n<li><p>Alternatively, it seems like there might be a natural extension of context-free grammars to two-dimensional output: just make the right-hand side of each rule be a two-dimensional array of terminals and non-terminals of arbitrary size, and then apply the obvious generation algorithm.  Do such grammars have a standard name?  Is there a grammar inference algorithm for such grammars?</p></li>\n</ul>\n', 'ViewCount': '42', 'Title': '"Grammar inference" for 2-D images', 'LastActivityDate': '2014-04-08T09:34:06.440', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><formal-grammars><tree-grammars>', 'CreationDate': '2013-12-10T07:46:27.600', 'Id': '18823''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $L$ be a given Context Free Language over the alphabet $\\{a,b\\}$. Now consider $$L_1=L-\\{xyx\\ |\\ x,y\\in\\{a,b\\}^*\\}$$\nI know that $\\{xyx\\ |\\ x,y\\in\\{a,b\\}^*\\}$ is not Context Free (by using pumping lemma).</p>\n\n<p>Based on that can we affirmatively say that $L_1$ will <strong>NEVER</strong> be Context Free (can't use closure property here, as $\\{xyx\\ |\\ x,y\\in\\{a,b\\}^*\\}$ is neither <em>CFL</em> not <em>Regular</em>)?</p>\n\n<p>Or shall $L_1$ ALWAYS be Context Free ?</p>\n", 'ViewCount': '51', 'Title': 'Relative complement of a Non CFL to CFL', 'LastActivityDate': '2013-12-10T19:10:17.103', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18836', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11949', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-12-10T13:57:09.853', 'Id': '18831''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am having a bit of difficulty understanding the order of precedence in boolean logic for the OR operation. Take this example:</p>\n\n<p>Assume the following regular expression:</p>\n\n<pre><code>((a(b+))+(a|c))|a|c\n</code></pre>\n\n<p>Why is it that this accepts the strings:</p>\n\n<pre><code>a\nc\nabba\nabbabbba\nabbabbc\n</code></pre>\n\n<p>etc</p>\n\n<p>But when I flip it around and use the regular expression</p>\n\n<pre><code>a|c|((a(b+))+(a|c))\n</code></pre>\n\n<p>I can now only ever get the following strings when I check it with a RegExp tester:</p>\n\n<pre><code>a\nc\n</code></pre>\n\n<p>I know it is to do with the order of precedence but I don't understand why, please could somebody enlighten me?</p>\n", 'ViewCount': '81', 'Title': 'Why does a regular expression only accept all my required strings when the concatenation is the first of the OR operations?', 'LastActivityDate': '2013-12-11T05:47:49.150', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '18864', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12006', 'Tags': '<formal-languages><automata><regular-expressions>', 'CreationDate': '2013-12-11T02:11:39.407', 'FavoriteCount': '1', 'Id': '18858''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a non-deterministic push down automata (we define "accept" here using accept states), if we assume any operation popping from the stack and checking if the top of the stack contains some symbol can succeed (i.e. "getting rid" of the stack), we get a non-deterministic finite automata.</p>\n\n<p>If we convert two such PDAs, whose languages recognized are the same, and assuming <em>all states are reachable</em>, to NFAs in this fashion, are the languages recognized by the NFAs still the same?</p>\n\n<hr>\n\n<p>Here\'s a simple example.  Consider the language $\\{a^n b^n : n \\in \\mathbb{N}\\}$.  Here\'s one simple PDA for it.  The PDA has two states, $q_0,q_1$.  When it is in state $q_0$ and it reads the symbol $a$ on the input tape, it pushes $A$ on the stack and remains in state $q_0$.  When it reads the symbol $b$ on the input table and the stack is non-empty, it pops whatever is on the stack and moves to state $q_1$.  The PDA accepts if the stack is empty at the end of the input string.  If we convert this PDA to a NFA, we get a NFA with two states $q_0,q_1$ and transitions $q_0 \\stackrel{a}{\\to} q_0$, $q_0 \\stackrel{b}{\\to} q_1$, $q_1 \\stackrel{b}{\\to} q_1$.  This NFA accepts the language $a^* b^*$.  There are other ways to build a PDA for the language $\\{a^n b^n : n \\in \\mathbb{N}\\}$; if we apply the same conversion to them, does the corresponding NFA always accept the language $a^* b^*$?</p>\n', 'ViewCount': '86', 'Title': 'Relaxing the stack in a push down automata', 'LastEditorUserId': '9173', 'LastActivityDate': '2013-12-14T11:26:22.807', 'LastEditDate': '2013-12-14T06:50:09.547', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '18970', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9173', 'Tags': '<formal-languages><pushdown-automata><nondeterminism>', 'CreationDate': '2013-12-13T16:15:38.797', 'Id': '18955''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to derive a context free grammar for the following language on alphabet $\\Sigma=\\{a,b\\}$:</p>\n\n<p>$\\qquad\\displaystyle \\{ xax'yby'z \\mid x,y,z\\in\\Sigma ^*, |x|=|x'|, |y|=|y'|, |z|=|x|+|y|\\}$</p>\n\n<p>I am convinced that this language is context-free because this is part of my proof to a theorem given in textbook, but haven't yet seen a context-free grammar for it.</p>\n", 'ViewCount': '80', 'Title': 'Looking for a contex-free grammar for the following language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-16T12:51:50.140', 'LastEditDate': '2013-12-16T12:51:50.140', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11589', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2013-12-16T10:33:03.267', 'Id': '19035''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>Given a standard grammar describing the boolean expression with <code>AND</code>, <code>OR</code> and <code>NOT</code> operators:</p>\n\n<pre><code>exp\u2192term {OR term};\nterm\u2192factor {AND factor};\nfactor\u2192id;\nfactor\u2192NOT factor;\nfactor\u2192LPAREN exp RPAREN;\n</code></pre>\n\n<p>I would like to translate the strings of the corresponding language in the Product Of Sums form:</p>\n\n<pre><code>P\u2192S|S AND P\nS\u2192LPAREN Ls RPAREN | NOT LPAREN Ls RPAREN\nLs\u2192I|I OR Ls\nI\u2192id|Not id\n</code></pre>\n\n<p>I would like to associate each of the former rule to a rule of the latter oen, so as to easly implement it with <code>Bison</code>/<code>Yacc</code>.</p>\n\n<p>I'm not constrained to those two grammars, I can rewrite them as long as the express the same languages.</p>\n\n<p>Could you suggest me how to preoceed?</p>\n", 'ViewCount': '35', 'Title': 'Write grammars rule to translate general boolean expressions in Prodocut Of Sums', 'LastActivityDate': '2013-12-17T12:36:54.670', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1228', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-12-17T12:36:54.670', 'Id': '19063''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to describe a TM that decides the language $A=\\{0^{5^n} \\mid n\\ge0\\}$.<br>\n<br>I know how to do this for $0^{2^n}$, marking off every other 0 in each pass. In my case would it work marking off every fifth 0 in each pass? It would reject if there are an even number of 0s. Every pass reduces the number of 0's by a fifth until there are no more 0s.</p>\n", 'ViewCount': '135', 'Title': 'TM for $0^{5^n}$. Describing a turing machine that decides the language consisting of all strings of zeroes whose length is a power of 5', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-03-23T18:51:24.853', 'LastEditDate': '2013-12-20T07:20:36.557', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-12-20T03:39:23.743', 'Id': '19139''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Define the language $L$ as $L = \\{a, b\\}^* - \\{ww\\mid w \\in \\{a, b\\}^*\\}$.  In other words, $L$ contains the words that cannot be expressed as some word repeated twice.  Is $L$ context-free or not?</p>\n\n<p>I've tried to intersect $L$ with $a^*b^*a^*b^*$, but I still can't prove anything. I also looked at Parikh's theorem, but it doesn't help.</p>\n", 'ViewCount': '220', 'Title': 'Is $\\{a, b\\}^* \\setminus \\{ww \\mid w \\in \\{a,b\\}^*\\}$ context-free?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-12-23T09:37:00.473', 'LastEditDate': '2013-12-23T09:37:00.473', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12256', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-12-20T10:32:51.057', 'Id': '19151''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have the following CFG which I suspect cannot be rewritten to one which is LL(1):</p>\n\n<p>$S \\rightarrow \\epsilon\\ |\\ aSbS\\ |\\ bSaS\\ |\\ cSdS\\ |\\ dScS$</p>\n\n<p>I\'ve thought about it for a while, and can\'t seem to make any progress. I know that <a href="http://stackoverflow.com/questions/15161636/making-a-grammar-ll1">the simpler grammar here</a> can be rewritten into LL(1), but it seems like there is something different about the above grammar which prevents a rewriting in a similar style. Is it possible? If not, is there an easy way to prove that this is the case?</p>\n', 'ViewCount': '109', 'Title': 'Can this CFG be written into an equivalent LL(1) grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-06T10:56:54.060', 'LastEditDate': '2014-01-06T09:24:40.650', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12290', 'Tags': '<formal-languages><context-free><formal-grammars><parsing>', 'CreationDate': '2013-12-21T19:21:26.410', 'Id': '19178''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $L = \\{ww \\mid w \\in \\{a,b\\}^*\\}$.  In other words, each word of $L$ is some string repeated twice (some string concatenated with itself).</p>\n\n<p>Is the language $L$ context-free?</p>\n', 'ViewCount': '128', 'ClosedDate': '2014-03-19T08:21:47.193', 'Title': 'Is L= $\\{ww \\mid w \\in \\{a,b\\}^*\\}$ context-free?', 'LastEditorUserId': '12863', 'LastActivityDate': '2014-03-19T06:26:02.637', 'LastEditDate': '2014-03-19T06:26:02.637', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2013-12-23T19:38:09.190', 'Id': '19218''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '373', 'Title': 'Examples of context-free languages with a non-context-free complements', 'LastEditDate': '2013-12-29T17:22:50.333', 'AnswerCount': '2', 'Score': '4', 'OwnerDisplayName': 'K. Stm.', 'PostTypeId': '1', 'OwnerUserId': '10872', 'Body': '<p>Context-free languages are not closed under complementation. In the lectures we have been given the same argument as <a href="https://en.wikipedia.org/wiki/Context_free_language#Nonclosure_under_intersection_and_complement" rel="nofollow">here on Wikipedia</a>. But this only shows that one of the three languages $A$, $B$, and $\\overline A \\cup \\overline B$ is a context-free language with a non-context-free complement, not for which one of these this is true. So what is it?</p>\n\n<p>Also, is there a minimal and elegant example of a context-free language witch a non-context-free complement, maybe over a binary alphabet?</p>\n', 'Tags': '<formal-languages><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-29T17:22:50.333', 'CommentCount': '0', 'AcceptedAnswerId': '19267', 'CreationDate': '2013-12-04T13:58:59.267', 'Id': '19266''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>can someone give me the step-by-step approach to obtaining a context free grammar for a language? example: obtain a grammar to generate string consisting of at least 2 a's my answer was this: S-->aA A-->aB B-->aB|$(epsilon) the text book answer : S-->aa S-->aS can there be more than one answer? obtain a grammar to generate string consisting of at least 2 a's please reply asap as i have a test in 2 days!!</p>\n", 'ViewCount': '14', 'ClosedDate': '2013-12-26T09:38:53.160', 'Title': 'step-by-step approach context free grammar', 'LastActivityDate': '2013-12-25T16:08:49.773', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12371', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-12-25T16:08:49.773', 'Id': '19279''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><strong>Background:</strong><br>\nIn the book of <a href="http://is.ifmo.ru/books/_principles_of_model_checking.pdf" rel="nofollow">Principle of Model Checking (Section 9.2, Page 701)</a>, the semantics of the <code>until</code> modality is defined over some time-divergent path $\\pi \\in s_0 \\Rightarrow^{d_0} s_1 \\Rightarrow^{d_1} \\cdots \\Rightarrow^{d_{i-1}} s_i \\Rightarrow^{d_i} \\cdots$ as follows:</p>\n\n<p>(We can skip the formal definition at your first reading.)<br>\n$\\pi \\models \\Phi \\cup^{J} \\Psi \\iff$<br>\n$\\exists i \\ge 0. s_i + d \\models \\Psi \\textrm{ for some } d \\in [0,d_i] \\textrm{ with } \\sum_{k=0}^{i-1}d_k + d \\in J \\textrm{ and }$\n$\\forall j \\le i. s_j + d\' \\models \\Phi \\lor \\Psi \\textrm{ for any } d\' \\in [0,d_j] \\textrm{ with } \\sum_{k=0}^{j-1} d_k + d\' \\le \\sum_{k=0}^{i-1} d_k + d$.</p>\n\n<blockquote>\n  <p>Intuitively, time-divergent path $\\pi \\in s_0 \\Rightarrow^{d_0} s_1 \\Rightarrow^{d_1} \\cdots \\Rightarrow^{d_{i-1}} s_i \\Rightarrow^{d_i} \\cdots$ satisfies $\\Phi \\cup^{J} \\Psi$ whenever at some time point in $J$, a state is reached satisfying $\\Psi$ and at all previous time instants <strong>$\\Phi \\lor \\Psi$</strong> holds.</p>\n</blockquote>\n\n<p>However, in the book of Model Checking by E.M. Clarke (Section 16.3, Page 256), the semantics of the <code>until</code> modality is given as follows:</p>\n\n<blockquote>\n  <p>$s \\models E[\\Phi \\cup_{[a,b]} \\Psi]$ if and only if there exists a path $\\pi = s_0 s_1 s_2 \\cdots$ starting at $s = s_0$ and some $i$ such that $a \\le i \\le b$ and $s_i \\models \\Psi$ and for all $j &lt; i, s_j \\models \\Phi$.</p>\n</blockquote>\n\n<p>As indicated, the second definition is stricter than the first one in that it does not allow the case of $\\lnot \\Phi \\land \\Psi$ before reaching a state satisfying $\\Psi$.</p>\n\n<p><strong>Problem:</strong>    </p>\n\n<blockquote>\n  <ol>\n  <li>Why are there two different <code>until</code> ($\\cup$) semantics in Timed Computation Tree Logic (TCTL)?</li>\n  <li>Which one is more official?</li>\n  </ol>\n</blockquote>\n', 'ViewCount': '45', 'Title': 'Why are there two different `until` ($\\cup$) semantics in Timed Computation Tree Logic?', 'LastActivityDate': '2013-12-29T07:05:45.310', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<formal-languages><formal-methods><model-checking>', 'CreationDate': '2013-12-28T09:23:35.717', 'Id': '19338''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am working on CFG grammars, LL grammars in particular and I encountered the following theorem in the slides of presentations written by my professor:</p>\n\n<blockquote>\n  <p>A CFG grammar cannot be left-factored if all elements in the FIRST-set of one factorizable rule belong to the FIRST-set of the alternative rule. </p>\n</blockquote>\n\n<p>Mathematically speaking:</p>\n\n<p>$$\nA \\rightarrow \\alpha\\beta_1 | \\alpha\\beta_2 , \\forall x \\in \\text{FIRST}(\\alpha\\beta_1)\n\\wedge x \\in \\text{FIRST}(\\alpha\\beta_2) \\implies \\text{Cannot left-factorize}\n$$</p>\n\n<p>Is it correct? I think it is not!</p>\n\n<p>Consider grammar rules $A \\rightarrow aB | a C$ This thing can be left-factorized in: $A \\rightarrow aD; D \\rightarrow B|C$. But considering the theorem such a grammar is not supposed to be left-factorizable because $\\text{FIRST}(aB) =\\text{FIRST}(aC) = {a}$.</p>\n\n<p>Which one is the correct version of this theorem? Thankyou</p>\n', 'ViewCount': '32', 'Title': 'Is this theorem about left-factored grammars correct?', 'LastActivityDate': '2013-12-31T18:41:05.803', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12499', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-12-31T18:41:05.803', 'Id': '19417''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>As I have studied, deciding regularity of context-free languages is undecidable.</p>\n\n<p>However, we can test for regularity using the Myhill\u2013Nerode theorem which provides a necessary and sufficient condition. So the problem should be decidable.</p>\n\n<p>Where is my mistake?</p>\n', 'ViewCount': '151', 'Title': 'Why is deciding regularity of a context-free language undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-05T17:18:35.267', 'LastEditDate': '2014-01-04T18:39:42.627', 'AnswerCount': '1', 'CommentCount': '14', 'AcceptedAnswerId': '19500', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12569', 'Tags': '<formal-languages><computability><regular-languages><undecidability>', 'CreationDate': '2014-01-03T12:37:01.957', 'Id': '19482''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The classic example of a context-free grammar is $a^nb^n$. That is, $n$ occurrences of $a$ followed by an equal number of occurrences of $b$.</p>\n\n<p>Do such forms occur in the real world? Can you provide an example of a real-world case where there must be $n$ occurrences of something followed an equal number of occurrences of something else?</p>\n\n<p>Let me give an example: if I run an on-line store, then for each purchase made to my store, there must be a corresponding delivery of the purchased item. That might be modeled as $n$ purchases followed by $n$ deliveries:</p>\n\n<blockquote>\n  <p>purchase purchase purchase delivery delivery delivery</p>\n</blockquote>\n\n<p>However, that is not a good data model since each delivery should legitimately be paired to a purchase:</p>\n\n<blockquote>\n  <p>purchase delivery purchase delivery purchase delivery</p>\n</blockquote>\n\n<p>So I am left wondering if there are <em>any</em> real-world examples where data would be (legitimately) modeled as a sequence of $n$ items of one type followed by $n$ items of another type. Can you provide a real-world example please?</p>\n\n<p>Hendrik Jan provided this good example (see it in the comments below): <em>This weekend I visited my mother. Three flights up, and three flights down when I left.</em> </p>\n\n<p>Neat example! Can you think of others?</p>\n\n<p>A colleague just informed me of another example. In the KML specification it says that a &lt;Track> element must contain N &lt;when> elements followed by N &lt;gx:Coord> elements:</p>\n\n<p><a href="https://developers.google.com/kml/documentation/kmlreference#gxtrack" rel="nofollow">https://developers.google.com/kml/documentation/kmlreference#gxtrack</a></p>\n\n<p>Another excellent example. What are other examples?</p>\n\n<p>Another colleague sent me an article about columnar databases. It is often more efficient to store data in columns rather than rows. For example, we may have a column of person\'s ages followed by a column of person\'s heights. Or, a list of N integers (ages) followed by a list of N decimals (heights). This enables efficient calculation of sums or averages. Here\'s the article:</p>\n\n<p><a href="http://www.postgresql.org/message-id/52C59858.9090500@garret.ru" rel="nofollow">http://www.postgresql.org/message-id/52C59858.9090500@garret.ru</a></p>\n\n<p><strong>More examples please! I would like for us to create a nice collection of compelling examples.</strong></p>\n', 'ViewCount': '306', 'Title': 'Is $a^n b^n$ an artificial language or does it occur in the real world?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-06T10:16:16.683', 'LastEditDate': '2014-01-06T10:16:16.683', 'AnswerCount': '2', 'CommentCount': '8', 'OwnerUserId': '9907', 'Score': '4', 'PostTypeId': '1', 'CommunityOwnedDate': '2014-01-06T10:16:16.683', 'Tags': '<formal-languages><context-free><modelling>', 'CreationDate': '2014-01-03T13:12:13.693', 'Id': '19485''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>The following array occupies 10000 slots in memory:</p>\n\n<pre><code>a = [0,1,2,3,4,5,6,7,8,9,10,...,10000]\n</code></pre>\n\n<p>But one could easily represent the same array as:</p>\n\n<pre><code>a = {len:10000, get: \u03bb idx -&gt; idx}\n</code></pre>\n\n<p>Which is much more compact. Similarly, there are several arrays that can be represented compactly:</p>\n\n<pre><code>a = {a:1000, get: \u03bb idx -&gt; idx * 2}\nIs a description for [0,2,4,6,8,10,...,2000]\n\na = {a:1000, get \u03bb idx -&gt; idx ^ 2}\nIs a description for [0,1,2,4,9,...1000000]\n\nAnd so on...\n</code></pre>\n\n<p>Providing so many arrays can be represented in much shorter ways than storing each element on memory, I ask:</p>\n\n<ol>\n<li>Is there a name for this phenomena?</li>\n<li>Is there a way to find the minimal representation for a specific array?</li>\n<li>Considering this probably depends on the language of description (in this case, I used an imaginary programming language with functions, objects and math operators). Is there a specific language that is optimal for finding that kind of minimal description for objects?</li>\n</ol>\n', 'ViewCount': '91', 'Title': 'How to find the minimal description for an array?', 'LastActivityDate': '2014-01-28T15:05:22.407', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11547', 'Tags': '<algorithms><complexity-theory><formal-languages><programming-languages><data-compression>', 'CreationDate': '2014-01-04T23:53:15.990', 'Id': '19501''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>In the sense of a string distinct from a null reference string, what is the importance of an empty string in CS (and specially in formal languages)? </p>\n\n<p>Why do you need a separate concept, that of 'empty string', which even has it's own Greek letter (\u03b5)?</p>\n\n<p>Couldn't just an EOL character replace it?</p>\n", 'ViewCount': '302', 'Title': 'Importance of the empty string', 'LastActivityDate': '2014-01-09T22:40:24.013', 'AnswerCount': '5', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10637', 'Tags': '<formal-languages><terminology>', 'CreationDate': '2014-01-05T03:56:31.100', 'FavoriteCount': '1', 'Id': '19505''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="https://github.com/gurgeh/CodeSpace">This Github repo</a> hosts a very cool project where the creator is able to, give an integer sequence, predict the most likely next values by searching the smallest/simplest programs that output that integer sequence. I was trying to approach the same idea using lambda-calculus instead of a stack-based language, but I was stuck on the enumeration of valid programs on LC\'s grammar.</p>\n\n<p>Anyway, what is the field studying that kind of idea and how can I grasp the current state-of-art?</p>\n', 'ViewCount': '94', 'Title': 'What is the field studying the search and generation of computer programs?', 'LastActivityDate': '2014-01-12T11:12:54.350', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '11547', 'Tags': '<algorithms><complexity-theory><formal-languages><computability><regular-languages>', 'CreationDate': '2014-01-09T20:37:06.207', 'Id': '19605''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In a recent test, I was asked to recognize if the below language is context  free:</p>\n\n<p>$\\qquad\\displaystyle L = \\{0^{n+m}1^{n+m}0^m \\mid n,m \\geq 0\\}$ </p>\n\n<p>I think it is context free, and can be accepted by below context free grammar, where $S$ is the start symbol and $Y$ is a non-terminal:</p>\n\n<p>$\\qquad S \\to S0 \\mid Y$</p>\n\n<p>$\\qquad Y \\to 0Y1 \\mid \\epsilon$</p>\n\n<p>However, my answer was considered wrong and that the language $L$  is not context free.</p>\n\n<p>I'm confident about my answer, but the response has got me confused. Is my understanding correct? Please let me know if I've missed something.</p>\n", 'ViewCount': '131', 'Title': 'Is this language context free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T01:19:12.187', 'LastEditDate': '2014-01-13T13:03:19.593', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19906', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-01-13T12:22:13.227', 'Id': '19690''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is an exercise I've been struggling with for a while: </p>\n\n<blockquote>\n  <p>Let $g : \\mathbb{N} \\to \\mathbb{N}$ be a total, non-decreasing function, i.e. $\\forall x &gt; y.\\ g(x) \\geq g(y)$. Is the image $I_g$ of $g$ a recursive set?</p>\n</blockquote>\n\n<p>Intuitively, I know that the image $I_{g}$ is not recursive, as $g$ is not strictly monotonic. In fact, it's because that $g$ is not strictly monotonic that $g$ could be a constant function so testing if $y \\in I_{g}$  may not finish as it could be that $\\forall x, g(x) = c$, $c$ being a constant s.t. $c &lt; y$. Then, testing if there is an $x$ s.t. $g(x) = y$ incrementing $x$ as the $g(x) &lt; y$ may go forever.  On the other hand, it could be that after a while, (for a sufficiently greater $x$) it happens that $g(x) &gt; c$ and $g(x) = y$. If it were stricly monotonic, though, then it would be recursive as I would be able to test if $y = g(x)$ incrementing $x$ until the equality is satisfied or $g(x) &gt; y$ (then $g(x)$ wouldn't get stuck in the same value because $x_1 &gt; x_2$ implies $g(x_1) &gt; g(x_2)$).</p>\n\n<p>However, I haven't been able to prove this formally. Can this intuition become part of a formal proof? Or at least could you give me some help in proving it in some other way? A hint or some outline of a proof would be great.</p>\n", 'ViewCount': '133', 'Title': 'Is the image of a total, non-decreasing function decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T07:35:02.383', 'LastEditDate': '2014-01-15T18:19:25.850', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '19752', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2014-01-15T01:15:56.527', 'Id': '19732''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given is the definition of a general problem: $\\{ \\langle M,  S\\rangle \\mid M \\text{ is a } TM, L_M \\in S\\}$. In words: Given a TM M, does M decide a language that is an element of the given set of languages S?</p>\n\n<p>I'm stuck with the following instance of that problem: $L = \\{ \\langle M \\rangle \\mid M \\text{ is a } TM, L_M \\in \\mathrm{REG}\\}$. I have found proof that it is undecidable, however I'm stuck at finding if it's recognizable (synonyms: Turing-acceptable, semidecidable, ...) or not.</p>\n\n<p>The problem in words means: Given a TM M, does the TM decide a language that is an element of REG (the set of regular languages)?</p>\n\n<p>To prove a language is not semi-decidable, I would try to prove that it's complement is semi-decidable and that the language is not decidable (which I did by reduction from the Halting-problem).</p>\n\n<p>To prove it is semi-decidable, I would prove it by reduction to the $A_{TM}$, which is semi-decidable.</p>\n\n<p>I have tried both for this problem, but I get stuck / lose my way of thinking at every try ... Some directions would be greatly appreciated!</p>\n", 'ViewCount': '134', 'Title': 'Is regularity of the language accepted by a given Turing machine a semi-decidable property?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:22.317', 'LastEditDate': '2014-01-18T20:20:22.317', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<formal-languages><computability><turing-machines><semi-decidability>', 'CreationDate': '2014-01-16T18:10:49.223', 'Id': '19769''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking at the following non-deterministic finite automata which accepts all strings that end with at least 2 bs.  I am wondering what would happen when you have the input string \'abba\' with this automata:</p>\n\n<p><img src="http://i.stack.imgur.com/hQYaA.png" alt="Automata"></p>\n\n<p>The possible computations I have so far are</p>\n\n<p>q0, q0, q0, q0, q0</p>\n\n<p>q0, q0, q1, q2, ??</p>\n\n<p>q0, q0, q0, q1, ??</p>\n\n<p>Would anyone be able to fill in the \'??\'s in this automata and be able to explain why they occur?</p>\n', 'ViewCount': '40', 'Title': 'Finite Automata Input Confusion', 'LastEditorUserId': '12879', 'LastActivityDate': '2014-01-17T18:52:39.547', 'LastEditDate': '2014-01-17T18:33:14.803', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19790', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12879', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-01-17T18:04:12.667', 'Id': '19786''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is $L=\\{a^nb^m|m\\geq2^n\\}$ a context-free language?</p>\n', 'ViewCount': '48', 'Title': 'Is the following language context-free? $L= \\{a^nb^m| m\\geq2^n\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T19:44:31.820', 'LastEditDate': '2014-01-18T19:44:31.820', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '19809', 'Score': '1', 'OwnerDisplayName': 'user12941', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2014-01-18T14:27:09.293', 'Id': '19807''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have to prove or disprove the implications in these two situations</p>\n\n<ol>\n<li>$L^* = \\emptyset$ $\\rightarrow$ $L$ is infinite</li>\n<li>$L^+ = \\emptyset$ $\\rightarrow$ $L$ is infinite</li>\n</ol>\n\n<p>Here are my thoughts.</p>\n\n<ol>\n<li><p>I would say Kleene star operation (*) is union of </p>\n\n<p>$\\qquad L^0 \\cup L^1 \\cup L^2 \\cup \\dots$</p>\n\n<p>and since $\\_^0 = \\{\\epsilon\\}$ (even $\\emptyset^ 0 = \\{\\epsilon\\}$), there is no language $L$ such that $L^* = \\emptyset$. </p>\n\n<p>How to prove finiteness/infiniteness?</p></li>\n<li><p>Only language $L$ where $L^+ = \\emptyset$ is $\\emptyset$ which is a finite language. But how to prove there is no other language that is inifinite and the argument is valid for it?</p></li>\n</ol>\n\n<hr>\n\n<p>EDIT: will it help if I rewrite the implications $A \\rightarrow B$ to $\\neg B \\rightarrow \\neg A$ ?</p>\n\n<ol>\n<li>$L$ is finite $\\rightarrow$ $L^* \\neq \\emptyset$</li>\n<li>$L$ is finite $\\rightarrow$ $L^+ \\neq \\emptyset$</li>\n</ol>\n\n<p>2) can be now interpreted as $\\emptyset^+ = \\{\\epsilon\\}$ and $\\emptyset$ is a finite language. So the implication doesn't work.</p>\n", 'ViewCount': '93', 'Title': 'If $L^*$ or $L^+$ is empty, can L be an infinite language?', 'LastEditorUserId': '6689', 'LastActivityDate': '2014-01-20T07:40:08.050', 'LastEditDate': '2014-01-18T23:14:53.983', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12947', 'Tags': '<formal-languages><finite-sets>', 'CreationDate': '2014-01-18T18:48:12.320', 'Id': '19812''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to learn automata theory on my own and I am running into an issue with the second part of the question:</p>\n\n<p>We say B is transitive if $BB\\subseteq B$ and reflexive if $\\epsilon \\in B$</p>\n\n<blockquote>\n  <p>Show that A* is a reflexive and transitive set containing A and if B is any other reflexive and transitive set containing A, then $A^*\\subseteq B$.</p>\n</blockquote>\n\n<p>I've shown that Kleene star satisfies these two conditions. I've tried partitioning B into two sets with $A = B \\cup C $ and trying a constructive proof but this hasn't led any where. I also am considering a proof by contradition but don't know where to start.</p>\n\n<p>Can you help me with a hint on how to approach this problem?</p>\n", 'ViewCount': '45', 'Title': 'Prove that A* is the smallest reflexive and transitive set containing A', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:02:21.973', 'LastEditDate': '2014-01-19T14:55:51.747', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19827', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12955', 'Tags': '<formal-languages><closure-properties>', 'CreationDate': '2014-01-19T05:26:56.603', 'Id': '19820''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've seen in previous exams that professors marked the theory as correct:</p>\n\n<blockquote>\n  <p>If $L$ is CFL and $\\overline{L}$ is CFL, then L is regular.</p>\n</blockquote>\n\n<p>I just don't see how this would work. How would we prove such a thing? I also can't come up with contradicting languages.</p>\n", 'ViewCount': '102', 'Title': 'If $L$ is CFL and $\\overline{L}$ is CFL, then is L regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:50:22.907', 'LastEditDate': '2014-01-20T08:43:52.727', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '19836', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-01-19T20:00:18.470', 'Id': '19834''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I know that the language $\\{a^m b^n | n\\neq m\\}$ satisfies the pumping lemma, but it's still not regular (I have to count the # of a's and b's). \nHow can I formally prove it?</p>\n", 'ViewCount': '99', 'ClosedDate': '2014-01-24T17:17:44.213', 'Title': 'Proof that {$a^m b^n$ | m!=n} is not regular', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-24T17:19:13.437', 'LastEditDate': '2014-01-24T17:19:13.437', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13098', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-01-24T14:09:48.383', 'Id': '19940''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm studying for my Computing languages test and there's one idea I'm having problems wrapping my head around, as far as I know for any Context Free Grammar (CFG), we can design a 2-state Pushdown Automaton (PDA). I am however a little bit confused that why this is possible.</p>\n", 'ViewCount': '165', 'Title': 'How to get 2-state PDA for CFG?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T14:37:05.360', 'LastEditDate': '2014-01-26T14:37:05.360', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13108', 'Tags': '<formal-languages><context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2014-01-24T18:53:40.317', 'FavoriteCount': '4', 'Id': '19946''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am a little bit confused on one idea regarding <a href="http://en.wikipedia.org/wiki/Indexed_language" rel="nofollow">indexed languages</a>.</p>\n\n<blockquote>\n  <p>$\\{ww \\mid w \\in \\{a,b,c\\}^* \\}$ is a linear indexed language, but </p>\n  \n  <p>$\\{www \\mid w \\in \\{a,b,c\\}^* \\}$ is not a linear indexed language.</p>\n</blockquote>\n\n<p>What is the difference? As far as I know, indexed languages can be recognized by stack automatons, but I am a little confused on this.</p>\n', 'ViewCount': '164', 'Title': 'Why is ww a linear indexed language while www is not?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-26T14:28:25.127', 'LastEditDate': '2014-01-26T14:28:25.127', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '13110', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-01-24T19:26:33.487', 'FavoriteCount': '2', 'Id': '19948''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Prove/disprove: $\\exists L \\in RE/R$ such that $L^R \\cup L \\in R$</p>\n</blockquote>\n\n<p>Where in my context, $R$ is the turing decidable, and $RE$ is the recursively enurmable. I tried to find such an $L$ but couldn't. What I know for sure is that I need a language in $RE/R$ such that $L \\cup L^R = \\Sigma^*$, or am I also wrong?</p>\n", 'ViewCount': '31', 'Title': '$L \\in RE/R$ such that $L^R \\cup L \\in R$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:25:59.020', 'LastEditDate': '2014-01-25T16:25:59.020', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19954', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<formal-languages><computability>', 'CreationDate': '2014-01-24T22:31:42.317', 'Id': '19950''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have this question about closure of a context free grammar, and if someone can check my answer and see if it makes sense, and if not, what is missing, I would be very grateful.</p>\n\n<blockquote>\n  <p>Give an counter-example to show that the following contruction fails in to proof that class of languages free of context is closed under the operation star. By A a language free of context that it is generated by the GLC G = {V,,R,S}. Add the new rule S -> SS e call the resulting grammar G\'. That grammar is expected to generate a*"</p>\n</blockquote>\n\n<p>I have only a superficial comprehension, I believe it is necessary that Rg\', the set of production rules of G\' must be equal to Rg united with {Sg\'->SgSg\'|e} or in another words Rg\': Rg U {Sg\'->SgSg\'|e}. Even if that it is correct I don\'t understand why {Sg\'->SgSg\'|e} is necessary</p>\n', 'ViewCount': '65', 'Title': 'Kleene star closure of a context free grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:26:21.240', 'LastEditDate': '2014-01-25T16:26:21.240', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13113', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-01-24T23:59:34.787', 'Id': '19955''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>When translating an NFA into an equivalent DFA, we can say that all\n  states that contain the final states of NFA, is the final state of\n  DFA.</p>\n</blockquote>\n\n<p>What should my arguments be in order to prove this?</p>\n', 'ViewCount': '76', 'Title': 'NFA to DFA final states proof', 'LastActivityDate': '2014-01-25T14:47:06.420', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13122', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-01-25T13:32:47.600', 'FavoriteCount': '1', 'Id': '19966''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Describe the language generated by the following grammar</p>\n\n<pre><code>&lt;A&gt; ::= &lt;A&gt;&lt;A&gt; '+' | &lt;A&gt;&lt;A&gt; '*' | 'a'\n</code></pre>\n</blockquote>\n\n<p>So it's not too hard to see <code>aa + a*</code> can be generated by this grammar. But I fail to see a general rule for the output. It seems like the language is any math expression containing the operands <code>{a, aa}</code> with the operator <code>*</code>, <code>+</code>. Am I correct?</p>\n", 'ViewCount': '45', 'Title': 'Is this a grammar for arithmetic expressions?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T04:57:35.713', 'LastEditDate': '2014-01-26T04:57:35.713', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13138', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-01-26T04:30:23.137', 'Id': '19981''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been watching lectures from Coderisland on YouTube about finite state machines, DFAs and NFAs, and in one discussion he talks about how to use the pumping lemma to show how a language is not regular. I don't know quite how to apply the lemma and want to understand if I'm doing it right. If I had something like:</p>\n\n<p><strong>w</strong> = {a<sup>n</sup>b<sup>k</sup>, n =/= k}</p>\n\n<p>am I correct in that I can say that:</p>\n\n<p><strong>h</strong> = {a<sup>n</sup>b<sup>n + r</sup>, r > 0} is a subset of <strong>w</strong>, and thus if I show by the lemma that <strong>h</strong> is not regular, that <strong>w</strong> must not be regular since <strong>h</strong> is a subset of <strong>w</strong>.</p>\n\n<p>The way I would show this is as follows:</p>\n\n<ol>\n<li>h = xyz</li>\n<li>|xy| &lt;= n</li>\n<li>x = a<sup>n-r</sup></li>\n<li>y = a<sup>r</sup></li>\n<li>z = b<sup>n + r</sup></li>\n<li>xyz = a<sup>n-r</sup>a<sup>r</sup>b<sup>n + r</sup></li>\n<li>xy<sup>2</sup>z = a<sup>n-r</sup>a<sup>2r</sup>b<sup>n + r</sup> = a<sup>n + r</sup>b<sup>n + r</sup></li>\n</ol>\n\n<p>Thus <strong>h</strong> cannot be regular since a<sup>n + r</sup>b<sup>n + r</sup> is not of the form {a<sup>n</sup>b<sup>n + r</sup>, r > 0}, and since <strong>h</strong> is not regular <strong>w</strong> must not be regular, since <strong>h</strong> is an element of <strong>w</strong>.</p>\n\n<p>Have I applied it correctly? I understand how to apply it for an easy language like {a<sup>n</sup>b<sup>n</sup>}, because I can apply the lemma directly to this language, but the only way I could think of for my language was to create a subset that belongs to my language, and apply the lemma to that.</p>\n\n<p>If I haven't applied it correctly, is there a way to show that my language is not regular (or regular), using another lemma, or perhaps with closure properties?</p>\n\n<p>This is a really awesome topic, even if I don't understand the pumping lemma fully, I'm excited to explore it further!</p>\n", 'ViewCount': '71', 'Title': 'Is this the correct way to use the pumping lemma?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T11:38:01.893', 'LastEditDate': '2014-01-26T11:38:01.893', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13139', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-01-26T05:49:22.287', 'Id': '19985''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $A$ be some alphabet.</p>\n\n<p>$A$ itself is a regular language.</p>\n\n<p>$E = A^*$ is regular language over $A$. $E$ is a superset of all languages over $A$, regular or otherwise, i.e $E$ contains every possible string from symbols of $A$.</p>\n\n<p>Now let $L$ be some regular language over $A$.</p>\n\n<p>What is $\\tilde{L} = L \\cdot E$ ? More specifically, how $\\tilde{L}$ and $E$ relate to each other? Are they equal? Is one subset of the other? Something else?</p>\n\n<p>Source of the confusion is the following reasoning: closure under concatenation says that $\\tilde{L}$ is a regular language and therefore $\\tilde{L} \\subseteq E$  (according to the above). On the other hand $\\tilde{L}$ seems to contain strings $E$ does not, i.e. those that are formed by concatenating non-empty string from both languages.</p>\n\n<p>Obviously this is wrong. What is going on here?</p>\n', 'ViewCount': '80', 'Title': 'Regular language concatenation with superset', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-29T18:36:17.587', 'LastEditDate': '2014-01-29T17:16:31.227', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '20075', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12837', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-01-29T16:10:18.927', 'Id': '20069''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Let $A/B$ = $\\{ w \\mid wx \\in A$ for some $x \\in B \\}$.  Show that if A is context free and B is regular, then $A/B$ is context free.</p>\n</blockquote>\n\n<p>My interpretation of this is is that we need to show that if a string $wx$ is accepted by a CFG, and we know that $x$ is accepted by a regular language (and therefore is also accepted by a context-free language), then $w$ must also be accepted by a CFG. </p>\n\n<p>My initial thought on how to solve this would be a proof by contradiction in which we assume that $A$ is context free, $B$ is regular, and then assume that $A/B$ is not context-free.  Since $A$ is context free, we can construct an equivalent PDA that accepts $A$.</p>\n\n<p>From here, my thought was to take an arbitrary $wx$ that is accepted by $A$, such that $x \\in B$.  We can then construct another PDA based on the first that only accepts $wx$.  We could then break the PDA into two pieces: one that accepts $w$ and one that accepts $x$ (with the two pieces concatenated together).  Since there then would exist a PDA that accepts just $w$, and $w$ is arbitrary insofar as $wx$ was arbitrary, $A/B$ must therefore be context-free after all (contradiction). </p>\n\n<p>Will this approach work? (Is this a good general approach?)  If so, how would I go about breaking the PDA that accepts $wx$ into chunks formally? </p>\n', 'ViewCount': '160', 'Title': 'Closure of CFL against right-quotient with regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T12:07:40.013', 'LastEditDate': '2014-01-30T11:02:17.620', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '20091', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13232', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-01-29T23:16:32.513', 'Id': '20090''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is $L = \\{ W_1W_2 \\mid W_1,W_2 \\in (a+b)^* , N_a(W_1) = N_b(W_2)\\}$ context free? Can we construct an NPDA for the language? </p>\n\n<p>There is a book here that claims $L$ is not CF (without any elaboration), but I think we can construct a NPDA that accepts the language. My guess is we can construct the language with an NPDA where after reading some $a$ and $b$ and pushing $A$ for each $a$ into the stack, makes a guess to jump to a new state and consumes the pushed $A$ with each $b$.</p>\n', 'ViewCount': '46', 'Title': "Is the language of words with as many a's in the first as b's in the second part context-free?", 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-01T13:58:44.903', 'LastEditDate': '2014-02-01T13:58:44.717', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12173', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2014-01-31T15:49:09.507', 'FavoriteCount': '1', 'Id': '20159''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was reading through Context Free Grammar, and I came across ambiguous grammar. If the language produced by CFG has more then 1 parse tree, then CFG is an ambiguous grammar. Is there any way by which I can find out or prove that the grammar is Unambiguous. In general I can test some language produced by CFG and check whether more than 1 parse tree is generated from that language, to show that grammar is ambiguous. But how do I check or prove that give CFG is unambiguous?</p>\n', 'ViewCount': '13', 'ClosedDate': '2014-02-02T13:21:21.190', 'Title': 'Unambiguous Context free Grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:21:32.037', 'LastEditDate': '2014-02-02T13:21:32.037', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13042', 'Tags': '<formal-languages><context-free><formal-grammars><ambiguity>', 'CreationDate': '2014-02-02T08:51:12.323', 'Id': '20205''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I wanted to give the following as a homework question, but my first few attempts to solve it failed, so now I'm just curios for a solution:</p>\n\n<p>For two words $x,y\\in \\Sigma^*$ and for a letter $\\sigma\\in \\Sigma$ we define the <em>glue-concatenation</em> of $x\\sigma$ and $\\sigma y$ to be $g(x\\sigma,\\sigma y)=x\\sigma y$, and for words $w,z$ such that the last letter in $w$ differs from the first letter in $z$, the glue concatenation is undefined.</p>\n\n<p>For languages $A,B\\subseteq \\Sigma^*$, we lift the glue operator such that $g(A,B)=\\{g(w\\sigma,\\sigma z):w\\sigma \\in A, \\sigma z\\in B\\}$ (note that we only consider words for which $g$ is defined).</p>\n\n<blockquote>\n  <p>The question: is it always true that $|g(A,B)|\\le |A\\cdot B|$?</p>\n</blockquote>\n\n<p>Observe that trying to prove that if $g(x,y)\\neq g(w,z)$ then $xy\\neq wz$ will fail, since for example, $g(a,abb)\\neq g(aab,b)$, but $a\\cdot abb=aab\\cdot b$.</p>\n", 'ViewCount': '65', 'Title': 'Glue-concatenation v.s concatenation', 'LastEditorUserId': '6890', 'LastActivityDate': '2014-02-03T14:40:05.947', 'LastEditDate': '2014-02-02T13:48:15.393', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '20250', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6890', 'Tags': '<formal-languages>', 'CreationDate': '2014-02-02T12:24:47.023', 'Id': '20212''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to find the language generated by the grammar:</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to SA \\mid a \\\\\n  A &amp;\\to aAa \\mid bA \\mid \\varepsilon\n\\end{align*}$</p>\n\n<p>where $\\varepsilon$ is the empty string).</p>\n\n<p>The only way is to apply the productions rules an try to recognize the language, or can be used a general approach to find it?</p>\n\n<p>For example I can say that for Arden Rule $L(S) = aL(A)^*$ (right?), and then try to find $L(A)$, but one more time I have the same problem explained before. </p>\n', 'ViewCount': '39', 'Title': 'Find the language generated by a grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:48:49.657', 'LastEditDate': '2014-02-02T13:48:49.657', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13325', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-02-02T12:58:17.527', 'Id': '20213''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I know that <code>(1 + 0)*</code> is the set of all bit strings; but isn't  <code>1* + 0*</code> the same thing?</p>\n", 'ViewCount': '797', 'Title': 'Difference between 1* + 0* and (1 + 0)*', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T13:43:32.987', 'LastEditDate': '2014-02-03T09:31:45.900', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '20236', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<formal-languages><terminology><regular-languages><regular-expressions>', 'CreationDate': '2014-02-03T03:58:32.153', 'Id': '20235''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having trouble finding the language represented by the following:</p>\n\n<p>(AA|BB)*</p>\n\n<p>Should the expression be read as... ( A (A|B) B ) *\nor... ( (AA) | (BB) )*</p>\n\n<p>If that isn't clear, should this produce something like... ABABAB or should it produce AABBAABBBBAA</p>\n\n<p>My guess is that AABBAA is part of the represented language, while AB is not.</p>\n", 'ViewCount': '45', 'Title': 'Precedence in regular expressions', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T14:27:36.157', 'LastEditDate': '2014-02-03T09:34:49.770', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '20241', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-languages><terminology><regular-expressions><precedence>', 'CreationDate': '2014-02-03T05:47:10.583', 'Id': '20239''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Language:</p>\n\n<p>$ L = a^{n+m}b^{n}c^{m} $</p>\n\n<p>As per a recent test I gave, this language is not context free.</p>\n\n<p>However, I think it is.</p>\n\n<p><strong>Corresponding Grammar:</strong></p>\n\n<p>$ X \\rightarrow aXY \\space |\\space \\epsilon $</p>\n\n<p>$ Y \\rightarrow b \\space | \\space c $</p>\n\n<p><strong>Pushdown Automata:</strong></p>\n\n<p>Keeping pushing all $a$ to the stack, until a $b$ is scanned. Keeping popping  $a$ from stack for each character scanned, until end of input.</p>\n\n<p>If, after the end of input the stack is empty accept the string. Else, go to non-accepting state.</p>\n\n<p>Please let me know if I'm thinking along the right lines or if I've missed something..</p>\n", 'ViewCount': '78', 'Title': 'Is $a^{n+m}b^{n}c^{m}$ context free?', 'LastActivityDate': '2014-02-03T16:18:44.520', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '20252', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-02-03T14:28:28.637', 'FavoriteCount': '1', 'Id': '20249''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>Given that <code>A</code> is a context free language and <code>B</code> is a regular language, <code>B-A</code> can be not context free as it is equal to <code>B \u2229 A'</code>, and context free languages are not closed under complement. Could you give me a counterexample? </p>\n", 'ViewCount': '29', 'Title': 'Counterexample that B-A can be NOT context free', 'LastActivityDate': '2014-02-03T16:02:35.400', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '20258', 'Score': '1', 'OwnerDisplayName': 'Mary Star', 'PostTypeId': '1', 'OwnerUserId': '11889', 'Tags': '<formal-languages>', 'CreationDate': '2014-01-13T22:41:57.460', 'Id': '20256''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>There is something in the pumping lemma that I do not quite understand, namely if $s$ is at least of length $p$, then we could split it to $xyz$ such that the following conditions are met:</p>\n\n<ol>\n<li>For each $i \\geq 0$, $x(y^i)z \\in A$</li>\n<li>$|y| &gt; 0$</li>\n<li>$|xy| \\leq p$</li>\n</ol>\n\n<p>But if $i = 0$ then $|y|$ cannot be strictly greater than $0$. Isn't condition 1 contradicting condition 2? Isn't $y^0 = \\varepsilon$?</p>\n", 'ViewCount': '72', 'Title': u'How can both |y| = 0 and y\u2070 = \u03b5 hold in the Pumping lemma?', 'LastEditorUserId': '13175', 'LastActivityDate': '2014-02-05T12:45:29.647', 'LastEditDate': '2014-02-04T14:29:29.727', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-02-04T05:08:56.827', 'Id': '21277''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '80', 'Title': 'Proving that {0^{2^k}} is not regular with the Myhill-Nerode theorem', 'LastEditDate': '2014-02-12T20:26:14.113', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13139', 'Body': "<p>My language is the repetition of 0 to a length that's a power of 2:</p>\n\n<p>$L = \\{ 0^k \\ni k=2^n, n \\geq 1 \\}$</p>\n\n<p>I want to know how to prove that this language is not regular. I have attempted the proof below, but think it may be incorrect due to my potentially wrong assumption that the Myhill-Nerode theorem allows me to break up a regular language in the following way:</p>\n\n<p>$j, p = 2^h$ for 2 distinct values of $h$, $h \\in \\mathbb{N}$:</p>\n\n<p>$a = 0^{j/2}$</p>\n\n<p>$b = 0^{p/2}$</p>\n\n<p>$c = 0^{j/2}$</p>\n\n<p>$ac = 0^{j/2}0^{j/2} = 0^j$ is in my language since $j$ is of the form $2^n$</p>\n\n<p>$bc = 0^{p/2}0^{j/2}$ is not guaranteed to be in my language for every $p$ and $j$, since $j \\ne p$</p>\n\n<p>Thus my language must not be regular since $ac$ is in it but $bc$ is not.</p>\n\n<p>Did I apply the Myhill-Nerode correctly? If not, what do I need to change in my proof?</p>\n", 'ClosedDate': '2014-02-16T17:54:49.657', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-12T20:42:17.610', 'CommentCount': '3', 'AcceptedAnswerId': '21578', 'CreationDate': '2014-02-04T21:48:54.480', 'Id': '21301''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>There are two languages,</p>\n\n<p>$\\qquad L_1 = \\{w\\in\\{a,b\\}^*: N_a\\leq N_b\\}$ and<br>\n$\\qquad L_2=\\{w\\in\\{a,b\\}^*: N_b\\leq 2N_a\\}$ </p>\n\n<p>where $N_a$ means the number of occurrences of $a$ in the string $w$. Same for $N_b$.</p>\n\n<p>I've proved that $L_1$ has a DPDA (hope this is right). </p>\n\n<p>Now I want to know whether $L=L_1\\cap L_2$ has a DPDA or not. </p>\n\n<p>I applied the Pumping lemma but it seems like there is no contradiction. I tried to draw the DPDA but failed. Maybe $L$ has a nondeterministic PDA but not a DPDA. However I cannot prove this.</p>\n\n<p>Could anyone give me some hints?</p>\n", 'ViewCount': '79', 'Title': 'How to find a Deterministic PDA for an intersection of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T20:49:59.820', 'LastEditDate': '2014-02-05T08:34:26.133', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21328', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><context-free><automata><pushdown-automata>', 'CreationDate': '2014-02-05T04:09:47.847', 'Id': '21309''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider following grammar:</p>\n\n<p>$$X\\to Yc|ZY$$</p>\n\n<p>$$Y\\to ab|cX$$</p>\n\n<p>$$Z\\to d|\\epsilon$$</p>\n\n<p>Can this be converted to LL(1)?</p>\n\n<p>Cleary, its not LL(1) because of First/First conflict at first production. Can anyone suggest something to make it LL1?</p>\n', 'ViewCount': '67', 'Title': 'Is this grammar LL(1)?', 'LastEditorUserId': '14403', 'LastActivityDate': '2014-02-06T08:44:11.353', 'LastEditDate': '2014-02-05T19:50:39.943', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14403', 'Tags': '<formal-languages><formal-grammars><compilers>', 'CreationDate': '2014-02-05T10:30:12.203', 'Id': '21315''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is this true? If I change all final states of a given Deterministic Finite Automata to non final states and all non final states to final states then does this new automata represent the complement of the language that was accepted by the original automata?</p>\n\n<p>What if we talk about a Non deterministic finite automata instead of a DFA?</p>\n', 'ViewCount': '81', 'Title': 'Can reversing the final and non-final states of a DFA produce the complement of the original language?', 'LastActivityDate': '2014-02-06T08:29:16.050', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21361', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12845', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-02-06T07:09:39.397', 'Id': '21359''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '18', 'Title': 'Decidability of fullness of intersection of a CSL with a regular language', 'LastEditDate': '2014-02-06T16:30:23.490', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'vzn', 'PostTypeId': '1', 'OwnerUserId': '699', 'Body': '<p>Let $L_r$ be a regular language with alphabet $\\Sigma$ and $L_{\\text{csl}}$ be a context sensitive language. Are any of the following questions decidable?</p>\n\n<ol>\n<li>$L_r \\cap L_\\text{csl} \\stackrel{?}{=} L_r$</li>\n<li>$\\Sigma^* \\cap L_\\text{csl} \\stackrel{?}{=} L_r$</li>\n<li>$L_r \\cap L_\\text{csl} \\stackrel{?}{=} \\Sigma^*$</li>\n<li>$\\Sigma^* \\cap L_\\text{csl} \\stackrel{?}{=} \\Sigma^*$</li>\n</ol>\n\n<p>I understand that (1) implies the others. I am also looking for any "near variants" that might be decidable.</p>\n', 'Tags': '<formal-languages><computability><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T16:30:23.490', 'CommentCount': '0', 'AcceptedAnswerId': '21384', 'CreationDate': '2014-01-18T17:05:04.703', 'Id': '21383''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm working on homework for my formal languages and automata course. The text we are using is the first edition of Hopcroft and Ullman (1979). </p>\n\n<p>Specifically, I'm unsure how to justify that my regular expression for exercise 2.10 (c) is correct. The question asks for a regular expression for the set of all strings <strong>not</strong> containing the substring 101 (over the alphabet $\\{0, 1\\}$). Additionally, it asks for justification that the regular expression you write is correct. </p>\n\n<p>I came up with the regular expression \n$$0^*1^*0^* + (1 + 00 + 000)^* + 0^+1^+0^+.$$</p>\n\n<p>As for the justification, what exactly are they looking for?</p>\n", 'ViewCount': '69', 'ClosedDate': '2014-02-23T08:31:47.153', 'Title': 'Proving a regular expression is correct', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T22:51:10.453', 'LastEditDate': '2014-02-09T22:51:10.453', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14510', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-02-08T21:35:14.527', 'Id': '21458''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>My language is the repetition of 0 to a length that's a power of 2:</p>\n\n<p>$L = \\{ 0^k \\mid k=2^n, n \\geq 1 \\}$</p>\n\n<p>I want to know how to use the Myhill-Nerode theorem to show that this language is not regular.</p>\n\n<p>This is my first attempt at doing this although I am confident that I am wrong:</p>\n\n<p>$j, p = 2^h$ for 2 distinct values of $h$, $h \\in \\mathbb{N}$:</p>\n\n<p>$a = 0^{j/2}$</p>\n\n<p>$b = 0^{p/2}$</p>\n\n<p>$c = 0^{j/2}$</p>\n\n<p>$ac = 0^{j/2}0^{j/2} = 0^j$ is in my language since $j$ is of the form $2^n$</p>\n\n<p>$bc = 0^{p/2}0^{j/2}$ is not guaranteed to be in my language for every $p$ and $j$, since $j \\ne p$</p>\n\n<p>Thus my language must not be regular since $ac$ is in it but $bc$ is not.</p>\n", 'ViewCount': '41', 'Title': 'How do I use the Myhill-Nerode theorem to show that a language is not regular?', 'LastEditorUserId': '9612', 'LastActivityDate': '2014-02-11T11:07:04.730', 'LastEditDate': '2014-02-11T11:07:04.730', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13139', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-02-10T17:56:08.263', 'Id': '21499''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a question regarding regular languages. Given that $L_1$ and $L_2$ are non-regular languages, can a regular language $L$ exist so it is a subset of $L_2$ and $L_1$ subset of $L$?</p>\n\n<p>To be more specific:</p>\n\n<p>$\\qquad L_1 \\subset L \\subset L_2$</p>\n\n<p>for $L_1, L_2$ non-regular Languages.</p>\n', 'ViewCount': '61', 'Title': 'Are there regular languages between every two non-regular languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T07:56:10.523', 'LastEditDate': '2014-02-12T07:56:10.523', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21534', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13168', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-02-11T17:32:23.910', 'Id': '21531''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am having hard time solving the following problem.</p>\n\n<blockquote>\n  <p>Are there any languages for which\n  $$\n\\overline{L^*} = (\\overline{L})^*\n$$</p>\n</blockquote>\n\n<p>Assuming $\\emptyset^* = \\emptyset$, if I consider $\\Sigma = \\{a\\}$ and L = $\\Sigma^*$, I get that $L^* = L$ and that $\\overline{L^*} = \\emptyset$. For the right side I get $\\overline{L} = \\emptyset$ and $(\\overline{L})^* = \\emptyset$. Thus, both sides are equal. </p>\n\n<p>Is it true that $\\emptyset^* = \\emptyset$?</p>\n', 'ViewCount': '118', 'Title': 'Do Kleene star and complement commute?', 'LastEditorUserId': '14587', 'LastActivityDate': '2014-02-23T20:11:13.703', 'LastEditDate': '2014-02-23T20:11:13.703', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21549', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14587', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-02-11T23:09:29.767', 'Id': '21544''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I know that each regular language can be generated by a CFG.\nThis makes, in one sense at least: context-free languages more general than regular languages.</p>\n\n<p>Are there known results about the 'complexity' of regular languages in the CFG context? For example, is it true that every regular language can be generated by an unambiguous LL(1) grammar?  Or is something similar true?</p>\n\n<p>The general question above comes from the attempts I made to build a 'simple' grammar generating $L=\\{(ab)^i|(ba)^i : i\\geq 0\\}$.\nNone of the grammars I could build were 'simple'.</p>\n", 'ViewCount': '75', 'Title': 'Complexity of CFG grammar for a regular language', 'LastEditorUserId': '755', 'LastActivityDate': '2014-02-16T07:57:05.730', 'LastEditDate': '2014-02-16T07:57:05.730', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14695', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2014-02-15T13:36:39.660', 'Id': '21663''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need help constructing a Left Linear grammar for the language</p>\n\n<p>$L = \\{ a^n b^m c^p \\mid n\\geq 2, m\\geq 3, p\\geq 4 \\}$</p>\n\n<p>Here is what I have so far, I know :</p>\n\n<p>$N = \\{S\\}$</p>\n\n<p>$T = \\{ a, b, c \\}$</p>\n\n<p>$P = \\{$</p>\n\n<p>$S \\rightarrow Pcccc$</p>\n\n<p>$P \\rightarrow Pc$</p>\n\n<p>$P \\rightarrow M$</p>\n\n<p>$M \\rightarrow Mbbb$</p>\n\n<p>$M \\rightarrow Mb$</p>\n\n<p>$M \\rightarrow N$</p>\n\n<p>$N \\rightarrow Naa$</p>\n\n<p>$N\\rightarrow a$</p>\n\n<p>$\\}$</p>\n\n<p>I need help figuring out the productions. I am not sure if I am doing it right.</p>\n', 'ViewCount': '40', 'Title': 'Left Linear Grammar: How to construct?', 'LastEditorUserId': '1636', 'LastActivityDate': '2014-02-17T07:07:05.667', 'LastEditDate': '2014-02-17T06:41:17.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14744', 'Tags': '<formal-languages><regular-languages><formal-grammars>', 'CreationDate': '2014-02-17T05:23:46.860', 'Id': '21722''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '100', 'Title': 'Prove that languages which contain words whose lengths are multiples of a constant are regular', 'LastEditDate': '2014-02-18T08:49:52.853', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14596', 'FavoriteCount': '0', 'Body': '<p>This is a problem involving the theory of regular languages.  I am stuck on this problem and do not know how to solve this type of problem.  </p>\n\n<blockquote>\n  <p>Prove that the language $B_n = \\{ a^k \\mid k \\text{ is a multiple of } n \\}$ is a regular language for any $n \\ge 1$.</p>\n</blockquote>\n\n<p>Let me describe my thoughts thus far:  It is easy to show that for $n=1$, we have $B_1 = \\{a\\}$.</p>\n\n<p>In other words, a regular expression can easily be built for the value of $n=1$, and thus for any $k$.</p>\n', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-18T15:02:52.500', 'CommentCount': '2', 'AcceptedAnswerId': '21747', 'CreationDate': '2014-02-18T00:53:50.407', 'Id': '21746''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $L = \\{a^n \\mid n \\ge 0\\}$, where $a^0 = \\epsilon$ and $a^n = a^{n-1}a$ for all $n \\ge 1$.</p>\n\n<p>Thus $L$ consists of sequences of $a$ of all lengths, including a sequence\nof length $0$. Let $L_2$ be any infinite subset of $L$. I need to show there always exists a DFA to recognize $L_2^*$. </p>\n\n<p>If $L_2$ is a finite subset it is very obvious as $L_2$ would be a DFA and hence by Kleene closure $L_2^*$ would be recognized by a DFA. But I am unable to get it for infinite subset as $L_2$ may not be expressed as DFA when, e.g., string lengths are prime.</p>\n', 'ViewCount': '165', 'Title': 'Kleene star of an infinite unary language always yields a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T16:47:56.060', 'LastEditDate': '2014-02-18T16:47:56.060', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21775', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13212', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-02-18T14:05:22.823', 'Id': '21765''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It makes me wonder that despite of (CFL) being a subset of Turing Decidable languages, Turing Decidable is closed under intersection while CFL is not.</p>\n\n<p>Does not Turing Decidable engulf all CFLs?</p>\n', 'ViewCount': '44', 'Title': 'CFL not closed under intersection while Turing Decidable are', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T23:03:12.623', 'LastEditDate': '2014-02-19T23:03:12.623', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9576', 'Tags': '<formal-languages><context-free><turing-machines><closure-properties><decision-problem>', 'CreationDate': '2014-02-19T19:14:27.437', 'Id': '21821''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Describe a regular language that cannot be accepted by any DFA that has only three states.</p>\n</blockquote>\n\n<p>I'm not really sure where to start on this and was wondering if someone could give me some tips or advice. I understand that the pumping lemma can be used to prove a language is not regular, but in this case, it should be a regular language. If anyone has any thoughts it would be appreciated.</p>\n", 'ViewCount': '512', 'Title': 'Regular language not accepted by DFA having at most three states', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-30T02:24:06.250', 'LastEditDate': '2014-03-29T11:53:14.010', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '14857', 'Tags': '<formal-languages><regular-languages><finite-automata><pumping-lemma>', 'CreationDate': '2014-02-19T22:05:01.387', 'FavoriteCount': '1', 'Id': '21826''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a linear grammar G, is it possible to determine if L(G) contains a palindrome?</p>\n', 'ViewCount': '44', 'Title': 'Palindromes and linear grammars', 'LastActivityDate': '2014-02-20T16:01:25.377', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14447', 'Tags': '<formal-languages><undecidability>', 'CreationDate': '2014-02-20T15:12:23.643', 'Id': '21848''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Context-free grammars, as well as other types of grammars, can naturally\nassociate structure with the strings of the defined language, for\nexample tree structures in the case of context-free language.</p>\n\n<p>What kind of structural features can be thus described by regular grammars,\nand associated with the strings of the language.</p>\n\n<p>One answer is of course that it can associate a non-terminals with\neach prefix (or suffix) of the string. That sorts the prefixes (or\nsuffixes) into sets that may intersect, depending on the grammar.\nBut what else would you see?</p>\n\n<p>related question : <a href="http://cs.stackexchange.com/questions/21306">Why CFG can specify structure of sentence but Regular grammar cannot?</a></p>\n', 'ViewCount': '38', 'Title': 'What kind of structural features of strings can be described by regular grammars?', 'LastActivityDate': '2014-02-20T16:22:49.207', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars><syntax-trees>', 'CreationDate': '2014-02-20T16:22:49.207', 'Id': '21852''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am struggling with this question for a very long time and just can\'t find the flaw. So I am given a false Theorem:</p>\n\n<blockquote>\n  <p>The language ${awwa \\mid w \\in {a,b}^* }% is regular.</p>\n</blockquote>\n\n<p>Well, that part is obvious, we can prove it using the pumping lemma.</p>\n\n<p>The question I am asked is to find the flaw in the "proof" for this theorem:</p>\n\n<blockquote>\n  <p>Let</p>\n  \n  <p>$\\qquad L_1 = \\{ aw \\mid w \\in \\{a,b\\}^* \\}$</p>\n  \n  <p>$\\qquad L_1^R = \\{ aw \\mid w \\in \\{a,b\\}^* \\}$</p>\n  \n  <p>Let $L_2 = L_1 L_1^R = \\{ awwa \\mid w \\in \\{a,b\\}^*\\}$ be even-length palindromes that begin and end with an $a$.\n  Since $L_1$ is regular, and the class of regular languages is closed under reversal and concatenation, we conclude $L_2$ is also regular.</p>\n</blockquote>\n\n<p>Can you find the flaw? I could build a DFA for $L_1$ and $L_1^R$, so I know they are regular. And regular languages are closed under reversal and concatenation.</p>\n\n<p>But, however, $L_2$ is still not regular, so where is the mistake in the "proof"?</p>\n', 'ViewCount': '83', 'Title': 'A flawed theorem about regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T11:50:18.730', 'LastEditDate': '2014-02-21T11:50:18.730', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14896', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-02-21T01:27:47.970', 'Id': '21868''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '87', 'Title': 'showing that the pair of Finite Automata are equivalent', 'LastEditDate': '2014-02-22T09:48:46.713', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14495', 'FavoriteCount': '1', 'Body': '<p>Here I am trying to show that the pair of Finite Automata are equivalent. I have tried something but I am not sure if I am in the right direction. This is what I have.</p>\n\n<p>These are pairs of FA\'s. Set theory formula in here is <code>(L1\' + L2)\' + (L2\' + L2)\'</code></p>\n\n<p><img src="http://i.stack.imgur.com/pnj9J.png" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/McwoT.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/8mF4g.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/SVpwy.jpg" alt="enter image description here"></p>\n\n<p>Conclusion:</p>\n\n<blockquote>\n  <p>Both machines (FA1\'+FA2)\' and (FA2+FA1)\' has no final states.\n  (FA1\'+FA2)\' to have a final state, the machine (FA1\'+FA2)\' must have\n  no final state. The exact same thing half of the formula. Clearly, if\n  we added these machines together we would get a machine with nine\n  state and no final state. Because there is no final state, it accepts\n  no words and two languages L1 and L2 ar equivalent.</p>\n  \n  <p>So the two regular expressions defame the same language and\n  equivalent.</p>\n</blockquote>\n\n<p>Am I in the right direction ?</p>\n', 'Tags': '<formal-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T09:48:46.713', 'CommentCount': '3', 'AcceptedAnswerId': '21906', 'CreationDate': '2014-02-21T17:58:54.570', 'Id': '21897''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve got a simple question:</p>\n\n<p>Let\'s say we have the following definition of a language over some alphabet: $L = \\{w \\mid w \\text{ contains the infix } aab\\}$</p>\n\n<p>Does that mean $aab \\in L$? or does "$aab$" have to be "wrapped" on both sides by other letters?</p>\n', 'ViewCount': '56', 'Title': u'Definition of \u201cinfix\u201d in formal languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T13:26:15.920', 'LastEditDate': '2014-02-22T13:26:15.920', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21922', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14934', 'Tags': '<formal-languages><terminology>', 'CreationDate': '2014-02-22T09:47:07.130', 'Id': '21921''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Here is the problem:</p>\n\n<p>Prove the single-tape TM that cannot write on the portion of the tape containing the input string recognize only regular language. </p>\n\n<p>My idea is to prove that this particular TM is equivalent to DFA. </p>\n\n<p>Using this TM to simulate DFA is very straightforward. </p>\n\n<p>However, when I want to use this DFA to simulate TM, I encounter the problem. For the TM transition $\\delta(q,a)=(q',a,R)$, DFA can simulate definitely by reading tape to the right and doing the same state transition. </p>\n\n<p>For $\\delta(q,a)=(q',a,L)$, I cannot figure out how to use this DFA or NFA to simulate the left move because the DFA only reads to left and has no stack or something to store.</p>\n\n<p>Should I consider another way? Could anyone give me some hints? Thanks. </p>\n", 'ViewCount': '56', 'Title': 'Prove Single-Tape and Non-write Turing Machine can Only Recognize Regular Language?', 'LastActivityDate': '2014-02-27T06:41:33.020', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><computability><regular-languages><turing-machines><automata>', 'CreationDate': '2014-02-27T06:41:33.020', 'Id': '22082''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Minimizing deterministic finite automata (DFAs) is a problem that has been thoroughly studied in the literature, and several algorithms have been proposed to solve the following problem: \nGiven a DFA $\\mathscr{A}$, compute a corresponding minimal DFA accepting the same language as $\\mathscr{A}$.\nMost of these algorithms run in polynomial time.</p>\n\n<p>However, I wonder whether the decision variant of this problem - "given a DFA $\\mathscr{A}$, is $\\mathscr{A}$ minimal?" - can be solved more efficiently than actually computing the minimal automaton.\nObviously, this can also be done efficiently by running for example <a href="http://en.wikipedia.org/wiki/DFA_minimization#Hopcroft.27s_algorithm">Hopcroft\'s partition-refinement algorithm</a> and then deciding whether all partitions contain precisely one state.</p>\n\n<p>As Yuval Filmus suggests <a href="http://cs.stackexchange.com/a/3046/7486">in his answer</a>, the decidability variant can be solved faster, possibly by using the standard algorithms.\nUnfortunately, I cannot see how (I hope I am not missing an obvious point here).</p>\n\n<p>Yuval points out in the comments here that the best known algorithms (like the one above) run in time $\\mathcal{O}(n \\log n)$ for constant-sized alphabets. Therefore, I am not only interested in asymptotically significant gains in runtime, as these seem rather unlikely. What bothers me most is that I cannot imagine any "shortcut" that might be drawn from the fact that we are only interested in a yes-no-answer - not even a shortcut that allows for saving an asymptotically negligible amount of time. I feel that every sensible algorithm that decides the minimality of a DFA would have to actually minimize the DFA and see if anything changes during the process. </p>\n', 'ViewCount': '121', 'Title': 'How fast can we decide whether a given DFA is minimal?', 'LastEditorUserId': '7486', 'LastActivityDate': '2014-03-02T20:05:21.393', 'LastEditDate': '2014-03-02T18:51:48.217', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<algorithms><formal-languages><finite-automata>', 'CreationDate': '2014-03-02T12:41:01.930', 'FavoriteCount': '2', 'Id': '22191''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Suppose we have two language</p>\n\n<pre><code>L = {0^n|n&gt;=0}\nM = {1^n|n&gt;=0}\n</code></pre>\n\n<p>We know both of these are regular languages.</p>\n\n<p>Will L.M (concatenation) be a regular language? Please explain your answer and if yes then what will be its expression?</p>\n\n<p>Thanks for any help in advance.</p>\n\n<p>Adding to it, we know that language {o^n1^n|n>=0} isn't a regular language</p>\n", 'ViewCount': '55', 'ClosedDate': '2014-03-08T06:42:09.453', 'Title': 'Concatenation of regular languages', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-06T03:26:05.600', 'LastEditDate': '2014-03-04T08:37:41.347', 'AnswerCount': '4', 'CommentCount': '4', 'Score': '-3', 'PostTypeId': '1', 'OwnerUserId': '15253', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-03-04T02:37:25.230', 'Id': '22250''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '42', 'Title': 'If L is a non-regular language over {a}, are all Myhill-Nerode classes singletons?', 'LastEditDate': '2014-03-06T15:55:26.960', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'idannik', 'PostTypeId': '1', 'OwnerUserId': '16112', 'Body': '<p>Is there a non-regular language over unary alphabet $\\{a\\}$ which has a Myhill-Nerode equivalence class that is not a singleton?</p>\n', 'Tags': '<formal-languages><automata>', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-06T15:55:26.960', 'CommentCount': '1', 'AcceptedAnswerId': '22273', 'CreationDate': '2014-01-22T19:28:06.297', 'Id': '22272''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have few CS textbooks with me which discuss languages, well actually 2 plus old course notes supplied a few years ago. I have been searching the web too any only seem to come up with vague responses just like the text books I have.</p>\n\n<p>My question is about language recognisers verses generators. </p>\n\n<p>I get the overriding principle of a recogniser. That it analyses a language and is able to determine nay or yay if a String belongs to a language.  This is at least what I have picked up from the books and notes. However, it's much more complex than that is it not? A tokenise and syntax analyser  (which I assume to be recognisers) do not just say yes or no, they also ways where don't they...?</p>\n\n<p>However, language generators. No one seems to be very clear about what they are. The typical description I get is  For example Sebasta's Concepts of programming languages says <em>'A language generator is a device that can be used to generate the sentences of a language. We can think of a generator as a push button that produces a sentence of a language every time it is pressed.'</em>  Seriously? That's it?? Your kidding right.... </p>\n\n<p>I read that Regex is an example of a Generator, then why when people talk of generators to they not talk of the inputs. For example Regex has a target String, and the Regex with defines both the accepted alphabet and it's grammar rules.</p>\n\n<p>Can someone provide for me a clearer distinction of what a recogniser is?</p>\n", 'ViewCount': '89', 'Title': 'Language Recognition Devices and Language Generators', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-05T22:24:39.077', 'LastEditDate': '2014-03-05T07:16:31.087', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '22298', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15290', 'Tags': '<formal-languages><terminology><automata>', 'CreationDate': '2014-03-05T02:39:33.337', 'Id': '22288''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I am working on a pumping lemma question and trying to prove that the following is not regular, but I can't finish the proof, if someone can help me it will be great.</p>\n\n<p>So I am given this language: \n$L = \\{ a^n | n = 3^k , k\u22650 \\}$ .\nOk. I choose $w = a^{3^m}$. I know for sure that $y = a^t$ ($y$ must be any number or $a$'s), where $t\u22651$. $x = a^{(3^m)-t}$ and $y = a^t$. I pump twice, so $i =2$ and  $xy = a^{(3^m)+t}$.</p>\n\n<p>Now, is this enough to finish the proof? What is my $xyz$? and how do I prove that my $w$ is not in the language?\nThank you so much for whoever decide to help me out!</p>\n", 'ViewCount': '65', 'ClosedDate': '2014-03-08T06:42:50.470', 'Title': u'Pumping lemma on {a^n | n=3^k} \u2014 help finishing the proof', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-06T18:51:30.940', 'LastEditDate': '2014-03-06T18:51:30.940', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15347', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-03-06T15:21:03.270', 'Id': '22341''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The Chomsky hierarchy is a guideline on language expressive power. The linear feedback shift register is a very interesting "element" to structure a language and there is a large theoretical literature. </p>\n\n<p>In reference to the Chomsky hierarchy (and automata), which is the linear feedback shift register languages/automaton ? </p>\n', 'ViewCount': '23', 'Title': 'In reference to the Chomsky hierarchy (and automatas), Which is the linear feedback shift register Languages/automaton?', 'LastEditorUserId': '6447', 'LastActivityDate': '2014-03-06T21:29:06.013', 'LastEditDate': '2014-03-06T21:29:06.013', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15361', 'Tags': '<formal-languages><automata>', 'CreationDate': '2014-03-06T20:32:54.597', 'Id': '22351''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '51', 'Title': 'Using the pumping lemma for a proof by contradiction', 'LastEditDate': '2014-03-07T07:15:01.397', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15365', 'FavoriteCount': '0', 'Body': u"<p>I'm trying to prove that the set of even-length strings with the two middle symbols being equal cannot be accepted by finite automata.  I can explain why it cannot be accepted intuitively, but I'm having trouble with the proof.  Our symbols are {a, b}.</p>\n\n<p>I allowed L = $\\{(ab)^{*{\\frac{n}{2} - 1}} aa (ab)^{*{\\frac{n}{2} - 1}}\\}$.  I know the format of the language is wonky, and will be talking to my professor about it tomorrow.  For the proof, I allowed $\\frac{n}{2} - 1$ to be the combination of symbols before and after the two elements.  So, using the Pumping Lemma's condition that |uv|\u2264 n, I allowed $u = \\frac{n}{2} -1$  and $v = n^2$ (for aa); this is obviously greater than n, but I'm having trouble understanding how to choose $u$ and $v$.  Is my assignment for these parameters correct?</p>\n", 'ClosedDate': '2014-04-01T22:08:50.070', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-07T07:15:01.397', 'CommentCount': '5', 'CreationDate': '2014-03-06T22:45:34.737', 'Id': '22356''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to find a context-free grammar for $L = \\{a^n : n\\leq2^{20}\\}$. There's one for sure. I approached it by two ways and both seemed dead end. One was to set a limit during the production of the new strings. But I don't think there's such a thing in CFGs. Second approach was to produce the strings of the language top-down. Starting from the last string $a^{2^{20}}$ and removing an $a$ each time till epsilon but I don't think that's achievable either. Any ideas?</p>\n", 'ViewCount': '86', 'Title': 'Context-free grammar for $L = \\{a^n : n\\leq2^{20}\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-10T08:58:13.090', 'LastEditDate': '2014-03-10T08:58:13.090', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '22403', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15424', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2014-03-08T16:36:44.420', 'Id': '22402''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider\n  the language $L = \\{w, w \\in \\{a,b,c\\}^*, n_c(w) = n_a(w) + n_b(w)\\}$, where $n_q(\\omega)$ is defined to be "the number of $p \\in \\omega$.</p>\n\n<p>I have tried a couple of PDA\'s that follow this whole idea of a stack-replacement kind of algorithm, but the reasoning behind it is incorrect. I know it is not the right structure; furthermore, those examples of my previous attempts don\'t really fit in the context of the question that I\'m asking.</p>\n\n<p>There I have a gut feeling that I need to exploit the fact that $0=n_a(w)+n_b(w)-n_c(w)$ but I have absolutely the faintest idea how to do so. When building this kind of "counting machine," what are some design patterns that I can exploit? </p>\n', 'ViewCount': '64', 'Title': 'A NPDA for the language $L = \\{w \\mid w \\in \\{a,b,c\\}^*, n_c(w) = n_a(w) + n_b(w)\\}$', 'LastEditorUserId': '12863', 'LastActivityDate': '2014-03-11T02:53:10.467', 'LastEditDate': '2014-03-11T02:53:10.467', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22414', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12863', 'Tags': '<formal-languages><pushdown-automata><nondeterminism>', 'CreationDate': '2014-03-09T01:16:21.513', 'Id': '22412''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Deterministic context-free languages are not in general closed under substitution. I have been looking at the DK-test (it is described in the 3rd edition of Sipser's Intro. to Theory of Computation, 2012) which can be used to check if a given CFG is deterministic, and it seems to me this can be used to show that DCFLs are closed under substitution when the substituted languages are disjoint DCFLs. Is this a known result? Or is anything known about the substitution closure of DCFLs with other restrictions on the substituted languages?</p>\n", 'ViewCount': '25', 'Title': 'DCFL substitution closure', 'LastActivityDate': '2014-03-10T11:51:19.133', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages>', 'CreationDate': '2014-03-10T11:18:45.887', 'Id': '22464''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to prove this expression but don't have an exact idea about what to do:</p>\n\n<p>If $E$ is any alphabet and $L$ is any language $L \\subseteq E^*$. Prove that $L^*L^* = L^*$.</p>\n", 'ViewCount': '85', 'ClosedDate': '2014-03-27T07:54:59.240', 'Title': 'Kleene Star Property : L*L* = L*', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-12T11:15:44.430', 'LastEditDate': '2014-03-12T11:15:44.430', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15596', 'Tags': '<formal-languages>', 'CreationDate': '2014-03-12T10:57:02.210', 'Id': '22540''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '32', 'Title': 'Left recursion for LL(1)', 'LastEditDate': '2014-03-28T01:43:23.957', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15655', 'Body': u'<p>Hi I am trying to solve a LL(1) form question for first n follow rule The question is</p>\n\n<pre><code>A::=BC|C\nB::=Bd|ef\nC::=gh|j\n</code></pre>\n\n<p>What I have done to eliminate left recursion </p>\n\n<pre><code>A::=CA\u2019\nA\u2019::=CB\u2019\nA\u2019::=\u03f5\nB::=efB\u2019\nB::=dB\u2019\nB\u2019::=\u03f5\nC::=gh\nC::= j\n</code></pre>\n\n<p>Is it correct?</p>\n\n<p>Thanks guys, it has been solved.</p>\n', 'ClosedDate': '2014-03-27T07:54:49.217', 'Tags': '<formal-languages><parsing><left-recursion>', 'LastEditorUserId': '15655', 'LastActivityDate': '2014-03-28T01:43:23.957', 'CommentCount': '1', 'AcceptedAnswerId': '22595', 'CreationDate': '2014-03-13T18:07:01.433', 'Id': '22594''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I start to suspect this problem is very hard now that I cannot find a single relevant literature on the subject, but it\'s too late to change the class project topics now, so I hope any pointers to a solution. Please pardon the somewhat artificial scenerio of this question, but here goes:</p>\n\n<p>Technical version: </p>\n\n<p>Let $\\Sigma_{c}$ and $\\Sigma_{q}$ and $\\Sigma_{a}$ be 3 disjoint finite alphabet (c, q, a stand for content, query and answer respectively). Let $L_{c}\\in\\Sigma_{c}^{*}$ and $L_{q}\\in\\Sigma_{q}^{*}$ be FINITE languages, wherein $L_{q}$ have the property that for every string in the language all of its prefix are in the language too. There is an unknown function $f:L_{c}\\times L_{q}\\rightarrow\\Sigma_{a}^{*}$. Consider a mysterious machine that receive continuous stream of symbol through a channel one at a time step (we assume that the symbol are clearly distinguishable). This machine, whenever being feed with a string in $c\\in L_{c}$ (with the symbol in correct temporal order) followed by a string in $q\\in L_{q}$ will output (through a different output channel) the value of $f(c,q)$ as a temporal sequence, one symbol at a time. Note that the machine always output after every new symbol from $\\Sigma_{q}$. Note that the empty string is in $L_{q}$, which means the machine also output something before any symbol on $\\Sigma_{q}$ have arrived, but only if it is certain with high probability that the full string in $L_{c}$ have been received.</p>\n\n<p>The objective is to construct a neural network that emulate that mysterious machine, if we have only access to its input and output channel to use as training data, and we do not know $f$. We also have to assume that the input channel are noisy in the following sense: random noise are inserted into the input channel at high probability, delaying input symbol, and we initially do not know which one is noise and which one is authentic; also symbol in the input channel are sometimes lost at low probability. EDIT: Note: we do not know $L_{c}$ nor $L_{q}$, only the mysterious machine know, in fact we do not even know the alphabet $\\Sigma_{c}$ and $\\Sigma_{q}$ other than the fact that they are disjoint and are subset of the set of all possible input symbol (input symbol not in either set are certainly noise, but we can\'t tell which set it belongs to initially; note that it is still possible for symbol from the alphabet to be noise).</p>\n\n<p>(why neural network: beside the noise problem, also because that\'s what I wrote in my class project proposal)</p>\n\n<p>(layman version: consider Sherlock Holmes sitting in his chair, bored. Dr. Watson give a short description of the client. Once he\'s done, Sherlock Holmes give a conclusion about the client. Dr. Watson is astonished, and ask more question, and Sherlock Holmes reply. The conclusion must obviously based on the description alone; and subsequent answer have to answer the question being asked, taking into account the contexts which consists of question already being asked (for example, the same "How did you know?" following "Age?" demands different answer than when following "Height?"). Now you want to make a neural network that simulate Sherlock Holmes, having all the recordings of those session. Dr. Watson however tend to insert in long description that are rather irrelevant, making long statement before finally getting around to ask question, and sometimes accidentally omit crucial information, but otherwise describe people in a rather fixed order of details. The neural network must be able to deal with that. Of course, this is a just a layman\'s description, the situation is much less complex.)</p>\n\n<p>I have looked through various relevant literature, and I cannot find anything relevant. Conversion to spatial domain is useless due to high amount of noise causing very long input sequence. I have looked into LSTM to deal with the memory problem over arbitrary long time lag, but I for the life of me cannot figure out how is the network is supposed to be trained when there are arbitrarily long noise insertion everywhere or possibilities of missing symbol (every method I found seems to force a fixed time-lag between input and output, and missing symbol immediately wreck any method based on predicting the next item in the sequence). Also, is it too much to ask for network that isn\'t too hard to code? Integrate-and-fire neuron is even worse than LSTM in term of difficulty in coding.</p>\n\n<p>Thanks for your help. It\'s due in 2 days, so please be fast.</p>\n', 'ViewCount': '37', 'Title': 'Neural network: noisy temporal sequence converter (transducer?producer?) on demand?', 'LastEditorUserId': '15741', 'LastActivityDate': '2014-04-15T10:54:18.623', 'LastEditDate': '2014-03-16T10:28:14.080', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15741', 'Tags': '<formal-languages><neural-networks>', 'CreationDate': '2014-03-16T06:32:31.097', 'Id': '22666''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '49', 'Title': 'Language with $\\log\\log n$ space complexity?', 'LastEditDate': '2014-03-16T15:11:57.433', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15348', 'FavoriteCount': '1', 'Body': "<p>We know that every non-regular language can be recognized with $ \\Omega\n (\\log\\log n) $ space complexity.</p>\n\n<p>I'm looking for an example of a language which is $ \\Theta\n (\\log\\log n) $ space complexity (if such exists).</p>\n", 'Tags': '<formal-languages><space-complexity>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-16T15:37:57.397', 'CommentCount': '1', 'AcceptedAnswerId': '22681', 'CreationDate': '2014-03-16T14:35:46.383', 'Id': '22676''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've a set of grammar rules like this:</p>\n\n<p>$$\n\\begin{align*}\n&amp;S \\to AbB \\\\\n&amp;A \\to aA|\\epsilon \\\\\n&amp;B \\to aB|bB|\\epsilon\n\\end{align*}\n$$</p>\n\n<p>The grammar generates the following words:\n$$\n\\begin{gather*}\nAbB \\to a^2AB \\to a^3AB \\to \\cdots \\to a^nAB \\to a^nB \\to \\\\\n\\to a^nB \\to a^nbB \\to a^nb^2B \\to \\cdots \\to a^nb^mB \\to a^nb^m,\n\\end{gather*}\n$$\nso if I did things right, $L(G) = a^n b^m$.\nI think that $G$ is a type 1 grammar.</p>\n\n<p>Now I need to design a more restrictive type of grammar that generates the same expression, and I'm stuck. Any help is much appreciated.</p>\n\n<p>My attempt according to the collapsar's answer: </p>\n\n<p>$$\n\\begin{align*}\n&amp;S \\to aSA|b \\\\\n&amp;A \\to a|b \\\\\n&amp;\n\\end{align*}\n$$</p>\n", 'ViewCount': '44', 'ClosedDate': '2014-03-19T17:24:10.183', 'Title': 'Designing a different grammer that generates same expression', 'LastEditorUserId': '15795', 'LastActivityDate': '2014-03-19T15:03:49.400', 'LastEditDate': '2014-03-19T15:03:49.400', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15795', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-03-17T21:35:41.273', 'Id': '22723''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '36', 'Title': 'Proving a language is not a regular language but a context free language', 'LastEditDate': '2014-03-17T23:09:15.107', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': "<p>I have the languages $L_1$ and $L_2$ such that $L_1 = \\{a^nba^n :n \\in N\\}$ and $L_2 =\\{a,b\\}^*\\setminus L_1$.</p>\n\n<p>I want to prove that $L_2$ is not a regular language. I know that to prove that $L_2$ is not a regular language I can use the pumping lemma but I'm unsure about the details.</p>\n\n<p>I also want to prove that $L_2$ is a context free language. Do I need a Push Down Automaton that accepts the language to prove that $L_2$ is a context free language? If so, what would this Push-Down Automaton look like?</p>\n", 'ClosedDate': '2014-03-18T07:47:52.957', 'Tags': '<formal-languages><regular-languages><context-free><pushdown-automata>', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-17T23:28:09.877', 'CommentCount': '1', 'AcceptedAnswerId': '22731', 'CreationDate': '2014-03-17T22:36:34.083', 'Id': '22727''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '85', 'Title': 'Defining a context-free grammar for $\\{w \\in \\{0, 1\\}^* : \\#_0(w) = \\#_1(w)\\}$', 'LastEditDate': '2014-03-18T08:14:27.077', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': "<p>I have a language where each string in the language has even amount of $0$'s as $1$'s (e.g., $0101$, $1010$, $1100$, $0011$, $10$ are all in the language). I was hoping to define a context-free grammar that describes this language. After defining a context-free grammar I want to formally prove that this context-free grammar describes this language.</p>\n\n<p>I've came up with the context-free grammar production rules:\n$$\n\\begin{align*}\n&amp;S\\to0S1S \\\\\n&amp;S\\to1S0S \\\\\n&amp;S\\to\\epsilon\n\\end{align*}\n$$\nIs this the correct context free grammar to define this language?</p>\n\n<p>Im kind of stumped for the proving part. I'm guessing I will need some sort of induction?</p>\n", 'ClosedDate': '2014-03-18T08:16:09.753', 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T08:14:27.077', 'CommentCount': '1', 'AcceptedAnswerId': '22730', 'CreationDate': '2014-03-17T22:42:45.907', 'Id': '22729''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am studying for my algorithms final and came across the following problem:</p>\n\n<p>Find three languages $L_1 \\subset L_2 \\subset L_3$ over the same alphabet such that $L_2 \\in P$ and $L_1,L_3$ are undecidable.</p>\n\n<p>I am having trouble coming up with an example of three such languages. My first thought was to use a form of the halting problem for both $L_1$ and $L_3$ since that is pretty much the only undecidable language I know and am familiar with. I was thinking of perhaps coming up with something of the form \n\\begin{align*}\nL_1 &amp;= \\{M \\mid \\text{$M$ is a Turing machine that starts with 00 and halts}\\}\\\\\nL_2 &amp;= \\{M \\mid \\text{$M$ is a Turing machine that starts with a 00}\\}\\\\\nL_3 &amp;= ?\n\\end{align*}\nbut this doesn't seem to be working.  Any ideas are appreciated!</p>\n", 'ViewCount': '468', 'Title': 'Sandwiching Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T07:51:13.653', 'LastEditDate': '2014-03-18T07:51:13.653', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22737', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '15615', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2014-03-18T00:29:05.380', 'Id': '22735''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there any limit to what we can define as a language? Is any set of symbols a language?</p>\n\n<p>For example, given the alphabet $\\Sigma$, do we say that the language $L = \\Sigma$ has alphabet $\\Sigma$?</p>\n\n<p>Also, what is the intuitive modern equivalent to languages (as defined WRT complexity classes)? I always hear languages described as <em>problems</em>, but what are we really saying when we say that a language <em>is</em> a problem?</p>\n', 'ViewCount': '50', 'Title': 'Limits to the definition of a language', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T13:26:42.807', 'LastEditDate': '2014-03-18T07:58:02.740', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22743', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<formal-languages><terminology>', 'CreationDate': '2014-03-18T03:24:01.907', 'Id': '22742''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '56', 'Title': 'Complexity of Languages', 'LastEditDate': '2014-03-25T04:27:11.867', 'AnswerCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>1) Find language $L_1 \\subseteq L_2 \\subseteq L_3$ such that both $L_1$ and $L_3$ are not context-free languages, but $L_2$ is a regular language.</p>\n\n<p>2) Find language $L_1 \\subseteq L_2 \\subseteq L_3$ such that both $L_1$ and $L_3$ are regular languages but $L_2$ is not context-free.</p>\n\n<p>I understand that context-free grammars are strictly more powerful than regular expressions and any language that can be generated using regular expressions can be generated by a context-free grammar. I am also aware that there are languages that can be generated by a context-free grammar that cannot be generated by any regular expression. </p>\n', 'ClosedDate': '2014-03-18T08:13:19.247', 'Tags': '<formal-languages><regular-languages><context-free>', 'LastEditorUserId': '15798', 'LastActivityDate': '2014-03-25T04:27:11.867', 'CommentCount': '8', 'CreationDate': '2014-03-18T04:58:43.450', 'Id': '22747''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '47', 'Title': 'If neither $L_1$ nor $L_2$ are context free then is $L_1 \\cup L_2$ also not a context free language?', 'LastEditDate': '2014-03-18T21:37:36.353', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>If two regular languages $L_1$ and $L_2$ are both <strong>not</strong> context free languages then is $L_1 \\cup L_2$ also <strong>not</strong> a context free?</p>\n\n<p>I am aware that if $L_1$ and $L_2$ are context free languages then the language $L_1 \\cap L_2$ is also context free but cannot quite connect the dots. If someone could help out that would be great.</p>\n', 'ClosedDate': '2014-03-19T00:05:02.747', 'Tags': '<formal-languages><regular-languages><context-free>', 'LastEditorUserId': '15798', 'LastActivityDate': '2014-03-18T23:07:04.487', 'CommentCount': '2', 'AcceptedAnswerId': '22774', 'CreationDate': '2014-03-18T21:09:11.070', 'Id': '22772''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have been starting to learn about CFGs and PDAs and have gotten familiar with the simple stuff. I have been able to construct CFGs for simple languages but this question is more specific:</p>\n\n<p>$\\lbrace 0^a1^b2^c3^d4^e5^f |a,b,c,d,e,f \\geq 0$ and $a+b=d+e\\rbrace$.</p>\n\n<p>My thought process has only gone so far. I see that if you add a 0 you must add a 3 or 4, the same is if you add a 1. And for adding a 3 or 4 the case is very similar. My biggest troubles are due to the characters that lay between the pairs of 0s,1s,3s and 4s. I haven't been able to produce a serious attempt yet, but will post it as an edit if I do. Any help would be appreciated.</p>\n\n<p><strong>Edit:</strong> Here is a possible solution I have come to:</p>\n\n<p>$S\\rightarrow AB$</p>\n\n<p>$A\\rightarrow 0A4|C|D$</p>\n\n<p>$B\\rightarrow B5|\\epsilon $</p>\n\n<p>$C\\rightarrow 0C3|E$</p>\n\n<p>$D\\rightarrow 1D4|E$</p>\n\n<p>$E\\rightarrow 1E3|F$</p>\n\n<p>$F\\rightarrow 2F|\\epsilon$.</p>\n", 'ViewCount': '25', 'Title': 'Construct context free grammar from language', 'LastEditorUserId': '15512', 'LastActivityDate': '2014-03-20T00:55:54.307', 'LastEditDate': '2014-03-20T00:55:54.307', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22833', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15512', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-03-20T00:04:23.550', 'Id': '22832''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '65', 'Title': 'Proving that context-free languages are closed under inserting symbols', 'LastEditDate': '2014-03-20T15:55:52.117', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14596', 'FavoriteCount': '1', 'Body': '<p>This is a theoretical computer science question, regarding the proof of whether or not context-free languages are closed under an operation.  This means basically that any context-free language which undergoes this operation would still be context-free.</p>\n\n<blockquote>\n  <p>For a language $A$ which is a subset $\\Sigma^*$, define the language $A_+$ as</p>\n  \n  <p>$\\qquad\\displaystyle A_+ = \\{xyz | y\\in \\Sigma \\wedge xz \\in A\\}$.</p>\n  \n  <p>Prove that the set of context-free languages is closed under the $+$ operator.</p>\n</blockquote>\n\n<p>So $A_+$ contains all strings that can be obtained by inserting one symbol into a string in $A$.\nShow that the class of context-free languages is closed under the operation $+$ (i.e.,     show that\nif $A$ is context free, then $A_+$ is also context free).</p>\n\n<p>Note that this is not a homework question.  Examples of closure proofs are sparse online and in my textbook.  </p>\n\n<p>First, let\'s think about the different ways to prove closure of CFLs:  </p>\n\n<ol>\n<li><p>Constructing a "template" Push Down Automata that can incorporate any other Push Down Automata and add on a part to the beginning, middle, or end of the PDA and still be able to accept the language accepted by the original CFL, with the new operation on it.  Basically, if for any given PDA P, if a PDA P\' can be created which accepts the language of P with the new operation (in our case, the "+" operator) performed on it, then that operation must be under closure.  </p>\n\n<p>Solving the problem in this manner is quite simple to think about.  Imagine a PDA P which accepts strings from the CFL L.  In application to our problem, this would be a PDA which can successfully read in the string \'xz\', where x and z are simply any string conforming to our alphabet.  The PDA P\' would similarly have the ability to read xz, but each state of the PDA could have an additional self loop which reads the character in the string y.</p></li>\n</ol>\n\n<p>I have selected the answer which I find to be most appropriate for this question.  It simply involves using the "tempate PDA" strategy which I outline above; however, my construction did not achieve the goals of the new language (think about why before looking at the answer below).</p>\n', 'ClosedDate': '2014-03-20T11:52:14.493', 'Tags': '<formal-languages><context-free><closure-properties>', 'LastEditorUserId': '14596', 'LastActivityDate': '2014-03-20T15:55:52.117', 'CommentCount': '5', 'AcceptedAnswerId': '22844', 'CreationDate': '2014-03-20T00:24:22.407', 'Id': '22834''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was wondering if this language is context-free:</p>\n\n<p>$L = \\{ x \\in \\{ 0, 1 \\}^* : |x| = 2^n $ for some natural number n $\\}$ </p>\n\n<p>I know that this language is not regular because it fails the pumping lemma for regular languages but that does not necessarily mean it is not context-free. I'm not sure whether to use the pumping lemma for context-free languages to show that this is not context free or to provide context-free grammar to show that it is context free.</p>\n\n<p>I've tried creating a context-free grammar to generate this language but ran into trouble which makes me believe that this language is not context-free, but I am still unsure.</p>\n\n<p>If someone could point me in the right direction that would be greatly appreciated.</p>\n", 'ViewCount': '48', 'Title': 'Is $L = \\{ x \\in \\{ 0, 1 \\}^* : |x| = 2^n $ for some natural number n $\\}$ context free?', 'LastEditorUserId': '15798', 'LastActivityDate': '2014-03-20T04:21:16.400', 'LastEditDate': '2014-03-20T04:11:22.023', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22851', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2014-03-20T03:57:01.143', 'Id': '22850''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The question is simple: </p>\n\n<blockquote>\n  <p>$\\qquad \\operatorname{DropMiddle}(L)=\\{xy\\in\\Sigma^* \\mid |x|=|y| \\land \\exists a\\in\\Sigma\\colon xay\\in L\\}$. </p>\n  \n  <p>Prove that CFL's aren't closed under $\\operatorname{DropMiddle}$.</p>\n</blockquote>\n\n<p>I should probably be looking for a counter example, but I'm coming up short. I know that the language $ww$ ($w$ is a word in some CFL) isn't a CFL, but I can't figure out if I'm on the right track at all.</p>\n", 'ViewCount': '106', 'Title': "Prove that context free languages aren't closed under DropMiddle", 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-21T22:36:11.570', 'LastEditDate': '2014-03-21T22:16:58.467', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22915', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15977', 'Tags': '<formal-languages><context-free><closure-properties>', 'CreationDate': '2014-03-21T15:33:06.103', 'Id': '22905''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having trouble generating the set of strings, which a regular expressions describe.\nA typical regular expression can look like this:</p>\n\n<pre><code>[atom_0] atom_1 (atom_2 | atorm_3 | ... | atom_n-1) &lt;var&gt; [atom_n]\n</code></pre>\n\n<p>Or any other combination of the following:</p>\n\n<pre><code>[], means, that the atom inside of it can be omitted\n(), one of the atoms (seperated by | (stands for OR)) inside the braces can be chosen \n&lt;&gt;, variable.\natom, it can be thought as a constant, which is hard coded.\n</code></pre>\n\n<p>For example: </p>\n\n<pre><code>The [yellow] (dog | cat) named &lt;animalName&gt;\n</code></pre>\n\n<p>This expression describes the following set of strings:</p>\n\n<pre><code>The yellow dog named &lt;animalName&gt;;\nThe yellow cat named &lt;animalName&gt;;\nThe dog named &lt;animalName&gt;;\nThe cat named &lt;animal Name&gt;;\n</code></pre>\n\n<p>The strings can vary, depending on the variable <code>&lt;animalName&gt;</code>, but say, we have two names for <code>&lt;variableName&gt;</code> : <code>Petsy</code> and <code>Rony</code>, then w'll have:</p>\n\n<pre><code>The yellow dog named Petsy;\nThe yellow cat named Petsy;\nThe dog named Petsy;\nThe cat named Petsy;\nThe yellow dog named Rony;\nThe yellow cat named Rony;\nThe dog named Rony;\nThe cat named Rony;\n</code></pre>\n\n<p>Right now, I'm thinking that I could build a tree (or graph) from the expression and then a DFS or BFS can do the job.</p>\n\n<p>Any comments or document/article references would be helpful to me.</p>\n", 'ViewCount': '67', 'Title': 'Generating all strings that a regular expressions describe', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T22:34:20.143', 'LastEditDate': '2014-03-22T11:24:02.187', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22936', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15992', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-03-22T08:30:22.847', 'Id': '22931''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '59', 'Title': 'If $L_1$ is regular and $L_1 \\cap L_2$ context-free, is $L_2$ always context-free?', 'LastEditDate': '2014-03-24T11:49:13.320', 'AnswerCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>If $L_1$ is a regular language and $L_1 \\cap L_2$ is a context-free language, does it mean that $L_2$ is a context-free language too?</p>\n\n<p>I attempted to prove that $L_2$ was not required to be context-free by the following: If $L_1 = \\{ a^n \\}$ and $L_2 = \\{ a^nb^nc^n \\} $ then $L_1 \\cap L_2 = \\{ a^n \\}$ which is context-free. </p>\n\n<p>Is this a counterexample to show that $L_2$ is not required to be context-free? If not, then do you have any suggestions?</p>\n', 'ClosedDate': '2014-03-25T18:31:23.090', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'LastEditorUserId': '31', 'LastActivityDate': '2014-03-24T11:49:13.320', 'CommentCount': '3', 'CreationDate': '2014-03-24T09:23:43.800', 'Id': '22991''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is there a way to take the interection of two NPDAs?</p>\n\n<p>I can't seem to find anything that can make that happen, but it seems like the type of thing that is should be relatively trival.</p>\n", 'ViewCount': '54', 'Title': 'Intersection of two NPDAs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T13:43:12.540', 'LastEditDate': '2014-03-26T08:50:40.920', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23057', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '863', 'Tags': '<formal-languages><automata><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-26T02:34:19.813', 'Id': '23056''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to show that for any language $L \\subseteq \\{ a \\}^* $, $L$ satisfies the pumping lemma for context free languages if and only if it satisfies the pumping lemma for regular languages.</p>\n\n<p>I know that every regular language is also a context free language so I tried to show that direction of the proof first but ran into some difficulties. </p>\n\n<p>Is there a more logical approach to this? Would I have to show that the conditions for both the pumping lemma for regular languages and the pumping lemma for context free grammars are equivalent for this language? </p>\n', 'ViewCount': '62', 'Title': 'Show that the pumping lemmas for context-free and regular languages are equivalent for unary languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T17:35:18.490', 'LastEditDate': '2014-03-26T08:47:34.693', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23091', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2014-03-26T06:50:32.380', 'Id': '23064''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to find a context-free grammar for the following language which uses the alphabet $\\{a, b\\}$\n$$L=\\{a^nb^m\\mid 2n&lt;m&lt;3n\\}$$</p>\n', 'ViewCount': '115', 'ClosedDate': '2014-03-28T13:28:44.503', 'Title': 'Find a context-free grammar for the language $L=\\{a^nb^m\\mid 2n<m<3n\\}$', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-28T13:26:47.350', 'LastEditDate': '2014-03-28T13:17:52.803', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16233', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-03-28T13:00:10.153', 'Id': '23174''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to prove this following theorem, can someone help please?</p>\n\n<p>Let $L$ be a language over the alphabet $\\Sigma = \\{ a,b \\}$.\nIf $L' = \\{ w\\$w^R \\mid w \\in L\\}$ is context-free, then $L$ is regular.</p>\n", 'ViewCount': '92', 'ClosedDate': '2014-03-29T11:31:50.210', 'Title': 'proving that if $\\{w\\$w^R | w \\in L\\}$ is context-free then $L$ is regular', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-29T15:19:39.593', 'LastEditDate': '2014-03-29T02:08:37.950', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16256', 'Tags': '<formal-languages><context-free>', 'CreationDate': '2014-03-28T22:32:54.437', 'Id': '23197''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It seems like the proof that $A_{DFA}$ is decidable in <a href="http://rads.stackoverflow.com/amzn/click/0534950973" rel="nofollow">Sipser (2nd ed.)</a> assumes the computation will halt... and hence only really proves that $A_{DFA}$ is recognizable. </p>\n\n<p>The language $A_{DFA}$ is defined by $A_{DFA} = \\{\\langle B, w \\rangle \\mid B \\text{ is a } \\mathsf{DFA} \\text{ that accepts input string } w \\}$.</p>\n\n<p>Here is the passage (I\'ve bolded the most relevant sentence):</p>\n\n<blockquote>\n  <p>First, let\'s examine the input $\\langle B, w \\rangle$. It is a representation of a $\\mathsf{DFA}$ $B$ together with a string $w$. One reasonable representation of $B$ is simply a list of its five components, $Q$, $\\Sigma$, $\\delta$, $q_0$, and $F$. When $M$ receives its input, $M$ first determines whether it properly represents a $\\mathsf{DFA}$ $B$ and a string $w$. If not, $M$ rejects.</p>\n  \n  <p>Then $M$ carries out the simulation directly. It keeps track of $B$\'s current state and $B$\'s current position in the input $w$ by writing this information down on its tape. Initially, $B$\'s current state is $q_0$ and $B$\'s current input position is the leftmost symbol of $w$. The states and position are updated according to the specified transition function $\\delta$. <strong>When $M$ finishes processing the last symbol of $w$, $M$ accepts the input if $B$ is in an accepting state; $M$ rejects the input if $B$ is in a nonaccepting state.</strong></p>\n</blockquote>\n\n<p>Am I missing something or is this proof bogus?</p>\n\n<p><strong>EDIT</strong>: Never mind, I think I see my problem. A Turing machine may move back and forth, never halting, but an automaton like $B$ given finite input $w$ finishes after $|w|$ steps, correct? So $M$ does halt. Feel free to post an answer explaining this yourself - I don\'t want anyone to miss out on a chance to answer by me deleting the question. If no one responds within a day, I\'ll post an answer myself.</p>\n', 'ViewCount': '35', 'Title': 'Proof that $A_{DFA}$ is decidable in Sipser', 'LastEditorUserId': '12588', 'LastActivityDate': '2014-03-29T18:56:59.760', 'LastEditDate': '2014-03-29T18:56:59.760', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23226', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<formal-languages><finite-automata><undecidability>', 'CreationDate': '2014-03-29T18:04:51.747', 'Id': '23225''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to prove that a language is not $\\omega$-regular. </p>\n\n<p>The language I\'m working with can be defined as:</p>\n\n<p>$$L = \\{ a_1 \\dots a_n x^\\omega ~ | ~ n &gt; 0, a_1 \\dots a_n \\in L^\\prime \\}$$</p>\n\n<p>where $L^\\prime$ is a specific non regular language (I omit the definition $L^\\prime$ because I think it is of no help for my problem), $a_i$ are symbols in $L^\\prime$ alphabet and $x$ is any symbol not in $L^\\prime$ alphabet.</p>\n\n<p>I\'m aware of several proof techniques for proving a language is not regular (see e.g. <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a> ). </p>\n\n<p>Are there similar proof techniques for proving that a language is not $\\omega$-regular?</p>\n', 'ViewCount': '54', 'Title': u'Proving that the continuation of a non-regular language is not \u03c9-regular', 'LastEditorUserId': '14441', 'LastActivityDate': '2014-03-29T23:41:34.323', 'LastEditDate': '2014-03-29T23:41:34.323', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '23235', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14441', 'Tags': '<formal-languages><regular-languages><proof-techniques><buchi-automata>', 'CreationDate': '2014-03-29T18:56:27.080', 'Id': '23227''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>For an assignment in my university, we have to answer multiple choice questions about theoretical computer science. This particular one I find very hard to understand. I wonder if some of you could explain it to me.</p>\n\n<pre><code>In this question, L1, L2, L3, L4 refer to languages and M, M1, M2 refer to Turing machines.  \n</code></pre>\n\n<p>Let  </p>\n\n<pre><code>L1 = {(M1,M2) | L(M1) is a subset of L(M2)},\nL2 = {M | There exists an input on which TM M halts within 100 steps},\nL3 = {M | There exists an input w of size less than 100, such that M accepts w},\nL4 = {M | L(M) contains at least 2 strings}.\n</code></pre>\n\n<p>Decide whether each of L1, L2, L3 and L4 are recursive, RE or neither. Then identify the true statement below.</p>\n\n<pre><code>     a)      The complement of L3 is recursively enumerable.\n     b)      The complement of L2 is recursive.\n     c)      The complement of L2 is not recursively enumerable.\n     d)      L1 is recursively enumerable.\n</code></pre>\n\n<p><strong>What I do not understand is, how the definitions of L1, L2, L3, L4 can tell me whether or not they are recursive (enumerable).</strong> </p>\n\n<p>My guesses (probably wrong) are:</p>\n\n<p>L1: ?</p>\n\n<p>L2: recursive enumerable (I thought this since obviously there are inputs on which the TM halts but we can not say if it halts every time &ndash; therefore only recursive enumerable and not recursive)</p>\n\n<p>L3: recursive enumerable (Same explanation as for L2)</p>\n\n<p>L4: not recursive (This is only a guess, I don't get how the number of minimum strings of the language can imply any type of recursiveness.)  </p>\n", 'ViewCount': '42', 'Title': 'Turing machines and languages -- recursive (enumerable) or not', 'LastEditorUserId': '16286', 'LastActivityDate': '2014-03-30T12:46:48.657', 'LastEditDate': '2014-03-30T12:38:55.190', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16286', 'Tags': '<formal-languages><turing-machines><halting-problem>', 'CreationDate': '2014-03-30T09:58:27.093', 'FavoriteCount': '1', 'Id': '23250''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Every proof I can find of this result is by way of regular expressions. Is there any "constructive" proof that defines the corresponding DFA (probably NFA)? For instance the proof of concatenation closure is most often presented by demonstrating the NFA. I\'m just curious whether this is out there somewhere</p>\n', 'ViewCount': '162', 'Title': 'Does there exist a proof of closure of regular languages under regular substitution by giving the corresponding DFA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-10T06:27:44.253', 'LastEditDate': '2014-03-31T08:21:05.427', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '23623', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><reference-request><finite-automata><closure-properties>', 'CreationDate': '2014-03-30T17:15:21.897', 'Id': '23265''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $P$ be a deterministic PDA recognizing a deterministic CFL with a binary alphabet. Modify $P$ to identify its <em>reading states</em> (denote this subset of states by $R$) in accordance with the construction in Theorem 2.42 in Sipser (3$^{rd}$ edition only) for complementing DPDA. The final states of $P$ are $F\\subset R$, and $\\overline{P}$ recognizing the complement language is given by the same DPDA, but with final states $R-F$. </p>\n\n<p>Combine this with the construction in Lemma 2.59 showing that every DPDA recognizing an end-marked language has an equivalent DCFG. Modify $P$ to have a new accept state $q_\\mbox{accept}$. If $P$ enters a state in $F$ after reading the endmarker, it empties its stack and goes to $q_\\mbox{accept}$. Now do the same with $R-F$ and a new sink state $q_\\mbox{reject}$. </p>\n\n<p>In the grammar $G$ we have a start variable $A_{q_0q_\\mbox{accept}}$ which generates every string that takes $P$ from $q_0$ to $q_\\mbox{accept}$ with empty stack. Let $\\overline{G}$ be a copy of $G$, without renaming the variables, but replace the start state with $A_{q_0q_\\mbox{reject}}$. Then these grammars are both deterministic, and generate complement languages with respect to the portion of the string preceding the endmarker.</p>\n\n<p>Why do this? I think we can show DCFLs with binary alphabets are closed under substitution with an endmarked language and its complement using such a grammar. I think this is not in general the case as otherwise the resulting grammar with substitutions may have a forced handle in the production rules of both substituted grammars. Consider for example the language $\\{w\\mid w\\in\\{0,1\\}^*,\\#_0(w)=\\#_1(w)\\}$. Every string in this language can be extended to one in the complement and vice versa, so there must be strings for which both grammars would be able to match a handle based on just some initial portion of the string. Using the grammar construction described above, there will never be more than one forced handle, and every string will resolve to one of the start symbols. </p>\n\n<p>If this is a legitimate way to construct the complementary grammars, the very restricted closure result follows easily from the determinism of the grammars involved. Can anyone poke some holes in this?   </p>\n', 'ViewCount': '35', 'Title': 'A construction to show a very restricted substitution closure result for DCFLs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T07:42:25.793', 'LastEditDate': '2014-04-01T07:42:25.793', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-31T08:17:43.793', 'Id': '23288''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '73', 'Title': 'Is the language $\\{ a^pb^q \\mid p, q \\text{ are prime} \\}$ regular?', 'LastEditDate': '2014-03-31T18:52:02.587', 'AnswerCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '16317', 'Body': '<p>I am interested to know whether that language $$\nL = \\{ a^pb^q \\mid p, q \\text{ are prime} \\}\n$$ is regular. How do you prove that it is not regular?</p>\n', 'ClosedDate': '2014-03-31T11:40:37.320', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-31T18:52:02.587', 'CommentCount': '2', 'AcceptedAnswerId': '23291', 'CreationDate': '2014-03-31T10:15:30.917', 'Id': '23290''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a homework question about the properties (decidability, Turing-recognizability, etc.) of the language </p>\n\n<p>$$ L = \\{ \\langle M \\rangle | \\text{$M$ is a TM and $M$ accepts some string $w$ which has 101 as a prefix} \\}. $$</p>\n\n<p>I have made an attempt at showing decidability of $L$:</p>\n\n<p>On input $\\langle M, w\\rangle$ (where $M$ is a TM and $w \\in \\sigma^*$):</p>\n\n<ol>\n<li>Simulate $M$ on $w$.</li>\n<li>If $M$ rejects and halts, reject. If $M$ accepts and halts, accept.</li>\n</ol>\n\n<p>However, I'm not sure about moving forward after this. I do not want a solution, but I want some ideas/techniques as to what else I can prove about $L$. </p>\n", 'ViewCount': '85', 'Title': 'The language of TMs accepting some word starting with 101', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-31T23:14:21.683', 'LastEditDate': '2014-03-31T22:38:24.807', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16332', 'Tags': '<complexity-theory><formal-languages><turing-machines><automata>', 'CreationDate': '2014-03-31T21:27:37.883', 'Id': '23300''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have this context-free grammar and I want to find out whether its language is finite or infinite.</p>\n\n<pre><code>S -&gt; XY|bb  Step 1\nX -&gt; XY|SS  Step 2\nY -&gt; XY|SS  Step 3\n</code></pre>\n\n<p>So I would do</p>\n\n<pre><code>S -&gt; XY            From step 1\nS -&gt; YYY           From step 2\nS -&gt; SSYY          From step 3\nS -&gt; SSSSY         From step 3\nS -&gt; SSSSSS        From step 3\nS -&gt; bbSSSSS       From step 1\nS -&gt; bbbbSSS       From step 1\nS -&gt; bbbbbbSSS     From step 1\nS -&gt; bbbbbbbbSS    From step 1\nS -&gt; bbbbbbbbbbS   From step 1\nS -&gt; bbbbbbbbbbbb  From step 1\n\nbbbbbbbbbbbb \n</code></pre>\n\n<p>So I know how to generate words like this but how to find out whether the language is finite or infinite?</p>\n', 'ViewCount': '159', 'Title': "How to find whether a grammar's language is finite or infinite?", 'LastEditorUserId': '8321', 'LastActivityDate': '2014-04-03T14:05:21.387', 'LastEditDate': '2014-04-03T09:22:59.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23368', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><induction>', 'CreationDate': '2014-04-02T20:30:27.960', 'Id': '23367''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Consider two sets: the set of validities of propositional logic and the set of validities of monadic predicate logic. Call the first set $VP$ and the second set $VQM$. Both of these sets are decidable, so there are Turing machines that recognize both them and their complements. </p>\n\n<p>I'm interested in how the decidability of these two sets translates into grammars for them, along the lines of the Chomsky hierarchy. I have three questions:</p>\n\n<p>(1) Are there context-sensitive grammars that generate $VP$ and $VQM$? The answer would be yes if the Turing machines that recognized these sets were linearly bounded, but I don't think they are. </p>\n\n<p>(2) If these languages <em>aren't</em> context-sensitive, can <em>anything</em> be said about a grammar that generates them? </p>\n\n<p>I would have a better grasp of the second question if I understood something about grammars <em>between</em> the top two levels of the Chomsky hierarchy, context-sensitive and unrestricted. </p>\n\n<p>(3) There is a natural class of automata between linear-bounded Turing machines and unrestricted Turing machines: polynomially bounded TMs, exponentially bounded TMs, etc. Do these classes of TM track anything on the grammar side of the Chomsky hierarchy? If not, is there <em>any</em> structure to the gap between context-sensitive grammars and full-on unrestricted grammars?</p>\n\n<p>(Just to be clear: I'm <em>not</em> talking about a grammar for propositional logic, but a grammar for its validities.) </p>\n\n<p>EDIT: I thought I'd add a comment about why I'm interested in these questions. I know there is an unrestricted grammar that generates the (recursively enumerable but not recursive) set of validities of (full-on, polyadic) predicate logic. But since $VP$ and $VQM$ are not just recursively enumerable but recursive, I was wondering if the grammars that generate them might have more structure, in the Chomsky-hierarchy sense, than the grammar that generates the validities of all of predicate logic. <strong>In other words, I'm wondering if there is a <em>grammatical</em> way of detecting the difference between sets of validities that are recursive (as in the case of propositional and monadic predicate logic) and sets of validities that are merely recursively enumerable.</strong> What can be said about grammars of recursive but not recursively enumerable languages? Most references on the Chomsky hierarchy say nothing about this gap, but I don't know if that means there's nothing to be said.</p>\n", 'ViewCount': '35', 'Title': 'grammatical complexity of propositional and monadic predicate validities? (and grammars for recursive but not context-sensitive languages?)', 'LastEditorUserId': '16445', 'LastActivityDate': '2014-04-04T22:33:44.240', 'LastEditDate': '2014-04-04T22:33:44.240', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16445', 'Tags': '<complexity-theory><formal-languages><formal-grammars><logic>', 'CreationDate': '2014-04-04T14:53:25.143', 'FavoriteCount': '1', 'Id': '23423''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '200', 'Title': "I need clarification about DFA's and DFA acceptable languages", 'LastEditDate': '2014-04-05T19:38:55.520', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '16480', 'FavoriteCount': '1', 'Body': "<p>In class yesterday we went over DFA's and DFA acceptable languages.  An example of a language that is not DFA acceptable was given as $\\{ ab, aabb, aaabbb, aaaabbbb, \\ldots \\}$.  The reason given was that the machine would need an infinite amount of states.  </p>\n\n<p>But wouldn't a simple DFA that has only one state that is a final state and loops back to itself on all inputs accept that language?  </p>\n\n<p>Also in class we discussed how the complement of a DFA acceptable language is also DFA acceptable simply by swapping the final states and the non-final states.  But if you had the language $L = \\{ a \\}$, over the alphabet $\\{ a, b \\}$, then obviously $L$ is DFA acceptable, but the complement of $L$ is $\\{ a, b \\}^* - \\{ a \\}$, which includes $\\{ ab, aabb, aaabbb, \\ldots \\}$.</p>\n\n<p>I think I must be misunderstanding something crucial here.  </p>\n", 'Tags': '<formal-languages><finite-automata>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-12T19:46:34.000', 'CommentCount': '4', 'AcceptedAnswerId': '23470', 'CreationDate': '2014-04-05T18:34:32.793', 'Id': '23460''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need a regular language $ L\\subseteq \\{0,1\\}^{*} $ so that $unary(L)$ is not context free.</p>\n\n<p>unary of $L$ is defined by:\n$$unary(L) = \\{0^{1x}  : x \\in L  \\}$$</p>\n\n<p>Example $L = \\{0, 11\\} $ $\\rightarrow  unary(L) = \\{00, 0000000\\}$ </p>\n\n<p>Any help would be great.</p>\n', 'ViewCount': '45', 'ClosedDate': '2014-04-07T06:08:51.163', 'Title': 'a regular language so that $unary(L) \\notin $Context Free Languages', 'LastActivityDate': '2014-04-06T21:26:39.920', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23486', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16502', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2014-04-06T20:06:32.793', 'Id': '23484''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm working with compression algorithms that use context-free grammars (e.g. RE-PAIR and SEQUITUR). These grammars look for frequently occurring digrams (pairs of adjacent symbols) in an input string and use recursive substitution with non-terminal symbols to achieve compression. </p>\n\n<p>What I'm wondering is whether there are classes of grammar and inference methods that are able to exploit sequential patterns that are based on non-adjacent co occurrence. </p>\n\n<p>Take the following input sequence:</p>\n\n<blockquote>\n  <p>XaXbXcYaYbYcZaZbZc</p>\n</blockquote>\n\n<p>No two adjacent symbols co-occur more than once anywhere here, so the sequential compression techniques I mention will not compress this string any further, however there is a clear pattern to the sequence and it must be compressible. How is it possible to do so?</p>\n", 'ViewCount': '74', 'Title': 'Compression of non-adjacent structure using grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-08T21:52:35.873', 'LastEditDate': '2014-04-08T09:05:33.517', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '23548', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12876', 'Tags': '<formal-languages><formal-grammars><data-compression>', 'CreationDate': '2014-04-08T07:49:56.070', 'Id': '23534''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>In an article I am currently reading the grammar</p>\n\n<p><strong>S \u2192 SS | a | \u03b5</strong></p>\n\n<p>is being described as canonical infinitely ambiguous. The infinitely ambiguous part I have no problem recognizing, but does "canonical" mean? Does it mean "typical", "standard example" etc.?</p>\n', 'ViewCount': '21', 'Title': 'Canonical infinitely ambiguous languages', 'LastActivityDate': '2014-04-08T11:06:36.490', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16549', 'Tags': '<formal-languages><terminology>', 'CreationDate': '2014-04-08T10:14:48.200', 'Id': '23541''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Does anyone know any good introductions to Formal Language theory and Formal Grammar, that cover the mathematical basis of Syntax and things like context free grammars and pushdown automata. In particular, I\'d like to be able to understand:</p>\n\n<p>-Parikh\u2019s theorem</p>\n\n<p>-Pentus\' proof that Lambek-calculus grammars define only context-free stringsets</p>\n\n<p>-the theorem of Chandra, Kozen and Stockmeyer</p>\n\n<p>-B\xfbchi\u2019s theorem and Doner\u2019s theorem</p>\n\n<p>Geoffrey Pullum\'s review <a href="http://www.lel.ed.ac.uk/~gpullum/Rev_Kracht.pdf" rel="nofollow">http://www.lel.ed.ac.uk/~gpullum/Rev_Kracht.pdf</a> has put me off reading a book called "The Mathematics of Language" by Markus Kracht, since I am not sure I have the required level of mathematical maturity. He writes:</p>\n\n<p>"Readers of The Mathematical Intelligencer will probably get on with it well enough, but others should be warned that Kracht assumes a lot of mathematical sophistication: graduate students whose first degree is in humanities or social science may experience symbol shock. Kracht does not pamper those who crave intuitive presentations. He will not explain that a finite automaton accepts exactly those strings on which there is a run beginning in the start state and ending in a final state; he will expect you to see that immediately when he tells you (on p.96) that $L(A) = \\{x \\colon~ \\delta(\\{i_0\\},x)\\cap F \\neq \\emptyset\\}$."</p>\n\n<p>The review has also put me off several other introductions:</p>\n\n<p>"W. J. M. Levelt\u2019s truly excellent 3-volume 1974 textbook [6] had remarkably wide coverage (Lev- elt\u2019s psycholinguistic interests lead him to cover work on \u2018learnability\u2019, also known as grammar induction, which Kracht does not touch on), but sadly has long been out of print. And the standard text by Partee, ter Meulen and Wall [9] is now more than fifteen years behind the leading edge of research, especially with respect to grammars and automata. (Though it was published in 1990, the Partee el al. volume reports as open the question of whether the complement of a context-sensitive stringset is always context-sensitive, which was settled in the affirmative in 1987, at Partee\u2019s insti- tution!) Though strong on formal semantics, it completely misses important topics in other areas (parsing and computational complexity, for example), and it looks positively fusty beside Kracht\u2019s much more up-to-date and considerably more mathematical book."</p>\n\n<p>So I\'d be grateful to hear if there are any introductions to this field which people can recommend.</p>\n', 'ViewCount': '62', 'Title': 'Good introductions to Formal Language Theory and Formal Grammars', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-08T23:10:13.477', 'LastEditDate': '2014-04-08T23:10:13.477', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16562', 'Tags': '<formal-languages><context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2014-04-08T18:09:27.717', 'Id': '23557''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I saw the answer in one of the solutions and I cannot figure out how they got the answer. The question is asked if the word is in the language or not for CNF...</p>\n\n<p>How did they get the answer so that ab is in the language and aaaa is not in the language here ?</p>\n\n<pre><code>S -&gt; aSb |ab\n\nab     Yes\naaaa   No\naabb   Yes\n</code></pre>\n\n<p>edit:\nis <code>aaaa No</code> because it has b in <code>aSb</code> and <code>ab</code> is yes because obviously <code>ab</code> is there in <code>aSb |ab</code></p>\n\n<p>also <code>aabb</code> is in the language because of <code>aSb</code> cause you would add same amount of <code>a's</code> and <code>b's</code> to both sides</p>\n", 'ViewCount': '223', 'Title': 'Proving that a word is *not* generated by a context-free grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T23:06:13.337', 'LastEditDate': '2014-04-09T22:54:02.310', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-04-09T21:55:24.510', 'Id': '23609''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In an assignment I\'ve been asked to find a CFG for $a^x b^y a^z b^w$, where, $x,y,z,w \\in \\mathbb{N}^+$, $y &gt; x$, $z &gt; w$, and $x+z = y+w$. A hint was given, think of the language as $(a^p b^p)(b^q a^q)(a^r b^r)$.</p>\n\n<p>I\'ve had a go at it, and have come up with </p>\n\n<ul>\n<li>S -> A </li>\n<li>A -> aAbB | ab  </li>\n<li>B -> bBaC | ba </li>\n<li>C -> aCb | ab</li>\n</ul>\n\n<p>This language will give me equal $a$\'s and $b$\'s. The reason I\'ve chained the productions together is that since $x,y,z,w$ can\'t be 0, when one production is done, the others must be done as well (that was my thinking). However, I can\'t help but be worried about order. Even the smallest production won\'t come out as in the order "abab". Is it possible to construct a CFG that imposes order and memory? Or do I have to go to a PDA then CFG? Or is it irrelevant?</p>\n', 'ViewCount': '54', 'Title': 'Find a CFG for a language', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-10T11:44:40.630', 'LastEditDate': '2014-04-10T11:09:17.643', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '23632', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16625', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-04-10T09:38:39.543', 'Id': '23631''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>Giving the following Grammar:<br></p>\n\n<pre><code>S \u2192 ^ | SaSMSM |  SMSaSM | SMSMSa   \nM \u2192 b | c\n</code></pre>\n\n<p><br>\n^ means eopsilon.</p>\n\n<p>How can i check whether its ambgious or not?\nMy intuition is that its not: every time you derive,the a is placed in different places between the M's.</p>\n\n<p>Can you give me a clue to get a better prove? Or give an example for its ambiguity?<br>\n<br>\nIn other words,Can i have to different derevation trees for a same string in this grammar?\n<br>\nThank you.</p>\n", 'ViewCount': '39', 'Title': 'How to check ambiguity of a specific grammar', 'LastEditorUserId': '16678', 'LastActivityDate': '2014-04-11T11:27:38.387', 'LastEditDate': '2014-04-11T11:01:26.010', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '23670', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16678', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-04-11T10:49:03.413', 'Id': '23669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In proving Parikh's Theorem, my Theory of Computer Science textbook defines a linear set as:</p>\n\n<p>$u_0 + \\langle u_1, \\dots, u_m \\rangle = \\{u_0 + a_1u_1 + \\dots + a_mu_m \\mid a_1, \\dots, a_m \\in \\mathbb{N}\\}$ where $u_i$ are vectors of natural numbers.</p>\n\n<p>and a semi-linear set as a union of finitely many linear sets. It goes on to say ''For every semilinear set $S \\subset N^k$, it is not hard to construct a regular set $R \\subset \\Sigma^*$ such that $\\psi(R) = S$'' (where $\\psi$ is the Parikh map, taking strings over an alphabet $\\Sigma$ to vectors where the first entry is the number of the first letter, the second entry is the number of the second letter, etc. So $\\psi(\\{a, ab, ba, aaa\\})) = \\{(1), (1, 1), (3)\\}$.)</p>\n\n<p>I was trying to think why regular languages would be semi-linear instead of just linear, and it seems like the + (or) operation in regular expressions is to blame. Is this correct: are languages described by regular expressions which use only concatenation and $^*$ linear?</p>\n", 'ViewCount': '38', 'Title': 'Regular expressions and semi-linear sets', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-14T04:01:26.270', 'LastEditDate': '2014-04-14T02:45:44.470', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23775', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15627', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-04-14T01:59:01.303', 'Id': '23768''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am confused regarding the statements provided by one of our faculty regarding \n   "Is it compulsory that every infinite set is non regular \n    though every finite set is a regular set".\nProviding this  example:</p>\n\n<blockquote>\n  <p>$$L= \\{ 0^n 1^n | n&gt;=0 \\} $$     its  formal as $\\Sigma=\\{0,1\\}$ and\n  thus we\'ve a formal meaning as $\\{\\epsilon,01,0011,000111,....\\}$</p>\n\n<pre><code>                               no. of 0\'s = no. of 1\'s \n</code></pre>\n</blockquote>\n\n<p>The above language should be a non-regular as we need to keep track the value of \'n\' in order to make it a equal no, of 0\'s &amp; 1\'s and FA has no memory.</p>\n\n<p>or am i mistaken.</p>\n\n<p>Please, provide some oxygen regarding this confusion.thank you.</p>\n', 'ViewCount': '428', 'Title': 'Is it compulsory that every infinite set be non regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-14T11:16:09.610', 'LastEditDate': '2014-04-14T07:52:31.777', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23777', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10564', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-04-14T04:45:36.133', 'Id': '23776''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m just starting to get into the theory of computation, which studies what can be computed, how quickly, using how much memory and with which computational model.</p>\n\n<p>I have a pretty basic question, but am really hoping some of you guys can help me understand the concept behind it:</p>\n\n<blockquote>\n  <p>Why is everything centered around the notion and definition of\n  LANGUAGES (i.e. regular languages and context free languages)? And how\n  do these relate and describe the complexity of an algorithm and the\n  possible computational models for solving them?</p>\n</blockquote>\n\n<p>I read these sort of related questions:</p>\n\n<ul>\n<li><a href="http://cstheory.stackexchange.com/questions/14811/what-is-the-enlightenment-im-supposed-to-attain-after-studying-finite-automata">What is the enlightenment I&#39;m supposed to attain after studying finite automata?</a></li>\n<li><a href="http://cstheory.stackexchange.com/questions/8539/how-practical-is-automata-theory">How practical is Automata Theory?</a></li>\n</ul>\n\n<p>but still don\'t have an answer to my doubts, since they provide a practical justification of why they are important (which I do understand) but don\'t help me understand why complexity theory is based upon them.</p>\n', 'ViewCount': '674', 'Title': 'Why use languages in Complexity theory', 'LastActivityDate': '2014-04-15T00:26:26.867', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '9', 'OwnerDisplayName': 'Matteo', 'PostTypeId': '1', 'OwnerUserId': '16764', 'Tags': '<complexity-theory><formal-languages>', 'CreationDate': '2014-04-14T16:34:19.947', 'FavoriteCount': '2', 'Id': '23787''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>For $L_1, L_2 $ and $L_1 \\in RE $ and  $ L_1\\notin R$ and $L_2 \\in RE $ and  $ L_2\\notin R$</p>\n\n<p>I was asked to prove/disprove if the following can occur:</p>\n\n<ol>\n<li>$L_1 \\cap L_2 \\in R$</li>\n<li>$L_1 \\cup L_2 \\in R$</li>\n<li>$L_1 \\cap L_2 \\in R$ and $L_1 \\cup L_2 \\in R$</li>\n</ol>\n\n<p>For 1., I think any two disjoint langauges will suffice (because the empty set is decideable).</p>\n\n<p>For 2., I think something along the lines of a language and its complement but I'm struggling to think of an example.</p>\n\n<p>For 3,. it seems impossible but I have no idea how to prove it.</p>\n\n<p>Any help/further insight would be welcomed!</p>\n", 'ViewCount': '95', 'Title': "Intersection/Union of recursively enumerable languages that aren't decidable?", 'LastActivityDate': '2014-04-15T21:19:17.917', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23832', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16769', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2014-04-15T18:58:29.003', 'Id': '23826''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '109', 'Title': 'Proving a language (ir)regular (standard methods have failed)', 'LastEditDate': '2014-04-19T21:26:37.113', 'AnswerCount': '1', 'Score': '7', 'OwnerDisplayName': 'James', 'PostTypeId': '1', 'OwnerUserId': '16922', 'FavoriteCount': '1', 'Body': "<p>I'm currently trying to prove a language regular (for personal amusement). The language is:</p>\n\n<p><em>The language containing all numbers in ternary that have even bit-parity when encoded in binary.</em></p>\n\n<p>Now, I've currently tried a few different approaches that have not led me to any success. I've tried using the pumping lemma (couldn't find anything to pump on), Myhill-Nerode (similar) and even counted the number of strings of each length for which the statement is true (my intuition is that it checks out with a probabilistic argument).</p>\n\n<p>Are their any other approaches that might help here, or are there any intuitions that might be helpful? At this point, my best guess is that the language is not regular, but I don't seem to be able to come up with an explanation.</p>\n", 'Tags': '<formal-languages><regular-languages><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-21T10:31:58.500', 'CommentCount': '3', 'AcceptedAnswerId': '23982', 'CreationDate': '2014-04-19T13:47:36.470', 'Id': '23944''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to construct the small-step semantic rules involving the for-loops, but I can't find anything about it in the literature (only about while-loops).</p>\n\n<p>I was wondering if anyone could help me out with this? This is a first attempt, where $s$ represents a statement and $e$ an expression:</p>\n\n<p>$\\quad \\displaystyle\\sigma, \\text{for } s_1 \\, e_1 \\, e_2 \\, s_2 \\, \\rightarrow \\, \\sigma, \\text{if } e_1 \\text{ then (} s_2 ; \\, e_2; \\, \\text{for } s_1 \\, e_1 \\, e_2 \\, s_2 \\text{ ) else } skip$</p>\n\n<p>Where $\\sigma$ is a local value store, $s_1$ is for example $i = 0$, $e_1$ could equal $i &lt; 4$ and $e_2$ $i=i+1$. </p>\n", 'ViewCount': '27', 'Title': 'Small-step semantics: for-loops', 'LastEditorUserId': '16897', 'LastActivityDate': '2014-04-21T10:32:24.130', 'LastEditDate': '2014-04-21T10:32:24.130', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23983', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16897', 'Tags': '<formal-languages><programming-languages><semantics><operational-semantics><small-step>', 'CreationDate': '2014-04-21T10:18:48.197', 'Id': '23981''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I recently discussed with a friend about a website that proposed regex challenges, mainly matching a group a of words with a special property. He was looking for a regex that matches strings like <code>||||||||</code> where the number of <code>|</code> is prime. I immediatly told him that won\'t ever work because if such a language was regular, the translation of pumping lemma would gives the fact that for a prime $p$ large enough, it exists $k \\leq p$ such that $p + nk$ is prime for all $n \\geq -1$, and well this is not likely to be the case at all (repartition of primes, triviality of such an unknown and crushing property, ...)</p>\n\n<p>But then someone came with the solution : NOT MATCHING <code>(||+?)\\1+</code>\nThis expression tries to match the capture group (that can be <code>||</code>,<code>|||</code>,<code>||||</code> and so on of $k \\geq 2$ occurences of <code>|</code>) $n \\geq 2$ times. If it matches, it means that the number represented by the string is divisible by $k$, and hence is not prime. Otherwise, it is.</p>\n\n<p>And I felt stupid, because it became obvious that grouping and backreference allows regex to be actually a lot more expressive than...regular expression, in the theoritical sense. Now they even added lookarounds and other operators I didn\'t know about when I used to do real regex.</p>\n\n<p>According to Wikipedia, it is even more expressive that languages generated by a context-free grammar. So here is my question :</p>\n\n<ul>\n<li>can we represent any algebraic language (generated from a context-free grammar) with modern regular expression engines </li>\n<li>is there a more general description, or at least an upper bound on the complexity of what kind of languages can be described by a modern regex ?</li>\n</ul>\n\n<p>More pragmatically, is there any serious theory behind it or are we just adding any new features as it comes each time it seems implementable to the initial block of real regular expressions based on finite automata ?</p>\n\n<p>I know that "modern regex" isn\'t very specific while the question is, but I mean at least with backreferences, and possibly more. Of course, if you have partial anwsers assuming certain restrictions on this "modern regex" language, feel free to post it.</p>\n', 'ViewCount': '62', 'Title': 'Expressiveness of modern regular expressions', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-22T18:30:26.273', 'LastEditDate': '2014-04-22T18:30:26.273', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '16992', 'Tags': '<formal-languages><machine-models>', 'CreationDate': '2014-04-22T15:48:24.010', 'Id': '24031''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I came across this notation and I don't know the meaning of it, or if it's a typo:  $\\{$ some set $\\}^{+}$</p>\n\n<p>What does the + mean, i.e., the plus operator applied to a set?</p>\n", 'ViewCount': '75', 'Title': 'What does $\\{$ a set $\\}^{+}$ mean in the context of languages?', 'LastEditorUserId': '755', 'LastActivityDate': '2014-04-25T15:37:18.733', 'LastEditDate': '2014-04-25T15:37:18.733', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24095', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16480', 'Tags': '<formal-languages><terminology><regular-languages><sets>', 'CreationDate': '2014-04-25T05:27:11.613', 'Id': '24094''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can we prove that:</p>\n\n<p>$$\nL = \\{ w_1\\#w_2 \\mid w_1 \\in w_2;\\; |w_2| &gt; |w_1|;\\; w_1 , w_2 \\in \\{0, 1\\}^*\\}\n$$</p>\n\n<p>is not context-free? </p>\n\n<p>The language defines $w_1$ as a sub-string of $w_2$, and they are separated by a $\\#$. This is easy with the CFG pumping-lemma for a slightly different language with $|w_2| \\ge |w_1|$ by using the special case of $|w_2| = |w_1|$ (i.e. $w_1 = w_2$). </p>\n\n<p>But here, $w_1$ is a proper sub-string of $w_2$ so I can't do the same. I fail to push the string out since we can always pump, for example the first symbol of $w_2$.</p>\n", 'ViewCount': '51', 'Title': 'Prove not context free', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-25T14:20:46.833', 'LastEditDate': '2014-04-25T12:55:52.150', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '24104', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8805', 'Tags': '<formal-languages><context-free><proof-techniques><pumping-lemma>', 'CreationDate': '2014-04-25T12:28:16.643', 'Id': '24100''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there a <code>Context-free grammar</code> for the following language:</p>\n\n<p>$L=\\{ x\\#1^m|x \\in \\{0,1\\}^* \\space and \\space the \\space m^{th} \\space char \\space in \\space x \\space is \\space 1 \\}$</p>\n\n<p>If so what is it? Because i couldn\'t find any. I also tried to prove there isn\'t (by the <a href="http://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages" rel="nofollow">Pumping lemma for context-free languages</a>), but it\'s given that a <code>Context-free grammar</code> does exist and I found an error in my "proof".</p>\n\n<p>So what would be the grammar?</p>\n\n<hr>\n\n<p>Here\'s the big picture of my proof:</p>\n\n<p>Let\'s choose $m=n_0$ and take the word $w=0^{n_0}1\\#1^{n_0+1}$ (so that $x$ is what\'s on the left side of $\\#$) .</p>\n\n<p>According to the lemma, $w$ can be written as $uvxyz$ and some conditions hold...</p>\n\n<p>$|vxy| \\leq n_0$</p>\n\n<p>therefor, $vxy$ include only zeros ($0$\'s).</p>\n\n<p>Now let\'s choose <code>k=2</code> and pump it up:</p>\n\n<p>we get: $w_2=uv^2xy^2z$</p>\n\n<p>which means, the number of $0$\'s is now:</p>\n\n<p>$n_0 + |v| + |y| \\geq n_0 + 1$</p>\n\n<p>(since $|vy| \\geq 1$) .</p>\n\n<p>Hence, the $m$th number (the $n_0$th in our case) is not $1$. It\'s actually $0$.</p>\n\n<p>Hence, $w_2$ doesn\'t belong to $L$. Contradiction.</p>\n\n<p>Hence, $L$ isn\'t <code>Context-free</code>.</p>\n\n<hr>\n\n<p>I think i know where\'s my mistake in the proof:</p>\n\n<p>$vxy$ isn\'t necessarily only $0$\'s. It could have the last $n_0-1$ zero\'s and a $1$.</p>\n', 'ViewCount': '45', 'Title': 'Is there a Context-free grammar for this language?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-27T11:26:19.710', 'LastEditDate': '2014-04-27T11:26:19.710', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24144', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7931', 'Tags': '<formal-languages><context-free><pumping-lemma>', 'CreationDate': '2014-04-26T20:58:30.470', 'Id': '24140''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The exercise says </p>\n\n<p>"Show that the grammar $G = \\langle\\{S\\}, \\{a, b\\}, S, \\{S \\to \\lambda, S \\to aSb\\}\\rangle$ \ngenerates the language $L = \\{a^i b^i \\mid i = 0, 1, 2, \\ldots\\}$."</p>\n\n<p>Now, I\'m new to this subject although I\'m familiar with the theory of Turing machines and automata. I\'m teaching myself (not in a class, completely independently) from scratch. Please go easy on me.</p>\n\n<p>Now, two questions:</p>\n\n<p>(1) I suspect the way to do this proof is by induction on $i$, which is to say induction on the iterations of letters in the alphabet or the length of the word formed by iterations of $a, b$. <strong><em>Is this assumption correct?</em></strong></p>\n\n<p>(2) If the assumption in (1) is not correct, what <strong><em>is</em></strong> the correct strategy?</p>\n', 'ViewCount': '81', 'Title': 'A Question from Introduction to Formal Languages by Gyorgy E. Revesz; Exercise 1.1', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-28T03:02:00.173', 'LastEditDate': '2014-04-28T03:00:51.613', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '17107', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-04-28T02:42:37.180', 'FavoriteCount': '1', 'Id': '24170''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>You have a description of a language that you have to prove is regular, context free, or other. In order to prove that it does <em>not</em> belong to a certain class of languages, you might think that it will be more convenient to prove it by using a subset of that language. The problem is that a subset of a language does not necessarily belong to the same language class as the superset language. For example: with $\\Sigma = \\{0,1\\}$, $\\Sigma^*$ is a regular language, while $ A = \\{ 0^n1^n \\mid n \\geq 0\\} \\subseteq \\Sigma^* $ is a context free language. </p>\n\n<p>(<a href="http://math.stackexchange.com/questions/718141/prove-or-disprove-that-the-language-l-1-anbm-mid-n-m-is-regular">I have fallen in the trap</a> of trying to use subsets of languages in order to try to prove that they belong to a certain class of languages.)</p>\n\n<p>An example:</p>\n\n<blockquote>\n  <p>Let $\\Sigma = \\{0,1\\} $ and $L = \\{ w \\in \\Sigma^* \\mid \\text{w contains less 1\'s than 0\'s} \\}$</p>\n  \n  <p>Is $L$ regular, context free, or neither?</p>\n</blockquote>\n\n<p>My intuition says that it is not regular, since finite state machines <em>can\'t count</em>. I think it is context free. </p>\n\n<p>The strategy I\'m thinking of is to show that this language is context free:</p>\n\n<blockquote>\n  <p>$ L_2 = \\{ 0^n1^m \\mid n \\gt m\\}$</p>\n</blockquote>\n\n<p>This language is clearly a proper subset of $L$. But, like we\'ve seen, that may not be a very useful fact if we want to prove things about the proper superset (to my understanding). It <em>seems</em> that $L_2$ is <em>easier</em> to generate than $L$: it seems easier to count how many consecutive 0\'s there are rather than counting the number of 0\'s in a string. (Especially if you consider using a PDA to count it, since then it just boils down to pushing consecutive 0\'s and then popping when you start seeing 1\'s, accepting the language if there are 0\'s left on the stack when you have consumed the word.) Consequently, if this intuition of <em>hardness</em> is correct, then $L$ is at least not regular. But then another problem reveals itself; maybe $L$ is not context free? So then you have at least shown it to not be regular, but you still have to show that it is context free or not.</p>\n\n<p>This is not the only problem for which I want to use this strategy. For example:</p>\n\n<blockquote>\n  <p>$L_p = \\{ w \\in \\Sigma^* \\mid \\text{the number of 0\'s in w is prime}\\}$</p>\n</blockquote>\n\n<p>Here I think it might be more convenient to use something like the Pumping Lemma on this language:</p>\n\n<blockquote>\n  <p>$L_{p2} = \\{ 0^n \\mid \\text{n is prime}\\}$</p>\n</blockquote>\n\n<p>Is this kind of strategy valid?</p>\n', 'ViewCount': '58', 'Title': 'Proving that a language does not belong to a language class by using more specific instances of that language', 'LastEditorUserId': '11089', 'LastActivityDate': '2014-05-01T13:28:48.180', 'LastEditDate': '2014-05-01T13:28:48.180', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '24181', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11089', 'Tags': '<formal-languages><proof-techniques>', 'CreationDate': '2014-04-28T09:54:09.097', 'Id': '24180''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How would I go about making a Turing machine to accept the following language L?</p>\n\n<p>$$L = \\{ www \\mid w = \\{0,1\\}^* \\text{ and } w &gt; 0\\}$$</p>\n\n<p>I was thinking counting the number of symbols in the input string and then dividing by three to find the beginning of each instance of <em>w</em> and then testing if each instance is the same, but this seems a bit roundabout. </p>\n\n<p>I feel like there is a way by marking the first three symbols and then moving the 2nd and 3rd markers until the strings in between them are the same but I'm having a hard time articulating this into an algorithm.</p>\n\n<p>Can anyone point me in the right direction?</p>\n", 'ViewCount': '45', 'Title': 'Turing machine with repeated strings', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T10:19:18.573', 'LastEditDate': '2014-04-29T10:19:18.573', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24214', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14950', 'Tags': '<formal-languages><turing-machines><automata><strings>', 'CreationDate': '2014-04-28T13:35:58.237', 'Id': '24184''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am trying to extend an existing UTP theory package(Isabelle/UTP) by introducing a new type for use in encoding a custom framework built on UTP. <code>MkName</code> is a type constructor, <code>fset</code> basically restricts <code>VAR</code> to finite sets. The type <code>@{term "UTYPE"}</code> consists of the set of types which, according to the typing relation, have at least one defined value. <code>WF_PREDICATE_OVER</code> calculates all predicates which satisfy the given argument(alphabet). <code>\u03c0 p = snd(WF_ALPHA_PREDICATE)</code> . <code>&lt;_&gt;\u21e9f</code> is <code>Rep</code> function for <code>fset</code>.  <code>\u03b9\u03c0 p = snd(WF_ALPHA_PREDICATE)</code></p>\n\n<pre><code>(*--------- from Isabelle/UTP package -------*)\n\ndefinition fsets :: "\'a set set" where "fsets = Collect finite"\ntypedef \'a fset = "fsets :: \'a set set"  by (auto simp add:fsets_def)\nnotation Rep_fset ("&lt;_&gt;\u21e9f")    \n\nclass DEFINED = fixes Defined   :: "\'a \u21d2 bool" ("D")\ndefinition "UTYPES (x::\'a itself) = {t. \u2203 v :: \'a. v :\u21e9u t \u2227 D v}"\ntypedef \'VALUE UTYPE = "UTYPES TYPE(\'VALUE)"    \n\ndatatype NAME = MkName string nat\n\ntype_synonym \'VALUE VAR = "NAME \xd7 \'VALUE UTYPE \xd7 bool"\ndefinition VAR :: "\'VALUE VAR set" where "VAR = UNIV"\n\ntype_synonym \'VALUE ALPHABET = "(\'VALUE VAR) fset"\ntype_synonym \'VALUE ALPHA_PREDICATE = "(\'VALUE ALPHABET) \xd7 \'VALUE WF_PREDICATE"\n\ntype_synonym \'VALUE BINDING = "(\'VALUE VAR) \u21d2 \'VALUE"\ntypedef \'VALUE WF_BINDING   = "WF_BINDING :: \'VALUE BINDING set"\ntypedef \'VALUE WF_PREDICATE = "UNIV :: \'VALUE WF_BINDING set set"\n\ndefinition WF_ALPHA_PREDICATE :: "\'VALUE ALPHA_PREDICATE set" where\n    "WF_ALPHA_PREDICATE = {(a,p) | a p . p \u2208 WF_PREDICATE_OVER &lt;a&gt;\u21e9f}"\n\ntypedef \'a WF_ALPHA_PREDICATE = "WF_ALPHA_PREDICATE :: \'a ALPHA_PREDICATE set"\n\n\n(*--------- My Code -------*)\ntype_synonym \'VALUE LA_PREDICATE = "(\'VALUE ALPHABET) \xd7 (\'VALUE WF_ALPHA_PREDICATE)"\n\ndefinition WF_LA_PREDICATE :: "\'VALUE LA_PREDICATE set" where\n"WF_LA_PREDICATE = {(a::\'VALUE ALPHABET, p::\'VALUE WF_ALPHA_PREDICATE) | a p . \n       (\u03c0 p) \u2208 WF_PREDICATE_OVER (VAR - &lt;a&gt;\u21e9f) }" \n\ntypedef \'VALUE WF_LA_PREDICATE = "WF_LA_PREDICATE :: \'VALUE LA_PREDICATE set"\n\nlift_definition Exists1 ::\n  "\'VALUE ALPHABET \u21d2 \'VALUE WF_LA_PREDICATE \u21d2 \'VALUE WF_LA_PREDICATE" is\n  "\u03bb a p . ( \u03b1 p, \u2203\u21e9\u03b1 Abs_fset(VAR) -\u21e9f a .  \u03b9\u03c0 p)"\n</code></pre>\n\n<p>The lift definition results in the following error.</p>\n\n<p>Lifting failed for the following types:\nRaw type:  (NAME \xd7 \'a UTYPE \xd7 bool) fset \xd7 \'a WF_ALPHA_PREDICATE\nAbstract type:  \'VALUE WF_LA_PREDICATE</p>\n\n<p>Reason:\n  The <em>quotient type</em> "\'VALUE WF_LA_PREDICATE" and the <em>quotient type pattern</em> "?\'a WF_LA_PREDICATE"  don\'t match.</p>\n\n<p>What would be a valid definition for Exists1???\nWhat is the syntax I\'m writing wrong? </p>\n', 'ViewCount': '25', 'ClosedDate': '2014-04-29T22:32:36.733', 'Title': "Isabelle : quotient type and quotient type pattern don't match", 'LastActivityDate': '2014-04-29T14:15:04.437', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17180', 'Tags': '<formal-languages><type-theory><functional-programming><type-inference><type-checking>', 'CreationDate': '2014-04-29T14:15:04.437', 'Id': '24223''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need help with this exercise. </p>\n\n<p>Indicate the regular expression for the following Languages. Explain your  expression in one sentence and indicate the basis form of the alphabet. Indicate also every assumption you make.</p>\n\n<p>i) Sums of positive fixed-point decimal numbers. The following Strings should exist in the Language: </p>\n\n<p>e.g: 3.14 or also 3 + 4.2 + 7 + 1</p>\n\n<p>I have a couple more exersices that are pretty similar but I guess if I get to understand this exercise I could try to do the others faster.</p>\n\n<p>I appreciate the help in advance. </p>\n', 'ViewCount': '31', 'ClosedDate': '2014-04-29T22:32:59.837', 'Title': 'regular expression: sum of positive fixed point decimal numbers', 'LastActivityDate': '2014-05-01T21:12:01.907', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '24227', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16960', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2014-04-29T16:13:53.143', 'Id': '24226''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m working on a paper and would like to review the origins of <a href="http://en.wikipedia.org/wiki/Kleene_star">Kleene\'s closure</a>. I am unable to find any article of Kleene\'s that has the original definition of the Kleene closure.</p>\n\n<p>Is there a paper by Kleene in which he first defines the Kleene closure?</p>\n', 'ViewCount': '74', 'Title': 'Where/when did Stephen Kleene first define the Kleene closure/star?', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-04-30T07:25:55.133', 'LastEditDate': '2014-04-30T07:25:55.133', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '17192', 'Tags': '<formal-languages><reference-request><automata>', 'CreationDate': '2014-04-29T21:40:11.143', 'Id': '24237''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '28', 'Title': 'Constructing an unrestricted grammar for a^n b^m c^n d^m', 'LastEditDate': '2014-05-02T23:52:33.843', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17197', 'Body': "<p>I've been trying to construct an unrestricted grammar which has the language:</p>\n\n<p><code>L = {a^n b^m c^n d^m | n&gt;0, m&gt;0}</code></p>\n\n<p>But I can't seem to figure it out without making the derivations run an unreasonably long amount of time.  Can anyone help me devise an elegant way to create this grammar?</p>\n\n<p>Edit: In order to clarify, I was trying to find an Unrestricted Grammar that would run in <code>O(n^2)</code> time or better.  As it stood, all of my solutions were exponential, which made parsing very long strings prohibitively costly.</p>\n", 'ClosedDate': '2014-04-30T17:24:56.633', 'Tags': '<formal-languages><formal-grammars>', 'LastEditorUserId': '17197', 'LastActivityDate': '2014-05-02T23:52:33.843', 'CommentCount': '2', 'AcceptedAnswerId': '24244', 'CreationDate': '2014-04-29T23:39:58.147', 'Id': '24243''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '28', 'Title': 'How does one figure out where a class of languages falls under some complexity class?', 'LastEditDate': '2014-04-30T17:33:52.967', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Body': '<p><img src="http://i.imgur.com/fKkk9Aq.png" alt="enter image description here"></p>\n\n<p>I was wondering how can someone prove that one class of languages is of a certain complexity? For example, how could I show the Turing-recognizable languages are in P?</p>\n\n<p>Would I have to come up with an algorithm that runs in deterministic polynomial time?</p>\n', 'ClosedDate': '2014-05-02T12:48:31.513', 'Tags': '<complexity-theory><formal-languages><proof-techniques>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-30T17:33:52.967', 'CommentCount': '1', 'AcceptedAnswerId': '24257', 'CreationDate': '2014-04-30T14:20:55.117', 'Id': '24256''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to write a regular expression for some particular license plates. They consist of one up to three capital letters, a hyphen, one up to two capitol letters and one up to four numbers. The license plate should not exceed the 8 symbols.</p>\n\n<p>Example: AA-AA123</p>\n\n<p>What I have until now is the following:</p>\n\n<p>because there has to be at least one letter before the hyphen, I have this expression for the first letter:\n$$\nP = (A\\cup B \\cup...\\cup Z)\n$$</p>\n\n<p>For the second letter:\n$$\nD = (A\\cup B \\cup...\\cup Z\\cup empty)\n$$\nempty indicates the possibility that there could not be a letter.</p>\n\n<p>For the numbers is basically almost the same procedure:\n$$\nE = (1\\cup 2 \\cup...\\cup 9)\n$$\n$$\nF = (1\\cup 2 \\cup...\\cup 9 \\cup empty)\n$$</p>\n\n<p>now for my explicit expression I think the answer would be:\n$$\nK= PDD^* - PDEF^*F^*\n$$</p>\n\n<p>but I'm not quite sure. I think this means I have 8 symbols, at least one letter before the hyphen but I could have up to three, the hyphen (that is a must), at least one letter after the hyphen but up to two and at least one number but I could have up to 4.</p>\n\n<p>Something tells me I have something wrong here, I'm still new in the regular expressions world and I appreciate any help I could get in advance.</p>\n", 'ViewCount': '71', 'Title': 'regular expression in license plates', 'LastActivityDate': '2014-05-01T20:37:52.770', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16960', 'Tags': '<formal-languages><regular-expressions>', 'CreationDate': '2014-05-01T11:14:52.227', 'Id': '24293''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A few years ago, I read a paper that gave me a deeper understanding of ecological data (<a href="https://bcrc.bio.umass.edu/courses/fall2010/grad/micbio697b/sites/default/files/madin_2008.pdf" rel="nofollow">Madin et al, 2008</a>). More recently, I read a paper in PLOS-ONE (<a href="https://dx.doi.org/10.1371/journal.pone.0091001" rel="nofollow">Villa et al 2014</a>) that describes a particularly powerful a software based on ontologies.</p>\n\n<p>I find both of these papers informative, engaging, and useful. I and others have applied concepts from the first paper to database design, and the new programming language in the second paper seems useful. So I was surprised when a colleague (senior math faculty at an R1 university) told me that he scoffed that "Ontology" was a bogus field, in the same vein as astrology and homeopathy.</p>\n\n<p>When presented these two papers from my field, he called the first a "typical example of bogus research" and the second "valid attempt to do meaningful research within a failed framework". He pointed to two compelling graphs from Google Trends, one for "semantic web" and one for "web ontology language". I know this isn\'t peer-reviewed, but it is straightforward evidence that interest in these topics (or at least these specific terms) is waning. Here is a similar query:</p>\n\n<p><img src="http://i.stack.imgur.com/bPkCV.png" alt="enter image description here"></p>\n\n<p>I would appreciate additional background so that I can better understand my colleague\'s perspective. Are there any references that would provide me with historical context and a background for understanding the limitations of research on and applications of Ontology?</p>\n', 'ViewCount': '61', 'ClosedDate': '2014-05-03T09:41:47.747', 'Title': 'Why is interest in the fields of ontology and semantics declining?', 'LastActivityDate': '2014-05-03T09:41:37.610', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '2', 'OwnerDisplayName': 'Bob The Builder', 'PostTypeId': '1', 'OwnerUserId': '17286', 'Tags': '<reference-request><formal-languages><programming-languages><semantics>', 'CreationDate': '2014-05-01T02:44:51.360', 'FavoriteCount': '1', 'Id': '24298''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If I informally define a language like this: Use an alphabet that consists of a-z, plus (). The language consists of any string from that alphabet where:</p>\n\n<p>No subsequence of the string that begins with ( and ends with ) reoccurs. In other words:</p>\n\n<p>(this)(this) is not in the language.\nthisthis would be, as would (this)this or (this)(that).</p>\n\n<p>Is this language provably context-sensitive? Or conversely, not context-sensitive?</p>\n', 'ViewCount': '13', 'ClosedDate': '2014-05-02T12:48:56.067', 'Title': 'What class of formal language: forbid repitition of a subsequence', 'LastActivityDate': '2014-05-01T19:05:51.893', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17258', 'Tags': '<formal-languages>', 'CreationDate': '2014-05-01T19:05:51.893', 'Id': '24299''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}