{'Body': '<p>I am trying to search for an algorithm that can tell me which node has the highest download (or upload) capacity given a weighted directed graph, where weights correspond to individual link bandwidths. I have looked at the maximal flow problem and at the Edmond-Karp algorithm. My questions are the following: </p>\n\n<ol>\n<li>Edmond-Karp just tells us how much throughput we can get (at the sink) from source to sink if any of the paths were used. Correct?</li>\n<li>Edmond-Karp does not tell us which path can give us the maximum flow. Correct?</li>\n</ol>\n', 'ViewCount': '473', 'Title': 'Finding the maximum bandwidth along a single path in a network', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:52:42.887', 'LastEditDate': '2012-06-10T11:42:16.480', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '1639', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1289', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2012-04-30T14:17:06.293', 'Id': '1591''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1918', 'Title': 'Reducing minimum vertex cover in a bipartite graph to maximum flow', 'LastEditDate': '2012-11-09T11:07:26.610', 'AnswerCount': '2', 'Score': '7', 'OwnerDisplayName': 'Summer_More_More_Tea', 'PostTypeId': '1', 'OwnerUserId': '1727', 'FavoriteCount': '1', 'Body': '<p>Is it possible to show that the minimum vertex cover in a bipartite graph can be reduced to a maximum flow problem? Or to the minimum cut problem (then follow max-flow min-cut theorem, the claim holds).</p>\n\n<p>Intuitively: for each flow, pick one endpoint, then it is a minimum vertex cover in bipartite graph. But can it be shown rigorously?</p>\n', 'Tags': '<complexity-theory><graph-theory><reductions><network-flow>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-09T11:07:26.610', 'CommentCount': '0', 'CreationDate': '2012-06-03T02:37:49.540', 'Id': '2208''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>We want to solve a minimal-cost-flow problem with a generic negative-cycle cancelling algorithm. That is, we start with a random valid flow, and then we do not pick any "good" negative cycles such as minimal average cost cycles, but use Bellman-Ford to discover a minimal cycle and augment along the discovered cycle. Let $V$ be the number of nodes in the graph, $A$ the number of edges, $U$ the maximal capacity of an edge in the graph, and $W$ the maximal costs of an edge in the graph. Then, my learning materials claim: </p>\n\n<ul>\n<li>The maximal costs at the beginning can be no more than $AUW$ </li>\n<li>The augmentation along one negative cycle reduces the costs by at least one unit </li>\n<li>The lower bound for the minimal costs is 0, because we don\'t allow negative costs </li>\n<li>Each negative cycle can be found in $O(VA)$ </li>\n</ul>\n\n<p>And they follow from it that the algorithm\'s complexity is $O(V\xb2AUW)$. I understand the logic behind each of the claims, but think that the complexity is different. Specifically, the maximal number of augmentations is given by one unit of flow per augmentation, taking the costs from $AUW$ to zero, giving us a maximum of $AUW$ augmentations. We need to discover a negative cycle for each, so we multiply the maximal number of augmentations by the time needed to discover a cycle ($VA$) and arrive at $O(A\xb2VUW)$ for the algorithm. </p>\n\n<p>Could this be an error in the learning materials (this is a text provided by the professor, not a student\'s notes from the course), or is my logic wrong? </p>\n', 'ViewCount': '258', 'Title': u'Why is the complexity of negative-cycle-cancelling $O(V\xb2AUW)$?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-06T00:47:27.197', 'LastEditDate': '2012-06-10T11:42:45.650', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1717', 'Tags': '<algorithms><graph-theory><algorithm-analysis><runtime-analysis><network-flow>', 'CreationDate': '2012-06-08T13:26:38.437', 'FavoriteCount': '1', 'Id': '2283''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In Cormen et. al., <em>Introduction to Algorithms</em> (3rd ed.), I don't get a line in the proof of Lemma 26.1  which states that the augmented flow $f\\uparrow f'$ is a flow in $G$ and is s.t. $|f\\uparrow f'| =|f|+|f'|$ (this is pp. 717-718).</p>\n\n<p>My confusion: When arguing <em>flow-conservation</em> they use the definition of $f\\uparrow f'$ in the first line to say that for each $u\\in V\\setminus\\{s,t\\}$</p>\n\n<p>$$ \\sum_{v\\in V} (f\\uparrow f')(u,v) = \\sum_{v\\in V} (f(u,v)+f'(u,v) - f'(v,u)), $$</p>\n\n<p>where the augmented path is defined as</p>\n\n<p>$$ (f\\uparrow f')(u,v) = \\begin{cases} f(u,v)+f'(u,v) - f'(v,u) &amp; \\text{if $(u,v)\\in E$}, \\\\\n0 &amp; \\text{otherwise}. \\end{cases} $$</p>\n\n<p>Why can they ignore the 'otherwise' clause in the summation? I don't think the first clause evaluates to zero in all such cases. Do they use flow-conservation of $f$ and $f'$ in some way?</p>\n", 'ViewCount': '273', 'Title': "CLRS - Maxflow Augmented Flow Lemma 26.1 - don't understand use of def. in proof", 'LastEditorUserId': '1964', 'LastActivityDate': '2012-06-25T23:11:59.127', 'LastEditDate': '2012-06-25T23:11:59.127', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2494', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1964', 'Tags': '<algorithms><network-flow>', 'CreationDate': '2012-06-25T17:14:37.713', 'Id': '2492''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know why and how the <a href="https://en.wikipedia.org/wiki/Push-relabel_algorithm" rel="nofollow">push relabel algorithm</a> works for solving the max-flow problem. But why is a global update step required? </p>\n', 'ViewCount': '224', 'Title': 'Reason for global update steps in the push-relabel algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-20T15:50:51.657', 'LastEditDate': '2012-07-20T15:50:51.657', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'user997704', 'PostTypeId': '1', 'OwnerUserId': '2212', 'Tags': '<algorithms><graph-theory><network-flow>', 'CreationDate': '2012-07-18T09:27:04.577', 'Id': '2819''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m trying to find the Maximum Independent Set of a Biparite Graph.</p>\n\n<p>I found this in some notes <strong>"May 13, 1998 - University of Washington - CSE 521 - Applications of network flow"</strong>:</p>\n\n<blockquote>\n  <p><strong>Problem:</strong></p>\n  \n  <p>Given a bipartite graph $G = (U,V,E)$, find an independent set $U\' \\cup V\'$ which is as large as possible, where $U\' \\subseteq U$ and $V\'\n&gt; \\subseteq V$. A set is independent if there are no edges of $E$ between\n  elements of the set.</p>\n  \n  <p><strong>Solution:</strong></p>\n  \n  <p>Construct a flow graph on the vertices $U \\cup B \\cup \\{s,t\\}$. For\n  each edge $(u,v) \\in E$ there is an infinite capacity edge from $u$ to\n  $v$. For each $u \\in U$, there is a unit capacity edge from $s$ to $u$,\n  and for each $v \\in V$, there is a unit capacity edge from $v$ to\n  $t$.</p>\n  \n  <p>Find a finite capacity cut $(S,T)$, with $s \\in S$ and $t \\in T$. Let\n  $U\' = U \\cap S$ and $V\' = V \\cap T$. The set $U\' \\cup V\'$ is\n  independent since there are no infinite capacity edges crossing the\n  cut.  The size of the cut is $|U - U\'| + |V - V\'| = |U| + |V| - |U\' \\cup V\'|$. This, in order to make the independent set as large as\n  possible, we make the cut as small as possible.</p>\n</blockquote>\n\n<p>So lets take this as the graph:</p>\n\n<pre><code>A - B - C\n    |\nD - E - F\n</code></pre>\n\n<p>We can split this into a bipartite graph as follows $(U,V)=(\\{A,C,E\\},\\{B,D,F\\})$</p>\n\n<p>We can see by brute force search that the sole Maximum Independent Set is $A,C,D,F$. Lets try and work through the solution above:</p>\n\n<p>So the constructed flow network adjacency matrix would be:</p>\n\n<p>$$\\begin{matrix}\n      &amp; s &amp; t &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F \\\\\n    s &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\\n    t &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\\n    A &amp; 1 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n    B &amp; 0 &amp; 1 &amp; \\infty &amp; 0 &amp; \\infty &amp; 0 &amp; \\infty &amp; 0 \\\\\n    C &amp; 1 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n    D &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 \\\\\n    E &amp; 1 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 &amp; \\infty &amp; 0 &amp; \\infty \\\\\n    F &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 \\\\\n\\end{matrix}$$</p>\n\n<p>Here is where I am stuck, the smallest finite capacity cut I see is a trivial one: $(S,T) =(\\{s\\},\\{t,A,B,C,D,E,F\\})$ with a capacity of 3.</p>\n\n<p>Using this cut leads to an incorrect solution of:</p>\n\n<p>$$ U\' = U \\cap S = \\{\\}$$\n$$ V\' = V \\cap T = \\{B,D,F\\}$$\n$$ U\' \\cup V\' = \\{B,D,F\\}$$</p>\n\n<p>Whereas we expected $U\' \\cup V\' = \\{A,C,D,F\\}$?  Can anyone spot where I have gone wrong in my reasoning/working?</p>\n', 'ViewCount': '2163', 'Title': 'Maximum Independent Set of a Bipartite Graph', 'LastActivityDate': '2013-08-27T14:52:52.030', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '3033', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1577', 'Tags': '<algorithms><graph-theory><network-flow>', 'CreationDate': '2012-08-03T19:21:39.403', 'FavoriteCount': '1', 'Id': '3027''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Suppose that we redefine the residual network to disallow edges into $s$. Argue that the procedure FORD-FULKERSON still correctly computes a maximum flow.  </p>\n</blockquote>\n\n<p>I was thinking that when we augment a path the residual capacity of reverse edge increases and can be used to decrease the flow in that edge (but overall increase the network flow) if needed. So if we disallow the edges into $s$ that means we are not allowing decrease in flow in edges $s\\to x$ ($x$ is the adjacent node to $s$). So in the case when we allow edges into $s$ we can have a cycle like </p>\n\n<p>$\\qquad \\displaystyle s \\to x_1 \\leadsto y \\leadsto x_2 \\to s \\to x_3 \\leadsto t$.  </p>\n\n<p>But if we disallow edges into $s$ again we can find the same path with out the cycle. All the above are intuitive ideas but I want a formal proof.  </p>\n\n<p>The question is from <em>Introduction to Algorithms</em> by Cormen et al.</p>\n', 'ViewCount': '356', 'Title': 'A variation in Ford-Fulkerson algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-02T13:17:51.197', 'LastEditDate': '2012-09-02T13:17:51.197', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2589', 'Tags': '<algorithms><graph-theory><network-flow><correctness-proof>', 'CreationDate': '2012-09-02T12:01:27.050', 'Id': '3400''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>For directed graph $(G=(V, E),s,t,{Ce})$ in which we want to maximize max flow. All edge capacities are at least one. Define the capacity of an $s \\to t$ path to be the smallest capacities of constituent edges. The fastest path from $s$ to $t$ is the path with the most capcity.</p>\n\n<p>b) Show that the fastest path from $s$ to $t$ in a graph can be computed by Dijkstra's algorithm.</p>\n\n<p>c) Show that the maximum flow in $G$ is the sum of individual flows along at most $|E|$ paths from $s$ to $t$.</p>\n\n<p>It's one of the questions from my algorithms assignment, and I figured out (a), but can't get these two above.</p>\n", 'ViewCount': '418', 'Title': "Dijskstra's algorithm, maximum flow", 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-11T17:50:53.390', 'LastEditDate': '2012-11-09T22:10:28.233', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '4523', 'Tags': '<algorithms><graphs><optimization><shortest-path><network-flow>', 'CreationDate': '2012-11-09T19:31:05.533', 'Id': '6586''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1322', 'Title': 'Finding negative cycles for cycle-canceling algorithm', 'LastEditDate': '2012-11-20T09:31:55.460', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '4', 'Body': '<p>I am implementing the cycle-canceling algorithm to find an optimal solution for the min-cost flow problem. By finding and removing negative cost cycles in the residual network, the total cost is lowered in each round. To find a negative cycle I am using the bellman-ford algorithm.</p>\n\n<p>My Problem is:\nBellman-ford only finds cycles that are reachable from the source, but I also need to find cycles that are not reachable.</p>\n\n<p>Example: In the following network, we already applied a maximum flow. The edge $(A, B)$ makes it very expensive. In the residual network, we have a negative cost cycle with capacity $1$. Removing it, would give us a cheaper solution using edges $(A, C)$ and $(C, T)$, but we cannot reach it from the source $S$.</p>\n\n<p>Labels: Flow/Capacity, Cost</p>\n\n<p><img src="http://i.stack.imgur.com/jKtUd.png" alt="enter image description here"></p>\n\n<p>Of course, I could run Bellman-ford repeatedly with each node as source, but that does not sound like a good solution. I\'m a little confused because all the papers I read seem to skip this step.</p>\n\n<p>Can you tell me, how to use bellman-ford to find every negative cycle (reachable or not)?\nAnd if not possible, which other algorithm do you propose?</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path><network-flow>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-20T17:17:58.753', 'CommentCount': '3', 'AcceptedAnswerId': '6789', 'CreationDate': '2012-11-19T20:56:27.043', 'Id': '6773''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In the multiway cut problem, the input is an undirected graph $G= (V, E)$ and set of terminal nodes $s_1, s_2,\\ldots s_k$ are in $V$. The goal is to find a minimum\nset of edges in $E$ whose removal leaves all terminals in different components.</p>\n\n<ol>\n<li><p>How do we show that this problem can be solved exactly in polynomial time when\n$k= 2$?</p></li>\n<li><p>How do we get an approximation algorithm with ratio at most 2 for the case when $k \\geq 3$?</p></li>\n</ol>\n', 'ViewCount': '353', 'Title': '2OPT Approximation Algorithm for Multiway Cut Problem', 'LastEditorUserId': '19', 'LastActivityDate': '2013-04-02T15:47:46.743', 'LastEditDate': '2013-04-02T14:17:26.360', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'lam lae', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><approximation><network-flow>', 'CreationDate': '2012-12-02T22:34:14.450', 'Id': '7205''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Consider an undirected graph with a source and a sink vertex. We would like to remove minimum number of vertices in that graph to disconnect any path between source and sink.</p>\n\n<p>My intuition tells me that we can use max-flow, min-cut algorithm to solve this problem. I don't know whether my solution is correct or not. Please help me check it:</p>\n\n<ol>\n<li>Replace each of the undirected edges with a pair of directed edges.</li>\n<li>Replace each vertex $v$ with two vertices $v_\\text{in}$ and $v_\\text{out}$ connected by an edge. all the incoming edges of $v$ will be connected with $v_\\text{in}$, all the outgoing edges of $v$ will be connected with $v_\\text{out}$.</li>\n<li>Try to find a minimum cut $M$. The edges of $M$ refer to the vertices that we need to remove.</li>\n</ol>\n", 'ViewCount': '767', 'Title': 'Remove minimum number of vertices to disconnect the graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-17T09:25:17.337', 'LastEditDate': '2012-12-17T09:25:17.337', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5093', 'Tags': '<algorithms><graph-theory><network-flow>', 'CreationDate': '2012-12-17T07:12:38.157', 'Id': '7457''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '213', 'Title': 'XOR-like behavior in flow networks', 'LastEditDate': '2013-03-03T11:44:38.840', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '2', 'Body': '<p><em>XOR is not the correct name, but I am looking for some kind of exclusive behavior.</em></p>\n\n<p>I am currently solving a set of different (assignment) problems by modeling flow networks and running a min-cost-max-flow algorithm. Flow networks are quite handy because a lot of problems can be reduced to them in an easy and understandable way. In my case these are matchings with some additional constraints. As these constraints are getting more complex I\'ve been wondering if there are some existing constructions to model specific behaviors.</p>\n\n<p>In this case I want to restrict the outgoing flow of a node to a single edge.</p>\n\n<p>Given a graph $G=(V, E)$, integral capacities $c(u,v)$ and costs $k(u,v)$. An arbitrary node is called $A$. It\'s direct neighbors are called $B_1, ..B_n$. Can we replace the edges $AB_1,...AB_n$ (red) with some construction so that <strong>only one edge can receive flow</strong>? Which means that if $AB_1$ gets some flow (e.g. $5/10$) no other (red) edge can receive flow.</p>\n\n<p><img src="http://i.stack.imgur.com/1Cli7.png" alt=""></p>\n\n<p>We could add intermediate nodes/edges and play with costs and capacities. The total capacity of our new construction has to stay the same and the cost of the different alternatives have to stay somehow proportional.</p>\n\n<p>So my questions are:</p>\n\n<ol>\n<li>Are there constructions like this in general? (Any keywords, links, papers)</li>\n<li>Can you suggest a solution to my specific problem?</li>\n</ol>\n', 'Tags': '<algorithms><graph-theory><graphs><network-flow><assignment-problem>', 'LastEditorUserId': '4298', 'LastActivityDate': '2013-10-29T15:14:57.683', 'CommentCount': '9', 'AcceptedAnswerId': '7623', 'CreationDate': '2012-12-26T22:37:50.973', 'Id': '7610''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In the CLRS book (<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">http://en.wikipedia.org/wiki/Introduction_to_Algorithms</a>) Chapter 26 (Maximum Flow) page 744 (third edition), there is the following equation -</p>\n\n<p>$$\n\\sum_{u \\in U}e(u) \\;=\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in U}f(v, u) \\;+\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in \\bar{U}}f(v, u) \\;-\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in U}f(u, v) \\;-\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in \\bar{U}}f(u, v)\n$$</p>\n\n<p>where $f(u, v)$ is the flow between vertices $u$ and $v$, $e(u)$ is the excess flow at a particular vertex, $U$ is the set of vertices which are reachable from the source, and $\\bar{U}$ is the set of remaining vertices.</p>\n\n<p>In the next line, the first and third terms disappear. I don\'t understand why that holds. I do realize that those are flow values from vertex $u$ to vertex $v$ where both of them are in the same set $U$, but I don\'t understand why they cancel out to zero.</p>\n', 'ViewCount': '102', 'Title': 'Push relabel algorithms in flow networks', 'LastEditorUserId': '2152', 'LastActivityDate': '2013-04-03T16:18:22.383', 'LastEditDate': '2013-04-03T16:18:22.383', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10993', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6558', 'Tags': '<algorithms><graph-theory><graphs><network-flow>', 'CreationDate': '2013-01-25T16:14:49.193', 'Id': '9153''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '269', 'Title': 'Are link-cut trees ever used in practice, for max flow computation or other applications?', 'LastEditDate': '2013-02-05T10:22:43.413', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '6701', 'FavoriteCount': '2', 'Body': '<p>Many max flow algorithms that I commonly see implemented, Dinic\'s algorithm, push relabel, and others, can have their asymptotic time cost improved through the use of <a href="http://en.wikipedia.org/wiki/Link/cut_tree">dynamic trees</a> (also known as link-cut trees).</p>\n\n<ul>\n<li>Push relabel runs in $O(V^2E)$ or $O(V^3)$ or $O(V^2\\sqrt{E})$ normally, but with dynamic trees $O(VE \\log(V^2/E))$</li>\n<li>Dinic\'s algorithm runs in $O(V^2E)$, but with dynamic trees $O(VE\\log(V))$</li>\n</ul>\n\n<p>However, practical implementations of max-flow algorithms in most libraries don\'t seem to make use of this data structure.  Are dynamic trees ever used in practice for max flow computation? Or do they carry too much overhead to be useful for real world problem sizes?</p>\n\n<p>Are there any other problem domains where link cut trees are used?</p>\n\n<p>This question is related to a question that I asked on cstheory: <a href="http://cstheory.stackexchange.com/questions/16347/are-any-of-the-state-of-the-art-maximum-flow-algorithms-practical">Are any of the state of the art Maximum Flow algorithms practical?</a></p>\n', 'Tags': '<reference-request><graphs><data-structures><network-flow>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-05T21:59:44.773', 'CommentCount': '2', 'AcceptedAnswerId': '9521', 'CreationDate': '2013-02-05T04:36:34.087', 'Id': '9501''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let's say we a have flow network with $m$ edges and integer capacities. </p>\n\n<p>Prove that there exists a sequence of at most $m$ augmenting paths that yield the maximum flow.</p>\n\n<p>A good way to start thinking about this is to imagine that we know the maximum flow already.  How can we figure the sequence of $m$ paths?</p>\n", 'ViewCount': '310', 'Title': 'Maximum number of augmenting paths in a network flow', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-16T02:07:47.667', 'LastEditDate': '2013-04-15T08:17:49.407', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '11351', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Tags': '<graph-theory><combinatorics><network-flow>', 'CreationDate': '2013-04-13T16:06:42.840', 'Id': '11288''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was wondering. May the source and sink have in-out going edges in a flow-network, and if so - does Ford-Fulkerson and the max-flow min-cut theorem apply ?</p>\n\n<p>Flow-networks are always pictures with no edges entering source, and no edges leaving sink.</p>\n\n<p>I've tried to search the web for an answer, but did not come across an answer i fully understand. Also, I've yet to see a flow network pictured with these edges from source/sink.</p>\n\n<p>Could I transform an undirected graph into a flow-network ? This network will have edges going into source and edges leaving sink ?? This hypothesis is the reason for my question.</p>\n", 'ViewCount': '206', 'Title': 'In flow networks, may source/sink have incoming/outgoing edges?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T18:57:23.833', 'LastEditDate': '2013-05-19T15:03:37.647', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8254', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2013-05-19T14:20:17.700', 'Id': '12134''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need your help with an exercise on <a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" rel="nofollow">Ford-Fulkerson</a>.</p>\n\n<blockquote>\n  <p>Suppose you are given a flow network with capacities $(G,s,t)$ and you are also given the max flow $|f|$ in advance.</p>\n  \n  <p>Now suppose you are given an arc $e$ in $G$ and suppose this arc\'s capacity is increased by one.</p>\n  \n  <p>Give an efficent algorithm which returns true iff the increase of the capacity of the arc $e$ will allow an increase in the max flow.</p>\n</blockquote>\n\n<p>I suppose we shouldn\'t run Ford-Fulkerson again but somehow use the given $|f|$\u2026 Any ideas how?</p>\n', 'ViewCount': '237', 'LastEditorDisplayName': 'user742', 'Title': 'Effect of increasing the capacity of an edge in a flow network with known max flow', 'LastActivityDate': '2013-06-17T23:03:08.163', 'LastEditDate': '2013-06-17T23:03:08.163', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'SyndicatorBBB', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<algorithms><graph-theory><network-flow><weighted-graphs>', 'CreationDate': '2013-06-16T16:41:05.080', 'Id': '12703''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>On the <a href="http://en.wikipedia.org/wiki/Circulation_problem" rel="nofollow">circulation problem page on wikipedia</a>, the multicommodity circulation problem formulation seems to be insufficient, since we can just set all but one flow to $0$, and reduce it to a circulation problem.</p>\n\n<p>I can\'t find any concrete description of multicommodity circulation problem to verify the correctness. There is only <a href="http://transci.journal.informs.org/content/8/4/355.full.pdf" rel="nofollow">one paper</a> I can find and it\'s behind a pay wall.</p>\n\n<p>Here is a formulation I thought to make more sense:</p>\n\n<p>Let $G=(V,E)$. $l_i,u,c_i:E\\to \\mathbb{R}$ for $1 \\leq i\\leq n$. We want to find a sequence of flow function $f_i$, such that:</p>\n\n<p>$$\n\\begin{align}\n\\text{min} &amp; \\sum_{(v,w) \\in E} c_i(v,w)f_i(v,w) \\\\\n\\text{s.t.} &amp; \\sum_{(v,w) \\in E} f_i(v,w) = 0 \\text{ for } 1 \\le i \\le n, v \\in V, \\\\\n&amp; l_i(v,w) \\leq f_i(v,w) \\text{ for } 1 \\le i \\le n, (v,w)\\in E\\\\\n&amp; \\sum_{i=1}^n f_i(v,w) \\leq u(v,w) \\text{ for } (v,w)\\in E\\\\\n\\end{align}\n$$</p>\n\n<p>Is this a formulation of multicommodity circulation problem?</p>\n', 'ViewCount': '71', 'Title': 'Multicommodity circulation formulation', 'LastEditorUserId': '220', 'LastActivityDate': '2013-07-06T13:07:35.350', 'LastEditDate': '2013-07-05T18:43:56.970', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12965', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '220', 'Tags': '<reference-request><optimization><network-flow>', 'CreationDate': '2013-06-29T09:56:58.443', 'Id': '12963''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m attepting to model a process flow where the transition to the next state is occasionally based on not only the input to the current state, but a prior state as well.</p>\n\n<p>Below is an example graph descibring the process. The essence is: If both State Q1 and State Q3 recieve an input of one, after State 3, transition to State Q4, otherwise transition to State Q5.</p>\n\n<p><img src="http://i.stack.imgur.com/DcBTc.png" alt="Non-state dependent machine"></p>\n\n<p>I understand that it would be possible to model this using a finite-state machine where we duplicate any states between those that we are interested in. The example below demonstrates this with States Q2a and Q2b corresponding to the differences in input at state Q1</p>\n\n<p><img src="http://i.stack.imgur.com/r9cMs.png" alt="State-dependent"></p>\n\n<p>However, as the number of conditions and the gaps between them grows (both of which are possible in the process I\'m looking at), the number of states grows exponentially.</p>\n\n<p>The question is, what other computational models could be used to describe a process where an arbitrary number of inputs could be used to control transition between states?</p>\n', 'ViewCount': '96', 'Title': 'State machine with knowledge of prior states?', 'LastActivityDate': '2013-07-22T11:24:27.433', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8632', 'Tags': '<graphs><automata><network-flow>', 'CreationDate': '2013-07-22T00:27:48.457', 'Id': '13379''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose that I have run maxflow algorithm on a graph G and, as a result, I have a set of edges with flow on them.\nI would like to enumerate all possible sets of paths that comprise the maxflow.\nThat is, each set of paths will make the max flow.\nBut I suspect there could be multiple set of such paths.</p>\n', 'ViewCount': '102', 'ClosedDate': '2013-11-28T21:50:32.407', 'Title': 'Finding paths from the result of max flow', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-24T09:17:42.807', 'LastEditDate': '2013-08-26T08:28:54.027', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9311', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2013-07-23T22:13:52.240', 'Id': '13403''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have here a directed graph that I used to perform <a href="http://en.wikipedia.org/wiki/Dinic%27s_algorithm" rel="nofollow">Dinic\'s algorithm</a> to find maximum flow. I need to adjust this graph and this algorithm to work with dynamic trees (i.e. the Sleator-Tarjan algorithm).</p>\n\n<p>I just wish I could find an image source or video that can help me visualize the steps. Something <a href="http://www.arl.wustl.edu/~jst//cse/542/text/sec19.pdf" rel="nofollow">like this</a> is really close. But I just really want to find thing to lead me step by step in a visual way or a way that doesn\'t involve pseudocode.</p>\n', 'ViewCount': '106', 'Title': "Understanding Dinic's algorithm using dynamic trees", 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:09:51.823', 'LastEditDate': '2013-08-13T08:09:51.823', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9626', 'Tags': '<algorithms><reference-request><network-flow>', 'CreationDate': '2013-08-12T20:48:37.890', 'Id': '13720''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>To find the maximum flow in a graph, why doesn't it suffice to only saturate all augmenting paths with the minimum edge capacity in that path without considering the back-edges? I mean, what is the point calling it a back-edge if we assume flow from it?</p>\n", 'ViewCount': '52', 'Title': 'Saturating all augmenting paths with the minimum edge capacity in max flow', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T21:07:48.467', 'LastEditDate': '2013-10-18T21:07:48.467', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10525', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs><network-flow>', 'CreationDate': '2013-10-18T17:15:17.717', 'Id': '16202''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How does one construct the residual network in such a case?</p>\n\n<p>The formula is for edge $(u, v)$  is </p>\n\n<p>$$rf(u,v) = (c_{\\mathrm{upper}}(u,v) - f(u,v)) + (f(v,u) - c_{\\mathrm{lower}}(v, u))\\,,$$</p>\n\n<p>where $rf(u, v)$ is the residual flow on the edge $(u, v)$, $c_{\\mathrm{upper}}$ and $c_{\\mathrm{lower}}$ are capacities on the edge and $f$ is the flow.</p>\n\n<p>If, say, my edge $(u, v)$ has capacities $[3, 25]$ and a flow $f(u,v)=1$, then what are $rf(u, v)$ and $rf(v, u)$?</p>\n\n<p>what is $c_{\\mathrm{lower}}(v, u)$?</p>\n\n<p>Thank you.</p>\n', 'ViewCount': '28', 'Title': 'residual network for a network with lower and upper bounds?', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-12-02T23:13:19.397', 'LastEditDate': '2013-12-02T23:13:19.397', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11771', 'Tags': '<network-flow>', 'CreationDate': '2013-12-02T23:05:33.947', 'Id': '18548''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Hi I'm trying to prove the following proposition:</p>\n\n<hr>\n\n<p>Given a network $G,s,t,\\omega$ where $\\omega$ is the capacity, create a minimal cut cut  ${S=\\left\\{ (s,v)\\in E_{G_{r\\_max}}\\right\\} }$ where $G_{r\\_max}$  is graph representing the the residual network(meaning we take the group of all vertices that are reachable from s in $G_{r\\_max}$). So that the cut is $\\left(S,V\\backslash S\\right)$.</p>\n\n<p>Given two maximal flows $f_1\\neq f_2$ prove that $\\left(S_1,V\\backslash S_1\\right)=\\left(S_2,V\\backslash S_2\\right)$ (which are defined in the above mentioned form for each maximal flow).</p>\n\n<hr>\n\n<p>I've tried proving by assuming the contrary and saying that $S_1 $ is not subset of $S_2$.\nTried to say that this leads to $\\exists \\ v\\in S_1 \\ \\ \\mbox{s.t} \\ \\ v\\notin S_2$.\nTried looking at the intersection and union of these groups but to no avail.</p>\n\n<p>I'd appreciate some guidance\\explanation as to how best prove this claim.</p>\n", 'ViewCount': '77', 'Title': 'Prove that every maximal flow yields the same minimal cut', 'LastEditorUserId': '8709', 'LastActivityDate': '2014-01-01T20:19:13.333', 'LastEditDate': '2014-01-01T20:19:13.333', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8709', 'Tags': '<graphs><network-flow>', 'CreationDate': '2014-01-01T18:34:05.833', 'Id': '19436''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a simple directed graph $G(V,E)$ that has a source $s$ and sink $t$. Each edge $e$ of $G$ has positive integer capacity $c(e)$ and positive integer cost $a(e)$. I am trying to find the minimum cost maximum flow from $s$ to $t$ using the <a href="http://wwwhome.math.utwente.nl/~uetzm/do/DO_Lecture4.pdf" rel="nofollow">well-known Dijkstra potential method for finding augmenting paths</a>. It goes something like this:</p>\n\n<pre><code>Initialize all edge flows to 0.\nInitialize all potentials pi[v] to 0.\nWhile there exists an augmenting path in G_f (the residual network):\n    Set the costs of all edges e = uv to be:\n        b(e) = a(e) + pi[u] - pi[v], if e exists in G or\n        b(e) = -a(e_reverse) + pi[u] - pi[v], where e_reverse = vu otherwise\n    # We are now assured all edges have nonnegative costs\n    Using Dijkstra method with costs b(e) in G_f:\n        Find the cheapest augmenting path from s to t\n        Calculate dist(v), the cost of cheapest path from s to v\n    Augment the cheapest path to t to current flow\n    Set pi[v] = pi[v] + dist(v) for all vertices v\nThe current flow gives the minimum cost maximum flow.\n</code></pre>\n\n<p>Obviously, if all costs $a(e) \\le a_{max}$ and all capacities $c(e) \\le c_{max}$, then there is a loose bound $|E|c_{max}a_{max}$ for cost of minimum cost maximum flow. However, the bound on the potentials $\\pi(v)$ and Dijkstra distances $dist(v)$ is not so obvious. In fact, judging by how it adds $dist(v)$ to $\\pi(v)$ each iteration, $\\pi(v)$ can possibly be multiplied by $|V|$ each iteration!</p>\n\n<p><strong>My question is</strong>, is there a way to calculate a non-exponential bound for $\\pi(v)$? If not, say all capacities and costs are at most $10^4$, $|V| = 200$, $|E| = 5000$. The minimum cost of the maximum flow is at most $5000 \\times 10^4 \\times 10^4 = 5 \\times 10^{11}$. But is it possible that $\\pi(v)$ and $dist(v)$ exceeds 64-bit integers? How do so many implementations not use Big Integers?</p>\n', 'ViewCount': '104', 'Title': 'Potential values of minimum cost maximum flow algorithm', 'LastEditorUserId': '7137', 'LastActivityDate': '2014-01-15T14:37:32.410', 'LastEditDate': '2014-01-15T14:37:32.410', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7137', 'Tags': '<algorithms><graph-theory><algorithm-analysis><asymptotics><network-flow>', 'CreationDate': '2014-01-11T04:25:09.883', 'Id': '19645''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '70', 'Title': "Why can't you write the 2-paths problem as a max-flow problem?", 'LastEditDate': '2014-02-12T19:55:24.250', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8877', 'FavoriteCount': '1', 'Body': '<p>This is a follow-up question to <a href="http://cstheory.stackexchange.com/questions/20989/graph-problems-which-are-np-complete-on-directed-graphs-but-polynomial-on-undire/20991#comment55620_20991">this</a>. Consider the 2-paths problem:</p>\n\n<blockquote>\n  <p>Given a directed graph $D=(V,A)$ and pairs of vertices $(s_1,t_1)$ and $(s_2,t_2)$, are there paths $P_1 = (s_1,\\dots, t_1)$ and $P_2=(s_2,\\dots,t_2)$ such that $P_1$ and $P_2$ are vertex-disjoint?</p>\n</blockquote>\n\n<p>This problem has been shown to be NP-complete (references <a href="http://cstheory.stackexchange.com/questions/20989/graph-problems-which-are-np-complete-on-directed-graphs-but-polynomial-on-undire/20991#comment55620_20991">here</a>). \nThis struck me as unusual, because there seems to be a natural way to formulate this as a max flow problem: </p>\n\n<ul>\n<li>Add new vertices $s$ and $t$ to $D$.</li>\n<li>Add arcs $(s,s_1),(s,s_2),(t_1,t),(t_2,t)$.</li>\n<li>Let all vertices have capacity one (besides $s$ and $t$).</li>\n</ul>\n\n<p>It seems to me that the max $s-t$ flow of this new graph (call it $D\'$) should be two iff $D$ has those desired paths $P_1$ and $P_2$. Surely there must be some mistake here, because this seems to imply that an NP-complete problem can be solved in polytime. Where is the mistake?</p>\n', 'Tags': '<complexity-theory><graphs><network-flow>', 'LastEditorUserId': '8877', 'LastActivityDate': '2014-02-12T22:50:32.903', 'CommentCount': '2', 'AcceptedAnswerId': '21577', 'CreationDate': '2014-02-12T18:35:27.667', 'Id': '21574''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a set of buyers, houses, agents with the following constraints: </p>\n\n<ol>\n<li>Agents only know a subset of buyers</li>\n<li>Agents only know a subset of houses</li>\n<li>Agents can only do some amount of transactions</li>\n</ol>\n\n<p>Construct a flow network to model the problem.\n<em>Disclaimer this is homework</em></p>\n\n<p>I have put together some thoughts on a solution to this problem.  First I realized that agents should be right before the sink node with a max flow equal to the number of possible transactions.  This would then limit the number of transactions that can flow through an agent since the max flow can't be exceeded.  </p>\n\n<p>I was then thinking that it would be possible to put an edge between each person and house that an agent knows (example if agent knows person A, B and house 1, 2 there are edges (A,1), (A,2), (B,1), (B,2)). Finally, connect each house that an agent knows to an agent with max flow of 1. Then by running a Ford-Fulkerson algorithm across it the inflow of the sink node would indicate max number of transactions.</p>\n\n<p>However, I am concerned that there is no limit of stopping a house from being purchased more than once. I have tried building the network with various configurations (swapping houses and clients, building nodes of client/house pairs) and nothing seems to solve this specific problem.</p>\n\n<p>I am mostly looking for hints to solve this problem.</p>\n", 'ViewCount': '30', 'Title': 'Network Flow with multiple connected subsets', 'LastActivityDate': '2014-04-10T02:41:15.647', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7887', 'Tags': '<algorithms><network-flow>', 'CreationDate': '2014-03-10T07:12:56.767', 'Id': '22455''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a variant of bidding problem at hand.\nThere are N bidders(~20) who bid for items from a pool of many items(~10K). Each bidder can bid many items. I want to maximize the number of bidders who are satisfied. A bidder is satisfied if he gets all the items that he bid for in the first place. For eg-</p>\n\n<pre><code>Bidders = A,B,C\nItems = 1,2,3,4\n\nBidder    Bids\nA         1,2\nB         2,3\nC         3,4\n</code></pre>\n\n<p><img src="http://i.stack.imgur.com/Xcxlu.png" alt="enter image description here">\nIn this case its only possible to satisfy 2 bidders at max.</p>\n\n<p>I\'ve tried to model the problem to a maxflow problem and have taken several approaches but to no avail\nMy approaches so far-</p>\n\n<ol>\n<li><p>Tried to model this problem as a bipartite matching problem. The only problem being that instead of a one-one mapping I have a one-many mapping with an AND condition. </p></li>\n<li><p>A maxflow problem with edges going from source to each vertex with a capacity of number of bids. Problem here being ensuring that all edges from a bidder are selcted.</p></li>\n<li><p>A maxflow problem with both upper bounded and lower bounded edge capacities.</p></li>\n</ol>\n', 'ViewCount': '155', 'Title': 'Maximum number of matched vertexes in a one-to-many bipartite graph', 'LastActivityDate': '2014-03-12T17:58:04.897', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '22548', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15606', 'Tags': '<algorithms><graph-theory><network-flow><bipartite-matching><max-cut>', 'CreationDate': '2014-03-12T16:10:00.057', 'Id': '22542''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>What is a known strategy to approach a situation where short bursts of data are being sent very often over a high bandwidth, high latency cable? I am aware of cubic but even that does not utilize a 10GBps cable in a short burst scenario.</p>\n\n<p>Lets say I have a distributed network where a single computer is sending tasks to many other computers. The computers then respond with a short answer 50-100KB. We need to receive these answers as quickly as possible.</p>\n\n<p>What are the consideration and do we determine the optimal initial congestion window size? </p>\n\n<p>Assumptions:</p>\n\n<ol>\n<li>Using TCP Cubic.</li>\n<li>Bursts are arrive with a Poisson distribution.</li>\n<li>Goal is to get the data as quickly as possible.</li>\n<li>Two scenarios, limited or vast buffer size.</li>\n</ol>\n', 'ViewCount': '23', 'Title': 'Picking an optimal initial congestion window size (high bw, high latency and short bursts)?', 'LastEditorUserId': '14875', 'LastActivityDate': '2014-04-23T13:15:33.887', 'LastEditDate': '2014-04-23T13:15:33.887', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14875', 'Tags': '<computer-networks><network-flow><communication-protocols>', 'CreationDate': '2014-03-18T19:07:01.763', 'Id': '22765''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am working out with the rooks problem. If there are m rooks on an nxn chessboard,i have to give describe a polynomial (in m and n) time algorithm that \ufb01nds a maximum-sized subset of the rooks such that if we leave this subset on the chessboard and remove all other rooks, then no two rooks attack one another. (Two rooks are said to attack one another if and only if they are either in the same row or in the same column with no other intervening rooks between them.)</p>\n\n<p>My idea for solving this problem is to consider a bipartite graph (X,Y) where X is the rows in the chessboard and Y is the columns. if a row and column have a rook placed at their intersection, then there is an edge between the those vertices from x to y. This can be converted into a maximum flow network and the value of max flow is the max matching. </p>\n\n<p>In order to find a polynomial time algorithm i can run maybe BFS.</p>\n\n<p>I wanted to know that if i build my solution on this idea shall it be correct. Is there a better algorithm (polynomial in m and n)?</p>\n\n<p>Any help is appreciated.</p>\n', 'ViewCount': '34', 'Title': 'maximum bipartite matching', 'LastActivityDate': '2014-03-20T02:28:19.897', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6688', 'Tags': '<network-flow><bipartite-matching>', 'CreationDate': '2014-03-20T01:48:01.570', 'Id': '22840''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>My question is that I'm trying to find the sparsest cut in a connected, undirected graph (all weights are = 1). Basically, I am looking trying to find the smallest cut (i.e., number of edges cut since all weights = 1) while maximizing the number of vertices in the resulting subgraph. How do I approach this problem with flow?</p>\n", 'ViewCount': '20', 'ClosedDate': '2014-04-16T23:02:28.523', 'Title': 'Minimum cut versus sparsest cut?', 'LastActivityDate': '2014-04-14T02:32:51.203', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16201', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2014-03-27T15:31:57.593', 'Id': '23133''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>What is the difference between maximal flow and maximum flow. I am reading these terms while working on Ford Fulkerson algorithms and they are quite confusing. I tried on internet, but couldn't get a reasonable answer. I believe maximum flow is quite clear as it means maximum amount of flow that can be transferred from source to sink in a network, but what exactly is maximal flow.</p>\n\n<p>Please answer in layman terms if possible.</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '100', 'Title': 'What is the difference between maximal flow and maximum flow?', 'LastActivityDate': '2014-04-14T01:38:17.857', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16750', 'Tags': '<algorithms><graph-theory><graphs><network-flow>', 'CreationDate': '2014-04-14T00:31:01.150', 'Id': '23763''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29#Proof" rel="nofollow">Wikipedia</a> shows how one can determine the minimum vertex cover in a bipartite graph ($G(X \\cup Y, E)$) in polytime from a maximum flow using alternating paths. However, I read that the (S,T) cut (extracted from the final residual network) can also be used to determine the minimum vertex cover:</p>\n\n<p>$$(X\\cap T)\\cup(Y\\cap S)$$</p>\n\n<p>If this expression is a correct alternative, I don\'t have an intuition for why it\'s true. The best intuition I\'ve been able to come up with is: Select each vertex on the left (X) that has a positive flow leading up to it and select each vertex on the right if there is no flow leading up to it. Why is this set equal to the minimum vertex cover?</p>\n', 'ViewCount': '13', 'Title': 'Determining the minimum vertex cover in a bipartite graph from a maximum flow/matching using the residual network rather than alternating paths', 'LastActivityDate': '2014-04-17T01:33:45.290', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23873', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graphs><network-flow><bipartite-matching>', 'CreationDate': '2014-04-17T00:27:40.150', 'Id': '23871''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm studying for my finals in algorithms and reading the part about flow networks. There's a certain section that has me completely stumped and it is as follows:</p>\n\n<blockquote>\n  <p>Given a graph $G= \\langle V_G, E_G \\rangle$, we can construct the $H(G)=\\langle V_H, E_H\\rangle$ as follows:\n  $$V_H = V_G\\times\\{0,1\\}E_H = \\{((v,0),(v,1))|v\\in V_G\\}\\cup\\{((x,1),(y,0))|(x,y)\\in E_G\\}.$$\n  Say that we have a graph $\\langle G,u,v\\rangle$ where $G$ is some directed graph, which contains vertices $u$ and $v$ then $H(G)$ can be used to find the smallest number of nodes that must be removed from $G$ to separate $u$ to $v$, meaning there will be no simple path from $u$ to $v$.</p>\n</blockquote>\n\n<p>I really don't understand what's going on here, partly because I can't visualise $H(G)$. I assume we'd get some bipartite graph and maybe apply Edmonds-Karp only because the flow networks sections is succinct and there's not much else in this chapter. Could someone tell/show me what $H(G)$ is doing exactly and why this result is true. Much appreciated.</p>\n", 'ViewCount': '65', 'Title': "Don't understand this graph definition", 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T21:53:50.963', 'LastEditDate': '2014-05-02T21:53:50.963', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15826', 'Tags': '<graph-theory><terminology><network-flow>', 'CreationDate': '2014-05-01T14:30:30.687', 'Id': '24295''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}