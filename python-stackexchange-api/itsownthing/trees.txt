{'Body': "<p>I need to create a recursive algorithm to see if a binary tree is a binary search tree as well as count how many complete branches are there (a parent node with both left and right children nodes) with an assumed global counting variable. This is an assignment for my data structures class. </p>\n\n<p>So far I have</p>\n\n<pre><code>void BST(tree T) {\n   if (T == null) return\n   if ( T.left and T.right) {\n      if (T.left.data &lt; T.data or T.right.data &gt; T.data) {\n        count = count + 1\n        BST(T.left)\n        BST(T.right)\n      }\n   }\n}\n</code></pre>\n\n<p>But I can't really figure this one out. I know that this algorithm won't solve the problem because the count will be zero if the second if statement isn't true.</p>\n\n<p>Could anyone help me out on this one? </p>\n", 'ViewCount': '1727', 'Title': 'Algorithm to test whether a binary tree is a search tree and count complete branches', 'LastEditorUserId': '79', 'LastActivityDate': '2012-03-07T22:25:59.700', 'LastEditDate': '2012-03-07T22:25:59.700', 'AnswerCount': '3', 'CommentCount': '14', 'AcceptedAnswerId': '113', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '79', 'Tags': '<algorithms><recursion><trees>', 'CreationDate': '2012-03-07T19:47:33.067', 'Id': '105'}{'ViewCount': '303', 'Title': 'Efficient compression of unlabeled trees', 'LastEditDate': '2012-03-20T20:21:39.787', 'AnswerCount': '5', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '2', 'Body': '<p>Consider unlabeled, rooted binary trees. We can <em>compress</em> such trees: whenever there are pointers to subtrees $T$ and $T&#39;$ with $T = T&#39;$ (interpreting $=$ as structural equality), we store (w.l.o.g.) $T$ and replace all pointers to $T&#39;$ with pointers to $T$. See <a href="http://cs.stackexchange.com/a/177/98">uli\'s answer</a> for an example.</p>\n\n<p>Give an algorithm that takes a tree in the above sense as input and computes the (minimal) number of nodes that remain after compression. The algorithm should run in time $\\cal{O}(n\\log n)$ (in the uniform cost model) with $n$ the number of nodes in the input.</p>\n\n<p>This has been an exam question and I have not been able to come up with a nice solution, nor have I seen one.</p>\n', 'Tags': '<algorithms><data-structures><trees><binary-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-20T20:21:39.787', 'CommentCount': '11', 'AcceptedAnswerId': '174', 'CreationDate': '2012-03-09T17:54:38.383', 'Id': '168'}{'Body': "<p>When implementing a dictionary ('I want to look up customer data by their customer IDs'), the typical data structures used are hash tables and binary search trees. I know for instance that the C++ STL library implements dictionaries (they call them maps) using (balanced) binary search trees, and the .NET framework uses hash tables under the hood.</p>\n\n<blockquote>\n  <p>What are the advantages and disadvantages of these data structures? Is there some other option that is reasonable in certain situations?</p>\n</blockquote>\n\n<p>Note that I'm not particularly interested in cases where the keys have a strong underlying structure, say, they are all integers between 1 and n or something.</p>\n", 'ViewCount': '4628', 'Title': 'Hash tables versus binary trees', 'LastActivityDate': '2012-03-13T01:43:44.703', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '278', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<algorithms><data-structures><binary-trees><hash-tables>', 'CreationDate': '2012-03-13T00:30:42.750', 'FavoriteCount': '2', 'Id': '270'}{'ViewCount': '1205', 'Title': 'Not all Red-Black trees are balanced?', 'LastEditDate': '2012-04-12T05:55:31.997', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '2', 'Body': '<p>Intuitively, "balanced trees" should be trees where left and right sub-trees at each node must have "approximately the same" number of nodes.</p>\n\n<p>Of course, when we talk about red-black trees*(see definition at the end) being balanced, we actually mean that they are <em>height</em> balanced and in that sense, they are balanced. </p>\n\n<p>Suppose we try to formalize the above intuition as follows:</p>\n\n<blockquote>\n  <p><strong>Definition:</strong> A Binary Tree is called $\\mu$-balanced, with $0 \\le \\mu \\leq \\frac{1}{2}$, if for every node $N$, the inequality</p>\n  \n  <p>$$ \\mu \\le \\frac{|N_L| + 1}{|N| + 1} \\le 1 - \\mu$$</p>\n  \n  <p>holds and for every $\\mu&#39; \\gt \\mu$, there is some node for which the above statement fails. $|N_L|$ is the number of nodes in the left sub-tree of $N$ and $|N|$ is the number of nodes under the tree with $N$ as root (including the root).</p>\n</blockquote>\n\n<p>I believe, these are called <em>weight-balanced</em> trees in some of the literature on this topic. </p>\n\n<p>One can show that if a binary tree with $n$ nodes is $\\mu$-balanced (for a constant $\\mu \\gt 0$), then the height of the tree is $\\mathcal{O}(\\log n)$, thus maintaining the nice search properties.</p>\n\n<p>So the question is:</p>\n\n<blockquote>\n  <p>Is there some $\\mu \\gt 0$ such that every big enough red-black tree is $\\mu$-balanced?</p>\n</blockquote>\n\n<hr>\n\n<p>The definition of Red-Black trees we use (from Introduction to Algorithms by Cormen et al):</p>\n\n<p>A binary search tree, where each node is coloured either red or black and</p>\n\n<ul>\n<li>The root is black</li>\n<li>All NULL nodes are black</li>\n<li>If a node is red, then both its children are black.</li>\n<li>For each node, all paths from that node to descendant NULL nodes have the same number of black nodes.</li>\n</ul>\n\n<p>Note: we don\'t count the NULL nodes in the definition of $\\mu$-balanced above. (Though I believe it does not matter if we do).</p>\n', 'Tags': '<data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:55:44.147', 'CommentCount': '19', 'AcceptedAnswerId': '375', 'CreationDate': '2012-03-14T00:15:10.127', 'Id': '342'}{'ViewCount': '2403', 'Title': 'Counting binary trees', 'LastEditDate': '2012-03-14T16:35:41.583', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '68', 'FavoriteCount': '6', 'Body': '<p>(I\'m a student with some mathematical background and I\'d like to know how to count the number of a specific kind of binary trees.)</p>\n\n<p>Looking at Wikipedia page for <a href="http://en.wikipedia.org/wiki/Binary_tree">Binary Trees</a>, I\'ve noticed this assertion that the number of rooted binary trees of size $n$ would be this <a href="http://en.wikipedia.org/wiki/Catalan_number">Catalan Number</a>:\n$$C_n = \\dfrac{1}{n+1}{2n \\choose n}$$</p>\n\n<p>But I don\'t understand how I could come up with such a result by myself? Is there a method to find this result?</p>\n\n<p>Now, what if the order of sub-trees (which is left, which is right) is not considered? For example, from my point of view, I consider that these two trees are the same:</p>\n\n<pre><code>   /\\   /\\\n  /\\     /\\\n</code></pre>\n\n<p>Would it be possible to apply a similar method to count how many of these objects have exactly $n$ nodes?</p>\n', 'Tags': '<combinatorics><binary-trees><discrete-mathematics>', 'LastEditorUserId': '5', 'LastActivityDate': '2013-02-24T10:49:26.230', 'CommentCount': '2', 'AcceptedAnswerId': '372', 'CreationDate': '2012-03-14T13:57:03.527', 'Id': '368'}{'ViewCount': '1248', 'Title': 'AVL trees are not weight-balanced?', 'LastEditDate': '2012-04-12T05:55:19.533', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '1', 'Body': '<p>In a previous <a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">question</a> there was a definition of weight balanced trees and a question regarding red-black trees. </p>\n\n<p>This question is to ask the same question, but for <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL trees</a>. </p>\n\n<p>The question is, given the definition of $\\mu$-balanced trees as in the other question,</p>\n\n<blockquote>\n  <p>Is there some $\\mu \\gt 0$ such that all big enough AVL trees are $\\mu$-balanced?</p>\n</blockquote>\n\n<p>I presume there is only one definition of AVL trees and there is no ambiguity.</p>\n', 'Tags': '<data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:56:47.213', 'CommentCount': '0', 'AcceptedAnswerId': '424', 'CreationDate': '2012-03-15T16:56:32.180', 'Id': '421'}{'ViewCount': '2234', 'Title': 'Which combinations of pre-, post- and in-order sequentialisation are unique?', 'LastEditDate': '2012-03-17T09:20:08.613', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '5', 'Body': '<p>We know post-order,</p>\n\n<pre><code>post L(x)     =&gt; [x]\npost N(x,l,r) =&gt; (post l) ++ (post r) ++ [x]\n</code></pre>\n\n<p>and pre-order</p>\n\n<pre><code>pre L(x)     =&gt; [x]\npre N(x,l,r) =&gt; [x] ++ (pre l) ++ (pre r)\n</code></pre>\n\n<p>and in-order traversal resp. sequentialisation.</p>\n\n<pre><code>in L(x)     =&gt; [x]\nin N(x,l,r) =&gt; (in l) ++ [x] ++ (in r)\n</code></pre>\n\n<p>One can easily see that neither describes a given tree uniquely, even if we assume pairwise distinct keys/labels.</p>\n\n<p>Which combinations of the three can be used to that end and which can not?</p>\n\n<p>Positive answers should include an (efficient) algorithm to reconstruct the tree and a proof (idea) why it is correct. Negative answers should provide counter examples, i.e. different trees that have the same representation. </p>\n', 'Tags': '<algorithms><binary-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-20T19:49:58.823', 'CommentCount': '0', 'AcceptedAnswerId': '441', 'CreationDate': '2012-03-16T21:11:12.777', 'Id': '439'}{'ViewCount': '472', 'Title': 'Creating a Self Ordering Binary Tree', 'LastEditDate': '2012-04-12T05:55:04.773', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '79', 'FavoriteCount': '1', 'Body': "<p>I have an assignment where I need to make use a binary search tree and alter it to self order itself such that items that are accessed the most (have a higher priority) are at the top of the tree, the root being the most accessed node.</p>\n\n<p>The professor gave me the BST and node struct to work with, but trying to get my head around the algorithm to update the tree as things are being inserted is confusing me.</p>\n\n<p>I know that as the insert is happening, it checks if the current node's data is less or greater than the current node, then recursively goes in the correct direction until it finds a null pointer and inserts itself there. and after it is inserted it increases the priority by 1.</p>\n\n<pre><code>template &lt;class Type&gt;\nvoid BinarySearchTree&lt;Type&gt; ::  insert( const Type &amp; x, BinaryNode&lt;Type&gt; * &amp; t )\n{\n    if( t == NULL )\n        t = new BinaryNode&lt;Type&gt;( x, NULL, NULL );\n    else if( x &lt; t-&gt;element )\n        insert( x, t-&gt;left );\n    else if( t-&gt;element &lt; x )\n        insert( x, t-&gt;right );\n    else\n        t-&gt;priority++;  // Duplicate; do nothing for right now\n}\n</code></pre>\n\n<p>Now I need to figure out when the node is equal, how to re-order the tree so that the current node (who is equal to an already existing node) finds the existing node, increases that node's priority, then shifts it up if the root is a lower priority.</p>\n\n<p>I think I have the idea down that the AVL logic would work, and when a shift would take place, it would be a single rotation right or a single rotation left.</p>\n\n<p>Here's where I'm confused,  don't really know where to start with creating an algorithm to solve the problem. Since the AVL algorithm works with keeping track of the balance of a tree, then rotating nodes left or right accordingly, this tree doesn't need to worry about being balanced, just that the nodes with the highest priority not have children with a higher priority.</p>\n", 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-12T05:55:04.773', 'CommentCount': '0', 'AcceptedAnswerId': '610', 'CreationDate': '2012-03-21T00:05:18.697', 'Id': '559'}{'Body': '<p>Suppose we have a balanced binary tree, which represents a recursive partitioning of a set of $N$ points into nested subsets.  Each node of the tree represents a subset, with the following properties: subsets represented by two children nodes of the same parent are disjoint, and their union is equal to the subset represented by the parent.  The root represents the full set of points, and each leaf represents a single distinct point.  So there are $\\log N$ levels to the tree, and each level of the tree represents a partitioning of the points into increasingly fine levels of granularity.</p>\n\n<p>Now suppose we have two algorithms, each of which operates on all of the subsets of the tree.  The first does $O(D^2)$ operations at each node, where $D$ is the size of the subset represented by the node.  The second does $O(D \\log D)$ operations at each node.  What is the worst case runtime of these two algorithms?</p>\n\n<p>We can easily bound the first algorithm as $O(N^2 \\log N)$, because it does $O(N^2)$ work at each of $\\log N$ levels of the tree.  Similarly, we can bound the second algorithm as $O(N \\log ^2 N)$, by similar reasoning.</p>\n\n<p>The question is, are these bounds tight, or can we do better?  How do we prove it?</p>\n', 'ViewCount': '394', 'Title': 'What is the complexity of these tree-based algorithms?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-21T15:26:40.690', 'LastEditDate': '2012-03-21T06:35:12.333', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '579', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '363', 'Tags': '<algorithms><time-complexity><binary-trees>', 'CreationDate': '2012-03-21T04:43:41.727', 'Id': '578'}{'ViewCount': '893', 'Title': 'Logarithmic vs double logarithmic time complexity', 'LastEditDate': '2012-04-12T05:54:48.283', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '652', 'FavoriteCount': '2', 'Body': '<p>In real world applications is there a concrete benefit when using $\\mathcal{O}(\\log(\\log(n))$ instead of $\\mathcal{O}(\\log(n))$ algorithms ?</p>\n\n<p>This is the case when one use for instance van Emde Boas trees instead of more conventional binary search tree implementations. \nBut for example, if we take $n &lt; 10^6$ then in the best case the double logarithmic algorithm outperforms the logarithmic one by (approximately) a factor of $5$. And also in general the implementation is more tricky and complex. </p>\n\n<p>Given that I personally prefer BST over VEB-trees, what do you think ?</p>\n\n<p><em>One could easily demonstrate that :</em></p>\n\n<p>$\\qquad \\displaystyle \\forall n &lt; 10^6.\\ \\frac{\\log n}{\\log(\\log(n))} &lt; 5.26146$</p>\n', 'Tags': '<algorithms><complexity-theory><binary-trees><algorithm-analysis><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:54:23.937', 'CommentCount': '3', 'AcceptedAnswerId': '661', 'CreationDate': '2012-03-22T14:23:03.533', 'Id': '654'}{'ViewCount': '1315', 'Title': 'Proving a binary tree has at most $\\lceil n/2 \\rceil$ leaves', 'LastEditDate': '2012-03-30T02:27:43.967', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '756', 'FavoriteCount': '3', 'Body': '<p>I\'m trying to prove that a <a href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a> with $n$ nodes has at most $\\left\\lceil \\frac{n}{2} \\right\\rceil$ leaves. How would I go about doing this with induction?</p>\n\n<p><em>For people who were following in the original question about heaps, it has been moved <a href="http://cs.stackexchange.com/questions/841/proving-a-binary-heap-has-lceil-n-2-rceil-leaves">here</a>.</em></p>\n', 'Tags': '<data-structures><binary-trees><combinatorics><graph-theory><proof-techniques>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-10-01T04:35:17.907', 'CommentCount': '7', 'AcceptedAnswerId': '810', 'CreationDate': '2012-03-26T21:51:56.127', 'Id': '805'}{'Body': '<p>I\'m trying to prove that a <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heap</a> with $n$ nodes has exactly $\\left\\lceil \\frac{n}{2} \\right\\rceil$ leaves, given that the heap is built in the following way:</p>\n\n<p>Each new node is inserted via <a href="http://en.wikipedia.org/wiki/Binary_heap#Insert">percolate up</a>. This means that each new node must be created at the next available child. What I mean by this is that children are filled level-down, and left to right. For example, the following heap:</p>\n\n<pre><code>    0\n   / \\\n  1   2\n</code></pre>\n\n<p>would <b>have</b> to have been built in this order: 0, 1, 2. (The numbers are just indexes, they give no indication of the actual data held in that node.) </p>\n\n<p>This has two important implications:</p>\n\n<ol>\n<li><p>There can exist no node on level $k+1$ without level $k$ being completely filled</p></li>\n<li><p>Because children are built left to right, there can be no "empty spaces" between the nodes on level $k+1$, or situations like the following:  </p>\n\n<pre><code>    0\n   / \\\n  1   2\n / \\   \\\n3  4    6\n</code></pre></li>\n</ol>\n\n<p>(This would be an illegal heap by my definition.) Thus, a good way to think of this heap is an <a href="http://en.wikipedia.org/wiki/Binary_heap#Heap_implementation">array implementation</a> of a heap, where there can\'t be any "jumps" in indeces of the array.</p>\n\n<p>So, I was thinking induction would probably be a good way to do this... Perhaps something having to deal with even an odd cases for n. For example, some induction using the fact that even heaps built in this fashion must have an internal node with one child for an even n, and no such nodes for an odd n. Ideas?</p>\n', 'ViewCount': '853', 'Title': 'Proving a binary heap has $\\lceil n/2 \\rceil$ leaves', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-09T16:12:24.240', 'LastEditDate': '2012-03-28T06:42:55.933', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '843', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '756', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-03-28T00:56:55.877', 'Id': '841'}{'Body': '<p>Why cannot I find any information about spanning tree for DAG ?  I must be wrong somewhere.</p>\n', 'ViewCount': '427', 'Title': 'Does spanning tree make sense for DAG?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-31T07:20:13.363', 'LastEditDate': '2012-03-30T10:44:36.073', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '906', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '694', 'Tags': '<graphs><graph-theory><spanning-trees>', 'CreationDate': '2012-03-30T10:43:07.210', 'Id': '897'}{'Body': '<p>Consider a <a href="http://en.wikipedia.org/wiki/Minimax" rel="nofollow">minimax</a> tree for an adversarial search problem. For example, in this picture (alpha-beta pruning):</p>\n\n<p><img src="http://i.stack.imgur.com/NmKIO.jpg" alt="enter image description here"></p>\n\n<p>When marking the the tree with $[\\min,\\max]$ values bottom-up, we first traverse node $3$ and assign $B.\\max = 3$. Then we traverse $12$ and $8$ in this order, it will make sure $B.max = 3$.</p>\n\n<p>But why is $B.\\min = 3$? What is the use of that value?</p>\n', 'ViewCount': '311', 'Title': 'What use are the minimum values on minimax trees?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-06T17:30:48.237', 'LastEditDate': '2012-04-06T17:14:35.593', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '240', 'Tags': '<data-structures><trees><game-theory>', 'CreationDate': '2012-04-06T04:11:51.570', 'FavoriteCount': '0', 'Id': '1069'}{'ViewCount': '855', 'Title': 'Why does the splay tree rotation algorithm take into account both the parent and grandparent node?', 'LastEditDate': '2012-08-10T11:00:07.597', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '1056', 'FavoriteCount': '2', 'Body': '<p>I don\'t quite understand why the rotation in the splay tree data structure is taking into account not only the parent of the rating node, but also the grandparent (zig-zag and zig-zig operation). Why would the following not work:</p>\n\n<p>As we insert, for instance, a new node to the tree, we check whether we insert into the left or right subtree. If we insert into the left, we rotate the result RIGHT, and vice versa for right subtree. Recursively it would be sth like this</p>\n\n<pre><code>Tree insert(Tree root, Key k){\n    if(k &lt; root.key){\n        root.setLeft(insert(root.getLeft(), key);\n        return rotateRight(root);\n    }\n    //vice versa for right subtree\n}\n</code></pre>\n\n<p>That should avoid the whole "splay" procedure, don\'t you think?</p>\n', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '187', 'LastActivityDate': '2012-08-10T11:00:07.597', 'CommentCount': '0', 'AcceptedAnswerId': '1230', 'CreationDate': '2012-04-11T21:37:01.123', 'Id': '1229'}{'ViewCount': '638', 'Title': 'NP-completeness of a spanning tree problem', 'LastEditDate': '2012-05-18T16:16:57.077', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1108', 'FavoriteCount': '0', 'Body': '<p>I was reviewing some NP-complete problems on this site, and I meet one interesting problem from </p>\n\n<p><a href="http://cs.stackexchange.com/questions/808/np-completeness-proof-of-a-spanning-tree-problem">NP completeness proof of a spanning tree problem</a></p>\n\n<p>In this problem, I am interested in the original problem, which the leaf set is precisely $S$. The author said that he can prove this by reducing it to the Hamiltonian path. However, I still cannot figure it out. Could anybody help me with this in details?</p>\n', 'Tags': '<complexity-theory><np-complete><graph-theory><spanning-trees>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-18T16:49:04.167', 'CommentCount': '3', 'AcceptedAnswerId': '1912', 'CreationDate': '2012-04-16T03:30:50.807', 'Id': '1299'}{'Body': u"<p>There are some documents to be indexed, that means I need to read the docs and extract the words and index them by storing at which document they appear and at which position.</p>\n\n<p>For each word initially I am creating a separate file. Consider 2 documents:</p>\n\n<ul>\n<li>document 1: \u201cThe Problem of Programming Communication with\u201d</li>\n<li>document 2: \u201cProgramming of Arithmetic Operations\u201d</li>\n</ul>\n\n<p>Here, there are 10 words, 8 unique. So I create 8 files (<code>the</code>, <code>problem</code>, <code>of</code>, <code>programming</code>, <code>communications</code>, <code>with</code>, <code>arithmetic</code>, <code>operations</code>).</p>\n\n<p>In each file, I will store at which document they appear and at what position. The actual structure I am implementing has lot more information but this basic structure will serve the purpose.</p>\n\n<pre><code>file name        file content\nthe              1 1\nproblem          1 2\nof               1 3 2 2\nprogramming      1 4 2 1\ncommunications   1 5\nwith             1 6\narithmetic       2 3\noperations       2 4\n</code></pre>\n\n<p>Meaning. the word is located at document 1, position 3 and at document 2, position 2.</p>\n\n<p>After the initial index is done I will concatenate all the files into a single index file and in another file I store the offset where a particular word will be found.</p>\n\n<p>index file: <code>1 1 1 2 1 3 2 2 1 4 2 1 1 5 1 6 2 3 2 4</code><br>\noffset file: <code>the 1 problem 3 of 5 programming 9 communications 13  with 15 arithmetic 17 operations 19</code></p>\n\n<p>So if I need the index information for <code>communications</code>, I will go to position 13 of the file and read up to position 15 excluded, in other words the offset of the next word.</p>\n\n<p>This is all fine for static indexing. But if I change a single index the whole file will need to be rewritten. Can I use a binary tree as the index file's structure, so that I can dynamically change the file content and update the offset somehow ? </p>\n", 'ViewCount': '188', 'Title': 'Maintaining search indices with binary trees', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T11:42:40.107', 'LastEditDate': '2012-04-22T11:42:40.107', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '173', 'Tags': '<data-structures><binary-trees><data-mining>', 'CreationDate': '2012-04-20T19:32:58.920', 'Id': '1398'}{'Body': '<p>I am struggling with hashing and binary search tree material.\nAnd I read that instead of using lists for storing entries with the same hash values, it is also possible to use binary search trees. And I try to understand what the worst-case and average-case running time for the operations</p>\n\n<ol>\n<li><code>insert</code>, </li>\n<li><code>find</code> and</li>\n<li><code>delete</code></li>\n</ol>\n\n<p>is in worth- resp. average case. Do they improve with respect to lists?</p>\n', 'ViewCount': '1265', 'Title': 'Hashing using search trees instead of lists', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T15:37:46.957', 'LastEditDate': '2012-05-10T15:37:46.957', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<data-structures><time-complexity><runtime-analysis><search-trees><hash-tables>', 'CreationDate': '2012-05-08T21:46:33.920', 'Id': '1739'}{'Body': '<p>As a follow up to this <a href="http://cs.stackexchange.com/questions/368/counting-binary-trees">question</a> (the number of rooted binary trees of size n), how many possible binary trees can you have if the nodes are now labeled, so that abc is different than bac cab etc ? In other words, order matters. Certainly it will be much more than the Catalan number.</p>\n\n<p>What would the problem be if you have n-ary trees instead of binary ?  </p>\n\n<p>Are these known problems?  reference ?  </p>\n', 'ViewCount': '268', 'Title': 'Counting trees (order matters)', 'LastActivityDate': '2012-05-16T23:10:20.257', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '1876', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1419', 'Tags': '<binary-trees><combinatorics><trees>', 'CreationDate': '2012-05-09T21:20:54.163', 'Id': '1762'}{'ViewCount': '287', 'Title': 'What is postorder traversal on this simple tree?', 'LastEditDate': '2012-05-19T08:26:17.000', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'Jorge Zapata', 'PostTypeId': '1', 'OwnerUserId': '1547', 'Body': '<p>Given the following tree: </p>\n\n<p><img src="http://i.stack.imgur.com/GbJzO.png" alt="tree"></p>\n\n<p>Which traversal method would give as result the following output: CDBEA?</p>\n\n<p>The answer in my study guide is <em>Postorder</em>, but I think postorder would output: DEBCA. Am I wrong?</p>\n', 'Tags': '<algorithms><trees>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-19T08:26:17.000', 'CommentCount': '4', 'AcceptedAnswerId': '1916', 'CreationDate': '2012-05-18T18:03:56.970', 'Id': '1915'}{'ViewCount': '535', 'Title': 'How can I prove that a complete binary tree has $\\lceil n/2 \\rceil$ leaves?', 'LastEditDate': '2012-06-02T00:54:30.613', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Luc Peetersen', 'PostTypeId': '1', 'OwnerUserId': '1722', 'FavoriteCount': '2', 'Body': "<p>Given a complete binary tree with $n$ nodes. I'm trying to prove that a complete binary tree has exactly $\\lceil n/2 \\rceil$ leaves.\nI think I can do this by induction.</p>\n\n<p>For $h(t)=0$, the tree is empty. So there are no leaves and the claim holds for an empty tree.</p>\n\n<p>For $h(t)=1$, the tree has 1 node, that also is a leaf, so the claim holds.\nHere I'm stuck, I don't know what to choose as induction hypothesis and how to do the induction step.</p>\n", 'Tags': '<data-structures><graph-theory><proof-techniques><combinatorics><binary-trees>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-06-02T05:41:15.503', 'CommentCount': '6', 'AcceptedAnswerId': '2196', 'CreationDate': '2012-06-01T21:08:05.543', 'Id': '2193'}{'Body': '<p>If a weighted graph $G$ has two different minimum spanning trees $T_1 = (V_1, E_1)$ and $T_2 = (V_2, E_2)$, then is it true that for any edge $e$ in $E_1$, the number of edges in $E_1$ with the same weight as $e$ (including $e$ itself) is the same as the number of edges in $E_2$ with the same weight as $e$? If the statement is true, then how can we prove it?</p>\n', 'ViewCount': '1156', 'Title': 'Do the minimum spanning trees of a weighted graph have the same number of edges with a given weight?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-14T20:29:01.367', 'LastEditDate': '2012-06-02T23:23:48.057', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2211', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<graph-theory><spanning-trees><weighted-graphs>', 'CreationDate': '2012-06-02T22:25:00.557', 'Id': '2204'}{'Body': u"<p>I've been given the following problem:</p>\n\n<p>Given a data structure $M$ that is based on comparisons and supports the following methods on a group of numbers $S$:</p>\n\n<ul>\n<li>$\\text{Insert}(x)$ \u2013 add $x$ to $S$</li>\n<li>$\\text{Extract_min}()$ \u2013 remove the minimal element in $S$ and return it </li>\n</ul>\n\n<p>We can implement with a heap the above methods in $O(\\log n)$, however, we're looking at \na bigger picture, a general case that we have no guarantee that $M$ is indeed a heap. Prove that \nno matter what kind of data structure $M$ is, that <strong>at least one</strong> of the methods that $M$ supports must take $\\Omega(\\log n )$.</p>\n\n<p><strong>My solution:</strong></p>\n\n<p>Each sorting algorithm that is based on comparisons must take at the worst case at least $\\Omega(n\\log n)$ \u2013 we'll prove that using a decision tree: if we look at any given algorithm that is based on comparisons, as a binary tree where each vertex is a <em>compare-method</em> between 2 elements: </p>\n\n<ul>\n<li>if the first is bigger than the second element \u2013 we'll go to the left child</li>\n<li>if the second is bigger than the first element \u2013 we'll go to the right child</li>\n</ul>\n\n<p>At the end, we'll have $n!$ leaves that are the options for sorting the elements.</p>\n\n<p>The height of the tree is $h$, then:</p>\n\n<p>$$2^h \\ge n! \\quad\\Longrightarrow\\quad \\log(2^h) &gt;= \\log(n!) \\quad\\Longrightarrow\\quad h \\ge \\log(n!) \\quad\\Longrightarrow\\quad h = \\Omega(n \\log n)$$</p>\n\n<p>Then, if we have a $\\Omega(n \\log n)$ worst case for $n$ elements, then we have a $\\Omega(\\log n)$ for a single element. </p>\n\n<p>I'm not sure regarding this solution, so I'd appreciate for corrections or anything else \nyou can come up with. </p>\n", 'ViewCount': '311', 'Title': 'Prove that for a general data structure - operations Extract_min() and Insert(x) cost $\\Omega(\\log n)$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-26T12:42:03.597', 'LastEditDate': '2012-06-26T12:42:03.597', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '776', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'CreationDate': '2012-06-23T13:38:12.030', 'FavoriteCount': '0', 'Id': '2459'}{'Body': u'<p>I\'ve been reading a bit of the literature lately, and have found some rather interesting data-structures.</p>\n\n<p>I have researched various different methods of getting update times down to $\\mathcal{O}(1)$ worst-case update time [1-7].</p>\n\n<p>Recently I begun looking into lock-free data-structures, to support efficient concurrent access.</p>\n\n<p><strong>Have any of these worst-case $\\mathcal{O}(1)$ update-time techniques been used in the implementation of lock-free data structures?</strong></p>\n\n<p>I ask because; to me, they seem like the obvious practical extension of this "theoretical enhancement".</p>\n\n<hr>\n\n<ol>\n<li><p><a href="http://www.sciencedirect.com/science/article/pii/0020019083900996">Tarjan, Robert Endre. \u201cUpdating a Balanced Search Tree in O(1) Rotations.\u201d Information Processing Letters 16, no. 5 (1983): 253 \u2013 257.</a></p></li>\n<li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.133.4630">Driscoll, J R, N Sarnak, D D Sleator, and R E Tarjan. \u201cMaking Data Structures Persistent.\u201d In Proceedings of the Eighteenth Annual ACM Symposium on Theory of Computing, 109\u2013121. STOC  \u201986. New York, NY, USA: ACM, 1986.</a></p></li>\n<li><p><a href="http://dx.doi.org/10.1007/BF00299635">Levcopoulos, C., and Mark H. Overmars. \u201cA Balanced Search Tree with O(1) Worst Case Update Time.\u201d Acta Inf. 26, no. 3 (November 1988): 269\u2013277.</a></p></li>\n<li><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.9433">Fleischer, Rudolf. A Simple Balanced Search Tree With O(1) Worst-Case Update Time</a></p></li>\n<li><p><a href="http://dx.doi.org/10.1016/0020-0190%2894%2900115-4">Dietz, Paul F, and Rajeev Raman. \u201cA Constant Update Time Finger Search Tree.\u201d Information Processing Letters 52, no. 3 (1994): 147 \u2013 154.</a></p></li>\n<li><p><a href="http://dl.acm.org/citation.cfm?id=998223.998229">Lagogiannis, George, Christos Makris, Yannis Panagis, Spyros Sioutas, and Kostas Tsichlas. \u201cNew Dynamic Balanced Search Trees with Worst-case Constant Update Time.\u201d J. Autom. Lang. Comb. 8, no. 4 (July 2003): 607\u2013632.</a></p></li>\n<li><p><a href="http://www.cs.au.dk/~gerth/papers/stoc02.pdf">Brodal, Gerth St\xf8lting, George Lagogiannis, Christos Makris, Athanasios Tsakalidis, and Kostas Tsichlas. \u201cOptimal Finger Search Trees in the Pointer Machine.\u201d J. Comput. Syst. Sci. 67, no. 2 (September 2003): 381\u2013418.</a></p></li>\n</ol>\n', 'ViewCount': '506', 'Title': 'Lock-free, constant update-time concurrent tree data-structures?', 'LastEditorUserId': '1120', 'LastActivityDate': '2013-05-14T16:27:44.497', 'LastEditDate': '2012-07-18T05:21:06.267', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '1120', 'Tags': '<reference-request><data-structures><time-complexity><concurrency><search-trees>', 'CreationDate': '2012-07-10T20:04:39.177', 'FavoriteCount': '5', 'Id': '2680'}{'Body': "<p>Is there any formal definition about the average height of a binary tree?</p>\n\n<p>I have a tutorial question about finding the average height of a binary tree using the following two methods:</p>\n\n<ol>\n<li><p>The natural solution might be to take the average length of all possible\npaths from the root to a leaf, that is</p>\n\n<p>$\\qquad \\displaystyle \\operatorname{avh}_1(T) = \\frac{1}{\\text{# leaves in } T} \\cdot \\sum_{v \\text{ leaf of } T} \\operatorname{depth}(v)$.</p></li>\n<li><p>Another option is to define it recursively, that is the average height for a node is the average over the average heights of the subtrees plus\none, that is </p>\n\n<p>$\\qquad \\displaystyle \\operatorname{avh}_2(N(l,r)) = \\frac{\\operatorname{avh}_2(l) + \\operatorname{avh}_2(r)}{2} + 1$</p>\n\n<p>with $\\operatorname{avh}_2(l) = 1$ for leafs $l$ and $\\operatorname{avh}_2(\\_) = 0$ for empty slots.</p></li>\n</ol>\n\n<p>Based on my current understanding, for example the average height of the tree $T$</p>\n\n<pre><code>    1    \n   / \\\n  2   3\n /\n4\n</code></pre>\n\n<p>is $\\operatorname{avh}_2(T) = 1.25$ by the second method, that is using recursion.</p>\n\n<p>However, I still don't quite understand how to do the first one. $\\operatorname{avh}_1(T) = (1+2)/2=1.5$ is not correct.</p>\n", 'ViewCount': '825', 'Title': 'What is the average height of a binary tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-22T09:42:41.200', 'LastEditDate': '2012-07-22T09:42:37.330', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '2859', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1895', 'Tags': '<graph-theory><terminology><combinatorics><binary-trees>', 'CreationDate': '2012-07-16T13:55:13.860', 'Id': '2762'}{'Body': u'<p><a href="http://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm">Bor\u016fvka\'s algorithm</a> is one of the standard algorithms for calculating the minimum spanning tree for a graph $G = (V,E)$, with $|V| = n, |E| = m$.</p>\n\n<p>The pseudo-code is:</p>\n\n<pre><code>MST T = empty tree\nBegin with each vertex as a component\nWhile number of components &gt; 1\n    For each component c\n       let e = minimum edge out of component c\n       if e is not in T\n           add e to T  //merging the two components connected by e\n</code></pre>\n\n<p>We call each iteration of the outer loop a round. In each round, the inner loop cuts the number of components at least in half. Therefore there are at most $O(\\log n)$ rounds. In each round, the inner loop looks at each edge at most twice (once from each component). Therefore the running time is at most $O(m \\log n)$.</p>\n\n<p>Now suppose after each round, we remove all the edges which only connect vertices within the same component and also remove duplicate edges between components, so that the inner loop only looks at some number of edges m\' &lt; m which are the minimum weight edges which connect two previously disconnected components. </p>\n\n<p><strong>How does this optimization affect the running time?</strong></p>\n\n<p>If we somehow knew that in each round, it would cut the number of edges in half, then the running time would be significantly improved:\n$T(m) = T(m /2) + O(m) = O(m)$.</p>\n\n<p>However, while the optimization will dramatically reduce the number of edges examined, (only 1 edge by the final round, and at most # of components choose 2 in general), it\'s not clear how/if we can use this fact to tighten the analysis of the run-time. </p>\n', 'ViewCount': '374', 'Title': u"Tighter analysis of modified Bor\u016fvka's algorithm", 'LastActivityDate': '2012-07-20T08:15:16.420', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2829', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '71', 'Tags': '<algorithms><algorithm-analysis><spanning-trees>', 'CreationDate': '2012-07-18T18:53:31.420', 'FavoriteCount': '3', 'Id': '2816'}{'Body': "<p>Is there a way to reconstruct a binary tree just from its in-order representation?</p>\n\n<p>I've searched the internet, but I could only find solutions for reconstructing a binary tree from inorder and preorder representations, but none for only inorder.</p>\n", 'ViewCount': '316', 'Title': 'From in-order representation to binary tree', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-19T21:10:44.540', 'LastEditDate': '2012-07-19T08:49:01.357', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'papen', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><binary-trees>', 'CreationDate': '2012-07-18T19:23:00.627', 'Id': '2817'}{'Body': "<p>In the book 'Introduction to Algorithms 3/e', I have found the following definition of Binary Search Tree property:</p>\n\n<blockquote>\n  <p>Let $x$ be a node in a binary search tree. If $y$ is a node in the left subtree\n  of $x$, then $y.key \\leq x.key$. If $y$ is a node in the right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n\n<p>My confusion is that while implementing binary search trees we either consider that the keys of left-subtree of a node $x$ would be $\\leq x.key$ <strong>or</strong> the keys of right-subtree of a node $x$ would be $\\geq x.key$ but <strong>not both</strong>. That is we follow one of the two convention. But in the property they have included $=$ in both the cases. Where am I wrong?</p>\n\n<p>I would appreciate any idea on this issue.</p>\n", 'ViewCount': '274', 'Title': 'Binary Search Tree Property', 'LastEditorUserId': '29', 'LastActivityDate': '2012-08-29T00:50:34.147', 'LastEditDate': '2012-08-28T11:38:51.780', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2556', 'Tags': '<terminology><data-structures><binary-trees><search-trees>', 'CreationDate': '2012-08-28T05:54:20.237', 'Id': '3345'}{'Body': "<p>Given a directed graph $G=(V,E)$ and a node $r\\in V$, I need to grow a tree $T$ rooted at $r$ that has a minimum weight and spans all reachable nodes in $G$.</p>\n\n<p>The weight function assigns a non-negative weight to each node, which depends on the node's ancestors in $T$.  Specifically, for some fixed sets of nodes $S_1, S_2, \\dots, S_k \\subseteq V$, the weight of node $v$ is the number of sets $S_i$ that contain $v$ and all its ancestors in $T$.</p>\n\n<p>Any suggestion how to approach this problem?</p>\n", 'ViewCount': '141', 'Title': 'Minimum vertex-weight directed spanning tree where the weight function depends on the tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-13T06:27:26.233', 'LastEditDate': '2012-09-13T06:27:26.233', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2774', 'Tags': '<algorithms><graph-theory><optimization><spanning-trees>', 'CreationDate': '2012-09-10T07:57:07.253', 'FavoriteCount': '1', 'Id': '3486'}{'Body': '<p>I have seen two definitions of balanced binary trees, which look different to me.</p>\n\n<ol>\n<li><p>A binary tree is balanced if for each node it holds that the number of inner nodes in the left subtree and the number of inner nodes in the right subtree differ by at most 1.</p></li>\n<li><p>A binary tree is balanced if for any two leaves the difference of the depth is at most 1.</p></li>\n</ol>\n\n<p>Does every tree that satisfies def. 1 also satisfy def. 2? What about the other way round?</p>\n', 'ViewCount': '1138', 'Title': 'Two definitions of balanced binary trees', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-12T22:31:04.060', 'LastEditDate': '2012-09-12T20:24:51.237', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-09-12T17:37:24.510', 'FavoriteCount': '1', 'Id': '3515'}{'Body': '<p>I was watching the <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-16-greedy-algorithms-minimum-spanning-trees/" rel="nofollow">video lecture from MIT on Prim\'s algorithm for minimum spanning trees</a>.\nWhy do we need to do the swap step for proving the theorem that if we choose a set of vertices  in minimum spanning tree of $G(V,E)$and let us call that $A$ such  $A\\subset B$,  the edge with the least weight connecting $A$ to $V-A$ will always be in the minimum spanning tree ?  The professor has done the swap step at point 59:07 seconds in the video.</p>\n', 'ViewCount': '179', 'Title': "Why do the swap step in Prim's algorithm for minimum spanning trees?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-20T06:52:26.807', 'LastEditDate': '2012-09-19T21:19:36.247', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4624', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graph-theory><algorithm-analysis><greedy-algorithms><spanning-trees>', 'CreationDate': '2012-09-19T13:11:11.090', 'Id': '4614'}{'Body': '<p>Consider a graph $G(V,E)$. Each edge $e$ has two weights $A_e$ and $B_e$. Find a spanning tree that minimizes the product $\\left(\\sum_{e \\in T}{A_e}\\right)\\left(\\sum_{e \\in T}{B_e}\\right)$. The algorithm should run in polynomial time with respect to $|V|, |E|$.</p>\n\n<p>I find it difficult to adapt any of the traditional algorithms on spanning trees(Kruskal, Prim, Edge-Deletion). How to solve it? Any hints?</p>\n', 'ViewCount': '250', 'Title': 'Minimal Spanning Tree With Double Weight Parameters', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-14T05:06:23.300', 'LastEditDate': '2012-09-21T13:05:45.600', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '848', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2012-09-20T14:50:02.843', 'FavoriteCount': '6', 'Id': '4635'}{'Body': '<p>The notion of best-case running time is kind of ambiguous for me. According to wikipedia, the definition of best case running time is:</p>\n\n<blockquote>\n  <p>The term best-case performance is used in computer science to describe the way of an algorithm behaves under optimal conditions. For example, the best case for a simple linear search on a list occurs when the desired element is the first element of the list.</p>\n</blockquote>\n\n<p>According to this definition, the best case running time for BST insertion should be $O(1)$ [consider that we are inserting to the root node]. But different resources says different things, some claim that it is $O(\\log n)$ [perfect balanced tree] and some others claim that it is $O(1)$ which one should I believe?</p>\n', 'ViewCount': '1986', 'Title': 'Best-Case Running Time For Binary Search Tree Insertion', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-24T22:16:37.427', 'LastEditDate': '2012-09-24T22:12:54.513', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4725', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2956', 'Tags': '<terminology><data-structures><runtime-analysis><binary-trees>', 'CreationDate': '2012-09-24T21:48:27.473', 'Id': '4723'}{'Body': '<p>I am trying to derive the <a href="http://alexandria.tue.nl/repository/freearticles/597601.pdf">classic paper</a> in the title only by elementary means (no generating functions, no complex analysis, no Fourier analysis) although with much less precision. In short, I "only" want to prove that the average height $h_n$ of a tree with $n$ nodes (that is, the maximum number of nodes from the root to a leaf) satisfies $h_n \\sim \\sqrt{\\pi n}$.</p>\n\n<p>The outline is as follows. Let $A_{nh}$ be the number of trees with height less than or equal to $h$ (with the convention $A_{nh} = A_{nn}$ for all $h \\geqslant n$) and $B_{nh}$ the number of trees of $n$ nodes with height greater than or equal to $h+1$ (that is, $B_{nh} = A_{nn} - A_{nh}$). Then $h_n = S_n/A_{nn}$, where $S_n$ is the finite sum\n$$\nS_n = \\sum_{h \\geqslant 1} h(A_{nh} - A_{n,h-1}) = \\sum_{h \\geqslant 1} h(B_{n,h-1} - B_{nh}) = \\sum_{h \\geqslant 0} B_{nh}.\n$$\nIt is well known that $A_{nn} = \\frac{1}{n}\\binom{2n-2}{n-1}$, for the set of general trees with $n$ nodes is in bijection with the set of binary trees with $n-1$ nodes, counted by the Catalan numbers.</p>\n\n<p>Therefore, the first step is to find $B_{nh}$ and then the main term in the asymptotic expansion of $S_n$.</p>\n\n<p>At this point the authors use analytical combinatorics (three pages) to derive\n$$\nB_{n+1,h-1} = \\sum_{k \\geqslant 1} \\left[\\binom{2n}{n+1-kh} - 2\\binom{2n}{n-kh} + \\binom{2n}{n-1-kh}\\right].\n$$</p>\n\n<blockquote>\n  <p>My own attempt is as follows. I consider the bijection between trees with $n$ nodes\n  and monotonic paths on a square grid $(n-1) \\times (n-1)$ from $(0,0)$ to $(n-1,n-1)$ which do not cross the diagonal (and are made of two kinds of steps: $\\uparrow$ and $\\rightarrow$). These paths are sometimes called <em>Dyck paths</em> or <em>excursions</em>. I can express now $B_{nh}$ in terms of lattice paths: it is the number of Dyck paths of length 2(n-1) and height greater than or equal to $h$. (Note: a tree of height $h$ is in bijection with a Dyck path of height $h-1$.)</p>\n  \n  <p>Without loss of generality, I assume that they start with $\\uparrow$ (hence stay above the diagonal). For each path, I consider the first step crossing the line $y = x + h - 1$, if any. From the point above, all the way back to the origin, I change $\\uparrow$ into $\\rightarrow$ and vice versa (this is a <em>reflection</em> wrt the line $y=x+h$). It becomes apparent that the paths I want to count ($B_{nh}$) are in bijection with the monotonic paths from $(-h,h)$ to $(n-1,n-1)$ which avoid the boundaries $y=x+2h+1$ and $y=x-1$. (See <a href="http://www.filedropper.com/lattice">figure</a>.)</p>\n</blockquote>\n\n<p>In the classic book <em>Lattice Path Counting and Applications</em> by Mohanty (1979, page 6) the formula\n$$\n\\sum_{k \\in \\mathbb{Z}} \\left[\\binom{m+n}{m-k(t+s)} - \\binom{m+n}{n+k(t+s)+t}\\right],\n$$\ncounts the number of monotonic paths in a lattice from $(0,0)$ to $(m,n)$, which avoid the boundaries $y = x - t$ and $y = x + s$, with $t &gt; 0$ and $s &gt; 0$. (This result was first established by Russian statisticians in the 50s.) Therefore, by considering a new origin at $(-h,h)$, we satisfy the conditions of the formula: $s=1$, $t=2h+1$ and the destination point (the upper right corner) is now $(n+h-1,n-h-1)$. Then\n$$\nB_{nh} = \\sum_{k \\in \\mathbb{Z}} \\left[\\binom{2n-2}{n+h-1-k(2h+2)} - \\binom{2n-2}{n-h-1+k(2h+2) + 2h+1}\\right].\n$$\nThis can be simplified in\n$$\nB_{n+1,h-1} = \\sum_{k \\in \\mathbb{Z}} \\left[\\binom{2n}{n+1-(2k+1)h} - \\binom{2n}{n-(2k+1)h}\\right],\n$$\nwhich, in turn, is equivalent to\n$$\nB_{n+1,h-1} = \\sum_{k \\geqslant 0} \\left[\\binom{2n}{n+1-(2k+1)h} - 2\\binom{2n}{n-(2k+1)h} + \\binom{2n}{n-1-(2k+1)h}\\right].\n$$\nThe difference with the expected formula is that I sum over the odd numbers ($2k+1$), instead of all positive integers ($k$).</p>\n\n<p>Any idea where the problem is?</p>\n', 'ViewCount': '202', 'Title': 'On "The Average Height of Planted Plane Trees" by Knuth, de Bruijn and Rice (1972)', 'LastEditorUserId': '2993', 'LastActivityDate': '2012-09-30T09:32:05.513', 'LastEditDate': '2012-09-30T09:32:05.513', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2993', 'Tags': '<combinatorics><discrete-mathematics><trees><average-case><random-walks>', 'CreationDate': '2012-09-28T12:20:51.920', 'Id': '4777'}{'Body': '<p>This is part of a larger problem, which I believe I have reduced to this. Given a tree $T$ having positive edge weights, and $k$ leaves (nodes which have exactly one connected node), I need to delete some edges in the tree so that no two leaves in the original tree are connected (by a path) in the newly formed forest (of trees). The total sum of the weights of the deleted edges needs to be minimized.</p>\n\n<p>My understanding is that atleast $k-1$ edges need to be deleted to separate out all the $k$ leaves. Any more deletions will unnecessarily increase the total cost. Thus, we need to perform exactly $k-1$ deletions.</p>\n\n<p>My hypothesis:\nFor every pair of leaf nodes $l_i$ and $l_j$, find the edge with the minimum weight in the (unique) path from $l_i$ to $l_j$. The $k-1$ least weight edges from this set of edges need to be deleted. This will minimize the sum of weights of the edges to be deleted in order to disconnect all leaves from each other.</p>\n\n<p>I am unable to prove or disprove this hypothesis. Can someone please prove the correctness of this hypothesis, or give a counter-example along with the correct algorithm to solve this problem? If this is indeed correct, is there a faster way (asymptotic complexity wise) to solve this problem? This approach will take $\\Theta({k^2})$ time. Thanks in advance!</p>\n', 'ViewCount': '210', 'Title': 'Separate all leaves of a weighted tree with minimum weight cuts', 'LastActivityDate': '2014-01-23T09:20:39.300', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '6396', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '3011', 'Tags': '<algorithms><graph-theory><trees>', 'CreationDate': '2012-10-06T05:53:00.637', 'FavoriteCount': '1', 'Id': '4898'}{'Body': "<p>I have a formula $ \\neg((q \\implies \\neg q) \\vee p \\vee (\\neg q \\implies (r \\wedge p))) $.</p>\n\n<p>As it contains 3 subformulas between the $\\vee$'s, how can i put it into a parse tree, as a parse tree contains 2 branches from each node.</p>\n", 'ViewCount': '242', 'Title': 'How to make a parse tree for the following propositional logic formula?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T09:21:21.817', 'LastEditDate': '2012-10-07T16:22:33.433', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '4921', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3088', 'Tags': '<formal-languages><logic><binary-trees><parsing>', 'CreationDate': '2012-10-07T12:33:25.243', 'Id': '4918'}{'Body': '<p>I have a forest, i.e., nodes with directed edges and no cycles (directed or undirected). I define the height of a vertex $v$ as 0 if it does not have any incoming edges, or the maximum number of edges to traverse in reverse to reach a vertex of height 0. \n<img src="http://i.stack.imgur.com/WzfAx.png" alt="enter image description here"></p>\n\n<p>I also know that the average degree of a node is a small constant, say 2 or so. To find the height of all vertices, I can think of two algorithms:</p>\n\n<p>Walking Algorithm</p>\n\n<ol>\n<li>Go through and mark $h=0$ for vertices with no incoming edges.</li>\n<li>For each vertex with $h=0$, follow the outgoing edges, updating the height of each encountered vertex if it\'s previous height is smaller.</li>\n</ol>\n\n<p>Frontier Algorithm</p>\n\n<ol>\n<li>Go through and mark $h=0$ for vertices with no incoming edges, and mark these as the frontier.</li>\n<li>For every frontier vertex, see if it\'s parent has children at or below the frontier, If it does, mark the parent as having $1$ plus the largest height among its children. Mark the parent as being on the frontier.</li>\n<li>Repeat 2 until there is nothing beyond the frontier.</li>\n</ol>\n\n<p>My questions:</p>\n\n<ol>\n<li>Is there a name for this problem, and a well known fastest solution?</li>\n<li>I tend to think simply walking up from all the $h=0$ vertices is the fastest solution. Am I right?</li>\n</ol>\n', 'ViewCount': '206', 'Title': 'Finding the height of all nodes in a forest', 'LastEditorUserId': '3159', 'LastActivityDate': '2012-10-12T17:47:57.643', 'LastEditDate': '2012-10-11T22:03:43.253', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '8', 'OwnerDisplayName': 'highBandWidth', 'PostTypeId': '1', 'OwnerUserId': '3159', 'Tags': '<algorithms><trees><graph-traversal>', 'CreationDate': '2012-10-11T18:13:18.083', 'Id': '5027'}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/439/which-combinations-of-pre-post-and-in-order-sequentialisation-are-unique">Which combinations of pre-, post- and in-order sequentialisation are unique?</a>  </p>\n</blockquote>\n\n\n\n<p>I have three different tree traversal of a binary tree Inorder, Preorder and Postorder. I want to identify the tree back from these traversal. I found that a single traversal cant not identify the tree.<br>\n So if I\'ll take in pair then can I identiy the tree?</p>\n', 'ViewCount': '40', 'ClosedDate': '2012-10-13T23:11:23.750', 'Title': 'How to identify a binary tree uniquely if its Inorder, Preorder and Postorder traversal is given?', 'LastActivityDate': '2012-10-13T04:52:21.040', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3075', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-10-13T04:52:21.040', 'Id': '5039'}{'Body': '<p>This is a GRE practice question. </p>\n\n<p><img src="http://i.stack.imgur.com/dUavw.png" alt="BST n=8"></p>\n\n<p>If a node in the binary search tree above is to be located by binary tree search, what is the expected number of comparisons required to locate one of the items (nodes) in the tree chosen at random?</p>\n\n<p>(A) 1.75 </p>\n\n<p>(B) 2 </p>\n\n<p>(C) 2.75 </p>\n\n<p>(D) 3 </p>\n\n<p>(E) 3.25</p>\n\n<p>My answer was 3 because $n=8$ and $\\lg(n)$ comparisons should be made, and $\\lg(8) = 3$. But the correct answer is 2.75. Can someone explain the correct answer? Thanks!</p>\n', 'ViewCount': '1385', 'Title': 'Average number of comparisons to locate item in BST', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-16T15:02:35.267', 'LastEditDate': '2012-10-15T08:13:09.373', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6089', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4198', 'Tags': '<binary-trees><probability-theory><search-trees><average-case>', 'CreationDate': '2012-10-15T06:49:28.390', 'Id': '6085'}{'Body': u'<p>This question assumes the definition of a complete binary tree to be<sup>\u2020</sup>:</p>\n\n<blockquote>\n  <p>A binary tree $T$ with $N$ levels is complete if all levels except possibly the last are completely full, and the last level has all its nodes to the left side.</p>\n</blockquote>\n\n<p>The following is an excerpt from <em><a href="http://www.amazon.ca/Algorithms-Sanjoy-Dasgupta/dp/0073523402" rel="nofollow">Algorithms</a></em>:</p>\n\n<blockquote>\n  <p>It ($\\log N$) is also the depth of a complete binary tree with $N$ nodes. (More precisely: $\u230a\\log N\u230b$.)</p>\n</blockquote>\n\n<p>Why is the above excerpt valid?</p>\n\n<p><sup>\u2020</sup> Originally defined <a href="http://courses.cs.vt.edu/~cs3114/Summer11/Notes/T03a.BinaryTreeTheorems.pdf" rel="nofollow">here</a>  </p>\n', 'ViewCount': '1528', 'Title': 'What is the depth of a complete binary tree with $N$ nodes?', 'LastActivityDate': '2012-10-19T06:27:37.757', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6162', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4267', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-10-19T03:19:21.177', 'Id': '6161'}{'Body': u"<blockquote>\n  <p>Let $f(N)$ be the average number of full nodes (nodes with two children) in an $N$-node binary search tree.</p>\n  \n  <ol>\n  <li>Determine the values of $f(0)$ and $f(1)$. </li>\n  <li><p>Given that for $N &gt; 1$, </p>\n  \n  <p>$\\qquad \\displaystyle f(N) = \\frac{N-2}{N} + \\frac{1}{N} \\sum_{i=0}^{N-1} [f(i) + f(N - i - 1)]$,</p>\n  \n  <p>show that $f(N) = \\frac{N - 2}{3}$.</p></li>\n  <li>Using this information, show that the average number of nodes with one child in a binary search tree is $\\frac{N + 1}{3}$.</li>\n  </ol>\n</blockquote>\n\n<p>I know that for (1) both values are $0$. I mainly need help proving (2).\nI also found some hints for (2) and (3) but I can't figure it out:</p>\n\n<p>(2) The root contributes $\\frac{N \u2212 2}{N}$ full nodes on average, because the root is full as long as it does not contain the largest or smallest item. The remainder of the equation is the expected contribution of the subtrees.</p>\n\n<p>(3) The average number of leaves is $\\frac{N + 1}{3}$.</p>\n\n<p>Any help would be appreciated, even just pointing me in the right direction. Thanks!</p>\n", 'ViewCount': '517', 'Title': 'Average number of full nodes in a binary search tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T16:49:13.143', 'LastEditDate': '2012-10-22T15:51:25.087', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user1758064', 'PostTypeId': '1', 'Tags': '<data-structures><combinatorics><recurrence-relation><binary-trees>', 'CreationDate': '2012-10-19T02:17:50.273', 'Id': '6179'}{'Body': u'<p>From <a href="http://fileadmin.cs.lth.se/cs/Personal/Rolf_Karlsson/lect12.pdf" rel="nofollow">Van Emde Boas trees lecture</a>:</p>\n\n<blockquote>\n  <p>We will use the idea of superimposing a tree of degree ${u^{1/2}}$ on top of\n  a bit vector, but <strong>shrink the universe size recursively</strong> by a square\n  root at each tree level. The ${u^{1/2}}$ items on the \ufb01rst level each hold\n  structures of ${u^{1/4}}$ items, which hold structures of ${u^{1/8}}$ items, and\n  so on, down to size 2.\n  I have a  question regarding van Emde Boas trees :</p>\n</blockquote>\n\n<ol>\n<li>How is the universe size getting reduced ? Aren\'t we just spreading the universe keys which is always constant at $u$ to different levels ? I can not understand the idea of "<strong>shriniking</strong>" the universe size .  I find similar language is used in defining the recursive structure for Van Emde Boas tree in <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/" rel="nofollow">Introduction to Algorithms</a> by CLRS also .</li>\n</ol>\n', 'ViewCount': '563', 'Title': 'Explanation of recursive structure of Van Emde Boas Tree', 'LastEditorUserId': '2223', 'LastActivityDate': '2013-01-18T15:27:02.663', 'LastEditDate': '2012-10-22T09:04:38.213', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6197', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><data-structures><algorithm-analysis><search-trees><trees>', 'CreationDate': '2012-10-20T14:15:05.167', 'Id': '6192'}{'Body': '<p>In order to achieve the time complexity of $O(\\log \\log u)$ for van Emde Boas trees I read in <a href="http://fileadmin.cs.lth.se/cs/Personal/Rolf_Karlsson/lect12.pdf" rel="nofollow">this lecture</a> that the the universe size  $u$  is chosen as $u = 2^{2^k}$ for some integer $k$ for van Emde Boas trees. Why choose $u$ to be of this specific form ?</p>\n', 'ViewCount': '116', 'Title': 'Size of the universe for van Emde Boas Trees', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-20T14:34:19.040', 'LastEditDate': '2012-10-20T14:34:19.040', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6195', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><data-structures><algorithm-analysis><binary-trees><trees>', 'CreationDate': '2012-10-20T14:22:39.857', 'Id': '6193'}{'ViewCount': '92', 'Title': 'Constructing a tree from disjoint graphs', 'LastEditDate': '2012-10-23T09:13:36.870', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'BadAtGraphs', 'PostTypeId': '1', 'OwnerUserId': '4330', 'Body': '<p>I will preface my question with the definition of a simple tree that applies to my question:</p>\n\n<blockquote>\n  <p>A simple tree is an undirected and connected graph with no cycles.</p>\n</blockquote>\n\n<p>I am having difficulty coming up with a compelling argument that a tree of the above definition can be constructed by taking a set of disjoint valid graphs and adding a vertex between each of them. The practice problem states:</p>\n\n<blockquote>\n  <p>Prove that some graph $G$ is a tree if and only if it can be constructed from a set $X_1, X_2, \\dots, X_i$ of disjoint valid graphs by adding a new node adjacent to one node from each of $X_1,\\dots, X_i$. A single node is a valid graph.</p>\n</blockquote>\n\n<p>I\'m confused whether this question is asking me to prove that two graphs, or trees ("valid"), can be made into one tree by adding a node and adding edges from one preexisting node from each of the trees. If that is how the question should be interpreted, then is it enough to prove that the new tree (or "graph," I guess) has no cycles, and is connected?</p>\n\n<p>I\'m new to graph theory and I\'m wondering if you can help me understand it.</p>\n', 'Tags': '<graph-theory><trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-23T09:13:36.870', 'CommentCount': '0', 'AcceptedAnswerId': '6252', 'CreationDate': '2012-10-22T20:36:40.003', 'Id': '6249'}{'ViewCount': '3499', 'Title': 'Why is the minimum height of a binary tree $\\log_2(n+1) - 1$?', 'LastEditDate': '2012-10-24T22:18:38.927', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Imray', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '0', 'Body': "<p>In my Java class, we are learning about complexity of different types of collections.</p>\n\n<p>Soon we will be discussing binary trees, which I have been reading up on. The book states that the minimum height of a binary tree is $\\log_2(n+1) - 1$, but doesn't offer further explanation.</p>\n\n<p>Can someone explain why?</p>\n", 'Tags': '<data-structures><binary-trees><discrete-mathematics><trees>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-10-24T22:18:38.927', 'CommentCount': '1', 'AcceptedAnswerId': '6282', 'CreationDate': '2012-10-23T22:12:56.283', 'Id': '6277'}{'ViewCount': '1759', 'Title': 'Proof that a randomly built binary search tree has logarithmic height', 'LastEditDate': '2012-10-28T11:16:30.370', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '1', 'Body': '<p>How do you prove that the expected height of a randomly built <a href="http://en.wikipedia.org/wiki/Binary_search_tree" rel="nofollow">binary search tree</a> with $n$ nodes is $O(\\log n)$? There is a proof in CLRS <em>Introduction to Algorithms</em> (chapter 12.4), but I don\'t understand it.</p>\n', 'Tags': '<data-structures><algorithm-analysis><binary-trees><search-trees><average-case>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T12:56:45.620', 'CommentCount': '4', 'AcceptedAnswerId': '6356', 'CreationDate': '2012-10-27T19:37:43.787', 'Id': '6342'}{'Body': '<p>Suppose I am making a red-black search tree, and in my right subtree, I have a black node, then a red node, and it has two black children, the black children further black childrens. As such a lemma has been made that red-black trees with $n$ internal nodes have height at most $2\\log(n+1)$, would this proof still hold for such a black tree?</p>\n', 'ViewCount': '64', 'Title': 'Can you have three consecutive black nodes in red-black search tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T10:55:19.397', 'LastEditDate': '2012-10-28T10:55:19.397', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6344', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2012-10-27T23:52:30.187', 'Id': '6343'}{'Body': u'<p><img src="http://i.stack.imgur.com/2hUx4.jpg" alt="search tree"></p>\n\n<p><strong>Problem : Two players have in front of\nthem a single pile of objects, say a stack of 7 pennies. The first player divides the original\nstack into two stacks that must be unequal. Each player alternatively thereafter does the\nsame to some single stack when it is his turn to play. The game proceeds until each stack has\neither just one penny or two\u2014at which point continuation becomes impossible. The player\nwho first cannot play is the loser. Show, by drawing a game tree, whether any of the players\ncan always win.</strong></p>\n\n<p>Why is the state 6-1 not going to 3-3-1?If we have 6-1 pennies we can remove 3 pennies from the 6 stack and we have 3-3-1 pennies.So why isn\'t 3-3-1 not a child of 6-1?</p>\n', 'ViewCount': '1689', 'Title': 'Nim game tree + minimax', 'LastActivityDate': '2012-10-28T23:34:33.923', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '6364', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3004', 'Tags': '<artificial-intelligence><search-trees><game-theory>', 'CreationDate': '2012-10-28T23:20:35.870', 'FavoriteCount': '1', 'Id': '6363'}{'Body': '<p>Let $n$ be the number of strings which are sorted in lexicographical order and stored in a balanced binary search tree. You are provided with a prefix $x$ of which $M$ strings have the prefix $x$. I have devised the following algorithm, where I search until I find the first occurence of the prefix $x$ in one of the nodes. After that I run an inorder traversal on it, such that I print only the ones, that have prefix $x$ and are in order. </p>\n\n<p>For example of sorted strings: $[ACT,BAT,CAT,CAB]$ and the prefix $x = CA$, I would print $CAT$ and $CAB$. </p>\n', 'ViewCount': '170', 'Title': 'Can you have a binary search tree with O(logn + M) property for the following case', 'LastEditorUserId': '31', 'LastActivityDate': '2012-10-30T07:32:51.260', 'LastEditDate': '2012-10-29T08:36:24.140', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '6381', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<binary-trees><search-trees>', 'CreationDate': '2012-10-29T05:32:13.887', 'Id': '6368'}{'ViewCount': '748', 'Title': 'What is the time complexity of calling successor $n$ times during tree traversal?', 'LastEditDate': '2012-10-30T10:28:52.880', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '2', 'Body': '<p>According to some <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/binarySearchTree.htm" rel="nofollow">sources</a>, the time complexity of finding the successor of a node in a tree is $O(h)$. So, if the tree is well balanced, the height $h=\\log n$, and the successor function takes time $O(\\log n)$. \nYet, according to this <a href="http://stackoverflow.com/questions/12447499/time-complexity-of-bst-inorder-traversal-if-implemented-this-way">stackoverflow post on the time complexity of an inorder traversal of a binary search tree</a>, if you call the successor function $n$ times, the time complexity is $O(n)$.</p>\n\n<p>What resolves the apparent contradiction between:</p>\n\n<blockquote>\n  <p>If I call the sucessor function once, the time complexity is $O(h)$, which could be $O(n)$ or $O(\\log n)$, depending on the kind of tree.</p>\n</blockquote>\n\n<p>AND</p>\n\n<blockquote>\n  <p>If I call the successor $n$ times, the time complexity is $O(n)$ in a balanced tree.</p>\n</blockquote>\n\n<p>Shouldn\'t tree traversal take $O(n^2)$ or $O(n\\log n)$ time?</p>\n', 'Tags': '<binary-trees><search-trees>', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-10-30T15:34:30.833', 'CommentCount': '3', 'AcceptedAnswerId': '6383', 'CreationDate': '2012-10-30T03:10:00.910', 'Id': '6378'}{'Body': "<p>How is $\\frac{n}{2^{h+1}}$ the maximum possible number of nodes at height $h$ for a binary search tree or heap tree? I saw this as proof to asymptotically bound the <code>build_heap</code> function in the book, but I don't get it.</p>\n", 'ViewCount': '1750', 'Title': 'Maximum number of nodes with height h', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T08:17:25.400', 'LastEditDate': '2012-10-31T23:12:27.867', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '6412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-10-31T21:24:01.887', 'Id': '6405'}{'Body': '<p>How many different max-heaps can I form using a list of $n$ integers. </p>\n\n<p>Example: \nlist [1,2,3,4]</p>\n\n<p>and max-heap is <code>4 3 2 1</code>  or </p>\n\n<pre><code>    4\n   / \\\n  3   2\n /\n1\n</code></pre>\n\n<p>other possible max-heap is <code>4 2 3 1</code></p>\n\n<pre><code>    4 \n   / \\\n  2   3 \n /\n1\n</code></pre>\n', 'ViewCount': '569', 'Title': 'How many max heaps are there?', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-01-27T20:52:32.243', 'LastEditDate': '2012-11-20T08:21:15.937', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6458', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '244', 'Tags': '<graph-theory><data-structures><combinatorics><binary-trees><heaps>', 'CreationDate': '2012-11-02T18:19:35.187', 'Id': '6456'}{'Body': "<p>I'd like to know if there is a function $f$ from n-bit numbers to n-bit numbers that has the following characteristics:</p>\n\n<ul>\n<li>$f$ should be bijective</li>\n<li>Both $f$ and $f^{-1}$ should be calculable pretty fast</li>\n<li>$f$ should return a number that has no significant correlation to its input.</li>\n</ul>\n\n<p>The rationale is this:</p>\n\n<p>I want to write a  program that operates on data. Some information of the data is stored in a binary search tree where the search key is a symbol of an alphabet. With time, I add further symbols to the alphabet. New symbols simply get the next free number available. Hence, the tree will always have a small bias to smaller keys which causes more rebalancing than I think should be needed.</p>\n\n<p>My idea is to mangle the symbol numbers with $f$ such that they are widely spread over the whole range of $[0,2^{64}-1]$. Since the symbol numbers only matter during input and output which happens only once, applying such a function should not be too expensive.</p>\n\n<p>I thought about one iteration of the Xorshift random number generator, but I don't really know a way to undo it, although it should theoretically be possible.</p>\n\n<p>Does anybody know such a function?<br>\nIs this a good idea?</p>\n", 'ViewCount': '151', 'Title': 'Function that spreads input', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-07T02:34:50.327', 'LastEditDate': '2013-01-31T06:57:46.533', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<binary-trees><hash><binary-arithmetic>', 'CreationDate': '2012-11-14T20:53:55.090', 'FavoriteCount': '2', 'Id': '6668'}{'Body': "<p>A depth first search produces a spanning tree. If you perform DFS using all possible orderings of the adjacency list, wouldn't you find the minimum spanning tree? In other words, there is no example of a graph where a DFS won't find the minimum spanning tree regardless of how the adjacency list is ordered. Is this correct or not? I can't come up with a counter example and intuitively it seems correct...</p>\n", 'ViewCount': '703', 'Title': 'Depth First Search to find Minimum spanning tree', 'LastActivityDate': '2012-11-19T09:40:43.430', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4645', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2012-11-19T00:37:02.580', 'FavoriteCount': '1', 'Id': '6749'}{'Body': '<p>Given a <a href="http://en.wikipedia.org/wiki/Binary_expression_tree" rel="nofollow">binary expresion tree</a>, with addition and multiplication operations, how can we optimize it\'s evaluation?</p>\n\n<p>Can we learn from <a href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication" rel="nofollow">matrix chain multiplication</a>? A <a href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication#Generalizations" rel="nofollow">generalization</a> of matrix chain multiplication is defined as:</p>\n\n<blockquote>\n  <p>Given a linear sequence of objects, an associative binary operation on those objects, and a way to compute the cost of performing that operation on any two given objects (as well as all partial results), compute the minimum cost way to group the objects to apply the operation over the sequence.</p>\n</blockquote>\n\n<p>What happens if we put <em>two</em> binary operators? <strong>Can the algorithm for <em>Matrix chain multiplication</em> be further generalized (or how can we otherwise solve this problem) to <em>two</em> binary operators in a <em>binary expresion tree</em>, given the cost functions of these operations?</strong> In particular, <strong>multiplication and addition, which complicates things further by allowing distribution</strong>. Also, does it matter that mind that some of the numbers can be negative, allowing reduction in size of intermediate results (see <a href="http://cs.stackexchange.com/q/1424/2755">Overflow safe summation</a>)?</p>\n\n<p><strong>Also, how does this relate to  <a href="http://en.wikipedia.org/wiki/Graph_reduction" rel="nofollow">Graph Reduction</a>?</strong></p>\n\n<p>I also remember learning about database <a href="http://en.wikipedia.org/wiki/Query_optimization" rel="nofollow">query optimization</a> which seemed to do something similar to determine how early to execute particular joins to keep the intermediate values smaller.</p>\n', 'ViewCount': '422', 'Title': 'Chained operations on sequences with two operators', 'LastEditorUserId': '2755', 'LastActivityDate': '2012-11-28T22:31:40.290', 'LastEditDate': '2012-11-28T22:31:40.290', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<optimization><binary-trees><dynamic-programming><efficiency><arithmetic>', 'CreationDate': '2012-11-20T18:58:03.297', 'FavoriteCount': '1', 'Id': '6790'}{'Body': '<p>I know the term <strong>order</strong> of a B-tree. Recently I heard a new term  <strong>B tree with minimum degree of 2.</strong><br>\nWe know the degree is related with a node but what is degree of a tree.<br>\nIs degree imposes any kind of a restriction on height of a B-tree?  </p>\n', 'ViewCount': '1586', 'Title': 'B-Tree Is degree and order both are the same thing related to a B-Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T10:30:15.287', 'LastEditDate': '2014-02-21T10:30:15.287', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3075', 'Tags': '<terminology><data-structures><search-trees><dictionaries>', 'CreationDate': '2012-11-21T05:17:52.773', 'FavoriteCount': '1', 'Id': '6799'}{'Body': "<p>Aren't there $n^2$ unique substrings of a string (irrespective of the alphabet size)? Perhaps the number of unique <em>suffix substrings</em> is less than the number of unique <em>substrings</em> of a string.</p>\n", 'ViewCount': '272', 'Title': 'Why does a suffix tree have a linear number of nodes (relative to input string size)?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-29T10:50:42.293', 'LastEditDate': '2012-11-27T07:47:22.710', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '6945', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<data-structures><strings><trees>', 'CreationDate': '2012-11-27T05:43:15.827', 'Id': '6943'}{'Body': '<blockquote>\n  <p><strong>Problem:</strong> Suppose $V$ is an <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL tree</a> (a self-balancing binary search tree) of $n$\n  elements. After the insertion of $n^2$ elements, what would be its\n  height?</p>\n</blockquote>\n\n<p><strong>My idea:</strong> the height of an AVL tree is originally $O(\\log(n))$ where $n$ is the number of elements. After insertion of $n^2$ elements, its height will be:$$O(\\log(n+n^2))=O(\\log(n^2))=O(2\\log(n))=O(\\log(n))$$</p>\n\n<p>My answer would be $O(\\log(n))$ but I\'m having doubts.</p>\n\n<p>Why is the asymptotic complexity of the result the same despite the fact that there are more elements?</p>\n', 'ViewCount': '82', 'Title': 'Height of AVL after entries', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-29T07:36:40.940', 'LastEditDate': '2012-11-29T06:08:02.270', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7007', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<algorithms><asymptotics><binary-trees><search-trees>', 'CreationDate': '2012-11-28T15:22:50.797', 'Id': '6995'}{'Body': "<p>This is a homework question. I do not want the solution - I'm offering the solution I've been thinking of and wish to know whether is it good or why is it flawed.</p>\n\n<p>My motivation is to find what edges of an weighted, undirected graph are not a part of any MST. This problem only makes sense when several edges have the same weight, otherwise the MST is unique.</p>\n\n<p>My idea comes from Prim's Algorithm with a slight change - instead of adding the minimum edge from S to T on every step (where S and T being the two sets of vertex) - instead look for the minimum edge and more edges of the same value going from S to the vertex the minimum edge goes to. By doing that, (so I suppose) we will receive a graph containing all the edges which appear in any MST. If this is right, I can simply XOR the edges list with the original graph edges list to find what edges are not in any MST.</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '130', 'Title': 'What edges are not in any MST', 'LastEditorUserId': '5026', 'LastActivityDate': '2012-12-11T05:49:35.473', 'LastEditDate': '2012-12-11T05:49:35.473', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5026', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-10T22:51:01.253', 'Id': '7318'}{'Body': "<p>I came across a couple of solutions to one of the problems that is in the CLRS textbook (pg. 637 23.2-5 edition 3).  I am wondering if anyone can make a clarification as to the stated running time of the solution.</p>\n\n<p>Q:  Given that we know the edge weights on a graph are between $1$ and some constant $W$, how fast can we make Prim's algorithm run?</p>\n\n<p>Solution:</p>\n\n<ul>\n<li>Uses an array of linked lists where each index corresponds to a given weight [$1\\dots W + 1$]</li>\n<li>Each link linked lists contains a series of vertices with the weight of the index as their key</li>\n</ul>\n\n<p>The run time given is $O(E)$</p>\n\n<p>They break it down as follows:</p>\n\n<p>$O(1)$ to find the vertex with smallest weight\n       - I understand this part since we scan at most $W$ array slots to find a non-empty list and $W$ is constant.</p>\n\n<p>$O(1)$ for decrease key\n     - This makes sense as far as the actual removing of a link from one list and inserting it into another</p>\n\n<p>My question is about the decrease key step.  Say for example we pull the node $A$ from the 3rd slot, that is the next node to be processed.  We look at $A$'s adjacency matrix and see that it has edges to $B, C, F$.  Since we are using linked lists we have no choice other than to look at all array slots from $4$ to $W$ and see if we can find the vertices listed in the linked list for that particular index. Then delete the vertex from its current list and add it to the correct list if we find it. Possible search time = $O(V)$ [since we store vertices in the linked lists and could search all before finding our desired vertex] not $O(1)$.</p>\n\n<p>Since each decrease key takes $O(V)$ and we process all vertices running time = $O(V^2)$.  </p>\n\n<p>If anyone could let me know where I am going astray in my analysis I would greatly appreciate it.</p>\n", 'ViewCount': '489', 'Title': 'Question about Prims algorithm where weights are between 1 and some constant W', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-14T22:17:34.860', 'LastEditDate': '2013-01-14T22:17:34.860', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'cpowel2', 'PostTypeId': '1', 'OwnerUserId': '5050', 'Tags': '<algorithms><graph-theory><runtime-analysis><spanning-trees>', 'CreationDate': '2012-12-11T18:43:12.797', 'Id': '7345'}{'Body': '<p>Given a path down a <em>full</em> binary tree to a node (for example, a sequence of $1$s and $0$s, $0$ representing "go left" and $1$ representing "go right"), how would one find the position of the node in the preorder traversal. In other words the $i$th node in the preorder traversal will end up with at this node.</p>\n\n<p>Obviously something better than brute force would be nice.</p>\n', 'ViewCount': '311', 'Title': 'Calculating traversal position of a node in a full binary tree, given its path', 'LastActivityDate': '2013-02-10T05:11:58.387', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7348', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<binary-trees><trees><graph-traversal>', 'CreationDate': '2012-12-12T00:34:37.243', 'Id': '7346'}{'Body': '<p>Given an undirected weighted graph $G$ with two edges of minimum weight and all other edges are distinct. Does G have a unique minimum spanning tree?</p>\n\n<p>I know the proof for if all edge weights are distinct (it does give a unique MST) and I am thinking that if two edges of minimum weight are in $G$ then I should be able to show a counter example. But so far I have not been able to produce one.</p>\n\n<p>So my question is does it give a unique MST if the graph $G$ contains two minimum weight edges?</p>\n', 'ViewCount': '1396', 'Title': 'Minimum spanning tree with two minimum edge weights', 'LastActivityDate': '2013-04-17T10:28:33.490', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-15T18:14:13.453', 'FavoriteCount': '1', 'Id': '7414'}{'Body': "<p>A BTree has a $k$ value that determines that every node has $k$ to $2k$ children. When a node has $2k$ keys it needs to be split into two nodes.</p>\n\n<p>Let's say I want to create a $k/(2k-x)$ tree. (like a 2-3 tree that follows the BTree rules, but isnt $k/2k$)</p>\n\n<p>What is the possible range of $x$? The tree must follow the behavior of a BTree, meaning it needs to hold keys and split accordingly.</p>\n", 'ViewCount': '188', 'Title': 'B-tree branching factor boundaries', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-16T21:30:40.277', 'LastEditDate': '2012-12-16T21:30:40.277', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5078', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2012-12-16T03:55:01.130', 'Id': '7428'}{'Body': '<p>I have a data structure described as following:</p>\n\n<pre><code>- It\'s a collection of trees.\n- Each tree has the same structure.\n- Each tree has information of diferent nature.\n</code></pre>\n\n<p>A example of this data structure:</p>\n\n<pre><code>    4 - - - - - - - \'a\' - - - - - - - 3.5 \n   / \\              / \\               / \\\n  3   1           \'f\' \'y\'           1.0 3.1\n     / \\              / \\               / \\\n    4   7           \'e\' \'f\'           2.3 7.7\n</code></pre>\n\n<p>If you see, ignoring the contents of each tree, each of them is just the same tree (the same hierarchy, the same structure). The first contains natural numbers, the second one, characters, and the third one, floating numbers.</p>\n\n<p>The idea of this data structure is that diferent classes (in a C++ program for example) explore diferent "layers" of this tree, in order to each class uses only the information this class needs, ignoring the remaining information. In other words, each class sees only one tree.</p>\n\n<p>Does this data structure match with a <a href="http://en.wikipedia.org/wiki/Hypertree" rel="nofollow">hypertree</a> or can it be reformulated/adapted to a hypertree? Or just they are isomorphic trees put together is a same data structure?</p>\n', 'ViewCount': '58', 'Title': 'Is this data structure a hypertree or only isomorphic trees?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-19T01:15:36.680', 'LastEditDate': '2012-12-18T23:48:05.767', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Peregring-lk', 'PostTypeId': '1', 'OwnerUserId': '4675', 'Tags': '<data-structures><trees>', 'CreationDate': '2012-12-11T12:48:05.580', 'Id': '7448'}{'Body': '<p>I\'m currently working on a paper describing a new algorithm in computational science. If all goes well, this algorithm will be around for a while (within the specific community). As such, I want to set notation conventions that will <em>not</em> drive other people insane. The primary difference is that this algorithm makes use (logically) of tree data structures while the traditional algorithms in the field have used linear arrays.</p>\n\n<p>The old algorithms therefore could denote specific data as $data_i$ (that is, using LaTex subscripts. Similarly, one could refer to $data_{i-1}$, and it would be clear that that is the "parent" data to $data_i$. Unfortunately, trees do not support this sort of indexing.</p>\n\n<p>Are there any notation conventions for trees that allow clear, concise descriptions of that sort? I want to be able to give talk about an arbitrary bit of data (i.e. $data_i$) and readily discuss parent and child data. The community is mathematician heavy and as such mathematical notation of the sub/superscript y operator sort is favored over the class.property CS style. Note also that these are arbitrary trees; they need not be binary or any other such structure.</p>\n\n<p>Does anyone know of a notation convention that would fit the bill? Alternatively, is there a better place to ask this? Thanks for the help.</p>\n', 'ViewCount': '193', 'Title': 'Notation Conventions for Tree Data Structures', 'LastEditorUserId': '5280', 'LastActivityDate': '2013-01-03T00:16:07.643', 'LastEditDate': '2013-01-02T22:22:01.857', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'Ethan', 'PostTypeId': '1', 'OwnerUserId': '5280', 'Tags': '<algorithms><trees>', 'CreationDate': '2013-01-02T19:14:32.530', 'Id': '7705'}{'Body': "<p>I have a set of strings.  My goal is to find a minimal set of longest prefixes which will match most of that set.</p>\n\n<p>For instance, if my set is:</p>\n\n<pre><code>abracadabra\nabracado\nabramu\nbanana\nbananasplit\nbananaicecream\nxylophone\nzebra\nzeitgeist\nzello\n</code></pre>\n\n<p>I would want the output to be:</p>\n\n<pre><code>banana (len 6, matches 3)\nabra (len 4, matches 3)\nxylophone (len 9, matches 1)\nze (len 2, matches 3)\n</code></pre>\n\n<p>Now, this question isn't yet properly specified.  That's because I'm ranking my results on two dimensions: maximum matches, and maximum length.  My goal is to find prefixes that cover as much as of the set as possible, which are as long as possible and thus less likely to occur in strings that <em>aren't</em> in the set (all other things being equal, of course).</p>\n\n<p>Ideally, I'd like to find a set of very long strings, ranked by how much of the set they cover.</p>\n\n<p>That's my goal.  Now I'll present my work, and where I need help.</p>\n\n<p><strong>FIRST</strong> Let's specify the problem better.  We want a set of prefixes.  For each prefix, we compute its length, and the number of matches it has in the set, and order the prefixes by their product.  I'm then free to pick the top X prefixes.</p>\n\n<p>I think that's a good specification.</p>\n\n<p><strong>NOW</strong> Comes an efficient implementation.  Brute force is to check every possible prefix against every string, which is complexity n * n * m (n being number of strings, m being average length of strings).</p>\n\n<p>An efficient algorithm?<br>\nSomething like this:   </p>\n\n<ol>\n<li>Build a prefix tree of the set</li>\n<li>Each leaf has value 1</li>\n<li>Work up the tree, with each parent equal to sum of its children , plus 1 if it has an entry</li>\n<li>Now we know each prefix and how many matches it has - I believe complexity is n log n</li>\n<li>Walk through the tree, counting length of each string (complexity n * m)</li>\n<li>And collect all the entries, sort them by length * value (complexity n log n)</li>\n</ol>\n\n<p>That algorithm is roughly n log n, which is efficient enough.  Will it work? How should it be improved? What's a simple way to implement it? </p>\n\n<p>Finally: Since all the data is in a Postgres relational database, I believe it would be simplest to do the algorithm using relational algebra with aggregate functions. Comments on this?</p>\n", 'ViewCount': '216', 'Title': 'Algorithm for determining minimal set of covering prefixes', 'LastEditorUserId': '1623', 'LastActivityDate': '2013-01-11T14:38:16.920', 'LastEditDate': '2013-01-10T16:50:17.210', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5368', 'Tags': '<algorithms><trees><data-compression><sets><coding-theory>', 'CreationDate': '2013-01-10T13:34:14.843', 'Id': '7868'}{'Body': '<p>Suppose that we take an initial search problem and we add $c &gt; 0$ to the costs on all edges. Will <a href="http://en.wikipedia.org/wiki/Uniform-cost_search" rel="nofollow">uniform-cost search</a> return the same answer as in the initial search problem?</p>\n\n<p>Definitions: Uniform-cost search is also known as lowest cost first. Initial search problem can be any graph with a start and a goal state. You just apply the uniform cost search algorithm on the graph. </p>\n', 'ViewCount': '426', 'Title': 'Uniform-cost Search Problem', 'LastEditorUserId': '867', 'LastActivityDate': '2013-11-19T07:11:47.707', 'LastEditDate': '2013-01-29T03:40:50.913', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6601', 'Tags': '<graphs><search-algorithms><search-trees><search-problem>', 'CreationDate': '2013-01-29T02:33:45.660', 'Id': '9265'}{'Body': '<p>On Facebook HackerCup 2013, they asked the following question:</p>\n\n<blockquote>\n  <p>Your friend John uses a lot of emoticons when you talk to him on\n  Messenger. In addition to being a person who likes to express himself\n  through emoticons, he hates unbalanced parenthesis so much that it\n  makes him go :(</p>\n  \n  <p>Sometimes he puts emoticons within parentheses, and you find it hard\n  to tell if a parenthesis really is a parenthesis or part of an\n  emoticon.</p>\n  \n  <p>A message has balanced parentheses if it consists of one of the\n  following:</p>\n  \n  <ul>\n  <li>An empty string "" </li>\n  <li>One or more of the following characters: \'a\' to\n  \'z\', \' \' (a space) or \':\' (a colon) </li>\n  <li>An open parenthesis \'(\', followed\n  by a message with balanced parentheses, followed by a close\n  parenthesis \')\'. </li>\n  <li>A message with balanced parentheses followed by\n  another message with balanced parentheses. </li>\n  <li>A smiley face ":)" or a\n  frowny face ":(" </li>\n  </ul>\n  \n  <p>Write a program that determines if there is a way to\n  interpret his message while leaving the parentheses balanced.</p>\n</blockquote>\n\n<p><a href="http://stackoverflow.com/questions/6447289/how-to-print-all-possible-balanced-parentheses-for-an-expression">Balancing parentheses</a> is talked about in a lot of places.  E.g. <code>(()) vs ()()</code>.  You can count</p>\n\n<ul>\n<li><code>\'(\' = +1 </code> </li>\n<li><code>\')\' = -1 </code></li>\n</ul>\n\n<p>Then you have to make sure your sum never falls below <strong>0</strong>. </p>\n\n<p>In this question they consider <code>:)</code> and <code>:(</code> as balanced and I wonder how much it changes things. One <a href="https://gist.github.com/4660602" rel="nofollow">solution</a> says that you can replace <code>r\'[^a-z:() ], \'\'</code>, <code>\':)\' -> \'}\'</code> and <code>\':(\' -> \'{\'</code>.  </p>\n\n<p>While I agree with the first sub, why are the last two substitutions valid?</p>\n', 'ViewCount': '177', 'Title': 'Facebook Hackercup 2013: Balanced Smileys', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-30T12:46:36.447', 'LastEditDate': '2013-01-30T12:46:36.447', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><context-free><binary-trees><parsing>', 'CreationDate': '2013-01-29T22:41:19.300', 'Id': '9285'}{'Body': "<p>I'm trying to prove/disprove two statements. I just want to make sure with you I'm on the right line.</p>\n\n<p>These are the following statements:</p>\n\n<p><strong>Preface :</strong> Let A[n] be an array of min-heap (a min-heap represented by an array], whereas all the elements in the heap are different from each other. \nLet i and j be two indexes in the range : $0 \\le i, j \\le n-1$.</p>\n\n<p><em><strong>Prove or disprove :</em></strong> </p>\n\n<ol>\n<li>If $i &lt; j $ then $A[i] &lt; A[j]$</li>\n<li>If $A[i] &lt; A[j] $ then $i &lt; j$</li>\n</ol>\n\n<p>I believe I managed to disprove both of them using the following heap:</p>\n\n<p>$\\qquad [2, 6, 7, 11, 14, 13, 12, 12, 13,15, 16, 71, 72, 13, 81]$</p>\n\n<p>For:</p>\n\n<ol>\n<li><p>Simply plug in the following indexes: $i = 4$ and $j = 13$. </p>\n\n<p>So $i &lt; j$ but $A[i] &gt; A[j]$.</p></li>\n<li><p>Simply plug in the following indexes: $i = 13$ and $j = 4$.</p>\n\n<p>So $A[i] &lt; A[j]$ but $i &gt; j$.</p></li>\n</ol>\n\n<p>Am I missing something here? Or It is really that easy?</p>\n", 'ViewCount': '209', 'Title': 'MinHeap represented by an array - two simple statements', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-03T10:26:59.710', 'LastEditDate': '2013-02-03T10:26:59.710', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9445', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<data-structures><binary-trees><arrays><heaps>', 'CreationDate': '2013-02-03T08:44:32.337', 'Id': '9444'}{'Body': u'<p>I have this confusion. What is the local minimum of a complete binary tree?</p>\n\n<p>Consider an $n$-node complete binary tree $T$, where $n = 2^d \u2212 1$ for some $d$. Each node $v \\in V(T)$ is labeled with a real number $x_v$.  You may assume that the real numbers labeling the nodes are all distinct.  A node $v \\in V(T)$ is a local minimum if the label $x_v$ is less than the label $x_w$ for all nodes $w$ that are joined to $v$ by an edge.</p>\n', 'ViewCount': '377', 'Title': 'What is the local minimum of a complete binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-26T06:13:57.493', 'LastEditDate': '2013-02-25T07:15:14.690', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6999', 'Tags': '<terminology><graphs><binary-trees>', 'CreationDate': '2013-02-24T21:49:00.743', 'Id': '10071'}{'Body': '<p>Given an undirected tree (with no specific root), how to find the longest path, i.e. 2 vertices that are the farthest apart from each other? There are no lengths associated with the edges (each edge has length 1 by default).<br>\nObviously one idea is to check the path lengths between all pairs of vertices (e.g. by doing a DFS from each vertex), but there should be a more efficient solution. Please include a short proof in your answer.</p>\n', 'ViewCount': '683', 'ClosedDate': '2013-03-04T17:16:27.133', 'Title': 'Longest path in undirected tree', 'LastEditorUserId': '7096', 'LastActivityDate': '2013-03-01T22:46:48.810', 'LastEditDate': '2013-03-01T19:35:40.383', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7096', 'Tags': '<algorithms><graph-theory><trees>', 'CreationDate': '2013-03-01T18:10:03.390', 'Id': '10181'}{'ViewCount': '143', 'Title': 'Are probabilistic search data structures useful?', 'LastEditDate': '2013-03-03T16:57:40.847', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7022', 'FavoriteCount': '1', 'Body': '<p>A SkipList provides the same $O(\\log n)$ bounds for search as a balanced tree with the advantage that rebalancing isn\'t necessary. Since the SkipList is constructed using random coin flips, these bounds only hold as long as the structure of the SkipList is sufficiently "balanced". In particular, with probability $1/n^c$ for some constant $c&gt;0$, the balanced structure might be lost after inserting an element.</p>\n\n<p>Let\'s say I want to use a skip list as a storage backend in a web application that potentially runs forever. So after some polynomial number of operations, the balanced structure of the SkipList is very likely to be lost. </p>\n\n<p>Is my reasoning correct? Do such probabilistic search/storage data structures have practical applications and if so, how is the above problem avoided? </p>\n\n<p>Edit: I\'m aware that there are deterministic variants of the SkipList, which, are much more complicated to implement in comparison to the (classic) randomized SkipList.</p>\n', 'Tags': '<data-structures><search-trees><probabilistic-algorithms>', 'LastEditorUserId': '7022', 'LastActivityDate': '2013-03-08T13:10:42.580', 'CommentCount': '1', 'AcceptedAnswerId': '10239', 'CreationDate': '2013-03-03T14:09:52.280', 'Id': '10229'}{'Body': '<blockquote>\n  <p>Given a tree $T = (V , F)$, find an algorithm which finds $u \\in V$, so in the graph $T = (V \\setminus \\{u\\} , F)$ the size of each connected component is $\\lceil |V| / 2 \\rceil$ at most. What is the complexity?</p>\n</blockquote>\n\n<p>Can I please have a hint?</p>\n', 'ViewCount': '211', 'Title': 'Find node that splits tree in half', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-07T02:37:14.300', 'LastEditDate': '2013-03-05T07:06:43.247', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'user2102697', 'PostTypeId': '1', 'Tags': '<algorithms><complexity-theory><graph-theory><trees>', 'CreationDate': '2013-03-01T15:40:43.320', 'Id': '10262'}{'Body': '<p>A full binary tree seems to be a binary tree in which every node is either a leaf or has 2 children.\nI have been trying to prove that its height is O(logn) unsuccessfully.\nHere is my work so far:</p>\n\n<p>I am considering the worst case of a full binary tree in which each right node has a subtree, and each left node is a leaf.\nIn this case:<br>\n$N = 2x - 1$<br>\n$H = x - 1$<br>\nI am going nowhere trying to prove that $H = O(\\log(N))$</p>\n\n<p>Furthermore, we know that leaves l is bounded by $h+1 &lt;l&lt;2^h$.<br>\nInternal nodes is bounded by $h&lt;i&lt;2^{h-1}$.<br>\nAll this proves is that number of nodes $n=i+e$ is $&lt;= 2^{h+1} - 1$ i.e. $\\log(n) &lt;= h$. But this does not take me anywhere closer to prove that $H = O(\\log(n))$</p>\n', 'ViewCount': '364', 'Title': 'Height of a full binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-13T14:40:59.037', 'LastEditDate': '2013-03-13T14:40:59.037', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10508', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7260', 'Tags': '<graph-theory><combinatorics><binary-trees><trees>', 'CreationDate': '2013-03-13T06:53:28.090', 'Id': '10507'}{'ViewCount': '2573', 'Title': 'BIT: What is the intuition behind a binary indexed tree and how was it thought about?', 'LastEditDate': '2013-03-16T19:33:32.607', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '6823', 'FavoriteCount': '22', 'Body': '<p>A binary indexed tree has very less or relatively no literature as compared to other data structures. The only place where it is taught is <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=binaryIndexedTrees">the topcoder tutorial</a>. Although the tutorial is complete in all the explanations, I cannot understand the intuition behind such a tree? How was it invented? What is the actual proof of its correctness?</p>\n', 'Tags': '<algorithms><binary-trees><trees>', 'LastEditorUserId': '7304', 'LastActivityDate': '2013-12-17T10:36:55.957', 'CommentCount': '2', 'AcceptedAnswerId': '10541', 'CreationDate': '2013-03-15T17:56:58.113', 'Id': '10538'}{'Body': "<p>Just a quick question,</p>\n\n<p>If i were to alter the general DFS algorithm to do this:</p>\n\n<pre><code>minDFS(Vertex v)\n{\n   if (!v.getVisted())\n   {\n       v.setVisited();\n       Vertex temp = findClosestVertex();\n       graph.addEdge(v, temp);\n       minDFS(temp);\n   }\n}\n</code></pre>\n\n<p>Would I eventually (at the end of DFS) get  minimum spanning tree? I know there are other ways of getting the MST (Kruskal's, Prim's etc..),but I was just wondering if this would work.</p>\n", 'ViewCount': '88', 'Title': 'DFS miniumum spanning tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T10:04:43.703', 'LastEditDate': '2013-03-25T10:04:43.703', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10721', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7381', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2013-03-23T19:28:16.987', 'Id': '10717'}{'Body': "<p>Suppose all costs on edges are distinct. How many minimal spanning trees are possible?</p>\n\n<p>I dont know if this question is supposed to be easy or hard, but all I can come up with is one, because Kruskal's, and any other greedy algorithm should choose all the smallest weighted edges first. Then, if all weights on all edges are distinct, then there are no two equivalently weighted minimum spanning trees if a greedy algorithm is used.</p>\n", 'ViewCount': '1057', 'Title': 'How many minimal spanning trees are there when all edge costs are distinct?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-27T16:47:34.527', 'LastEditDate': '2013-03-25T10:19:10.033', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '10731', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2013-03-24T02:05:51.303', 'Id': '10728'}{'Body': "<p>I have a problem where I am supposed to analyze the <code>Steiner tree problem</code> by doing the following 3 steps.</p>\n\n<p>1) Look up what the Steiner tree problem is.</p>\n\n<p>2) Find a polynomial time reduction to it from one of these 8 known NP-complete problems:</p>\n\n<ul>\n<li>3-col </li>\n<li>subset-sum </li>\n<li>clique </li>\n<li>hampath </li>\n<li>Uhampath </li>\n<li>sat </li>\n<li>3-sat </li>\n<li>vertex-cover.</li>\n</ul>\n\n<p>3) Prove that it is NP-complete.</p>\n\n<hr>\n\n<p>My first problem is that I don't understand what the Steiner tree problem is. I can't find the problem anywhere. Wikipedia has  a page on it, but doesn't really describe it in simple terms.</p>\n\n<p>Can anyone help me out on this, and also give me hints for number 1, 2 and 3?</p>\n", 'ViewCount': '202', 'Title': 'How to analyze the Steiner tree problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-26T11:23:15.850', 'LastEditDate': '2013-03-26T11:23:15.850', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions><trees>', 'CreationDate': '2013-03-26T00:09:08.733', 'FavoriteCount': '2', 'Id': '10790'}{'Body': '<p>I have an undirected tree whose vertices I want to label. The leaf nodes should be labeled one. Then, assume the leaves were removed. In the tree that remains, the leaves should be labeled two. This process continues in the obvious way until all vertices have a label. The reason I do this is I want to store the vertices in a queue, and go through them "leaves first". Is there an easy way to do this $O(n+m)$ time?</p>\n\n<p>I can solve the problem by doing a BFS on every step. But in the worst case, on every step I go through every vertex, remove exactly two leaves and enqueue them. I believe this takes quadratic time.</p>\n\n<p>Another idea was to first find all the leaves, and then do a BFS from every leaf. This doesn\'t give me the desired solution. For example, consider a kind of "crown graph" as in the figure below. The desired solution is shown, but launching a BFS from each leaf would result in only two labels used.</p>\n\n<p><img src="http://i.stack.imgur.com/nNtzL.png" alt="enter image description here"></p>\n\n<p>Ideally, the linear time algorithm would also be easy to explain and implement.</p>\n', 'ViewCount': '232', 'Title': 'Linear time labeling algorithm for a tree?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-10T19:00:50.640', 'LastEditDate': '2013-03-27T21:33:17.693', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10821', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7434', 'Tags': '<algorithms><trees>', 'CreationDate': '2013-03-27T02:54:50.987', 'Id': '10819'}{'ViewCount': '1020', 'Title': 'Colour a binary tree to be a red-black tree', 'LastEditDate': '2013-04-03T16:56:13.100', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '2', 'Body': '<p>A common interview question is to give an algorithm to determine if a given binary tree is height balanced (AVL tree definition).</p>\n\n<p>I was wondering if we can do something similar with Red-Black trees.</p>\n\n<blockquote>\n  <p>Given an arbitrary uncoloured binary tree (with NULL nodes), is there a "fast" algorithm which can determine if we can colour (and find a colouring) the\n  nodes Red/Black so that they satisfy all the properties of a Red-Black\n  tree (definition as in this <a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">question</a>)?</p>\n</blockquote>\n\n<p>An initial thought was that we can just remove the NULL nodes and try to recursively verify if the resulting tree can be a red-black tree, but that didn\'t seem to go anywhere.</p>\n\n<p>I did (a brief) web search for papers, but could not seem to find any which seem to deal with this problem.</p>\n\n<p>It is possible that I am missing something simple.</p>\n', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '139', 'LastActivityDate': '2013-04-20T17:57:19.710', 'CommentCount': '1', 'AcceptedAnswerId': '10999', 'CreationDate': '2013-04-03T08:02:32.960', 'Id': '10990'}{'ViewCount': '1416', 'Title': 'Constructing a binary tree with given traversals', 'LastEditDate': '2013-04-04T10:52:27.670', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Body': '<p>I have given a post order &amp; in order traversal a BST &amp; I need to construct it. I want to know how to do this. </p>\n\n<p>for eg.</p>\n\n<p>Post Order : DCBGFEA</p>\n\n<p>In Order : BDCAFGE </p>\n\n<p>This is how I am trying to do : </p>\n\n<ul>\n<li><p>From POST order it is clear that A is root. So in IN order, I consider everything right to A is at it\'s right sub tree &amp; so for left.</p>\n\n<p><img src="http://i.stack.imgur.com/PVFn9.jpg" alt="image1"></p></li>\n<li><p>Now, I consider A\'s left sub tree. It has BDC. Again from POST order, I conclude that B is root. </p>\n\n<p><img src="http://i.stack.imgur.com/EiAQ7.jpg" alt="image2"></p></li>\n<li><p>Now, again consider B\'s sub tree. It has contents DC &amp; POST order, C has to be at root. So now I get C at root. But where to place C, at B\'s left or right ? It\'s where I am getting stuck now. </p></li>\n</ul>\n\n<p>Same happening with A\'s right sub tree also. I place E as root of A\'s right sub tree. Then I conclude element below should be F, but does it come at right or left of E ? </p>\n\n<p>I want to know how to tackle this problem &amp; also is there any better approach for this to do. </p>\n', 'ClosedDate': '2013-04-04T12:05:00.787', 'Tags': '<binary-trees>', 'LastEditorUserId': '6665', 'LastActivityDate': '2013-04-04T11:22:31.740', 'CommentCount': '0', 'AcceptedAnswerId': '11016', 'CreationDate': '2013-04-04T10:47:15.770', 'Id': '11015'}{'ViewCount': '183', 'Title': 'Number of possible search paths when searching in BST', 'LastEditDate': '2013-04-11T23:41:46.050', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'FavoriteCount': '1', 'Body': "<p>I have the following question, but don't have answer for this. I would appreciate if my method is correct :</p>\n\n<p>Q. When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70, 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root node containing the value 60? </p>\n\n<p>(A) 35 (B) 64 (C) 128 (D) 5040 </p>\n\n<p>From the question, I understand that all nodes given have to be included in traversal and ultimately we have to reach the key, 60. For example, one such combination would be : </p>\n\n<p>10, 20, 40, 50, 90, 80, 70, 60. </p>\n\n<p>Since we have to traverse all nodes given above, we have to start either with 10 or 90. If we start with 20, we will not reach 10 (since 60 > 20 and we will traverse right subtree of 20)</p>\n\n<p>Similarly, we cannot start with 80, because we will not be able to reach 90, since 80>60, we will traverse in left sub tree of 80 &amp; thus not reaching 90. </p>\n\n<p>Lets take 10. The remaining nodes are 20, 40, 50, 70, 80, 90. Next node could be either 20 or 90. We cannot take other nodes for same earlier mentioned reason.</p>\n\n<p>If we consider similarly, at each level we are having two choices. Since there are 7 nodes, two choices for first 6 &amp; no choice for last one. So there are totally </p>\n\n<p>$2*2*2*2*2*2*1$ permutations = $2^6$ = $64$</p>\n\n<ol>\n<li><p>Is this a correct answer?</p></li>\n<li><p>If not, whats the better approach?</p></li>\n<li><p>I would like to generalize. If $n$ nodes are given then total possible search paths would be $2^{n-1}$</p></li>\n</ol>\n", 'Tags': '<data-structures><combinatorics><binary-trees><search-trees><graph-traversal>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T23:41:46.050', 'CommentCount': '0', 'AcceptedAnswerId': '11048', 'CreationDate': '2013-04-05T07:42:32.627', 'Id': '11043'}{'ViewCount': '85', 'Title': 'Prize collecting steiner tree', 'LastEditDate': '2013-04-07T11:49:54.243', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Armin Meisterhirn', 'PostTypeId': '1', 'OwnerUserId': '7866', 'Body': '<p>I\'m reading about the <strong>prize collecting steiner tree</strong> problem and an approximation algorithm that uses randomization to set a lower bound on the optimal solution (see Chapter 5.7 in <a href="http://www.designofapproxalgs.com/book.pdf" rel="nofollow"> The Design of Approximation Algorithms </a> by Williamson and Shmoys). I don\'t understand the second line in the proof for Lemma 5.16: <img src="http://i.stack.imgur.com/9uldl.png" alt="Lemma 5.16">.</p>\n\n<p>It seems to me that $V-V(T)$ is a much larger set than $U$. So, how can the total penalty for this set be upper bounded by the total penalty of a set that is much smaller?</p>\n', 'Tags': '<algorithm-analysis><optimization><approximation><trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T11:49:54.243', 'CommentCount': '0', 'AcceptedAnswerId': '11070', 'CreationDate': '2013-04-04T00:13:44.200', 'Id': '11069'}{'Body': '<p>I have been reading about AVL trees, at the moment I\'m trying to figure out how to determine the height of a tree and how to draw an AVL tree of some height with minimum number of elements.  </p>\n\n<p>In a tutorial I found that this: would be a AVL tree of height 7<br>\n<img src="http://i.stack.imgur.com/xc90l.jpg" alt="enter image description here"></p>\n\n<p>And this AVL tree with the height 4<br>\n<img src="http://i.stack.imgur.com/ZseOY.jpg" alt="enter image description here"></p>\n\n<p>This is really confusing by the look I would guess that both of them are of height 4. I\'m fairly new to data structures, I could not find a simple documentation/tutorial regarding this most of what i found was about Insertion/Deletion with AVL trees.  </p>\n\n<p>So is the top tree of height 7 if not how would I draw it with the minimal number of elements. I understand the each sub tree would have to be balanced.</p>\n', 'ViewCount': '362', 'Title': 'AVL tree with fixed height and as few elements as possible', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:57:27.700', 'LastEditDate': '2013-04-07T12:57:27.700', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7619', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-04-07T01:48:44.733', 'Id': '11086'}{'Body': "<p>Let's say I have two equations for a geometric object (a rectangle):</p>\n\n<p>$\\left\\{\n    \\begin{array}{l}\n      x \\ge 0 \\\\\n      y \\ge 0 \\\\\n      A \\ge 0 \\\\\n      P \\ge 0 \\\\\n      A = x*y \\\\ \n P = 2*x + 2*y\n    \\end{array}\n\\right.$</p>\n\n<p>Now I would like to set the values of some variables, and compute the values of the other ones.</p>\n\n<p>At first, I thought it could be done with simple tree transformations on the AST, but I realized that I was more or less building a full solver.</p>\n\n<p>The easy case is when one side of the equality consists only of constant terms, as it consists of a simple recursive tree evaluation. But the interesting case is when there are several variable bound together in a subtree. For example, for $ (A,P)=(30,11)$ the solution is $(x,y)=(5,6)$ or $(6,5)$</p>\n\n<p>Can arbitrary complex instances of this problem solved just with tree transformations ? Or do I need something more elaborate ?</p>\n", 'ViewCount': '129', 'Title': 'Which data structure to use to solve equations?', 'LastActivityDate': '2014-03-20T00:01:45.690', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2151', 'Tags': '<data-structures><trees>', 'CreationDate': '2013-04-07T19:24:47.227', 'FavoriteCount': '0', 'Id': '11112'}{'Body': '<p>If I am given a graph which forms a tree, I am interested in finding a vertex which maximizes the minimum distance to any leaf.</p>\n\n<p>I am sure this problem has been studied before.\nDoes anybody know the name of this problem or an algorithm for solving it?</p>\n', 'ViewCount': '250', 'Title': 'Given a tree, find a vertex which maximizes the minimum distance to any leaf', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T22:49:24.883', 'LastEditDate': '2013-04-10T21:35:43.710', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11212', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7675', 'Tags': '<algorithms><graph-theory><reference-request><trees>', 'CreationDate': '2013-04-10T21:05:36.970', 'Id': '11208'}{'Body': '<p>A program takes as input a balanced binary search tree with $n$ leaf nodes and computes the value of a function $g(x)$ for each node $x$. If the cost of computing $g(x)$ is </p>\n\n<p>$\\qquad \\min(\\#\\text{leaves in } L(x), \\#\\text{leaves in } R(x))$</p>\n\n<p>for $L(x), R(x)$ the left resp. right subtree of $x$, then the worst-case time complexity of the program is</p>\n\n<ol>\n<li>$\\Theta(n)$</li>\n<li>$\\Theta(n \\log n)$</li>\n<li>$\\Theta(n^2)$ </li>\n<li>$\\Theta(n^2 \\log n)$</li>\n</ol>\n\n<p>I am actually looking for a subtle hint. </p>\n', 'ViewCount': '492', 'Title': 'Finding no. of leaf nodes for each node in a BST', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-22T14:55:46.203', 'LastEditDate': '2013-04-12T10:03:59.117', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11254', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><binary-trees><search-trees>', 'CreationDate': '2013-04-12T08:03:52.183', 'Id': '11252'}{'ViewCount': '2886', 'Title': 'Longest path in an undirected tree with only one traversal', 'LastEditDate': '2013-04-12T14:33:50.713', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '4980', 'FavoriteCount': '4', 'Body': "<p>There is this standard algorithm for finding longest path in undirected trees using two depth-first searches:</p>\n\n<ul>\n<li>Start DFS from a random vertex $v$ and find the farthest vertex from it; say it is $v'$. </li>\n<li>Now start a DFS from $v'$ to find the vertex farthest from it. This path is the longest path in the graph.</li>\n</ul>\n\n<p>The question is, can this be done more efficiently? Can we do it with a single DFS or BFS?</p>\n", 'Tags': '<algorithms><trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T17:42:01.533', 'CommentCount': '4', 'AcceptedAnswerId': '11264', 'CreationDate': '2013-04-12T14:00:52.687', 'Id': '11263'}{'Body': '<p><img src="http://i.stack.imgur.com/reeMb.jpg" alt="Pruning"></p>\n\n<p>I am studying some old past test questions.  Is this search tree correctly pruned?</p>\n', 'ViewCount': '140', 'Title': 'Did I correctly prune this min-max search tree using alpha-beta pruning?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T21:55:57.437', 'LastEditDate': '2013-04-14T11:51:58.280', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11312', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7721', 'Tags': '<search-trees><check-my-answer>', 'CreationDate': '2013-04-14T09:36:32.457', 'Id': '11308'}{'ViewCount': '216', 'Title': 'Is there a binary search tree datastructure which can avoid becoming badly weight-balanced?', 'LastEditDate': '2013-05-04T09:38:43.037', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2152', 'FavoriteCount': '1', 'Body': '<p>This is a follow-up question of "<a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">Not all Red-Black trees are balanced?</a>" and "<a href="http://cs.stackexchange.com/questions/421/avl-trees-are-not-weight-balanced">AVL trees are not weight-balanced?</a>".$\\def\\le{\\leqslant}\\def\\ge{\\geqslant}$</p>\n\n<blockquote>\n  <p><strong>Definition:</strong> For a rooted tree $T$ and a vertex $v \\in V(T)$, let $L_T(v)$ be the number of nodes in the left-subtree from $v$, and $N_T(v)$ be the number of nodes in the subtree rooted at $v$. We say that $T$ is <em>$\\mu$-balanced</em>, with $0 \\le \\mu \\le \\frac{1}{2}$, if for every node $v \\in V(T)$ the inequality\n  $$ \\mu \\le \\frac{L_T(v) + 1}{N_T(v) + 1} \\le 1 - \\mu$$\n  holds, and if $\\mu$ is minimal subject to this inequality holding.</p>\n</blockquote>\n\n<p>(These are apparently also known as  <em>weight-balanced</em> trees in some of the literature.) A tree which is $\\mu\'$-balanced for some $\\mu\' &lt; \\mu$, we will say is <strong>&mu;-imbalanced</strong>.</p>\n\n<p>The above-linked posts essentially show that neither <a href="http://en.wikipedia.org/wiki/AVL_tree">AVL trees</a>, nor <a href="http://en.wikipedia.org/wiki/Red%E2%80%93black_tree">Red-Black trees</a>, can be guaranteed to be $\\mu$-balanced for any $\\mu &gt; 0$: that is, for any such $\\mu$, one can provide a sequence of inputs to be inserted so that the resulting tree is $\\mu$-imbalanced.</p>\n\n<p><strong>Question.</strong> Is there any binary search tree structure, with the usual characteristics of $O(\\log n)$ insertion and search time, and some $m &gt; 0$, such that the tree will always be $\\mu$-balanced for some $\\mu &gt; m$?</p>\n', 'Tags': '<data-structures><search-trees>', 'LastEditorUserId': '2448', 'LastActivityDate': '2013-05-04T09:38:43.037', 'CommentCount': '2', 'AcceptedAnswerId': '11758', 'CreationDate': '2013-05-03T13:19:28.613', 'Id': '11756'}{'Body': '<p>The idea of <a href="http://en.wikipedia.org/wiki/Splay_tree">splay trees</a> is very nice as they move frequently accessed elements to the top, which can gain a considerable speed up in many applications. The drawback is that in the worst case an operation can have $O(n)$ complexity. \n(Although amortized bounds are $O(n\\log n)$ <a href="http://en.wikipedia.org/wiki/Splay_tree#Performance_theorems">if we perform at least $n$ operations</a>.)</p>\n\n<p>Is there a self-adjusting search tree structure that has both? Favoring recently accessed elements and with worst $O(\\log n)$ complexity for a single operation?</p>\n', 'ViewCount': '286', 'Title': 'Is there a binary tree structure with fast access to recently accessed elements and worst $O \\left( \\log n \\right )$ complexity?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-09-24T06:09:43.897', 'LastEditDate': '2013-05-07T07:14:06.917', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2448', 'Tags': '<data-structures><binary-trees><search-trees><splay-trees>', 'CreationDate': '2013-05-04T09:54:49.780', 'FavoriteCount': '2', 'Id': '11772'}{'Body': "<p>We're asked to prove the above mentioned lemma but I having a hard time proving this rigorously.</p>\n\n<p>We did prove that given $n$ values AVL's height is $\\Theta\\left (\\log \\left ( n \\right ) \\right )$ So I thought that after inserting a $\\frac{n}{2}$ values the height of the tree will be at least $\\Theta\\left (\\log \\left ( \\frac{n}{2} \\right ) \\right )$ which and because each isertion we make is now on a tree with at least $\\frac{n}{2}$ and insertion is $\\log \\left (h \\right ) $ where $h$ is the height of the tree.</p>\n\n<p>So for a function $F$ using the previous logic:</p>\n\n<p>$\\begin{align}  F &amp;= \\frac{n}{2} \\times \\log \\left (h \\right ) \n\\\\&amp; \\geq \\frac{n}{2} \\times \\log \\left (\\frac{n}{2} \\right ) \n\\\\&amp;=\\Omega\\left( n\\log \\left (n \\right )  \\right)\n\\end{align}$</p>\n\n<p>But I have a few issues with this </p>\n\n<ul>\n<li>This does feel fishy to me don't know why but it doesn't feel like a good well defined calculus proof :)</li>\n<li>I'm not sure which way to take it in order to prove the upper boud i.e $\\mathcal{O}$</li>\n</ul>\n\n<p>If I haven't given all the required information I'd be glad to.</p>\n", 'ViewCount': '78', 'Title': 'Prove that inserting $n$ sorted values in to an AVL using AVL insertion is $\\Theta\\left (n \\log \\left ( n \\right ) \\right )$', 'LastEditorUserId': '31', 'LastActivityDate': '2013-05-05T16:35:06.797', 'LastEditDate': '2013-05-05T16:35:06.797', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11808', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8004', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'CreationDate': '2013-05-05T15:30:17.330', 'Id': '11807'}{'Body': "<p>Given we change the rule to: </p>\n\n<blockquote>\n  <p>$-s \\ \\ \\leq$ height(left-subtree) - height(right-subtree) $\\leq \\ \\ s$</p>\n</blockquote>\n\n<p>I was wandering whether it's possible and how would it affect the trees' height, would it still be logarithmic? </p>\n\n<p>Would the exact same balancing techniques work? (if we took those methods from a normal AVL and try to convert our modified AVL to a normal AVL running from down to top or to down).</p>\n\n<p>I've tired drawing some schematics in order to find out what would be the minimal number of nodes $m$ for some tree $T$ with height $h$ like we did with a regular AVL but I had a real hard time formalizing it.</p>\n", 'ViewCount': '54', 'Title': "Changing AVL's balance factor to some other $s>2 \\in \\mathbb{N}$", 'LastEditorUserId': '8004', 'LastActivityDate': '2013-05-06T17:15:16.980', 'LastEditDate': '2013-05-06T17:15:16.980', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11834', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8004', 'Tags': '<algorithms><data-structures><binary-trees><trees>', 'CreationDate': '2013-05-06T14:22:34.710', 'Id': '11832'}{'Body': '<p>Could someone please provide a reference giving an algorithm to generate uniformly random binary trees?</p>\n', 'ViewCount': '378', 'Title': 'How to generate uniformly random binary trees?', 'LastActivityDate': '2013-06-06T22:33:38.807', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6437', 'Tags': '<trees><random>', 'CreationDate': '2013-05-07T19:17:27.750', 'Id': '11862'}{'Body': '<p>Given $n$ points in $\\mathbf{R}^2$, define the optimal Euclidean Steiner tree to be a minimum (Euclidean) length tree containing all $n$ points and any other subset of points from $\\mathbf{R}^2$.\nProve that each of the additional points must have degree 3, with all three angles being $120^\\circ$.</p>\n', 'ViewCount': '113', 'Title': 'Euclidean Steiner Tree Question in Approximation Algorithms', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-05-08T07:18:28.980', 'LastEditDate': '2013-05-08T07:18:28.980', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11881', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7300', 'Tags': '<algorithms><algorithm-analysis><computational-geometry><approximation><trees>', 'CreationDate': '2013-05-08T06:34:08.107', 'Id': '11880'}{'Body': '<p>A lot of articles say that hash tree traversal cost to any <em>randomly</em> chosen leaf is $\\mathcal{O}(\\log_2 N)$ ($N$ is a number of leafs) and that is right. If we have a tree of 8 leafs it will take us at most 3 operations to get to any leaf, if we have a tree of 64 leafs it will take us at most 5 operations etc.</p>\n\n<p>But lets say I need to check <strong><em>every</em></strong> leaf sequentially to check if <strong><em>all blocks</em></strong> of a file are correct, then I would need $\\mathcal{O}(N \\log_2 N)$ operations. Or if I would check every second leaf (just left leaf of every pair) I would need $\\mathcal{O}((\\frac{N\\log_2 N}{2}))$ operations. That is, I will need $\\mathcal{O}(\\log_2 N)$ operations for every leaf? Which leads to exponentially growing evaluations curve and it would be better to use simple hash list or hash chain? Am I right?</p>\n\n<p>Or I just don\'t see/know something?</p>\n\n<p><img src="http://i.stack.imgur.com/Mnvvt.jpg" alt=""></p>\n\n<p>*Note, chart has logarithmic scale</p>\n', 'ViewCount': '102', 'Title': 'Sequential hash tree traversal', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-14T18:11:32.220', 'LastEditDate': '2013-05-14T10:59:03.967', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8111', 'Tags': '<data-structures><search-trees><graph-traversal><hash-tables>', 'CreationDate': '2013-05-10T07:16:57.917', 'Id': '11927'}{'Body': u'<p>You\u2019re doing some stress-testing on various models of glass jars to determine the height from which they can be dropped and still not break. The setup for this experiment, on a particular type of jar, is as follows. You have a ladder with $n$ rungs, and you want to find the highest rung from which you can drop a copy of the jar and not have it break. We call this the highest safe rung.\nIt might be natural to try binary search: drop a jar from the middle rung, see if it breaks, and then recursively try from rung $n/4$ or $3n/4$ depending on the outcome. But this has the drawback that you could break a lot of jars in finding the answer.</p>\n\n<p>If your primary goal were to conserve jars, on the other hand, you could try the following strategy. Start by dropping a jar from the first rung, then the second rung, and so forth, climbing one higher each time until the jar breaks. In this way, you only need a single jar\u2014at the moment it breaks, you have the correct answer\u2014but you may have to drop it $n$ times (rather than $\\log n$ as in the binary search solution).</p>\n\n<p>So here is the trade-off: it seems you can perform fewer drops if you\u2019re willing to break more jars. To understand better how this trade- off works at a quantitative level, let\u2019s consider how to run this experiment given a fixed \u201cbudget\u201d of $k \\ge 1$ jars. In other words, you have to determine the correct answer\u2014the highest safe rung\u2014and can use at most $k$ jars in doing so.</p>\n\n<p>Suppose you are given a budget of $k = 2$ jars. Describe a strategy for finding the highest safe rung that requires you to drop a jar at most $f (n)$ times, for some function $f (n)$ that grows slower than linearly. (In other words, it should be the case that $\\lim_{n\\to\\infty} f (n)/n = 0$.)</p>\n\n<p>Anyone any insights how to solve this problem?</p>\n\n<p>I know that the answer is $h = \\sqrt n$. I know  that it solves the problem. But I want to know how you got that answer, there must be a general way to do it?</p>\n', 'ViewCount': '672', 'Title': 'Balancing subproblems in resilience testing', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-11T01:48:19.290', 'LastEditDate': '2013-08-01T07:17:26.863', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'user75300', 'PostTypeId': '1', 'OwnerUserId': '8086', 'Tags': '<algorithms><binary-trees><decision-problem><divide-and-conquer>', 'CreationDate': '2013-05-07T21:28:25.053', 'Id': '11981'}{'Body': '<p>Given a Bayesian Network $N$, one can build a junction/joint tree $JT$ over $N$ by applying series of steps (namely, moralisation,triangulation..etc). Then we can use $JT$ to answer queries over $N$.</p>\n\n<p>My question is: what makes BN decomposable into $JT$? The structure (along with the CPTs) must exhibit certain conditions otherwise any graphical model is decomposable.  </p>\n', 'ViewCount': '97', 'Title': 'What makes Bayesian Networks decomposable into joint trees?', 'LastActivityDate': '2013-05-15T08:38:34.180', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12035', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graph-theory><probability-theory><trees>', 'CreationDate': '2013-05-13T02:30:42.550', 'Id': '11983'}{'Body': '<p>So, Google Code Jam round 1C has just wrapped up, and one of its problems seems rather elusive to me:  <a href="https://code.google.com/codejam/contest/2437488/dashboard#s=p2" rel="nofollow">https://code.google.com/codejam/contest/2437488/dashboard#s=p2</a></p>\n\n<p>A quick summary of the problem is thus:</p>\n\n<p>The Great Wall of China starts out as an infinite line, where the height at all locations is $0$.</p>\n\n<p>Some number of tribes $N$, $N \\le 1000$, will attack the wall the wall according to the following parameters - a start day, $D$, a start strength $S$, a start west-coordinate, $W$, and a start east-coordinate, $E$.  This first attack occurs on day $D$, on range $[W,E]$, at strength $S$.  If there is any portion of the Great Wall within $[W,E]$ that has height $&lt; S$, the attack is successful, and at the end of the day, the wall will be built up such that any segment of it within $[W,E]$ of height $&lt; S$ would then be at height $S$ (or greater, if some other attack that day hit upon the same segment with strength $S\' &gt; S$)</p>\n\n<p>Each tribe will perform up to $1000$ attacks before retreating, and each attack will be determined iteratively from the one before it.  Every tribe has some $\\delta_D$, $\\delta_X$, and $\\delta_S$ that determines their sequence of attacks:  The will wait $\\delta_D \\ge 1$ days between attacks, they will move their attack range $\\delta_X$ units for each attack (negative = west, positive = east), though the size of the range will stay the same, and their strength will also increase/decrease by a constant value after each attack.</p>\n\n<p>The goal of the problem is, given a complete description of the attacking tribes, determine how many of their attacks will be successful.</p>\n\n<p>I managed to code a solution that does work, running in about 20 seconds:  I believe the solution I implemented takes $O(A\\log A + (A+X)\\log X)$ time, where $A =$ the total number of attacks in a simulation (max $1000000$), and $X =$ the total number of unique edge points on attack ranges (max $2000000$).</p>\n\n<p>At a high level, my solution:</p>\n\n<ul>\n<li>Reads in all the Tribe information</li>\n<li>Calculates all the unique $X$-coordinates for attack ranges - $O(A)$</li>\n<li>Represents the Wall as a lazily-updated binary tree over the $X$ ranges that tracks minimum height values.  A leaf is the span of two $X$ coordinates with nothing in-between, and all parent nodes represent the continuous interval covered by their children. - $O(X \\log X)$</li>\n<li>Generates all the Attacks every Tribe will perform, and sorts them by day - $O(A \\log A)$</li>\n<li>For each attack, see if it would be successful ($\\log X$ query time).  When the day changes, loop through all unprocessed successful attacks and update the wall accordingly ($\\log X$ update time for each attack). - $O(A\\log X)$</li>\n</ul>\n\n<p>My question is this:  Is there a way to do better than $O(A\\log A + (A+X)\\log X)$?  Perhaps, is there some strategic way to take advantage of the linear nature of Tribes\' successive attacks?  20 seconds feels too long for an intended solution (Although Java might be to blame for that)</p>\n\n<p>-- Edit --</p>\n\n<p>Looking over other discussions and successful solutions seems to indicate that the solution I\'ve described is pretty much the expected algorithm.  The slow-down in my solution is possibly just due to lazy use of auto-boxing and a pointer-based tree structure, rather than an array-based one - so I suspect that, if a solution does exist, it\'s probably not a whole lot better than what\'s here.  We shall see if anything crops up though</p>\n\n<p>-- Edit2 --</p>\n\n<p>The solution has been posted at last: <a href="https://code.google.com/codejam/contest/2437488/dashboard#s=a&amp;a=2" rel="nofollow">https://code.google.com/codejam/contest/2437488/dashboard#s=a&amp;a=2</a><br>\nIt\'s very much the same as what I have posted here; so I am much more inclined to believe that a more efficient solution does not exist.</p>\n', 'ViewCount': '344', 'Title': 'Google Code Jam Great Wall Problem', 'LastEditorUserId': '7678', 'LastActivityDate': '2013-07-14T05:43:02.910', 'LastEditDate': '2013-07-14T05:43:02.910', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7614', 'Tags': '<complexity-theory><data-structures><binary-trees>', 'CreationDate': '2013-05-15T15:26:19.040', 'FavoriteCount': '2', 'Id': '12040'}{'ViewCount': '1087', 'Title': 'Graph Has Two / Three Different Minimal Spanning Trees?', 'LastEditDate': '2013-05-15T20:00:02.037', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8202', 'FavoriteCount': '0', 'Body': "<p>I'm trying to find an efficient method of detecting whether a given graph G has two different minimal spanning trees. I'm also trying to find a method to check whether it has 3 different minimal spanning trees. The naive solution that I've though about is running Kruskal's algorithm once and finding the total weight of the minimal spanning tree. Later , removing an edge from the graph and running Kruskal's algorithm again and checking if the weight of the new tree is the weight of the original minimal spanning tree , and so for each edge in the graph. The runtime is O(|V||E|log|V|) which is not good at all, and I think there's a better way to do it.</p>\n\n<p>Any suggestion would be helpful, thanks in advance</p>\n", 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-17T21:55:27.857', 'CommentCount': '5', 'AcceptedAnswerId': '12058', 'CreationDate': '2013-05-15T18:45:13.007', 'Id': '12048'}{'Body': '<p>There is  a greedy algorithm for finding minimum vertex cover of a tree which uses DFS traversal.</p>\n\n<ol>\n<li>For each leaf of the tree, select its parent (i.e. its parent is in minimum vertex cover).</li>\n<li>For each internal node:<br>\nif any of its children is not selected, then select this node.</li>\n</ol>\n\n<p>How do I prove that this greedy strategy gives an optimal answer? That there is no vertex cover smaller in size than the one that the above algorithm produces?</p>\n', 'ViewCount': '1379', 'Title': 'Correctness-Proof of a greedy-algorithm for minimum vertex cover of a tree', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-05-21T18:43:17.647', 'LastEditDate': '2013-05-21T16:09:33.600', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4980', 'Tags': '<algorithms><trees><greedy-algorithms>', 'CreationDate': '2013-05-21T03:52:48.837', 'Id': '12177'}{'Body': '<p>How to prove that the largest number of leaves in an $n$-tree of height $k$ is $k^n$?</p>\n', 'ViewCount': '236', 'Title': 'Proving that the largest number of leaves in an $n$-ary tree of height $k$ is $k^n$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-22T17:24:20.150', 'LastEditDate': '2013-05-22T02:31:34.160', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-4', 'PostTypeId': '1', 'OwnerUserId': '8284', 'Tags': '<combinatorics><trees><discrete-mathematics>', 'CreationDate': '2013-05-21T17:05:29.760', 'Id': '12196'}{'Body': '<p>In both <a href="https://mitpress.mit.edu/books/introduction-algorithms" rel="nofollow">CLRS</a> (third edition) and Erik Demaine\'s <a href="https://www.youtube.com/watch?v=AjFtTQevtq0" rel="nofollow">lecture</a>, the van Emde Boas tree is defined to store <code>max</code> but not <code>min</code> recursively.  Why store max recursively?</p>\n\n<p>If it is <em>not</em> stored recursively, insert(<em>V</em>, <em>x</em>) can take advantage of the special case where a cluster or summary contains one element (<code>min = max</code>), although I think the advantage gained from this is insignificant.  Keith Schwarz implements it this way in his Archive of Interesting Code.  So why do CLRS and Erik not make use of this optimization in the algorithm?  Is it actually a mistake?</p>\n', 'ViewCount': '142', 'Title': 'van Emde Boas tree: why store max recursively?', 'LastEditorUserId': '8460', 'LastActivityDate': '2013-11-01T10:09:31.133', 'LastEditDate': '2013-06-02T00:10:12.777', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8460', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2013-05-31T06:01:44.097', 'Id': '12392'}{'Body': "<p>Here is the question:</p>\n\n<p>I have a given tree with n nodes. The task is to find the number of subtrees of the given tree with outgoing edges to its complement less than or equal to a given number K.</p>\n\n<p>for example: If <code>n=3</code> and <code>k=1</code></p>\n\n<p>and the given tree is    <code>1---2---3</code></p>\n\n<p>Then the total valid subtrees would be 6</p>\n\n<pre><code>{}, {1}, {3}, {1,2}, {2,3}, {1,2,3}\n</code></pre>\n\n<p>I know I can enumerate all <code>2^n</code> trees and chack the valid ones, but is there some approach that is faster? Can I achieve polynomial time in <code>n</code>? Something close to <code>O(n^3)</code> or even <code>O(n^4)</code> would be nice.</p>\n\n<p>for k=1 this value turns out to be <code>2*n</code></p>\n\n<p><strong>There was a solution provided for this one as:</strong></p>\n\n<p>This is a fairly typical instance of the DP-on-a-tree paradigm. Let's generalize the problem slightly by allowing the specification of a root vertex v and stratifying the counts of the small-boundary trees in two ways: whether v is included, and how many edges comprise the boundary.</p>\n\n<p>The base case is easy. There are no edges and thus two subtrees: one includes v, the other excludes v, and both have no boundary edges. Otherwise, let e = {v, w} be an edge incident to v. The instance looks like this.</p>\n\n<pre><code>|\\         /|\n| \\   e   / |\n|L v-----w R|\n| /       \\ |\n|/         \\|\n</code></pre>\n\n<p>Compute recursively the stratified counts for L rooted at v and R rooted at w.</p>\n\n<p>Subtrees that include v consist of a subtree in L that includes v, plus optionally e and a subtree in R that includes w. Subtrees that don't include v consist of either a subtree in L that doesn't include v, or a subtree in R (double counting the empty tree). This means we can obtain the stratified counts by convolving the stratified counts for L with the stratified counts for R.</p>\n\n<p>Here's how this works on your example. Let's choose root 1.</p>\n\n<pre><code>  e\n1---2---3\n</code></pre>\n\n<p>We choose e as shown and recurse.</p>\n\n<pre><code>1\n</code></pre>\n\n<p>The vector for includes-1 is [1], since the one subtree is {1}, with no boundary. The vector for excludes-1 is [1], since the one subtree is {}, also with no boundary.</p>\n\n<pre><code>2---3\n</code></pre>\n\n<p>We compute 2 and 3 as we did for 1. The vector for includes-2 is [1, 1], since {2, 3} has no boundary edges, and {2} has one. We obtained this vector by adding the includes-2 vector for 2, shifted by one because of the new boundary edge to make [0, 1], to the convolution of the includes-2 vector for 2 with the includes-3 vector for 3, which is [1, 0]. The vector for excludes-2 is [1] + [1, 1] - [1] = [1, 1], where [1, 1] is the sum of the shifted includes-3 vector and the excludes-3 vector, and the subtraction is to compensate for double-counting {}.</p>\n\n<p>Now, for the original invocation, to get the includes-1 vector, we add [0, 1], the includes-1 vector for 1 shifted by one, to the convolution of [1] with [1, 1], obtaining [1, 2]. To check: {1, 2, 3} has no boundary, and {1} and {1, 2} have one boundary edge. The excludes-1 vector is [1] + [1, 2, 1] - [1] = [1, 2, 1]. To check: {} has no boundary, {2, 3} and {3} have one boundary edge, and {2} has two boundary edges.</p>\n\n<p><strong>I am unable to understand this fully. Can anyone help?</strong></p>\n", 'ViewCount': '242', 'LastEditorDisplayName': 'user742', 'Title': 'Trouble understanding this dynamic programming solution', 'LastActivityDate': '2013-09-20T09:33:50.137', 'LastEditDate': '2013-09-20T09:33:50.137', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12449', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8505', 'Tags': '<algorithms><graph-theory><dynamic-programming><trees>', 'CreationDate': '2013-06-03T16:03:41.183', 'Id': '12445'}{'Body': '<p>I have an exercise which I can\'t solve.</p>\n\n<p><strong>Exercise.</strong> Consider a game where the players have $2$ pure strategies each and assume that the graph $G$ is a tree with maximum degree $3$. Give a polynomial time algorithm to decide if such a game has a pure Nash equilibrium.</p>\n\n<p>The idea seems pretty obvious, every vertex of the tree and corresponding neighbouring vertices represent a "mini" game  which can be represent in normal form with size at most $2^4$. This "mini" game can decided efficiently in polynomial time.</p>\n\n<p>The problem is we have $n$ such a neighbouring areas (as a number of players), therefore we need somehow iteratively going over every area and decide where we have equilibrium and if not going back to the previous neighbouring areas change actions and check the existence. On the worst case it is going to take $2^{4n}$.</p>\n\n<p>But how to decide it in polynomial time?</p>\n', 'ViewCount': '47', 'Title': 'Nash Equilibrium in Tree of Bounded Degree', 'LastActivityDate': '2013-06-04T15:26:43.427', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4778', 'Tags': '<complexity-theory><trees><game-theory><polynomial-time>', 'CreationDate': '2013-06-04T15:26:43.427', 'Id': '12460'}{'Body': "<p>I am trying to prove by induction  the following theorem:\nUse Induction to prove the following fact: for every integer, $N\\ge  1$ , a BST with $N$ nodes must have at least $\\log( N + 1)$ levels.\nI've proved the base case but I am struggling to figure out how to apply induction to prove for the $K+1$ case. Any suggestions would be wonderful.</p>\n", 'ViewCount': '49', 'Title': 'Proving that a BST with N>=1 nodes will have log(N+1) levels', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-11T16:27:11.647', 'LastEditDate': '2013-06-11T16:27:11.647', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8624', 'Tags': '<graph-theory><data-structures><binary-trees><induction>', 'CreationDate': '2013-06-11T16:18:32.680', 'Id': '12622'}{'Body': '<p>Well, i have a binary search tree $T$ that is equilibrated by height witch has $2^d+c$ nodes ($c&lt;2^d$). \nWhat is the number of comparisons that will occur in the worst case scenario, if we ask whether $k\\in V(T)$ and why does it arise?</p>\n', 'ViewCount': '274', 'Title': 'Worst case scenario in binary search tree retrieval', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-14T21:57:25.843', 'LastEditDate': '2013-06-14T12:13:40.983', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'Mihai Alin', 'PostTypeId': '1', 'Tags': '<graph-theory><search-trees><search-problem>', 'CreationDate': '2013-06-13T18:46:27.367', 'Id': '12667'}{'Body': "<p>Find the number of topological sorts in a tree that has nodes that hold the size of their sub-tree including itself.</p>\n\n<p>I've tried thinking what would be the best for m to define it but couldn't get anything specific. </p>\n\n<p>Maybe $\\mbox{Number of sorts =}\\prod\\limits_{x\\in \\mbox{children}}\\mbox{Number of sorts}(x)$\nMeaning that starting at the root I call the the method recursively multilying each result by the previous children's result. When we reach a node with size 1 we assume that there's just 1 topological sort;</p>\n\n<p>If this is correct I'd really appreciate some help with proving correctness and if not a explanation why and a clue could be nice :)</p>\n", 'ViewCount': '50', 'Title': 'Find the number of topological sorts in a tree', 'LastEditorUserId': '8709', 'LastActivityDate': '2013-06-17T16:06:57.213', 'LastEditDate': '2013-06-17T15:42:53.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12716', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8709', 'Tags': '<graph-theory><graphs><algorithm-analysis><trees>', 'CreationDate': '2013-06-17T15:29:23.190', 'Id': '12713'}{'Body': '<p>I have been trying to solve this LCA problem for many queries on a tree of size ~ 10^5</p>\n\n<p>There are about 10^5 queries that have to be handled. What is the best way to do this? I am aware of the naive solution that takes linear time in worst case. I have read a few articles where they claimed it was analogous to Range Minimum Query. Like <a href="http://www14.in.tum.de/konferenzen/Jass03/presentations/kiefer.pdf" rel="nofollow">this one</a>. But after they find the L{} array things get hard to understand. I would be extremely greatful if someone could give a link to alternate solution or provide one. Something with a worst case complexity of O(log n) or lower would be fine. Thanks.</p>\n', 'ViewCount': '77', 'Title': 'Lowest Common Ancestor Problem', 'LastEditorUserId': '8757', 'LastActivityDate': '2013-06-19T21:24:34.693', 'LastEditDate': '2013-06-19T21:24:34.693', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8757', 'Tags': '<algorithms><trees>', 'CreationDate': '2013-06-19T21:18:42.883', 'Id': '12768'}{'Body': '<p>Let $T$ be a depth-first search tree of a connected undirected graph $G$ and $h$ be the height of $T$. How do you show that $G$ has no more than $h \\times |V|$ edges where $|V|$ is the number of vertices in $G$? </p>\n', 'ViewCount': '75', 'Title': 'Upper bound on the number of edges relative to the height of a DFS tree', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-26T12:42:38.160', 'LastEditDate': '2013-06-26T12:42:38.160', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12852', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2013-06-23T22:54:36.937', 'Id': '12851'}{'Body': '<p>Working on a project for my Data Structures class. </p>\n\n<p>I\'ve implemented a Red/Black tree in Java. One of the operations required of the data structure is "find a node which has a key of at least n". The leaves of the tree are the sentinel node.</p>\n\n<p>My initial thought was using the regular search with modifications:</p>\n\n<ol><li>Search for a node with key == n</li><li>If result == sentinel, call getSuccessor on parent until a node with key > n is found</li></ol>\n\n<p>I -think- this is $O(m*lgm)$ ($m$ being number of nodes in the tree) at the worst case. </p>\n\n<p>Inspired by the getSuccessor code - if right subtree of target node is empty, find smallest ancestor which has a left child also an ancestor - was wondering if there is a better way to do this.</p>\n\n<p>Would appreciate any advice; thanks. </p>\n', 'ViewCount': '84', 'Title': 'Find node with key of at least n in a binary search tree', 'LastActivityDate': '2013-06-30T08:45:47.077', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12975', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8929', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-06-29T21:31:49.023', 'Id': '12971'}{'Body': "<p>Given a valid binary search tree whose keys are unique real numbers, and a set of $k$ pointers to the $k$ minimum elements in the tree, will the BST property be maintained if I replace all $k$ elements with the average of the $k$ elements? </p>\n\n<p>The BST property as given in Corman:</p>\n\n<blockquote>\n  <p>Let $x$ be a node in a binary search tree. If $y$ is a node in the\n  left subtree of $x$, then $y.key \\leq x.key$. If $y$ is a node in the\n  right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n\n<p>I've tried this with a few test cases for $k=3$ and a few different trees, and it seems to hold, but I'm not sure if it actually does <em>and how I could prove it</em>.</p>\n", 'ViewCount': '122', 'Title': 'Binary Search Tree: Replace $k$ min elements with their average', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-30T20:46:51.233', 'LastEditDate': '2013-06-30T19:15:30.497', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '12998', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<data-structures><proof-techniques><search-trees>', 'CreationDate': '2013-06-30T09:09:43.920', 'Id': '12984'}{'Body': '<p>A <em>binary sequence</em> of length $n$ is just an ordered sequence $x_1,\\ldots,x_n$ so that each $x_j$ is either $0$ or $1$. In order to generate all such binary sequences, one can use the obvious binary tree structure in the following way: the root is "empty", but each left child corresponds to the addition of $0$ to the existing string and each right child to a $1$. Now, each binary sequence is simply a path of length $n+1$ starting at the root and terminating at a leaf. </p>\n\n<p>Here\'s my question:</p>\n\n<blockquote>\n  <p>Can we do better if we only want to generate all binary strings of length $2n$ which have precisely $n$ zeros and $n$ ones?</p>\n</blockquote>\n\n<p>By "can we do better", I mean we should have lower complexity than the silly algorithm which first builds the entire tree above and then tries to find those paths with an equal number of "left" and "right" edges.</p>\n', 'ViewCount': '257', 'Title': "How does one efficiently produce all binary sequences with an equal number of 0's and 1's?", 'LastActivityDate': '2013-07-01T08:25:02.287', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12994', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8940', 'Tags': '<algorithms><graphs><binary-trees>', 'CreationDate': '2013-06-30T14:02:49.333', 'Id': '12992'}{'Body': '<p>Let\'s say I have a software that calculates integrals, formally if possible and if not, then it computes an approximation by taking a small $dt$. Of course if the integral is an <em>unknown</em> number, I wouldn\'t be interested in giving it a name. But if I calculate $\\int_0^e\\left(\\frac{\\pi}e+1\\right)dt$, I\'d like to get $\\pi+e$ instead of $5.85987\\dots$. Now of course any decent program would be able to calculate that integral that way. But if I made it a bit trickier, I\'m quite sure most wouldn\'t. For example $\\int_0^e\\ln\\left|\\exp\\left(\\left(\\frac{\\pi}e+1\\right)+\\sqrt{2}i\\right)\\right|dt$. Maybe some programs would. But at some point, they would all fail. And when I reach that point where I can\'t compute it formally, I want to be able to say <em>"Hey, it\'s not far from $\\pi+e$"</em>.</p>\n\n<p><strong>How do I find an expression using (a small set of well-known) constants (for example $\\{1,e,\\pi\\}$), $+$, ,$-$,$\\times$ $/$ using as few characters* as possible which value is at a distance of at most $\\varepsilon &gt;0$ of my approximate value?</strong></p>\n\n<p>Obviously I could compute all the trees until I hit it or got more than $M$ elements (the maximum length of a formula that I could find interesting). M wouldn\'t be that big so it would be feasible. But isn\'t there a <em>bright</em> way of doing this?</p>\n\n<hr>\n\n<p>Because my current vision of how this could be done, I think all algorithm better than the naive brute-force one are </p>\n\n<p>Things I\'ve though of:</p>\n\n<ul>\n<li><p>Use inequalities. For example, if there is a sum at the root, order all the operands in the order: unknown sign, negative, positive so that once you\'re done with negatives and start the positive, if you get over the value you want, you know you\'re not getting anywhere. And things like that.</p></li>\n<li><p>Keep a <em>"do not try"</em> subset of the variables. And pass it as an argument to the recursive function trying the trees. For example in $\\pi + e - \\cdot$, both $\\pi$ and $e$ would be in the <em>"do not try"</em> subset since if they helped find a formula, then there would be a shorted one with the same value. But for that thing to be efficient, I\'d probably need to remove $1$ from the constants and add an operation $n\\times \\cdot$ for all $n \\in \\Bbb Z$ but that brings a new problem: You have infinitely many operators and therefore infinitely many trees of a fixed size... And I\'m pretty sure that unless I implement everything from structures to the actual algorithm with that specific goal in mind, it\'ll actually slow things down...</p></li>\n</ul>\n\n<hr>\n\n<p>I\'d be fine with any kind of <strong>deterministic</strong> algorithm even though I couldn\'t think of anything aside from the naive one plus removing some trees that could work.</p>\n\n<hr>\n\n<p>* It\'s the only way I found to measure the <em>relevance</em> of a formula. But if you\'ve got another one, I\'d like to hear it :)</p>\n', 'ViewCount': '71', 'Title': 'Assigning a formula to an approximate value', 'LastEditorUserId': '2353', 'LastActivityDate': '2013-07-09T17:50:20.750', 'LastEditDate': '2013-07-09T17:50:20.750', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2353', 'Tags': '<artificial-intelligence><trees>', 'CreationDate': '2013-07-09T17:35:05.900', 'Id': '13180'}{'Body': "<p>As I think of data structures I studied and dealt with, they are all optimized to retrieve/put  a random element, to perform optimally based on unspoken assumption that each element has equal odds of being asked for (e.g. Red-Black trees).</p>\n\n<p>By the nature of my program, I need to maintain an online dictionary of items that typically serves items that were added last.</p>\n\n<p>That is, the later an item has been added, the higher the likelihood of it being retrieved back in the nearest future.</p>\n\n<p>Speaking more formally, let's define a set $S$ of pair $(k_i, d_i)$, where $k_i \\in K $ and $K$ has a comparison operator $\\leq$ defined, $d_i \\in D$. Let $p(k)$ be the probability of our need to retrieve pair $(k, d)$.</p>\n\n<p>What is an efficient way to store $S$ with regard to function $p$ ?</p>\n", 'ViewCount': '117', 'Title': '"Last Come => More Relevant" data structures', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-13T10:12:31.957', 'LastEditDate': '2013-07-12T07:34:39.067', 'AnswerCount': '3', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9134', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2013-07-11T17:29:37.650', 'Id': '13231'}{'ViewCount': '139', 'Title': 'Reachability queries on a tree in $O(1)$ time with $O(n+m)$ time preprocessing', 'LastEditDate': '2013-07-18T07:18:05.990', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9214', 'FavoriteCount': '3', 'Body': '<p>I am given an undirected tree $T$ in the usual graph theoretic sense. Given a vertex $v$ and an edge $(v,u)$ incident to $v$, I need to answer queries of the form <em>return any leaf of $T$ that is reachable from $v$ with a path including $(u,v)$, and no other edges incident to $v$?</em> More informally, the restriction is that when the edge is given, we can only proceed in to that direction. </p>\n\n<p>I can simply perform a DFS and return a leaf found. I think this would take $O(d)$ time, where $d$ is the diameter of $T$. However, I\'d like to answer a query in $O(1)$ time. Moreover, I\'d only like to allow linear preprocessing time. My idea for achieving this was to use a DFS, label leaves, and then label edges when the search backtracks. This idea might work with some additional effort, but I\'m really unsure about the details.</p>\n\n<p>"Graph reachability" turned up some results, but maybe they are dealing with more complex problems. I\'m happy with any method that uses $O(n+m)$ preprocessing time and answers the queries in $O(1)$ time.</p>\n', 'Tags': '<algorithms><data-structures><trees>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-18T07:18:05.990', 'CommentCount': '4', 'AcceptedAnswerId': '13320', 'CreationDate': '2013-07-17T15:31:23.960', 'Id': '13316'}{'Body': '<p>My similarity search seminar topic are <a href="https://en.wikipedia.org/wiki/M-tree" rel="nofollow">M-trees</a>. I would like to give some examples about where they are practically applied, but I can\'t find anything googling. </p>\n\n<p>Does someone know if M-trees are still used and what for? I am interested in answers regarding both practice and applied research.</p>\n', 'ViewCount': '96', 'Title': 'Where are M-Trees applied in practice?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-30T18:04:07.047', 'LastEditDate': '2013-07-30T16:40:04.920', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9407', 'Tags': '<data-structures><search-trees><applied-theory>', 'CreationDate': '2013-07-29T16:39:35.700', 'Id': '13493'}{'Body': '<p><img src="http://i.stack.imgur.com/oB6Zq.jpg" alt="enter image description here"></p>\n\n<p>From the above image, while trying to maintain an <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL tree data structure</a>, how would the tree look after inserting the value 10? Also, if anyone has any suggestions or simple method of rotating, feel free to share. I am a bit lost with this idea of maintaining a certain height in this data structure.</p>\n', 'ViewCount': '200', 'Title': 'How does insertion work in an AVL tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-08T18:19:50.890', 'LastEditDate': '2013-08-05T20:31:26.483', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13582', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9490', 'Tags': '<data-structures><trees><search-trees>', 'CreationDate': '2013-08-03T05:50:15.613', 'Id': '13581'}{'Body': "<p>According to CLRS, the Prim's algorithms is implemented as below -- </p>\n\n<blockquote>\n  <p>$\\mathtt{\\text{MST-PRIM}}(G,w,r)$  </p>\n  \n  <ul>\n  <li>for each $u \\in V[G]$ do<br>\n  <ul>\n  <li>$\\mathtt{\\text{key}}[u] \\leftarrow \\infty$  </li>\n  <li>$\\pi[u] \\leftarrow \\mathtt{\\text{NIL}}$ </li>\n  </ul></li>\n  <li>$\\mathtt{\\text{key}}[r] \\leftarrow 0$  </li>\n  <li>$Q \\leftarrow V[G]$  </li>\n  <li>while $Q \\ne \\emptyset$ do // ... $O(V)$\n  <ul>\n  <li>$u$ $\\leftarrow$ $\\mathtt{\\text{EXTRACT-MIN}}(u)$ // ... $O(\\lg V)$<br>\n  <ul>\n  <li>for each $v \\in \\mathtt{\\text{adj}}[u]$ do // ... $O(E)$<br>\n  <ul>\n  <li>if $v \\in Q$ and $w(u,v) \\gt \\mathtt{\\text{key}}[v]$\n  <ul>\n  <li>then $\\pi[v] \\leftarrow u$\n  <ul>\n  <li>$\\mathtt{\\text{key}} \\leftarrow w(u,v)$ // $\\mathtt{\\text{DECREASE-KEY}}$ ... $O(\\lg V)$</li>\n  </ul></li>\n  </ul></li>\n  </ul></li>\n  </ul></li>\n  </ul></li>\n  </ul>\n</blockquote>\n\n<p>The book says the total complexity is $O(V \\lg V + E \\lg V) \\approx O(E \\lg V)$. However, what I understood is that the inner <code>for</code> loop with the <code>DECREASE-KEY</code> operation will cost $O(E \\lg V)$, and the outer <code>while</code> loop encloses both the <code>EXTRACT-MIN</code> and the inner <code>for</code> loop, so the total complexity should be $O(V (\\lg V + E \\lg V)) = O(V \\lg V + EV \\lg V) \\approx O(EV \\lg V)$. </p>\n\n<p>Why the complexity analysis is not performed as such? and What is wrong with my formulation?</p>\n", 'ViewCount': '534', 'Title': "MST: Prim's algorithm complexity, why not $O(EV \\lg V)$?", 'LastActivityDate': '2013-08-05T06:45:45.717', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13609', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7678', 'Tags': '<algorithms><algorithm-analysis><spanning-trees>', 'CreationDate': '2013-08-05T05:59:33.073', 'FavoriteCount': '1', 'Id': '13608'}{'ViewCount': '280', 'Title': 'What linked list data structure adjustments would give me fast random lookup?', 'LastEditDate': '2013-08-07T13:56:23.087', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7284', 'FavoriteCount': '1', 'Body': "<p>I am presently using an doubly linked list (C++ <code>std::list</code>) to hold a bunch of records that each have a unique integer identifier.  The linked list is created in sorted order such that in the list, the next item always has a larger unique identifier than its predecessor.</p>\n\n<p>The issue I'm facing is that occasionally I need to be able to insert an item quickly into its  relative sorted position and using a plain linked list means this operation is $O(n)$ which is causing performance issues for me.  Generally, this would mean I want to use something like a binary tree (C++ <code>std::map</code>), however, I am also depending upon the following feature of a doubly linked list for good performance:</p>\n\n<ul>\n<li>Ability to splice a contiguous section out of one linked list into another in $O(1)$ time. (Amortized $O(1)$ or $O(\\log \\log n)$ would be good enough.)</li>\n</ul>\n\n<p>One feature of my data that I would like to leverage is that I often have long ranges of contiguous records where each one's unique integer is exactly one more than its predecessor.  When searching for an item's relative sorted position, it would always be outside such contiguous records since there are no duplicate identifiers.</p>\n\n<p>I'd like to find a replacement data structure or augmentation to a doubly linked list that will allow me to continue to splice whole sections from one list to another in constant time but allow me to locate the sorted position in which to insert a new record in better than $O(n)$ time.</p>\n\n<p>Other operations include forward and backward iteration across the items. The record indexes begin at zero and grow upwards towards 64 bits, generally sequentially, and the code works well in such cases. Occasionally some records are not available before subsequent ones, it is the insertion of these missing records that causes the performance issues now. </p>\n\n<p>One possible approach that occurs to me is to cache the location of several indexes.  The cache would get invalidated whenever a splice removes items that might overlap the cached entries.  With this cache, instead of doing a linear search, the search could instead begin from the cache point iterator whose unique index is closest to the one whose position is being  searched for.  However, I'd like to more fully utilize the feature of the contiguous records.  I also thought about a hierarchical linked list where I have a top level linked list of contiguous regions, where each region is a linked list of records that are consecutive, but I didn't see a clean way to adapt a linked list to provide this functionality.  Perhaps something like this has been done before?  I find skip lists to be close, but do not see the splice() functionality, plus a generic skip list would not leverage the fact that insertion never occurs within contiguous records.</p>\n", 'Tags': '<data-structures><time-complexity><binary-trees><linked-lists>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-08T10:37:59.160', 'CommentCount': '3', 'AcceptedAnswerId': '13646', 'CreationDate': '2013-08-05T23:00:36.700', 'Id': '13620'}{'Body': '<p>I want to know how to calculate total number of nodes in a perfect balanced binary tree with $n$ nodes in the last level. I know the answer is $2\\cdot 2^{\\log n} - 1$. Just curious how this can be calculated</p>\n', 'ViewCount': '564', 'Title': 'What is the size of the Perfect binary tree with n nodes in last level', 'LastEditorUserId': '157', 'LastActivityDate': '2013-08-06T00:48:19.433', 'LastEditDate': '2013-08-06T00:48:19.433', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9536', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2013-08-05T23:48:11.370', 'Id': '13621'}{'Body': u"<p>I am trying to figure out difference between fully- and quasi-reduced BDDs. I have read a lot of material but still it is not very clear. As I am trying to figure out the quasi reduced version for union between two BDDs.\nThe algorithm for union between two fully-reduced BDDs is </p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n   //fully-reduced version\n   local bdd r;\n1  if p=0 or q=1 then return q;\n2  if q=0 or p=1 then return p;\n3  if p=q then return p;\n4  if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n5  if p.lvl = q.lvl then\n6    r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n7  else if p.lvl &gt; q.lvl then\n8    r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q), Union(p[1], q));\n9  else since p.lvl &lt; q.lvl then\n10   r \u2190 UniqueTableInsert(q.lvl, Union(p, q[0]), Union(p, q[1]));\n11 enter\u27e8UnionCODE,{p,q}:r\u27e9inCache;\n12 return r;\n</code></pre>\n\n<p>I have read the paper <em>Binary decision diagrams in theory and practice</em> by Rolf Drechsler, Detlef Sieling for basics of BDD, and <em>Data Representation and Efficient Solution: A Decision Diagram Approach</em> by Gianfranco Ciardo for quasi-reduced and fully reduced definitions. Then I read more papers with more or less same description of quasi- and fully-reduced BDDs. In the former paper I mentioned the authors talk about reduced BDDs, I am not clear whether these BDDs are fully reduced. Quasi-reduced BDDs has no variable skipping so how come they are reduced when they have redundant nodes. I am pretty confused between BDD, quasi-reduced BDD and fully-reduced BDD. Yes, I am trying to find the difference between union algorithm for quasi-reduced and fully-reduced, for this I need to look at the quasi-reduced version of union algorithm.</p>\n\n<p>I figured out an algorithm for union of two quasi reduced BDDs <code>p</code> and <code>q</code> resulting in <code>r</code>.</p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n  local bdd r;\n1 if p=0 or q=1 then return q;\n2 if q=0 or p=1 then return p;\n3 if p=q then return p;\n4 if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n  //p.lvl = q.lvl in case of quasi reduced BDDs\n5 r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n6 enter\u27e8UnionCODE,{p,q}:r\u27e9 in Cache;\n7 return r;\n</code></pre>\n\n<p>Since there is no variable skipping, <code>p.lvl</code> is always equal to <code>q.lvl</code>. I have a question about this algorithm.</p>\n\n<p>If I want to implement Xor or Xnor for quasi-reduced BDDs, can it be done the same way as union or should I implement the expression <code>pq' + p'q</code> where <code>q' = !q</code>.</p>\n", 'ViewCount': '86', 'Title': 'Difference between fully-reduced BDD and quasi-reduced BDD', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:56:46.307', 'LastEditDate': '2013-08-13T08:56:46.307', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9556', 'Tags': '<algorithms><terminology><logic><binary-trees><bdd>', 'CreationDate': '2013-08-06T23:35:14.983', 'Id': '13637'}{'Body': '<p><strong>Question:</strong></p>\n\n<p>Suppose I have a </p>\n\n<ul>\n<li>set of male people, and </li>\n<li>a function isAncestor(person1,person2) that checks whether person1 is an ancestor of person2 in O(1) time. Eg, isAncestor(grandfather, grandson) would return true.</li>\n</ul>\n\n<p>What are some fast algorithms for constructing a complete "family tree"  by using only this information? (or "family forest" as not everyone may be related to a single common ancestor).</p>\n\n<p><strong>Comment:</strong></p>\n\n<p>This is not homework or from a book. It is derived from some issues I\'m having coupling an adaptive finite element code to some blackbox mesh generation software, boiled down to the core problem and expressed in an analogy that shares the same mathematical structure. Right now I have a brute-force $O(n^3)$ method that seems horribly inefficient.</p>\n\n<p>Thank you for any help.</p>\n\n<p><strong>Results:</strong></p>\n\n<p>I\'ve implemented Gilles suggestion in Matlab and tested it. Here is the pseudocode, code, and unit test script. I release it all to the public domain.</p>\n\n<p><em>Pseudo-code</em>:</p>\n\n<pre>\nfunction buildAncestorForest\n    roots = empty list\n    for each person p\n        roots = graft(p, roots)\n\n    subfunction new_roots = graft(q, old_roots)\n        descendents = empty list\n        nondescendents = empty list\n        for each person t in old_roots\n            if q is an ancestor of t\n                append t to descendents\n            else\n                append t to nondescendents\n\n        if descendents is still empty\n            q_is_incomparable = true; \n            for each person t in old_roots\n                if t is an ancestor of q\n                    new_roots = old_roots;\n                    new children of t = graft(q, old children of t)\n                    q_is_incomparable = false;\n                    break for loop\n            if (q_is_incomparable)\n                new_roots = append q to old_roots;\n        else\n            new_roots = append q to nondescendents;\n            for each person t in descendents\n                children of q = graft(t, children of q);\n</pre>\n\n<p><em>Matlab code:</em></p>\n\n<p><a href="https://github.com/NickAlger/MeshADMM/blob/master/buildAncestorForest.m" rel="nofollow">https://github.com/NickAlger/MeshADMM/blob/master/buildAncestorForest.m</a></p>\n\n<p><em>Unit test script:</em></p>\n\n<p><a href="https://github.com/NickAlger/MeshADMM/blob/master/test_buildAncestorForest.m" rel="nofollow">https://github.com/NickAlger/MeshADMM/blob/master/test_buildAncestorForest.m</a></p>\n', 'ViewCount': '163', 'Title': 'Constructing Tree (forest) from Ancestor function', 'LastEditorUserId': '9589', 'LastActivityDate': '2013-08-25T01:24:03.963', 'LastEditDate': '2013-08-25T01:24:03.963', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '13692', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9589', 'Tags': '<algorithms><trees>', 'CreationDate': '2013-08-09T09:50:43.147', 'Id': '13685'}{'Body': '<p>I have </p>\n\n<ol>\n<li>two red-black trees $T_1$ of black height $H_1$ and $T_2$ of black height $H_2$</li>\n<li>such that all the nodes $N$ belonging to $T_1$ are less than (in value) all the nodes $N$ of $T_2$</li>\n<li>and a key $K$ such that $K$ is greater than all the nodes of $T_1$ and less than all the nodes of $T_2$.</li>\n</ol>\n\n<p>I wanted to devise an algorithm to combine $T_1$, $K$ and $T_2$ into a single red-black tree $T$.</p>\n\n<p>I could delete each element from either $T_1$ or $T_2$ and put it in other tree. But that will give me an algorithm of time-complexity $2^{H_1}$ or $2^{H_2}$ (depending on the tree from which I have deleted the elements from). I would like to have an algorithm which is $O(\\max(H_1,H_2))$.</p>\n\n<blockquote>\n  <p>Definitions : <br><br> Black-height is the number of black-colored nodes in\n  its path to the root.</p>\n  \n  <p>Red-Black tree : A binary search tree, where each node is coloured\n  either red or black and</p>\n  \n  <ul>\n  <li>The root is black All NULL nodes are black</li>\n  <li>If a node is red, then both its children are black </li>\n  <li>For each node, all paths from that node to descendant NULL nodes have the same number of black nodes.</li>\n  </ul>\n</blockquote>\n', 'ViewCount': '561', 'Title': 'Joining two red-black trees', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-12T23:42:30.383', 'LastEditDate': '2013-08-11T13:20:15.663', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6699', 'Tags': '<algorithms><data-structures><search-trees>', 'CreationDate': '2013-08-11T07:06:44.943', 'Id': '13703'}{'Body': u"<p>Below is an algorithm for union of two quasi reduced BDDs <code>p</code> and <code>q</code> resulting in <code>r</code>.</p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n  local bdd r;\n1 if p=0 or q=1 then return q;\n2 if q=0 or p=1 then return p;\n3 if p=q then return p;\n4 if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n  //p.lvl = q.lvl in case of quasi reduced BDDs\n5 r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n6 enter\u27e8UnionCODE,{p,q}:r\u27e9 in Cache;\n7 return r;\n</code></pre>\n\n<p>Since there is no variable skipping, <code>p.lvl</code> is always equal to <code>q.lvl</code>. I have a question about this algorithm.</p>\n\n<p>If I want to implement Xor or Xnor for quasi-reduced BDDs, can it be done the same way as union or should I implement the expression <code>pq' + p'q</code> where <code>q' = !q</code>.</p>\n", 'ViewCount': '21', 'ClosedDate': '2013-08-13T08:54:25.437', 'Title': 'Can xor and xnor for quasi-reduced BDDs be implemented just like union?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:19:40.103', 'LastEditDate': '2013-08-13T08:19:40.103', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9598', 'Tags': '<algorithms><logic><binary-trees>', 'CreationDate': '2013-08-13T02:32:32.443', 'Id': '13722'}{'Body': u'<p>How can I write an algorithm which inverts a 2-level BDD? It should take as input a 2L-level quasi-reduced BDD rooted at $r$ encoding a relation $R : B^L \u2192 2^{B^L}$ and returns the 2L-level quasi-reduced BDD rooted at $s$ encoding the relation $R^{\u22121} : B^L \u21922^{B^L}$, that is, $j \\in R(i) \\iff i \\in R^{\u22121}(j)$.</p>\n', 'ViewCount': '39', 'Title': 'Inversion of BDD', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:20:09.527', 'LastEditDate': '2013-08-13T08:20:09.527', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9598', 'Tags': '<algorithms><logic><binary-trees>', 'CreationDate': '2013-08-13T03:47:07.090', 'Id': '13723'}{'Body': '<p>I need to keep a collection on integers in the range 0 to 65535 so that I can quickly do the following:</p>\n\n<ul>\n<li>Insert a new integer</li>\n<li>Insert a range of contiguous integers</li>\n<li>Remove an integer</li>\n<li>Remove all integers below an integer</li>\n<li>Test if an integer is present</li>\n</ul>\n\n<p>My data has the property that it often contains runs of integers in the collection.  For example, the collection might at one point in time be:</p>\n\n<pre><code>{ 121, 122, 123, 124, 3201, 3202, 5897, 8912, 8913, 8914, 18823, 18824, 40891 }\n</code></pre>\n\n<p>The simplest approach is just to use a balanced binary tree like the C++ std::set, however, using that, I am not leveraging the fact that I often have runs of numbers.  Perhaps it would be better to store a collection of ranges?  But that means a range needs to be able to be broken up if an integer in its middle is removed, or joined together if the space between two ranges in filled in.</p>\n\n<p>Are there any existing data structures that would be well suited for this problem?</p>\n', 'ViewCount': '402', 'Title': 'What data structure would efficiently store integer ranges?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-26T17:37:25.270', 'LastEditDate': '2013-08-26T11:07:37.533', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7284', 'Tags': '<data-structures><efficiency><search-trees><integers>', 'CreationDate': '2013-08-22T20:22:55.240', 'Id': '13874'}{'Body': '<p>I\'m interested in the first appearance in the CS literature of the data structure described <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=lowestCommonAncestor#Segment_Trees" rel="nofollow">here</a> which is used to answer Range Queries. Although I have come across the same data structure many times with the name <em>segment tree</em> (mostly in algorithmic competition sites), it seems that the same name is also used for <a href="http://en.wikipedia.org/wiki/Segment_tree" rel="nofollow">this</a> data structure which is quite different from the first one and has application in computational geometry.</p>\n\n<p>I\'d like to know who introduced the data structure described in the TopCoder tutorial and if another name was initially used as there seems to be a confusion between the two data structures that go by the same name.</p>\n', 'ViewCount': '130', 'Title': 'Origins of the Segment tree data structure', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T15:14:39.863', 'LastEditDate': '2013-09-09T09:34:27.603', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10010', 'Tags': '<reference-request><data-structures><trees>', 'CreationDate': '2013-09-06T12:32:28.053', 'Id': '14172'}{'Body': '<p>When inserting an item into a splay tree, rotations are performed in pairs based on either a zig-zag or zig-zig pattern. When there is an odd number of rotations to be performed, one could either do the extra rotation beginning at the leaf or save the extra rotation and do it at the root. Does it matter?</p>\n\n<p>For example, in the attached image I insert a 4 into a BST, and "splay it"\nit to the root. On the top of the figure, I first locate the zig-zig pair \nat the leaf node and perform the zig-zag splay from the bottom leaving a final right rotation at the root. At the bottom of the figure, I first do the odd rotation starting from the leaf, and the then do a zig-zig splay to the root.</p>\n\n<p>Which is correct? Or  will both lead to the usual splay-tree performance?</p>\n\n<p><img src="http://i.stack.imgur.com/CNSAZ.png" alt="two ways to splay for odd number of rotations"></p>\n', 'ViewCount': '186', 'Title': 'Splay tree with odd number of rotations', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-03-01T08:50:13.433', 'LastEditDate': '2013-09-08T10:02:30.483', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '10033', 'Tags': '<data-structures><binary-trees><splay-trees>', 'CreationDate': '2013-09-07T20:35:21.943', 'FavoriteCount': '1', 'Id': '14200'}{'Body': '<p>We have a tree with $N$ nodes. $N \\le 10^5.$ Each node has a value $V$ associated with it. Now we have $Q$ $(\\le 10^5)$ queries. There are two types of queries:</p>\n\n<ol>\n<li><p>Q X Y: in this type of query we have to decrement each node of the subtree rooted at $X$ by value $Y$.</p></li>\n<li><p>C X: in this type of query we have to count the number of nodes in the subtree rooted at $X$ that are $\\le 0$.</p></li>\n</ol>\n\n<p>Here is my approach:\nI can perform the update query in $O(N)$ along with some sort of lazy propogation.\nThe count query can be thus performed in constant time.</p>\n\n<p>But I am more than sure that there will be a better approach to handle update queries. Possibly a $O(\\log N)$ bound for both updates and counts. Is there a way I could map this tree into a segment tree or a bit.</p>\n\n<p>Any approach would be appreciated.</p>\n', 'ViewCount': '174', 'Title': 'Queries on Tree', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-08T03:14:17.253', 'LastEditDate': '2013-09-08T10:00:49.680', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10039', 'Tags': '<data-structures><trees>', 'CreationDate': '2013-09-08T09:24:29.977', 'FavoriteCount': '1', 'Id': '14210'}{'Body': '<p>I have an array of size $N$ $(N \\leq 10^5)$. I need to perform two types of operations on the array.</p>\n\n<ol>\n<li><p>Decrease elements in range $[L,R]$ by $X$.</p></li>\n<li><p>Count the number of negative elements in range $[L,R]$.</p></li>\n</ol>\n\n<p>There are $10^5$ queries. All I can think about is using a segment tree with lazy propagation, but I believe there would be a better method. The segment tree method will probably time out because in case of alternate update/count queries, this will be close to linear.</p>\n', 'ViewCount': '319', 'Title': 'How to query and update ranges of arrays?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-06T05:14:47.383', 'LastEditDate': '2013-09-11T19:20:40.383', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10039', 'Tags': '<data-structures><trees>', 'CreationDate': '2013-09-09T07:08:53.333', 'FavoriteCount': '2', 'Id': '14228'}{'Body': u'<p>Suppose I have a connected graph with $n$ vertices and $n\u22121$ edges, that is in form of a tree. Now, I will add the number of vertices in the tree and uniformly randomly select a vertex. I break the graph at this selected vertex, deleting the vertex and the edges connected to it. Now, I again repeat the same thing at all of the left components (sub-trees) until I am left with one vertex for which the answer is inherently $1$. What will be the expectation of the sum obtained by adding the number of vertices recursively in such a problem?</p>\n\n<p>For example, I have 3 vertices, A, B and C in which A is connected to B as well as C, but B and C are not connected. Like, B--A--C. Now, I could select any one vertex out of three with probability 1/3, so I add 3. Now, if I had selected A, I would repeat this for B and C separately adding one for each case. Otherwise, selecting B or C, I would have repeated it on A--C or B--A respectively, adding 2 and selecting each node again with probability 1/2.</p>\n\n<p>I agree the problem is weakly written, here is a formulation suggested by <a href="http://cs.stackexchange.com/users/5167/karolis-juodel">Karolis Juodel\u0117</a>:\nI\'m looking for the expected value of $f(G) = \\left|V_G\\right| + \\sum f(G_i)$ where $G_i$ are components remaining after removing a random vertex of $G$.</p>\n', 'ViewCount': '61', 'Title': 'Which component sizes do we observe while randomly deconstructing a tree?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:37:06.417', 'LastEditDate': '2013-11-28T21:37:06.417', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8619', 'Tags': '<graphs><probability-theory><trees>', 'CreationDate': '2013-09-10T17:58:03.147', 'Id': '14252'}{'Body': '<p>Can anyone explain heavy light decomposition of trees or give a resource to read it from? I have already gone through <a href="http://ipsc.ksp.sk/2009/real/solutions/l.html" rel="nofollow">http://ipsc.ksp.sk/2009/real/solutions/l.html</a> which is the best i could find but still could not understand its working completely.</p>\n', 'ViewCount': '680', 'Title': 'Explanation of Heavy light decomposition', 'LastEditorUserId': '9694', 'LastActivityDate': '2014-04-09T01:32:25.857', 'LastEditDate': '2013-09-10T22:46:08.853', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9694', 'Tags': '<data-structures><trees>', 'CreationDate': '2013-09-10T21:16:59.930', 'FavoriteCount': '1', 'Id': '14259'}{'Body': "<p>I'm having trouble finding materials on what 'finger search' is, in the context of a red black tree.</p>\n\n<p>Even Wikipedia has a very short page about that, could you refer me or explain what kind of search is that.</p>\n", 'ViewCount': '119', 'Title': 'finger search on a red black tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T07:28:09.240', 'LastEditDate': '2013-09-16T07:28:09.240', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14292', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9851', 'Tags': '<terminology><data-structures><search-trees>', 'CreationDate': '2013-09-13T17:11:10.787', 'Id': '14291'}{'Body': '<p>If we have $n$ elements $s_1, \\dots, s_n$ and build a kind of treap (tree-heap) out of it. Each $s_k$ has a priority, which is an integer in $\\{ 1, 2, 3 \\dots, \\lceil \\log n \\rceil\\}$. Since the priorities will have duplicates, I just want the treap the verify that for each node $s_k$, all the nodes in its right and left subtrees have smaller priority. </p>\n\n<p>Is there a way to find the expected depth of this tree?</p>\n', 'ViewCount': '96', 'Title': 'Expected depth of modified kind of treap', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T09:06:30.243', 'LastEditDate': '2013-09-18T09:06:30.243', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10186', 'Tags': '<algorithm-analysis><data-structures><search-trees><heaps>', 'CreationDate': '2013-09-17T21:35:36.280', 'Id': '14391'}{'Body': '<p>Could somebody explain to me why the height of a  weight balanced  binary tree in $O(\\log n)$ in the worst case?</p>\n', 'ViewCount': '109', 'Title': 'Why the height of the weight balanced tree is logarithmic', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-09-23T06:26:36.727', 'LastEditDate': '2013-09-22T19:10:46.167', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10275', 'Tags': '<binary-trees><trees>', 'CreationDate': '2013-09-22T17:22:27.090', 'FavoriteCount': '1', 'Id': '14520'}{'Body': "<p>I can't figure out or find on the Internet what is the time complexity of B-tree in-order depth-first iteration. Can you help me out here, please?</p>\n\n<p>What is the characteristic operation we're using to estimate the running time here, is it a disk seek? Assuming that we have enough space to temporarily store the number of tree nodes equal to the height of the tree, it looks like we will only need to load each node once and keep it in memory while we're examining its children. Am I right?</p>\n", 'ViewCount': '53', 'Title': 'What is time complexity of in-order depth-first iteration over keys in a B-tree?', 'LastEditorUserId': '10378', 'LastActivityDate': '2013-09-28T18:19:24.870', 'LastEditDate': '2013-09-28T18:19:24.870', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10378', 'Tags': '<time-complexity><search-trees>', 'CreationDate': '2013-09-28T14:01:24.307', 'Id': '14654'}{'Body': "<p>I am stumped as to how to print the longest path from the root of a binary tree to a leaf, essentially traversing the height of the tree. I've got the following for finding the height of a binary tree:</p>\n\n<pre><code>if (root == null) {\n    return -1;\n}\n\nreturn 1 + (Math.max(heightOfTree(root.leftNode), heightOfTree(root.rightNode)));\n</code></pre>\n\n<p>This easily finds the height of the tree but doesn't lend itself to actually figuring out which nodes should be printed out. I could go about finding the nodes's value that is at the leaf, and then do a find for that particular node, but that seems inefficient. </p>\n\n<pre><code>        A\n      B   C\n    D  E F  G\n             H\n</code></pre>\n\n<p>For example, the height of this binary tree is 3, and I would ideally like to know the path to take, in this case it would be A, C, G, H. I know that I most likely need to keep an array for the path, but I just can't seem to find a solution that isn't terribly inefficient. </p>\n", 'ViewCount': '955', 'ClosedDate': '2013-10-28T20:58:32.103', 'Title': 'Printing The Longest Path from Root to Leaf in Binary Tree', 'LastActivityDate': '2013-10-02T20:46:24.137', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10399', 'Tags': '<binary-trees><recursion>', 'CreationDate': '2013-09-29T23:35:34.197', 'Id': '14687'}{'Body': "<p>(I've been stuck on this homework assignment for far too long)</p>\n\n<p>I need to find the number of independent sets in a tree. </p>\n\n<p>For example, say the set of nodes in a tree is {A, B, C, D, E}. B and C are children of A and D, E are children of B. This tree has 14 independent sets. </p>\n\n<p>I assume that the algorithm will be recursive and I think that I should make each level of a tree into a linked list, so B->C and D->E, but more than that I'm stumped. </p>\n\n<p>Would grealy appreciate help.</p>\n", 'ViewCount': '131', 'Title': 'Number of Independent Sets in a tree', 'LastActivityDate': '2013-10-03T05:46:54.597', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14770', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9743', 'Tags': '<algorithms><trees>', 'CreationDate': '2013-10-02T23:59:05.887', 'Id': '14768'}{'Body': '<p>I have the following problem:</p>\n\n<blockquote>\n  <p>Does inserting a node into a red-black tree and then immediately deleting it always result in the original tree? Prove that it does or give a counter-example if it does not. Does deleting a leaf node from a red-black tree, then reinserting the same node always result in the original tree? Prove that it does or give a counter-example if it does not.</p>\n</blockquote>\n\n<p>I have used several demos, but none of them have made much sense to answer this question. I havent been sure as to yes or no, I am still new to binary trees.</p>\n', 'ViewCount': '141', 'Title': 'Does inserting and immediately removing a node change a red-black tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T15:26:08.840', 'LastEditDate': '2013-10-04T07:00:36.170', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10497', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-10-04T05:02:22.753', 'Id': '14804'}{'Body': "<p>Does anybody know how would I approach calculating the maximum number of 1 child nodes (nodes that have exactly 1 child) in a binary tree with n nodes. Please don't give me the actual answer as this is one of the homework problems, I would like to solve it by myself, but I simply don't know where to start. Any help is apreciated.</p>\n", 'ViewCount': '150', 'Title': 'Number of 1 child nodes in a binary tree', 'LastEditorUserId': '10511', 'LastActivityDate': '2013-10-05T00:07:11.277', 'LastEditDate': '2013-10-05T00:00:32.300', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '14818', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<binary-trees>', 'CreationDate': '2013-10-04T23:53:38.153', 'Id': '14817'}{'Body': "<p>Given a tree $T$ with $n$ vertices, we want to find the number of triplets of vertices $(a,b,c)$ such $d(a,b) = d(b,c) = d(c,a)$ where $d$ is the distance function (length of the shortest path between two nodes).</p>\n\n<p>It's pretty easy to do it in $O(n^3)$ time. Is it possible to do it faster?<br>\nI think that on-line algorithm and pre-processing should help.</p>\n", 'ViewCount': '86', 'Title': 'Find equidistant triplets in a tree', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-14T02:33:40.063', 'LastEditDate': '2013-10-13T18:35:08.433', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10555', 'Tags': '<algorithms><graphs><dynamic-programming><trees>', 'CreationDate': '2013-10-13T18:28:25.567', 'FavoriteCount': '0', 'Id': '16047'}{'Body': '<p>We define a <em>regular tree language</em> as in the book <a href="http://tata.gforge.inria.fr/" rel="nofollow">TATA</a>: It is the set of trees accepted by a non-deterministic finite tree automaton (Chapter 1) or, equivalently, the set of trees generated by a regular tree grammar (Chapter 2). Both formalisms hold close resemblances to the well-known string analogues.</p>\n\n<blockquote>\n  <p>Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?</p>\n</blockquote>\n\n<p>Obviously there are tree languages such that the height of a tree is linear in its size; and in the book <a href="http://algo.inria.fr/flajolet/Publications/books.html" rel="nofollow">Analytic Combinatorics</a> it is shown e.g. that binary trees of size $n$ have average height $2\\sqrt{ \\pi n}$. If I understand Proposition VII.16 (p.537) of the mentioned book correctly, then there is a wide subset of regular tree languages that have average height of $\\Theta(\\sqrt{n})$, namely those in which the tree language is also a <em>simple variety of trees</em> fulfilling some extra conditions.</p>\n\n<p>So I was wondering whether there is a regular tree language showing a different average height or if there is a true dichotomy for regular tree languages.</p>\n', 'ViewCount': '316', 'Title': 'Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T08:11:24.593', 'LastEditDate': '2013-10-18T08:11:24.593', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '10734', 'Tags': '<formal-languages><regular-languages><combinatorics><trees><tree-grammars>', 'CreationDate': '2013-10-14T14:19:09.910', 'FavoriteCount': '4', 'Id': '16073'}{'Body': '<p>I want to flatten a binary tree into a linear array, and I wonder if there are specific algorithms to improve locality in the linearized representation (for instance, ensuring that all data from the left child of the root node appears before the data from the right child is an easy optimization.) What is the recommended approach to maintain high locality?</p>\n', 'ViewCount': '78', 'Title': 'Tree flattening with layout guarantees', 'LastActivityDate': '2013-10-16T14:15:15.257', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '16136', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10792', 'Tags': '<binary-trees><performance>', 'CreationDate': '2013-10-16T12:44:44.580', 'Id': '16134'}{'Body': '<p>For labelled trees there are the Pruefer numbers that uniquely identify them. Is there a similar numbering system for unlabelled trees?</p>\n', 'ViewCount': '52', 'Title': 'Numbering of unlabelled trees', 'LastActivityDate': '2013-10-20T05:16:23.427', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6437', 'Tags': '<trees>', 'CreationDate': '2013-10-19T07:46:01.023', 'Id': '16223'}{'Body': '<p>I\'m looking at the lecture review for one of my computer science classes and I\'m having trouble coming up with an answer. Could someone help me work through it?</p>\n\n<p>Background: </p>\n\n<p>Let the balance factor of a node be defined by $\\left| height(\\text{right sub tree}) - height(\\text{left sub tree}) \\right|$.</p>\n\n<p>Questions:</p>\n\n<ol>\n<li><strong>Give the balance factor for the nodes in slides 27-30 (given below)</strong></li>\n<li><strong>Instead of storing the heights of the nodes, can we store the balance factors of the nodes and update an AVL tree (for insertion and deletion) based on this information?</strong></li>\n</ol>\n\n<p>Here are the relevant slides: </p>\n\n<p><img src="http://i.stack.imgur.com/LusSW.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/wuUdi.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/47jDV.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/P8w2s.png" alt="enter image description here"></p>\n', 'ViewCount': '118', 'Title': 'Updating an AVL Tree Based On Balance Factors', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-21T19:44:13.303', 'LastEditDate': '2013-10-21T19:44:13.303', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<binary-trees><trees><search-trees>', 'CreationDate': '2013-10-21T19:14:25.870', 'Id': '16313'}{'Body': "<p>Given a tree $T$ and a sequence of nodes $S$, with the only constraint on $S$ being that it's done through some type of recursion - that is, a node can only appear in $S$ if all of its ancestors have already appeared, what's a good algorithm to determine if $S$ is a breadth first visit, a depth first visit, or neither?</p>\n\n<p>A brute force approach is to compute every breadth first and depth first sequences and see if any is identical to $S$.  Is there a better approach?</p>\n\n<p>What if we don't want a yes or no answer, but a measure of distance.  E.g. $breadth &lt; S &lt; R &lt; U &lt; depth$; what's a good algorithm to determine distance? (A brute force approach for this is just $max(length(longest{\\_}common{\\_}subsequence(S, breadth))/length(breadth))$ over every BFS - again, is there a better way to do this?)</p>\n", 'ViewCount': '167', 'Title': 'Algorithm to determine if recursion was breadth first or depth first', 'LastEditorUserId': '10925', 'LastActivityDate': '2014-02-24T22:45:29.007', 'LastEditDate': '2013-10-27T11:20:32.830', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<algorithms><trees><recursion><discrete-mathematics>', 'CreationDate': '2013-10-27T00:54:38.727', 'FavoriteCount': '1', 'Id': '16459'}{'Body': '<p>Why is it that Iterative-deepening A* is optimal, even without monotonicity? How can I be sure that the first goal reached is the optimal one?</p>\n', 'ViewCount': '282', 'Title': 'Why is Iterative-deepening A* optimal, even without monotonicity?', 'LastActivityDate': '2013-10-28T20:50:58.197', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '16514', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10575', 'Tags': '<search-algorithms><search-trees>', 'CreationDate': '2013-10-27T17:01:21.627', 'Id': '16477'}{'Body': '<p>Some priority queues, like the <a href="https://en.wikipedia.org/wiki/Leftist_tree" rel="nofollow">height-based leftist tree</a> (or <a href="http://www.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch8.html" rel="nofollow">here</a>) support merging in $\\mathcal O\\left(\\log n\\right)$ time.</p>\n\n<p>I am looking for a priority queue that merges in (expected|average|amortized|worst-case) <em>sub-linear</em> time, but also has the following properties:</p>\n\n<ul>\n<li>Elements are unique</li>\n<li><code>peek</code> and <code>pop</code> should work in (expected|average|amortized|worst-case) <em>sub-linear</em> time</li>\n</ul>\n\n<p>Is this impossible?</p>\n', 'ViewCount': '210', 'Title': 'Priority queue with unique elements and sublinear time merge?', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-04T02:12:44.287', 'LastEditDate': '2013-11-01T03:36:00.840', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><data-structures><trees><priority-queues>', 'CreationDate': '2013-11-01T03:30:02.627', 'FavoriteCount': '2', 'Id': '16611'}{'Body': '<p>I know how a BIT works. But I was wondering if a BIT can be used to find the minimum/maximum element in the complete range, or more specifically, to find the minimum (or maximum) value after all the update processes have been completed. Now, I know that this can very well be achieved using Segment Trees, but is it possible to do the same using a BIT?</p>\n\n<p>I know the obvious way of traversing the complete BIT and calculating the value at each index. I am looking for a more efficient/optimized way.</p>\n', 'ViewCount': '178', 'Title': 'Finding minimum/maximum value in a Binary Indexed Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T10:12:11.680', 'LastEditDate': '2013-11-02T10:12:11.680', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11119', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2013-11-01T14:37:26.980', 'FavoriteCount': '2', 'Id': '16620'}{'ViewCount': '150', 'Title': 'Artificial Intelligence: Condition for BFS being optimal', 'LastEditDate': '2013-11-18T19:12:31.383', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6998', 'FavoriteCount': '1', 'Body': '<p>It is said in the book <em>Artificial Intelligence: A Modern Approach</em> for finding a solution on a tree using BFS that: </p>\n\n<blockquote>\n  <p>breadth-first search is optimal if the path cost is a nondecreasing function of the\n  depth of the node. The most common such scenario is that all actions have the same cost.</p>\n</blockquote>\n\n<p>From that I understand that if the path cost is non decreasing function of depth, the BFS algorithm returns an optimal solution, i.e., <strong>the only condition is the cost function being nondecreasing</strong>. But I think the only way for BFS to be optimal is the scenario in which all the path costs are identical, therefore a node found in a certain level is necessarily the optimal solution, as, if they exist, the others are. Therefore I think for BFS to be optimal, cost function should be non decreasing <strong>AND</strong> the costs of nodes should be identical. However, the book says only one of the conditions (former one) makes BFS optimal.</p>\n\n<p>Is there a situation in which the costs are not identical, the cost function is nondecreasing and the solution returned by BFS is guaranteed to be optimal?</p>\n', 'Tags': '<optimization><artificial-intelligence><search-algorithms><search-trees><search-problem>', 'LastEditorUserId': '6998', 'LastActivityDate': '2013-11-18T19:12:31.383', 'CommentCount': '0', 'AcceptedAnswerId': '16780', 'CreationDate': '2013-11-06T01:16:28.697', 'Id': '16758'}{'Body': '<p>Half a decade ago I was sitting in a data structures class where the professor offered extra credit if anyone could traverse a tree without using recursion, a stack, queue, etc. (or any other similar data structures) and just a few pointers.  I came up with what I thought was an obvious answer to that question which was ultimately accepted by the professor.  I was sitting in a discrete math class with another professor in the same department--and he asserted that it was impossible to traverse a tree without recursion, a stack, queue, etc., and that my solution was invalid.</p>\n\n<p>So, is it possible, or impossible?  Why or why not?</p>\n\n<p>Edit:  To add some clarification, I implemented this on a binary tree which had three elements-- the data stored at each node and pointers to two children.  My solution could be extended to n-ary trees with only a few changes.</p>\n\n<p>My data structures teacher did not put any constraints against mutating the tree, and indeed I found out later that his own solution was to use the child pointers to point back up the tree on his way down.  My discrete math professor said any mutation of a tree means that it is no longer a tree according to the mathematical definition of a tree, his definition would also preclude any pointers to parents--which would match the case where I solved it above.</p>\n', 'ViewCount': '726', 'Title': 'Can a tree be traversed without recursion, stack, or queue, and just a handful of pointers?', 'LastEditorUserId': '11262', 'LastActivityDate': '2013-11-14T13:15:47.923', 'LastEditDate': '2013-11-09T16:24:18.440', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11262', 'Tags': '<algorithms><trees><recursion>', 'CreationDate': '2013-11-08T22:19:23.803', 'FavoriteCount': '1', 'Id': '16833'}{'Body': "<p>I'm given this problem:</p>\n\n<p>Consider the following closest-point heuristic for building an approximate traveling-salesman  tour. Begin with a trivial cycle consisting of a single arbitrarily chosen vertex. At each step, identify the vertex u that is not on the cycle but whose distance to any vertex on the cycle is minimum. Suppose that the vertex on the cycle that is nearest u is vertex v. Extend the cycle to include u by inserting u just after v. Repeat until all vertices are on the cycle. Prove that this heuristic returns a tour whose total cost is not more than twice the cost of an optimal tour. </p>\n\n<p>This is the same as Prim's algorithm.  Unless I'm missing something, this is not an approximate traveling salesman tour since the traveling salesman requires a Hamiltonian path where we don't revisit any nodes, but on many graphs this algorithm seems to require revisiting nodes to get back to the source node.  Am I wrong or is this problem unclearly worded?</p>\n", 'ViewCount': '120', 'Title': "Traveling Salesman's Tour Approx Algorithm: is this really a Hamiltonian Path?", 'LastActivityDate': '2013-11-19T10:58:35.200', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18152', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11474', 'Tags': '<traveling-salesman><spanning-trees><approximation-algorithms>', 'CreationDate': '2013-11-19T06:43:05.060', 'Id': '18147'}{'Body': '<p>Suppose we have a graph $H$, where each vertex represents a spanning tree of another graph $G$.</p>\n\n<p>We create an edge between 2 vertices in $H$ if $ST_1$ (spanning tree) contains exactly one edge not in $ST_2$ (and vice versa).</p>\n\n<p>How do we show that $H$ is connected?</p>\n', 'ViewCount': '60', 'Title': 'Showing that graph of spanning trees are connected', 'LastEditorUserId': '9863', 'LastActivityDate': '2013-11-25T14:57:33.637', 'LastEditDate': '2013-11-25T14:36:00.353', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11608', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-11-25T13:29:31.623', 'Id': '18325'}{'Body': "<p>I'm studying for my CS final and I can't seem to get the anywhere with one of the questions.</p>\n\n<p>This is the question:</p>\n\n<p>Prove that if a node in a BST has a successor, but has no right child, then its successor must be an ancestor. (We will consider only BSTs with distinct elements.)</p>\n\n<p>I know that a successor is the node that replaces the deleted node, and that we only need to worry about this case when the node being deleted has two children, but I can't seem to start this proof.</p>\n\n<p>Any help?</p>\n", 'ViewCount': '51', 'Title': 'BST Successor Proof', 'LastActivityDate': '2013-12-02T17:27:33.667', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<proof-techniques><binary-trees><binary-search>', 'CreationDate': '2013-12-01T22:36:10.517', 'FavoriteCount': '1', 'Id': '18512'}{'Body': "<p>Let $n$ be an integer, and let $\\mathbb{Z}$ denote the set of all integers.  Let $[a,b]$ denote the interval of integers $\\{a,a+1,a+2,\\dots,b\\}$.</p>\n\n<p>I am looking for a data structure to represent a map $f:[1,n] \\to \\mathbb{Z}$.  I want the data structure to support the following operations:</p>\n\n<ul>\n<li><p>$\\text{get}(i)$ should return $f(i)$.</p></li>\n<li><p>$\\text{set}([a,b],y)$ should update $f$ so that $f(a)=f(a+1)=\\cdots=f(b)=y$, i.e., update $f$ to a new map $f'$ such that $f'(i) = y$ for $i \\in [a,b]$ and $f'(i) = f(i)$ for $i \\notin [a,b]$.</p></li>\n<li><p>$\\text{stab}(i)$ should return the largest interval $[a,b]$ such that $i \\in [a,b]$ and $f$ is constant on $[a,b]$ (i.e., $f(a)=f(a+1)=\\cdots=f(b)$).</p></li>\n<li><p>$\\text{add}([a,b],\\delta)$ should update $f$ to a new map $f'$ such that $f'(i) = f(i) + \\delta$ for $i \\in [a,b]$ and $f'(i) = f(i)$ for $i \\notin [a,b]$.</p></li>\n</ul>\n\n<p>I want each of these operations to be efficient.  I would count $O(1)$ or $O(\\lg n)$ time as efficient, but $O(n)$ time is too slow.  It's OK if the running times are amortized running times.  Is there a data structure that simultaneously makes all of these operations efficient?</p>\n\n<p>(I've noticed a similar pattern come up in a several programming challenges.  This is a generalization that would suffice for all of those challenge problems.)</p>\n", 'ViewCount': '145', 'Title': 'Data structure for map on intervals', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-03T07:49:12.067', 'LastEditDate': '2013-12-02T20:33:03.120', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><data-structures><trees><intervals>', 'CreationDate': '2013-12-02T18:19:49.227', 'FavoriteCount': '1', 'Id': '18542'}{'Body': "<p>I'm quite stuck trying to answer this. The problem of finding the size of the maximum independent set in a tree using dynamic programming is well documented and many solutions are around.</p>\n\n<p>I've been trying to use a similar technique (ie. recursing through the childred and then the grandchildren of a node) to find the <strong>number</strong> of such sets but I have not been able to work it out.</p>\n\n<p>Any help?</p>\n", 'ViewCount': '76', 'Title': 'Finding number of maximum independent sets in tree, using dynamic programming', 'LastActivityDate': '2013-12-07T17:45:59.723', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11885', 'Tags': '<dynamic-programming><trees><sets>', 'CreationDate': '2013-12-06T20:33:13.333', 'Id': '18694'}{'Body': "<p>What is the difference between minimum spanning tree algorithm and a shortest path algorithm?</p>\n\n<p>In my data structures class we covered two minimum spanning tree algorithms (Prim's and Kruskal's) and one shortest path algorithm (Dijkstra's). </p>\n\n<p>Minimum spanning tree is a tree in a graph that spans all the vertices and total weight of a tree is minimal. Shortest path is quite obvious, it is a shortest path from one vertex to another. </p>\n\n<p>What I don't understand is since minimum spanning tree has a minimal total weight, wouldn't the paths in the tree be the shortest paths? Can anybody explain what I'm missing?</p>\n\n<p>Any help is appreciated.</p>\n", 'ViewCount': '530', 'Title': 'Minimum spanning tree vs Shortest path', 'LastActivityDate': '2013-12-10T10:12:43.997', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<shortest-path><spanning-trees>', 'CreationDate': '2013-12-09T22:57:57.720', 'Id': '18797'}{'Body': '<p>This problem is from the book <a href="http://cseweb.ucsd.edu/users/dasgupta/book/index.html" rel="nofollow">Algorithms, Chapter 5: Greedy algorithms</a>. In case of being closed as a duplication to that in <a href="http://stackoverflow.com/questions/13127446/minimum-spanning-tree-subgraph">Minimum Spanning tree subgraph</a>, I will first make a defense:</p>\n\n<ul>\n<li>The accepted solution at <a href="http://stackoverflow.com/questions/13127446/minimum-spanning-tree-subgraph">Minimum Spanning tree subgraph</a> <strong>is</strong> still in dispute.</li>\n<li>The solution given by <code>eh9</code> seems to be related with the Kruskal MST algorithm.</li>\n<li>I am seeking for a general (and easy) solution.</li>\n</ul>\n\n<p>The problem is as follows:</p>\n\n<blockquote>\n  <p>Let $T$ be an MST of graph $G$. Given a connected subgraph $H$ of $G$, show that $T \\cap H$ is contained in some MST of $H$.</p>\n</blockquote>\n\n<p>My partial trial is <em>by contradiction</em>:</p>\n\n<blockquote>\n  <p>Suppose that $T \\cap H$ is not contained in any MST of $H$. That is to say, for any MST of $H$ (denoted $MST_{H}$), there exists an edge $e$ such that $e \\in T \\cap H$, and however, $e \\notin MST_{H}$.<br>\n  Now we can add $e$ to $MST_{H}$ to get $MST_{H} + {e}$ which contains a cycle (denoted $C$). </p>\n  \n  <ul>\n  <li>Because $MST_{H}$ is a minimum spanning tree of $H$ and $e$ is not in $MST_{H}$, we have that every other edge $e\'$ than $e$ in the cycle $C$ has weight no greater than that of $e$ (i.e., $\\forall e\' \\in C, e\' \\neq e. w(e\') \\le w(e)$).</li>\n  <li>There exists at lease one edge (denoted $e\'\'$) in $C$ other than $e$ which is not in $T$. Otherwise, $T$ contains the cycle $C$. </li>\n  </ul>\n  \n  <p>Now we have $w(e\'\') \\le w(e)$ and $e \\in T \\land e\'\' \\notin T$, $\\ldots$</p>\n</blockquote>\n\n<p>As you see, I failed to continue with the above argument. Therefore, my problem here is:</p>\n\n<blockquote>\n  <ul>\n  <li>Is my argument by contradiction feasible so far? </li>\n  <li>And, how to draw the contradiction to complete the argument?</li>\n  </ul>\n</blockquote>\n', 'ViewCount': '178', 'Title': 'Minimum spanning tree and its connected subgraph', 'LastEditorUserId': '4911', 'LastActivityDate': '2013-12-12T23:34:15.087', 'LastEditDate': '2013-12-11T15:25:56.723', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2013-12-11T08:02:14.180', 'Id': '18867'}{'Body': '<p>Consider this tree:</p>\n\n<p><img src="http://i.stack.imgur.com/cMslZ.png" alt="Simple binary tree"></p>\n\n<p>If I traverse it using post-order, I\'d start at <em>B</em> (as it is the leftmost leaf) and that\'s where my misunderstanding begins. I know <em>B</em> is the first and <em>A</em> will be the last node in post order, as the rule is left-right-root. One of my university professors said the correct answer for the post-order traversal of a tree similar to the one above would be <strong><em>B</em>, <em>C</em>, <em>D</em>, <em>E</em>, <em>A</em></strong>, but in my understanding, it should be <strong><em>B</em>, <em>D</em>, <em>E</em>, <em>C</em>, <em>A</em></strong>.  </p>\n\n<p>Am I getting it wrong? Shouldn\'t I evaluate <em>(C,D),(C,E)</em> as a subtree and then go back to the parent tree?</p>\n', 'ViewCount': '40', 'Title': "Doesn't post-order traversal require subtrees to be evaluated separately?", 'LastEditorUserId': '12111', 'LastActivityDate': '2013-12-14T19:07:44.407', 'LastEditDate': '2013-12-14T19:07:44.407', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18988', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12111', 'Tags': '<data-structures><binary-trees><search-algorithms><trees><search-trees>', 'CreationDate': '2013-12-14T17:40:35.087', 'Id': '18987'}{'Body': "<p>For my homework I have a problem that I can't solve and it makes me wonder about 2 different MST:</p>\n\n<blockquote>\n  <p>Let $G=(V,E)$ be a graph that has a minimum spanning tree $T$.</p>\n  \n  <p>I want to find another minimum spanning tree $T'$ that has at least 1 different edge $e'$\n  such that the weight of $e'$ is differ from any weight of edges in $T$.</p>\n</blockquote>\n\n<p>If $T'$ doesn't exist I can claim that every 2 different MST must have the same weight for each edge. </p>\n\n<p>My intuition says that this claim is wrong but on the other hand I can't find example of $T'$ to contradict this claim.</p>\n", 'ViewCount': '72', 'Title': 'Find a diffrent minimal spanning tree for a graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-19T10:57:54.237', 'LastEditDate': '2013-12-19T10:57:54.237', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19116', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9292', 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-12-16T17:31:17.433', 'Id': '19049'}{'Body': '<p>This question was originally posted here: <a href="http://stackoverflow.com/q/20735339/2305618">http://stackoverflow.com/q/20735339/2305618</a></p>\n\n<p>I am surely not the first to have implemented code to perform the following graph transformation. But try as I might, I can\'t find a previous reference to it. </p>\n\n<p>The transformation arises when creating a single graph that simultaneously models hierarchical inclusion relationships and other pairwise relationships between nodes.</p>\n\n<p>The algorithm transforms a rooted directed tree DAG into an equivalent hierarchical network DAG. Equivalence in this sense - if the meaning of the tree structure is that parents \'consist of\' or \'contain\' their children the equivalent network structure would carry the same \'consisting of\' or \'containment\' information.</p>\n\n<p>The tree hierarchy is represented in the network as sub-networks and sub-sub-networks. The tree\'s exterior nodes are copied across and each interior node X is represented by the pair: X\' and X\'\'</p>\n\n<p>Does anyone know the name/reference of this transformation/ algorithm? :-)</p>\n\n<p>Illustration image of this transformation:\n<img src="http://davidpratten.com/wp-content/uploads/2013/12/example-algorithm.png" alt="Illustration image of this transformation"></p>\n\n<p>Thanks</p>\n\n<p>David</p>\n', 'ViewCount': '56', 'Title': "What is this algorithm? Create a tree's equivalent hierarchical network", 'LastEditorUserId': '12306', 'LastActivityDate': '2013-12-23T05:21:06.803', 'LastEditDate': '2013-12-23T05:21:06.803', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12306', 'Tags': '<algorithms><graph-theory><trees>', 'CreationDate': '2013-12-23T00:45:35.480', 'Id': '19200'}{'Body': '<p>Let G be a weighted undirected graph and e be an edge with maximum weight in G.Suppose there is a minimum weight spanning tree in G containing the edge e.Which of the following statements is always TRUE?</p>\n\n<p>1.There exists a cut in g having all edges if maximum weight</p>\n\n<p>2.There exists a cycle in G having all edges of maximum weight</p>\n\n<p>3.Edge e can not be contained in a cycle </p>\n\n<p>4.All edges in G have the same weight </p>\n\n<p>i think Option 4 and 1 is correct but which is always true .and what is the meaning of option 3.Can any body remove my confusion ??</p>\n', 'ViewCount': '46', 'Title': 'Satisfying condition to be in minimum spanning tree of an edge (maximum weight)', 'LastActivityDate': '2013-12-24T10:44:53.143', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19241', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12340', 'Tags': '<algorithms><graph-theory><trees><spanning-trees>', 'CreationDate': '2013-12-24T10:26:51.827', 'Id': '19239'}{'Body': "<p>Is there any example that anybody could come up  with that shows Prim's algorithm does not always give the correct result when it comes knowing the minimal spanning tree.</p>\n", 'ViewCount': '137', 'Title': "Minimal Spanning tree and Prim's Algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-05T17:28:24.357', 'LastEditDate': '2014-01-05T17:28:24.357', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '19309', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<algorithms><greedy-algorithms><spanning-trees>', 'CreationDate': '2013-12-26T17:49:25.153', 'Id': '19306'}{'Body': "<p>what is the reason for the correctness proof of Prim's Algorithm for the undirected case cannot carry over to the directed case?</p>\n\n<p>Is it because of after any number of steps, $S$ might not be in a sub tree of an MST since it depends upon the direction of the edge of the directed graph, unlike the undirected one?</p>\n", 'ViewCount': '111', 'ClosedDate': '2014-01-05T17:29:58.513', 'Title': "Proof of Correctness of Prim's algorithm", 'LastEditorUserId': '7269', 'LastActivityDate': '2013-12-31T16:22:53.543', 'LastEditDate': '2013-12-31T13:52:39.337', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<graph-theory><correctness-proof><greedy-algorithms><spanning-trees>', 'CreationDate': '2013-12-31T12:55:44.063', 'Id': '19405'}{'Body': '<p>Given a Bayesian Network DAG $G$, we can transform it into a junction tree $T_G$ by performing two steps: </p>\n\n<ol>\n<li>moralisation (connect variables that have the same child, drop directions)</li>\n<li>triangulation (fill-in edges) i.e chordal graphs. </li>\n</ol>\n\n<p>Are there known conditions/assumptions over $G$ under which for any junction tree $T_G$, $T_G$ will have tree width at most $k$? In other words, bounded treewidth for the triangulated graph of $G$? </p>\n', 'ViewCount': '47', 'ClosedDate': '2014-01-05T15:21:05.217', 'Title': 'How to go from a DAG model to bounded treewidth?', 'LastEditorUserId': '4598', 'LastActivityDate': '2014-01-03T00:36:05.477', 'LastEditDate': '2014-01-03T00:36:05.477', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graphs><trees>', 'CreationDate': '2014-01-03T00:15:21.217', 'Id': '19467'}{'Body': '<p>Here is how deletion in B-trees is described:</p>\n\n<blockquote>\n  <ol>\n  <li><p>If the key k is in node x and x is a leaf, delete the key k from x.</p></li>\n  <li><p>If the key k is in node x and x is an internal node, do the following.</p>\n  \n  <p>a) If the child y that precedes k in node x has at least t keys, then find the predecessor k0 of k in the sub-tree rooted at y. Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)</p>\n  \n  <p>b) If y has fewer than t keys, then, symmetrically, examine the child z that follows k in node x. If z has at least t keys, then find the successor k0 of k in the subtree rooted at z. Recursively delete k0, and replace k by k0 in x. (We can find k0 and delete it in a single downward pass.)</p>\n  \n  <p>c) Otherwise, if both y and z have only t-1 keys, merge k and all of z into y, so that x loses both k and the pointer to z, and y now contains 2t-1 keys. Then free z and recursively delete k from y.</p></li>\n  <li><p>If the key k is not present in internal node x, determine the root x.c(i) of the appropriate subtree that must contain k, if k is in the tree at all. If x.c(i) has only t-1 keys, execute step 3a or 3b as necessary to guarantee that we descend to a node containing at least t keys. Then finish by recursing on the appropriate child of x.</p></li>\n  </ol>\n</blockquote>\n\n<p>What is the actual difference between case 1 case 3? Both seem to be directing to a leaf node.</p>\n', 'ViewCount': '40', 'Title': 'Case distinction in B-tree deletion', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-08T17:04:46.533', 'LastEditDate': '2014-01-08T17:04:46.533', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11804', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2014-01-08T12:53:21.410', 'Id': '19580'}{'Body': '<p>Im learning the delete operation on <a href="http://www.cs.princeton.edu/~rs/talks/LLRB/08Dagstuhl/RedBlack.pdf" rel="nofollow">Left-leaning Red Black Tree</a> invented by Prof. Sedgewick. In delete operation, a node could be only deleted from a 3-node or a 4-node but 2-node. In order to ensure we dont end up at 2-node, we push the red link down when both the left and left of left of this node are black (if the cmp &lt; 0) by the code below</p>\n\n<pre><code>// Assuming that h is red and both h.left and h.left.left\n// are black, make h.left or one of its children red.\nprivate Node moveRedLeft(Node h) {\n    assert (h != null);\n    assert isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.left.left);\n\n    flipColors(h);\n    if (isRed(h.right.left)) { \n        h.right = rotateRight(h.right);\n        h = rotateLeft(h);\n    }\n    return h;\n}\n</code></pre>\n\n<p>The fact is before we invoke this function, there is not any check if this node is red. So, This must be one of the characters of LLRB. Actually the image below just show this.</p>\n\n<p><img src="http://i.stack.imgur.com/FazCz.png" alt="one possible llrb tree"></p>\n\n<p>But how to prove this?</p>\n', 'ViewCount': '35', 'Title': 'LLRB Tree How to prove if left and left of left node are black, then this node must be a red node?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-13T19:09:14.983', 'LastEditDate': '2014-01-13T19:09:14.983', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12804', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2014-01-13T16:07:25.153', 'Id': '19696'}{'Body': '<p>I am working on the following problem:</p>\n\n<blockquote>\n  <p>Suppose that $T$ is a spanning tree of a graph $G$, with an edge cost function $c$.  Let $T$ have the <em>cycle property</em> if for any edge $e\' \\not \\in T, c(e\') \\geq c(e)$ for all $e$ in the cycle generated by adding $e\'$ to $T$.  Let  $T$ have the <em>cut property</em> if for any edge $e \\in T$, $c(e) \\leq c(e\')$ for all $e\'$ in the cut defined by $e$.</p>\n  \n  <p>Show that the following three properties are equivalent </p>\n  \n  <ol>\n  <li>T has the cycle property, </li>\n  <li>T has the cut property, and </li>\n  <li>T is a minimum cost spanning tree.</li>\n  </ol>\n</blockquote>\n\n<p>I believe that to show that 3. implies 1., we suppose otherwise, and then show that this would give a cycle with an edge that can replace another edge in T and that is cheaper, whence we have a contradiction.  Similarly, I believe to show that 3. implies 2., we similarly suppose otherwise, and then show that this would give a cut with an edge that can replace another edge in T and that is cheaper, whence a contradiction.</p>\n\n<p>However, I am not sure how to prove the other implications needed for this problem.  My feeling is to somehow use a similar argument to what I listed, but "in reverse".</p>\n\n<p>Any help with this problem would be greatly appreciated.</p>\n', 'ViewCount': '96', 'Title': 'Spanning Tree - Equivalent Properties', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T11:47:57.600', 'LastEditDate': '2014-01-21T08:21:15.430', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12985', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2014-01-20T22:19:12.643', 'Id': '19855'}{'Body': '<p>In the accepted answer to my question <a href="http://cs.stackexchange.com/a/19998/13022">Data Structure For Closest Pair Problem</a>, I do not see why deletion works.</p>\n\n<p>Let\'s say (x, y) are the closest pair before the delete. If the node to be deleted is either x or y, then we would have to recalculate the closest pair, which would not satisfy the O(log n) requirement. The best solution I currently see is that each time a "new" closest pair occurs during an insertion, we link it to the previous closest pair. That is, instead of storing just the closest pair in the root node, we store a linked list of closest pairs. However, this seems like overkill. </p>\n\n<p>Is there a better way resp. why does the proposed solution work?</p>\n', 'ViewCount': '134', 'ClosedDate': '2014-02-02T11:24:13.863', 'Title': 'AVL Trees - Maintaining Closest Pair information on a Delete', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-01-28T12:17:10.023', 'LastEditDate': '2014-01-28T12:17:10.023', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8639', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2014-01-27T04:16:48.070', 'Id': '20005'}{'Body': '<p>Im trying to draw an annotated parse tree for <code>3*5+4n</code>, the text book shows the following:</p>\n\n<p><img src="http://i.stack.imgur.com/TilDt.png" alt="enter image description here"><br>\n<sup>[<em>Compilers - Principles, techniques and tools (Dragon Book) by Aho, p308</em>]</sup></p>\n\n<p>I have a few questions regarding this</p>\n\n<ol>\n<li><p>Why is <code>3*5+4</code> considered as a single string? Can\'t I draw a parse tree something like \nfor the same string ie:with operator at the node <img src="http://i.stack.imgur.com/PRd1R.jpg" alt="enter image description here"> </p></li>\n<li><p>What is the need for giving <code>T.VAL=3</code> and then giving another child <code>F.VAL=3</code>. (I understand that the integer attribute for digit needs to be supplied by the lexical analyzer)</p></li>\n</ol>\n', 'ViewCount': '226', 'ClosedDate': '2014-02-03T00:27:50.477', 'Title': 'Drawing Annotated Parse Tree for Syntax Directed Definition', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T11:40:12.120', 'LastEditDate': '2014-01-30T11:13:37.357', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<formal-grammars><compilers><parsing><syntax-trees>', 'CreationDate': '2014-01-30T08:37:50.427', 'Id': '20098'}{'Body': '<p>As per <a href="http://algs4.cs.princeton.edu/lectures/52Tries.pdf" rel="nofollow">Tries slides</a> (page 17) from Algorithm 4th edition book by Robert Sedgewick, the asymptotic expected runtime for an unsuccessful search in $R$-way tries miss is $O(\\log_R N)$. Can someone please explain how this number can be derived?</p>\n', 'ViewCount': '21', 'Title': 'Understanding expected time bound for unsuccessful search in R-way tries', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T16:21:49.280', 'LastEditDate': '2014-02-06T16:21:49.280', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21387', 'Score': '1', 'OwnerDisplayName': 'ManojGumber', 'PostTypeId': '1', 'Tags': '<data-structures><runtime-analysis><search-trees>', 'CreationDate': '2014-01-12T22:11:10.073', 'Id': '21386'}{'Body': '<p>Knowing the frequencies of each symbol, is it possible to determine the maximum height of the tree without applying the Huffman algorithm? Is there a formula that gives this tree height?</p>\n', 'ViewCount': '94', 'Title': 'Huffman tree and maximum depth', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-10T21:50:18.413', 'LastEditDate': '2014-02-10T21:50:18.413', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8767', 'Tags': '<trees><coding-theory>', 'CreationDate': '2014-02-06T18:16:44.847', 'FavoriteCount': '1', 'Id': '21394'}{'Body': '<p>Earlier this week a <a href="http://arxiv.org/pdf/1402.3036.pdf" rel="nofollow">paper</a> was released describing an algorithm for building optimal alphabetic ternary trees. The alphabetic property as described on <a href="http://en.wikipedia.org/wiki/Binary_search_tree#Optimal_binary_search_trees" rel="nofollow">Wikipedia</a> as </p>\n\n<blockquote>\n  <p>Alphabetic trees are Huffman trees with the additional constraint on\n  order, or, equivalently, search trees with the modification that all\n  elements are stored in the leaves. Faster algorithms exist for optimal\n  alphabetic binary trees (OABTs).</p>\n</blockquote>\n\n<p>From this, I understand that an alphabetic binary tree will produce shorter paths from root to element for elements that have been inserted into the tree more times than elements that haven\'t, and the alphabetic property would be described the same way for a ternary tree. </p>\n\n<p>I haven\'t been able to find a lot of discussion about applications for the alphabetic property outside of Huffman coding but it is not a requirement to implement the algorithm.  Are there any applications where the alphabetic property would be a requirement, and if not, are there any benefits to guaranteeing the alphabetic property that justifies increased implementation complexity?</p>\n', 'ViewCount': '49', 'Title': 'What are applications of alphabetic trees?', 'LastActivityDate': '2014-02-15T21:47:02.083', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14703', 'Tags': '<algorithms><data-structures><trees>', 'CreationDate': '2014-02-15T21:47:02.083', 'FavoriteCount': '1', 'Id': '21680'}{'Body': '<p>How can we prove a binary search tree with $n$ internal vertices has height $h = \\lceil \\log(n+1) \\rceil$? </p>\n', 'ViewCount': '31', 'ClosedDate': '2014-02-18T21:34:52.390', 'Title': 'Binary search tree with $n$ internal vertices', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T21:35:18.720', 'LastEditDate': '2014-02-18T21:35:18.720', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14815', 'Tags': '<data-structures><combinatorics><trees><search-trees>', 'CreationDate': '2014-02-18T17:27:13.633', 'Id': '21781'}{'Body': "<p>Suppose we were using a priority queue(PQ) to implement Prim's algorithm. My understanding is that initially the weight of all vertices is set to $\\infty$. The weight of the starting vertex is then set to 0. All of the vertices are then inserted into the PQ. </p>\n\n<p>1) Does that mean that we can insert the vertices in any order into the PQ? </p>\n\n<p>2) Given that we can insert the vertices in any order, suppose we have a graph with the<br>\n$\\quad$following vertices a, b and c and the following weights w(a,$\\,$b) = 1, w(a,$\\,$c ) = 2. Once we set a.key = 0 $\\quad$and then extract a from PQ, we have b.key = 1 and c.key = 2. Given the answer to (1) was yes,my<br>\n$\\quad$understanding would be that in a binary tree representation of the heap, b would now be the root and c<br>\n$\\quad$would be a child of b. However, depending on the order in which the a, b and<br>\n$\\quad$c were added to the heap, c could be either the left or right child of b, right?</p>\n\n<p>3) Suppose now that the graph has vertices a, b, c, d and edges (a, b), (a, c), (a, d). Suppose they were<br>\n$\\quad$inserted into the heap in the order a, b, c, d. The binary tree representation of the heap should then be:       </p>\n\n<p>$\\quad\\quad$ a is the root, left(a) = b, right(a) = c, left(b) = d    </p>\n\n<p>$\\quad$ So, that would mean that the parent-child relationships do not correspond to the parent-child<br>\n$\\quad$ relationships in the original graph and they don't have to, right? </p>\n", 'ViewCount': '98', 'Title': "Prim's Algorithm - Building the Priority Queue", 'LastEditorUserId': '8639', 'LastActivityDate': '2014-02-19T15:22:41.730', 'LastEditDate': '2014-02-19T15:22:41.730', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8639', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2014-02-19T05:32:02.400', 'FavoriteCount': '1', 'Id': '21801'}{'Body': '<p>I know that depth-first search can be used to produce a depth-first spanning tree, which classifies all edges as tree edges, forward edges, backward edges or cross edges. Are there any algorithms that make use of the depth-first spanning tree?</p>\n', 'ViewCount': '78', 'Title': 'Applications of Depth-First Spanning Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-20T15:01:48.333', 'LastEditDate': '2014-02-20T11:08:14.503', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14872', 'Tags': '<algorithms><graphs><graph-traversal><spanning-trees>', 'CreationDate': '2014-02-20T07:12:38.657', 'Id': '21839'}{'Body': '<p>Context-free grammars, as well as other types of grammars, can naturally\nassociate structure with the strings of the defined language, for\nexample tree structures in the case of context-free language.</p>\n\n<p>What kind of structural features can be thus described by regular grammars,\nand associated with the strings of the language.</p>\n\n<p>One answer is of course that it can associate a non-terminals with\neach prefix (or suffix) of the string. That sorts the prefixes (or\nsuffixes) into sets that may intersect, depending on the grammar.\nBut what else would you see?</p>\n\n<p>related question : <a href="http://cs.stackexchange.com/questions/21306">Why CFG can specify structure of sentence but Regular grammar cannot?</a></p>\n', 'ViewCount': '38', 'Title': 'What kind of structural features of strings can be described by regular grammars?', 'LastActivityDate': '2014-02-20T16:22:49.207', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars><syntax-trees>', 'CreationDate': '2014-02-20T16:22:49.207', 'Id': '21852'}{'ViewCount': '40', 'Title': 'the height of a tree given n nodes and a condition', 'LastEditDate': '2014-02-23T20:33:45.123', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12545', 'Body': '<p>I came across a question on which I got totally stuck :( a sort of homework question)</p>\n\n<p>A weight-balanced tree is a binary tree in which for each node. The number of nodes in the left sub tree is at least half and at most twice the number of nodes in the right sub tree. The maximum possible height (number of nodes on the path from the root to the farthest leaf) of such a tree on n nodes is best described by which of the following? </p>\n\n<pre><code>a) log_2 n  \nb) log_{4/3} n  \nc) log_3 {n} \nd) log_{3/2} n\n</code></pre>\n\n<p>I cant imagine to solve this one. Intuitive based answer is most welcome.</p>\n', 'ClosedDate': '2014-02-23T20:33:23.810', 'Tags': '<combinatorics><trees><discrete-mathematics>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-23T20:33:45.123', 'CommentCount': '6', 'AcceptedAnswerId': '21943', 'CreationDate': '2014-02-23T13:32:38.407', 'Id': '21942'}{'Body': '<p>If we were to intuitively construct a lower bound for searching an element in a list $A$ containing $n$ integers, it would be in $\\Omega(n)$.</p>\n\n<p>But with the decision tree model, the number of leafs is $n$, so we conclude that the lower bound is $\\Omega(\\log{n})$.</p>\n\n<p>This is the same as finding the maximum element in a list. Intuitively, it is in $\\Omega(n)$, but with the decision tree model it is $\\Omega(\\log{n})$.</p>\n\n<p>Can someone help me understand this discrepancy ?</p>\n\n<p>Thank you in advance.</p>\n', 'ViewCount': '17', 'Title': 'Doubt in the correctness of decision tree models for constructing a lower bound', 'LastActivityDate': '2014-02-27T19:13:00.927', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22104', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<algorithms><search-algorithms><decision-problem><trees><lower-bounds>', 'CreationDate': '2014-02-27T17:39:15.747', 'Id': '22099'}{'Body': u'<p>In the words of (<a href="http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf" rel="nofollow">http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf</a>, section 17.2), "Each $f(x)$ can be interpreted as de\ufb01ning a hyperplane in $R^n$. Thus, tracing a path through the tree computes the intersection of the half-planes de\ufb01ned by the nodes touched by the path."</p>\n\n<p>I fail to visualize how path tracing is done? I would be glad to see it explained through the presentation of the path in a 2-dimensional space.</p>\n\n<p>I do understand that $x_1,x_2,...,x_n$ is a point in the $R^n$ dimensional space. But I don\'t get how Figure 17.1 in (<a href="http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf" rel="nofollow">http://www.cs.utah.edu/~suresh/5962/lectures/17.pdf</a>) helped in proving the lower bounds of Element Uniqueness as $\\Omega(n\\log n)$. I also don\'t get the implication of $\\#F$ being connected components; why can\'t they simply be called solutions?</p>\n\n<p>Unfortunately, reading online resources did not help me much understand the aforementioned concepts.</p>\n\n<p>Thank you in advance.</p>\n', 'ViewCount': '34', 'Title': 'Help in geometrically understanding "Linear Decision Trees"', 'LastEditorUserId': '15072', 'LastActivityDate': '2014-02-27T22:05:37.933', 'LastEditDate': '2014-02-27T19:22:01.350', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22113', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<algorithms><search-trees><lower-bounds>', 'CreationDate': '2014-02-27T19:09:05.800', 'Id': '22102'}{'Body': '<p>I built a set of samples from an imbalanced dataset with two classes through the undersampling technique. Now, from that set of decision trees I would like to choose one representative tree. Is there any algorthm to do that?</p>\n', 'ViewCount': '9', 'Title': 'Representative tree from sets of decision trees', 'LastActivityDate': '2014-03-07T17:28:30.820', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15398', 'Tags': '<trees><sampling>', 'CreationDate': '2014-03-07T17:28:30.820', 'FavoriteCount': '1', 'Id': '22376'}{'Body': '<p>I want to find a minimal vertex in a tree from which we can traverse some edges exactly twice then come back to that vertex then do it with the rest of edges. By minimal, I mean that the difference of numbers of two subsets of edges have to be minimum.</p>\n', 'ViewCount': '84', 'ClosedDate': '2014-03-12T13:16:04.857', 'Title': 'Edge traversals of trees', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-14T00:52:01.190', 'LastEditDate': '2014-03-10T07:13:30.620', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12820', 'Tags': '<graph-theory><trees><graph-traversal>', 'CreationDate': '2014-03-09T09:43:04.420', 'Id': '22421'}{'Body': '<p>Consider the following Huffman trees:<br>\n<img src="http://i.stack.imgur.com/Q3bzR.png" alt="enter image description here"></p>\n\n<p>I was asked if those trees can have the same corpus. My answer was no, based on these calculations:  </p>\n\n<p>For the right tree:<br>\n$a_1 \\le a_2$<br>\n$a_1 + a_2 \\le a_5$<br>\n$a_3 \\le a_4$<br>\n$a_1 + a_2 + a_5 \\le a_3 + a_4$</p>\n\n<p>For the left tree:<br>\n$a_1 \\le a_2$<br>\n$a_3 \\le a_4$<br>\n$a_1 + a_2 + a_3 + a_4 \\le a_5$  </p>\n\n<p>Adding the last equations from each tree we have that:<br>\n$2a_1 + 2a_2 \\le 0$ Which is a contradiction because frequency cannot be negative.</p>\n\n<p>Nevertheless, I understood that there is a possibility that the two trees would have the same corpus. For instance, consider $1,1,1,2,3$.</p>\n\n<p>So, where do my calculations go wrong?</p>\n', 'ViewCount': '18', 'Title': 'Do the two huffman trees have the same corpus?', 'LastEditorUserId': '12859', 'LastActivityDate': '2014-03-11T02:11:18.050', 'LastEditDate': '2014-03-11T02:11:18.050', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22463', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15485', 'Tags': '<data-structures><trees><information-theory><data-compression>', 'CreationDate': '2014-03-10T10:19:44.723', 'Id': '22459'}{'ViewCount': '161', 'Title': 'What is the expected number of nodes at depth d of a tree after i random insertions', 'LastEditDate': '2014-03-14T09:33:19.310', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2825', 'FavoriteCount': '0', 'Body': "<p>Suppose one wanted to build a tree at random.  Let the first insertion at step $i = 1$ be the root node.  From here, nodes are inserted into the tree at random one at a time.  How would one go about calculating the expected number of nodes $E(d)$ at depth $d$ after $i$ insertions?</p>\n\n<p>For example, At $i = 1$, it's just the root node, so $E(0) = 1$ and all other depths will have zero nodes.  At $i = 2$, $E(0) = 1$ and $E(1) = 1$ as the inserted node has to be at depth 1 from the root.  At $i = 3$, the next node may either be attached to the root node or the existing node at depth one, so the tree may either look like:</p>\n\n<p><code>\n    *\n   / \\\n  *   *\n</code></p>\n\n<p>Or:</p>\n\n<p><code>\n     *\n    /\n   *\n  /\n *\n</code></p>\n\n<p>Depending on what happend at $i = 3$, at $i = 4$ there's either a $2/3$ chance of the new node attaching at depth 2 and $1/3$ attaching at depth 1, or an even $1/3$ probability of the new node attaching at the root, the node at depth 1 or the node at depth 2.  Keeping random insertion in mind (not a binary or balanced tree in any way), how would one go about calculating the expected number of nodes at depth $d$ after $i$ insertions? </p>\n", 'Tags': '<data-structures><trees><average-case>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-14T09:33:19.310', 'CommentCount': '0', 'AcceptedAnswerId': '22583', 'CreationDate': '2014-03-13T11:50:12.127', 'Id': '22580'}{'Body': '<p>Let $T = (V, E)$ be a tree with a designated root $r \\in V$. The fact that the tree is rooted allows us to speak of "subtrees of $T$ rooted at some node $x \\in V$". Let\'s say we have a (not necessarily injective) function $c: V \\rightarrow \\mathbb{N}$ that assigns a color to every node. </p>\n\n<p>We want to find for every node $x \\in V$ the number of distinct colors in the subtree rooted at $x$. So if $A(x)$ is the set of children of $x$, we want to find for every node $x$, the cardinality of the set </p>\n\n<p>$S(x) = \\bigcup_{y\\in A(x)} S(y) \\cup \\{c(x)\\}$</p>\n\n<p>There is a rather simple algorithm that solves this problem offline in $O(n \\log^2 n)$:</p>\n\n<ul>\n<li>Process the nodes in depth-first order</li>\n<li>Represent the sets $S(x)$ as a persistent, self-balancing binary search trees</li>\n<li>For every node $x$, let $y \\in A(x)$ be the child of $x$ that maximizes $|S(y)|$.  Now we just merge for every other child $z \\in A(x) \\setminus {y}$ the set $S(z)$ into the set $S(y)$ via insertion. We also insert $c(x)$ and now have $S(x)$ as a binary search tree and can give the answer for node $x$</li>\n</ul>\n\n<p>We can even avoid the persistent trees by mutating the subresult for the heaviest child instead of creating a new set.</p>\n\n<p>The typical argument I have seen to justify the bound is the following:</p>\n\n<blockquote>\n  <p>A "move" consist of taking an element from a set and inserting it in another set.\n  Let\'s prove that there\'s at most $O(n \\log n)$ moves, each move can be done in $O(\\log n)$, the total complexity is $O(n \\log^2 n)$.</p>\n  \n  <p>When you are merging two sets you move all elements from smaller set (assume its size is $k$) to the bigger one, so every element in the smaller set now is in a set with at least size $2k$. In other words every element that has been moved $t$ times is in a set with at least size $2^t$, thus every element will be moved at most $O(\\log n)$ and we have $n$ elements so in total there will be at most $O(n \\log n)$ move operations.</p>\n</blockquote>\n\n<p>(Quote from a <a href="http://codeforces.com/blog/entry/10696" rel="nofollow">Codeforces comment</a>).</p>\n\n<p>While this is a beautiful argument, it\'s not <em>quite</em> correct, because usually we remove duplicates, so sets don\'t in fact grow exponentially (for example if every node has the same color). </p>\n\n<p>I am convinced that the bound holds, because I can prove it using structural induction. What I want to know is the following:</p>\n\n<ul>\n<li>Is there a way to prove the $O(n \\log^2 n)$ bound using an argument similar to the above, by bounding the number of "moves" of the color of a node? In other words, can the proof be "fixed" easily?</li>\n<li>The argument from above would also hold in DAGs, not only in trees. However it seems unlikely that we could achieve a runtime better than $O(n \\cdot m)$ to solve this problem in a DAG, so I guess there is no fix for the proof idea in this case. Am I right? Is there a good intuition for that?</li>\n</ul>\n', 'ViewCount': '36', 'Title': 'Merge-by-weight to solve reachability problems in trees and DAGs', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-18T06:54:34.033', 'LastEditDate': '2014-03-18T06:54:34.033', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22744', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13167', 'Tags': '<graphs><trees><complexity-proof>', 'CreationDate': '2014-03-17T22:31:30.940', 'Id': '22725'}{'Body': '<p>I have to solve this problem: We have weighted $n$-node undirected graph $G = (V,E)$ and a positive integer $k$. We can reach all vertices from vertex 1 (the root). We need to find the weight of minimal spanning tree in which the degree of vertex 1 is at most $k$ (we don\'t care about other vertices\' degrees). We can assume that such a tree exists.</p>\n\n<p>Can someone give an idea how to approach the solution?</p>\n\n<p>What I\'ve already tried:</p>\n\n<p>1) I know how to find essential edges from vertex 1. We can use dfs and start from a random edge of vertex 1. When we return to vertex 1 we can check if this edge (another vertex 1 edge) has lower weight than the previous one. If yes, than the previous one is not essential.</p>\n\n<p>2) After that I wanted to use Kruskal\'s algorithm (adding in the beginning of the algorithm all essential edges). But the problem is that sometimes we should not take an edge with minimal weight to construct the required tree. </p>\n\n<p>For example: 9-node undirected graph, $k = 3$</p>\n\n<pre><code>(vertex1 vertex2 weight)\n1 2 1\n2 3 5\n3 4 6\n4 5 7\n5 1 1\n1 6 1\n6 7 8\n7 8 9\n8 9 10\n9 1 2\n</code></pre>\n\n<p>So essentials will be (1,2) and (1, 6) (or (1, 5) and (1,6)). Kruskal will take (1,5) (or (1,2)) anyway. And the weight will be 41, but the correct answer is 39.\nSo I don\'t know how to use Kruskal\'s algorithm here. </p>\n\n<p>(The same example visualized, vertex 1 = vertex A)</p>\n\n<p><img src="http://i.stack.imgur.com/ud2Xc.png" alt="The same example visualized"></p>\n\n<p>I thought that we may construct a minimal spanning tree without constraints and after that try to transform it to the required one, but I don\'t know how to do this (how to transform without brute force).</p>\n', 'ViewCount': '146', 'Title': 'Minimal spanning tree with degree constraint', 'LastEditorUserId': '15839', 'LastActivityDate': '2014-03-19T20:17:49.750', 'LastEditDate': '2014-03-19T11:20:15.890', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15839', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2014-03-18T21:45:52.923', 'FavoriteCount': '2', 'Id': '22775'}{'Body': "<p>For a binary tree we define horizontal distance as follows:</p>\n\n<pre><code>    Horizontal distance(hd) of root = 0\n    If you go left then hd = hd(of its parent)-1, and \n    if you go right then hd = hd(of its parent)+1.\n</code></pre>\n\n<p>The bottom view of a tree then consists of all the nodes of the tree, where there is no node with the same <code>hd</code> and a greater level. (There may be multiple such nodes for a given value of <code>hd</code>. In this case all of them belong to the bottom view.) I'm looking for an algorithm that outputs the bottom view of a tree.</p>\n\n<hr>\n\n<p>Examples:</p>\n\n<p>Suppose the binary tree is:</p>\n\n<pre><code>         1\n        /  \\\n       2    3\n      / \\  / \\\n     4   5 6  7\n            \\\n             8\n</code></pre>\n\n<p>Bottom view of the tree is: 4 2 5 6 8 7</p>\n\n<pre><code>    Ok so for the first example,\n    Horizontal distance of node with value 1: 0, level = 1\n    Horizontal distance of node with value 2: 0 - 1 = -1, level = 2\n    Horizontal distance of node with value 3: 0 + 1 = 1, level = 2\n    Horizontal distance of node with value 4: -1 - 1 = -2, level = 3\n    Horizontal distance of node with value 5: -1 + 1 = 0, level = 3\n    Horizontal distance of node with value 6: 1 - 1 = 0, level = 3\n    Horizontal distance of node with value 7: 1 + 1 = 2, level = 3\n    Horizontal distance of node with value 8: 0 + 1 = 1, level = 4\n\n    So for each vertical line that is for hd=0, print those nodes which appear in the last level of that line.\n    So for hd = -2, print 4\n    for hd = -1, print 2\n    for hd = 0, print 5 and 6 because they both appear in the last level of that vertical line\n    for hd = 1, print 8\n    for hd = 2, print 7\n</code></pre>\n\n<p>One more example for reference :</p>\n\n<pre><code>         1\n      /     \\\n    2         3\n   / \\       / \\\n  4   5     6     7 \n / \\ / \\   / \\    / \\\n8  9 10 11 12 13 14 15     \n</code></pre>\n\n<p>So the output for this will be :\n8 4 9 10 12 5 6 11 13 14 7 15</p>\n\n<pre><code>Similarly for this example\nhd of node with value 1: 0, , level = 1\nhd of node with value 2: -1, level = 2\nhd of node with value 3: 1, level = 2\nhd of node with value 4: -2, level = 3\nhd of node with value 5: 0, , level = 3\nhd of node with value 6: 0, level = 3\nhd of node with value 7: 2, level = 3\nhd of node with value 8: -3, level = 4\nhd of node with value 9: -1, level = 4\nhd of node with value 10: -1, level = 4\nhd of node with value 11: 1, level = 4\nhd of node with value 12: -1, level = 4\nhd of node with value 13: 1, level = 4\nhd of node with value 14: 1, level = 4\nhd of node with value 15: 3, level = 4\n\nSo, the output will be:\nhd = -3, print 8\nhd = -2, print 4\nhd = -1, print 9 10 12\nhd = 0, print 5 6\nhd = 1, print 11 13 14\nhd = 2, print 7\nhd = 3, print 15 \n\nSo the ouput will be:\n8 4 9 10 12 5 6 11 13 14 7 15\n</code></pre>\n\n<hr>\n\n<p>I already know a method in which I can do it using a lot of extra space (a map, and a 1-D array for storing the level of the last element in that vertical line) and with time complexity of $O(N \\log N)$.\nAnd this is the implementation of this method:</p>\n\n<pre><code>void printBottom(Node *node, int level, int hd, int min, map&lt; int, vector&lt;int&gt; &gt;&amp; visited, int lev[], int l)\n{\n     if(node == NULL)\n             return;\n     if(level == 1){\n              if(lev[hd-min] == 0 || lev[hd-min] == l){\n                      lev[hd-min] = l;\n                      visited[hd-min].push_back(node-&gt;data);\n              }\n     }\n     else if(level &gt; 1)\n     {\n          printBottom(node-&gt;left, level-1, hd-1, min, visited, lev, l);\n          printBottom(node-&gt;right, level-1, hd+1, min, visited, lev, l);\n     }\n}\n\n\nint main()\n{\n    find the minimum and maximum values for hd via DFS\n\n    int lev[max-min+1]; //lev[hd] contains the maximum level for which we have found nodes with this value of hd; initialized with 0's\n\n    map &lt; int, vector&lt;int&gt; &gt; visited; //the nodes in the bottom view\n\n    int h = height(root);\n\n    for (int i=h; i&gt;0; i--){\n        printBottom(root, i, 0, min, visited, lev, i);\n    }\n\n    output visited\n}\n</code></pre>\n\n<p>I am seeking help to do this in more optimized way, which used less space or time. Is there any other efficient method for this problem?</p>\n", 'ViewCount': '279', 'Title': 'Print bottom view of a binary tree', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-21T11:07:00.120', 'LastEditDate': '2014-03-20T11:18:18.890', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22899', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15862', 'Tags': '<algorithms><binary-trees>', 'CreationDate': '2014-03-19T10:10:45.850', 'Id': '22801'}{'Body': u"<p>This is a Discrete Math/Combinatorics Question from my hw\u2026but I don't really understand the question.</p>\n\n<blockquote>\n  <p>Find largest chromatic number of a full binary tree given the following depths: (Check all that apply)</p>\n  \n  <p>T2 T3 T7 T12 T200</p>\n</blockquote>\n\n<p>I understand that the chromatic number refers to the minimum color that you can color a graph or tree with the adjacent nodes or vertices being different colors.</p>\n\n<p>So knowing this fact... I'm sure that the chromatic number for all full binary trees should be 2 since you can use two different color nodes to completely color the tree? But they want me to find the largest chromatic number. I'm just confused.</p>\n", 'ViewCount': '94', 'ClosedDate': '2014-04-01T22:00:40.957', 'Title': 'Find largest chromatic number of a full binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T05:10:33.807', 'LastEditDate': '2014-03-21T21:11:42.240', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'Ace', 'PostTypeId': '1', 'Tags': '<graph-theory><binary-trees><trees><discrete-mathematics><colorings>', 'CreationDate': '2014-03-21T03:15:36.973', 'Id': '22906'}{'Body': '<p>I was trying to understand the concept of Max-Heap. And to my understanding its a complete binary tree and each parent has a value greater than its children.The example I was going though had the following array which it said was a Max-Heap.</p>\n\n<pre><code>BookArray [] = {45,10,11,3,2,7,9,1,0}\n</code></pre>\n\n<p>I then decided to shuffle the elements (so they are no longer in binary heap) and got this.</p>\n\n<pre><code>Shuffled[] = {11,1,0,7,9,3,2,10,45}\n</code></pre>\n\n<p>I then decided to write a program that would sort the elements in the array in Min-Heap\nso I got this array</p>\n\n<pre><code>Sorted[] = {45,11,3,10,7,0,2,1,9}\n</code></pre>\n\n<p>My question is if my sorted array is also a valid max-heap ? since my array does not match the bookArray</p>\n', 'ViewCount': '34', 'Title': 'Is this a proper Max Heap Data Structure', 'LastEditorUserId': '2421', 'LastActivityDate': '2014-03-22T19:19:23.603', 'LastEditDate': '2014-03-22T18:30:06.260', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22943', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2421', 'Tags': '<data-structures><binary-trees><heaps>', 'CreationDate': '2014-03-22T17:50:21.793', 'Id': '22941'}{'Body': '<p>I was wondering if anyone had any good references or book recommendations that cover abstract syntax trees (ASTs). Specifically, I am interested in the abstract syntax trees of different evaluation strategies (call by value vs. call by name) of the pure lambda calculus. I would like to be able to draw the AST of some pure lambda calculus expression such as\n$$and \\, true \\, false = (\\lambda a. \\lambda b. a \\, b \\, (\\lambda t. \\lambda f. f))(\\lambda t. \\lambda f. t)(\\lambda t. \\lambda f. f).$$</p>\n\n<p>I would like to know if/how evaluation strategies affect the structure of ASTs, or how order of operation is reflected in the AST of an expression. This seems trivial for any pure lambda calculus interpreter; so perhaps there is some AST generator out there somewhere? I did some searching on Google but found nothing.</p>\n\n<p>I think if I could just get some practice with the AST representation of some non-trivial functions in any language, I will be okay.</p>\n', 'ViewCount': '27', 'Title': 'Abstract Syntax Tree of Pure Lambda Calculus', 'LastActivityDate': '2014-03-23T05:29:48.010', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22958', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<lambda-calculus><syntax-trees>', 'CreationDate': '2014-03-22T22:44:40.753', 'Id': '22949'}{'Body': '<p>I am having trouble in understanding <a href="http://en.wikipedia.org/wiki/Order_statistic_tree" rel="nofollow">order-statistics tree</a> .   </p>\n\n<p><strong>Definition :</strong><br>\nEvery node in tree stores the number of descendants of itself .<br>\nCan you please explain the Algorithm or pseudocode how to <strong>Insert</strong> and <strong>Delete</strong> a node in the tree <strong>when tree is to be balanced</strong> .  </p>\n\n<p>Basically i want to find the rank of an element in the tree in <strong>O(log N)</strong> time complexity and nodes can be inserted and deleted in between querries .  </p>\n\n<p>P.S. I am able to understand the <strong>rank(x)</strong> operation .</p>\n', 'ViewCount': '36', 'Title': 'insert and delete in order statistic tree', 'LastEditorUserId': '635', 'LastActivityDate': '2014-03-27T03:22:10.707', 'LastEditDate': '2014-03-27T03:22:10.707', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '16107', 'Tags': '<algorithms><data-structures><binary-trees>', 'CreationDate': '2014-03-26T13:08:12.103', 'Id': '23073'}{'Body': "<p>The question is as follows:\nTrue or False: For every non-directed connected non-weighted graph and for every spanning tree T of the graph there exists a vertex v such that T is a DFS tree with the root v.</p>\n\n<p>What about if instead of DFS I used BFS?</p>\n\n<p>I have no clue where to begin with this one. I feel like I'm overlooking some basic characteristic of the algorithm or the tree that it produces. Any help would be appreciated!</p>\n", 'ViewCount': '28', 'Title': 'Question about spanning trees and creating them through BFS and/or DFS algorithms', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-26T23:45:56.843', 'LastEditDate': '2014-03-26T23:45:56.843', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15977', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2014-03-26T22:08:28.540', 'FavoriteCount': '2', 'Id': '23101'}{'ViewCount': '76', 'Title': 'Why should leaf nodes in a red-black tree be black?', 'LastEditDate': '2014-03-27T15:03:50.240', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16188', 'FavoriteCount': '1', 'Body': u'<p>From the property of Red-Black Trees we know that: </p>\n\n<ul>\n<li>All leaves (NIL) are black. (All leaves are same color as the root.)(Comren et al "Introduction to Algorithms")</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/hz7wf.png" alt="An example of a red\u2013black tree. From Wikipedia"></p>\n\n<p>But what is the reason that we should enforce them as Black, even though they\'re NILL\'s? </p>\n', 'Tags': '<terminology><data-structures><search-trees><dictionaries>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T05:15:31.620', 'CommentCount': '1', 'AcceptedAnswerId': '23123', 'CreationDate': '2014-03-27T10:13:14.353', 'Id': '23119'}{'Body': "<p>If given that all edges in a graph $G$ are of equal weight $c$, can one use breadth-first search (BFS) in order to produce a minimal spanning tree in <strong>linear time</strong>?</p>\n\n<p>Intuitively this sounds correct, as BFS does not visit a node twice, and it only traverses from vertex $v$ to vertex $u$ iff it hasn't visited $u$ before, such that there aren't going to be any cycles, and if $G$ is connected it will eventually visit all nodes. Since the weight of all edges is equal, it doesn't matter which edges the BFS chose.</p>\n\n<p>Does my reasoning make any sense?</p>\n", 'ViewCount': '318', 'Title': 'If all edges are of equal weight, can one use BFS to obtain a minimal spanning tree?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-29T19:58:59.877', 'LastEditDate': '2014-03-29T19:58:59.877', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23181', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2014-03-28T13:34:40.343', 'Id': '23179'}{'Body': '<p>I\'m studying for my finals and I can across this statement.</p>\n\n<p>"For a fixed set of (unique) keys, any binary search tree containing those keys can\nbe converted to any other BST on the same set of keys via a sequence of left- and/or right-\nrotations."</p>\n\n<p>I\'m interested in a proof. Does anyone know any references?</p>\n', 'ViewCount': '78', 'Title': 'Unique keys in a binary search tree', 'LastActivityDate': '2014-04-10T16:49:59.190', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15826', 'Tags': '<algorithms><algorithm-analysis><binary-trees>', 'CreationDate': '2014-04-06T18:43:38.257', 'Id': '23481'}{'ViewCount': '38', 'Title': 'What is the common terminology to refer to the nth ancestor of a tree root?', 'LastEditDate': '2014-04-07T23:34:03.630', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'xtian', 'PostTypeId': '1', 'OwnerUserId': '16569', 'Body': '<p>Reading the Wikipedia article for common terminology for tree <a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29" rel="nofollow">(data structure)</a> there are several near references, but I don\'t read a formal declaration for how to refer to a specific generation of a tree\'s subtrees. </p>\n\n<p>For example, </p>\n\n<blockquote>\n  <h3>Definition</h3>\n  \n  <p>As a data type, a tree has a value and children, and <strong>the children are \n  themselves trees</strong>;  [...] Due to the use of references to\n  trees in the linked tree data structure, trees are often discussed\n  implicitly assuming that they are being represented <strong>by references to\n  the root node</strong>, as this is often how they are actually implemented.</p>\n</blockquote>\n\n<p>And also,</p>\n\n<blockquote>\n  <h3>Terminology.</h3>\n  \n  <p>"The <strong>height of a node is the length of the longest downward path to a\n  leaf from that node.</strong> The height of the root is the height of the\n  tree. [...] <strong>The root node has depth zero</strong>..."</p>\n</blockquote>\n\n<p>The former implies subtree n could be refered to as the nth decendant of root or the nth tree. Can I be sure subtree only refers to decendants and not other branches at the same distance from root?</p>\n\n<p>The latter refers to the height counting from the root (0). Again, height sounds uncommon to me. As in, <em>"Please refer to the nodes at height 4 to see..."</em> Since a tree is commonly displayed from the root branching downward, I\'m predisposed to bias against the term <em>height</em> versus my preferred notion of <em>depth</em>. </p>\n', 'Tags': '<graph-theory><terminology><trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T23:34:03.630', 'CommentCount': '4', 'AcceptedAnswerId': '23523', 'CreationDate': '2014-04-06T16:18:17.753', 'Id': '23519'}{'Body': '<p>The <a href="http://en.wikipedia.org/wiki/K-d_tree" rel="nofollow">link</a> in wikipedia about kd-trees store points in the inner nodes. I have to perform NN queries and I <strong>think</strong> (newbie here), I am understanding the concept.</p>\n\n<p>However, I was said to study Kd-trees from Computational Geometry Algorithms and Applications (De Berg, Cheong, Van Kreveld and Overmars), section 5.2, page 99. The main difference I can see is that Overmars places the splitting data in the inner nodes and the actual points of the dataset in the leaves. For example, in 2D, an inner node will hold the splitting line.</p>\n\n<p>Wikipedia on the other hand, seems to store points in inner nodes and leaves (while Overmars only on leaves).</p>\n\n<p>In this case, how do we perform nearest neighbour search? Moreover, why there is this difference?</p>\n', 'ViewCount': '36', 'Title': 'kd-tree stores points in inner nodes? If yes, how to search for NN?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-10T14:43:00.437', 'LastEditDate': '2014-04-10T14:43:00.437', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16638', 'Tags': '<data-structures><computational-geometry><search-algorithms><search-trees><nearest-neighbour>', 'CreationDate': '2014-04-10T13:20:27.113', 'Id': '23636'}{'Body': "<p>We have an n-ary tree used for searching that we'd like to keep balanced.  It is currently mostly a B-tree without the balancing operations. The issue we have for implementing those is that each sub-tree has its own sorting criteria (chosen in a set of five, if that's important) and that the balancing algorithms we know don't work in that case.</p>\n\n<p>Is there a known algorithm which work in that case?  Or for a variation, we would probably reduce the number of criteria -- but not to one! -- and ensure that all nodes at a given level are using the same criteria if that help to keep the tree balanced at a reasonable cost and avoid rebuilding the whole tree like we do in some cases.</p>\n", 'ViewCount': '13', 'Title': 'Balanced multi-criteria trees', 'LastActivityDate': '2014-04-28T17:40:10.260', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '584', 'Tags': '<data-structures><trees>', 'CreationDate': '2014-04-28T17:40:10.260', 'Id': '24191'}{'Body': '<p>Let\'s say you have the following sentence: "This is my first cs question posted here". How would I go about inserting the sentence into a search tree. Do I assign each word a number value and perform the insertions based on those? </p>\n', 'ViewCount': '15', 'Title': 'Inserting a sentence into search trees', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T08:37:33.313', 'LastEditDate': '2014-04-29T08:37:33.313', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17159', 'Tags': '<data-structures><strings><search-trees>', 'CreationDate': '2014-04-29T01:30:52.450', 'Id': '24204'}{'ViewCount': '58', 'Title': 'Tree data structure for fast merges', 'LastEditDate': '2014-04-30T18:06:55.563', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17191', 'Body': '<p>I need trees that have the following properties:</p>\n\n<ol>\n<li><p>Each node in the tree has two values associated with it - a key and an associated opaque data element.</p></li>\n<li><p>An internal node in the tree has unbounded number of children. The tree reflects a real world hierarchy that is in flux over time - hence the maximum number of children of a given node are not known ahead of time.</p></li>\n<li><p>There is an ordering defined on sibling nodes that is a function of the keys stored in the nodes. </p></li>\n</ol>\n\n<p>Allow the following operations to be $O(\\lg n)$.</p>\n\n<h2>Update operations</h2>\n\n<ul>\n<li><p><code>merge(tree_1, tree_2)</code> - Destructively consumes <code>tree_1</code> and <code>tree_2</code> to create a new tree which contains keys from both input trees. I realize now that this operation is underdefined, I will put more thought into the semantics of the merge.</p></li>\n<li><p><code>insert(tree, parent_key, child_key, value)</code> - inserts the given key-value pair into the given subtree rooted at the node pointed to by the parent key. </p></li>\n<li><p><code>delete(tree, key)</code> - Delete subtree rooted at node with given key.</p></li>\n<li><p><code>update(tree, key, value)</code> - Destructively updates the existing data associated with the given key-value pair.</p></li>\n</ul>\n\n<h2>Query operations</h2>\n\n<ul>\n<li><p><code>find(tree, key)</code> - returns the value associated with the given key in the given tree. </p></li>\n<li><p><code>get_tree(tree, key)</code> - Return a subtree that is rooted at node with given key. The returned tree must a reference and share identity with corresponding nodes in the incoming tree. Modifying any nodes via the returned tree will hence result in changes to the initial tree. </p></li>\n<li><p><code>children(tree, key)</code> - Returns sequence of (key, data) of child nodes of node corresponding to key. </p></li>\n</ul>\n\n<p>Things I looked at before I asked this question - Binary trees, AVL trees, Red Black trees, 2-3 trees and they were not suitable because of fixed degree of internal nodes.</p>\n', 'ClosedDate': '2014-04-30T17:45:07.280', 'Tags': '<data-structures><trees><dictionaries>', 'LastEditorUserId': '17191', 'LastActivityDate': '2014-04-30T18:06:55.563', 'CommentCount': '6', 'AcceptedAnswerId': '24241', 'CreationDate': '2014-04-29T21:23:05.400', 'Id': '24235'}{'Body': "<p>The $k$-bounded spanning tree problem is where you have an undirected graph $G(V,E)$ and you have to decide whether or not it has a spanning tree such that each vertex has a degree of at most $k$.</p>\n\n<p>I realize that for the case $k=2$, this is the Hamiltonian path problem. However I'm having trouble with cases where $k&gt;2$. I tried thinking about it in the sense that you can add more nodes onto an existing spanning tree where $k=2$ and maybe since the base is NP complete, adding things on will make it NP-complete as well, but that doesn't seem right. I'm self-studying CS and am having trouble with theory, so any help will be appreciated!</p>\n", 'ViewCount': '141', 'Title': 'Why is the k-bounded spanning tree problem NP-complete?', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-30T06:54:45.953', 'LastEditDate': '2014-04-30T06:54:45.953', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24247', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '17199', 'Tags': '<spanning-trees>', 'CreationDate': '2014-04-30T01:56:50.577', 'Id': '24246'}{'Body': "<p>I know that leaf-bound-MST is NP-complete by reducing two-leaf-MST to Hamiltonian Path. However, I don't know how to reduce 10-leaf-MST problem (MST with exactly 10-leaf) to a existing NP-complete problem.\nThanks!</p>\n", 'ViewCount': '30', 'ClosedDate': '2014-05-01T02:41:39.773', 'Title': 'How to prove 10-leaf-MST is NP-complete?', 'LastActivityDate': '2014-05-01T01:38:50.957', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17235', 'Tags': '<np-complete><spanning-trees><hamiltonian-path>', 'CreationDate': '2014-05-01T01:38:50.957', 'FavoriteCount': '1', 'Id': '24284'}{'Body': "<p>In my algorithms course I have learned about the binary search tree and its functions add, find and remove.\nI have also learned about how to find the successor and the predecessor in a balanced binary search tree, but they are both $O(\\log n)$ I think.</p>\n\n<p>Now, I have been thinking, how can I change a given binary search tree so that I could find any given node's successor in $O(1)$ time? The other operations should still run in $O(\\log n)$ time.</p>\n\n<p>I have thought about maintaining the tree in a linked list but I am sure that there is a better solution to it.</p>\n", 'ViewCount': '36', 'ClosedDate': '2014-05-02T21:52:16.723', 'Title': 'Finding a successor in a binary search tree in $O(1)$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T21:51:10.597', 'LastEditDate': '2014-05-02T21:51:10.597', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14724', 'Tags': '<data-structures><search-trees>', 'CreationDate': '2014-05-02T15:37:33.333', 'Id': '24317'}