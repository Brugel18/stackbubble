{'ViewCount': '649', 'Title': 'What are the conditions for a NFA for its equivalent DFA to be maximal in size?', 'LastEditDate': '2012-03-15T10:17:50.310', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '1', 'Body': "<p>We know that DFAs are equivalent to NFAs in expressiveness power; there is also a known algorithm for converting NFAs to DFAs (unfortunately I do now know the inventor of that algorithm), which in worst case gives us $2^S$ states, if our NFA had $S$ states.</p>\n\n<p>My question is: what is determining the worst case scenario?</p>\n\n<hr>\n\n<p>Here's a transcription of an algorithm in case of ambiguity:</p>\n\n<p>Let $A = (Q,\\Sigma,\\delta,q_0,F)$ be a NFA. We construct a DFA $A&#39; = (Q&#39;,\\Sigma,\\delta&#39;,q&#39;_0,F&#39;)$ where </p>\n\n<ul>\n<li>$Q&#39; = \\mathcal{P}(Q)$, </li>\n<li>$F&#39; = \\{S \\in Q&#39; | F \\cap S \\neq \\emptyset \\}$,</li>\n<li>$\\delta&#39;(S,a) =\\bigcup_{s \\in S} (\\delta(s,a) \\cup \\hat \\delta(s,\\varepsilon))$, and</li>\n<li>$q&#39;_0 = \\{q_0\\} \\cup \\hat \\delta(q_0, \\varepsilon)$,</li>\n</ul>\n\n<p>where $\\hat\\delta$ is the extended transition function of $A$.</p>\n", 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T10:45:27.090', 'CommentCount': '1', 'AcceptedAnswerId': '131', 'CreationDate': '2012-03-08T10:20:46.940', 'Id': '130''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '539', 'Title': 'What are the possible sets of word lengths in a regular language?', 'LastEditDate': '2012-03-10T15:16:58.000', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Given a language $L$, define the length set of $L$ as the set of lengths of words in $L$:\n$$\\mathrm{LS}(L) = \\{|u| \\mid u \\in L \\}$$</p>\n\n<p>Which sets of integers can be the length set of a regular language?</p>\n', 'Tags': '<formal-languages><computability><regular-languages><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-10T15:16:58.000', 'CommentCount': '2', 'AcceptedAnswerId': '175', 'CreationDate': '2012-03-09T16:46:44.240', 'Id': '164''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>A deterministic finite automaton (DFA) is a state machine model capable of accepting all and only regular languages. DFAs can be (and usually are) defined in such a way that each state must provide some transition for all elements of the input alphabet; in other words, the transition function $\\delta : Q \\times \\Sigma \\rightarrow Q$ should be a (total) function.</p>\n\n<p>Imagine what we will call a doubly deterministic finite automaton (DDFA). It is defined similarly to a DFA, with two exceptions: first, instead of the transition leading from one state to one other state for every possible input symbol, it must lead to two distinct states; second, in order to accept a string, all potential paths must satisfy either one or the other of the following conditions:</p>\n\n<ol>\n<li>All potential paths through the DDFA lead to an accepting state (we will call this a type-1 DDFA).</li>\n<li>All potential paths through the DDFA lead to the same accepting state (we will call this a type-2 DDFA).</li>\n</ol>\n\n<p>Now for my question:</p>\n\n<blockquote>\n  <p>What languages do type-1 and type-2 DDFAs accept? Specifically, is it the case that $L(DFA) \\subsetneq L(DDFA)$, $L(DDFA) = L(DFA)$, or $L(DDFA) \\subsetneq L(DFA)$? In the case that $L(DDFA) \\neq L(DFA)$, is there an easy description of $L(DDFA)$? </p>\n</blockquote>\n\n<p>Proofs (or at least moderately fleshed-out sketches) are appreciated, if they aren't too complicated.</p>\n", 'ViewCount': '133', 'Title': 'Languages accepted by modified versions of finite automata', 'LastActivityDate': '2012-03-14T18:00:07.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '385', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2012-03-14T14:59:22.810', 'Id': '374''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '228', 'Title': 'Is this language defined using twin primes regular?', 'LastEditDate': '2012-03-14T15:49:25.680', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '2', 'Body': '<p>Let</p>\n\n<p>$\\qquad L = \\{a^n \\mid \\exists_{p \\geq n}\\ p\\,,\\ p+2 \\text{ are prime}\\}.$</p>\n\n<p>Is $L$ regular?</p>\n\n<p>This question looked suspicious at the first glance and I\'ve realized that it is connected with the <a href="https://en.wikipedia.org/wiki/Twin_prime">twin prime conjecture</a>. My problem is that the conjecture has not been resolved yet, so I am not sure how can I proceed with deciding that the language is regular. </p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-14T20:25:40.660', 'CommentCount': '2', 'AcceptedAnswerId': '377', 'CreationDate': '2012-03-14T15:42:01.860', 'Id': '376''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The following DFA is a lexical analyzer which is supposed to recognize comments. The lexical analyzer will ignore the comment and goes back to the state one. I\'m told that there\'s something wrong with it but I can\'t figure it out. What\'s the problem?</p>\n\n<p><img src="http://i.stack.imgur.com/EeIdO.png" alt="enter image description here"></p>\n\n<p>FWIW, those tiny signs are stars which are necessary for C-style comment: "/* comment */"<br>\n  The loop in the state three is "except *"</p>\n', 'ViewCount': '489', 'Title': 'A DFA for recognizing comments', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:19.720', 'LastEditDate': '2012-03-25T15:53:37.777', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '398', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><automata><finite-automata><compilers>', 'CreationDate': '2012-03-14T22:46:16.420', 'Id': '396''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '658', 'Title': 'How to convert an NFA with overlapping cycles into a regular expression?', 'LastEditDate': '2014-01-25T16:51:44.933', 'AnswerCount': '3', 'Score': '10', 'OwnerDisplayName': 'zell', 'PostTypeId': '1', 'OwnerUserId': '694', 'Body': '<p>If I understand correctly, NFA have the same expressive power as regular expressions. Often, reading off equivalent regular expressions from NFA is easy: you translate cycles to stars, junctions as alternatives and so on. But what to do in this case: </p>\n\n<p><img src="http://i.stack.imgur.com/yCGnv.png" alt="enter image description here"><br>\n<sup>[<a href="https://github.com/akerbos/sesketches/blob/gh-pages/src/cs_689.tikz" rel="nofollow">source</a>]</sup></p>\n\n<p>The overlapping cycles make it hard to see what this automaton accepts (in terms of regular expressions). Is there a trick?</p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:51:44.933', 'CommentCount': '7', 'AcceptedAnswerId': '692', 'CreationDate': '2012-03-23T07:35:51.517', 'Id': '689''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '597', 'Title': 'Words that have the same right- and left-associative product', 'LastEditDate': '2012-04-24T06:17:40.090', 'AnswerCount': '4', 'Score': '7', 'OwnerDisplayName': 'Ismael Mezquino', 'PostTypeId': '1', 'OwnerUserId': '1217', 'FavoriteCount': '1', 'Body': '<p>I have started to study non deterministic automata using the book of <a href="https://en.wikipedia.org/wiki/Introduction_to_Automata_Theory,_Languages,_and_Computation" rel="nofollow">Hopcroft and Ullman</a>. I\'m stuck in a problem that I found very interesting:</p>\n\n<blockquote>\n  <p>Give a non deterministic finite automaton accepting all the strings that\n  have the same value when evaluated left to right as right to left by\n  multiplying according to the following table:</p>\n  \n  <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \r\n    \\times &amp; a &amp; b &amp; c \\\\\r\n    \\hline \r\n    a &amp; a &amp; a &amp; c \\\\\r\n    b &amp; c &amp; a &amp; b \\\\\r\n    c &amp; b &amp; c &amp;a\r\n   \\end{array}$</p>\n</blockquote>\n\n<p>So if we have the string $abc$,<br>\nthe product from left to right is $(a \\times b) \\times c=a \\times c=c$ and<br>\nthe product from right to left is $a \\times (b \\times c)=a \\times b=a$</p>\n\n<p>So $abc$ should not be acceptable for the automata. To me its obvious that any string $aa^*$ or $bb^*$ or $cc^*$ is an aceptable string (their right and left evaluation work on the same partial strings). It is easy to give an NFA that describes the left to right evaluation but the problem is that if the machine try to compute the <em>right to left</em> evaluation I think it needs to know the length of the string (so infinite memory is necessary).</p>\n\n<p>So how can a non deterministic automata evaluate from right to left in order to compare with the left to right evaluation?</p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-25T17:11:22.873', 'CommentCount': '0', 'AcceptedAnswerId': '1479', 'CreationDate': '2012-04-23T18:12:11.180', 'Id': '1467''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Let $A_P = (Q,\\Sigma,\\delta,0,\\{m\\})$ the <em>string matching automaton</em> for pattern $P \\in \\Sigma^m$, that is </p>\n\n<ul>\n<li>$Q = \\{0,1,\\dots,m\\}$</li>\n<li>$\\delta(q,a) = \\sigma_P(P_{0,q}\\cdot a)$ for all $q\\in Q$ and $a\\in \\Sigma$</li>\n</ul>\n\n<p>with $\\sigma_P(w)$ the length of the longest prefix of $P$ that is a Suffix of $w$, that is</p>\n\n<p>$\\qquad \\displaystyle \\sigma_P(w) = \\max \\left\\{k \\in \\mathbb{N}_0 \\mid P_{0,k} \\sqsupset w \\right\\}$.</p>\n\n<p>Now, let $\\pi$ the <em>prefix function</em> from the <a href="https://secure.wikimedia.org/wikipedia/en/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" rel="nofollow">Knuth-Morris-Pratt algorithm</a>, that is</p>\n\n<p>$\\qquad \\displaystyle \\pi_P(q)= \\max \\{k \\mid k &lt; q \\wedge P_{0,k} \\sqsupset P_{0,q}\\}$.</p>\n\n<p>As it turns out, one can use $\\pi_P$ to compute $\\delta$ quickly; the central observation is:</p>\n\n<blockquote>\n  <p>Assume above notions and $a \\in \\Sigma$. For $q \\in \\{0,\\dots,m\\}$ with $q = m$ or $P_{q+1} \\neq a$, it holds that</p>\n  \n  <p>$\\qquad \\displaystyle \\delta(q,a) = \\delta(\\pi_P(q),a)$</p>\n</blockquote>\n\n<p>But how can I prove this?</p>\n\n<hr>\n\n<p>For reference, this is how you compute $\\pi_P$:</p>\n\n<pre><code>m \u2190 length[P ]\n\u03c0[0] \u2190 0\nk \u2190 0\nfor q \u2190 1 to m \u2212 1 do\n  while k &gt; 0 and P [k + 1] =6 P [q] do\n    k \u2190 \u03c0[k]\n    if P [k + 1] = P [q] then\n       k \u2190 k + 1\n    end if\n    \u03c0[q] \u2190 k\n end while\nend for\n\nreturn \u03c0\n</code></pre>\n', 'ViewCount': '1117', 'Title': 'Connection between KMP prefix function and string matching automaton', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:53:30.563', 'LastEditDate': '2012-05-17T23:59:30.850', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '1900', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1378', 'Tags': '<algorithms><finite-automata><strings><searching>', 'CreationDate': '2012-05-05T09:56:27.257', 'Id': '1669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Lets $L_z \\ := \\{ a^i b^i c^i : 0 \\leq i &lt; z \\}$</p>\n\n<p>$\\{a,b,c\\} \\in \\sum^*$</p>\n\n<p>there is a DFA with $\\frac{z(z+1)}{2}+1$ states - How can I prove this?</p>\n\n<p>And I need largest possible number $n_z$, for which i can prove that every NFA, which accepts $L_z$, have $n_z$ states, at least!</p>\n\n<p>But first I need to show that $n_z = \\frac{z(z+1)}{2}$\n right?</p>\n', 'ViewCount': '249', 'Title': 'DFA with limited states', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-19T15:56:15.823', 'LastEditDate': '2012-05-08T23:09:26.217', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '1743', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-05-08T22:59:08.823', 'Id': '1740''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '309', 'Title': 'Non-regular Languages?', 'LastEditDate': '2012-05-09T14:33:33.083', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Body': u'<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Why $L_a$ and  $L_b$  are not reguluar?</p>\n\n<p>$L_a = \\{ e^i f^{n-i} g^j h^{n-j} : n \\in N, 1 \\leq i, j \\leq n \\}$. </p>\n\n<p>$L_b= \\{nm^{i_1} nm^{i_2}...bn^{i_z}: z \\in N, (i_1,...,i_n) \\in N^z, 1 \\leq j \\leq z, i_j \u2260 j \\}$.</p>\n', 'ClosedDate': '2012-05-09T19:58:17.077', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-10T02:21:47.107', 'CommentCount': '8', 'AcceptedAnswerId': '1756', 'CreationDate': '2012-05-09T13:39:25.267', 'Id': '1753''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '546', 'Title': "Why is a regular language called 'regular'?", 'LastEditDate': '2012-05-14T15:15:21.780', 'AnswerCount': '2', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '1434', 'FavoriteCount': '3', 'Body': '<p>I have just completed the first chapter of the <a href="http://www-math.mit.edu/~sipser/book.html"><em>Introduction to the Theory of Computation</em></a> by <em>Michael Sipser</em> which explains the basics of finite automata. </p>\n\n<p>He defines a regular language as anything that can be described by a finite automata. But I could not find where he explains why a regular language is called "regular?"  What is the origin of the term "regular" in this context?</p>\n\n<p>NOTE: I am a novice so please try to explain in simple terms!</p>\n', 'Tags': '<formal-languages><regular-languages><terminology><finite-automata><history>', 'LastEditorUserId': '1298', 'LastActivityDate': '2012-05-14T15:15:21.780', 'CommentCount': '1', 'AcceptedAnswerId': '1772', 'CreationDate': '2012-05-10T02:07:18.947', 'Id': '1771''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Brzozowski's DFA minimization algorithm builds a minimal DFA for DFA $G$ by:</p>\n\n<ol>\n<li>reversing all the edges in $G$, making the initial state an accept state, and the accept states initial, to get an NFA $N&#39;$ for the reverse language, </li>\n<li>using powerset construction to get $G&#39;$ for the reverse language, </li>\n<li>reversing the edges (and initial-accept swap) in $G&#39;$ to get an NFA $N$ for the original language, and</li>\n<li>doing powerset construction to get $G_{\\min}$.</li>\n</ol>\n\n<p>Of course, since some DFA's have an exponential large reverse DFA, this algorithm runs in exponential time in worst case in terms of the size of the input, so lets keep track of the size of the reverse DFA. </p>\n\n<p>If $N$ is the size of the input DFA, $n$ is the size of the minimal DFA, and $m$ the size of the minimal reverse DFA, then <strong>what is the run time of Brzozowski's algorithm in terms of $N$,$n$, and $m$?</strong></p>\n\n<p>In particular, <strong>under what relationship between $n$ and $m$ does Brzozowski's algorithm outperform Hopcroft's or Moore's algorithms?</strong></p>\n\n<p>I have heard that on typical examples in <em>practice/application</em>, Brzozowski's algorithm outperforms the others. <strong>Informally, what are these typical examples like?</strong></p>\n", 'ViewCount': '1327', 'Title': "Brzozowski's algorithm for DFA minimization", 'LastEditorUserId': '55', 'LastActivityDate': '2012-11-09T13:05:46.000', 'LastEditDate': '2012-05-16T18:52:28.467', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<algorithms><finite-automata><runtime-analysis>', 'CreationDate': '2012-05-16T16:43:10.513', 'FavoriteCount': '2', 'Id': '1872''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m am stuck solving the next exercise:</p>\n\n<p>Argue that if $L$ is context-free and $R$ is regular, then $L / R = \\{ w \\mid \\exists x \\in R \\;\\text{s.t}\\; wx \\in L\\} $ (i.e. the <a href="https://en.wikipedia.org/wiki/Right_quotient" rel="nofollow">right quotient</a>) is context-free.</p>\n\n<p>I know that there should exist a PDA that accepts $L$ and a DFA that accepts $R$. I\'m now trying to combine these automata to a PDA that accepts the right quotient. If I can build that I proved that $L/R$ is context-free. But I\'m stuck building this PDA.</p>\n\n<p>This is how far I\'ve made it:   </p>\n\n<blockquote>\n  <p>In the combined PDA the states are a cartesian product of the states of the seperate automata. And the edges are the edges of the DFA but only the ones for which in the future a final state of the original PDA of L can be reached. But don\'t know how to write it down formally.</p>\n</blockquote>\n', 'ViewCount': '637', 'Title': 'If $L$ is context-free and $R$ is regular, then $L / R$ is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-17T23:12:15.793', 'LastEditDate': '2012-05-17T19:38:52.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1526', 'Tags': '<formal-languages><context-free><finite-automata><closure-properties><pushdown-automata>', 'CreationDate': '2012-05-17T16:19:42.050', 'FavoriteCount': '1', 'Id': '1886''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm learning for the exam and have problems with this task:</p>\n\n<blockquote>\n  <p>Describe an algorithm that transforms a given NFA $A = (Q, \\Sigma, \\delta, q_0, F)$ (which may have $\\epsilon$-transitions) into an equivalent NFA without $\\epsilon$-transitions with the same condition number. And then determine the maturity of the algorithm. The algorithm should have a running time $O(|Q| \xb7 |\\delta|)$ where\n  $$|\\delta| := \\sum_{\\substack{q\\in Q\\\\ a\\in\\Sigma\\cup\\{\\epsilon\\}}} |\\delta(q,a)|$$</p>\n</blockquote>\n", 'ViewCount': '710', 'Title': 'Transforming an NFA into an NFA of similar size but without $\\epsilon$-transitions', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T21:24:51.643', 'LastEditDate': '2012-05-22T19:49:52.230', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1593', 'Tags': '<algorithms><automata><finite-automata>', 'CreationDate': '2012-05-21T22:26:40.027', 'Id': '1983''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '985', 'Title': 'Prove that regular languages are closed under the cycle operator', 'LastEditDate': '2012-05-22T07:23:51.960', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '2', 'Body': u"<p>I've got in a few days an exam and have problems to solve this task.</p>\n\n<p>Let $L$ be a regular language over the alphabet $\\Sigma$. We have the operation \n$\\operatorname{cycle}(L) = \\{ xy \\mid x,y\\in \\Sigma^* \\text{ and } yx\\in L\\}$\nAnd now we should show that $\\operatorname{cycle}(L)$ is also regular.</p>\n\n<p>The reference is that we could construct out of a DFA $D=(Q,\\Sigma,\\delta, q_0, F)$ with $L(D) = L$ a $\\epsilon$-NFA $N$ with $L(N) = \\operatorname{cycle}(L)$ and  $2 \xb7 |Q|^2 + 1$ states. </p>\n", 'Tags': '<formal-languages><regular-languages><finite-automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:35:34.333', 'CommentCount': '2', 'AcceptedAnswerId': '1989', 'CreationDate': '2012-05-22T05:28:58.017', 'Id': '1986''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '14352', 'Title': 'How to convert finite automata to regular expressions?', 'LastEditDate': '2014-03-22T11:29:26.503', 'AnswerCount': '4', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '18', 'Body': '<p>Converting regular expressions into (minimal) NFA that accept the same language is easy with standard algorithms, e.g. <a href="http://en.wikipedia.org/wiki/Thompson%27s_construction_algorithm" rel="nofollow">Thompson\'s algorithm</a>. The other direction seems to be more tedious, though, and sometimes the resulting expressions are messy.</p>\n\n<p>What algorithms are there for converting NFA into equivalent regular expressions? Are there advantages regarding time complexity or result size?</p>\n\n<p><sup>This is supposed to be a reference question. Please include a general decription of your method as well as a non-trivial example.</sup></p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:29:26.503', 'CommentCount': '2', 'AcceptedAnswerId': '2389', 'CreationDate': '2012-05-23T08:19:27.003', 'Id': '2016''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need help with the following exercise:</p>\n\n<p>Construct an $\\varepsilon$-NFA for the following regular expression $(a|\\varepsilon)(ba)^*(c^*a|bc)^*$.</p>\n\n<p>i already tried this exercise with nerode but i didnt come to a solution please help me\nthank you guys</p>\n\n<p>Source wiki\nNerode : (Given a language L, and a pair of strings x and y, define a distinguishing extension to be a string z such that exactly one of the two strings xz and yz belongs to L. Define a relation RL on strings by the rule that x RL y if there is no distinguishing extension for x and y. It is easy to show that RL is an equivalence relation on strings, and thus it divides the set of all finite strings into equivalence classes.</p>\n\n<p>The Myhill\u2013Nerode theorem states that L is regular if and only if RL has a finite number of equivalence classes, and moreover that the number of states in the smallest deterministic finite automaton (DFA) recognizing L is equal to the number of equivalence classes in RL. In particular, this implies that there is a unique minimal DFA with minimum number of states.)</p>\n', 'ViewCount': '164', 'Title': 'construct regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T13:19:11.120', 'LastEditDate': '2012-05-23T15:44:05.140', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1424', 'Tags': '<formal-languages><finite-automata><regular-expressions>', 'CreationDate': '2012-05-23T14:54:13.360', 'Id': '2024''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '289', 'Title': 'Optimal myopic maze solver', 'LastEditDate': '2012-06-02T18:29:46.523', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '55', 'FavoriteCount': '1', 'Body': '<p>I was fooling around with <a href="http://neil.fraser.name/software/blockly/demos/maze/index.html">Google Blocky\'s Maze demo</a>, and remembered the old rule that if you want to solve a maze, just keep your left hand to the wall. This works for any simple-connected maze and can be implemented by a finite transducer.</p>\n\n<p>Let our robot be represented by a transducer with the following actions, and observables:</p>\n\n<ul>\n<li>Actions: go forward ($\\uparrow$), turn left ($\\leftarrow$), turn right ($\\rightarrow$)</li>\n<li>Observables: wall ahead ($\\bot$), no wall ahead ($\\top$)</li>\n</ul>\n\n<p>Then we can build the left-hand maze solver as (pardon my lazy drawing):</p>\n\n<p><img src="http://i.stack.imgur.com/vAnFO.png" alt="transducer to solve the maze"></p>\n\n<p>Where seeing an observable will make us follow the appropriate edge out of the state while executing the action associated with that edge. This automaton will solve all simply-connected mazes, although it might take its time following dead ends. We call another automaton $B$ <em>better than</em> $A$ if:</p>\n\n<ol>\n<li><p>$B$ takes strictly more steps on only a finite number of mazes, and</p></li>\n<li><p>$B$ takes strictly fewer steps (on average; for probabilistic variants) on an infinite number of mazes.</p></li>\n</ol>\n\n<p>My two questions:</p>\n\n<ol>\n<li><p><strong>Is there a finite automaton <em>better than</em> the one drawn above?</strong> What if we allow probabilistic transducers?</p></li>\n<li><p><strong>Is there a finite automaton for solving mazes that are not necessarily simply-connected?</strong></p></li>\n</ol>\n', 'Tags': '<automata><finite-automata><artificial-intelligence>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-03T08:49:25.447', 'CommentCount': '3', 'AcceptedAnswerId': '2207', 'CreationDate': '2012-06-02T16:18:06.140', 'Id': '2201''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '451', 'Title': 'Automata that recognizes Kleene closure of permutations of three symbols', 'LastEditDate': '2012-06-05T20:22:44.813', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1758', 'FavoriteCount': '1', 'Body': u'<p>This is an automata theory homework question.</p>\n\n<p>I need to create DFA that meets the following criteria:  </p>\n\n<ul>\n<li><p>Alphabet $\\Sigma = \\{ a, b, c \\}$</p></li>\n<li><p>Machine accepts empty string and strings of length that is a multiple of three, with every block of three containing one $a$, one $b$ and one $c$.</p></li>\n</ul>\n\n<p>So far, I came up with this machine, it is obvious:</p>\n\n<p><img src="http://i.stack.imgur.com/r3rCz.jpg" alt="the machine"></p>\n\n<p>However, I can\'t get it to accept empty string. Does it mean there is a transition q0 \u2192 q3?</p>\n\n<p><strong>Update1:</strong>  Following corrections by Dave Clarke I made some corrections.</p>\n\n<ol>\n<li>A regular expression for this machine is $(www)^*$ where $w = \\{abc,acb,\u2026\\}$. Therefore to represent multiple of three, I need to copy this (on the picture) machine 3 times. Final state should have arrows pointing to the first copy, for transitions marked \'a\', \'b\',\'c\'.  </li>\n<li>As it was pointed out, since this is DFA, I need to add missing states. This can be accomplished by adding "dead" states.  </li>\n<li>Empty string should correspond to $\\varepsilon$-transition from qStarting \u2192 qFinal.</li>\n</ol>\n\n<p><strong>Update2:</strong> \nAs it was pointed out, my regular expression is wrong ! It should be $(w)^*$. Here is the final machine, that I think should be correct.(I didn\'t include "dead" state)<img src="http://i.stack.imgur.com/L3xZX.jpg" alt="enter image description here"></p>\n', 'Tags': '<formal-languages><automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-06T11:21:21.587', 'CommentCount': '11', 'AcceptedAnswerId': '2234', 'CreationDate': '2012-06-05T17:19:48.020', 'Id': '2233''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to proof that if $L_1 \\subset L_2$ and $L_1$ is not regular then $L_2$ it not regular. This is my proof. Is it valid? </p>\n\n<p>Since $L_1$ is not regular, there does not exists a finite automata $M_1$ such that $L_1$ is the language of $M_1$. Pick $x\\in L_1$. So $x \\in L_2$ and suppose that $L_2$ is regular. Then there exists a finite automata $M_2$ such that $L_2$ is the language of $M_2$. Since $x \\in L_2$ and $L_2$ is regular, there exists a state $s\\in S$ such that from the initial state in $M_2$ there is a path $x$ to this final state $s$. Since this holds for all $x \\in L_1$, we can construct a finite automata which language is $L_1$, so $L_1$ is regular, so we reached a contradiction, so $L_2$ is not regular.</p>\n\n<p>Can this be done easier?</p>\n', 'ViewCount': '463', 'Title': 'Are supersets of non-regular languages also non-regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-29T12:06:06.380', 'LastEditDate': '2012-06-28T16:53:23.070', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata><check-my-proof>', 'CreationDate': '2012-06-28T16:24:12.253', 'Id': '2528''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Let $L_1$ be regular, $L_1 \\cap L_2$ regular, $L_2$ not regular. Show that $L_1 \\cup L_2$ is not regular or give a counterexample.</p>\n</blockquote>\n\n<p>I tried this: Look at $L_1 \\backslash (L_2 \\cap L_1)$. This one is regular. I can construct a finite automata for this ($L_1$ is regular, $L_2 \\cap L_1$ is regular, so remove all the paths (finite amount) for $L_1 \\cap L_2$ from the finite amount of paths for $L_1$. So there is a finite amount of paths left for this whole thing. This thing is disjoint from $L_2$, but how can I prove that the union of $L_1 \\backslash (L_1 \\cap L_2)$ (regular) and $L_2$ (not regular) is not regular?</p>\n', 'ViewCount': '2072', 'Title': 'Proof that union of a regular and a not regular language is not regular', 'LastEditorUserId': '667', 'LastActivityDate': '2014-04-19T06:24:37.110', 'LastEditDate': '2012-07-17T18:05:14.560', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-06-28T20:00:17.477', 'Id': '2537''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '528', 'Title': 'How to simulate backreferences, lookaheads, and lookbehinds in finite state automata?', 'LastEditDate': '2012-06-30T11:18:42.317', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'Aadit M Shah', 'PostTypeId': '1', 'OwnerUserId': '2023', 'Body': "<p>I created a simple regular expression lexer and parser to take a regular expression and generate its parse tree. Creating a non-deterministic finite state automaton from this parse tree is relatively simple for basic regular expressions. However I can't seem to wrap my head around how to simulate backreferences, lookaheads, and lookbehinds.</p>\n\n<p>From what I read in the purple dragon book I understood that to simulate a lookahead $r/s$ where the regular expression $r$ is matched if and only if the match is followed by a match of the regular expression $s$, you create a non-deterministic finite state automaton in which $/$ is replaced by $\\varepsilon$. Is it possible to create a deterministic finite state automaton that does the same?</p>\n\n<p>What about simulating negative lookaheads and lookbehinds? I would really appreciate it if you would link me to a resource which describes how to do this in detail.</p>\n", 'Tags': '<automata><finite-automata><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:41:59.937', 'CommentCount': '0', 'AcceptedAnswerId': '2560', 'CreationDate': '2012-06-29T05:27:14.677', 'Id': '2557''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $\\Sigma$ be a given alphabet. Is there a way to code up Deterministic Finite state Automata (DFA) over $\\Sigma$ as strings of $\\Sigma$ in such a way that the corresponding subset of $\\Sigma^*$ is a regular language?</p>\n\n<p>For example for Turing machines, the set of codes of Turing machines over a fixed alphabet is decidable, and we can speak of decidable sets of Turing machines (through their codes).</p>\n\n<p>Of course we can also speak of regular sets of DFA's (through their codes). Is the set of all DFA's regular in this sense?</p>\n", 'ViewCount': '143', 'Title': 'Is the set of codes of Deterministic Finite-State Automata a regular language?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-06-13T13:23:28.980', 'LastEditDate': '2012-07-17T05:57:31.880', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'OwnerDisplayName': 'user1491069', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-07-09T16:26:02.807', 'Id': '2682''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have this finite-state process with the corresponding labeled transition system: </p>\n\n<p><img src="http://i.stack.imgur.com/mxLLU.png" alt="enter image description here"></p>\n\n<p>The FSP is: </p>\n\n<pre><code>MAKER = (kochen -&gt; fertig -&gt; MAKER).\nUSER = (fertig -&gt; essen -&gt; USER). \n\n||MAKER_USER = (USER||MAKER).\n</code></pre>\n\n<p>Why is <code>essen</code> possible after the second <code>kochen</code>? <code>USER</code> needs to have <code>fertig</code> in order to able to <code>essen</code> right? </p>\n', 'ViewCount': '168', 'Title': 'LTS of this simple FSP', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-27T15:36:33.043', 'LastEditDate': '2012-07-16T23:31:50.067', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1877', 'Tags': '<automata><finite-automata><process-algebras>', 'CreationDate': '2012-07-15T00:33:08.300', 'Id': '2744''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '139', 'Title': 'Building a finite state transducer', 'LastEditDate': '2012-07-16T23:33:18.050', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'madflame991', 'PostTypeId': '1', 'OwnerUserId': '2170', 'Body': "<p>I know it's possible to build a Finite State Transducer for converting numbers from base 2 to base 4 or 8 or other powers of 2 (translating from base N to base N^M is easy). However I've never seen a FST that can convert numbers from base 1 to base 2 or viceversa. Can a FST even do this? If so, can you please give some hints on building such a FST?</p>\n", 'Tags': '<automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:33:18.050', 'CommentCount': '2', 'AcceptedAnswerId': '2747', 'CreationDate': '2012-07-14T19:48:07.230', 'Id': '2745''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I cannot understand decidability really well. I have been reading from books and internet, but I am little bit confused. \nAccording to the book (as I understood), we can decide on decidability of a problem by constructing Turing Machines. Let us say that we want to decide whether an NFA is a decidable language. First, we need to construct a Turing Machine that accepts if the run on w in NFA ends in accept state, otherwise Turing Machine rejects. \nAccording to this definition, I can construct any Turing Machine that can decide every NFA. As a result, I can say that every NFA that can be constructed is decidable. Is this true ?</p>\n\n<p>Additionally, I realized that we cannot decide whether two Context Free Grammars produce same languages. However, we can decide whether two NFA produce same language. Therefore, can we conclude that as our machines get complicated, some of the problems get harder to decide ? </p>\n\n<p>I mean lets take an example. Let us say that there is an NFA that accepts some string w whose length is a composite number. I think that this is a decidable problem.</p>\n\n<p>As you can see that I am little bit confused with these concepts. It will be a lot better for me to go over an example, because it is difficult for me to understand only from conceptual explanations.</p>\n', 'ViewCount': '90', 'Title': 'Decidability of Machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:04:31.740', 'LastEditDate': '2012-07-17T22:04:31.740', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Marigi Maskere', 'PostTypeId': '1', 'Tags': '<computability><automata><finite-automata><turing-machines>', 'CreationDate': '2009-12-06T15:47:36.283', 'Id': '2797''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I just came across an exercise which is to find a regular expression for the following automata, such that the regular expression and the automata generate the same language.</p>\n\n<p><img src="http://i.stack.imgur.com/4Zk9t.png" alt="NFA"></p>\n\n<p>One solution presents the following expression:</p>\n\n<p>$\\qquad \\displaystyle r_A = a^+b^+(c\\mid ca^*b^+)^*$</p>\n\n<p>However, can this be true? I think not, because the all words created from the regular expression will have at least one $b$ in it, whereas the automata accepts words without $b$, such as $aaa$.</p>\n\n<p>What is your opinion?</p>\n', 'ViewCount': '214', 'Title': 'Does this regular expression equal this automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-23T07:39:49.723', 'LastEditDate': '2012-07-23T07:39:49.723', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1413', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-07-21T13:37:50.370', 'Id': '2851''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The problem, coming from an interview question, is:</p>\n\n<blockquote>\n  <p>You have a stream of incoming numbers in range 0 to 60000 and you have\n  a function which will take a number from that range and return the\n  count of occurrence of that number till that moment. Give a suitable\n  Data structure/algorithm to implement this system.</p>\n</blockquote>\n\n<p>The stream is infinite, so if fixed size data structures re used, i.e. primitive types in Java or C, they will overflow. So there is the need to use data structures that have a size that grows over time. As pointed by the interviewer, the memory occupied by those data structures will diverge.</p>\n\n<p>The model of computation is a Turing machine with three tapes:</p>\n\n<ul>\n<li>infinite read-only one-way input tape;</li>\n<li>constant space bounded read-write two way work tape;</li>\n<li>infinite write-only one-way output tape.</li>\n</ul>\n\n<p>The main reason to choose the model above is that in the real world there is virtually no limit to the quantity of input that can be acquired using a keyboard or a network connection. Also, there is virtually no limit to the quantity of information that can be displayed on amonitor over time. But memory is limited and expensive.</p>\n\n<p>I modeled the problem as the problem to recognize the language L of all couples (number,number of occurrences so far).</p>\n\n<p>As a corollary of the Theorem 3.13 in Hopcroft-Ullman I know that every language recognized by a constant space bounded machine is regular.</p>\n\n<p>But, in any given moment, the language L is a finite language, because the number of couples to be recognized is finite: 60001. So I can\'t use the pumping lemma for regular languages to prove that such language is not regular.</p>\n\n<p>Is there a way I can complete my proof?</p>\n\n<p>The original question is <a href="http://stackoverflow.com/questions/11708957/find-the-count-of-a-particular-number-in-an-infinite-stream-of-numbers-at-a-part">here</a>.</p>\n', 'ViewCount': '198', 'Title': 'Counting with constant space bounded TMs', 'LastEditorUserId': '851', 'LastActivityDate': '2012-07-30T11:41:01.430', 'LastEditDate': '2012-07-30T11:41:01.430', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '2951', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<regular-languages><turing-machines><finite-automata><space-complexity><streaming-algorithm>', 'CreationDate': '2012-07-29T16:44:46.170', 'Id': '2948''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $\\mathrm{MIN}_{\\mathrm{DFA}}$ collection of all the codings of DFAs such that they are minimal regarding their states number. I mean if $\\langle A \\rangle \\in \\mathrm{MIN}_{\\mathrm{DFA}}$ then for every other DFA $B$ with less states than $A$, $L(A)\\ne L(B)$ holds. I'm trying to figure out how come that $\\mathrm{MIN}_{\\mathrm{DFA}} \\in R$? How come it is decidable?</p>\n\n<p>What is about this kind of DFAs that is easy to decide?</p>\n", 'ViewCount': '131', 'Title': 'Is the set of minimal DFA decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T14:43:53.250', 'LastEditDate': '2012-08-05T14:43:53.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3046', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-08-05T13:05:39.717', 'Id': '3044''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Repost from Stack Overflow:</p>\n\n<p>I'm going through past exams and keep coming across questions that I can't find an answer for in textbooks or on google, so any help would be much appreciated.</p>\n\n<p>The question I'm having problems with at the moment is as follows:  </p>\n\n<blockquote>\n  <p>Given a regular expression (a|bb)*, derive an estimate of the cost in time for \n  converting it to a corresponding NFA and a DFA. Your answer should refer to\n  the size of the regular expression.</p>\n</blockquote>\n\n<p>A similar question from another year is:</p>\n\n<blockquote>\n  <p>Given that, for the above example, you know the size of the original regular\n  expression, |r| and the size of the input string |x|, explain how you would calculate the cost in time for constructing and running the NFA versus constructing\n  and running an equivalent DFA.</p>\n</blockquote>\n\n<p>The resulting NFA for (a|bb)* has 9 states, while the DFA has 4. Even knowing this, I have no idea how to approach the question.</p>\n", 'ViewCount': '819', 'Title': 'Cost in time of constructing and running an NFA vs DFA for a given regex', 'LastActivityDate': '2012-08-09T21:15:55.073', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3094', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2386', 'Tags': '<regular-languages><automata><finite-automata><compilers>', 'CreationDate': '2012-08-07T09:36:46.857', 'Id': '3071''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '5374', 'Title': 'How to show that a "reversed" regular language is regular', 'LastEditDate': '2013-03-06T13:33:29.817', 'AnswerCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2576', 'FavoriteCount': '2', 'Body': '<p>I\'m stuck on the following question:</p>\n\n<p>"Regular languages are precisely those accepted by finite automata. Given this fact, show that if the language $L$ is accepted by some finite automaton, then $L^{R}$ is also accepted by some finite; $L^{R}$ consists of all words of $L$ reversed."</p>\n', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'LastEditorUserId': '2100', 'LastActivityDate': '2013-10-03T14:07:16.580', 'CommentCount': '13', 'AcceptedAnswerId': '3253', 'CreationDate': '2012-08-18T15:54:03.993', 'Id': '3251''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>$$L=\\{a^n \\mid \\text{\\(n\\) is even}\\}$$</p>\n\n<p>This is regular but fails in the pumping Lemma.</p>\n\n<p>Assuming $m=4$, $w=aaaaaa$, $|w|=6$ (even).\nLet $w=xyz$,\n$x=a$,\n$y=aaa$.\nWe have $|y|&gt;0$ and $|xy| \\le m$.</p>\n\n<p>Let $w_i=xy^iz$.\nFor $i=2$,\n$w_2=xy^2z=aaaaaaaaa$.\n$|w_2|=9$ therefore it is not regular.</p>\n\n<p>Where am I going wrong?</p>\n', 'ViewCount': '668', 'Title': 'Pumping Lemma for regular language for $a^n$ where $n$ is even fails', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-18T12:56:53.010', 'LastEditDate': '2012-08-30T04:59:09.197', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '2', 'OwnerDisplayName': 'Raj', 'PostTypeId': '1', 'Tags': '<regular-languages><automata><finite-automata><pumping-lemma>', 'CreationDate': '2012-08-24T05:02:20.050', 'Id': '3330''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Construct an NFA over $\\{0, 1\\}$ whose language contains only words that do not end with $10$.</p>\n</blockquote>\n\n<p>This is one of the first problems in the book, so it's supposedly easy. I just can't figure it out. It's easy using a DFA, but I'm not so sure using an NFA. Maybe I'm not understanding a particular concept in the NFA.</p>\n", 'ViewCount': '398', 'Title': 'NFA for binary words that do not end in 10', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-30T16:21:24.157', 'LastEditDate': '2012-08-30T15:48:21.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user10537', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-08-30T01:16:20.547', 'FavoriteCount': '0', 'Id': '3368''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can I build an example of a DFA that has $2^n$ states where the equivalent NFA has $n$ states. Obviously the DFA's state-set should contain all subsets of the the NFA's state-set, but I don't know how to start. Any suggestions to put me on the right track?</p>\n", 'ViewCount': '905', 'Title': 'NFA with exponential number of states when deteminized', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-21T13:32:00.343', 'LastEditDate': '2012-09-01T11:01:36.277', 'AnswerCount': '4', 'CommentCount': '9', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-08-31T19:54:57.733', 'FavoriteCount': '1', 'Id': '3381''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>When converting a DFA to a regular expression using the <a href="http://cs.stackexchange.com/a/2395">transitive closure method</a>, what is the significance of state $k$ and what values $k$ takes? If $k$ represents the intermediate states then what are the values for $k$? That is while applying the method, for which value of $k$ should we stop finding the regular expressions?</p>\n', 'ViewCount': '162', 'Title': 'What is the purpose of k in the transitive closure method?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T07:51:30.237', 'LastEditDate': '2012-09-03T07:51:30.237', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2699', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2012-09-01T07:18:00.917', 'Id': '3384''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '129', 'Title': "Compute 'insertable' letters in a regular language", 'LastEditDate': '2012-09-03T19:54:55.990', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2714', 'FavoriteCount': '1', 'Body': '<p>Let $L$ a regular language and define the <em><a href="https://en.wikipedia.org/wiki/Subsequence" rel="nofollow">subsequence</a> closure</em> of $L$ as</p>\n\n<p>$\\qquad \\displaystyle S(L) = \\{ w \\mid \\exists w\' \\in L.\\ w \\text{ subsequence of } w\'\\}$.</p>\n\n<p>The problem I want to solve is to find for such subsequences $w \\in S(L)$ which letters can be inserted into them so that the result is also in $S(L)$. Formally:</p>\n\n<blockquote>\n  <p>Given $w_1\\dots w_n \\in S(L)$, output all pairs $(i,a) \\in \\{0,\\dots,n\\} \\times \\Sigma$ for which $w_1 \\dots w_{i} a w_{i+1} \\dots w_n \\in S(L)$.</p>\n</blockquote>\n\n<p>Consider, for instance, the language$\\{ab, abc, abcc\\}$. The string $b$ is in $S(L)$ and inserting $a$ at the beginning -- corresponding to $(0,a)$ -- yields $ab \\in S(L)$. On the other hand, the string $cb$ is not in $S(L)$; there is no way to convert it to a language string by insertion.</p>\n\n<p>Using this language, if the input string is $b$ the possible insertions I am looking for are $(0,a)$ and $(1,c)$ at the end. If the input string is $bc$ the possible insertions are $(0,a), (1,c)$ and $(2,c)$.</p>\n\n<p>The use of this algorithm is in a user interface: the user builds strings belonging to the language starting from an empty string and adding one character at a time in different positions. At each step the UI prompts the user with all the possible valid letters in all the possible insertion positions.</p>\n\n<p>I have a working naive algorithm that involves a lot of back-tracking, and it is way too slow even in relatively simple cases. I was wondering if there is something better, or -- failing that -- if there are any available studies of this problem.</p>\n', 'Tags': '<algorithms><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-04T20:40:39.843', 'CommentCount': '5', 'AcceptedAnswerId': '3424', 'CreationDate': '2012-09-02T19:55:58.830', 'Id': '3404''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '215', 'Title': "Why isn't converting from an NFA to a DFA working?", 'LastEditDate': '2012-09-16T06:08:00.687', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'John Hoffman', 'PostTypeId': '1', 'OwnerUserId': '3003', 'Body': '<p>I am just beginning to learn computation theory. I wrote up a non-deterministic finite automata that accepts strings that contain the substring "abba":</p>\n\n<p><img src="http://i.stack.imgur.com/jZx92.jpg" alt="My NFA"></p>\n\n<p>I tried to convert it to a DFA by putting together sets of states in the NFA to be states of the DFA:<img src="http://i.stack.imgur.com/yHRck.jpg" alt="My DFA"></p>\n\n<p>However, I just realized that my DFA doesn\'t accept strings such as "abbaa" that do not end in "abba." That means that my methodology was wrong. Why? I thought it would make sense to combine states of the NFA to make states of the DFA.</p>\n', 'Tags': '<automata><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-10-22T12:01:57.383', 'CommentCount': '1', 'AcceptedAnswerId': '4581', 'CreationDate': '2012-09-15T19:52:53.927', 'Id': '4572''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '527', 'Title': 'What piece am I missing to turn this idea into a programming language?', 'LastEditDate': '2013-07-20T09:50:34.237', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2161', 'FavoriteCount': '2', 'Body': '<p>I\'ve been doing some reading (I\'ll name drop along the way) and have selected a few scattered ideas that I think could be cobbled together into a nifty esoteric programming language. But I\'m having some difficulty assembling the parts.</p>\n\n<p>Kleene\'s Theorem states: Any Regular Set can be recognized by some Finite-State Machine (Minsky 4.3).</p>\n\n<p>Minsky\'s Theorem 3.5: Every Finite-State machine is equivalent to, and can be "simulated by", some neural net.</p>\n\n<p>"There is a natural way to represent any forest as a binary tree." (Knuth, v1, 333).</p>\n\n<p>And according to Bentley (Programming Pearls, p.126) a binary tree can be encoded as a flat array.</p>\n\n<p>So I\'m imagining an array of bit-fields (say 4 bits so it can easily be worked with in hexadecimal). Each field indicates a type of automaton, and the positions of the array encode (via an intermediary binary tree representation) a forest which approximates (? missing piece ?) the power of a graph.</p>\n\n<p>I\'m somewhat bewildered by the possibilities of automaton sets to try, and of course the fun Universal Automata require three inputs (I worked up an algorithm inspired by Bentley to encode a ternary tree implicitly in a flat array, but it feels like the wrong direction). So I\'d appreciate any side-bar guidance on that. Current best idea: the normal set: and or xor not nand nor, with remaining bits used for threshold weights on the inputs.</p>\n\n<p>So the big piece I\'m missing is a formalism for applying one of these nibble-strings to a datum. Any ideas or related research I should look into?</p>\n\n<hr>\n\n<p><em>Edit:</em> My theoretical support suggests that the type of computations will probably be limited to RL acceptors (and maybe generators, but I haven\'t thought that through).</p>\n\n<p>So, I tried to find an example to flesh this out. The C <code>int isdigit(int c)</code> function performs a logical computation on (in effect) a bit-string. Assuming ASCII, where the valid digits are <code>0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39</code>, so bit 7 must be off, bit 6 must be off, bit 5 must be on, and bit 4 must be on: these giving us the 0x30 prefix; then bit 3 must be off (0-7) or if bit 3 is on, bit 2 must be off and bit 1 must be off (suppressing A-F), and don\'t care about bit 0 (allowing 8 and 9). If you represent the input <em>c</em> as a bit-array (<code>c[0]</code>..<code>c[7]</code>), this becomes</p>\n\n<pre><code>~c[7] &amp; (~c[6] &amp; (c[5] &amp; (c[4] &amp; (~c[3] | (~c[2] &amp; ~c[1])))))\n</code></pre>\n\n<p>Arranging the operators into a tree (colon (:) represents a wire since pipe (|) is logical or),</p>\n\n<pre><code>c[7]  6   5   4   3   2   1   0\n ~    ~   :   :   ~   ~   ~   :\n    &amp;     :   :   :     &amp;\n       &amp;      :      |\n           &amp;        :  \n                &amp;\n</code></pre>\n\n<p>My thought based on this is to insert "input lead" tokens into the tree which receive the values of the input bit assigned in a left-to-right manner. And I also need a <em>ground</em> or <em>sink</em> to explicitly ignore certain inputs (like c[0] above).</p>\n\n<p>This leads me to make NOT (~) a binary operator which negates the left input and simply absorbs right input. And in the course of trying this, I also realized the necessity for a ZERO token to build masks (and to provide dummy input for NOTs).</p>\n\n<p>So the new set is: &amp;(and) |(or) ^(xor) ~(not x, sink y) 0(zero) I(input)</p>\n\n<p>So the tree becomes (flipping up for down)</p>\n\n<pre><code>                 ^\n           &amp;           &amp;\n       &amp;       |      I 0\n     &amp;   I  ~     &amp;\n   &amp;   I   I 0  ~   ~\n ~   ~         I 0 I 0\nI 0 I 0\n=   =  = = =   =   =  =\n7   6  5 4 3   2   1  0 \n</code></pre>\n\n<p>Which encodes into the array (skipping the "forest&lt;=>tree" part, "_" represents a blank)</p>\n\n<pre><code>_ ^ &amp; &amp; &amp; | I 0 &amp; I ~ &amp; _ _ _ _ &amp; I _ _ I 0 ~ ~ _\n  _ _ _ _ _ _ _ ~ ~ _ _ _ _ _ _ _ _ _ _ I 0 I 0 _\n  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ I 0 I 0 \n</code></pre>\n\n<p>The tree->array encoding always put the root in array(1) so with zero-indexed array, there\'s a convenient blank at the beginning that could be used for linkage, I think.</p>\n\n<p>With only 6 operators, I suppose it could be encoded in octal.</p>\n\n<p>By packing a forest of trees, we could represent a chain of acceptors each applied on the next input depending on the result of the previous.</p>\n', 'Tags': '<programming-languages><finite-automata><arrays><neural-networks><machine-models>', 'LastEditorUserId': '2161', 'LastActivityDate': '2013-11-29T03:20:30.750', 'CommentCount': '6', 'AcceptedAnswerId': '4623', 'CreationDate': '2012-09-19T19:58:45.397', 'Id': '4618''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can you show that the Language accepted by an NFA and the reverse NFA is the same?</p>\n\n<p>For a language $L$, there is an $L^R=\\{ w^R \\mid w \\in L\\}$</p>\n\n<p>Let's say that $w^R$ is the string obtained by reversing the string $w$.</p>\n\n<p>I know that it involves using induction on the length of the input, but I would really appreciate some help.</p>\n", 'ViewCount': '339', 'Title': 'How do you prove that two languages are equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T22:29:06.833', 'LastEditDate': '2012-10-02T20:02:27.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3040', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-10-02T18:37:35.743', 'Id': '4845''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>In my Computing Theory course, a lot of our problems involve using induction on the length of the input string to prove statements about finite automata.  I understand mathematical induction, however when strings come into play I get real tripped up.  I\'d really appreciate it if someone would go through the process of making such a proof step by step.</p>\n\n<p>Here\'s an example problem (Exercise 2.2.10 from Hopcroft and Ullman 3rd Edition):</p>\n\n<blockquote>\n  <p>Consider the DFA with the following transition table:</p>\n\n<pre>\n        0    1\n       ________\n-> A |  A    B\n  *B |  B    A\n</pre>\n  \n  <p>Informally describe the language accepted by this DFA, and prove by induction on the length of an input string that your description is correct.</p>\n</blockquote>\n\n<p>This is an answered problem in the book, so I\'m not looking for someone to do my homework.  I just need someone to explain it to me straight.</p>\n\n<p><strong>Book\'s Answer:</strong>\n(taken from <a href="http://infolab.stanford.edu/~ullman/ialcsols/sol2.html" rel="nofollow">here</a>)</p>\n\n<blockquote>\n  <p>The automaton tells whether the number of 1\'s seen is even (state A) or odd (state B), accepting in the latter case. It is an easy induction on |w| to show that dh(A,w) = A if and only if w has an even number of 1\'s.\n  Basis: |w| = 0. Then w, the empty string surely has an even number of 1\'s, namely zero 1\'s, and \u03b4-hat(A,w) = A.</p>\n  \n  <p>Induction: Assume the statement for strings shorter than w. Then w = za, where a is either 0 or 1.</p>\n  \n  <ul>\n  <li><p><strong>Case 1:</strong> a = 0. If w has an even number of 1\'s, so does z. By the inductive hypothesis, \u03b4-hat(A,z) = A. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then so does z. By the inductive hypothesis, \u03b4-hat(A,z) = B, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  <li><p><strong>Case 2:</strong> a = 1. If w has an even number of 1\'s, then z has an odd number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = B. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then z has an even number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = A, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case as well, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  </ul>\n</blockquote>\n\n<p>I understand how to prove things like $\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}$ using induction.  I\'m just confused by how this works with building strings.  I\'m confused by the bolded parts.  I don\'t understand how they are come up with/how it actually proves what is accepted/how it is inductive.</p>\n\n<p>\u03b4-hat is the extended transition function, by the way.</p>\n', 'ViewCount': '1544', 'Title': 'How do I write a proof using induction on the length of the input string?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T17:30:34.120', 'LastEditDate': '2014-02-02T17:30:34.120', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4907', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3082', 'Tags': '<automata><finite-automata><proof-techniques><reference-question><induction>', 'CreationDate': '2012-10-06T19:00:18.360', 'Id': '4905''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p><sup>(edit: the question was ambiguous. The following is it's non-trivial interpretation) </sup></p>\n\n<p>I need to <code>Find a regular grammar that generates the set of all real numbers in C (programming Language)</code></p>\n\n<ol>\n<li>How do I know how the C programming language defines a real number?</li>\n<li>How can I find a <em>regular</em> grammar for such numbers?</li>\n</ol>\n", 'ViewCount': '587', 'ClosedDate': '2012-10-10T20:09:06.560', 'Title': 'Find a regular grammar that generates the set of all real numbers in C', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-19T17:26:29.650', 'LastEditDate': '2012-10-09T07:14:53.170', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3095', 'Tags': '<regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2012-10-08T03:12:37.733', 'Id': '4939''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Im trying to figure out how to describe fifty-six strings to test if a three state FA over the alphabet $\\{a,b\\}$ has a finite language.</p>\n\n<p>The number fifty-six comes from a theorem that states if a machine has $N$ states and an alphabet has $m$ letters, then in total there are $m^N + m^{N + 1} + m^{N + 2} +\\ldots+ m^{2N-1}$ different input strings in the range $N \\leq \\text{length of string} &lt; 2N$. Thus $2^3 2^4 2^5 = 56$ strings.</p>\n\n<p>I know that we can test them all by running them on the machine and if any are accepted, the language is infinite, if none are accepted, the language is finite. I'm just not sure how to describe the strings.</p>\n", 'ViewCount': '98', 'LastEditorDisplayName': 'user3115', 'Title': 'Describing Strings', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T19:15:19.750', 'LastEditDate': '2012-12-12T19:15:19.750', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-10-08T23:02:02.093', 'Id': '4962''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Im trying to prove that the following language is not regular.\n$$\\text{Notprime} = \\{a^n \\text{where \\(n\\) isn\'t prime}\\}\n  = \\{\\epsilon, a, aaaa, aaaaaa, aaaaaaaa, \\ldots\\}$$</p>\n\n<p>Heres what I have:</p>\n\n<p>"If Notprime were regular, then its complement would be regular also. However, the complement of Notprime is the language Prime, hence Notprime is non-regular." </p>\n\n<p>Is this the right way of proving it? Any help is appreciated!</p>\n', 'ViewCount': '499', 'Title': 'Prove that the language of non-prime numbers written in unary is not regular', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-09T22:46:52.467', 'LastEditDate': '2012-10-09T22:35:33.397', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '4986', 'Score': '4', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2012-10-09T22:26:18.387', 'Id': '4984''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a>  </p>\n</blockquote>\n\n\n\n<p>Im curious if anyone knows if its possible to write a program to generate a regular expression given a finite automation.  </p>\n\n<p>To make things less complicated I want to limit the number of states to about 4, assume the FA is in minimal form and that the FA has only one FinalState and only one StartState. </p>\n\n<p>Ive been thinking about it for a while now and I think the first obvious thing to do would be to create a transition table for the FA. </p>\n\n<p>So an FA could look like this:</p>\n\n<pre><code>NumberOfStates 4 \nStartState   1 \nFinalState   4 \nStateNumber  NextStateA   NextStateB\n1            2            4\n2            3            2\n3            4            4\n</code></pre>\n\n<p>And would generate the regular expression: b + (ab*a(a + b))</p>\n\n<p>Ive been racking my brain for hours but am stumped on how to go about this. Any ideas is greatly appreciated. </p>\n', 'ViewCount': '142', 'LastEditorDisplayName': 'user3115', 'ClosedDate': '2012-10-10T06:38:21.657', 'Title': 'Program that generates a regular expression from an FA', 'LastActivityDate': '2012-10-10T06:25:59.247', 'LastEditDate': '2012-10-10T05:17:02.773', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2012-10-10T04:58:04.090', 'Id': '4987''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Im having trouble figuring out how to determine if two finite automata are the same apart from renumbered states.  </p>\n\n<p>More specifically, heres an example:\n<img src="http://i.stack.imgur.com/EPdpg.jpg" alt="example"> </p>\n\n<p>It\'s easy to generate a regular expression by hand and see that both FA produce: \nb + (ab*a(a+b)), though their states are renumbered, they are identical.</p>\n\n<p>What I\'m trying to do is figure out a way to check if the two states are the same apart from state renumbering without generating a regular expression. </p>\n\n<p>Since the states are just renumbered, I\'m thinking it has something to do with permutations of the states(1 2 3 4) but am not seeing how to determine if they are equivalent. I\'m thinking it has something to do with input like this and relating it to the 24 permutations of the states:</p>\n\n<pre><code>Left       Right\n1 a 2      4 a 3\n1 b 4      4 b 1\n2 a 3      3 a 2\n2 b 2      3 b 3\n3 a 4      2 a 1\n3 b 4      2 b 1\n</code></pre>\n\n<p>Im more so trying to figure out the algorithm to renumber the states Any ideas or help is greatly appreciated! </p>\n', 'ViewCount': '201', 'Title': 'Finding an isomorphism between finite automata', 'LastEditorUserId': '630', 'LastActivityDate': '2014-01-21T06:55:28.640', 'LastEditDate': '2014-01-21T06:55:28.640', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '5012', 'Score': '1', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-10-11T05:37:04.637', 'Id': '5010''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '348', 'Title': 'How to prove that DFAs from NFAs can have exponential number of states?', 'LastEditDate': '2012-10-14T14:49:28.763', 'AnswerCount': '3', 'Score': '12', 'OwnerDisplayName': 'John Hoffman', 'PostTypeId': '1', 'OwnerUserId': '3003', 'Body': '<p>All non-deterministic finite automata can be turned into equivalent deterministic finite automata. However, a deterministic finite automata only allows a single arrow per symbol pointing from a state. Therefore, its states should be members of the power set of states of the NFA. This seems to indicate that the number of states of the DFA could scale exponentially in terms of the number of states of the NFA. However, I was wondering how to actually prove this.</p>\n', 'Tags': '<automata><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-14T14:49:28.763', 'CommentCount': '2', 'AcceptedAnswerId': '6065', 'CreationDate': '2012-09-15T21:10:09.980', 'Id': '6063''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to design an NFA that will take the strings <code>"token"</code> and <code>token</code>.</p>\n\n<p>I can use $\\lambda$ or <code>"</code> to the first state, but then how do I know on the final state if it should have end quotes or not?</p>\n', 'ViewCount': '107', 'Title': 'How to make NFA remember its first step?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-16T17:59:41.573', 'LastEditDate': '2012-10-16T07:23:36.440', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3095', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-10-16T06:03:14.447', 'Id': '6103''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been trying to implement Brzozowski's algorithm but I've just discovered that it creates suboptimal automata for a certain class of inputs, having one more state than what is really needed in the result. I can show it on a trivial automaton:</p>\n\n<pre><code>   a b           a   b           a b            a     b            a b\n&gt;0 0 1  rev  *0 0,2  -   det  &gt;0 - 1  rev  *0   -     -    det  &gt;0 1 2\n 1 1 2  --&gt;   1  1   0   --&gt;   1 2 5  --&gt;   1   -    0,4   --&gt;   1 1 2\n*2 0 2       &gt;2  -  1,2        2 2 3        2  1,2    -          2 2 3\n                              *3 4 -        3   -     2         *3 1 3\n                              *4 4 1        4  3,4    -          \n                              *5 5 5        5   5    1,5         \n                                           &gt;6 3,4,5 1,2,5        \n</code></pre>\n\n<p>Here <em>rev</em> is the edge reversal part, where I'd already removed the transitions on epsilon, and <em>det</em> is determinization through powerset construction, creating new states as soon as it discovers them, recursively.</p>\n\n<p>The problem here is this: once I add the extra state to make up for the three different start states after the first edge reversal and powerset construction, nothing ever returns to that state and thus I can't get rid of it later for being equivalent to the original start state.</p>\n\n<p>Is there something wrong with the way I'm doing it? Am I missing something?</p>\n", 'ViewCount': '136', 'Title': "Problem with implementing Brzozowski's algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-18T15:29:53.410', 'LastEditDate': '2012-10-18T06:29:58.037', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6152', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4237', 'Tags': '<algorithms><automata><finite-automata>', 'CreationDate': '2012-10-17T22:23:04.570', 'Id': '6138''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '209', 'Title': 'If $L$ is a regular language, how to prove $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$ is also regular?', 'LastEditDate': '2013-04-07T12:25:29.787', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3146', 'FavoriteCount': '2', 'Body': "<blockquote>\n  <p>If $L$ is a regular language, prove that the language\n  $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$\n  is also regular.</p>\n</blockquote>\n\n<p>My idea: $L$ can be represented as a DFA and then you could add 2 consecutive transitions from every final state for the letters of $v$, creating a new NFA diagram. Is that correct? I'm not sure how to make this a formal proof.</p>\n", 'Tags': '<regular-languages><automata><finite-automata><closure-properties><check-my-answer>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:25:29.787', 'CommentCount': '3', 'AcceptedAnswerId': '6281', 'CreationDate': '2012-10-24T05:09:01.860', 'Id': '6279''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am doing self study from <a href="http://www.myoops.org/twocw/mit/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-042JFall-2005/3970D151-BFD3-4181-81CD-804F109B3AC2/0/ln7.pdf" rel="nofollow">MIT OCW exercises</a> and I could not understand this question.</p>\n\n<blockquote>\n  <p>The following rules define the <em>binary-GCD state machine</em> working on states in $\\mathbb{N}^3$ with start state $(a,b,1)$ for $a&gt;b&gt;0$. If multiple rules apply, smaller numbers have precedence.</p>\n  \n  <p>Provided $\\min(x,y) &gt;0$, then $(x,y,e) \\to $</p>\n  \n  <ol>\n  <li>$(1,0,ex)$ if $x=y$</li>\n  <li>$(1,0,e)$ if $y=1$</li>\n  <li>$(x/2,y/2,2e)$ if $2|x \\land 2|y$</li>\n  <li>$(y,x,e)$ if $y&gt;x$</li>\n  <li>$(x,y/2,e)$ if $2|y$</li>\n  <li>$(x/2,y,e)$ if $2|x$</li>\n  <li>$(x-y,y,e)$ otherwise</li>\n  </ol>\n</blockquote>\n\n<p>The binary-GCD state machine computes the GCD of $a$ and $b$ using only division by $2$ and subtraction, which makes it run very efficiently on hardware that uses binary representation of numbers. In practice, it runs more quickly than the Euclidean algorithm state machine.</p>\n\n<p>Each execution of a command (one of rules 1-7 according to algorithm) is a transition and the current state $(x,y,e)$ is stored in registers $A,B,E$. At first the values in the registers $a,b,1$</p>\n\n<p>Here is the question I am having trouble with:</p>\n\n<blockquote>\n  <p>Prove that the machine reaches a final state in at most $3+2\\log(\\max(a,b))$\n  transitions.</p>\n  \n  <p><strong>Hint:</strong> Strong induction on $\\max(a,b)$ </p>\n</blockquote>\n\n<ul>\n<li><p>First, why does this state machine assume it halves the $\\max(a,b)$ at every two transitions beacuse we can apply rule 4 and 7 and one extra rule to halve the $\\max(a,b)$, which is more than two transitions/steps. I know it is not a common case but a case is a case unless proved.</p></li>\n<li><p>Next I don\'t see where an extra 3 comes from in $3+2\\log(\\max(a,b))$.  </p></li>\n</ul>\n', 'ViewCount': '129', 'Title': 'Runtime of the binary-GCD state machine', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T04:01:55.783', 'LastEditDate': '2012-10-31T23:35:29.357', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4413', 'Tags': '<algorithms><finite-automata><proof-techniques>', 'CreationDate': '2012-10-31T17:37:32.330', 'FavoriteCount': '0', 'Id': '6404''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a beginners question. I and reading the book "Introduction to Computer Theory" by Daniel Cohen. But I end up with confusion regarding simplification of regular expressions and finite automata. I want to create an FA for the regular expression</p>\n\n<p>$\\qquad \\displaystyle (a+b)^* (ab+ba)^+a^+\\;.$</p>\n\n<p>My first question is that how we can simplify this expression? Can we we write the middle part as $(ab+ba)(ab+ba)^*$? will this simplify the expression?</p>\n\n<p>My second question is whether the automaton given below is equivalent to this regular expression? If not, what is the mistake?</p>\n\n<p><img src="http://i.stack.imgur.com/m4Agi.png" alt="enter image description here"></p>\n\n<p>This is not a homework but i want to learn this basic example. And please bear me as a beginner.</p>\n', 'ViewCount': '996', 'Title': 'Simplification of regular expression and conversion into finite automata', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T17:25:30.637', 'LastEditDate': '2012-11-02T10:10:37.237', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '6450', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<formal-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-11-02T08:12:01.797', 'Id': '6443''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So I\'ve been scratching my head over this problem for a couple of days now.  Given some language $A$ and $B$ that is regular, show that the language $L$ which consists of all strings in $A$ whose length is equal to some string in $B$ is a regular language.</p>\n\n<p>In equation form:</p>\n\n<p>$$L = \\{x \\in A \\mid \\exists y \\in B \\text{ s.t. } |x| = |y| \\}$$</p>\n\n<p>My initial thought was to try and come up with some DFA for both languages $A$ and $B$ and map the two states to each other and hopefully get a 1:1 ratio that way I can generate a new DFA which proves that $L$ is regular.  But then I realized that $A$ and $B$ don\'t have to be over the same set of symbols.  </p>\n\n<p>I think the correct way to solve this is to use the closure properties of regular language, but I\'m not sure of how to begin/use the properties for "lengths" of strings instead of strings themselves.  </p>\n\n<p>Could someone point me in the right direction?</p>\n', 'ViewCount': '255', 'Title': 'Proving the language which consists of all strings in some language is the same length as some string in another language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-08T04:07:41.613', 'LastEditDate': '2012-11-05T08:20:14.120', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4463', 'Tags': '<formal-languages><regular-languages><finite-automata><proof-techniques><closure-properties>', 'CreationDate': '2012-11-05T05:52:51.367', 'Id': '6484''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have some questions regarding acceptance of a language by DFA</p>\n\n<ol>\n<li>Whether more that one dfa accept a language  </li>\n<li>Whether a dfa can accept more than one language</li>\n</ol>\n', 'ViewCount': '305', 'Title': 'Language acceptance by DFA', 'LastActivityDate': '2012-11-10T02:32:03.653', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '6594', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><regular-languages><finite-automata>', 'CreationDate': '2012-11-10T01:29:26.060', 'Id': '6590''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently working on this question as part of some homework, it has me stumped.</p>\n\n<p><img src="http://i.stack.imgur.com/taFpH.png" alt="FSA Question"></p>\n\n<p>I\'m familiar with finite state automata (FSA), I know how they work and I\'ve read everything I can find on Google, but nothing\'s helped me come any closer to a solution.</p>\n\n<p>If I don\'t know the length of the input string, or I\'m not searching for a particular pattern, how can I design a machine that will always land on the final state? </p>\n\n<p>I\'ve tried drawing some, but that always end up being a little off. </p>\n', 'ViewCount': '71', 'Title': 'Finite State Automata for recognising consecutive characters', 'LastEditorUserId': '1636', 'LastActivityDate': '2012-11-17T09:02:53.670', 'LastEditDate': '2012-11-17T09:02:53.670', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6709', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4623', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2012-11-17T05:05:50.290', 'Id': '6704''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m constructing a <a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton" rel="nofollow">deterministic finite automata</a> (DFA) for a language of all strings defined over $\\{0,1\\}$ whose length is even and number of $1$s is odd. I constructed each DFA separately and then combined:</p>\n\n<p><img src="http://i.stack.imgur.com/rKHhw.png" alt="dfas and their union"></p>\n\n<ul>\n<li>Is the given procedure for combining DFAs correct?<br>\n<strong>EDIT:</strong> Originally wrote union; actually taking the intersection.</li>\n<li>Would someone suggest material on constructing DFAs<br>\ngiven restrictions on length and number of $0$s or $1$s?</li>\n</ul>\n\n<p>According to link given by Merbs, I have developed this FA. <img src="http://i.stack.imgur.com/ZMnEl.png" alt="enter image description here"> <br/> This FA does not accept a language of even length.</p>\n', 'ViewCount': '1097', 'Title': 'Is this intersection of DFAs correct?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:12:19.483', 'LastEditDate': '2013-05-24T03:12:19.483', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '7108', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<automata><regular-languages><finite-automata>', 'CreationDate': '2012-11-25T19:04:26.350', 'Id': '6893''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently studying for an exam for a course where some of the material covered included finite state automata, I\'ve completed a question and I\'m not sure about my answer.</p>\n\n<p><strong>Question</strong>\n<a href="http://i.stack.imgur.com/vDFax.png" rel="nofollow">http://i.stack.imgur.com/vDFax.png</a></p>\n\n<p><strong>My Answer</strong>\n<a href="http://i.stack.imgur.com/rSnEv.png" rel="nofollow">http://i.stack.imgur.com/rSnEv.png</a></p>\n\n<p>Are multiple completion states allowed?</p>\n', 'ViewCount': '186', 'Title': 'Finite state automata, multiple completion states?', 'LastActivityDate': '2012-11-27T00:06:05.017', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6935', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4623', 'Tags': '<automata><finite-automata>', 'CreationDate': '2012-11-26T23:33:22.737', 'Id': '6934''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given two regular languages $L_1$ and $L_2$, we define a new language </p>\n\n<p>$$L=\\{w_1w_2\\mid \\text{ there exist two words } x,y \\text{ such that } xw_1\\in L_1, w_2y\\in L2\\}$$</p>\n\n<p>How do I show that $L$ is regular with equivalence classes?</p>\n\n<p>My assignment allows the use of closure properties that all regular languages hold, but I cannot use $\\text{rank} (L)$, as in show a limit to the number of equivalence class.</p>\n\n<p>Can someone lead me in the right direction? </p>\n', 'ViewCount': '214', 'Title': 'Proving regularity via equivalence classes', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-19T05:17:59.307', 'LastEditDate': '2012-12-15T21:16:08.037', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5074', 'Tags': '<automata><regular-languages><finite-automata><proof-techniques>', 'CreationDate': '2012-12-15T20:27:22.903', 'FavoriteCount': '1', 'Id': '7419''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to create a DFA that can recognize strings with alphabet $\\{a,b,c\\}$ where $a$ and $c$ appear even number of times and where $b$ appears odd number of times.</p>\n\n<p>I am wondering that this may only be expressed with other methods such as Turing machine or context-free languages.</p>\n\n<p>You might find it fun to think of the solution.</p>\n', 'ViewCount': '199', 'Title': 'Does this DFA have a solution?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-16T16:29:32.997', 'LastEditDate': '2012-12-16T16:29:32.997', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7430', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5079', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-12-16T04:36:17.710', 'Id': '7429''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need some help with the following problem: $L$ - regular language and i have to prove that the language $P$ = {$\\alpha$| $\\beta\\alpha\\gamma \\in L$, $\\beta,\\gamma \\in (A)^*$} is regular. In other words $P$ is the language of all parts of words from $L$.   </p>\n\n<p>Thanks a lot!</p>\n', 'ViewCount': '66', 'Title': u'Regularity of \u201cmiddles\u201d of words from regular language', 'LastEditorUserId': '3011', 'LastActivityDate': '2012-12-24T22:25:40.707', 'LastEditDate': '2012-12-24T22:25:40.707', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7589', 'Score': '1', 'OwnerDisplayName': 'user54060', 'PostTypeId': '1', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2012-12-23T11:59:42.723', 'Id': '7588''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A true/false question: If a DFA $M$ contains a self-loop on some state $q$, then $M$ must accept an infinite language.</p>\n\n<p>The answer is "false". I\'ve read <a href="http://cs.stackexchange.com/questions/6609/infinite-language-vs-finite-language">this question</a>, but I\'m still wondering why $M$ does not necessarily accept an infinite language. Isn\'t the language $b^*$ infinite? Don\'t all self-loops look like $b^*$?</p>\n', 'ViewCount': '474', 'Title': 'Do self-loops in DFA cause infinite languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-17T13:36:18.223', 'LastEditDate': '2013-01-17T13:36:18.223', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '8983', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-01-17T07:53:01.867', 'Id': '8982''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>First, I have tried to build a DFA over the alphabet $\\sum = \\{0,\\dots, 9\\}$ that accepts all decimal representations of natural numbers divisible by 3, which is quite easy because of the digit sum. For this I choose the states $Q = \\mathbb{Z}/3\\mathbb{Z}\\cup\\{q_0\\}$ ($q_0$ to avoid the empty word), start state $q_0$, accept states $\\{[0]_3\\}$ and $\\delta(q, w) =\\begin{cases} [w]_3 &amp;\\mbox{if } q = q_0 \\\\\n[q + w]_3 &amp; \\mbox{else } \\end{cases}$</p>\n\n<p>Of course, it doesn't work that way for natural numbers divisible by 43. For 43 itself, I would end in $[7]_{43}$, which wouldn't be an accepting state. Is there any way I can add something there or do you have other suggestions on how to do this? Thanks.</p>\n", 'ViewCount': '486', 'Title': 'DFA that accepts decimal representations of a natural number divisible by 43', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-20T15:16:39.223', 'LastEditDate': '2013-01-20T15:13:05.993', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'Zlatansbraten', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-01-19T23:50:17.853', 'FavoriteCount': '1', 'Id': '9049''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The basic idea is to have one or more symbol that clearly indicate the end. For example:</p>\n\n<p>Non-ambiguous:</p>\n\n<blockquote>\n  <p>$ab^*c$<br>\n  $(a|b)c$<br>\n   $ab^+c$<br>\n   $ab?c$<br>\n   $a(b|c)$<br>\n   $c(ab)^*ccc$<br>\n   $acc^*d$<br>\n   $abc|bcd$  </p>\n</blockquote>\n\n<p>Ambiguous:</p>\n\n<blockquote>\n  <p>$abc^*$<br>\n  $abc^+$<br>\n  $abc?$<br>\n  $acc^*$ or $ac^*c$</p>\n</blockquote>\n\n<p>An alternative definition of a non-ambiguous ending would be that the corresponding DFA can have multiple final states, but none of them can have a outgoing transition.</p>\n', 'ViewCount': '194', 'Title': 'Is there a name/interest for regular languages that have a non-ambiguous ending?', 'LastEditorUserId': '1053', 'LastActivityDate': '2013-01-25T16:19:20.677', 'LastEditDate': '2013-01-25T15:20:19.237', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9094', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1053', 'Tags': '<regular-languages><finite-automata><regular-expressions><ambiguity>', 'CreationDate': '2013-01-22T12:50:22.110', 'Id': '9091''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '140', 'Title': 'Testing whether the language of one automaton is a subset of another', 'LastEditDate': '2013-01-25T11:32:27.240', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Jendas', 'PostTypeId': '1', 'OwnerUserId': '6541', 'Body': '<p>Is there an algorithm to solve following problem?</p>\n\n<p>Given two finite automata $A$ and $B$. Determine whether the language recognized by automaton $A$ is a subset of language recognized by automaton $B$ or otherwise.</p>\n', 'Tags': '<automata><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T11:32:27.240', 'CommentCount': '1', 'AcceptedAnswerId': '9131', 'CreationDate': '2013-01-24T11:28:05.360', 'Id': '9130''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '370', 'Title': "How come {ww} isn't regular when {uv | |u|=|v|} is?", 'LastEditDate': '2013-01-26T19:42:01.027', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'henry', 'PostTypeId': '1', 'OwnerUserId': '6576', 'Body': u'<p>As we know, using the pumping lemma, we can easily prove the language $L = \\{ w w \\mid w \\in \\{a,b\\}^* \\}$ is not a regular language.</p>\n\n<p>However, the language $L_1 = \\{ w_1 w_2 \\mid |w_1| = |w_2| \\}$ is a regular language. Because we can get the DFA like below, </p>\n\n<pre><code>DFA:  \n\n--\u25ba((even))------a,b---------\u25ba(odd)  \n      \u25b2                         |  \n      |--------a,b--------------| \n</code></pre>\n\n<p>My question is, $L = \\{ w w \\mid w \\in \\{a,b\\}^* \\}$ also has the even length of strings ($|w|=|w|$, definitely), so $L$ still can have some DFA like the one above. How come is it not a regular language?</p>\n', 'Tags': '<regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-27T05:20:46.897', 'CommentCount': '5', 'AcceptedAnswerId': '9176', 'CreationDate': '2013-01-26T16:53:57.553', 'Id': '9175''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1104', 'Title': 'Can we say DFA is more efficient than NFA?', 'LastEditDate': '2013-05-17T04:01:16.283', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'avi', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Body': "<p>I just started reading about theory of computation. If we compare which is more powerful (in accepting strings), both are same. But what about efficiency ? DFA will be fast compared to NFA, since it has only one outgoing edge &amp; there will be no ambiguity. But in case of NFA we have to check all possible cases &amp; that surely takes time. So can we say DFA is more efficient than NFA ? </p>\n\n<p>But, my other part of brain is also thinking that NFA exists only in theory, so we cannot compare it's efficiency with DFA. </p>\n", 'Tags': '<finite-automata><efficiency><nondeterminism>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-17T07:39:06.093', 'CommentCount': '0', 'AcceptedAnswerId': '9393', 'CreationDate': '2013-02-01T14:42:41.990', 'Id': '9389''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can I build a finite automaton that accepts only the language of all words in which <code>b</code> is the second letter?</p>\n\n<p>This is my solution so far but I\'m not sure if it\'s correct.</p>\n\n<p><img src="http://i.stack.imgur.com/f5Rcj.gif" alt=""></p>\n', 'ViewCount': '824', 'Title': 'Finite automaton for the language of words whose second letter is b', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-27T17:08:04.247', 'LastEditDate': '2014-03-27T17:08:04.247', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-5', 'PostTypeId': '1', 'OwnerUserId': '6726', 'Tags': '<finite-automata>', 'CreationDate': '2013-02-06T06:03:38.793', 'FavoriteCount': '0', 'Id': '9537''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am taking the <a href="https://class.coursera.org/compilers-selfservice/class/index" rel="nofollow">Coursera class</a> on compilers and in the lesson about lexers it is hinted that there is a time-space tradeoff between using non-deterministic finite automaton (NFA) and deterministic finite automaton (DFA) to parse regular expressions. If I understand correctly, the tradeoff is that a NFA is smaller, but is more time consuming to traverse because all possible states have to be regarded at the same time and therefore it is most of the time transformed into a DFA.  Are there any lexers that use NFAs instead of DFAs in "real"-life i.e. some compiler that is used in production and not a just a proof of concept?</p>\n', 'ViewCount': '200', 'Title': 'Are there real lexers that use NFAs directly instead of first transforming them to DFAs?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-05T19:53:06.097', 'LastEditDate': '2013-04-02T07:28:48.933', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6843', 'Tags': '<automata><finite-automata><compilers><efficiency><nondeterminism>', 'CreationDate': '2013-02-12T17:55:33.023', 'Id': '9708''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am learning about automata and finite state machines. Consider the following automaton, that accepts the word 'ab', does not have to be infinite, just once:</p>\n\n<p>alphabet: 'a','b'\nstates: 1,2, 3 (3 is the final state and 1 is the initial state)</p>\n\n<p>transitions:</p>\n\n<pre><code>state 1, symbol a, state 2\nstate 2, symbol b, state 3\n</code></pre>\n\n<p>First part of my questions:</p>\n\n<p>Question 1. Is it required to add self-loops at 1 for 'b', and a self-loop for 'a' at 2?</p>\n\n<p>Question 2. What about at state 3(final)? Should I add self-loops for 'a' and 'b'?</p>\n\n<p>I basically need to know, how to design my final state. So that even if my alphabet was expanded (say a, b, c), and I have a 'dump' state, with the following transitions:</p>\n\n<pre><code>state 1, symbol a, state 2\nstate 1, symbol b or c, state dump\n\nstate 2, symbol b, state 3\nstate 2 symbol a or c, state dump\n</code></pre>\n\n<p>Question 3. Now from final state 3, should I add a transition to dump state, with symbol values a,b,c ???</p>\n\n<p>Your assistance is much appreciated. </p>\n", 'ViewCount': '143', 'Title': 'design of self-loops and final states in fsm', 'LastEditorUserId': '6844', 'LastActivityDate': '2013-02-12T19:48:51.903', 'LastEditDate': '2013-02-12T19:16:08.193', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9713', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6844', 'Tags': '<finite-automata>', 'CreationDate': '2013-02-12T18:53:41.987', 'Id': '9711''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do you say $\\delta\\colon Q \\times \\Sigma \\to Q$ in English? Describing what $\\times$" and $\\to$ mean would also help.</p>\n', 'ViewCount': '92', 'Title': u'How does "\u03b4:Q\xd7\u03a3\u2192Q" read in the definition of a DFA (deterministic finite acceptor)?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-02-14T12:56:41.347', 'LastEditDate': '2013-02-14T09:28:07.567', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '9762', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6871', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2013-02-14T07:45:04.143', 'Id': '9761''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In the book <a href="http://rads.stackoverflow.com/amzn/click/0072322004" rel="nofollow">Introduction to Languages and the Theory of Computation</a>, I\'m reading section 2.6 on how to minimize the number of states in an FA.</p>\n\n<p>I\'m having trouble understanding a notation defined as $L_q$. Here\'s what the book says:</p>\n\n<blockquote>\n  <p>Suppose we have a finite automaton $M = (Q, \\Sigma, q_0, A, \\delta)$ accepting $L \\subseteq \\Sigma^*$. For a state $q$ of $M$, we have introduced the notation $L_q$ to denote the set of strings that cause $M$ to be in state $q$:</p>\n  \n  <p>$$L_q = \\{ x \\in \\Sigma^* | \\delta^*(q_0, x) = q\\}$$.</p>\n  \n  <p>The first step in reducing the number of states of M as much as possible is to eliminate every state $q$ for which $L_q$ = $\\emptyset$, along with transitions from these states. None of these states is reachable from the initial state, and eliminating them does not change the language accepted by $M$.</p>\n</blockquote>\n\n<p>I tried looking at this automaton to try to understand this definition:</p>\n\n<p><img src="http://i.stack.imgur.com/QpfNt.png" alt="enter image description here"></p>\n\n<p>How can any of the states $1$ through $5$ be $L_q = \\emptyset$ if I can find a string that can reach every state for this FA?</p>\n\n<p>That is I can reach state $2$ with string $a$, and state $5$ with string $ab$, etc. Is this a correct way to approach this?</p>\n', 'ViewCount': '57', 'Title': 'How to find $L_q = \\emptyset$, a state that is not reachable for any given string?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-14T20:45:34.953', 'LastEditDate': '2013-02-14T20:45:34.953', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9782', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-02-14T19:47:14.307', 'Id': '9781''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a simple problem of making a DFA which accepts all inputs starting with double letters (aa, bb) or ending with double letters (aa, bb), given $\\Sigma =\\{a, b\\}$ is the alphabet set of the given language.</p>\n\n<p>I tried to solve it in a roundabout way by:</p>\n\n<ol>\n<li>Generating a regular expression</li>\n<li>Making its corresponding NFA</li>\n<li>Using powerset construction to deduce a DFA</li>\n<li>Minimizing the number of states in DFA</li>\n</ol>\n\n<p><strong>Step 1:</strong> <em>Regular expression</em> for given problem is (among countless others):</p>\n\n<pre><code>((aa|bb)(a|b)*)|((a|b)(a|b)*(aa|bb))\n</code></pre>\n\n<p><strong>Step 2:</strong> <em>NFA</em> for given expression is:</p>\n\n<p><img src="https://qbcweg.sn2.livefilestore.com/y1pi4Jp5zdZjHEzQ61lYnqZtFu8DQ9B9qS0TyTX2HXh1ZJDDYAmokxBQf4orLezYEon6ct94vJJ18Z8AhfyBHHaBrVp18YEA8aa/automata%20question.jpg" alt="NFA"></p>\n\n<p>In Tabular form, NFA is:</p>\n\n<pre><code>State    Input:a     Input:b\n-&gt;1        2,5         3,5\n  2        4           -\n  3        -           4\n (4)       4           4\n  5        5,7         5,6\n  6        -           8\n  7        8           -\n (8)       -           -\n</code></pre>\n\n<p><strong>Step 3:</strong> Convert into a DFA using powerset construction:</p>\n\n<pre><code>Symbol, State       +   Symbol, State (Input:a) +   Symbol, State (Input:b)\n   -&gt;A, {1}         |        B, {2,5}           |        C, {3,5}\n     B, {2,5}       |        D, {4,5,7}         |        E, {5,6}\n     C, {3,5}       |        F, {5,7}           |        G, {4,5,6}\n   (D), {4,5,7}     |        H, {4,5,7,8}       |        G, {4,5,6}\n     E, {5,6}       |        F, {5,7}           |        I, {5,6,8}\n     F, {5,7}       |        J, {5,7,8}         |        E, {5,6}\n   (G), {4,5,6}     |        D, {4,5,7}         |        K, {4,5,6,8}\n   (H), {4,5,7,8}   |        H, {4,5,7,8}       |        G, {4,5,6}\n   (I), {5,6,8}     |        F, {5,7}           |        I, {5,6,8}\n   (J), {5,7,8}     |        J, {5,7,8}         |        E, {5,6}\n   (K), {4,5,6,8}   +        D, {4,5,7}         +        K, {4,5,6,8}\n</code></pre>\n\n<p><strong>Step 4:</strong> Minimize the DFA:</p>\n\n<p>I have changed K->G, J->F, I->E first. In the next iteration, H->D and E->F. Thus, the final table is:</p>\n\n<pre><code>  State    +   Input:a     +   Input:b\n   -&gt;A     |      B        |      C\n     B     |      D        |      E\n     C     |      E        |      D\n    (D)    |      D        |      D\n    (E)    |      E        |      E\n</code></pre>\n\n<p>And diagramatically it looks like:</p>\n\n<p><img src="https://yhtvma.sn2.livefilestore.com/y1pW43x0q2NHkqp6KEDLVS95HinOgTt-VM3obaUiIJvEe4yBNecx0abQh4P7HOC5Emj6sMnfqsDim0fk3kS0ovA-l3Rf7_GoCxB/automata%20question%20final%20dfa.jpg" alt="Final DFA"></p>\n\n<p>...which is not the required DFA! I have triple checked my result. So, where did I go wrong?</p>\n\n<p>Note:</p>\n\n<ul>\n<li>-> = initial state</li>\n<li>() = final state </li>\n</ul>\n', 'ViewCount': '561', 'Title': 'Not able to convert from NFA to DFA', 'LastEditorUserId': '4289', 'LastActivityDate': '2013-02-16T05:14:07.853', 'LastEditDate': '2013-02-16T05:04:21.590', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9793', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4289', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-02-14T22:56:54.687', 'Id': '9788''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do we find all equivalence classes of $\\mathsf{R_L}$ for a language? </p>\n\n<p>Say I\'m trying to look for all equivalent classes for the regular language $\\mathsf{L}$ is $011(0+1)^*011$.</p>\n\n<p>Here\'s an example they give us in the book\n<a href="http://books.google.com/books?id=VEHYzv0GHt8C&amp;pg=PA73&amp;lpg=PA73&amp;dq=ding+du+example+2.51&amp;source=bl&amp;ots=P8gAls0z7f&amp;sig=HIsMb7rcD3hKZHYzi8fYZsyrLQ8&amp;hl=en&amp;sa=X&amp;ei=5N0nUfSoJ6We2gWOv4HYDQ&amp;ved=0CDMQ6AEwAA" rel="nofollow">http://books.google.com/books?id=VEHYzv0GHt8C&amp;pg=PA73&amp;lpg=PA73&amp;dq=ding+du+example+2.51&amp;source=bl&amp;ots=P8gAls0z7f&amp;sig=HIsMb7rcD3hKZHYzi8fYZsyrLQ8&amp;hl=en&amp;sa=X&amp;ei=5N0nUfSoJ6We2gWOv4HYDQ&amp;ved=0CDMQ6AEwAA</a></p>\n\n<p>ps\nThe relation $\\mathsf{R_L}$ is an equivalent relation.\n$\\mathsf{R_L}$ on $\\Sigma^* as:$\n$xRy$ iff $(\\forall w)[xw \\in \\mathsf{L} \\Leftrightarrow yw \\in \\mathsf{L}]$</p>\n', 'ViewCount': '425', 'Title': 'DFA Minimization: Finding all equivalence classes of $\\mathsf{R_L}$ for language $011(0+1)^*011$', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-02-22T21:11:15.843', 'LastEditDate': '2013-02-22T21:07:31.420', 'AnswerCount': '1', 'CommentCount': '19', 'AcceptedAnswerId': '10030', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-02-22T19:56:41.727', 'Id': '10029''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was going through construction proofs for closure of regular languages under union, star and concatenation operation in the book: "<a href="http://rads.stackoverflow.com/amzn/click/053494728X" rel="nofollow">Introduction to Theory of Computation</a>" by Michael Sipser.</p>\n\n<p>I have doubts regarding how he wrote the transition function. </p>\n\n<p><img src="http://i.stack.imgur.com/R7KhO.jpg" alt="enter image description here"></p>\n\n<p>When $Q \\in F_1$ and $a=\\epsilon$ he wrote $\\delta_1(q,a) \\cup \\{q_2\\}$. I couldn\'t understand why its so. When the input is epsilon, the state moves to $q_2$ and what is the need for writing that $\\delta_1(q,a)$</p>\n\n<p>Also if that is so, the $A^*$ example he wrote for the transition function $\\{q_1\\}$ only  when $q=q_0$ and $a=\\epsilon$</p>\n', 'ViewCount': '171', 'Title': 'Closure of regular Language - Transition Function : Sipser Proof', 'LastEditorUserId': '947', 'LastActivityDate': '2013-04-27T13:09:00.637', 'LastEditDate': '2013-02-26T12:31:34.827', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><proof-techniques><finite-automata><nondeterminism>', 'CreationDate': '2013-02-26T11:47:09.320', 'Id': '10117''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '135', 'Title': 'Is The Following Language Regular?', 'LastEditDate': '2013-02-28T00:14:10.330', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Body': '<p>Let $L_{1}$ and $L_{2}$ be 2 languages over the same alphabet $\\Sigma$.  </p>\n\n<p>$$A(L_1,L_2)=\\{x\\in \\Sigma^*|\\exists y,z\\in L_2\\text{ such that } yxz\\in L_1\\}$$</p>\n\n<p>Assume that $L_{1}$ is regular and $L_{2}$ is context-free. The language $A(L_{1},L_{2})$:</p>\n\n<ol>\n<li>is always a regular language</li>\n<li>is always not a regular language</li>\n<li>can sometimes be a regular language</li>\n<li>cannot be context free</li>\n</ol>\n\n<p>They say that the correct answer is 1.</p>\n', 'ClosedDate': '2013-03-01T08:12:00.193', 'Tags': '<formal-languages><regular-languages><automata><context-free><finite-automata>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T03:38:56.220', 'CommentCount': '4', 'AcceptedAnswerId': '10163', 'CreationDate': '2013-02-27T23:51:15.260', 'Id': '10147''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Definition<br>\n  A family of circuits $(C_{1}, C_{2}, \\ldots)$ is uniform if some log\n  space transducer $T$ outputs $\\langle C_{n}\\rangle$ where $T$\'s input is $1^{n}$. (from <a href="http://en.wikipedia.org/wiki/Boolean_circuit#Uniform_Boolean_Circuits" rel="nofollow">http://en.wikipedia.org/wiki/Boolean_circuit#Uniform_Boolean_Circuits</a>)</p>\n</blockquote>\n\n<p>Can anyone exlain this? I know what boolean circuits are, so only explanation needed is what  and transducer exactly are.</p>\n', 'ViewCount': '106', 'Title': 'Definition of uniform boolean circuit', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T04:39:19.890', 'LastEditDate': '2013-03-01T03:49:03.477', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7084', 'Tags': '<complexity-theory><finite-automata><circuits>', 'CreationDate': '2013-03-01T02:09:59.500', 'Id': '10161''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a deterministic finite automaton which behaves mostly like a Turing machine, with following difference (relevant to this question):</p>\n\n<ul>\n<li>The tape is initially finite.</li>\n<li>The automaton can insert and delete cells from the tape.</li>\n<li>Actions are associated with states rather than with transitions (this includes head shift and tape manipulation).</li>\n<li>The automaton has no accepting/final state. The computation is only terminated when the machine exits the tape. The final state of the tape is the machine's output.</li>\n</ul>\n\n<p>I know most of the states in the machine are redudant (equivalent to other states). However the good old DFA minimization algorithm won't work here, because it starts its work on the final states (which I don't have).</p>\n\n<p>The algorithm should be efficiently computable (the machines in question have hundreds of thousands to millions of states).</p>\n\n<p>Is this possible in the general case? Every algorithm I make up fails in some cases.</p>\n", 'ViewCount': '123', 'Title': 'Minimizing Turing machine-like automaton with no final states', 'LastActivityDate': '2013-03-01T15:14:45.800', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10176', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7094', 'Tags': '<turing-machines><automata><finite-automata>', 'CreationDate': '2013-03-01T15:02:56.103', 'Id': '10175''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1427', 'Title': 'DFA to regular expression conversion', 'LastEditDate': '2013-03-02T00:16:02.467', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was looking at the question <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a> to convert DFA to regex.</p>\n\n<p>The question, I was trying to solve is:</p>\n\n<p><img src="http://i.stack.imgur.com/e7YPr.jpg" alt="enter image description here"></p>\n\n<p>I have got the following equations:</p>\n\n<p>$Q_0=aQ_0 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>$Q_1=aQ_1 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>When solved, we will get $Q_0=a^*b(a \\cup b)^* \\cup\\ \\epsilon$</p>\n\n<p>But my doubt is that, in the DFA starting state is also the final state so, even if we dont give any $b$, it will be accepted, if we give some $a$. But in the regex we have $b$, instead of $b^*$. Why is it so? Is it because,we have that regex $\\cup$ $\\epsilon$ ?</p>\n', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'LastEditorUserId': '947', 'LastActivityDate': '2013-03-02T01:00:05.917', 'CommentCount': '2', 'AcceptedAnswerId': '10184', 'CreationDate': '2013-03-01T17:26:49.227', 'Id': '10180''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for practical applications of Finite State Machines like DFA, NFA, Moore, Mealy machines...</p>\n\n<p>It would be helpful if someone point to examples from Linux Kernel. I know that DFA is used in string matching like KMP algorithm.</p>\n\n<p>What is the significance of NFA, Moore and Mealy machines?</p>\n', 'ViewCount': '1145', 'Title': 'Practical application of Finite State Machines', 'LastActivityDate': '2013-03-06T19:32:54.840', 'AnswerCount': '4', 'CommentCount': '3', 'AcceptedAnswerId': '10290', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<reference-request><automata><finite-automata>', 'CreationDate': '2013-03-05T03:25:55.350', 'FavoriteCount': '3', 'Id': '10280''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have used FSM in Digital sequential Circuit designs. But I am unfamiliar with Finite Automata. Can somebody help me in understanding 'basic' difference between the two ?    </p>\n", 'ViewCount': '2471', 'Title': 'What is the difference between finite automata and finite state machines?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-09T18:01:35.117', 'LastEditDate': '2013-03-07T15:39:44.790', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2013-03-07T10:44:05.670', 'FavoriteCount': '2', 'Id': '10357''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a regular language $L$, can we say anything about its complement $\\overline L$? One thing that is trivial to say is that the DFA's for both languages are equal in size as complementing the language is simply a matter of changing all accepting states into rejecting states and vice-versa. Are there any other things to conclude? Is there anything one can say about the number of states of a (minimal) NFA?</p>\n", 'ViewCount': '272', 'Title': 'Can we say anything about the complement of a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-12T10:28:18.477', 'LastEditDate': '2013-03-12T10:28:18.477', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'FUZxxl', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<regular-languages><finite-automata><closure-properties>', 'CreationDate': '2013-03-11T14:18:52.303', 'Id': '10458''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>E.g.</p>\n\n<p><strong>Matching Problem</strong> The DFA of regex <code>good</code> is like a chain.</p>\n\n<pre><code>match:     "good"\nnot match: "people do not give good comments are not good people"\n</code></pre>\n\n<p><strong>Searching Problem</strong> The DFA used in searching regex <code>good</code> could be:</p>\n\n<p><img src="http://i.stack.imgur.com/BcnoQ.jpg" alt="enter image description here"></p>\n\n<pre><code>1 matching:  "good"\n2 matchings: "people do not give good comments are not good people"\n</code></pre>\n\n<p>Here are the questions:</p>\n\n<ol>\n<li>In the above two problems, it seems the searching problem\'s DFA is the matching problem\'s DFA plus some backedges and an additional state (here state <code>0</code>). Is this the difference in general?</li>\n<li>What is the regex of searching problem in this case?</li>\n</ol>\n', 'ViewCount': '139', 'Title': 'Difference between pattern matching and pattern searching in terms of DFA/Regex', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T18:51:02.610', 'LastEditDate': '2013-03-20T11:08:46.557', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'JackWM', 'PostTypeId': '1', 'Tags': '<finite-automata><regular-expressions><search-algorithms>', 'CreationDate': '2013-03-19T00:16:58.863', 'Id': '10632''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need to find a minimal DFA given the following information: </p>\n\n<blockquote>\n  <p>$ \\{a^nb : n\\geq 0\\} \\cup \\{b^na: n \\geq 1\\}$</p>\n</blockquote>\n\n<p>Now, maybe I'm not seeing this properly, but I don't see how this is possible: the first one will take 0 or more a's followed by one b, whereas the second one will take a 1 or more b's followed by one a.</p>\n\n<p>Drawing the combined automata only brought me to trap states. Any suggestions?</p>\n", 'ViewCount': '311', 'Title': 'Union of two automata', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-23T03:41:04.227', 'LastEditDate': '2013-03-23T03:41:04.227', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10685', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-03-21T17:34:51.983', 'Id': '10684''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>Recently, I asked a <a href="http://math.stackexchange.com/q/334581/17111">question</a> on Math SE. No response yet. This question is related to that question, but more technical details toward computer science.</em></p>\n\n<p>Given two DFAs $A = (Q, \\Sigma, \\delta, q_1, F_1)$ and $B = (Q, \\Sigma, \\delta, q_2, F_2)$ where the set of states, the input alphabet and the transition function of $A$ and $B$ are the same, the initial states and the final(accepting) states could be different. Let $L_1$ and $L_2$ be the languages accepted by $A$ and $B$, respectively.</p>\n\n<p>There are four cases:</p>\n\n<ol>\n<li>$q_1 = q_2$ and $F_1 = F_2$.</li>\n<li>$q_1 \\neq q_2$ and $F_1 = F_2$.</li>\n<li>$q_1 = q_2$ and $F_1 \\neq F_2$.</li>\n<li>$q_1 \\neq q_2$ and $F_1 \\neq F_2$.</li>\n</ol>\n\n<p>My question is</p>\n\n<blockquote>\n  <blockquote>\n    <p>What are the differences between $L_1$ and $L_2$\n     in cases 2, 3 and 4?</p>\n  </blockquote>\n</blockquote>\n\n<p>I have a more specific question along this line,</p>\n\n<p>The transition monoid of an automaton is the set of all functions on the set of states\ninduced by input strings. See <a href="http://en.wikipedia.org/wiki/Semiautomaton">the page</a> for more details. The transition monoid can be regarded as a monoid acting on the set of states. See this <a href="http://en.wikipedia.org/wiki/Semigroup_action">Wiki page</a> for more details.</p>\n\n<p>In many literatures, an automaton is called strongly connected when the monoid action is transitive, i.e. there is always at least one transition (input string) from one state to another state.</p>\n\n<blockquote>\n  <blockquote>\n    <p>If $A$ and $B$ are strongly connected automata, what are the differences between $L_1$ and $L_2$ in cases 2, 3 and 4 above?</p>\n  </blockquote>\n</blockquote>\n\n<p>Any literatures discussing these issues in details?</p>\n\n<p>I have searched many books and articles and found nothing helpful so far. I believe I don\'t have the appropriate key words yet. Thus I am seeking help. Any pointers/references will be appreciated very much.</p>\n', 'ViewCount': '170', 'Title': 'Difference between the languages accepted by two DFAs with different initial state/accepting states?', 'LastActivityDate': '2013-03-24T11:48:30.127', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10737', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '630', 'Tags': '<formal-languages><reference-request><finite-automata>', 'CreationDate': '2013-03-24T03:40:45.747', 'FavoriteCount': '1', 'Id': '10733''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '391', 'Title': 'Can a Turing Machine decide if an NFA accepts a string of prime length?', 'LastEditDate': '2013-03-28T10:11:57.990', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'user2216670', 'PostTypeId': '1', 'OwnerUserId': '7450', 'FavoriteCount': '1', 'Body': "<p>I want to know if the following problem is decidable:</p>\n\n<p>Instance: An NFA A with n states</p>\n\n<p>Question: Does there exist some prime number p such that A accepts some string of length p.</p>\n\n<p>My belief is that this problem is undecidable, but I can't prove it. The decider can easily have an algorithm to figure out if a particular number is prime, but I don't see how it would be able to analyze the NFA in enough detail to know exactly what lengths it can produce. It could start testing strings with the NFA, but for an infinite language, it may never halt (and thus not be a decider).</p>\n\n<p>The NFA can easily be changed to a DFA or regular expression if the solution needs it, of course.</p>\n\n<p>This question is something I've been pondering as a self-made prep question for a final I have coming up in 2 weeks.</p>\n", 'Tags': '<computability><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T10:11:57.990', 'CommentCount': '3', 'AcceptedAnswerId': '10851', 'CreationDate': '2013-03-27T17:28:14.523', 'Id': '10848''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Earlier I asked the question: <a href="http://cs.stackexchange.com/questions/10848/can-a-turing-machine-decide-if-an-nfa-accepts-a-string-of-prime-length">Can a Turing Machine decide if an NFA accepts a string of prime length?</a>. The answer introduced me to Parikh\'s theorem, which I\'ve been reading about. The concept of Parikh\'s theorem, if we apply it to regular expressions, allows us to break down a regular expression into expressions that only have one level of Kleene-star nesting.</p>\n\n<p>So: $aa(b(cc)^*)^*$ can have a list of expressions created using the same methodology as Parikh\'s theorem where none of the new expressions in the final list has nested Kleene-stars. The linear subsets will use starred expressions </p>\n\n<p>To make it more clear, I\'m referencing this paper: <a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow"><a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow">http://people.inf.ethz.ch/torabidm/par-ext.pdf</a></a>.</p>\n\n<p>I\'m not too concerned with it actually being a regular expression, DFAs or NFAs would work fine. It seems easier to work with as an RE.</p>\n\n<hr>\n\n<p>I want to know if the problem is decidable:</p>\n\n<p><strong>Instance</strong>: A regular expression $R$</p>\n\n<p><strong>Question</strong>: Does there exist some length $l \\ge 1$ such that $R$ accepts every string of that length (ie. if its alphabet is $\\Sigma$, it accepts $\\Sigma^l$, for some $l \\ge 1$.</p>\n\n<hr>\n\n<p>I\'m pretty sure the problem actually is decidable but it\'s a tough one. I\'ve enjoyed pondering it so far and would love to see what someone more experienced than myself can come up with.</p>\n', 'ViewCount': '359', 'Title': 'Can a Turing Machine decide if a regular expression matches all strings of exactly some length $l \\geq 1$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-02T07:22:55.830', 'LastEditDate': '2013-03-29T18:35:42.483', 'AnswerCount': '3', 'CommentCount': '8', 'AcceptedAnswerId': '10880', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7450', 'Tags': '<computability><finite-automata><regular-expressions>', 'CreationDate': '2013-03-28T20:10:53.063', 'Id': '10879''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>$L = \\{a^n b^m | m \\not= n^2 \\}$ \nI guess I need to use Pumping Lemma for CFL in order to prove this. But I'm stuck.</p>\n\n<p>Assuming that $ a^n b^m = uvxyz$, we know that $v$ or $y$ can not have both $a$ and $b$ symbols in them. Otherwise pumping would generate strings not of the form $a^i b^j$.</p>\n\n<p>Hence both $v$ and $y$ must consist only of one kind of symbol each.\nBeyond this I wonder what string in $L$ has to be chosen in order to pump and obtain something of the form $a^n b^{n^2}$.</p>\n\n<p><em><strong>Alternative idea :</em></strong> Assuming that $L$ is context-free, then I must have a PDA accepting it by final state. Can I say that this PDA can be adjusted* to accept $L'$ i.e., all $a^n b^{n^2}$ ? However I know that $L'$ is not a CFL. Hence, contradiction ?</p>\n\n<p>*Adjusted = Make the non-final state on reading $a^n b^{n^2}$ as final and the rest as all non-final.</p>\n", 'ViewCount': '223', 'Title': 'Why is the following language not context-free?', 'LastEditorUserId': '7620', 'LastActivityDate': '2013-04-10T11:05:56.600', 'LastEditDate': '2013-04-08T15:54:42.337', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7620', 'Tags': '<formal-languages><context-free><automata><finite-automata><pumping-lemma>', 'CreationDate': '2013-04-07T18:09:51.310', 'Id': '11106''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have an exam coming up and I need help with the following homework:</p>\n\n<blockquote>\n  <p>Given an NFA $A$ and a regular expression $B$, consider the problem of determining if $L(A) = L(B)$. Is this decidable? Prove your answer.</p>\n</blockquote>\n', 'ViewCount': '135', 'Title': 'Given an NFA A and a regular expression B, is the problem of determining L(A) = L(B) decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:55:24.693', 'LastEditDate': '2013-04-08T14:55:24.693', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7639', 'Tags': '<automata><finite-automata><undecidability><regular-expressions>', 'CreationDate': '2013-04-08T10:13:25.680', 'Id': '11138''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This may be a silly question. It seem clear that an FSA, since it is finite, can only count the number of symbols in its input string up to a number bounded by the number of its states. But now suppose we equip the FSA with output (e.g. printing) capabilities. It would then be <em>very</em> easy to construct a machine capable of printing one symbol for each symbol that it reads. Would that count as counting? If not, why not?</p>\n\n<p>To put it in terms of FSTs instead: I take it that it is not possible to construct an FST capable of mapping a string of an arbitrary length to a binary representation (i.e. a number in the base-2 numeral system) of its length. But it IS of course trivial to construct an FST capable of mapping a string of arbitrary length to a string of says zeroes (or ones) of the same length. But that could count as counting, could it not, beacuse what the FST is doing is building a representation of the length of its input. A somewhat odd representation, but still a representation, is it not?</p>\n', 'ViewCount': '353', 'Title': 'Can an FSA count?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:52:44.130', 'LastEditDate': '2013-04-10T08:52:44.130', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '6', 'OwnerDisplayName': u'Torbj\xf6rn', 'PostTypeId': '1', 'OwnerUserId': '7657', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-04-09T07:58:38.200', 'Id': '11155''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Considering this FSM:\n<img src="http://i.stack.imgur.com/aIh8C.jpg" alt="finite state machine"></p>\n\n<p>Can someone explain me why the grammar is not:</p>\n\n<ol>\n<li>$S \\rightarrow aA$</li>\n<li>$A \\rightarrow aA \\mid bB \\mid \\varepsilon$</li>\n<li>$B \\rightarrow bB \\mid \\varepsilon$</li>\n</ol>\n\n<p>Why does A not have a transition to $\\varepsilon$?</p>\n', 'ViewCount': '86', 'Title': 'Simple FSM question', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-10T11:08:20.773', 'LastEditDate': '2013-04-09T18:35:08.000', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11167', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1626', 'Tags': '<formal-grammars><finite-automata>', 'CreationDate': '2013-04-09T18:07:59.410', 'Id': '11166''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How would I go about using Cartesian construction to find the intersection between a PDA and a DFA?</p>\n\n<p>Is there another term for Cartesian construction? Would it be similar to the procedure for finding the intersection/union of 2 DFAs?</p>\n', 'ViewCount': '175', 'Title': 'Cartesian construction of PDA and DFA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T20:15:03.627', 'LastEditDate': '2013-04-10T20:15:03.627', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<automata><finite-automata><pushdown-automata>', 'CreationDate': '2013-04-10T18:43:39.247', 'Id': '11201''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '173', 'Title': 'Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular', 'LastEditDate': '2013-04-30T15:54:36.220', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7492', 'FavoriteCount': '1', 'Body': "<p>Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular.</p>\n\n<p>These are the things that I would use to start.</p>\n\n<ul>\n<li>As $L_1L_2$ is regular, then the homomorphism $h(L_1L_2)$ is regular.</li>\n<li>Let $h(L_1) = L_2$ and $h(L_2) = L_1$, then $h(L_1L_2) = L_2L_1$ is regular (we already know that) or $h(L_2) = \\epsilon$ and we get $L_1$</li>\n<li>By reflexing, $L_1L_2 = (L_2L_1)^{R}$, same result.</li>\n</ul>\n\n<p>But i don't know how to, for example, intersect something that gives me $L_1$ in order to preserve closure and finally $L_1$ be regular.</p>\n\n<p>Any help?</p>\n", 'Tags': '<regular-languages><finite-automata><proof-techniques><closure-properties>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-30T15:54:36.220', 'CommentCount': '0', 'AcceptedAnswerId': '11596', 'CreationDate': '2013-04-27T03:06:35.000', 'Id': '11592''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The regular expression $a^{3}b^{+}$ is indeed regular because we can define an automata $M$. But I see that $\\mathcal{L} = \\{a^{3}b^{n}, n \\geq 1\\}$ may generate the same strings, but using the pumping lemma with constant $N$ for a substring $\\alpha\\beta = a^{3}b^{t},|\\alpha\\beta| \\leq N$, let $\\alpha = a$ and $\\beta = a^{2}b^{t}$, therefore $\\gamma = b^{N-t}$, and when $k = 0$, $\\sigma = \\alpha \\beta^{0} \\gamma = \\alpha \\gamma = ab^{N-t}$, which doesn't belong to $\\mathcal{L}$ and the language isn't regular.</p>\n\n<p>So, is really the regex equal to $\\mathcal{L}$? or am I pumping wrong?</p>\n", 'ViewCount': '62', 'Title': 'Is the language $a^{3}b^{+}$ the same as $\\{a^{3}b^{n}, n \\geq 1\\}$ ? and what is the result of pumping this?', 'LastActivityDate': '2013-04-28T04:30:58.543', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11621', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7492', 'Tags': '<regular-languages><finite-automata><regular-expressions><pumping-lemma>', 'CreationDate': '2013-04-28T03:39:32.733', 'FavoriteCount': '1', 'Id': '11619''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Basically, I currently have two ideas but unsure on which is correct for the following question:\n"The High level data link control protocol (HDLC), is a popular protocol used for point-to-point data communication. In HDLC, data are organised into frames which begin and end with the sequence 01111110. This sequence never occurs within the main body of the frame, only at the beginning and end (in order to avoid confusion).</p>\n\n<p>a.)Design an NFA which recognises the language of binary strings which contain one or more HDLC frames"</p>\n\n<p>My possible solutions:\n<a href="http://tinypic.com/r/2bnq4m/5" rel="nofollow">http://tinypic.com/r/2bnq4m/5</a></p>\n\n<p>The next part is to convert to DFA, but I first need to get this part right</p>\n', 'ViewCount': '339', 'Title': 'NFA to recognize bit strings containing 01111110', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-20T17:56:49.680', 'LastEditDate': '2013-07-29T08:00:06.633', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-05-04T20:07:13.117', 'Id': '11780''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can we design a regular expressions without particular substrings.\nThe goal of this is to create language <code>L</code> which won't contain a particular substring (i.e. 110)</p>\n\n<p>for the case of a regular expression without substring $110$, I Was thinking of: $\\require{cancel}\\cancel{(101)^*+}(010)^*+(10)^*+(\\cancel{1}1)^*+(\\cancel{0}0)^*+(01)^*$ but is that over excessive?</p>\n\n<p>Then for example, I crossed out (101)* because obviously if you have two of those 101101, a subset of that will be 110, which we don't want.</p>\n\n<h3>Notes:</h3>\n\n<p>Question has been edited since it gained attention in the past few days. Also see comment for justification.</p>\n", 'ViewCount': '3292', 'Title': 'Regular expression for the strings without a particular substring', 'LastEditorUserId': '6980', 'LastActivityDate': '2014-01-31T12:46:01.967', 'LastEditDate': '2014-01-31T12:46:01.967', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '11791', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-05-04T23:46:05.660', 'Id': '11787''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have my own version of <code>lex</code> and I would like to add the complement operation. Derived from that I can then add the intersection and difference also. My version also supports the generation of NFAs (Non-deterministic Finite Automaton) and of course I try to keep the automatons as small as possible.</p>\n\n<p>My question thus is: what is the most optimal known upper bound on the number of states in the NFA that accepts the complement of another NFA? Of course going through the conversion to a DFA (Deterministic Finite Automaton) and then interchanging accepting and rejecting states, gives an exponential upper bound. Are there any better known upper bounds? Preferably polynomial or even linear of course.</p>\n\n<p>If no better upper bound is known, has it been shown that for some family of languages the lower bound is exponential or otherwise super polynomial?</p>\n', 'ViewCount': '96', 'Title': 'Optimal upper bound on the number of states in the complement of an NFA', 'LastActivityDate': '2013-05-05T12:58:46.023', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11804', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7970', 'Tags': '<finite-automata>', 'CreationDate': '2013-05-05T09:49:53.543', 'FavoriteCount': '1', 'Id': '11802''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm doing some research regarding NFAs and inclusion problems with them. I know that in general, the inclusion problems, and converting to an unambiguous NFA, are both PSPACE-complete.</p>\n\n<p>I'm wondering, are there any sub-classes of NFA for which these can be decided efficiently? In particular, the NFAs I'm looking at accept finite language where all words have the same Parikh vector.</p>\n", 'ViewCount': '107', 'Title': 'Classes of NFAs which allow efficient subset testing or unambiguity conversions', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-06-13T16:33:18.830', 'LastEditDate': '2013-05-06T23:38:41.717', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-05-06T22:26:42.443', 'FavoriteCount': '1', 'Id': '11841''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was asked this question at an interview, and couldn't answer it, and would like to know how it is 'shown' that two Turing machines which accept the same language is undecidable. This is not a homework question!</p>\n", 'ViewCount': '482', 'Title': 'Show that it is undecidable if two Turing Machines accept the same language', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-05-14T03:12:53.943', 'LastEditDate': '2013-05-09T20:06:15.133', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8104', 'Tags': '<algorithms><computability><finite-automata><undecidability>', 'CreationDate': '2013-05-09T17:18:46.500', 'Id': '11916''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>So I\'ve been trying to crack this for a long time and almost feel like I am going in loops about this question.</p>\n\n<p>Given the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hL3Ps.png" alt="enter image description here"></p>\n\n<p>Using the GNFA algorithm get the regular expression.</p>\n\n<p>I understand that you would have the following for the first step(adding empty states):\n<img src="http://i.stack.imgur.com/6XXjj.png" alt="enter image description here"></p>\n\n<p>The next step would be removing the state [q1] I would get:\n<img src="http://i.stack.imgur.com/cwjUd.png" alt="enter image description here"></p>\n\n<p>Finally removing [q2] would get:\n<img src="http://i.stack.imgur.com/WW3Fj.png" alt="enter image description here"></p>\n\n<p>However the answers others have got is:\n$(a \\cup bb^*a)^*bb^*$\nWhich does not make sense as I got, $a^*b(b \\cup aa^*b)^*$?\nA GNFA(generalised nondeterministic finite automaton) is described as follows:</p>\n\n<p>A GNFA is similar to an NFA but must obey certain rules: </p>\n\n<ul>\n<li>It has only one accept state</li>\n<li>The initial state has no transitions coming into it</li>\n<li>The accept state has no transitions coming out from it</li>\n<li>A transition can denote any regular expression, rather than just a\nsymbol from the alphabet Note that a symbol is a kind of regular\nexpression.</li>\n</ul>\n\n<p>Furthermore, We may convert an NFA into a GNFA as follows: </p>\n\n<ul>\n<li>Add a new start state with an \u03b5-transition to the old start state</li>\n<li>Add a new accept state with \u03b5-transitions from the old accept states</li>\n<li>If arrows have multiple labels, or if there are multiple arrows\nbetween two states, replace them with the union (or) of those labels</li>\n</ul>\n', 'ViewCount': '2097', 'Title': 'Converting an NFA to regex using GNFA algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:23:30.563', 'LastEditDate': '2013-05-12T10:23:30.563', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '11950', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata><regular-expressions><nondeterminism>', 'CreationDate': '2013-05-10T14:50:56.853', 'Id': '11935''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am converting NFA <b>with $\\varepsilon$-moves </b> to the NFA <b>without </b> $\\varepsilon$-null moves. I understand that if, there is a $\\varepsilon$-move between, $q_i$ and $q_j$, then all edges from $q_j$ have to be repeated from $q_i$. And if the $q_j$ is a final state, then $q_i$ will also be a final state.</p>\n\n<p>But, if $q_j$ does not contain any transition, i.e., there are no edges starting from $q_j$, then what has to be done? </p>\n', 'ViewCount': '673', 'Title': 'How to convert NFA with null moves to NFA without null moves?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-05-16T16:06:25.040', 'LastEditDate': '2013-05-14T06:58:57.550', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8155', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-05-14T05:56:21.350', 'Id': '12003''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can the set of states Q be empty by definition?</p>\n\n<p>I was wondering about this question when doing exercises in the pumping lemma for finite automaton.</p>\n', 'ViewCount': '92', 'Title': 'DFA: Can the set of States Q be empty by definition?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-22T08:01:43.090', 'LastEditDate': '2013-05-22T08:01:43.090', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12167', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8272', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2013-05-20T19:52:43.710', 'Id': '12166''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Question:The set of all first names given to children born in New Zealand in 1996</p>\n\n<p>I think this language is regular because every element in the set can be a accept state</p>\n\n<p>How can I prove if the language is regular?</p>\n', 'ViewCount': '65', 'Title': 'Regular language proving', 'LastEditorUserId': '157', 'LastActivityDate': '2013-05-25T00:56:19.277', 'LastEditDate': '2013-05-25T00:56:19.277', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8341', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-05-24T22:06:59.133', 'Id': '12256''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it theoretically possible to have a nondeterministic finite state machine without any initial state or does it need at least one initial state?</p>\n', 'ViewCount': '122', 'Title': 'Nondeterministic finite state machine without any initial state possible', 'LastActivityDate': '2013-05-29T15:15:48.100', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8414', 'Tags': '<formal-languages><regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2013-05-28T18:27:39.930', 'Id': '12338''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<blockquote>\n  <p>Describe a (general) procedure that, given some finite automaton M, produces a new finite automaton M\u2019 with:  M\u2019 rejects \u03b5, but accepts otherwise the identical language as M does.Note that M may or may not accept \u03b5, while M\u2019 does not!</p>\n</blockquote>\n\n<p>My solution is to discuss the different cases. If M doesn't contain \u03b5, then, don't need to produce a new M', but if M contains \u03b5-transition, then convert it to DFA. I'm not sure my procedure is right or not.</p>\n\n<p>Can someone come up with some more effective idea?</p>\n", 'ViewCount': '160', 'Title': 'Given NFA to recognize a language, construct a new NFA for that language without the empty string', 'LastEditorUserId': '755', 'LastActivityDate': '2013-07-26T06:14:57.440', 'LastEditDate': '2013-07-26T06:14:57.440', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-06-10T02:54:21.953', 'Id': '12579''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If not, then what does it mean when for some state $q$ and some symbol $a$, $\\delta(q, a)$ does not exist?</p>\n', 'ViewCount': '667', 'Title': 'In a DFA, does every state have a transition on every symbol of the alphabet?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T22:42:05.853', 'LastEditDate': '2013-06-10T11:16:39.073', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '12596', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2013-06-10T05:15:52.510', 'Id': '12587''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Of course, converting NFA to DFA is not a problem. But what about the other direction?</p>\n\n<p>My motivation is the notion of minimization regular expressions using the DFA minimization algorithm.</p>\n', 'ViewCount': '123', 'Title': 'Can we minimise regular expressions using known DFA minimisation algorithms?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-11T16:57:51.563', 'LastEditDate': '2013-06-11T16:57:51.563', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '1', 'OwnerDisplayName': 'Jendas', 'PostTypeId': '1', 'OwnerUserId': '6541', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-06-11T08:51:24.510', 'Id': '12612''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Or at least generate a set of strings that one NFA accepts, so I can feed it into the other NFA.  If I do a search through every path of the NFA, will that work?  Although that will take a long time.</p>\n', 'ViewCount': '149', 'Title': 'Is there a way to test if two NFAs accept the same language?', 'LastActivityDate': '2013-06-11T18:47:24.080', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12625', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<algorithms><regular-languages><finite-automata>', 'CreationDate': '2013-06-11T17:23:26.430', 'FavoriteCount': '1', 'Id': '12624''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '409', 'Title': 'Why is NFA minimization a hard problem when DFA minimization is not?', 'LastEditDate': '2013-06-15T18:22:30.120', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I know that we can minimize DFAs by finding and merging equivalent states, but why can't we do the same with NFAs?  I'm not looking for a proof or anything like that--unless a proof is simpler to understand.  I just want to understand intuitively why NFA minimization is so hard when DFA minimization is not.</p>\n", 'Tags': '<complexity-theory><finite-automata><nondeterminism>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-06-18T03:28:02.137', 'CommentCount': '0', 'AcceptedAnswerId': '12712', 'CreationDate': '2013-06-15T17:57:35.147', 'Id': '12693''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '141', 'Title': 'Are HTML and CSS regular languages?', 'LastEditDate': '2013-06-24T17:18:01.450', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8839', 'FavoriteCount': '1', 'Body': '<p>I have a question whether or not CSS and HTML are regular languages.</p>\n\n<p>I believe CSS is a regular language, since it should be possible to create a regular expression to match the structure of CSS.</p>\n\n<p>However, I believe that HTML is <strong>not</strong> a regular language since you have nested attributes that could be defined recursively.</p>\n', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-24T17:18:01.450', 'CommentCount': '7', 'AcceptedAnswerId': '12869', 'CreationDate': '2013-06-24T14:45:41.140', 'Id': '12867''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '236', 'Title': 'What is a good algorithm for generating random DFAs?', 'LastEditDate': '2013-06-29T08:40:23.377', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I am generating random DFAs to test a DFA reduction algorithm on them.</p>\n\n<p>The algorithm that I'm using right now is as follows: for each state $q$, for each symbol in the alphabet $c$, add $\\delta (q, c)$ to some random state.  Each state has the same probability of becoming a final state.</p>\n\n<p>Is this a good method of generating unbiased DFAs?  Also, this algorithm doesn't generate a trim DFA (a DFA with no obsolete states) so I'm wondering if there is a better way of generating random DFAs that can somehow ensure that it is trim?</p>\n", 'Tags': '<algorithms><finite-automata><random><pseudo-random-generators><random-graphs>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-18T10:13:05.943', 'CommentCount': '9', 'AcceptedAnswerId': '12949', 'CreationDate': '2013-06-28T05:14:15.410', 'Id': '12943''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given s as a string of some alphabet, what is the best known algorithm to compute a corresponding automaton that accepts any string that contains s?</p>\n\n<p>I am mostly intrested of the lowest time complexity so if you tell me what is the best known complexity in O notation to build an automaton for a string that would be just as good.</p>\n', 'ViewCount': '256', 'Title': 'Automaton for substring matching', 'LastEditorUserId': '1033', 'LastActivityDate': '2013-07-02T07:49:31.180', 'LastEditDate': '2013-07-01T12:02:13.157', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1033', 'Tags': '<automata><finite-automata><strings><substrings>', 'CreationDate': '2013-07-01T10:48:25.027', 'Id': '13009''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm doing some research with NFAs, and I'm wondering there are algorithms which quasi-efficiently minimize them. I realize that this problem is $PSPACE$ hard, so I'm not looking for a polynomial time algorithm.</p>\n\n<p>What I mean by this is an algorithm which may run in exponential time in the worst cases, but which uses some sort of heuristic to speed up the process, albiet not enough to make it exponential.</p>\n\n<p>I'm only using this to try to get a better idea of what the minimal NFAs of certain languages look like. I'm not using it in any production code, so it doesn't need to be blazingly fast.</p>\n\n<p>For example, the Antichains algorithm for NFAs does equivalence testing which is usually fast but sometimes has exponential explosion. I'm looking for something similar, but for minimization.</p>\n\n<p>Note that I'm NOT looking for things like equivalences, etc. which run efficiently but don't produce a minimal NFA.</p>\n\n<p>Bonus points to anyone who find one with an implementation, and quadruple bonus points if it's in Prolog or Python.\nIf the tool I'm looking for doesn't exist, I'd be happy if anyone gave any old implementation of NFA minimization.</p>\n", 'ViewCount': '152', 'Title': 'Are there algorithms to exactly minimize NFAs which are sometimes efficient?', 'LastActivityDate': '2014-02-05T14:19:54.790', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<algorithms><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-07-10T17:56:35.363', 'FavoriteCount': '1', 'Id': '13206''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is somewhat related to <a href="http://cs.stackexchange.com/questions/13206/are-there-algorithms-to-exactly-minimize-nfas-which-are-sometimes-efficient?noredirect=1#comment27879_13206">another question I asked</a>, but I feel it\'s different enough to warrant its own question.</p>\n\n<p>I\'m doing research where I\'m trying to find the structure of complements of a certain class of finite languages. It\'s easy for me to get the minimal DFAs accepting these languages, but I\'d like to examine what kind of structure NFAs accepting these langauges have, particularly how nondeterminism helps with state-size of the automata (the DFAs are exponentially large).</p>\n\n<p>The problem is, the main NFA reduction technique uses equivalences, which won\'t produce any reduction if I start with a minimal DFA (since it\'s basically using the same technique). If I start with a non-minimal DFA, it just spits out the minimal DFA.</p>\n\n<p>What I\'m wondering is, are there algorithms which can start with a DFA, and shrink it into a smaller NFA by introducing nondeterminism? Are there "standard techniques" to do this?</p>\n\n<p>I have found <a href="http://www.csd.uwo.ca/faculty/ilie/TisF04.pdf">preorder reductions</a>, which look promising but hard to implement. I\'m open to many suggestions.</p>\n', 'ViewCount': '205', 'Title': 'Algorithm to shrink a DFA by introducing nondeterminism?', 'LastActivityDate': '2013-07-17T13:39:28.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '13266', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><automata><finite-automata><discrete-mathematics><nondeterminism>', 'CreationDate': '2013-07-12T16:19:26.300', 'FavoriteCount': '1', 'Id': '13249''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>It's known that the complement of a DFA can be easily formed. That is, given a machine $M$, we can construct $M'$ such that $L(M') = \\Sigma^* \\setminus L(M)$.</p>\n\n<p>Is it possible to construct such a complement for a non-deterministic finite automation (NFA)? To my knowledge, it isn't.</p>\n", 'ViewCount': '1457', 'Title': 'Complement of Non deterministic Finite Automata', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-16T18:40:12.790', 'LastEditDate': '2013-07-16T10:18:36.350', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9190', 'Tags': '<automata><finite-automata><closure-properties>', 'CreationDate': '2013-07-15T10:40:24.740', 'FavoriteCount': '1', 'Id': '13282''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My task is to design a FSM whose output goes high for a single cycle whenever the pattern 0110 is detected on its input. The patterns may overlap, so an input 0110110 of would cause the output to go high twice- once for the first pattern (0110110), and once for the second pattern (0110110). a is used for the input and f is used for the output.</p>\n\n<p>I am assuming I will need five state bubbles <a href="http://i.stack.imgur.com/ghKNq.png" rel="nofollow">like this.</a></p>\n\n<p>Is this correct or am I missing some cases based on the pattern going high twice if the pattern overlaps?</p>\n', 'ViewCount': '164', 'Title': 'How to design a finite state machine to detect 0110 in the input?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-07-25T18:18:36.643', 'LastEditDate': '2013-07-25T18:18:36.643', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9332', 'Tags': '<finite-automata><digital-preservation>', 'CreationDate': '2013-07-25T01:30:33.483', 'Id': '13425''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm wondering, what is the time-complexity of determining emptiness for 2-way DFAs? That is, finite automata which can move backwards on their read-only input tape.</p>\n\n<p>According to Wikipedia, they are equivalent to DFAs, though the equivalent DFA might be exponentially larger. I've found state complexity for their complements and intersections, but not for their emptiness-testing.</p>\n\n<p>Does anyone know of a paper where I could find this?</p>\n", 'ViewCount': '135', 'Title': 'What is the complexity of the emptiness problem for 2-way DFAs?', 'LastActivityDate': '2013-07-30T14:30:26.037', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13482', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><reference-request><automata><finite-automata>', 'CreationDate': '2013-07-26T22:35:28.517', 'Id': '13456''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Recently an interesting question was asked and subsequently deleted.</p>\n\n<p>For a regular language $L$, its <em>DFA complexity</em> is the size of the minimal DFA accepting it, and its <em>NFA complexity</em> is the size of the minimal NFA accepting it. It is well-known that there is an exponential separation between the two complexities, at least when the size of the alphabet is unbounded. Indeed, consider the language $L_n$ over the alphabet $\\{1,\\ldots,n\\}$ consisting of all words <em>not</em> containing all symbols. Using the Myhill-Nerode theorem it is easy to calculate the DFA complexity $2^n$. On the other hand, the NFA complexity is only $n$ (if multiple initial states are allowed; otherwise it is $n+1$).</p>\n\n<p>The deleted question concerned the <em>DFA covering complexity</em> of a language, which is the minimal $C$ such that $L$ can be written as the (not necessarily disjoint) union of languages of DFA complexity at most $C$. The DFA covering complexity of $L_n$ is only $2$.</p>\n\n<blockquote>\n  <p>Is there an exponential separation between NFA complexity and DFA covering complexity?</p>\n</blockquote>\n', 'ViewCount': '108', 'Title': 'Exponential separation between NFAs and DFAs in the presence of unions', 'LastActivityDate': '2013-07-27T11:42:51.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13465', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '683', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-07-27T11:42:51.633', 'Id': '13464''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is a practice problem for a midterm in a class I'm taking:</p>\n\n<blockquote>\n  <p>Given a regular language $L$, describe formally a Turing machine that recognize $L$. </p>\n</blockquote>\n\n<p>I'm not sure how I should do that.</p>\n", 'ViewCount': '440', 'Title': 'How can a Turing Machine recognize a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T15:30:56.463', 'LastEditDate': '2013-07-30T10:26:40.687', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<turing-machines><regular-languages><automata><finite-automata><simulation>', 'CreationDate': '2013-07-29T19:45:40.207', 'Id': '13500''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am looking for an example, which corresponds to what I've learned in my Applied Automata Theory Class:</p>\n\n<p>Given a NFA $\\mathcal{A}$, </p>\n\n<ul>\n<li>a $\\approx _\\mathcal{A}$ quotient automaton can be bigger then a $\\sim_\\mathcal{A}$ quotient automaton and this can be bigger than an optimal quotient </li>\n<li>and an optimal quotient does not need to be the smallest equivalent NFA.</li>\n</ul>\n\n<p>$\\approx _\\mathcal{A}$ denotes the bisimulation relation (block refinement algorithm) and $\\sim_\\mathcal{A}$ denotes the canonical congruence, where $p \\sim_\\mathcal{A} q \\text{ iff } \\delta^*(p,w) \\in F \\text{ iff } \\delta^*(q,w) \\in F$, where DFA $\\mathcal{A}= (Q, \\Sigma, q_0, \\delta, F)$.</p>\n\n<p>Follow-up:</p>\n\n<p>The original Automaton $\\mathcal{A}$ over $\\Sigma={\\{a,b\\}}$ recognizing $\\mathcal{L} = \\Sigma a^*$:</p>\n\n<p>The original automaton $\\mathcal{A} = (\\{1,2,3,4,5,6\\}, \\Sigma, 1, \\Delta, \\{{3,4}\\}) $ with $\\Delta$:\n\\begin{pmatrix}\n&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\\\\\n1 &amp;- &amp; b &amp; a &amp; -&amp; -&amp;- &amp;  \\\\\n2 &amp;b &amp; b &amp; - &amp; a &amp; -&amp;- &amp;  \\\\\n3 &amp;- &amp; b &amp; - &amp; a&amp; a&amp;- &amp;  \\\\\n4 &amp;- &amp; b &amp; - &amp; a&amp; a&amp;- &amp;  \\\\\n5 &amp;- &amp; - &amp; - &amp; -&amp; -&amp;b &amp;  \\\\\n6 &amp;- &amp; - &amp;  &amp; a&amp; b&amp;b &amp;  \\\\\n\\end{pmatrix}</p>\n\n<p>The quotient automaton $\\mathcal{A}_{\\approx}  = (\\{12,34,5,6\\}, \\Sigma, 12, \\Delta_{\\approx}, \\{{34}\\}) $ with $\\Delta_{\\approx}$:\n\\begin{pmatrix}\n&amp; 12 &amp; 34 &amp; 5 &amp; 6\\\\\n12 &amp;b &amp; a &amp; - &amp; - \\\\\n34 &amp;b &amp; a &amp; a &amp; - \\\\\n5 &amp;- &amp; - &amp; - &amp; b \\\\\n6 &amp;- &amp; a &amp; b &amp; b  \\\\\n\\end{pmatrix}</p>\n\n<p>The quotient automaton $\\mathcal{A}_{\\sim}  = (\\{126,34,5\\}, \\Sigma, 126, \\Delta_{\\sim}, \\{{34}\\}) $ with $\\Delta_{\\sim}$:\n\\begin{pmatrix}\n&amp; 126 &amp; 34 &amp; 5 \\\\\n126 &amp;b &amp; a &amp; b \\\\\n34 &amp;b &amp; a &amp; a  \\\\\n5 &amp;b &amp; - &amp; -  \\\\\n\\end{pmatrix}</p>\n\n<p>The optimal quotient automaton $\\mathcal{A_{OPT}}  = (\\{1256,34\\}, \\Sigma, 1256, \\Delta_{OPT}, \\{{34}\\}) $ with $\\Delta_{OPT}$:\n\\begin{pmatrix}\n&amp; 1256 &amp; 34 \\\\\n1256 &amp;a,b &amp; a \\\\\n34 &amp;a,b &amp; a  \\\\\n\\end{pmatrix}</p>\n\n<p>The first property is satisfied since $\\mathcal{A}_{\\approx}$ has 4 states and $\\mathcal{A}_{\\sim}$ has 3 states. But in my example $\\mathcal{A}_{OPT}$ is the smallest automaton recognizing the given language. When do they differ?</p>\n", 'ViewCount': '83', 'Title': 'Quality of Reduction of finite automata using different congruences', 'LastEditorUserId': '1382', 'LastActivityDate': '2013-08-01T12:30:08.780', 'LastEditDate': '2013-08-01T12:30:08.780', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1382', 'Tags': '<automata><reductions><finite-automata>', 'CreationDate': '2013-07-31T18:04:22.847', 'Id': '13546''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '22', 'Title': 'Complement of non-deterministic finite automation', 'LastEditDate': '2013-08-02T15:20:44.810', 'AnswerCount': '0', 'Score': '2', 'OwnerDisplayName': 'Unni', 'PostTypeId': '1', 'FavoriteCount': '0', 'Body': u'<p>Given an NFA, is there a way to \u201ctake its complement\u201d and obtain an NFA that recognizes the complement language?</p>\n', 'ClosedDate': '2013-08-04T23:26:34.703', 'Tags': '<regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-02T15:20:44.810', 'CommentCount': '2', 'CreationDate': '2013-07-15T06:12:30.940', 'Id': '13572''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I found the paper "On the State Minimization of Nondeterministic Finite Automata" which, I assume, contains the Kameda-Weiner algorithm that I\'ve been searching for. It\'s behind a paywall though. I\'m just a hobbyist. Can someone explain it, or point me to another source?</p>\n', 'ViewCount': '135', 'Title': 'Free description of the Kameda-Weiner algorithm?', 'LastActivityDate': '2013-09-26T02:01:37.907', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<algorithms><automata><finite-automata>', 'CreationDate': '2013-08-03T18:57:58.530', 'FavoriteCount': '1', 'Id': '13591''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I\'ve only recently learned anything substantial about finite automata, and I\'ve just come across some things I hadn\'t seen before. Specifically, that classic NFAs are \u222a-NFA, and there are also these things \u2295-NFA , \u2229-NFA and \u22c6-NFA (I love unicode). These can all be seen in <a href="http://fastar.org/publications/PresentationFEW2006Geldenhuys.pdf" rel="nofollow">http://fastar.org/publications/PresentationFEW2006Geldenhuys.pdf</a> or <a href="http://www.cs.sun.ac.za/~lvzijl/publications/fsmnlp2009.pdf" rel="nofollow">http://www.cs.sun.ac.za/~lvzijl/publications/fsmnlp2009.pdf</a></p>\n\n<p>How are these different from the NFAs I\'m familiar with?</p>\n', 'ViewCount': '46', 'Title': u'How do the non-\u222a variants of NFAs work?', 'LastActivityDate': '2013-08-04T08:04:27.787', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13593', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-08-04T04:55:56.147', 'Id': '13592''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do you construct a DFA from a  language that has a + sign? e.g. $L = \\{(a+b)\\}*$</p>\n', 'ViewCount': '1836', 'Title': 'Convert regular expression to DFA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-05T08:26:57.573', 'LastEditDate': '2013-08-05T08:26:57.573', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'messivp', 'PostTypeId': '1', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-08-04T12:27:37.260', 'Id': '13599''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For my Bachelor\'s thesis, I consider the class of languages recognized by symmetrical DFAs, that is, deterministic (complete) finite automata satisfying the following condition: </p>\n\n<p>Let $A$ be a complete DFA over the alphabet $\\Sigma$. If, for every $a\\in \\Sigma$ and every transition $u \\stackrel{a}{\\longrightarrow}v$ in $A$, there is a transition $v \\stackrel{a}{\\longrightarrow}u$ in $A$, we call $A$ a <em>symmetrical</em> DFA (<em>SDFA</em>). If $A$ is not complete, we call it a <em>partial</em> SDFA. We can regard an SDFA as an undirected, labeled graph in a natural way. </p>\n\n<p>I could find an algebraic characterization of the class of languages recognized by (complete as well as partial) SDFAs and deduce some closure properties. However, neither me nor my supervisor are aware of previous results concerning this particular class of regular languages (barring results like Reingold\'s $\\mathsf{SL = L}$ which might seem related). </p>\n\n<p>Motivated by a <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory?noredirect=1#comment29176_13631">comment</a> that J.-E. Pin passed on <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory">a related question I asked</a>, my question is now:</p>\n\n<blockquote>\n  <p>Are there results concerning these automata?</p>\n</blockquote>\n', 'ViewCount': '130', 'Title': 'Results on the languages recognized by undirected DFAs', 'LastActivityDate': '2013-08-16T06:31:23.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13760', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><regular-languages><finite-automata>', 'CreationDate': '2013-08-15T10:27:23.167', 'Id': '13759''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '73', 'Title': 'Mealy machines to model ciphers', 'LastEditDate': '2013-08-18T03:18:05.613', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '25', 'FavoriteCount': '1', 'Body': u'<p>Similar questions have occurred quite a number of times <a href="http://cs.stackexchange.com/q/10280/25">(1)</a> <a href="http://cstheory.stackexchange.com/q/8539/869">(2)</a> <a href="http://cstheory.stackexchange.com/q/14811/869">(3)</a>, but I have, say, a specific instance of one. I\'m aware of a bunch of applications of finite automata, but would you provide an academic exposition of applications of finite state machines (like, e.g., Mealy machines) in cryptography and ciphers? There is a mention about things like that in Wikipedia article on Mealy machines (<a href="http://en.wikipedia.org/wiki/Mealy_machine#Applications" rel="nofollow">subsection \u201cApplications\u201d</a>). So the links to some academic texts play up on this are very appreciated. Alternatively would you share your thoughts on how to furnish this topic (FSM in cryptography) for students?</p>\n', 'ClosedDate': '2013-08-22T03:37:30.720', 'Tags': '<reference-request><automata><finite-automata><cryptography>', 'LastEditorUserId': '25', 'LastActivityDate': '2013-08-18T06:53:08.120', 'CommentCount': '1', 'AcceptedAnswerId': '13798', 'CreationDate': '2013-08-17T19:55:32.487', 'Id': '13795''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="http://en.wikipedia.org/wiki/Tag_system" rel="nofollow">Tag systems</a> are Turing-complete. I was wondering if there is any easy way to create tag systems that simulate finite automata. So create tag systems that recognize languages, e.g. by having at the end just one output symbol "A" for accepting the initial input or "R" for rejecting it.</p>\n\n<p>I guess a solution would be to make a Tag system simulate a specific Turing machine that simulates a finite automaton but that seems too much and too complicated. Is there perhaps a direct way from tag systems to finite automata?</p>\n', 'ViewCount': '67', 'Title': 'Make a tag system simulate a finite automaton?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:35:42.117', 'LastEditDate': '2013-08-22T14:35:42.117', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '927', 'Tags': '<computability><finite-automata><simulation><computation-models><turing-completeness>', 'CreationDate': '2013-08-19T03:42:11.630', 'FavoriteCount': '1', 'Id': '13808''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><em>This is a homework question, so I am only looking for hints.</em></p>\n\n<p>I got a question in an assignment which states :</p>\n\n<blockquote>\n  <p>Design a DFA that accepts strings having 1 as the 4th character from the end, on the alphabet {0,1}</p>\n</blockquote>\n\n<p>I have been at this for a few hours now, and I think that designing such a DFA is not possible. However, I am not sure how to move forward in this direction to write up a somewhat formal proof. </p>\n\n<p>So, what should I try to do to prove or disprove my hypothesis?</p>\n', 'ViewCount': '1136', 'Title': 'Designing a DFA that accepts strings such that nth character from last satisfies condition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-29T22:28:11.637', 'LastEditDate': '2013-08-29T14:39:17.470', 'AnswerCount': '4', 'CommentCount': '3', 'AcceptedAnswerId': '14021', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2044', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-08-29T01:49:33.573', 'Id': '14008''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am preparing for my exam in formal languages and I need some help with one question from one old exam.</p>\n\n<p><img src="http://i.stack.imgur.com/mHEZ6.png" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/eXL8R.png" alt="enter image description here"></p>\n\n<p>I know that the number of equivalence classes of some regular language L, is the number of states of the minimal DFA for that language.</p>\n\n<p>But how do I give a DFA for one of the equivalence classes ? </p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '346', 'Title': 'DFA - Equivalence classes', 'LastActivityDate': '2013-08-30T10:45:40.983', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14028', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><finite-automata>', 'CreationDate': '2013-08-29T19:57:52.213', 'Id': '14026''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In trying to gain a better understanding of finite state machines, I stumbled across this idea and have been confused as to how to approach this case in terms of a DFA.</p>\n\n<blockquote>\n  <p>The set of binary strings of length at least 3 where every substring\n  of length 3 contains at least two 0s.</p>\n</blockquote>\n\n<p>So in other words, something like 100100010 should be in the language (L) for this DFA but something like 11001010 would not be in the language.</p>\n\n<p>I know that you can start off by writing/drawing smaller DFAs for the substrings that are the pattern 000, 010, 100, 001, etc, but I cannot seem to get a hold of how it should look all together.</p>\n\n<p>Any help in understanding this would be appreciated.</p>\n', 'ViewCount': '224', 'Title': 'DFA drawing for binary string with substrings of minimum length 3 with at least two zeroes in each substring', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-02T09:56:55.093', 'LastEditDate': '2013-09-02T09:56:55.093', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '14055', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2013-08-31T03:05:59.700', 'Id': '14050''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know finite-state machines can be used to solve yes/no kind of problems, such as finding whether a word is in language or not. Can somebody tell me exactly what FSM cannot do and why?   </p>\n', 'ViewCount': '283', 'Title': 'What exactly can finite-state machines not do?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-04T09:26:11.450', 'LastEditDate': '2013-09-04T09:26:11.450', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-03T09:32:06.420', 'Id': '14093''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>When a DFA is converted into an equivalent NFA, the NFA gives more convenience to many yes/no kind of problems (such as a word belong to a language or not?). I want to know in general at what price this convenience is achieved?    </p>\n', 'ViewCount': '113', 'Title': 'What is the trade off in converting a DFA into a NFA?', 'LastEditorUserId': '6466', 'LastActivityDate': '2013-09-03T15:17:08.383', 'LastEditDate': '2013-09-03T12:54:36.230', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-03T11:54:53.030', 'Id': '14099''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a regular language $L$ over a unary alphabet $\\Sigma = \\{ a \\}$.</p>\n\n<p>How to decide whether there are two words $w,w' \\in L$ such that\nthe length of $w$ is relatively prime to the length of $w'$ ?</p>\n", 'ViewCount': '146', 'Title': 'Finding two words of lengths that are relatively prime in a regular language?', 'LastActivityDate': '2013-09-03T18:53:48.563', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9963', 'Tags': '<regular-languages><finite-automata><decision-problem>', 'CreationDate': '2013-09-03T16:03:03.457', 'Id': '14106''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>At many places I have read that the following language is not a regular, and thus it is impossible to express this in terms of  Finite Automata.    </p>\n\n<blockquote>\n  <p>L={0^i1^i | i>=0}</p>\n</blockquote>\n\n<p>But I tried  this as follows.   </p>\n\n<p><img src="http://i.stack.imgur.com/wKrBi.jpg" alt="enter image description here"></p>\n\n<p>Can somebody explain the fallacy?  </p>\n', 'ViewCount': '30', 'ClosedDate': '2013-09-06T16:09:34.667', 'Title': 'For the langauge L={0^i1^i | i>=0} DFA possible or not?', 'LastActivityDate': '2013-09-06T13:49:36.670', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-06T13:49:36.670', 'Id': '14175''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a regular language $L$. Let $D(L)$ be a minimal DFA for $L$ and $N(L)$ be a minimal NFA for $L$ (minimal in the sense of the smallest possible number of states for an automaton that recognizes the given language). Write $|A|$ for the size (number of states) of the automaton $A$. In general, $|N(L)|$ can be a lot smaller than $|D(L)|$ (down to $\\lg |D(L)|$, since determinization is exponential in the worst case).</p>\n\n<p>I am interested in languages for which the minimal NFA is guaranteed to be at least a fraction of the size of the DFA: $|N(L)| \\ge k |D(L)|$. What families of regular languages have this property? In other words, for what family of languages $(L_n)$ such that $|D(L_n)| = n$ is $|N(L_n)| = \\Omega(n)$?</p>\n', 'ViewCount': '176', 'Title': u'For what kinds of languages is min |NFA| = \u03a9(min |DFA|)?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-27T21:37:07.360', 'LastEditDate': '2013-09-13T16:00:09.733', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10106', 'Tags': '<formal-languages><automata><finite-automata><descriptive-complexity>', 'CreationDate': '2013-09-12T16:37:35.247', 'FavoriteCount': '1', 'Id': '14285''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a finite automaton with these properties:</p>\n\n<ul>\n<li>Contains cycles</li>\n<li>It's a directed graph</li>\n<li>All the states/nodes are initialy reachable from the initial state</li>\n<li>It has final states but I guess it isn't relevant for my issue</li>\n<li>It's a random generated automaton, and the generation isn't meant to satisfy properties like strongly connected components or connected components </li>\n</ul>\n\n<p>Let's suppose I have to delete an edge. </p>\n\n<p>I need to know if there's a way to prove that the reached state by this edge is still reachable from the initial state without using a classical search (DFS or BFS); obviously, if there is any.</p>\n", 'ViewCount': '57', 'Title': 'What is the optimal solution to prove the reachbility of a node from the root?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T17:36:35.740', 'LastEditDate': '2013-09-17T17:36:35.740', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<graph-theory><finite-automata><graph-traversal>', 'CreationDate': '2013-09-17T15:48:06.797', 'FavoriteCount': '1', 'Id': '14381''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve converted an NFA to a DFA.  But even after checking over it a few times, it still doesn\'t feel right.  I\'m sure this is trivial, but I\'d like someone to give me an idea where I went totally wrong on this.</p>\n\n<p>NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/LgZ9b.jpg" alt="enter image description here"></p>\n\n<p>DFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hMLf8.jpg" alt="enter image description here"></p>\n\n<p>Took several pics, these were the best, can\'t seem to get them straighter than this.</p>\n', 'ViewCount': '705', 'Title': 'Converting NFA to DFA', 'LastActivityDate': '2013-09-20T05:23:51.963', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '14461', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-09-20T02:44:27.307', 'Id': '14458''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>An NFA $M$ contains a cycle if there is a state $q$ and a string $x$ such that if $M$ is in state $q$ and reads string $x$, $M$ can return to state $q$. Prove:</p>\n\n<p>If $M$ recognizes an infinite language, then $M$ has a cycle.</p>\n', 'ViewCount': '66', 'ClosedDate': '2013-09-23T07:30:02.960', 'Title': 'If $M$ recognizes an infinite language, then $M$ has a cycle', 'LastActivityDate': '2013-09-23T00:43:28.777', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-09-23T00:42:55.103', 'Id': '14541''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm working on a NFA to DFA conversion tool that is different from the Subset Construction and I need to test this tool.</p>\n\n<p>In order to be sure that the immplementation has no bug I'd like to generate a random NFA with these properties:</p>\n\n<ul>\n<li>The NFA should be connected</li>\n<li>The NFA should have one initial state and one or more final states</li>\n<li>The NFA should have \u03b5-moves</li>\n</ul>\n\n<p>Is there a known algorithm or a paper that explains how to generate this NFA automaton as random as possible? </p>\n", 'ViewCount': '100', 'Title': 'NFA random generator', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-23T18:09:45.097', 'LastEditDate': '2013-09-23T18:09:45.097', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<finite-automata><pseudo-random-generators><random>', 'CreationDate': '2013-09-23T15:19:46.953', 'Id': '14555''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In some paper I read, </p>\n\n<blockquote>\n  <p>A theoretical worst case study shows that a single regular\n  expression of length $n$ can be expressed as an NFA with $O(n)$\n  states. When the NFA is converted into a DFA, it may generate\n  O($\\Sigma^n$) states. The processing complexity for each character in the inpuyt it $O(1)$ in a DFA, but is $O(n^2)$ for an NFA when all $n$ states are active at the same time.</p>\n</blockquote>\n\n<p>Please explain how NFA has at its maximum just $n$ states and its equivalent DFA has at most $O(\\Sigma^n)$ states?</p>\n', 'ViewCount': '92', 'Title': 'NFA and DFA storage cost', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T06:39:01.737', 'LastEditDate': '2013-10-04T06:39:01.737', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<regular-languages><automata><finite-automata><descriptive-complexity>', 'CreationDate': '2013-10-02T16:31:25.310', 'Id': '14755''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '242', 'Title': 'Counting Deterministic Finite Automata', 'LastEditDate': '2013-10-03T22:42:33.607', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'Heplar', 'PostTypeId': '1', 'OwnerUserId': '10493', 'FavoriteCount': '1', 'Body': u'<p>I have a question regarding counting DFAs:</p>\n\n<blockquote>\n  <p>Given a  <code>\u03a3 = {0, 1}</code> input string, with the state set <code>Q = {1...n}</code>, how would I find the total number of DFAs that can be constructed?</p>\n</blockquote>\n\n<p>I believe this is a combinatorics problem, but I am not really sure what I would have to multiply. </p>\n\n<p>Thanks. </p>\n', 'Tags': '<finite-automata>', 'LastEditorUserId': '10493', 'LastActivityDate': '2013-10-03T22:42:33.607', 'CommentCount': '5', 'CreationDate': '2013-09-19T04:17:15.567', 'Id': '14778''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I know that an \u03b5-NFA (NFA with epsilon transitions) is not an NFA or a DFA and an NFA is not a DFA.</p>\n\n<p>HOWEVER, say you have a complete DFA. Isn\'t that theoretically an NFA and an \u03b5-NFA? Just because it doesn\'t have \u03b5 transitions, does it mean it is not \u03b5-NFA? If a question asks you to turn a DFA into an \u03b5-NFA, can\'t you just write the complete DFA as an answer? What properties make DFA different from \u03b5-NFA and NFA?</p>\n\n<p>The same question applies to NFA \u2192 \u03b5-NFA, isn\'t NFA a more "primitive" version of \u03b5-NFA? It\'s just NFA without the \u03b5...</p>\n', 'ViewCount': '453', 'Title': u'DFA/NFA/\u03b5-NFA: subsetting each other or different sets?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-09T12:53:54.957', 'LastEditDate': '2013-10-09T12:53:54.957', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '14912', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6695', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2013-10-08T14:12:16.447', 'Id': '14908''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There is one point I don\'t understand in the DFA construction for mismatch cases.</p>\n\n<p>Here is the lecture note I watched, which describes how to handle mismatched characters during the DFA construction process.</p>\n\n<p><img src="http://i.stack.imgur.com/r4Q1Z.png" alt="enter image description here"></p>\n\n<p>Some information about the presentation screen shot:</p>\n\n<p><code>pat</code> is the pattern, string index starts at 0, <code>dfa</code> is the state transition table, in which the row is indexed by the character(eg, "A","B" or "C"), column by state(1,2,3,...).</p>\n\n<hr>\n\n<p><strong>My question starts</strong>:</p>\n\n<p>In the place in the presentation, where starts with "<em>To compute dfa[c][j]</em>", it says run the simulation using the last j-1 chars.</p>\n\n<p>I am confused:</p>\n\n<p>Why run the simulation using the last <code>j-1</code> chars, rather the last <code>j</code> chars. </p>\n\n<p>What\'s the intuition of this design?</p>\n', 'ViewCount': '277', 'Title': u'Confusion about finite automata construction in Knuth\u2013Morris\u2013Pratt algorithm', 'LastEditorUserId': '4662', 'LastActivityDate': '2013-12-01T06:48:14.043', 'LastEditDate': '2013-10-18T19:04:46.790', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><finite-automata><strings><matching>', 'CreationDate': '2013-10-18T09:15:06.677', 'FavoriteCount': '1', 'Id': '16195''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>While Learning about removing null moves from NFA , I came across a thought....</p>\n\n<p>To <strong>Remove Epsilon moves</strong> we follow following steps :</p>\n\n<ol>\n<li>Find <strong>Closure of all states</strong> which have null moves</li>\n<li>Mark <strong>these states which have null moves</strong></li>\n<li><strong>Make a revised transition table without epsilon column</strong> and Find all possible transition for those marked states by using their Closures.</li>\n<li>you will get nfa without null moves/epsilon moves</li>\n</ol>\n\n<p>Where is the issue : Actually, Doubt arises when you think of an nfa like this :</p>\n\n<p>If we try to remove epsilon moves out of it...</p>\n\n<p><img src="http://i.stack.imgur.com/x4yZj.png" alt="enter image description here"></p>\n\n<p>Initial transition Table : \n<img src="http://i.stack.imgur.com/hZeZX.png" alt="enter image description here"></p>\n\n<p>Now finding closure for q0, q1 and q3.</p>\n\n<p><strong>Which is CL(q0) = {q0,q1,q2}\nCL(q1) = {q1,q2}\nCL(q3) = {q2,q3}\nWe find a transition table after following above steps which is :</strong> \n<img src="http://i.stack.imgur.com/XDT2A.png" alt="enter image description here"></p>\n\n<p>The question gets quite tricky...</p>\n\n<p>because now this nfa has q1,q2 where there is no way to reach them..</p>\n\n<p>So What do you think we will remove q1 and q2 as they are unreachable or we will draw a nfa with them... </p>\n', 'ViewCount': '1992', 'Title': 'Removing Null moves from NFA', 'LastEditorUserId': '10861', 'LastActivityDate': '2014-02-27T16:49:27.293', 'LastEditDate': '2013-10-20T07:59:28.647', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><reductions><finite-automata>', 'CreationDate': '2013-10-19T20:40:25.610', 'Id': '16237''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm interested in finite state automata which have the capacity to require repetition.  That is, the machine may be in a state in which the next character may be any character from set $S$, but, whatever character there is, it must be repeated 3 times.  Or it may be in a different state, which requires a character from set $T$ repeated twice.</p>\n\n<p>I could in theory make a different state for each character in set S, and for each character in set T.  But that overcomplicates things and obscures the pattern - it can be any character in set S, but the same character must be repeated.</p>\n\n<p>Is there any standard approach to this? I'm interested both in terminology and in practical code.</p>\n\n<hr>\n\n<p>Motivation: I do not know the full makeup of the set $S$ or $T$.  I'd like to be able to communicate effectively about the FSM, draw state diagrams, and do implementation, without having to define $S$ or $T$.  In fact, $S$ and $T$ change based on the scenario.  (Now, given a character, it's trivial to tell if it's part of $S$ or $T$ \u2014 but, a priori, it's impossible to enumerate them.)</p>\n\n<p>At the least, I'd like a good way to draw a state diagram for these types of machines.  Perhaps I should use a standard FSM with some type of annotation? Could state charts help with this?</p>\n", 'ViewCount': '85', 'Title': 'Recognizing finite state machines with repetition', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-24T19:06:19.023', 'LastEditDate': '2013-10-23T04:04:41.797', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10923', 'Tags': '<algorithms><regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2013-10-22T23:13:36.837', 'Id': '16343''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have read that  the NFA size (i.e., the number of states) is linear in the number of characters in the regular expression. This holds even in the presence of character repetitions.</p>\n\n<p>I would like to know why is it so? </p>\n\n<p>If I have a pattern like this , [b-d]at then the number of states will be just 4 incase of NFA ? Size of DFA for this regular expression will also be 4? </p>\n', 'ViewCount': '59', 'Title': "NFA's number of states", 'LastEditorUserId': '4624', 'LastActivityDate': '2013-10-23T11:24:50.030', 'LastEditDate': '2013-10-23T08:42:00.380', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-10-23T08:36:07.103', 'Id': '16355''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $C$ be an infinite set of characters.  I'd like an abstract machine which can recognize sequences consisting of $k$ (constant) of repetitions of a char from $C$.</p>\n\n<p>For example, if ${x,y,z} \\subset C$, and $k = 3$, it should recognize $xxx$ but not $ddd$ or $xyz$.  (The same char must be repeated.)</p>\n\n<p>Since $C$ is infinite, a finite state machine <em>cannot</em> recognize this.  A Turing machine trivially can.  But we don't anything like the power of a Turing machine; simply extending the FSM with a single register that points to a member of $C$ is enough.</p>\n\n<p>My question is: What's the simplest formal abstract machine that is powerful enough to recognize this? Is there a standard extension to FSM's that enables them to recognize this? If I have more complicated versions of this machine (e.g. <em>Move from state 2 to state 3 if you encounter a $k$ repetition of a $C$ char</em>), what's the best way to express them?</p>\n", 'ViewCount': '108', 'Title': 'Abstract machine that can recognize repetition', 'LastActivityDate': '2013-12-22T22:31:30.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<formal-languages><computability><turing-machines><automata><finite-automata>', 'CreationDate': '2013-10-23T13:09:59.097', 'Id': '16362''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am taking an undergraduate CS Theory course and the material on finite automata and regular languages is being taught in a non-traditional manner. Instead of using regular expressions, the closure properties of regular languages, the pumping lemma etc, to show that a language is or is not regular, all of our proofs and examples for identifying regular languages use the Myhill-Nerode theorem and boolean matrices as defined below.</p>\n\n<p>Let $L = \\{w_1, w_2, ...\\}$ be a set of words over some alphabet $\\Sigma$ and let $T_L$ be a matrix with entries $t_{ij}$ where</p>\n\n<p>$$ t_{ij} =\n\\left\\{\n \\begin{array}{ll}\n  1  &amp; \\mbox{if } w_iw_j \\in L \\\\\n  0  &amp; \\mbox{otherwise}\n \\end{array}\n\\right.\n$$</p>\n\n<p><strike>Then by Myhill-Nerode, L is non-regular iff all rows of $T_L$ are distinct.</strike></p>\n\n<p><strong>Correction:</strong> Then by Myhill-Nerode, $L$ is non-regular iff $T_L$ has an infinite number of distinct rows. </p>\n\n<p>My question is, are there any readily available books, papers, or lecture notes that lean heavily on this technique and are appropriate for undergrads?</p>\n', 'ViewCount': '90', 'Title': 'Undergrad resources for identifying regular languages with Myhill-Nerode matrices', 'LastEditorUserId': '10980', 'LastActivityDate': '2013-10-26T20:25:02.053', 'LastEditDate': '2013-10-26T20:25:02.053', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10980', 'Tags': '<regular-languages><finite-automata><education><matrices>', 'CreationDate': '2013-10-25T22:43:27.700', 'FavoriteCount': '1', 'Id': '16434''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The question asks to:</p>\n\n<blockquote>\n  <p>construct a DFA which accepts exactly $\\frac{n(n-1)(n-2)}{6} + \\frac{n(n-1)}{2}+1$ many members of $\\{0, 1\\}^n$ for every n.</p>\n</blockquote>\n\n<p>I have no idea where to start to constructing the DFA, could you give some directions?\nBy the way, how many states should this DFA have?</p>\n', 'ViewCount': '48', 'Title': 'Construct a deterministic finite automation', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-04T19:55:49.573', 'LastEditDate': '2013-11-04T19:25:48.650', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11170', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-11-04T15:39:03.683', 'Id': '16707''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am learning about CS Theory and specifically Nondeterministic Finite Automata (NFA) right now. In my book I came across a section of text that discussed a way to determine the length of a walk stating specifically that :</p>\n\n<blockquote>\n  <p>If a transition graph has a walk labeled $w$, then there is a walk <em>w</em> of length no more than $\\Lambda + (1 + \\Lambda)|w|$ where $\\Lambda$ is the number of $\\lambda$ transitions in the graph.</p>\n</blockquote>\n\n<p>The book does not define $|w|$ which is causing part of my confusion. I\'m assuming $|w|$ is the length of the label of the walk. So in this case it would be 1 when going from $q_1 \\to q_0 \\to q1$ because $a$ is the only labeled edge.\nI am trying to understand this concept and how it works because when I have tested out this claim it has not held true.</p>\n\n<p>Here is the test I did with this NFA</p>\n\n<p><img src="http://i.stack.imgur.com/9tV6X.png" alt="enter image description here"></p>\n\n<p>$q_1$ is the final state. So assuming you were trying to find the length of the walk $a$, the label would indicate that the length is 1 (e.g. $\\delta^* (q_1, a)$) . However due to the lambdas you actually have $\\lambda \\lambda a$ to go from $q_1 \\to q_0 \\to q_1$.</p>\n\n<p>This theorem doesn\'t hold with my math though because it is defined as \u039b + (1 + \u039b)|w| where \u039b is the number of \u03bb-edges in the graph.</p>\n\n<p>Since there are two \u03bb-edges (and it doesn\'t state whether it means \u03bb-edges in the walk itself or in the graph in total...) this would then be 2 + (1 + 2)|w|. So thats 2 + 3|w|. This clearly is more than 3, which is the length of q1 -> q1 of \u03bb\u03bba.</p>\n\n<p>What am I missing here? Any help is greatly appreciated.</p>\n\n<p>This comes from Peter Linz "An Introduction to Formal Languages and Automata" 5th edition.</p>\n\n<p>Some more information about the argument for this claim:</p>\n\n<blockquote>\n  <p>While \u03bb-edges may be repeated, there is always a walk in which every repeated \u03bb-edge is separated by an edge labeled with a nonempty symbol. Otherwise, the walk contains a cycle labeled \u03bb, which can be replaced by a simple path without changing the label of the walk.</p>\n</blockquote>\n\n<p>Also the book never names this as a theorem or lemma or anything of the sort so it has been very difficult to find online resources about this topic.</p>\n', 'ViewCount': '90', 'Title': 'Determining Length of a walk in Nondeterministic Finite Automata with Lambda Transitions', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:40:46.183', 'LastEditDate': '2013-11-28T21:40:46.183', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11178', 'Tags': '<graph-theory><finite-automata><nondeterminism>', 'CreationDate': '2013-11-04T17:36:38.040', 'FavoriteCount': '0', 'Id': '16716''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>They have finite resources so they can be modeled by finite number of state what is the same that a finite state machine. There are any proof that it is not true?</p>\n\n<p>Thanks.</p>\n', 'ViewCount': '113', 'ClosedDate': '2013-11-05T13:05:35.547', 'Title': 'Are real computers finite state machines?', 'LastActivityDate': '2013-11-05T12:39:29.787', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '16734', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11196', 'Tags': '<computability><finite-automata>', 'CreationDate': '2013-11-05T08:33:46.060', 'Id': '16729''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given the language with alphabet: $\\{a, b, c\\}$\nDraw an NFA or DFA for all the strings that have exactly twice substrings $ab$ and at least on $c$.\nI\'m stuck with "exactly twice $ab$". Can somebody give me some ideas. It\'s also very good if you can suggest me the regular expression of this statement.</p>\n', 'ViewCount': '399', 'Title': 'NFA or DFA for strings the contain exactly twice substring ab?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-13T16:08:45.447', 'LastEditDate': '2013-11-12T09:47:18.353', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-11-12T03:43:29.253', 'Id': '17942''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to design a DFA with last 4th character from end is 1.</p>\n\n<p>The alphabets are {0,1}</p>\n\n<p>for e.g. (Anything)1***</p>\n\n<p>One way is to make an NFA and then convert it to DFA...</p>\n\n<p>But i am finding it quite difficult to do it.</p>\n', 'ViewCount': '85', 'ClosedDate': '2013-11-25T09:45:16.640', 'Title': 'Designing a DFA in which last fourth character is 1', 'LastActivityDate': '2013-11-14T17:49:03.743', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '18027', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><finite-automata><nondeterminism>', 'CreationDate': '2013-11-14T17:04:50.323', 'Id': '18023''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can I think this way:</p>\n\n<p>We can convert a NFA to a RE using GFA.</p>\n\n<p>We build a series of GFAs. At each step, one state (other than start or accept) is removed and replaced by transitions that have the same effect.</p>\n\n<p>So, if we can convert k REs which have different forms but accept same language, then there must exists a string that the NFA accepts along k paths.</p>\n\n<p>Does that sound right?</p>\n\n<p>How to prove it properly?</p>\n', 'ViewCount': '131', 'Title': 'Can it be decided whether there exists a string accepted by a given NFA at least k ways?', 'LastEditorUserId': '10617', 'LastActivityDate': '2013-11-18T21:45:16.193', 'LastEditDate': '2013-11-18T21:45:16.193', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10617', 'Tags': '<turing-machines><finite-automata><undecidability>', 'CreationDate': '2013-11-18T02:51:27.257', 'Id': '18109''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>First I apologize if I confused therms DFA and FSM, to me it seems that is the same thing. The question is simple: Are the flowcharts (sequence, branching and jumping) equivalent to DFA resp. FSM? I am a bit confused about this. There are classes where using logical synthesis, Karunaugh maps, state encodings, flip flops etc. one is able to construct hardware consisting of logic gates and flip-flops which realizes the desired DFA. Basically all processes that runs on the computer (no matter if is written in C# or Assembler), are at the lowest level realized through logical gates, zeros and ones. So it seems that programs firstly needs to be converted (by compiler I suppose) to some form as I've described. This might imply that every problem that is solvable using C# is solvable using FSM. But this is in contradiction to Chomsky hierarchy and all this theory related stuff, which says that you cannot do the same magic with regular expressions (which are based on FSM) that you can do on Turing machine (which is equivalent of any programming language, if I am wrong correct me please). Moreover, if flowcharts (or even C#, Java ... source codes) were equivalent to FSM why we do not have all software formally verified so far? There is mathematical apparatus for FSM and related stuff, so why do not formally verify everything and ensure the correctness? What I am missing here?</p>\n", 'ViewCount': '59', 'Title': 'Flowcharts vs DFA resp FSM equivalency', 'LastActivityDate': '2013-11-20T23:19:14.123', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11513', 'Tags': '<formal-languages><turing-machines><finite-automata><computer-architecture>', 'CreationDate': '2013-11-20T23:19:14.123', 'FavoriteCount': '1', 'Id': '18210''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I'm working on some questions to bone up on my knowledge of DFA's for a computing class and I've run across the following problem that is giving me some issues. If we have some \nDFA M = (Q, \u03a3, \u03b4, q0, F) and some other DFA M' = (Q, \u03a3, \u03b4, q0, F') where F is a proper subset of F', are the following relations possible or not between the two produced languages?</p>\n\n<p>1) L(M) \u2282 L(M')</p>\n\n<p>2) L(M) \u2283 L(M')</p>\n\n<p>My current theory is that the first one is not possible, due to the fact that the first machine has more finish states than the other, thus the language must be larger and cannot be subset to M'. This would of course mean that the second relationship is possible, since M must contain M'. Am I on the right track here and if so, how could I prove this?</p>\n", 'ViewCount': '58', 'Title': "Comparing DFA's produced languages", 'LastActivityDate': '2013-11-21T03:46:02.853', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11521', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-11-21T03:46:02.853', 'Id': '18214''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '430', 'Title': 'Maximum number of states in minimized DFA from NFA with $n$ states', 'LastEditDate': '2013-11-23T16:37:20.623', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8533', 'Body': '<p>If an NFA with $n$ states is converted to an equivalent minimized DFA then what will be the maximum number of states in the DFA? Will it be $2^n$ or $2n$?</p>\n', 'ClosedDate': '2013-11-28T06:27:57.097', 'Tags': '<automata><finite-automata><nondeterminism>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-23T17:32:54.963', 'CommentCount': '2', 'AcceptedAnswerId': '18280', 'CreationDate': '2013-11-23T15:18:01.973', 'Id': '18278''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '199', 'Title': 'Design a DFA which accepts words with sorted letters', 'LastEditDate': '2013-11-26T18:54:29.923', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11125', 'FavoriteCount': '1', 'Body': "<p>I have just started learning Theory of Computation and have come across a question which I am not able to solve.</p>\n\n<p>The question is as follows:</p>\n\n<pre><code>Design a DFA that reads a word (character strings) and decides whether the letters\nof the word are in sorted order.\nFor example: 'adept' and 'chilly' have their words in sorted order but 'baby' doesn't.\n</code></pre>\n\n<p>How should I design a DFA for this language?</p>\n\n<p>What I have tried:</p>\n\n<p>I think there must be two states.</p>\n\n<pre><code>1) While the DFA is scanning the word, the state (q1) will transit to itself \nif it reads a letter greater than or equal to previous letter read.\n\nThat is if the current_letter_read &gt;= previous_letter_read then \nq1 transits to itself. Otherwise, there is no action.\n\n2) If '\\0' is encountered, then the DFA transits to the final accepting state.\n</code></pre>\n\n<p>But in DFA is it possible to do so? How should I draw a DFA for this?\nI got stuck at this point. Am I missing some basic concept that I should know?</p>\n", 'Tags': '<finite-automata>', 'LastEditorUserId': '683', 'LastActivityDate': '2013-11-26T19:31:30.633', 'CommentCount': '5', 'AcceptedAnswerId': '18395', 'CreationDate': '2013-11-26T07:37:07.803', 'Id': '18355''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I\'ve converted this NFA to a DFA and I get a similar soultion automata but I\'m not sure if I really understand everything. </p>\n\n<p>Please correct me if I\'m explaining it wrong, I would love some feedback.</p>\n\n<p>From the state 0 we only have the set {0} since there doesn\'t exist any \u03b5-transition.\nAfter that we have to input "a" to move to state 1 and here I\'ve got a question. Does it include the 0 also since "a" can either take you to state 1 but also to state 0 since it loops? </p>\n\n<p>Continuing we want to move to state 2 via "a" input. Why does it include the "0"? Is it because you have to consider all the inputs from each set in the state 1? Like, if you input "a" at 0 you loop but you can also go to state 1. From 1 if you input "a" you move forward to state 2. Which gives us the set {0,1,2}. </p>\n\n<p>If this is correct, then the procedure for state 3 should be the same, right? \nAlso, at the third state {0,1,2,3} he can\'t just loop "b" since the other states can\'t "handle" the input so you have to create a new state containing the set {0,3} which can handle the "b" input?</p>\n\n<p>Sorry if this is a bit long, I just want to understand what is going on really. </p>\n\n<p><img src="http://i.imgur.com/O3X8kQB.png?1" alt="Automatas"></p>\n', 'ViewCount': '93', 'Title': 'NFA to DFA convertion explanation', 'LastActivityDate': '2013-11-27T16:27:27.337', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18421', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11661', 'Tags': '<automata><finite-automata><nondeterminism>', 'CreationDate': '2013-11-27T13:45:53.487', 'Id': '18415''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it possible to build DFA that support \\d, \\w, .(any symbol)? \nI understand that we can add each symbol from [0-9] as a separate edge for some of the symbols, but what about the others? for example .(any symbol)? or \\S (not white space)?</p>\n\n<p>In other words, can we build equivalent DFA for this NFA</p>\n\n<pre><code>(1) ---a----&gt; (2)\n |\n | \n .(any symbol)\n |\n \\/\n (3)\n</code></pre>\n', 'ViewCount': '38', 'Title': 'Is it possible to support .(any symbol) or \\d, \\w, \\W in DFA', 'LastActivityDate': '2013-11-28T16:59:34.080', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18447', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10348', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-11-28T16:33:28.350', 'Id': '18446''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given the following multiplication table how could one construct an NFA such that it accepts all strings that have a certain product (say a) ? </p>\n\n<p>The string "abcb" would be evaluated as (a(b(cb))) = a</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; a &amp; c \\\\\n    b &amp; c &amp; a &amp; b \\\\\n    c &amp; b &amp; c &amp;a\n   \\end{array}</p>\n\n<p>I tried to take the transpose of the above matrix:</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; c &amp; b \\\\\n    b &amp; a &amp; a &amp; c \\\\\n    c &amp; c &amp; b &amp; a\n   \\end{array}</p>\n\n<p>And build an NFA for that. I then reversed all the transitions, but I don\'t think that works.</p>\n', 'ViewCount': '72', 'Title': 'NFA for right left multiplication', 'LastActivityDate': '2013-12-02T04:34:35.407', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11741', 'Tags': '<regular-languages><finite-automata><nondeterminism><multiplication>', 'CreationDate': '2013-12-01T20:37:27.720', 'Id': '18509''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>when converting an NFA to DFA, we create sub-sets of states in the NFA.\ndoes it mean that every DFA-converted-from-NFA contain 2^Q states? or if some sub-sets are unreachable then they are not included in it?</p>\n', 'ViewCount': '308', 'Title': 'does a DFA converted from NFA always contain 2^Q states?', 'LastActivityDate': '2013-12-05T17:00:56.737', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '18579', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11713', 'Tags': '<automata><finite-automata>', 'CreationDate': '2013-12-03T17:58:02.983', 'FavoriteCount': '1', 'Id': '18577''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '134', 'Title': 'Partition an infinite regular language into 2 disjoint infinite regular languages', 'LastEditDate': '2013-12-05T18:01:50.127', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11713', 'FavoriteCount': '1', 'Body': "<p>Given any infinite regular language $L$, how can I prove that $L$ can be partitioned into 2 disjoint infinite regular languages $L_1, L_2$? That is: $L_1 \\cup L_2 = L$, $L_1 \\cap L_2 = \\varnothing$, and $L_1$ and $L_2$ are both both infinite and regular.</p>\n\n<p>So far, I thought of:</p>\n\n<ol>\n<li><p>using the pumping lemma such that \n$$ \\begin{gather}\n  L_1 &amp;= \\{ xy^nz \\mid \\text{\\(n\\) is even} \\} \\\\\n  L_2 &amp;= \\{ xy^mz \\mid \\text{\\(m\\) is odd} \\} \\\\\n\\end{gather} $$\nbut couldn't prove that they are dijoint or covering $L$ completely. </p></li>\n<li><p>Using the regular language partitions $\\Sigma^*$ into dijoint equivalence classes, but I haven't figured out how to determine if an equivalence class is regular or infinite.</p></li>\n</ol>\n", 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-05T18:01:50.127', 'CommentCount': '0', 'AcceptedAnswerId': '18613', 'CreationDate': '2013-12-04T14:40:00.883', 'Id': '18610''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The intersection of a context free language L with a regular language M, is said  to be always context free. I understood the cross product construction proof, but I still don't get why it is context free but not regular.</p>\n\n<p>The language generated by such an intersection has strings that are accepted both by a PDA <em>and</em> a DFA. Since it is accepted by a DFA, shouldn't it be a regular language? Plus, if the intersection is regular, it also implies context free, since all regular languages are also context free.</p>\n\n<p>Can someone explain to me why the language obtained by such an intersection is not regular?</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '273', 'Title': 'Intersection of context free with regular languages', 'LastActivityDate': '2013-12-05T15:20:51.903', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18645', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<context-free><finite-automata><formal-grammars>', 'CreationDate': '2013-12-05T14:24:39.063', 'FavoriteCount': '2', 'Id': '18642''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to figure out if there exists a DFA $M$ with $k+2$ states (for every $k\\in \\mathbb{N}$ ) so that every automaton which accepts $L(M)^R$ has at least $2^k$ states.<br>\nI am trying to find an example of such a DFA, any help?</p>\n', 'ViewCount': '66', 'Title': 'Is there a DFA with $k+2$ states which its reverse has $2^k$ states', 'LastActivityDate': '2013-12-06T01:03:55.337', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18655', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11841', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-12-05T16:27:34.630', 'Id': '18648''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '147', 'Title': 'Synchronizing sequence and Synchronizable DFA', 'LastEditDate': '2013-12-07T01:48:28.913', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11841', 'FavoriteCount': '1', 'Body': '<p>I am trying to prove problem 1.59 in Sipser\'s book: <em>Introduction to the theory of computation , 2nd Edition.</em></p>\n\n<blockquote>\n  <p>Let $M=(Q,\\Sigma,\\delta,q_0,A)$ be a DFA and let $q\'$ be a state of $M$ called its "home". A <strong>Synchronizing sequence</strong> for $M$ and $q\'$ is a string $s\\in \\Sigma^*$ where $\\delta (q,s)=q\'$ for every $q\\in Q$. (We actually have extended $\\delta$ to strings so that $\\delta(q,s)$ equals the state where $M$ ends up when $M$ starts at state $q$ and reads input $s$).</p>\n  \n  <p>Say that $M$ is <strong>Synchronizable</strong> if it has a synchronizing sequence for some state $q\'$.</p>\n  \n  <p>Prove that, if $M$ is a $k$-state synchronizable DFA, then it has a synchronizing sequence of length at most $k^3$. Moreover, can you improve upon this bound?  </p>\n</blockquote>\n\n<p>I\'m more interested in proving that the synchronized sequence is of length of at most $k^3$ then trying to improve upon this bound.  </p>\n\n<p>I tried to prove (with no success) that there exists $w\\in \\Sigma^*$ which $|w| \\leq k^2 $ so that: $\\delta(q_1,w)=\\delta(q_2,w)$ for two distinct states in $M$: $q_1,q_2\\in Q$ (thus, $w$ can be read from two states in the automaton and get to the same final state).<br>\nIf I prove it, I could construct a word $w$ which will be a synchronizing sequence in $M$ and $|w|\\leq k^3$ as required.  </p>\n\n<p>Any suggestions?</p>\n', 'Tags': '<regular-languages><automata><finite-automata>', 'LastEditorUserId': '11841', 'LastActivityDate': '2013-12-07T02:40:56.123', 'CommentCount': '1', 'AcceptedAnswerId': '18704', 'CreationDate': '2013-12-06T18:56:27.920', 'Id': '18692''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve had this little doubt bothering me since four semesters now, so I\'ve come here to resolve it. Theoretical CS was probably not the right place to ask.</p>\n\n<p>Coming to the question, my old coursebook (<em>Theory of Computer Science - Automata, Languages and Computation (Eastern Economy Edition)</em> by KLP Mishra) details the conversion of the regular expression -:</p>\n\n<p>$(0 + 1)^* (00 + 11)(0+1)^*$</p>\n\n<p>to a finite automaton. The book details the process as follows:</p>\n\n<p><img src="http://i.stack.imgur.com/BLoTu.jpg" alt="Diagram of Procedure"></p>\n\n<p>I am able to grasp the process uptil step (d). I do not understand how (e) was obtained, and there is no explanation given. I tried to convert (d) to (e) by removing null-moves, but I am not able to get (e) - I obtain a bunch of redundant states (extra initial and final states). </p>\n\n<p>It is not possible to use the DFA minimization procedure to obtain (e) after the null-moves are deleted, simply because this isn\'t a DFA yet - it\'s still an NFA. Note that I\'ve not shown the NFA to DFA conversion procedure, which was on the next page. Could someone point me in the right direction? </p>\n\n<p>There are no steps given to obtain (e) from (d). That\'s what\'s confusing - I know I have  to remove the null-moves but not how to get the neat and \'minimized\' transition system given by (e).</p>\n', 'ViewCount': '239', 'Title': 'Redundant States During Removal of Null-Moves (Regular Expression to DFA)', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-10T17:09:24.310', 'LastEditDate': '2013-12-19T15:36:26.560', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11990', 'Tags': '<automata><finite-automata><regular-expressions>', 'CreationDate': '2013-12-10T12:40:04.293', 'Id': '18828''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I did see a lot of nice and informative questions, articles on inter-net and on StackOverflow itself, of-course. But I found all the questions or articles following a specific rule or a pattern to explain the topic. I mean, when a question was asked on NFA, DFA or Regular Expression, a solution was presented to the question abiding by the theorems / rules of these topics (Theory of Computation).</p>\n\n<p>But what I feel is that, as most of the questions on DFA/NFA are of the type \n"Design an NFA...." or "design a DFA..." , I feel that developing/Designing DFA/NFA must be an ART. </p>\n\n<p>And where there is ART I feel there is an intuition. If these problems involve "DESIGNING" something ,then everyone must have their own way (of-course not going out-of-the-way of theorems or rules as such) of solving or attacking these problems. One should have developed a thinking process (over the years of practise) to solve these problems.</p>\n\n<p>So I would like all the experts over this Site to share their knowledge (preferably in simple words) how they think over the problems (simple ones) of these topics.</p>\n\n<p>I would like to elaborate the question with a simple example.</p>\n\n<blockquote>\n  <p>Let F be the language of all strings over {0,1} that do not contain a pair of 1s that\n  are separated by an odd number of symbols. Give the state diagram of a DFA with\n  five states that recognizes F . </p>\n</blockquote>\n\n<p>Or maybe this:</p>\n\n<blockquote>\n  <p>Design an NFA to find a 4-state NFA for the complement of F.</p>\n</blockquote>\n\n<p>These questions are from the Sipser\'s book and I have also found the solutions for them myself. </p>\n\n<p>I just want to know , how one can develop an intuition for solving the problems?</p>\n', 'ViewCount': '215', 'ClosedDate': '2013-12-13T08:23:17.523', 'Title': 'How to approach NFA design questions intuitively?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-12T09:39:34.433', 'LastEditDate': '2013-12-12T09:39:34.433', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11125', 'Tags': '<regular-languages><finite-automata><education>', 'CreationDate': '2013-12-12T07:26:32.340', 'Id': '18913''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to show that the language Anfa = {(A,w)| A is an nondeterministic finite automata that accepts w} can be decided in polynomial time. My problem is every solution that I think of requires exponential time.</p>\n\n<p>I would appreciate any help, Thanks in advance..</p>\n', 'ViewCount': '115', 'Title': 'how to solve NFA acceptance problem in polynomial time', 'LastActivityDate': '2013-12-19T17:38:29.810', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12242', 'Tags': '<time-complexity><finite-automata><nondeterminism><polynomial-time>', 'CreationDate': '2013-12-19T17:12:44.090', 'Id': '19126''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to understand decidable languages. In particular, I would like to show that\n$$B = \\lbrace \\langle D \\rangle \\mid \\exists k \\geq 0 \\,.\\,\\text{DFA $D$ accepts $a^k b^k$}\\rangle.$$\nI don't quite understand the process of proving these. I know that $a^kb^k$ is not regular, so then no DFA accepts it. I also know that $A_{DFA}$ (acceptance DFA) is decidable, I also know several other decidable languages like $E_{DFA}$ and $EQ_{DFA}$. How can I use these to prove that $B$ is decidable? </p>\n\n<p>If no DFA accepts $a^kb^k$, doesn't that mean that $A_{DFA}$ will reject? So if $A_{DFA}$ rejects then shouldn't the decider for $B$ accept? </p>\n", 'ViewCount': '110', 'Title': 'Decidability of $\\lbrace \\langle D \\rangle \\mid \\text{$D$ accepts $a^kb^k$ for some $k > 0$}\\rbrace$', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-29T09:53:04.893', 'LastEditDate': '2013-12-29T09:53:04.893', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '19173', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<computability><finite-automata>', 'CreationDate': '2013-12-21T02:54:13.680', 'Id': '19171''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '24', 'Title': 'Decidability. $\\lbrace \\langle D \\rangle \\mid \\text{$D$ accepts $a^kb^k$ for some $k > 0$}\\rbrace$', 'LastEditDate': '2013-12-29T09:52:56.220', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'Data', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Body': "<p>I'm trying to understand decidable languages. In particular, I would like to show that\n$$B = \\lbrace \\langle D \\rangle \\mid \\exists k \\geq 0 \\,.\\,\\text{DFA $D$ accepts $a^k b^k$}\\rangle.$$\nI don't quite understand the process of proving these. I know that $a^kb^k$ is not regular, so then no DFA accepts it. I also know that $A_{DFA}$ (acceptance DFA) is decidable, I also know several other decidable languages like $E_{DFA}$ and $EQ_{DFA}$. How can I use these to prove that $B$ is decidable? </p>\n\n<p>If no DFA accepts $a^kb^k$, doesn't that mean that $A_{DFA}$ will reject? So if $A_{DFA}$ rejects then shouldn't the decider for $B$ accept? </p>\n", 'ClosedDate': '2013-12-29T11:42:46.690', 'Tags': '<computability><finite-automata>', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-29T09:52:56.220', 'CommentCount': '4', 'CreationDate': '2013-12-21T01:42:14.683', 'Id': '19357''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do I iterate over all the $k$-element subsets of $\\{1,2,\\dots, n\\}$ by switching one element at a time?</p>\n\n<pre><code>123\n134\n234\n124\n145\n245\n345\n135\n235\n125\n</code></pre>\n\n<p>This comes from Ch2 of  <a href="http://www.math.upenn.edu/~wilf/website/CombinatorialAlgorithms.pdf" rel="nofollow">Combinatorial Algorithms</a> by Nienhuis and Wilf.</p>\n\n<p>Equivalently I am asking for a Hamiltonian circuit on the <a href="http://en.wikipedia.org/wiki/Johnson_graph" rel="nofollow">Johnson graph</a> of $k$ element subsets of a set of $n$ elements connected if their intersection has $k-1$ elements. </p>\n\n<hr>\n\n<p>I am trying to understand how the equation $$A(n,k) = A(n-1,k), \\overline{ A(n-1,k-1)}\\otimes \\{n\\}$$ from Nienhuis-Wilf leads to a type of "gray code" for subsets.  In fact, it is the gray code when you restruct to $k$-element sets. </p>\n\n<p>Here, $A(n,k)$ is an ordering, looping over the $k$-element subsets of $\\{1,2,\\dots, n\\}$.   The notation $\\overline{ A(n-1,k-1)}\\otimes \\{n\\}$ means we should list the $k-1$-element substs of $\\{1,2,\\dots, n-1\\}$ and append the element $n$ to each element of that list.</p>\n\n<p>This equation can also be thought of a set theoretic version of the binomial coefficient identity</p>\n\n<p>$$ \\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$$</p>\n\n<p>Using this formation I came up a means of listing all the subsets in order. </p>\n\n<p>Here <code>gc(n,k)</code> is returning an array of $k$-element arrays, enumerating the $k$-element subsets of $\\{1,2,\\dots, n\\}$.</p>\n\n\n\n<pre><code>def gc(n,k):\n    if(k==1):\n        return [[i+1] for i in range(n)]\n    elif(n == 0):\n        return []\n    else:\n        L = [ x+ [n] for x in gc(n-1,k-1)]\n        return gc(n-1,k)+ L[::-1]\n</code></pre>\n\n<p>How do I find the predecessor or successor of a given subset without generating all the subsets?  I wrote some python code for this, which is different from what is in the textbook.  It still doesn\'t return the correct answer.</p>\n\n<pre><code>def S(n,k,a):\n    if k == 1:\n        return [(a[0] + 1)%n]\n    elif(a[-1] == n-1):\n        return P(n-1,k-1, a[:-1]) + [n-1]\n    else:\n        return S(n-1,k,a)\n\ndef P(n,k,a):\n    if k == 1:\n        return [(a[0] - 1)%n]\n    elif(a[-1] == n-1):\n        return S(n-1,k-1, a[:-1]) + [n-1]\n    else:\n        return P(n-1,k,a)\n</code></pre>\n\n<p>This looks pretty close to the recursion in Nienhuis-Wilf but I would like to understand where I am going wrong in my implementation.</p>\n', 'ViewCount': '99', 'Title': 'iterating over subsets by switching one element at a time', 'LastEditorUserId': '3131', 'LastActivityDate': '2014-01-08T21:29:35.157', 'LastEditDate': '2014-01-05T18:08:51.710', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><graph-theory><finite-automata>', 'CreationDate': '2014-01-05T03:35:26.093', 'Id': '19504''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>(I\'m aware that software questions are better suited for stackoverflow, but since DFAs are not something that software developers usually care about, I hope it\'s alright if I ask here.)</p>\n\n<p>I\'m currently working on a project to do with regular overapproximations for context free languages. For this purpose, I need to implement stuff that requires me to represent regular languages in a minimized form, intersect them, complement them, etc. - i.e. everything that\'s easy and quick to do with DFAs. However, I\'m having a hard time finding still-maintained libraries for DFAs in C++. I could find <a href="http://augeas.net/libfa/index.html" rel="nofollow">libfa</a> which does everything quite nicely, but that\'s as far as I\'ve gotten. <a href="http://www.cse.ust.hk/faculty/dwood/.grail/" rel="nofollow">Grail</a> hasn\'t been maintained in 15+ years and the download link is dead. <a href="http://fado.dcc.fc.up.pt/" rel="nofollow">FAdo</a> seemed interesting initially, but it\'s in Python and I can\'t determine whether there\'s a way to use it as a C++ library, or whether it offers the functionality I mentioned above (the Docs are a bit slim).</p>\n\n<p>Do you know of C(++) libraries for DFAs that offer minimization, intersection and complementation that are free for academic use? I\'d like to have at least one alternative to libfa that I can use.</p>\n', 'ViewCount': '92', 'Title': 'C(++) library for DFAs - free for academic use', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-12T11:35:11.127', 'LastEditDate': '2014-01-12T11:35:11.127', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6689', 'Tags': '<reference-request><automata><finite-automata><mathematical-software>', 'CreationDate': '2014-01-12T04:18:00.143', 'FavoriteCount': '1', 'Id': '19664''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given two sets $A,B$ of strings over alphabet $\\Sigma$, can we compute the smallest deterministic finite-state automaton (DFA) $M$ such that $A \\subseteq L(M)$ and $L(M) \\subseteq \\Sigma^*\\setminus B$?</p>\n\n<p>In other words, $A$ represents a set of positive examples.  Every string in $A$ needs to be accepted by the DFA.  $B$ represents a set of negative examples.  No string in $B$ should be accepted by the DFA.</p>\n\n<p>Is there a way to solve this, perhaps using <a href="https://en.wikipedia.org/wiki/DFA_minimization">DFA minimization</a> techniques?  I could imagine creating a DFA-like automaton that has three kinds of states: accept states, reject states, and "don\'t-care" states (any input that ends in a "don\'t-care" state can be either accepted or rejected).  But can we then find a way to minimize this to an ordinary DFA?</p>\n\n<p>You could think of this as the problem of learning a DFA, given positive and negative examples.</p>\n\n<p>This is inspired by  <a href="http://cs.stackexchange.com/q/19686/755">Is regex golf NP-Complete?</a>, which asks a similar questions for regexps instead of DFAs.</p>\n', 'ViewCount': '158', 'Title': 'Smallest DFA that accepts given strings and rejects other given strings', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:31:57.547', 'LastEditDate': '2014-01-13T12:59:49.750', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '19693', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<regular-languages><automata><finite-automata><machine-learning>', 'CreationDate': '2014-01-13T09:37:38.647', 'Id': '19687''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m totally new to DFA\'s and automaton in general -- this is the first week or two of class that I\'ve actually seen this -- and I\'m curious as to a pattern to match the following: </p>\n\n<p>"Match the set of all strings on the alphabet {a, b} that have at least one b and exactly 2 a\'s" </p>\n\n<p>I\'ve tried to construct a DFA to represent this structure, but I have no idea how to form a structure to count for something and match for one. </p>\n\n<p>Can someone help? </p>\n\n<hr>\n\n<p>Okay, so. Here\'s what I got and I think it\'s the right answer. <img src="http://i.stack.imgur.com/ZxdI4.jpg" alt="dfa"></p>\n', 'ViewCount': '115', 'Title': 'DFA for exactly two of a and one or more of b', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:32:48.550', 'LastEditDate': '2014-01-15T08:32:48.550', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '19738', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12863', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-01-15T03:24:11.070', 'Id': '19736''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking at the following non-deterministic finite automata which accepts all strings that end with at least 2 bs.  I am wondering what would happen when you have the input string \'abba\' with this automata:</p>\n\n<p><img src="http://i.stack.imgur.com/hQYaA.png" alt="Automata"></p>\n\n<p>The possible computations I have so far are</p>\n\n<p>q0, q0, q0, q0, q0</p>\n\n<p>q0, q0, q1, q2, ??</p>\n\n<p>q0, q0, q0, q1, ??</p>\n\n<p>Would anyone be able to fill in the \'??\'s in this automata and be able to explain why they occur?</p>\n', 'ViewCount': '40', 'Title': 'Finite Automata Input Confusion', 'LastEditorUserId': '12879', 'LastActivityDate': '2014-01-17T18:52:39.547', 'LastEditDate': '2014-01-17T18:33:14.803', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19790', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12879', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-01-17T18:04:12.667', 'Id': '19786''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>When translating an NFA into an equivalent DFA, we can say that all\n  states that contain the final states of NFA, is the final state of\n  DFA.</p>\n</blockquote>\n\n<p>What should my arguments be in order to prove this?</p>\n', 'ViewCount': '76', 'Title': 'NFA to DFA final states proof', 'LastActivityDate': '2014-01-25T14:47:06.420', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13122', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-01-25T13:32:47.600', 'FavoriteCount': '1', 'Id': '19966''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '85', 'Title': 'Non determininstic finite state automata', 'LastEditDate': '2014-01-28T06:55:30.370', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'user116317', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Body': '<p>I wanted to construct a NFA over sigma star, where sigma={a,b}, such that at least one of the last 2 symbols is an "a".  I just wanted to make sure that this construction is correct.</p>\n\n<p><img src="http://i.stack.imgur.com/Tusk8.png" alt="State table"></p>\n\n<p><a href="http://i.stack.imgur.com/6zC8W.jpg" rel="nofollow">Original image</a></p>\n', 'ClosedDate': '2014-01-28T08:04:38.627', 'Tags': '<finite-automata><nondeterminism>', 'LastEditorUserId': '1669', 'LastActivityDate': '2014-01-28T06:55:30.370', 'CommentCount': '4', 'CreationDate': '2014-01-28T01:16:36.123', 'Id': '20025''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am taking a course in the theory of computation and am trying to understand how to correctly design NFA\'s so that I can transform them into regex. I was wondering if I have Sigma={a,b} and need to design a NFA over Sigma Star that has at least one of its last 2 characters to be an \'a\'; Can I simply start 2 threads, one that will accept \'a\' as the last character and the other will accept \'a\' or \'b\' in the second to last position and \'a\' as the last symbol? Also, the fact that this will be over Sigma Star, would that also mean that I have to have epsilon transitions included in this design?<img src="http://i.stack.imgur.com/LGiyR.jpg" alt="L(A)={w: at least one the last 2 characters of w is an \'a\'}"></p>\n', 'ViewCount': '30', 'ClosedDate': '2014-01-28T17:50:39.120', 'Title': 'Non-deterministic finite state automoton', 'LastEditorUserId': '13175', 'LastActivityDate': '2014-01-29T19:02:16.467', 'LastEditDate': '2014-01-29T19:02:16.467', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<finite-automata><nondeterminism>', 'CreationDate': '2014-01-28T14:15:44.520', 'Id': '20038''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $A$ and $B$ be regular languages. Let $C$ be their difference, i.e $C = B \\setminus A$.</p>\n\n<p>Given NFAs for $A$ and $B$, is it possible to directly construct an NFA for $C$ without (implicitly or explicitly) converting them to DFAs first?</p>\n', 'ViewCount': '62', 'Title': 'Direct construction of NFA for the difference of regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-29T02:00:09.690', 'LastEditDate': '2014-01-28T17:51:44.843', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12837', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-01-28T15:45:02.117', 'Id': '20042''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Assuming we have an automaton that simultaneously accepts a string on two paths. Would this mean that the construction of the NFA might be faulty?  In other words; at the end of any string over any alphabet, does the NFA have to end up accepting one single path only? Or could it accept several at the same time?</p>\n', 'ViewCount': '57', 'ClosedDate': '2014-02-16T18:12:58.687', 'Title': '2 threads accepted at the same time', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-31T09:11:28.767', 'LastEditDate': '2014-01-31T08:26:18.397', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<terminology><automata><finite-automata><nondeterminism>', 'CreationDate': '2014-01-31T00:41:46.270', 'Id': '20136''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am new to Automata Theory. I am studying the book thoroughly and understanding it well. I have got a confusion regarding NFA. Why does this automaton accept the empty string \u03bb?</p>\n\n<p><img src="http://i.stack.imgur.com/BV2Eh.jpg" alt="NFA"></p>\n\n<p>What I think is that: implicitly \u03b4(q,\u03bb)=q for all states q. But here also explicitly defined \u03b4(q0,\u03bb)=q2. As there is a walk to the final state using \u03b4(q0,\u03bb)=q0, so \u03b4(q0,\u03bb)=q2 will not be followed. Am I correct?  </p>\n', 'ViewCount': '92', 'Title': 'Why does this automation accept the empty string?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-19T14:49:30.260', 'LastEditDate': '2014-01-31T09:47:25.713', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '20144', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '13053', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-01-31T06:37:15.070', 'Id': '20143''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is this true? If I change all final states of a given Deterministic Finite Automata to non final states and all non final states to final states then does this new automata represent the complement of the language that was accepted by the original automata?</p>\n\n<p>What if we talk about a Non deterministic finite automata instead of a DFA?</p>\n', 'ViewCount': '81', 'Title': 'Can reversing the final and non-final states of a DFA produce the complement of the original language?', 'LastActivityDate': '2014-02-06T08:29:16.050', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21361', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12845', 'Tags': '<formal-languages><automata><finite-automata>', 'CreationDate': '2014-02-06T07:09:39.397', 'Id': '21359''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know that a DFA has to have exactly one transition for each symbol in the alphabet, but is it allowed to have two symbols on the same arrow? If, for example, I have a DFA with states $q_0$ and $q_1$, can I have one arrow from $q_0$ to $q_1$ with both $a$ and $b$? </p>\n\n<p>This may be a stupid question, but I need to be completely sure that this is allowed (I believe it is).</p>\n', 'ViewCount': '52', 'Title': 'Can a DFA have two symbols on one arrow?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-06T14:46:04.787', 'LastEditDate': '2014-02-06T13:27:53.107', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21374', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2014-02-06T12:51:38.073', 'Id': '21373''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My method of conversion is by creating a reachable set tree and each set within the tree would represent the new states. </p>\n\n<p>I have never dealt with FSAs that has 2 or more initial states. How do i create my reachable set tree with two or more states? </p>\n', 'ViewCount': '35', 'Title': 'Non-Deterministic FSA to Deterministic FSA, Two initial states', 'LastActivityDate': '2014-02-07T03:52:52.393', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '21417', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14460', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-07T02:51:06.547', 'Id': '21414''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>While going through certain problems. it seems that more than one NFA is possible for the given language. Is it so? </p>\n\n<p>For example for drawing: NFA ending with 1 where $\\Sigma=\\{0,1\\}$ is</p>\n\n<p><img src="http://i.stack.imgur.com/dUGPO.png" alt="From Wikipedia page on NFA"></p>\n\n<p>and also we can draw one without 0 from the edge P to P!</p>\n\n<p>Which one should be considered "more" correct?</p>\n', 'ViewCount': '114', 'Title': 'More than one NFA accepting a given language', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T09:03:46.317', 'LastEditDate': '2014-02-11T07:07:42.027', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21516', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-11T01:25:57.827', 'Id': '21515''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to construct NFA for all languages ending in 00.</p>\n\n<p>I got this </p>\n\n<p><img src="http://i.stack.imgur.com/MKW9H.png" alt="enter image description here"></p>\n\n<p>and this</p>\n\n<p><img src="http://i.stack.imgur.com/gSaQO.png" alt="enter image description here"></p>\n\n<p>First one I could convert to DFA by subset construction and I got the correct DFA. For the second one I got the DFA by subset construction, but it is not the correct one since it couldn\'t accept strings like 100.</p>\n\n<p>Is this beacuse, there is no non determinism in the second NFA? Or what is the general rule in drawing an NFA? We could always provide some form of non determinism?</p>\n', 'ViewCount': '56', 'Title': 'Why the given NFA is not possible', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-13T10:12:02.390', 'LastEditDate': '2014-02-13T10:12:02.390', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21588', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-13T02:18:39.663', 'Id': '21586''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>While studying automata theory a typical problem that I face is of the following type:</p>\n\n<blockquote>\n  <p>Constructing a DFA with minimum number of states for all strings over\n  $\\{a,b\\}$ which have number of $a$\u2019s divisible by $X$ and number of $b$\u2019s\n  divisible by $Y$ (where $X$ and $Y$ are some positive integer values).</p>\n</blockquote>\n\n<p>Is there some standard way of solving such problems?  </p>\n\n<p>I looked it up over the net and most people seem to have an idea that minimum number of states will be $X \\cdot Y$. I don\'t think that is right. I constructed a DFA with 15 states for $X = 6$ and $Y = 8$.</p>\n\n<p>Also along a similar line suppose the problem is changed slightly and we are \ngiven "number of $a$\'s mod $X$ = $P$ and number of $b$\'s mod $Y$ = $Q$".  </p>\n\n<p>I believe this type of problem will also have a similar solution as the above problem. Only difference will be in the final states of the two machines. Can someone please confirm whether I am right about this? </p>\n', 'ViewCount': '122', 'Title': 'Minimum number of states in DFA for the given language?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T00:21:27.540', 'LastEditDate': '2014-02-19T07:58:35.027', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12845', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-19T07:18:18.303', 'FavoriteCount': '2', 'Id': '21802''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Describe a regular language that cannot be accepted by any DFA that has only three states.</p>\n</blockquote>\n\n<p>I'm not really sure where to start on this and was wondering if someone could give me some tips or advice. I understand that the pumping lemma can be used to prove a language is not regular, but in this case, it should be a regular language. If anyone has any thoughts it would be appreciated.</p>\n", 'ViewCount': '512', 'Title': 'Regular language not accepted by DFA having at most three states', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-30T02:24:06.250', 'LastEditDate': '2014-03-29T11:53:14.010', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '14857', 'Tags': '<formal-languages><regular-languages><finite-automata><pumping-lemma>', 'CreationDate': '2014-02-19T22:05:01.387', 'FavoriteCount': '1', 'Id': '21826''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '87', 'Title': 'showing that the pair of Finite Automata are equivalent', 'LastEditDate': '2014-02-22T09:48:46.713', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14495', 'FavoriteCount': '1', 'Body': '<p>Here I am trying to show that the pair of Finite Automata are equivalent. I have tried something but I am not sure if I am in the right direction. This is what I have.</p>\n\n<p>These are pairs of FA\'s. Set theory formula in here is <code>(L1\' + L2)\' + (L2\' + L2)\'</code></p>\n\n<p><img src="http://i.stack.imgur.com/pnj9J.png" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/McwoT.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/8mF4g.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/SVpwy.jpg" alt="enter image description here"></p>\n\n<p>Conclusion:</p>\n\n<blockquote>\n  <p>Both machines (FA1\'+FA2)\' and (FA2+FA1)\' has no final states.\n  (FA1\'+FA2)\' to have a final state, the machine (FA1\'+FA2)\' must have\n  no final state. The exact same thing half of the formula. Clearly, if\n  we added these machines together we would get a machine with nine\n  state and no final state. Because there is no final state, it accepts\n  no words and two languages L1 and L2 ar equivalent.</p>\n  \n  <p>So the two regular expressions defame the same language and\n  equivalent.</p>\n</blockquote>\n\n<p>Am I in the right direction ?</p>\n', 'Tags': '<formal-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T09:48:46.713', 'CommentCount': '3', 'AcceptedAnswerId': '21906', 'CreationDate': '2014-02-21T17:58:54.570', 'Id': '21897''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<blockquote>\n  <p>Consider a DFA over $a,b$  accepting all strings having number of $a$ 's divible by 6 and number of $b$ 's divisble by 8. What is the minimum number of states in the resultant DFA ?</p>\n</blockquote>\n\n<p>This problem can be solved by assuming 2 DFAs. One accepting the number of $a$ 's divible by 6 and the other accepting with number of $b$ 's divisble by 8. And then taking intersection of them. So what will be the number of states in the resultant DFA?</p>\n\n<p>I tried drawing the DFA accepting all strings having number of $a$ 's divible by 3 and number of $b$ 's divisble by 3, and found it to have 3x3 (9) states. Can I asssume the reuslt to be 48 states for this case? Can it be inferred that the for string accepting number of $a$ 's divible by $m$  and number of $b$ 's divisble by $n$ , there will be $mn$  states? Or I need to draw it by hand? Or anything other? Any subtle hint will be very helpful.</p>\n", 'ViewCount': '59', 'Title': 'What is the possible number of states in the DFA of intersection of two given FA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-22T09:50:41.753', 'LastEditDate': '2014-02-22T09:50:41.753', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21919', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14933', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-02-22T06:04:42.697', 'Id': '21918''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Suppose $L1, L2$ are both regular languages and $A1, A2$ are their corresponding DFA's.\nHow can I construct a new DFA for the regular language $L1 \\cup L2$?</p>\n", 'ViewCount': '53', 'Title': "Given 2 regular languages and their DFA's, how to construct the DFA of the union?", 'LastActivityDate': '2014-02-24T20:35:30.693', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '22001', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14999', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2014-02-24T20:04:23.093', 'Id': '22000''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '72', 'Title': 'What languages does a (1-way) quantum finite state automata recognize?', 'LastEditDate': '2014-03-03T14:59:28.130', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15077', 'FavoriteCount': '1', 'Body': '<p>Sorry if this is well known, but most of the research is paywalled.</p>\n\n<p>So far I know that it is a subset of the regular languages, but I cannot seem to find any (available) research which pins it down.</p>\n\n<p>Thanks!</p>\n', 'Tags': '<finite-automata><quantum-computing>', 'LastEditorUserId': '15077', 'LastActivityDate': '2014-03-03T14:59:28.130', 'CommentCount': '0', 'AcceptedAnswerId': '22165', 'CreationDate': '2014-02-26T18:59:37.350', 'Id': '22059''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to find a <code>regular expression</code> and <code>finite automaton</code> that each define $L_1 \\cap L_2$, where $L_1 = (ab^*)^*$ and $L_2 = b(a+b)^*$.</p>\n\n<p>How would I start doing this problem?</p>\n\n<p>So I would draw a FA and when I draw it I would have a complement meaning take anywhere you have a plus, get rid of it and anywhere you didn't have a plus add one in. Am I on the right track?</p>\n", 'ViewCount': '53', 'Title': 'find a regular expression and FA that each define $L_1 \\cap L_2$', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-02T15:56:22.643', 'LastEditDate': '2014-03-02T01:54:43.447', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15179', 'Tags': '<finite-automata><regular-expressions>', 'CreationDate': '2014-03-01T23:21:21.307', 'Id': '22174''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Minimizing deterministic finite automata (DFAs) is a problem that has been thoroughly studied in the literature, and several algorithms have been proposed to solve the following problem: \nGiven a DFA $\\mathscr{A}$, compute a corresponding minimal DFA accepting the same language as $\\mathscr{A}$.\nMost of these algorithms run in polynomial time.</p>\n\n<p>However, I wonder whether the decision variant of this problem - "given a DFA $\\mathscr{A}$, is $\\mathscr{A}$ minimal?" - can be solved more efficiently than actually computing the minimal automaton.\nObviously, this can also be done efficiently by running for example <a href="http://en.wikipedia.org/wiki/DFA_minimization#Hopcroft.27s_algorithm">Hopcroft\'s partition-refinement algorithm</a> and then deciding whether all partitions contain precisely one state.</p>\n\n<p>As Yuval Filmus suggests <a href="http://cs.stackexchange.com/a/3046/7486">in his answer</a>, the decidability variant can be solved faster, possibly by using the standard algorithms.\nUnfortunately, I cannot see how (I hope I am not missing an obvious point here).</p>\n\n<p>Yuval points out in the comments here that the best known algorithms (like the one above) run in time $\\mathcal{O}(n \\log n)$ for constant-sized alphabets. Therefore, I am not only interested in asymptotically significant gains in runtime, as these seem rather unlikely. What bothers me most is that I cannot imagine any "shortcut" that might be drawn from the fact that we are only interested in a yes-no-answer - not even a shortcut that allows for saving an asymptotically negligible amount of time. I feel that every sensible algorithm that decides the minimality of a DFA would have to actually minimize the DFA and see if anything changes during the process. </p>\n', 'ViewCount': '121', 'Title': 'How fast can we decide whether a given DFA is minimal?', 'LastEditorUserId': '7486', 'LastActivityDate': '2014-03-02T20:05:21.393', 'LastEditDate': '2014-03-02T18:51:48.217', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<algorithms><formal-languages><finite-automata>', 'CreationDate': '2014-03-02T12:41:01.930', 'FavoriteCount': '2', 'Id': '22191''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can we add new words to DFA, maintaining minimality?</p>\n\n<p>Maybe, you can advise some completely different approach to solve the following problem:</p>\n\n<blockquote>\n  <p>A program must process two types of queries:</p>\n  \n  <ol>\n  <li>Add new word to the language.</li>\n  <li>Check if some word of the language occurs in the input string as a substring.</li>\n  </ol>\n  \n  <p>Time and space complexity should be as low as possible.</p>\n</blockquote>\n\n<p>The only solution that I know so far is to rebuild an automaton from scratch every time, using Aho-Corasick algorithm, but, you know, it\'s really-really inefficient.</p>\n\n<p>I\'ve performed some search on Internet and found some papers like <a href="http://acl.ldc.upenn.edu/J/J00/J00-1002.pdf" rel="nofollow">"Incremental Construction of Minimal Acyclic Finite-State Automata"</a>, but, unfortunately, algorithm described there produces and maintains just a minimal trie (not a complete FSM with suffix links, like an automaton produced by Aho-Corasick algo).</p>\n', 'ViewCount': '66', 'Title': 'Adding words to DFA, maintaining minimality', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-03T15:22:33.553', 'LastEditDate': '2014-03-03T10:08:34.447', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8991', 'Tags': '<algorithms><finite-automata>', 'CreationDate': '2014-03-03T10:06:53.027', 'FavoriteCount': '1', 'Id': '22215''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am currently reading Introduction to the Theory of Computation (Sipser), and after introducing epsilon labeled transition arrows, the book shows the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/B8lUJ.jpg" alt="enter image description here"></p>\n\n<p>I was following it until I read the following :</p>\n\n<blockquote>\n  <p>Practice with it to satisfy yourself that it accepts the strings \u03f5, a, baba and baa...</p>\n</blockquote>\n\n<p>What does an input string of \u03f5 mean?</p>\n', 'ViewCount': '39', 'Title': 'What does an input string of epsilon mean?', 'LastActivityDate': '2014-03-03T18:43:22.290', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22229', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15239', 'Tags': '<finite-automata>', 'CreationDate': '2014-03-03T18:17:27.267', 'Id': '22227''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to convert Finite Automata into Push Down Automata and I am not sure if I am doing this right. There are not many good tutorials on this topic that I can find, but this is what I have. I am on the right track here ? Does this look ok ?</p>\n\n<p>this is the FA I am trying to convert</p>\n\n<p><img src="http://i.stack.imgur.com/Xib6u.png" alt="enter image description here"></p>\n\n<p>this is what I have</p>\n\n<p><img src="http://i.stack.imgur.com/iWJYx.jpg" alt="enter image description here"></p>\n', 'ViewCount': '47', 'ClosedDate': '2014-04-29T22:41:32.273', 'Title': 'how to convert Finite Automata into Push Down Automata', 'LastActivityDate': '2014-03-23T16:25:21.957', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15179', 'Tags': '<finite-automata><pushdown-automata>', 'CreationDate': '2014-03-23T16:25:21.957', 'Id': '22973''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Are all Deterministic Finite Automatons also Non Deterministic Finite Automatons?</p>\n', 'ViewCount': '70', 'Title': 'Are all DFAs also NFAs?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T21:26:05.983', 'LastEditDate': '2014-03-24T21:26:05.983', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23013', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11684', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2014-03-24T16:52:37.563', 'Id': '23008''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Could I construct (for some wired reason) a DFA that has a state that is not connected to anything, and it would still be legal?</p>\n\n<p>I'm studying for a test, and I found a question that asks if an infinite DFA could represent a regular language, and I want to use a regular DFA and add all the infinite states not connected to the original. Can I do that?</p>\n", 'ViewCount': '231', 'Title': 'Do all states in a DFA must be connected?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-27T17:49:15.833', 'LastEditDate': '2014-03-27T15:14:26.687', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '23145', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15081', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-03-27T13:47:11.203', 'Id': '23127''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was trying to find info about this Finite Automata type FAB (Finite Automata Bowl) and wasn't able to find a lot. It is basically the rules that apply to PDA apply to FAB except you drop the temporal order of the stack. So instead of being restricted to only removing the top symbol of the stack, you can remove any symbol of the bowl.</p>\n\n<p>The question is, does there exist a context-free language that is <em>not</em> accepted by an FAB?</p>\n", 'ViewCount': '57', 'Title': 'What is Finite Automata Bowl?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-31T07:58:15.327', 'LastEditDate': '2014-03-31T07:58:15.327', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16197', 'Tags': '<terminology><reference-request><automata><finite-automata>', 'CreationDate': '2014-03-27T14:56:09.013', 'Id': '23128''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It seems like the proof that $A_{DFA}$ is decidable in <a href="http://rads.stackoverflow.com/amzn/click/0534950973" rel="nofollow">Sipser (2nd ed.)</a> assumes the computation will halt... and hence only really proves that $A_{DFA}$ is recognizable. </p>\n\n<p>The language $A_{DFA}$ is defined by $A_{DFA} = \\{\\langle B, w \\rangle \\mid B \\text{ is a } \\mathsf{DFA} \\text{ that accepts input string } w \\}$.</p>\n\n<p>Here is the passage (I\'ve bolded the most relevant sentence):</p>\n\n<blockquote>\n  <p>First, let\'s examine the input $\\langle B, w \\rangle$. It is a representation of a $\\mathsf{DFA}$ $B$ together with a string $w$. One reasonable representation of $B$ is simply a list of its five components, $Q$, $\\Sigma$, $\\delta$, $q_0$, and $F$. When $M$ receives its input, $M$ first determines whether it properly represents a $\\mathsf{DFA}$ $B$ and a string $w$. If not, $M$ rejects.</p>\n  \n  <p>Then $M$ carries out the simulation directly. It keeps track of $B$\'s current state and $B$\'s current position in the input $w$ by writing this information down on its tape. Initially, $B$\'s current state is $q_0$ and $B$\'s current input position is the leftmost symbol of $w$. The states and position are updated according to the specified transition function $\\delta$. <strong>When $M$ finishes processing the last symbol of $w$, $M$ accepts the input if $B$ is in an accepting state; $M$ rejects the input if $B$ is in a nonaccepting state.</strong></p>\n</blockquote>\n\n<p>Am I missing something or is this proof bogus?</p>\n\n<p><strong>EDIT</strong>: Never mind, I think I see my problem. A Turing machine may move back and forth, never halting, but an automaton like $B$ given finite input $w$ finishes after $|w|$ steps, correct? So $M$ does halt. Feel free to post an answer explaining this yourself - I don\'t want anyone to miss out on a chance to answer by me deleting the question. If no one responds within a day, I\'ll post an answer myself.</p>\n', 'ViewCount': '35', 'Title': 'Proof that $A_{DFA}$ is decidable in Sipser', 'LastEditorUserId': '12588', 'LastActivityDate': '2014-03-29T18:56:59.760', 'LastEditDate': '2014-03-29T18:56:59.760', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23226', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<formal-languages><finite-automata><undecidability>', 'CreationDate': '2014-03-29T18:04:51.747', 'Id': '23225''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Every proof I can find of this result is by way of regular expressions. Is there any "constructive" proof that defines the corresponding DFA (probably NFA)? For instance the proof of concatenation closure is most often presented by demonstrating the NFA. I\'m just curious whether this is out there somewhere</p>\n', 'ViewCount': '162', 'Title': 'Does there exist a proof of closure of regular languages under regular substitution by giving the corresponding DFA?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-10T06:27:44.253', 'LastEditDate': '2014-03-31T08:21:05.427', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '23623', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><reference-request><finite-automata><closure-properties>', 'CreationDate': '2014-03-30T17:15:21.897', 'Id': '23265''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><img src="http://i.stack.imgur.com/lSvI9.png" alt="enter image description here"></p>\n\n<p>Is this state machine a moore machine or a mealy machine? I am confused because the states have outputs and the transitions have output based on the input. I tried making a state table but I think its wrong. Can anyone provide the state machine?</p>\n', 'ViewCount': '44', 'Title': 'How to read edge labels like "01, 1" on a state diagram?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T08:46:59.387', 'LastEditDate': '2014-04-02T08:46:59.387', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23333', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<terminology><automata><finite-automata>', 'CreationDate': '2014-04-01T23:43:25.007', 'Id': '23329''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let A = $(Q, \\Sigma, \\delta, S, F)$ be a deterministic finite automaton associated with the language \n$L \\subseteq \\Sigma^*$ </p>\n\n<blockquote>\n  <p>$L' = \\{y \\in \\Sigma^*:\\exists x\\in L. |x| = |y|\\}$ </p>\n  \n  <p>$L \\subseteq L'$</p>\n</blockquote>\n\n<p>How do I show that there exist a NDFA associated with L' ? </p>\n", 'ViewCount': '35', 'Title': 'NDFA associated with language L', 'LastActivityDate': '2014-04-06T10:16:11.893', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16431', 'Tags': '<regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2014-04-04T01:31:52.257', 'Id': '23407''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '200', 'Title': "I need clarification about DFA's and DFA acceptable languages", 'LastEditDate': '2014-04-05T19:38:55.520', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '16480', 'FavoriteCount': '1', 'Body': "<p>In class yesterday we went over DFA's and DFA acceptable languages.  An example of a language that is not DFA acceptable was given as $\\{ ab, aabb, aaabbb, aaaabbbb, \\ldots \\}$.  The reason given was that the machine would need an infinite amount of states.  </p>\n\n<p>But wouldn't a simple DFA that has only one state that is a final state and loops back to itself on all inputs accept that language?  </p>\n\n<p>Also in class we discussed how the complement of a DFA acceptable language is also DFA acceptable simply by swapping the final states and the non-final states.  But if you had the language $L = \\{ a \\}$, over the alphabet $\\{ a, b \\}$, then obviously $L$ is DFA acceptable, but the complement of $L$ is $\\{ a, b \\}^* - \\{ a \\}$, which includes $\\{ ab, aabb, aaabbb, \\ldots \\}$.</p>\n\n<p>I think I must be misunderstanding something crucial here.  </p>\n", 'Tags': '<formal-languages><finite-automata>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-12T19:46:34.000', 'CommentCount': '4', 'AcceptedAnswerId': '23470', 'CreationDate': '2014-04-05T18:34:32.793', 'Id': '23460''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I having trouble constructing NPDAs for these two languages:</p>\n\n<p>$L_1 = \\{a^nb^m \\mid 2n \\le m \\le 3n\\}$</p>\n\n<p>$L_2 = \\{a^nb^mc^k \\mid n = m \\: or \\: m \\ne k\\}$</p>\n\n<p>Would these be the proper states for the first one?  </p>\n\n<ul>\n<li>$q_0$ \u2013 reading $a$\u2019s (initial state)  </li>\n<li>$q_1$ \u2013 reading $b$\u2019s and popping $A$\u2019s  </li>\n<li>$q_2$ \u2013 reading $b$\u2019s  </li>\n<li>$q_f$ \u2013 \ufb01nal state </li>\n</ul>\n\n<p>Would these be the proper states for the second one?  </p>\n\n<ul>\n<li>$q_0$ \u2013 reading $a$\u2019s (initial state) </li>\n<li>$q_1$ \u2013 reading $b$\u2019s and popping $A$\u2019s  </li>\n<li>$q_2$ \u2013 reading $b$\u2019s and pushing $B$\u2019s    </li>\n<li>$q_3$ \u2013 reading $c$\u2019s  </li>\n<li>$q_f$ \u2013 \ufb01nal state  </li>\n</ul>\n\n<p>How would I go from here? Any help would be appreciated.</p>\n', 'ViewCount': '50', 'Title': 'Constructing nondeterministic pushdown automata', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-08T14:54:27.627', 'LastEditDate': '2014-04-08T14:54:27.627', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16554', 'Tags': '<automata><finite-automata><pushdown-automata>', 'CreationDate': '2014-04-08T13:55:34.987', 'Id': '23551''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have always had a hard time making sense of infinities.     </p>\n\n<p>Example: the language $L = \\{ \\epsilon , 01, 0011, 000111, 00001111, ... \\}$ is not DFA acceptable because a machine capable of accepting it would require an infinite amount of states.  </p>\n\n<p>I can draw a DFA with ellipses in the middle to represent it's expansion.  I can prove that: </p>\n\n<p>For all strings x in L, using a machine M = mentioned DFA, under some finite expansion, I can accept all strings y in L, such that $|y| \\leq |x|$ and such that M has $|x| + 2$ states and such that all strings in compliment(L) are not accepted by M.</p>\n\n<p>All of those machines are finite.  </p>\n\n<p>The problem that prevents me from making the leap to claim that L is then DFA acceptable, is that I need to prove that there exists a largest string in L, but there is no largest string in L.</p>\n\n<p>Anyways, I know this sounds stupid because knowing what is proven about convergence and divergence, I should be able to make mathematical sense of this.  The problem is that no matter how much I know about infinity, I still do not think that what is said about convergence and divergence seems logical.  I always have this feeling that something is wrong.  </p>\n\n<p>So I guess I just wonder how I can look at it so that it makes more sense. </p>\n\n<p>In short, when a DFA needs a state for each character of a string in order to accept the string, and the language is an infinite set of strings whose enumeration could be represented as a sequence of strings increasing in length, how is it that a DFA needs an infinite amount of states to accept all of those strings, given each string is finite?</p>\n", 'ViewCount': '122', 'Title': 'Help me resolve my doubts about infinities, exemplified by an example of non DFA acceptable language', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-09T19:07:25.167', 'LastEditDate': '2014-04-09T13:26:57.210', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Tyson', 'PostTypeId': '1', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-04-09T04:55:45.693', 'FavoriteCount': '1', 'Id': '23583''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In my first lecture of "Theory of Automata", after giving some concepts of Alphabet, Language, transition function etc. and a couple of simple automata of an electric circuit with one and two switches, is this question.</p>\n\n<p><img src="http://i.stack.imgur.com/WIYoO.png" alt="enter image description here"></p>\n\n<p>I understand what an Alphabet as well as the Language of a DFA is, but are there any rules or steps to followed to reach a correct automaton for a given Language? Or we just have to imagine and think in our mind and get to a solution which satisfies the given Language?</p>\n\n<p>Note:- Please keep your language as simple as you can, since this is my first lecture and I am not yet aware of concepts like regular expressions or any other thing in the subject for that matter.</p>\n', 'ViewCount': '73', 'Title': 'Are there any steps or rules to draw a DFA?', 'LastActivityDate': '2014-04-12T11:19:47.723', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23699', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16703', 'Tags': '<automata><finite-automata>', 'CreationDate': '2014-04-12T07:41:22.240', 'Id': '23694''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am relatively new to the pumping lemma, and I have a problem here that I think I answered correctly, can anyone tell me if this works and if not why not </p>\n\n<p>The problem: $L=\\{www \\mid w \\in  \\{a,b\\}^*\\}$ </p>\n\n<p>My approach: </p>\n\n<p>take a string $www$ </p>\n\n<p>$u^* (v^k)^* w$ has to be a word in $L$ </p>\n\n<p>now let\'s split $www$ into $xyz$<br>\nso that $w_1=x, w_2=y,$ and $w_3=z$</p>\n\n<p>I then decide to say that x should be able to to "loop" twice\n$(x)^*(y^2)^*(z) = xyyz =wwww$ </p>\n\n<p>$wwww$ is not part of the language $www$ and therefore not regular</p>\n\n<p>Edit: Well my according to my understanding the pumping lemma by taking the "test string" we are looking at and splitting it into a portion that stays the same follow by a portion that is repeatable and then lastly another portion that remains the same. In my "approach" I took the test string "www" and split it into x,y, and z each respectively holding a single "w", with y being the repeatable section and the other two being the ones that remain the same. I double the y section and end up with a resulting xyyz which translates to wwww which appears as if it is not a part of the language www. I have a good feeling that I am wrong because of the condition "w is {a,b}<em>" which I think includes the empty string, and since the empty string is viable in the languages that accept wwww and www with the condition "w is {a,b}</em>" my pumping lemma is faulty. I would just like to know what I would have to do to tackle such a problem, its just a practice problem </p>\n', 'ViewCount': '48', 'ClosedDate': '2014-04-30T17:36:06.393', 'Title': 'Pumping Lemma Problem?', 'LastEditorUserId': '17221', 'LastActivityDate': '2014-05-01T17:17:44.297', 'LastEditDate': '2014-05-01T17:17:44.297', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17221', 'Tags': '<finite-automata><pumping-lemma>', 'CreationDate': '2014-04-30T15:38:50.900', 'Id': '24260''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given an automaton and an alphabet $\\{a, b\\} $,  and the language accepted by the automaton is $ab^*$. </p>\n\n<p>Such an automata can be found here:</p>\n\n<p><img src="http://i.stack.imgur.com/Vmutm.gif" alt="an automaton"></p>\n\n<p>My question is: this automaton cannot process the word $ba$ for example. In general,  do automata have to be able to process any word?</p>\n', 'ViewCount': '24', 'Title': 'Automata with no transition for some character', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-05-03T08:54:03.733', 'LastEditDate': '2014-05-03T08:54:03.733', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '24350', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17296', 'Tags': '<finite-automata>', 'CreationDate': '2014-05-03T08:07:09.610', 'Id': '24345''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}