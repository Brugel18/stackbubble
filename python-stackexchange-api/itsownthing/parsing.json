2390:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf" rel="nofollow">Knuth\'s original paper on $LR(k)$ grammars</a>, he proved that the decision problem "Given a CFG $G$, is there a $k$ such that $G$ is an $LR(k)$ grammar?" is undecidable.</p>\n\n<p>Is there a similar result showing that it is undecidable whether a given CFG is an $LL(k)$ grammar for some choice of $k$?  Or is this problem known to be decidable?</p>\n', 'ViewCount': '175', 'Title': 'Determining whether a CFG is $LL(k)$ for any $k$?', 'LastEditorUserId': '2131', 'LastActivityDate': '2012-12-10T22:55:35.893', 'LastEditDate': '2012-12-10T22:55:35.893', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4928', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><computability><formal-grammars><context-free><parsing>', 'CreationDate': '2012-07-23T23:15:59.023', 'Id': '2889'},2391:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<pre><code>S --&gt; Ta | b | Sc\nT --&gt; Tc | \u03bb\n</code></pre>\n\n<p>This isn't an LL grammar but I need it to be so I can do a parse table. The problem is that no matter how much I try I never manage to do make it an LL grammar. Can someone please help by making it a LL grammar? It isn't that big and I'm very confused.</p>\n", 'ViewCount': '88', 'Title': "What's wrong with this LL grammar? (very short)", 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-07T18:46:26.553', 'LastEditDate': '2012-08-14T14:07:17.107', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'Pablo Miranda', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing>', 'CreationDate': '2012-08-14T05:23:10.337', 'Id': '3172'},2392:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have been taking a compiler course of Stanford on coursera. I have a slight misunderstanding on the parsing table of the following grammar:</p>\n\n<p>S -> Sa | b</p>\n\n<p>According to the professor parsing table looks like this:</p>\n\n<ul>\n<li><p>If the leftmost nonterminal is S and the input is 'a', the production is nothing.</p></li>\n<li><p>If the leftmost nonterminal is S and the input is 'b', the production is both <code>Sa</code> and <code>b</code>.</p></li>\n</ul>\n\n<p>So if input is just <code>b</code>, then it is correct, it will go directly to production <code>b</code>.\nBut how will it go to production <code>Sa</code> for input <code>b</code>?</p>\n", 'ViewCount': '321', 'Title': 'LL(1) parsing table of left-recursive grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:11.390', 'LastEditDate': '2014-01-23T17:17:11.390', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Batman', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing><left-recursion>', 'CreationDate': '2012-08-14T07:11:18.640', 'Id': '3173'},2393:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I got one grammar:</p>\n\n<pre><code>re2: re1 $\n\nre1: expr == expr | expr != expr | expr &lt; expr | expr &lt;= expr | expr &gt;= expr | expr &gt; expr | expr\n\nexpr: expr + term | expr - term | term\n\nterm: term * factor | term / factor | factor\n\nfactor: (expr) | num | id\n\nnum: (0|1|2|3|4|5|6|7|8|9)num | \u03b5\n\nid: (a|b|....|z|A|B|....|Z|)id | \u03b5\n\nHere are the FOLLOW sets:\n\nFOLLOW(r2) = {}\nFOLLOW(r1) = {$}\nFOLLOW(expr) = {=,!,&lt;,&gt;,+,-,)}\nFOLLOW(term) = FOLLOW(factor) = FOLLOW (id) = FOLLOW (num) = {=,!,&lt;,&gt;,+,-,),*,/}\n</code></pre>\n\n<p>Now this grammar clearly got reduce-reduce conflict from\nnum: \u03b5 and id: \u03b5 because FOLLOW(num) \u2229 FOLLOW(id) != empty set</p>\n\n<p>Now let's say I fix the grammar by  doing the following (I assume it is mistake in the grammar because (\u03b5 == \u03b5) makes no sense):</p>\n\n<pre><code>num: (0|1|2|3|4|5|6|7|8|9)num | (0|1|2|3|4|5|6|7|8|9)\nid: (a|b|....|z|A|B|....|Z|)id | (a|b|....|z|A|B|....|Z|) \n</code></pre>\n\n<p>Now my question is, is this grammar SLR i.e can it be parsed by SLR parser? I know by building the parser I can find out but on exam I can not make the whole parser and then determine (I would lose lot of time).</p>\n", 'ViewCount': '344', 'Title': 'Ambiguous grammar? Could the grammar be parsed by SLR parser?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-05T22:08:40.713', 'LastEditDate': '2012-08-25T04:03:25.147', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'user1377320', 'PostTypeId': '1', 'OwnerUserId': '2634', 'Tags': '<formal-languages><formal-grammars><compilers><parsing>', 'CreationDate': '2012-08-24T22:55:28.367', 'Id': '3325'},2394:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I just started reading "Parsing Techniques, A Practical Guide", Second Edition, by Dick Grune and Ceriel J.H. Jacobs. </p>\n\n<p>On page 12, the authors start describing a set of rules that can be used to generate the set of all enumerations of names of the type "tom, dick and harry": the rules allow single names (e.g. "tom") as well as repetitions ("tom, harry, dick, dick and harry"); multiple names in an enumeration are separated by commas except the last two names which are separated by "and", so the following aren\'t valid: ("tom, harry, dick") or ("harry and tom and dick"). </p>\n\n<p>A few pages later, and after having defined some more terms and formalisms, the authors come up with the following replacement rules (parse structure grammar) to generate the sentences of the desired type:</p>\n\n<pre><code>0. Name -&gt; tom | dick | harry\n1. Sentence-&gt; Name | List End\n2. List -&gt; Name | Name, List\n3. , Name End -&gt; and Name\n</code></pre>\n\n<p>In the above, <strong>Sentence</strong> is the start symbol.</p>\n\n<p>However it seems to me that these rules can generate incorrect sentences: if we replace <strong>Sentence</strong> by <strong>List End</strong> and <strong>List</strong> by <strong>Name</strong> we end up with <strong>Name End</strong> for which no replacement rule is defined.</p>\n\n<p>It seems to me that the 2nd line in the rules above, if replaced by</p>\n\n<pre><code>Sentence -&gt; Name | Name, List End\n</code></pre>\n\n<p>would fix this problem. </p>\n\n<p>Am I correct that the authors have made an oversight, and is my modification correct? Or have I misunderstood something?</p>\n\n<p>I don\'t have a CS background and this is the first time I\'m reading about parsing, so please keep that in consideration in your replies. Thanks!</p>\n', 'ViewCount': '254', 'Title': 'Is this phrase structure grammar from my textbook correct?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-05T12:46:51.640', 'LastEditDate': '2012-09-05T07:47:54.720', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3428', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2736', 'Tags': '<formal-languages><formal-grammars><parsing>', 'CreationDate': '2012-09-05T03:34:36.257', 'Id': '3427'},2395:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Say I have an LR grammar <em>G</em> and a string <em>w</em>. I know that I can check if <em>w</em> is in the language of <em>G</em> in linear time. But what if <em>w</em> itself is not in the language of <em>G</em>, but I want to find all substrings of <em>w</em> that are in the language of <em>G</em>? And can I get parse trees for those substrings? What would be the time complexity for these things?</p>\n', 'ViewCount': '91', 'Title': 'Given an LR grammar G and a string w, is it possible to quickly find all substrings in w that are in L(G)?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-22T18:34:46.167', 'LastEditDate': '2012-09-12T12:15:54.237', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'oskarkv', 'PostTypeId': '1', 'Tags': '<formal-grammars><parsing><substrings>', 'CreationDate': '2012-08-08T15:52:55.883', 'Id': '3512'},2396:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m being asked to create a "top down grammar" for a certain language (I\'m pretty sure there\'s no such thing as a "top down grammar" but I think it means write a grammar that an LL(k) parser can parse).</p>\n\n<p>I\'m pretty sure the language is not LL(1), but I can remove left-recursion and common prefixes from it and still have an unambiguous grammar. But I\'m a little confused about the significance of that. If I successfully removed left-recursion and common prefixes and the grammar is still unambiguous, is the language LL(k)? And does that mean it can be parsed by a top-down parser?</p>\n', 'ViewCount': '205', 'Title': 'Can an LL(k) parser parse any grammar without left recursion or common prefixes?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-09T19:24:19.990', 'LastEditDate': '2012-10-09T03:45:47.377', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Aurast', 'PostTypeId': '1', 'Tags': '<formal-languages><compilers><parsing>', 'CreationDate': '2012-09-18T15:04:43.747', 'Id': '4630'},2397:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In helping someone understand phrase generators for use with testing grammars, think compiler test cases, I noted that I have never found a phrase generator that is knowledgeable of the grammar, and is deterministic. The phrase generators I am talking about rely on the grammar of the language as input so that the user does not have to recreate the rules for the grammar into a format acceptable for the tool. The tool must accept a BNF grammar; I don\'t mind if the grammar has to be factored some for the tool before input. Tools that rely on a seed or generate a random seed are what I want to avoid.</p>\n\n<p>I am aware that one can use PROLOG to generate a parser and then run a query that outputs a set of results that are phrases used for testing. I also know that it is not uncommon for these result sets to have 10**15 answers for basic cases of a grammar like C++.</p>\n\n<p>Does anyone know of such tools? They can be commercial or open-source as I don\'t plan on using it, I have my own, I just want to verify my knowledge. </p>\n\n<p>EDIT</p>\n\n<p>The tool must encompass sematic knowledge of the compiler. In other words the phrases must be able to be compiled by a compiler, not just pass the syntactic rules.</p>\n\n<p>EDIT</p>\n\n<p>I agree that the comments and answers regarding deterministic are correct and I my use of the word here is not correct.</p>\n\n<p>What I am looking for is a tool that not only takes in a BNF grammar and can use it "as is" which would mean for a grammar like C++ a basic result sets with 10**30 items. That is not an accurate number but a realistic one based on a phrase generator I have that can report the number of results before generating the results. Since that size of a result set is impractical, I have given the tool the ability to enhance the grammar with constraints, thinking tree pruning. This allows one to generate phrases for one particular branch of the grammar, and also prune and limit the sub-braches and number of recursion over those branches. Even with the constraints each result item is a valid C++ file for use as input to a C++ compiler.</p>\n\n<p>I have a proof of concept of this already, but the difference between a proof of concept and useful tool is a lot of work. So while a seed can be reused and create deterministic results, it does not allow the user to determine the conditions.</p>\n', 'ViewCount': '113', 'Title': "Phrase generators for use with testing grammars that don't use a seed", 'LastEditorUserId': '268', 'LastActivityDate': '2012-09-24T13:14:33.833', 'LastEditDate': '2012-09-24T13:14:33.833', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '4698', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<reference-request><formal-grammars><context-free><parsing><software-testing>', 'CreationDate': '2012-09-23T13:37:55.380', 'Id': '4692'},2398:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2372', 'Title': 'Understanding LEADING and TRAILING operations of an operator precedence grammar', 'LastEditDate': '2012-09-24T18:30:27.660', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Likhit', 'PostTypeId': '1', 'OwnerUserId': '2961', 'FavoriteCount': '2', 'Body': "<p>I want to understand what the <code>LEADING</code> and <code>TRAILING</code> of non-terminal in an operator precedence grammar physically mean.</p>\n\n<p>I am confused by the various definitions I have read on them. <br>\nI understand that the <code>LEADING</code> of a non-terminal is the first terminal which can be present in it's derivation. <br>\nOn the other hand, the <code>TRAILING</code> of a non-terminal is the last terminal which can be present in it's derivation. <br><br>\nIn the following example: <br></p>\n\n<pre><code>E   -&gt;  E   +   T      -- I\nE   -&gt;  T              -- II\nT   -&gt;  T   *   F      -- III\nT   -&gt;  F              -- IV\nF   -&gt;  (   E   )      -- V\nF   -&gt;  id             -- VI\n</code></pre>\n\n<p>By my understanding,</p>\n\n<pre><code>LEADING(E) = { +, *, (, id }\nLEADING(T) = { *, (, id }\nLEADING(F) = { (, id }\n</code></pre>\n\n<p>This turns out fine, but my problem is in the TRAILING.</p>\n\n<pre><code>TRAILING(F) = { id, ) }\nTRAILING(T) = TRAILING(F) = { id, ) }          -- (1)\nTRAILING(E) = TRAILING(T) = { id, ) }          -- (2)\n</code></pre>\n\n<p>Reason for <code>(2)</code> is that according to productions <code>I</code> and <code>II</code>, the last terminal of the derivation of <code>E</code> will be last terminals in the derivation of <code>T</code>.\nHence, <code>TRAILING(E) = TRAILING(T)</code>.<br>\nSimilarly, <code>TRAILING(T) = TRAILING(F)</code>.<br><br>\nUnfortunately the solution to this problem states:</p>\n\n<pre><code>TRAILING(F) = { id, ) }\nTRAILING(T) = TRAILING(F) `union` { * } = { *, id, ) }\nTRAILING(E) = TRAILING(T) `union` { + } = { +, *, id, ) }\n</code></pre>\n\n<p>I don't see how <code>*</code> or <code>+</code> can be the last terminals in the derivation of <code>E</code>. Any derivation of <code>E</code> will always end with either an <code>id</code> or <code>)</code>. Similarly, case for <code>T</code>.</p>\n", 'Tags': '<terminology><formal-grammars><parsing>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-27T03:12:52.417', 'CommentCount': '6', 'AcceptedAnswerId': '7223', 'CreationDate': '2012-09-24T12:40:55.317', 'Id': '4716'},2399:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '923', 'Title': 'Is there any way to distinguish between LL(k) and LR(k) grammar?', 'LastEditDate': '2012-10-05T19:53:15.253', 'AnswerCount': '2', 'Score': '8', 'OwnerDisplayName': 'Deb', 'PostTypeId': '1', 'OwnerUserId': '3075', 'FavoriteCount': '2', 'Body': '<p>I am recently studying about Compilers designing. I came to know about two types of grammar one is LL grammar and other is LR grammar.</p>\n\n<p>We also know the facts that every LL grammar is LR that is LL grammar is a proper subset of LR grammar. First one is used in top-down parsing and the second one is used in bottom-up parsing.  </p>\n\n<p>But is there any way to so that we can say that a given grammar is LL or LR?</p>\n', 'Tags': '<formal-grammars><compilers><parsing>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-06T03:43:28.817', 'CommentCount': '3', 'AcceptedAnswerId': '4897', 'CreationDate': '2012-10-05T14:27:41.813', 'Id': '4888'},23910:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a formula $ \\neg((q \\implies \\neg q) \\vee p \\vee (\\neg q \\implies (r \\wedge p))) $.</p>\n\n<p>As it contains 3 subformulas between the $\\vee$'s, how can i put it into a parse tree, as a parse tree contains 2 branches from each node.</p>\n", 'ViewCount': '242', 'Title': 'How to make a parse tree for the following propositional logic formula?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T09:21:21.817', 'LastEditDate': '2012-10-07T16:22:33.433', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '4921', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3088', 'Tags': '<formal-languages><logic><binary-trees><parsing>', 'CreationDate': '2012-10-07T12:33:25.243', 'Id': '4918'},23911:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having diffuculties understanding the principle of lookahead in LR(1) - items. How do I compute the lookahead sets ? </p>\n\n<p>Say for an example that I have the following grammar:</p>\n\n<p>S -> AB\nA -> aAb | b\nB -> d</p>\n\n<p>Then the first state will look like this:</p>\n\n<pre><code>S -&gt; .AB , {look ahead}\nA -&gt; .aAb, {look ahead}\nA -&gt; .b, {look ahead}\n</code></pre>\n\n<p>I now what look aheads are, but I don't know how to compute them. I have googled for answers but there isn't any webpage that explains this in a simple manner.</p>\n\n<p>Thanks in advance </p>\n", 'ViewCount': '500', 'Title': 'LR(1) - Items, Look Ahead', 'LastActivityDate': '2014-01-28T11:28:50.617', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6772', 'Score': '2', 'OwnerDisplayName': 'mrjasmin', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><formal-grammars><context-free><parsing>', 'CreationDate': '2012-11-19T18:00:06.743', 'Id': '6771'},23912:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the family of grammars $G_n,~n\\geq2$.\n$$S \\rightarrow A_ib_i~,~for~~1\\leq i \\leq n$$\n$$A_i \\rightarrow a_jA_i~|~a_j~,~for~~1 \\leq i,j \\leq n~~and~~i \\neq j$$</p>\n\n<p>where multiple alternative right sides result from different values of $i,j$\nwhile the terminal symbols $a_i$ and $b_i$ are not necessarily different from each other.</p>\n\n<ol>\n<li><p>Show that $G_n$ has exactly $n*2^{n-1}+n^2+1$ sets of LR(0) items.</p></li>\n<li><p>Examine if $G_n$ is LR(k) for some k.</p></li>\n</ol>\n\n<p>The above exercise is similar to Exercise 4.6.7 (page 258) from the "Compilers: Principles, Techniques &amp; Tools", 2nd Edition (a.k.a.Dragonbook) by Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman.</p>\n\n<p>I gave it much thought and also read chapter 4 of the book that is about Syntax Analysis but I still can\'t figure out how to prove this. Especially for question 2. I have no clue how to draw a conclusion about if this family of grammars can be parsed by an LR(k) parser.</p>\n\n<p>For part 1., I think it could be suitable to use induction to prove that this is the exact number of states for any $n \\geq 2$. At first, you have to construct the LR(0) states for $G_2,~n = 2$ and prove that the states correspond to the formula we have to prove. And it happens that way, as there are 9 LR(0) states which means that $\\Rightarrow n*2^{n-1}+n^2+1=2*2^{2-1}+2^2+1=4+4+1=9$. If it is helpful, I could post the state diagram for $n=2$.\nAlso, I don\'t know if this would help, but I proved that the productions for any $n$ is exactly $2n^2-n$.</p>\n', 'ViewCount': '251', 'Title': 'Parsing family of grammars, determine if LR(k)', 'LastEditorUserId': '4854', 'LastActivityDate': '2012-12-15T23:49:18.337', 'LastEditDate': '2012-12-15T23:49:18.337', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4854', 'Tags': '<formal-grammars><parsing>', 'CreationDate': '2012-12-05T23:45:46.217', 'Id': '7201'},23913:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On Facebook HackerCup 2013, they asked the following question:</p>\n\n<blockquote>\n  <p>Your friend John uses a lot of emoticons when you talk to him on\n  Messenger. In addition to being a person who likes to express himself\n  through emoticons, he hates unbalanced parenthesis so much that it\n  makes him go :(</p>\n  \n  <p>Sometimes he puts emoticons within parentheses, and you find it hard\n  to tell if a parenthesis really is a parenthesis or part of an\n  emoticon.</p>\n  \n  <p>A message has balanced parentheses if it consists of one of the\n  following:</p>\n  \n  <ul>\n  <li>An empty string "" </li>\n  <li>One or more of the following characters: \'a\' to\n  \'z\', \' \' (a space) or \':\' (a colon) </li>\n  <li>An open parenthesis \'(\', followed\n  by a message with balanced parentheses, followed by a close\n  parenthesis \')\'. </li>\n  <li>A message with balanced parentheses followed by\n  another message with balanced parentheses. </li>\n  <li>A smiley face ":)" or a\n  frowny face ":(" </li>\n  </ul>\n  \n  <p>Write a program that determines if there is a way to\n  interpret his message while leaving the parentheses balanced.</p>\n</blockquote>\n\n<p><a href="http://stackoverflow.com/questions/6447289/how-to-print-all-possible-balanced-parentheses-for-an-expression">Balancing parentheses</a> is talked about in a lot of places.  E.g. <code>(()) vs ()()</code>.  You can count</p>\n\n<ul>\n<li><code>\'(\' = +1 </code> </li>\n<li><code>\')\' = -1 </code></li>\n</ul>\n\n<p>Then you have to make sure your sum never falls below <strong>0</strong>. </p>\n\n<p>In this question they consider <code>:)</code> and <code>:(</code> as balanced and I wonder how much it changes things. One <a href="https://gist.github.com/4660602" rel="nofollow">solution</a> says that you can replace <code>r\'[^a-z:() ], \'\'</code>, <code>\':)\' -> \'}\'</code> and <code>\':(\' -> \'{\'</code>.  </p>\n\n<p>While I agree with the first sub, why are the last two substitutions valid?</p>\n', 'ViewCount': '177', 'Title': 'Facebook Hackercup 2013: Balanced Smileys', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-30T12:46:36.447', 'LastEditDate': '2013-01-30T12:46:36.447', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><context-free><binary-trees><parsing>', 'CreationDate': '2013-01-29T22:41:19.300', 'Id': '9285'},23914:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to define a non terminal symbol in a LALR(1) grammar (with CUP parser). It is requested that </p>\n\n<pre><code>the &lt;code&gt; token must appear exactly twice, \nwhile the &lt;hour&gt; token must appear at least once.\n</code></pre>\n\n<p>In the end I came up with this definition:</p>\n\n<pre><code>section     ::= hour_l CODE SC hour_l CODE SC hour_l ;\nhour_l      ::= /* epsilon */ \n            | hour_l HOUR SC ;\n</code></pre>\n\n<p>where <code>SC</code> is a separator (semicolon) between tokens and <code>hour_l</code> is the non terminal symbol for hour's list.\nThis solution has a problem: <code>HOUR</code> can be absent, because <code>epsilon</code> can be reduced from <code>hour_l</code>.\nIs there a clever solution other than specifying all possibilities or using the semantic capabilities of CUP (ie. putting a counter of how many times <code>HOUR</code> is present in <code>section</code>)? I'd prefer not to use semantics in order to achieve this; in fact, it seems to me this is syntax related.</p>\n\n<p>Thanks</p>\n", 'ViewCount': '33', 'Title': 'How to define at least one occurrence of a string between two tokens in bottom up LALR(1) parser grammar', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-22T11:22:49.337', 'LastEditDate': '2013-02-22T11:09:22.340', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10021', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6961', 'Tags': '<formal-grammars><parsing>', 'CreationDate': '2013-02-20T09:09:56.133', 'Id': '9961'},23915:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve recently came across a <a href="http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/FSF-ciaa06.pdf">paper</a> describing the parsing technique\nmentioned in the title. Unfortunately, the terminology used in said paper\nis somewhat beyond my comprehension, so I\'ve been attempting to grasp the\nconstruction algorithm more intuitively. I believe I succeeded (<a href="http://www.docstoc.com/docs/79482088/Approximating-Context-Free-Grammars-for-Parsing-and-Verification">this\npresentation</a> was the source of the ah-ha moment), but a verification of\ncorrectness from someone either familiar with the technique or the terminology\ncontained therein would be greatly appreciated.</p>\n\n<p>I\'m going to describe my take on the solution (if it\'s correct, I believe it\ncould be of help to other people attempting to understand the technique) and\nask additional questions afterwards. To ensure there\'s no misunderstanding,\nI\'m going to use the following standard notation: $a, b, c, ... \\in T$, $A, B,\nC, ... \\in N$, $... X, Y, Z \\in N \\cup T$, $\\alpha, \\beta, \\gamma, ... \\in \\{N\n\\cup T\\}^*$ and, as in the paper, $A \\xrightarrow{i} \\omega$ to denote rule number $i$. However, I\'ll probably use different names for concepts than\nthe original paper.</p>\n\n<p>Also, throughout the description, the equivalence relation $\\kappa_0$ is used.</p>\n\n<h3>Construction</h3>\n\n<p>There are two kinds of items inside the parsing automaton: simple LR(0) items\nof the form $A \\xrightarrow{i} \\alpha \\bullet \\beta$ which I call <em>shift items</em>\nand items of the form $A \\xrightarrow{i} \\alpha \\bullet \\beta, m, n$ which I\ncall <em>resolve items</em>; these tell the parser to push $n$ symbols back the\ninput stream and then reduce by rule number $m$ upon the first symbol of $\\beta$.</p>\n\n<p>The grammar is augmented with the rule $S\' \\xrightarrow{0} S \\$$ and the construction starts with the shift item $S\' \\xrightarrow{0} \\bullet S \\$ $ in the initial state.</p>\n\n<p>Now, to construct the automaton, decide between these alternatives for each item in a state $q$:</p>\n\n<ol>\n<li><p>If the item is a shift item $A \\xrightarrow{i} \\alpha \\bullet \\beta$,\nthere will be a transition $q \\xrightarrow{X} q\'$ in the automaton, where\n$X$ is the first symbol of $\\beta$.</p></li>\n<li><p>If the item is a finished shift item $A \\xrightarrow{i} \\omega \\bullet$,\nadd a resolve item $B \\xrightarrow{j} \\alpha A \\bullet \\beta, i, 0$ for each rule $B \\xrightarrow{j} \\alpha A \\beta$.</p></li>\n<li><p>If the item is a resolve item $A \\xrightarrow{i} \\alpha \\bullet \\beta, m, n$, let $X$ be the first symbol of $\\beta$. If $X \\in N$, add a shift item $X \\xrightarrow{j} \\bullet \\omega$ for each rule $X \\xrightarrow{j} \\omega$. If other items than $A \\xrightarrow{i} \\alpha \\bullet \\beta, m, n$ have $X$ as their dot lookahead, add a transition $q \\xrightarrow{X} q\'$ to the automaton.\nEvery resolve item $C \\xrightarrow{i} \\alpha \\bullet X \\beta, m, n$ in $q$ will result in a resolve item $C \\xrightarrow{i} \\alpha X \\bullet \\beta, m, n + 1$ in $q\'$.</p></li>\n<li><p>If the item is a resolve item $A \\xrightarrow{i} \\omega \\bullet, m, n$ it\nwon\'t contribute any lookahead information and can be discarded, but first add a resolve item $B \\xrightarrow{j} \\alpha A \\bullet \\beta, m, n$ for each rule\n$B \\xrightarrow{j} \\alpha A \\beta$.</p></li>\n</ol>\n\n<p>This is, of course, just a sketch; actually, a closure of the state must be calculated first and only then can we deal with transitions/shifts and resolutions.</p>\n\n<p>Transforming the automaton into a shift-resolve parsing table is trivial afterwards; just, as a minor variation, the authors of the paper interpret a resolution $r_{0,0}$ as the accept action. Given the resulting automaton, I found it handier to simply treat a shift of $\\$$ as the accept action.</p>\n\n<h3>Questions</h3>\n\n<p>The first one is, obviously, whether the process described above is correct.</p>\n\n<p>The second one is about the equivalence relations. I can only guess that the equivalence relation $\\kappa$ is what\'s responsible for deciding which resolve items are brought in when a finished shift item has been seen. $\\kappa_0$ seems to result in lookahead strikingly similar to the $FOLLOW_{LM}$ sets of LSLR parsers. The paper describes a "finer equivalence relation" on page 11; is there a way to interpret this relation in intuitive terms? Are there other relations known?</p>\n\n<p>And the final one is about conflict resolution. The paper describes well what constitutes an inadequacy in a shift-resolve automaton; is there a way of resolving these inadequacies, similar to ways of resolving conflicts in a traditional LR parser? Could something like <em>yacc</em>-style conflict resolution via precedence and associativity be implemented in a ShRe parser generator?</p>\n\n<p>Thanks if you read all this and any answers will be greatly appreciated :)</p>\n', 'ViewCount': '165', 'Title': 'Shift-resolve parsing - questions', 'LastEditorUserId': '4383', 'LastActivityDate': '2013-02-28T19:09:45.330', 'LastEditDate': '2013-02-26T20:28:26.713', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4383', 'Tags': '<algorithms><formal-grammars><context-free><parsing>', 'CreationDate': '2013-02-26T16:10:49.380', 'FavoriteCount': '2', 'Id': '10123'},23916:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '84', 'Title': 'Priority in formal grammar', 'LastEditDate': '2013-02-28T11:20:49.453', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4409', 'FavoriteCount': '1', 'Body': '<p>From my recitation class, I have the following exercise:</p>\n\n<blockquote>\n  <p>$\\mathrm{EXP} = 0 \\mid 1 \\mid b \\mathrm{EXP} \\mid \\mathrm{EXP} a \\mid \\mathrm{EXP} m \\mathrm{EXP}$</p>\n  \n  <p>The above grammar is ambiguous.</p>\n  \n  <p>Make an unambiguous grammar which produce same language as the above.</p>\n  \n  <p>In the new grammar, $a$ has priority over $b$ and $b$ has priority over $m$.\n  Also $m$ is associative.</p>\n</blockquote>\n\n<p>Can you explain what the phrases</p>\n\n<ul>\n<li>"has priority over" and</li>\n<li>"$m$ is associative"</li>\n</ul>\n\n<p>mean?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsing><ambiguity>', 'LastEditorUserId': '4409', 'LastActivityDate': '2013-02-28T14:58:59.373', 'CommentCount': '1', 'AcceptedAnswerId': '10151', 'CreationDate': '2013-02-27T19:11:49.933', 'Id': '10142'},23917:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do we determine minimum $k$ such that $G$ is a strong $LL(k)$ Grammar</p>\n\n<p>Like for grammar $G$ with the following rules\n$S\\rightarrow aAcaa \\mid bAbcc,A\\rightarrow a \\mid ab \\mid \\epsilon$</p>\n', 'ViewCount': '85', 'Title': 'Lookahead set: Determining minimum $k$ such that $G$ is a strong $LL(k)$ grammar', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-03-06T13:15:18.180', 'LastEditDate': '2013-03-05T12:02:22.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10271', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<context-free><formal-grammars><parsing>', 'CreationDate': '2013-03-03T21:14:35.493', 'Id': '10245'},23918:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let me know the first and follow sets of the following grammar, also the explanation to it</p>\n\n<p>$A \\to Ba \\mid Aa \\mid c$<br>\n$B \\to Bb \\mid Ab \\mid d$</p>\n\n<p>Non-terminals: $\\{A,B\\}$<br>\nTerminals: $\\{a,b,c,d\\}$</p>\n', 'ViewCount': '657', 'ClosedDate': '2014-02-27T15:10:50.473', 'Title': 'A problem on first and follow sets of a grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-27T02:19:16.383', 'LastEditDate': '2013-03-27T12:17:29.440', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '-4', 'PostTypeId': '1', 'OwnerUserId': '4865', 'Tags': '<context-free><parsing>', 'CreationDate': '2013-03-27T11:29:37.490', 'Id': '10824'},23919:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In college we have been learning about theory of computation in general and Turing machines more specifically. One of the great theoretical results is that at the cost of a potentially large alphabet (symbols), you can reduce the number of states down to only 2.</p>\n\n<p>I was looking for examples of different Turing Machines and a common example presented is the Parenthesis matcher/checker. Essentially it checks if a string of parentheses, e.g (()()()))()()() is balanced (the previous example would return 0 for unbalanced). </p>\n\n<p>Try as I may I can only get this to be a three state machine. I would love to know if anyone can reduce this down to the theoretical minimum of 2 and what their approach/states/symbols was!</p>\n\n<p>Just to clarify, the parentheses are "sandwiched" between blank tape so in the above example\n- - - - - - - (()()()))()()() - - - - - - - would be the input on the tape. The alphabet would include (,),1,0,-, and the <em>halt</em> state does not count as a state.</p>\n\n<p>For reference the three state approach I have is as follows:\nDescription of states:</p>\n\n<pre><code> State s1: Looks for Closing parenthesis\n\n State s2: Looks for Open parenthesis\n\n State s3: Checks the tape to ensure everything is matched\n</code></pre>\n\n<p>Symbols: ),(,X\nTransitions Listed as:</p>\n\n<p>Action: State Symbol NewState WriteSymbol Motion</p>\n\n<p>// Termination behavior</p>\n\n<p>Action: s2 - <em>halt</em> 0  -</p>\n\n<p>Action: s1 -  s3    -  r</p>\n\n<p>//Transitions of TM</p>\n\n<p>Action: s1 (  s1  (   l</p>\n\n<p>Action: s1 )  s2  X  r</p>\n\n<p>Action: s1 X  s1  X  l</p>\n\n<p>Action: s2 ( s1 X  l</p>\n\n<p>Action: s2 X  s2 X r</p>\n\n<p>Action: s3 (  <em>halt</em> 0 -</p>\n\n<p>Action: s3 X  s3     X r</p>\n\n<p>Action: s3 -  <em>halt</em> 1 -</p>\n\n<p>Forgive the informal way of writing all this down. I am still learning the theoretical constructs behind this.</p>\n', 'ViewCount': '1114', 'Title': 'Two-State Turing Machine for Parenthesis Matching', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-06T21:27:16.633', 'LastEditDate': '2013-04-06T21:27:16.633', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'Four_FUN', 'PostTypeId': '1', 'OwnerUserId': '7590', 'Tags': '<context-free><turing-machines><parsing>', 'CreationDate': '2013-04-05T06:57:23.333', 'Id': '11044'},23920:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Me and my friends are studying for an upcoming test and this exercise is one of the harder ones for us. </p>\n\n<p>We have been trying to solve it and we have been looking at similar exercises, the problem is that the explanations are too complicated for us to understand. Keep in mind we just started with this. </p>\n\n<p>So, my question is: Can anyone explain this as simple as possible, I have included the exercise. </p>\n\n<p><img src="http://i39.tinypic.com/3y81t.png" alt="Exercise"></p>\n', 'ViewCount': '136', 'Title': 'Parsing a string with LR parsing table', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-05-13T20:29:54.107', 'LastEditDate': '2013-05-13T20:29:54.107', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'Jakob Danielsson', 'PostTypeId': '1', 'Tags': '<parsing>', 'CreationDate': '2013-05-11T13:32:55.117', 'Id': '11962'},23921:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am writing this, because no matter how I look at the algorithm I see an error :-)</p>\n\n<p>Aho &amp; Ullman in "Theory of Parsing, vol.1" (pp. 357-359) described the algorithm for building $FIRST_k(A)$ set for any $A$ non terminal by incrementally building helper set $F_i(A)$ which has such property that every $F_i(A)$ set is contained in $F_{i+1}(A)$ and it is finally equal to $FIRST_k(A)$.</p>\n\n<p>However I found a counter example for this, for $k=2$.</p>\n\n<pre><code>A := a B\nB := b\n</code></pre>\n\n<p>$FIRST_k(A) = \\{ a b \\}$, while $F_0(A) = \\{ a \\}$.</p>\n\n<p>Any help is appreciated, here is shortened content of those pages -- <a href="http://www.seanerikoconnor.freeservers.com/ComputerScience/Compiler/ParserGeneratorAndParser/QuickReviewOfLRandLALRParsingTheory.html#FIRSTk" rel="nofollow">FIRST(k)</a> -- and if you don\u2019t have a book, I asked the same question in longer form as blog-post -- <a href="http://skila.pl/?page=2013/06/14/lalrk-first-sets/" rel="nofollow">LALR(k) FIRST sets</a>.</p>\n', 'ViewCount': '22', 'Title': '$FIRST_k$ set -- is algorithm given by Aho&Ullman correct?', 'LastActivityDate': '2013-06-18T20:39:43.047', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12754', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8742', 'Tags': '<parsing>', 'CreationDate': '2013-06-18T20:07:11.783', 'Id': '12753'},23922:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '312', 'Title': 'Does an abstract syntax tree have to be a tree?', 'LastEditDate': '2013-07-07T17:46:36.707', 'AnswerCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '9034', 'FavoriteCount': '1', 'Body': '<p>Does the output of a parser have to be a tree or could it also be general graph?</p>\n\n<p>Moreover, is there any existing language or a plausible one that uses general graphs representation instead of trees for their syntax?</p>\n', 'Tags': '<compilers><parsing>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-10T21:03:58.573', 'CommentCount': '1', 'AcceptedAnswerId': '13128', 'CreationDate': '2013-07-07T09:10:38.660', 'Id': '13126'},23923:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to learn how to build parse trees. \nThis is a very simple example as I am hoping I can catch on to the concept. \n$\\mathtt{y=x+z}$</p>\n\n<p>Wouldn't this simply require $\\mathtt{(term) = (term) + (term)}$?\nI'm not sure how to express my answer on here but would it only require one branch due to the $\\mathtt{=}$ sign?</p>\n", 'ViewCount': '135', 'Title': 'Parse Tree building', 'LastEditorUserId': '39', 'LastActivityDate': '2013-07-31T16:00:24.340', 'LastEditDate': '2013-07-30T19:27:27.717', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9425', 'Tags': '<parsing>', 'CreationDate': '2013-07-30T15:56:16.427', 'Id': '13520'},23924:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I wanted to define syntax for a graph path considering it may branch out anywhere.</p>\n\n<p>For instance, I have a path going from <code>a</code> to <code>e</code> following <code>b, c, d</code>: <code>a, b, c, d, e</code>.</p>\n\n<p>Let\'s consider it (may) branches from b now: <code>a, b, (x | y), d, e</code> which actually means three different paths: </p>\n\n<p>1) <code>a, b, d, e</code></p>\n\n<p>2) <code>a, b, x, d, e</code></p>\n\n<p>3) <code>a, b, y, d, e</code></p>\n\n<p>So, each parenthesis actually means "the path might either go through any of the nodes defined in the parenthesis connecting the node just before parenthesis and right after parenthesis or through none of the nodes defined in the parenthesis".</p>\n\n<p>With more inner parenthesis, a single string line may generate even more paths. For instance: <code>a, b, (x | (z | t) | y), d, e</code> which means these five paths:</p>\n\n<p>1) <code>a, b, d, e</code></p>\n\n<p>2) <code>a, b, x, d, e</code></p>\n\n<p>3) <code>a, b, y, d, e</code></p>\n\n<p>4) <code>a, b, z, d, e</code></p>\n\n<p>5) <code>a, b, t, d, e</code></p>\n\n<p>6) <code>a, b, z, y, d, e</code></p>\n\n<p>7) <code>a, b, t, y, d, e</code></p>\n\n<p>8) <code>a, b, x, z, d, e</code></p>\n\n<p>9) <code>a, b, x, t, d, e</code></p>\n\n<p>So, how can I define this syntax mathematically?</p>\n', 'ViewCount': '95', 'ClosedDate': '2013-08-29T23:27:41.833', 'Title': 'How can I define this syntax?', 'LastEditorUserId': '6899', 'LastActivityDate': '2013-08-17T13:31:05.470', 'LastEditDate': '2013-08-17T13:31:05.470', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6899', 'Tags': '<formal-languages><parsing>', 'CreationDate': '2013-08-16T16:42:46.340', 'Id': '13779'},23925:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I think the Question is self sufficient. Is the syntax of C Language completely defined through Context Free Grammars or do we have Language Constructs which may require non-Context Free definitions in the course of parsing?</p>\n\n<p>An example of non CFL construct i thought was the declaration of variables before their use. But in Compilers(Aho Ullman Sethi), it is stated that the C Language does not distinguish between identifiers on the basis of their names. All the identifiers are tokenized as 'id' by the Lexical Analyzer. If C is not completely defined by CFGs, please can anyone give an example of Non CFL construct in C?</p>\n", 'ViewCount': '98', 'Title': 'Is the Syntax of C Language completely defined by CFGs?', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-24T14:18:04.997', 'LastEditDate': '2014-03-24T14:18:04.997', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10717', 'Tags': '<context-free><programming-languages><compilers><parsing><c>', 'CreationDate': '2013-10-25T17:05:06.557', 'Id': '16426'},23926:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am learning LR(1) parsing from the Dragon Book. I am really confused with this sentence.</p>\n\n<blockquote>\n  <p>Formally we say that a configuration $[A \\to u\u2022v, a]$ is valid for a viable prefix $\u03b1$ if  there is a rightmost derivation $S \\Rightarrow^* \u03b2Aw \\Rightarrow^* \u03b2uvw$ where $\u03b1 = \u03b2u$ and either $a$ is the first symbol of $w$ or $w$ is $\u2202$ and $a$ is $\\$$. </p>\n</blockquote>\n\n<p>I am not able to figure out how validation of a configuration for a viable prefix is <em>useful</em> . What does it speak <em>intutively</em> and why does it matters?</p>\n', 'ViewCount': '47', 'Title': u'what does \u201cConfiguration is valid for a viable prefix \u201d actually means?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-03T15:24:39.277', 'LastEditDate': '2013-11-03T15:24:39.277', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11151', 'Tags': '<terminology><compilers><parsers><parsing>', 'CreationDate': '2013-11-03T14:55:18.830', 'FavoriteCount': '1', 'Id': '16673'},23927:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>The syntax of dice notation follows the following grammar:</p>\n\n<p>$$ Roll \\rightarrow Dice | Dice'x'Int | More \\quad Mod \\quad More $$\n$$ Dice \\rightarrow Int_{1}'d'Int_2$$\n$$ Mod \\rightarrow '+'|'-'$$\n$$ More \\rightarrow Int | Roll$$\n$$ Int \\rightarrow &lt;integer&gt;$$</p>\n\n<p>Give a leftmost derivation for the sample string:\n$3d8 + 2d4x3 + 1d12 + 567$</p>\n\n<p>I was able to parse the two first operands $3d8 + 2d4x3$ but I couldn't find a reasonable derivation for the rest.</p>\n\n<p>My solution is like:</p>\n\n<pre><code>E -&gt; More Mod More\nE -&gt; Roll Mod More\nE -&gt; Dice Mod More\nE -&gt; Int1\u2019d\u2019Int2 Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019Int2 Mod More\n...\n...\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + More Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + Roll Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + Dice Mod More\nE -&gt; &lt;integer&gt;\u2019d\u2019&lt;integer&gt; + &lt;integer&gt;\u2019d\u2019&lt;integer&gt;\u2019x\u2019&lt;integer&gt; + Int1\u2019d\u2019Int2 Mod More\n</code></pre>\n\n<p>I was thinking that the given string is not a valid string for this grammar.</p>\n\n<p>Does any have any idea for this problem. I'm newbie in Compiler Design :-)</p>\n", 'ViewCount': '45', 'Title': 'Parsing Dice Notation', 'LastEditorUserId': '11326', 'LastActivityDate': '2013-12-26T10:35:13.830', 'LastEditDate': '2013-11-22T01:00:42.440', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<parsers><parsing>', 'CreationDate': '2013-11-22T00:55:20.480', 'Id': '18245'},23928:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In working with <a href="http://en.wikipedia.org/wiki/Parser_combinator" rel="nofollow">parser combinators</a> I have been working with three means of handling <a href="http://en.wikipedia.org/wiki/Order_of_operations#Programming_languages" rel="nofollow">precedence</a> and <a href="http://en.wikipedia.org/wiki/Operator_associativity" rel="nofollow">associtivy</a> for <a href="http://en.wikipedia.org/wiki/Infix_notation" rel="nofollow">infix</a> operators.</p>\n\n<ol>\n<li><a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#classic" rel="nofollow">The classic solution</a>.</li>\n<li><a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#shunting_yard" rel="nofollow">Shunting Yard algorithm</a>.</li>\n<li><a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm#climbing" rel="nofollow">Precedence climbing</a>.</li>\n</ol>\n\n<p>I was wondering if there are any more ways to handle the construction of the an AST from infix operators that have precedence and associativity?</p>\n\n<p>I would prefer papers on the method and possibly an example of the code in a functional language.</p>\n\n<p>I recently ran into <a href="http://www.cse.chalmers.se/~nad/publications/danielsson-norell-mixfix.pdf" rel="nofollow">Mixfix</a> / <a href="http://dl.acm.org/citation.cfm?id=5659" rel="nofollow">distfix</a> but have not yet implemented a working version.</p>\n', 'ViewCount': '19', 'Title': 'For parser combinators what are the algorithms for handling precedence and associtivity?', 'LastEditorUserId': '268', 'LastActivityDate': '2013-11-30T21:15:22.443', 'LastEditDate': '2013-11-30T21:15:22.443', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<parsing><precedence><associtivity><infix><operators>', 'CreationDate': '2013-11-29T21:26:57.407', 'Id': '18478'},23929:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following grammar, where $ [ \\ ] \\ | \\ , \\ $ are terminal symbols</p>\n\n<p>$ \n\\begin{eqnarray}\nL \\rightarrow [ \\ ] \\qquad(1) \\\\ \nL \\rightarrow [ \\ H\\ T\\ ] \\qquad(2) \\\\ \nH \\rightarrow L \\qquad (3) \\\\\nH \\rightarrow L\\ ,\\ H \\qquad (4) \\\\\nT \\rightarrow |\\ L \\qquad(5) \\\\\nT \\rightarrow \\epsilon \\qquad (6)\n\\end{eqnarray}\n$ </p>\n\n<p>I went over the step to create the DFA for that grammar, and then building parsing table.</p>\n\n<p>However, after creating those things, I cannot parse the string $ [\\ [\\ ]\\ |\\ [\\ [\\ ]\\ ,\\ [\\ [\\ ]\\ ]\\ |\\ [\\ [\\ ]\\ ]\\ ]\\ ] $\nHere is the DFA:\n<img src="http://i.stack.imgur.com/NOGWb.png" alt="DFA"></p>\n\n<pre><code>Note: In state 11, the only lookahead is $\n</code></pre>\n\n<p>I think my problem is that I determined wrong lookahead for some DFA states. But I still don\'t know what\'s wrong here.</p>\n\n<p>Can anyone give my some idea?</p>\n', 'ViewCount': '50', 'Title': 'LR(1) constructing DFA', 'LastActivityDate': '2013-12-05T01:21:01.910', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<parsing>', 'CreationDate': '2013-12-05T01:21:01.910', 'Id': '18625'},23930:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm wondering about the result of this program as I get confused when it comes to lexical scoping and dynamic scoping.</p>\n\n<pre><code>fun bar() {\n   int a = 2\n   void foo(int b) {\n       b = b * a;\n       a = a - b     \n   }\n   {\n       int a = 10;\n       foo(a);\n       print a;\n   }\n}\n</code></pre>\n\n<p>There are a couple of questions of what program will print, and here are my answers</p>\n\n<ul>\n<li>Call-by-value and lexical scoping: <strong>10</strong> because call-by-value does not change the value of variable a after calling foo(a), and within the scope of $ print $ a is 10.</li>\n<li>Call-by-value and dynamic scoping: <strong>10</strong> just as the above, call-by-value does not change the value of a</li>\n<li>Call-by-reference and lexical scoping: </li>\n<li>Call-by-reference and dynamic scoping: </li>\n</ul>\n\n<p>I get confused about the last two options. I'm wondering whether with lexical scoping it will use the value a = 10, or a = 2 in foo function, i.e. I'm not sure what will be printed 20 or 100. The confusion also holds with call-by-reference dynamic scoping</p>\n", 'ViewCount': '131', 'Title': 'lexical scoping vs. dynamic scoping', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-27T11:02:40.977', 'LastEditDate': '2013-12-27T11:02:40.977', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<programming-languages><parsing><variable-binding>', 'CreationDate': '2013-12-09T00:48:35.130', 'FavoriteCount': '1', 'Id': '18766'},23931:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Generally (perhaps always) in programming languages, unary operators have the highest precedence.  In some langauges, such as Standard ML, one can dynamically change the precedence of binary operators at run time.</p>\n\n<p>But what if we have a language where binary operators had higher precedence than unary ones?  Do such languages exist?  And how would we interpret certain cases?  For example, let's say binary <code>+</code> had higher precedence than unary prefix <code>@</code>.  In some cases this is obvious because it would mean that</p>\n\n<pre><code>@x+y\n</code></pre>\n\n<p>would parse as</p>\n\n<pre><code>@(x+y)\n</code></pre>\n\n<p>rather than</p>\n\n<pre><code>(@x)+y\n</code></pre>\n\n<p>BUT, how would we parse</p>\n\n<pre><code>x + @y\n</code></pre>\n\n<p>Would it be a syntax error (as in it cannot be parsed) or should it parse as <code>x+(@y)</code>?  I don't mean for this to necessarily be an opinion question; I am more interested to know if any real programming languages exist with high-precedence binary operators, and if so, what do they do.</p>\n", 'ViewCount': '65', 'Title': 'Binary operators with higher precedence than unary operators', 'LastActivityDate': '2013-12-10T23:54:24.810', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18846', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11993', 'Tags': '<parsing><precedence><operators>', 'CreationDate': '2013-12-10T17:23:59.173', 'Id': '18835'},23932:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following CFG which I suspect cannot be rewritten to one which is LL(1):</p>\n\n<p>$S \\rightarrow \\epsilon\\ |\\ aSbS\\ |\\ bSaS\\ |\\ cSdS\\ |\\ dScS$</p>\n\n<p>I\'ve thought about it for a while, and can\'t seem to make any progress. I know that <a href="http://stackoverflow.com/questions/15161636/making-a-grammar-ll1">the simpler grammar here</a> can be rewritten into LL(1), but it seems like there is something different about the above grammar which prevents a rewriting in a similar style. Is it possible? If not, is there an easy way to prove that this is the case?</p>\n', 'ViewCount': '109', 'Title': 'Can this CFG be written into an equivalent LL(1) grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-06T10:56:54.060', 'LastEditDate': '2014-01-06T09:24:40.650', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12290', 'Tags': '<formal-languages><context-free><formal-grammars><parsing>', 'CreationDate': '2013-12-21T19:21:26.410', 'Id': '19178'},23933:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>i am new to compiler design, currently studying Ullmans book on this.He says:</p>\n\n<p>Problem with predictive parsing (both recursive and non recursive) is that Left recursive productions can go infinite loop.Thus, to make grammar suitable for predictive parsing we need to eliminate the left recursion by immediately or indirectly.</p>\n\n<pre><code> E -&gt; E+T|t\n</code></pre>\n\n<p>My problem is, same can happen with right recursion also.What is the solution for it?</p>\n\n<pre><code> T -&gt; E+T|t\n</code></pre>\n\n<p>Please correct me if i am wrong! thanks.</p>\n', 'ViewCount': '52', 'Title': 'Need solution for infinite right recursive grammar in Predictive parsing?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T19:25:29.983', 'LastEditDate': '2014-04-12T17:48:36.483', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10564', 'Tags': '<formal-grammars><parsing><left-recursion>', 'CreationDate': '2014-01-11T12:16:06.933', 'Id': '19654'},23934:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im trying to draw an annotated parse tree for <code>3*5+4n</code>, the text book shows the following:</p>\n\n<p><img src="http://i.stack.imgur.com/TilDt.png" alt="enter image description here"><br>\n<sup>[<em>Compilers - Principles, techniques and tools (Dragon Book) by Aho, p308</em>]</sup></p>\n\n<p>I have a few questions regarding this</p>\n\n<ol>\n<li><p>Why is <code>3*5+4</code> considered as a single string? Can\'t I draw a parse tree something like \nfor the same string ie:with operator at the node <img src="http://i.stack.imgur.com/PRd1R.jpg" alt="enter image description here"> </p></li>\n<li><p>What is the need for giving <code>T.VAL=3</code> and then giving another child <code>F.VAL=3</code>. (I understand that the integer attribute for digit needs to be supplied by the lexical analyzer)</p></li>\n</ol>\n', 'ViewCount': '226', 'ClosedDate': '2014-02-03T00:27:50.477', 'Title': 'Drawing Annotated Parse Tree for Syntax Directed Definition', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T11:40:12.120', 'LastEditDate': '2014-01-30T11:13:37.357', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<formal-grammars><compilers><parsing><syntax-trees>', 'CreationDate': '2014-01-30T08:37:50.427', 'Id': '20098'},23935:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am learning Compiler Design. Can somebody explain what type of Grammar this is? The answer given is $LL(1)$ but there exists a left recursion in the grammar so it cannot be $LL(1)$. I derived the parse table it had conflicts. Am I doing some thing wrong or is the answer given wrong? </p>\n\n<p>My texbook defines:</p>\n\n<blockquote>\n  <p>For LL(1) Grammar if there is left recursion or left factoring then that grammar is not LL(1) grammar if this applies to this grammar then it is not a LL(1) grammar</p>\n</blockquote>\n\n<p>$E \\to E+T \\mid E$</p>\n\n<p>$T \\to T$#$F \\mid F$</p>\n\n<p>$F \\to (E) \\mid i$</p>\n\n<p>I also have one more question: "Is there a Grammar which can be LL(1) but not LALR(1)"</p>\n', 'ViewCount': '49', 'Title': 'Which Type of Grammar is this?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-11T22:46:43.857', 'LastEditDate': '2014-02-11T07:24:00.183', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21543', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14497', 'Tags': '<formal-grammars><compilers><parsing>', 'CreationDate': '2014-02-11T05:20:18.990', 'Id': '21520'},23936:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm reading the Dragon Book. The following is from the start of Section 3.1.3.</p>\n\n<blockquote>\n  <p>When more than one lexeme can match a pattern, the lexical analyzer must provide the subsequent compiler phases additional information about the particular lexeme that matched. For example, the pattern for token <strong>number</strong> matches both 0 and&nbsp;1, but it is extremely important for the code generator to know which lexeme was found in the source program. Thus, in many cases, the lexical analyzer returns to the parser not only a token name, but an attribute value that describes the lexeme represented by the token; the token name influences parsing decisions, while the attribute value influences translation of tokens after the parse.</p>\n</blockquote>\n\n<p>From what I understand the symbol table stores the variable name and the some details like the type, scope etc. So if a character <code>0</code> is found by the lexical analyzer, it matches the pattern for a number so it uses the token name <code>number</code> so the token becomes <code>&lt;number, attrb&gt;</code>.</p>\n\n<p>As per the snippet I have cited above, I don't understand what data is stored in the symbol table for numbers. Is the value of the number stored in the symbol table?</p>\n", 'ViewCount': '82', 'Title': 'What data is stored in the symbol table for a number token?', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-01T23:12:43.733', 'LastEditDate': '2014-02-12T13:56:55.503', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<compilers><parsing>', 'CreationDate': '2014-02-12T06:38:52.730', 'Id': '21560'},23937:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '32', 'Title': 'Left recursion for LL(1)', 'LastEditDate': '2014-03-28T01:43:23.957', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15655', 'Body': u'<p>Hi I am trying to solve a LL(1) form question for first n follow rule The question is</p>\n\n<pre><code>A::=BC|C\nB::=Bd|ef\nC::=gh|j\n</code></pre>\n\n<p>What I have done to eliminate left recursion </p>\n\n<pre><code>A::=CA\u2019\nA\u2019::=CB\u2019\nA\u2019::=\u03f5\nB::=efB\u2019\nB::=dB\u2019\nB\u2019::=\u03f5\nC::=gh\nC::= j\n</code></pre>\n\n<p>Is it correct?</p>\n\n<p>Thanks guys, it has been solved.</p>\n', 'ClosedDate': '2014-03-27T07:54:49.217', 'Tags': '<formal-languages><parsing><left-recursion>', 'LastEditorUserId': '15655', 'LastActivityDate': '2014-03-28T01:43:23.957', 'CommentCount': '1', 'AcceptedAnswerId': '22595', 'CreationDate': '2014-03-13T18:07:01.433', 'Id': '22594'},23938:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For example,</p>\n\n<p>Let the Grammar be:</p>\n\n<pre><code>S-&gt;Sa|B\n</code></pre>\n\n<p>Thus, <code>S-&gt;Sa-&gt;Saa-&gt;...-&gt;Saa...aaa-&gt;Baa...aaa</code></p>\n\n<p>What's wrong with this?</p>\n\n<p>Why is right recursion a solution to the problem?</p>\n\n<pre><code>S-&gt;BS'\nS-&gt;aS'|e\n</code></pre>\n", 'ViewCount': '35', 'ClosedDate': '2014-03-29T11:54:23.990', 'Title': 'Why does left recursion have to be eliminated?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T11:54:13.160', 'LastEditDate': '2014-03-29T11:54:13.160', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11684', 'Tags': '<context-free><formal-grammars><compilers><parsing><left-recursion>', 'CreationDate': '2014-03-29T05:06:57.450', 'Id': '23210'},23939:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Have a question that requires me to write the rules for parsing a turing machine </p>\n\n<p>This is the question</p>\n\n<p>The PROBLEM involves writing a set of Turing Machine rules that will read and determine whether or not an input corresponds to the rules of a Turing Machine. This is the \ufb01rst step of a Universal Turing Machine. For example, if the input is a legal set of rules, then the machine shall accept this input (and any other legal input that describes a Turing Machine).</p>\n\n<p>The input would be \nIO = current state with the number of  I's indicating what state\nI = would be the current symbol being true with O being false\nIIO  = next state \nI = next symbol with O being false\nI or O = direction with I being left and O being right</p>\n\n<p>so a legal input would be </p>\n\n<p>IOOIIOOI     which would be state 1 = current state false = next state 2 = next state false = left</p>\n\n<p>How would I write the rule so that if I ran it through and it detected that the rules did not conform to the legal input it would place II at the beginning of the input and if its correct put OO at the beginning.</p>\n", 'ViewCount': '38', 'Title': 'Parsing Turing Machine', 'LastActivityDate': '2014-04-06T11:12:59.550', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16493', 'Tags': '<turing-machines><parsing>', 'CreationDate': '2014-04-06T11:12:59.550', 'Id': '23474'},23940:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is pridictive just a weaker form of deterministic in context of parsing methods?\nOr is it in fact a synonym?</p>\n\n<p>In case of former one I would realy appriciate reference or some guide to one.</p>\n\n<p>I am working with definition, where predictive means generaly contracting number of next possibilities, while deterministic goes even furt and allowing max 1 next possibility.</p>\n', 'ViewCount': '8', 'Title': 'Predictive vs Determinisistic Parsing', 'LastActivityDate': '2014-05-03T22:22:19.763', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14761', 'Tags': '<parsing>', 'CreationDate': '2014-05-03T22:22:19.763', 'Id': '24370'}