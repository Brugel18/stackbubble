{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I just recently started learning in a CS context (as opposed to a programming context) about simple recursive functions, along with the combinatorial applications, and techniques such as Backtracking and Divide et Impera.</p>\n\n<p>The example problem that I chose for my questions is the n queens problem (given n queens and a n*n chessboard, how do you position the queens such that they can't attack each other?).\nI understood that the basic idea is to generate all possible placements (by generating a cartesian product) and then simply discarding them as they come along if they are invalid (through the validation function).</p>\n\n<p>Here is my sample implementation:</p>\n\n<pre><code>    int valid (int k)\n    {\n    for (int i = 1; i &lt; k; i++)\n    {\n        if (sol[i] == sol[k]) return 0;\n        if (abs(sol[i] - sol[k]) == abs(i - k)) return 0;\n    }\n    return 1;\n}\n\nvoid print ()\n{\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cout &lt;&lt; sol[i];\n    }\n    cout &lt;&lt; endl;\n    how++;\n}\n\nvoid backtrack (int k)\n{\n    if (k == n+1) print();\n    else\n    {\n        sol[k] = 0;\n        while (sol[k] &lt; n)\n        {\n            sol[k]++;\n            if (valid(k)) backtrack(k+1);\n        }\n    }\n}\n</code></pre>\n\n<ol>\n<li>Why is it that in the validation function, the checking of the solution is done progressively by checking 1 with k, 2 with k and so on. I think that the solution can be correct in pairs of (i, k) but wrong overall (for example 1 and 2 relative to 3 are placed correctly, but 1 relative to 2 is placed incorrectly)?</li>\n</ol>\n", 'ViewCount': '232', 'Title': 'Why does backtracking work the way it does?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T11:55:37.743', 'LastEditDate': '2013-02-08T08:27:23.527', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9599', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2530', 'Tags': '<algorithms><recursion><backtracking>', 'CreationDate': '2013-02-08T06:03:24.863', 'Id': '9590'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Can someone give me a hand here, I am new to backtracking, and preparing for an interview. I couldn't even attempt this question, please help.</p>\n\n<p>Describe a back tracking algorithm for efficiently listing all k-element subsets of <code>n</code> items.</p>\n\n<p>For <code>n = 5</code> the 3 element subsets are <code>(1,2,3), (1,2,4), (1,2,5), (1,3,4), (1,3,5), (1,4,5), (2,3,4), (2,3,5), (2,4,5), (3,4,5)</code></p>\n\n<p>In particular, I am interesting in first describing the solution vector representation to use, and then how I would partition the work among construct-candidates, is-a-solution and process-solution functions.</p>\n", 'ViewCount': '386', 'Title': 'Backtracking for listing k elements', 'LastActivityDate': '2013-04-23T03:54:03.443', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><algorithm-analysis><backtracking>', 'CreationDate': '2013-04-23T02:18:34.563', 'Id': '11507'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '50', 'Title': 'Find all non-decreasing sequences given lenght and size', 'LastEditDate': '2014-02-17T17:57:13.627', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14696', 'Body': "<p>I'm trying to find a solution for this exercise:</p>\n\n<blockquote>\n  <p>Give the pseudocode of an algorithm which takes two positive integers\n  n and k and prints all the non-decreasing sequences of length k\n  (1,2,...,n).</p>\n  \n  <p>For example n=4, k=3:</p>\n  \n  <p>111 112 113 114 122 123 124 133 134 144 222 223 224 233 234 244 333\n  334 344 444</p>\n  \n  <p>the complexity must be O(n S(n,k)) with S(n,k) the number of the\n  sequences to print for n and k.</p>\n</blockquote>\n\n<p>i think from the complexity required that a backtracking algorithm it's needed  but i could'nt solve it.</p>\n\n<p>i tried something like this:</p>\n\n<pre><code>P(n,k,h: prefix length, S: sequence)\n\n      if h == k then\n           OUTPUT S\n      else\n         for i=1 to n do\n             if(i&gt;=S[h]) \n                   S[h+1]=i;\n                   P(n,k,h+1,S);\n</code></pre>\n", 'ClosedDate': '2014-02-17T19:49:23.877', 'Tags': '<algorithms><backtracking>', 'LastEditorUserId': '14696', 'LastActivityDate': '2014-02-17T17:57:13.627', 'CommentCount': '6', 'AcceptedAnswerId': '21671', 'CreationDate': '2014-02-15T14:23:38.727', 'Id': '21664'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Taking <a href="http://www.geeksforgeeks.org/backtracking-set-7-suduku/" rel="nofollow">this</a> as an example:</p>\n\n<pre><code>bool SolveSudoku(int grid[N][N])\n{\n    int row, col;\n\n    // If there is no unassigned location, we are done\n    if (!FindUnassignedLocation(grid, row, col))\n       return true; // success!\n\n    // consider digits 1 to 9\n    for (int num = 1; num &lt;= 9; num++)\n    {\n        // if looks promising\n        if (isSafe(grid, row, col, num))\n        {\n            // make tentative assignment\n            grid[row][col] = num;\n\n            //RUN ARC CONSISTENCY HERE ......?\n\n            // return, if success, yay!\n            if (SolveSudoku(grid))\n                return true;\n\n            // failure, unmake &amp; try again\n            grid[row][col] = UNASSIGNED;\n\n            ////REMOVE ARC CONSISTENCY HERE ......?\n        }\n    }\n    return false; // this triggers backtracking\n}\n</code></pre>\n\n<p>Given the backtracking algorithm with CSP\'s, I would like to add ARC consistency to make it smarter.</p>\n\n<p><a href="http://www.codeproject.com/Articles/34403/Sudoku-as-a-CSP" rel="nofollow">For example</a>:</p>\n\n<blockquote>\n  <p>"When we want to assign the digit \'d\' to cell s1, we use assign(cells,\n  s, d).  ...but I also want to eliminate this possibility from its\n  peers  (like Forward Checking does, tell me something new!). If the\n  elimination causes one (or some) of the peers going down to only one \n  possibility, which we call d2, we want to assign d2 to it, and by\n  doing that,  eliminate d2 from all of its peer\'s peers, and that could\n  make another chain  reaction. This chain reaction is simply called\n  constraint propagation:  placing a constraint on one cell can cause\n  further constraints to be placed on  other cells."</p>\n</blockquote>\n\n<ul>\n<li>Can the process of arc propagation end up leading to a solution by\nitself or even a false solution? What is done in those cases?</li>\n<li>In the likely event the next recursive call on the next variable returns false (no values worked out for that variable), <strong>how do I\nundo all the changes the arc consistency did?</strong></li>\n</ul>\n', 'ViewCount': '21', 'Title': 'How is ARC consistency un-done after a recursive failure condition?', 'LastActivityDate': '2014-02-28T02:44:32.343', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22119', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15116', 'Tags': '<algorithms><artificial-intelligence><recursion><constraint-programming><backtracking>', 'CreationDate': '2014-02-28T00:42:17.027', 'FavoriteCount': '3', 'Id': '22116'}