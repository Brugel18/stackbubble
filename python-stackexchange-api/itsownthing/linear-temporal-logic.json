{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>It's a known fact that every LTL formula can be expressed by a B\xfcchi $\\omega$-automaton. But, apparently, B\xfcchi automata are a more powerful, expressive model. I've heard somewhere that B\xfcchi automata are equivalent to linear-time $\\mu$-calculus (that is, $\\mu$-calculus with usual fixpoints and only one temporal operator: $\\mathbf{X}$). </p>\n\n<p>Is there an algorithm (constructive proof) of this equality?</p>\n", 'ViewCount': '445', 'Title': u'Equivalence of B\xfcchi automata and linear $\\mu$-calculus', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-14T13:06:54.697', 'LastEditDate': '2012-07-14T13:06:54.697', 'AnswerCount': '2', 'CommentCount': '13', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '147', 'Tags': '<logic><automata><formal-methods><linear-temporal-logic><buchi-automata>', 'CreationDate': '2012-03-07T20:53:40.587', 'FavoriteCount': '4', 'Id': '108'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a problem with the proof for constructing a GNBA (<a href="https://en.wikipedia.org/wiki/Generalized_B%C3%BCchi_automaton" rel="nofollow">generalized nondeterministic B\xfcchi automaton</a>) for a <a href="https://en.wikipedia.org/wiki/Linear_temporal_logic" rel="nofollow">LTL formula</a>:</p>\n\n<p><strong>Theorem:</strong> For any  LTL formula $\\varphi$ there exists a GNBA $G_{\\varphi}$ over alphabet $2^{AP}$ such that:</p>\n\n<ol>\n<li><p>$\\operatorname{Word}(\\varphi)=L_{\\omega}(G_{\\varphi})$.</p></li>\n<li><p>$G_{\\varphi}$ can be costructed in time and space $2^{O(|\\varphi|)}$, where $|\\varphi|$ is the size of $\\varphi$.</p></li>\n<li><p>The number of accepting states of $G_{\\varphi}$ is bounded above by $O(|\\varphi|)$.</p></li>\n</ol>\n\n<p>My problem lies in the proof of (2), that is, in the proof it says that the number of states in $G_{\\varphi}$ is bounded by  $2^{|\\operatorname{subf}(\\varphi)|}$ but since $|\\operatorname{subf}(\\varphi)| \\leq 2\\cdot|\\varphi|$ (where $\\operatorname{subf}(\\varphi)$ is the set of all subformulae) the number of states is bounded by  $2^{O(|\\varphi|)}$. </p>\n\n<p>But why does $|\\operatorname{subf}(\\varphi)| \\leq 2\\cdot|\\varphi|$ hold? </p>\n', 'ViewCount': '75', 'Title': 'Time to construct a GNBA for LTL formula', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-30T12:27:09.250', 'LastEditDate': '2012-06-30T12:27:09.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2533', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1999', 'Tags': '<logic><automata><formal-methods><model-checking><linear-temporal-logic>', 'CreationDate': '2012-06-28T17:27:44.363', 'Id': '2531'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Consider the <a href="http://en.wikipedia.org/wiki/Kripke_structure" rel="nofollow">Kripke structure</a>:\n$$\n\\begin{array}{ccccccc}\n  \\to &amp; (p, \\neg q) &amp; \\to &amp; (\\neg p, \\neg q) &amp; \\to &amp; (\\neg p, q) \\\\\n  &amp; \\circlearrowright &amp; &amp; \\circlearrowright &amp; &amp; \\circlearrowright &amp; \\\\\n\\end{array}\n$$</p>\n\n<p>where $(p, \\neg q)$ means \u201c$p$ and not $q$\u201d and $\\circlearrowright$ is a self loop. We number the states $s_1, s_2, s_3$ from left to right.\nNow consider the three <a href="http://en.wikipedia.org/wiki/Linear_temporal_logic" rel="nofollow">LTL</a> properties:\n$$\n\\begin{array}{ll}\n  M \\vDash \\mathbf{G}\\,\\mathbf{F}\\,p \\to \\mathbf{G}\\,\\mathbf{F}\\,q &amp; \\text{false} \\\\\n  M \\vDash \\mathbf{G}\\,\\mathbf{F}\\,p &amp; \\text{false} \\\\\n  M \\vDash \\mathbf{G}\\,\\mathbf{F}\\,q &amp; \\text{false} \\\\\n\\end{array}$$</p>\n\n<p>The oddity is this: how can $\\text{false} \\to \\text{false}$ be false?</p>\n\n<p>P.S.: I am sure of the results because I used NuSMV with the following code:</p>\n\n<pre><code>MODULE main\nVAR\n   state : {a, b, c};\n   p : boolean;\n   q : boolean;\n\nASSIGN\n   init(state) := a;\n   next(state) := \n       case\n         state=a : {a,b};\n         state=b : c;\n         state=c : c;\n   esac;\np :=\n  case\n    state=a : TRUE;\n    state=b : FALSE;\n    state=c : FALSE;\n  esac;\nq :=\n  case\n    state=a : FALSE;\n    state=b : FALSE;\n    state=c : TRUE;\n  esac;\n\nLTLSPEC \n   ((G ( F p = TRUE)) -&gt;  (G ( F q = TRUE)))\nLTLSPEC \n   (G ( F p = TRUE))\nLTLSPEC\n   (G ( F q = TRUE))\n</code></pre>\n', 'ViewCount': '131', 'Title': 'Why is GFp -> GFq false in LTL, even though GFp and GFq are false?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-04T08:00:08.620', 'LastEditDate': '2012-06-30T00:58:24.300', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2012', 'Tags': '<logic><modal-logic><linear-temporal-logic>', 'CreationDate': '2012-06-29T18:59:41.583', 'FavoriteCount': '1', 'Id': '2548'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': u'Algorithm to translate a deterministic B\xfcchi automaton to LTL (when possible)', 'LastEditDate': '2012-07-14T13:05:53.293', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'Ayrat', 'PostTypeId': '1', 'OwnerUserId': '2260', 'Body': u'<p><a href="http://en.wikipedia.org/wiki/Linear_temporal_logic" rel="nofollow">Linear temporal logic</a> and deterministic <a href="http://en.wikipedia.org/wiki/B%C3%BCchi_automaton" rel="nofollow">B\xfcchi automata</a> are incomparable: DBA cannot express $FGa$, and LTL cannot express <em>"at least each odd letter is \'a\'"</em>. But sometimes it is interesting to know whether the language of a DBA can be expressed in LTL.</p>\n\n<p>I need an algorithm that decides whether a language of a given DBA is describable in LTL. Do you know algorithms for that?</p>\n', 'Tags': '<logic><automata><linear-temporal-logic><buchi-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-14T13:05:53.293', 'CommentCount': '5', 'AcceptedAnswerId': '2740', 'CreationDate': '2012-03-02T13:16:26.227', 'Id': '2739'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following specification technique.</p>\n\n<p>A specification consists of a finite set of triples $\\langle C, A, C\' \\rangle$,\nwhere $A$ is the name of an action and $C, C\'$ are conditions, that is,\npropositional formulas over propositional variables.</p>\n\n<p>Example rules (in a more suggestive notation):</p>\n\n<ul>\n<li>$C_1 \\wedge \\neg(C_2 \\vee C_3) \\stackrel{A_1}{\\longrightarrow} C_1 \\wedge \\neg C_2$</li>\n<li>$C_1 \\vee C_3 \\stackrel{A_2}{\\longrightarrow} C_2 \\vee C_3$</li>\n</ul>\n\n<p>Each triple specifies an event together with its preconditions and postconditions:\nthe semantics can be defined by saying that the system being described has a state space consisting of the set of possible truth value assignments to the propositional variables, and that the actions may take the system from any state in which the precondition of a rule for that action holds to any state in which the postcondition of that same rule holds.</p>\n\n<p>This formalism, or a restriction (e.g. no negation in formulas, or only Horn clauses) will only suit my purposes if software exists that can answer questions such as</p>\n\n<ul>\n<li>Given a condition, which events may happen?</li>\n<li>Given a condition, may it lead to deadlock (a condition in which no event can happen)?</li>\n<li>Given a condition, will it <em>never</em> lead to deadlock?</li>\n<li>Do deadlock conditions exist at all?</li>\n<li>Given a condition, which events can never happen?</li>\n</ul>\n\n<p>in under a second.</p>\n\n<p>My question: what to Google for?</p>\n\n<p>Does this formalism have a name?\nCan it be converted to one for which equivalent problems have been studied?\nI\'m thinking of safe Petri nets, for which I\'ve found <a href="http://www.imsc.res.in/~kamal/old/pc1safe.pdf" rel="nofollow">some</a> <a href="http://people.cs.aau.dk/~srba/courses/MCS-07/safePN-atva04.pdf" rel="nofollow">papers</a>, Hoare logic, dynamic logic, no doubt there is more.</p>\n\n<p>Does such software exist?  How do I Google for it?</p>\n', 'ViewCount': '60', 'Title': 'Spot the formalism (some kind of process logic)', 'LastEditorUserId': '917', 'LastActivityDate': '2012-10-19T17:53:22.403', 'LastEditDate': '2012-10-19T17:53:22.403', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '917', 'Tags': '<logic><model-checking><linear-temporal-logic><hoare-logic>', 'CreationDate': '2012-10-19T17:47:54.750', 'Id': '6174'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '87', 'Title': 'Equivalence of GFp and Gp in LTL', 'LastEditDate': '2012-11-09T08:11:06.900', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3143', 'FavoriteCount': '1', 'Body': u"<p>In linear time logic, is $\\mathbf{GF}p$ equivalent to $ \\mathbf{G}p$ ?</p>\n\n<p><em>$\\mathbf{GF}p$ means that it is always the case that p is true eventually.</em></p>\n\n<p>Let $\\mathbf{G} p$ be defined as: $\\forall j \\ge0,\\  p$ holds in the suffix $q_j, q_{j+1}, q_{j+2},\\ldots$</p>\n\n<p>and since: \n<em>formula $\u03c6$ holds for state machine $M$ if $\u03c6$ holds for all possible traces of $M$</em></p>\n\n<p>Isn't $\\mathbf{G}$ in $\\mathbf{GF}p$ redundant then? </p>\n", 'Tags': '<logic><linear-temporal-logic>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-09T08:11:06.900', 'CommentCount': '0', 'AcceptedAnswerId': '6533', 'CreationDate': '2012-11-07T11:49:00.443', 'Id': '6532'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '81', 'Title': 'LTL: Show $\\neg(aUb) \\Leftrightarrow \\neg b U (\\neg a \\land \\neg b) \\lor G \\neg b$', 'LastEditDate': '2013-01-14T22:18:17.580', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4886', 'FavoriteCount': '1', 'Body': '<p>I got as far as\n\\begin{align}\nw \\vDash \\neg (a U b) &amp;\\Leftrightarrow  \\neg (w \\vDash a U b) \n\\Leftrightarrow \\neg (\\exists_{i\\geq0} : w^i \\vDash b \\land \\forall_{0\\leq k &lt; i} : w^k \\vDash a)  \\\\\n&amp;\\Leftrightarrow \\forall_{i\\geq0} :  \\neg(w^i \\vDash b) \\lor \\exists_{0\\leq k &lt; i} : \\neg(w^k \\vDash a)\n\\end{align}</p>\n\n<p>but got stuck. </p>\n\n<p>If you could offer some advice as on where to start I would very much appreciate it. Thanks in advance</p>\n', 'Tags': '<logic><linear-temporal-logic>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-14T22:18:17.580', 'CommentCount': '0', 'AcceptedAnswerId': '7389', 'CreationDate': '2012-12-13T17:12:51.620', 'Id': '7383'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for some sort of temporal logic for expressing invariants in interfaces. Since interfaces do not specify data representation, the invariants must rely solely on the publicly available functions of the interface.</p>\n\n<p>For example, suppose we have a simple interface (Java style) Sum:</p>\n\n<pre><code>interface Sum {\n    public void add (int a);\n    public int getSum();\n}\n</code></pre>\n\n<p>I want to express in an invariant that <code>getSum</code> returns the summation of <code>a</code> in all calls to <code>add(a)</code>, without using any data representation of this sum.</p>\n\n<p>The only way I can think of doing this is by using some form of temporal logic. Is there any literature on this subject available I can read? Any pointers would be much appreciated.</p>\n', 'ViewCount': '46', 'Title': 'Temporal logic for interface invariants', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T02:59:49.377', 'LastEditDate': '2013-04-12T07:15:00.573', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '11298', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7690', 'Tags': '<logic><object-oriented><linear-temporal-logic><software-verification>', 'CreationDate': '2013-04-12T00:18:07.817', 'Id': '11247'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '84', 'Title': 'Equivalence of logical Formula (Kripke structures)', 'LastEditDate': '2013-05-19T14:49:39.450', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8241', 'FavoriteCount': '1', 'Body': '<p>Can someone explain me how to find if these formulas are equivalent with Kripke structures?</p>\n\n<p>AG(Fp or Fq) , A(GFp or GFq)</p>\n\n<p>AGF(p and q) , A(GFp and GFq)</p>\n\n<p>AFG(p and q) , A(FGp and FGq)</p>\n\n<p>Thank you in advance for your help :)</p>\n', 'Tags': '<logic><linear-temporal-logic>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-19T14:49:39.450', 'CommentCount': '1', 'AcceptedAnswerId': '12110', 'CreationDate': '2013-05-18T12:50:18.547', 'Id': '12109'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading an article called <a href="http://www.sciencedirect.com/science?_ob=MiamiImageURL&amp;_cid=271538&amp;_user=32321&amp;_pii=0304397581901109&amp;_check=y&amp;_origin=article&amp;_zone=toolbar&amp;_coverDate=31-Dec-1981&amp;view=c&amp;originContentFamily=serial&amp;wchp=dGLzVlV-zSkWb&amp;md5=2073f527aa2be434886953d7aaa0f7d3&amp;pid=1-s2.0-0304397581901109-main.pdf" rel="nofollow">The temporal semantics of concurrent programs</a>\n.</p>\n\n<p>On page $9$, there is a small section (numbered as $2$) called "clean behavior".</p>\n\n<p>I think that there is a problem with this part, what does Pnueli meant by "Let $\\lambda_i$ be the leagality condition for <strong>the</strong> statement departing from $m^i$" ?</p>\n\n<p>I have marked the word "the" in bold since, as I see it, there can be more than one edge departing from $m^i$, an example can be seen on page $11$, at the beginning of part $5$.</p>\n\n<p>Did I missunderstood something , or is there actually a mistake in the article by not addressing the fact that there can be more than one statement that can be exectuded after $m^i$, and that this expression for clean behavior need to be corrected accordingly ?</p>\n', 'ViewCount': '41', 'Title': "Is there a mistake in the expression for clean behavior in Pnueli's article from 81'?", 'LastActivityDate': '2013-06-24T06:44:33.670', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3090', 'Tags': '<concurrency><linear-temporal-logic>', 'CreationDate': '2013-05-24T22:43:47.727', 'Id': '12258'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Do they need to "unwind" exactly to the same set of paths or does it suffice when one set is contained in the other ? </p>\n\n<p>Or is it sufficient to argue that M,s satisfies both LTL formulas for any starting s and a model M, that is, reaching with both at "true" ?</p>\n\n<p><strong>Generally.</strong></p>\n\n<p>Let $M$ be any model. Further, let $s$ be any state $M$ might be in.</p>\n\n<p>Let $\\phi$ and $\\psi$ be two LTL formulas.</p>\n\n<p>If $\\forall$ paths $\\pi$ in $M$ starting at $s$ it holds that $\\pi \\models \\phi \\leftrightarrow \\pi \\models \\psi $ then we say  $\\phi$ and $\\psi$ are equivalent ($\\phi \\equiv \\psi$). </p>\n\n<p>More succinct </p>\n\n<p>$(\\pi \\models \\phi \\leftrightarrow \\pi \\models \\psi) \\rightarrow (\\phi \\equiv \\psi)$.</p>\n\n<p><strong>Example.</strong> <em>Prove that $\\neg G \\chi \\equiv F \\neg \\chi$.</em></p>\n\n<p>If we can show that $(\\pi \\models \\neg G \\chi \\leftrightarrow \\pi \\models F \\neg \\chi)$ we would have proven that $(\\neg G \\chi \\equiv F \\neg \\chi)$. So we reduce to the former.</p>\n\n<p>Step 1. We show that $(\\pi \\models \\neg G \\chi \\rightarrow \\pi \\models F \\neg \\chi)$:</p>\n\n<p>$\\{(\\pi \\models \\neg G \\chi) \\leftrightarrow (\\pi \\not\\models G \\chi) \\leftrightarrow (\\forall i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\not\\models \\chi)\\} \\rightarrow \\{(\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\not\\models \\chi) \\leftrightarrow (\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\models \\neg\\chi) \\leftrightarrow (\\pi \\models F \\neg \\chi)\\}.$</p>\n\n<p>Step 2. We show that $(\\pi \\models F \\neg \\chi  \\rightarrow \\pi \\models \\neg G \\chi)$:</p>\n\n<p>$\\{(\\pi \\models F \\neg \\chi) \\leftrightarrow (\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\models \\neg\\chi) \\leftrightarrow (\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\not\\models \\chi)\\} \\rightarrow \\{?\\}.$ <em>How do I get back?</em> </p>\n\n<p><strong>Ok.</strong> I can semantically understand that if for every model and any path in it, it is true eventually that $\\neg \\chi$ holds, it cannot be the case that generally for every model and any path in it $\\chi$ will hold. How can I write this down formally?</p>\n\n<p>Would for $\\{?\\}$: $\\{\\neg (\\forall i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\models \\chi) \\leftrightarrow (\\neg (\\pi \\models G \\chi)) \\leftrightarrow (\\pi \\not\\models G \\chi) \\leftrightarrow (\\pi \\models \\neg G \\chi)\\}$ be a valid argumentation ? It looks different than Step 1. and anyway is there a rule to pull $\\neg$ "out" from $\\not\\models$ this way ?</p>\n', 'ViewCount': '169', 'Title': 'Howto formally go about proving that two LTL formulas are equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-05T14:34:53.770', 'LastEditDate': '2013-07-05T14:34:53.770', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '13096', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6789', 'Tags': '<logic><proof-techniques><linear-temporal-logic>', 'CreationDate': '2013-07-05T05:55:24.307', 'Id': '13092'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is known that the temporal logics LTL,CTL,CTL* can be translated/embedded into the $\\mu$-calculus. In other words, the (modal) $\\mu$-calculus subsumes these logics,\n(i.e. it is more expressive.)</p>\n\n<p>Could you please explain/point me to papers/books that elaborate on this matter.\nIn particular, are there concrete fairness, liveness, etc. properties not expressible in the temporal logics but in the $\\mu$-calculus?</p>\n', 'ViewCount': '293', 'Title': 'Why use $\\mu$-calculus and not LTL,CTL,CTL*?', 'LastEditorUserId': '9950', 'LastActivityDate': '2013-11-05T19:02:14.673', 'LastEditDate': '2013-10-31T18:15:11.500', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '11105', 'Tags': '<linear-temporal-logic><mu-calculus>', 'CreationDate': '2013-10-31T16:46:17.190', 'Id': '16603'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Suppose one wants to use a \u03bc-calculus model checker, but specify things in temporal logics, which is easier (more intuitive). Is there a technique (even better, a tool) that automatically translates formulae in any of these logics (CTL,CTL* or LTL) to the \u03bc-calculus?</p>\n\n<p>Thanks very much in advance!</p>\n', 'ViewCount': '61', 'Title': u'Techniques (tools) to convert temporal logic (CTL,CTL* or LTL) to \u03bc-calculus formulae', 'LastActivityDate': '2013-11-20T14:43:23.953', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11105', 'Tags': '<linear-temporal-logic><mu-calculus>', 'CreationDate': '2013-11-20T11:01:24.603', 'Id': '18196'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am learning about temporal logic and model checking systems. One conceptual exercise that I am struggling with is how to create a transition system which satisfies only <em>one</em> of two given properties, when one is in LTL and one is in CTL. For example:</p>\n\n<ul>\n<li>Find a transition system that satisfies only one of the following two properties: $FGp$, $AFEGp$</li>\n<li>Find a transition system that satisfies only one of the following two properties: $FGp$, $EFEGp$</li>\n<li>Find a transition system that satisfies only one of the following two properties: $GFp$, $AGEFp$</li>\n</ul>\n\n<p>How should I begin when trying to reason about these types of problems? In general, is it easier to design transition systems for LTL properties or CTL properties? Or does it depend on the situation?</p>\n\n<p>Any insight would be appreciated!</p>\n', 'ViewCount': '48', 'Title': 'Transition systems that satisfy LTL but not CTL, and vice versa', 'LastEditorUserId': '12914', 'LastActivityDate': '2014-01-17T23:04:29.320', 'LastEditDate': '2014-01-17T23:04:29.320', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12914', 'Tags': '<logic><linear-temporal-logic><model-checking>', 'CreationDate': '2014-01-17T07:50:25.933', 'Id': '19777'}