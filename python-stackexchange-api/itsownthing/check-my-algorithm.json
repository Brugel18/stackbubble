{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A <a href="http://stackoverflow.com/questions/10378738/maximise-sum-of-non-overlapping-numbers-from-matrix">question was posted on Stack Overflow</a> asking for an algorithm to solve this problem:</p>\n\n<blockquote>\n  <p>I have a matrix (call it A) which is nxn. I wish to select a subset\n  (call it B) of points from matrix A. The subset will consist of n\n  elements, where one and only one element is taken from each row and\n  from each column of A. The output should provide a solution (B) such\n  that the sum of the elements that make up B is the maximum possible\n  value, given these constraints (eg. 25 in the example below). If\n  multiple instances of B are found (ie. different solutions which give\n  the same maximum sum) the solution for B which has the largest minimum\n  element should be selected.</p>\n  \n  <p>B could also be a selection matrix which is nxn, but where only the n\n  desired elements are non-zero.</p>\n  \n  <p>For example: if A =</p>\n\n<pre><code>|5 4 3 2 1|\n|4 3 2 1 5|\n|3 2 1 5 4|\n|2 1 5 4 3|\n|1 5 4 3 2|\n</code></pre>\n  \n  <p>=> B would be</p>\n\n<pre><code> |5 5 5 5 5|\n</code></pre>\n</blockquote>\n\n<p>I <a href="http://stackoverflow.com/a/10387455/1191425">proposed a dynamic programming solution</a> which I suspect is as efficient as any solution is going to get. I\'ve copy-pasted my proposed algorithm below.</p>\n\n<hr>\n\n<ul>\n<li>Let $A$ be a square array of $n$ by $n$ numbers.</li>\n<li>Let $A_{i,j}$ denote the element of $A$ in the <code>i</code>th row and <code>j</code>th column.</li>\n<li>Let $S( i_1:i_2, j_1:j_2 )$ denote the optimal sum of non-overlapping numbers for a square subarray of $A$ containing the intersection of rows $i_1$ to $i_2$ and columns $j_1$ to $j_2$.</li>\n</ul>\n\n<p>Then the optimal sum of non-overlapping numbers is denoted <code>S( 1:n , 1:n )</code> and is given as follows:</p>\n\n<p>$$S( 1:n , 1:n ) = \\max \\left \\{ \\begin{array}{l}  S(   2:n , 2:n   ) + A_{1,1} \\\\\r\n                             S(   2:n , 1:n-1 ) + A_{1,n} \\\\\r\n                            S( 1:n-1 , 2:n   ) + A_{n,1} \\\\\r\n                            S( 1:n-1 , 1:n-1 ) + A_{n,n} \\\\\r\n                            \\end{array} \\right.$$</p>\n\n<pre><code>Note that S( i:i, j:j ) is simply Aij.\n</code></pre>\n\n<p>That is, the optimal sum for a square array of size <code>n</code> can be determined by separately computing the optimal sum for each of the four sub-arrays of size <code>n-1</code>, and then maximising the sum of the sub-array and the element that was "left out".</p>\n\n<pre><code>S for |# # # #|\n      |# # # #|\n      |# # # #|\n      |# # # #|\n\nIs the best of the sums S for:\n\n|#      |      |      #|      |# # #  |       |  # # #|\n|  # # #|      |# # #  |      |# # #  |       |  # # #|\n|  # # #|      |# # #  |      |# # #  |       |  # # #|\n|  # # #|      |# # #  |      |      #|       |#      |\n</code></pre>\n\n<hr>\n\n<p>This is a very elegant algorithm and I strongly suspect that it is correct, but I can\'t come up with a way to <strong>prove</strong> it is correct.</p>\n\n<p>The main difficulty I am having it proving that the problem displays optimal substructure. I believe that if the four potential choices in each calculation are the <em>only</em> four choices, then this is enough to show optimal substructure. That is, I need to prove that this:</p>\n\n<pre><code>|   #    |\n| #   # #|\n| #   # #| \n| #   # #|\n</code></pre>\n\n<p>Is not a valid solution, either because it\'s impossible (i.e. proof by contradiction) or because this possibility is already accounted for by one of the four "<code>n-1</code> square" variations.</p>\n\n<p>Can anyone point out any flaws in my algorithm, or provide a proof that it really does work?</p>\n', 'ViewCount': '341', 'Title': 'Maximise sum of "non-overlapping" numbers in square array - help with proof', 'LastEditorUserId': '1320', 'LastActivityDate': '2012-05-02T08:20:36.307', 'LastEditDate': '2012-05-01T00:17:31.290', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1600', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1320', 'Tags': '<algorithms><dynamic-programming><check-my-algorithm>', 'CreationDate': '2012-04-30T19:20:52.473', 'Id': '1597'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><strong>Updated Algorithm:</strong> There was a major flaw in my original presentation of the algorithm which could have impacted the results. I apologize for the same. The correction has been posted underneath.\n<hr></p>\n\n<p>The original algorithm posted had a major flaw in its working. I tried my best but could not get the desired accuracy in presenting the algorithm in pseudo code and/or Set Theory notation. I am thus posting python code, which has been tested and produces the desired results.</p>\n\n<p>Note that my question, however, remains the same: What is the time complexity of the algorithm (assuming that powersets are already generated)?</p>\n\n<pre><code># mps is a set of powersets; below is a sample (test case)\nmps = [\n        [       [], [1], [2], [1,2]     ],\n        [       [], [3], [4], [3,4]     ],\n        [       [], [5], [6], [5,6]     ]\n      ]\n\n\n# Core algorithm\n# enumerate(mps) may not be required in languages like C which support indexed loops\nlen = mps.__len__()\nfor idx, ps in enumerate(mps):\n    if idx &gt; len - 2:\n            break;\n    mps[idx + 1] = merge(mps[idx], mps[idx+1])   # merge is defined below\n\n\n# Takes two powersets and merges them\ndef merge (psa, psb):\n    fs = []\n    for a in psa:\n            for b in psb:\n                    fs.append(list(set(a) | set(b)))\n    return fs\n</code></pre>\n\n<p><strong>Output</strong>: <code>mps[-1]   #Last item of the list</code></p>\n\n<p>Running the above example will result in listing out the powerset of $\\{1,2,3,4,5,6\\}$.</p>\n', 'ViewCount': '154', 'Title': 'What is the complexity of this subset merge algorithm?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-23T09:30:36.730', 'LastEditDate': '2012-08-23T09:30:36.730', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2597', 'Tags': '<algorithms><time-complexity><algorithm-analysis><check-my-algorithm>', 'CreationDate': '2012-08-21T15:00:26.797', 'Id': '3273'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '56', 'Title': 'Compute relational composition in $O(|E||V|)$', 'LastEditDate': '2012-10-14T09:37:36.983', 'AnswerCount': '2', 'Score': '7', 'OwnerDisplayName': 'Johannes', 'PostTypeId': '1', 'OwnerUserId': '3181', 'Body': '<p>Definitions: Let $G=(V,E)$ be a DAG without self-loops, and $X \\subseteq G$ and $Y \\subseteq G$ be graphs.</p>\n\n<p>Input: $X,Y$. Output: The relational composition <a href="http://en.wikipedia.org/wiki/Relation_composition">relational composition</a> $X \\circ Y$ in $\\mathcal{O}(|E||V|)$.</p>\n\n<ul>\n<li>Case 1: $|E| \\le |V|$. Two for loops over $E(X)$ and $E(Y)$: Runtime $ \\le \\mathcal{O}(|E|^2) \\le \\mathcal{O}(|E||V|)$.</li>\n<li>Case 2: $|V| \\le |E|$\n<ol>\n<li>Draw the graph $(V(G),E(X) \\cup E(Y))$: $(O(|V|)+\\mathcal{O}(|2E|)))$. We call edges from $E(X)$ black and from $E(Y)$ red.</li>\n<li>Topologically sort it (Kahn: $\\mathcal{O}(|V|) + \\mathcal{O}(|E|)$). Let the first level be $0$, and edges go from a level to a higher level.</li>\n<li>Draw this graph twice.</li>\n<li>In the first copy, remove every red edge beginning at even level, and every black edge beginning at odd level: $\\mathcal{O}(E)$.</li>\n<li>In the second copy, remove every "black even" and "red odd": $\\mathcal{O}(E)$.</li>\n<li>For the first copy:\n<ul>\n<li>for all nodes $u$ on level $2i$</li>\n<li>for all nodes $v$ on level $2i+1$</li>\n<li>report edge $(u,v)$ (Runtime $\\mathcal{O}(V^2) \\le \\mathcal{O}(EV)$).</li>\n</ul></li>\n<li>For the second copy: The same for "$2i+1$".</li>\n<li>Union the reported nodes, throw out duplicates  $\\mathcal{O}(V^2) &lt;= \\mathcal{O}(EV)$ (I hope the graph representation allows this).</li>\n</ol></li>\n</ul>\n\n<p>Could some of you please look over my algorithm and check whether </p>\n\n<ul>\n<li>it is correct</li>\n<li>it is in $\\mathcal{O}(|E||V|)$</li>\n</ul>\n\n<p>If it\'s correct, does my algorithm already "exist"? If not, could you provide an alternative? I\'ll accept the first answer, but upvote if some more people are so kind to check.</p>\n\n<p>EDIT: Step 6 Seems to be in $O(E^2)$ sometimes. I wish this would not be true. Has anyone a working algorithm?</p>\n', 'Tags': '<algorithms><graph-theory><algorithm-analysis><check-my-algorithm>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-14T09:41:40.783', 'CommentCount': '0', 'AcceptedAnswerId': '6057', 'CreationDate': '2012-10-13T08:23:35.550', 'Id': '6055'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am working on problem (15-11) Inventory planning from <em>Introduction to Algorithms</em> (CLRS, 3rd Ed).</p>\n\n<blockquote>\n  <p><strong>15-11: Inventory Planning, p.411</strong></p>\n  \n  <p>The Rinky Dink Company makes machines that resurface ice rinks. The demand for such products varies from month to month, and so the company needs to develop a strategy to plan its manufacturing given the fluctuating, but predictable, demand. The company wishes to design a plan for the next $n$ months. For each month $i$, the company knows the demand $d_i$, that is, the number of machines that it will sell. Let $D  = \\displaystyle\\sum_{i=1}^{n} d_i $ be the total demand over the next $n$ months. The company keeps a full-time staff who provide labor to manufacture up to m machines in a given month, it can hire additional, part-time labor, at a cost that works out to c dollars per machine. Furthermore, if, at the end of a month, the company is holding any unsold machines, it must pay inventory costs. The cost for holding j machines is given as a function $h(j)$ for $u = 1, 2, ... , D$, where $h(j) \\ge 0$ for $1 \\le j \\le D$ and $h(j) \\le h(j+1)$ for $j \\le 1 \\le D - 1$.<br>\n  Give an algorithm that calculates a plan for the company that minimizes its costs while fulfilling all the demand. The running time should be polynomical in $n$ and $D$.</p>\n</blockquote>\n\n<p>In other words, problem asks to create dynamic programming algorithm that solves this problem.</p>\n\n<p>So far, I came up the the following solution, and not sure if it is any good.<br>\nOptimal sub-problem:\nLet $MinCost(i,j)$ be the function that returns minimized cost of operation for past $i$ months, $j$ is the number of unsold machines left at the end of the month $i$.(Goal, is to calculate $MinCost(n,0)$, in other words, at the end of planning period(month $n$), there are no unsold machines.)  </p>\n\n<p>So, the DP recurrence is given by $MinCost(0,0) = 0$ and</p>\n\n<p>$\\quad MinCost(i,j) = \\min\\{MinCost(i-1,j-k) + c(k,j,i) + h(j) \\mid 1 \\le k \\le D \\}$</p>\n\n<p>for $i+j &gt; 0$; here, $c(k,j,i)$ is the function that calculates the costs of the production.</p>\n\n<p>If my optimal sub-problem is correct, how do I create an algorithm to solve it?</p>\n', 'ViewCount': '1024', 'Title': 'Inventory planning problem solved through dynamic programming', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T14:49:19.330', 'LastEditDate': '2012-10-30T14:46:07.273', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1758', 'Tags': '<algorithms><dynamic-programming><check-my-algorithm>', 'CreationDate': '2012-10-30T04:11:00.550', 'Id': '6379'}