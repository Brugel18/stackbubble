77_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '7833', 'Title': 'How to prove that a language is not context-free?', 'LastEditDate': '2013-06-06T13:59:18.867', 'AnswerCount': '5', 'Score': '39', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '16', 'Body': '<p>We learned about the class of context-free languages $\\mathrm{CFL}$. It is characterised by both <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammars</a> and <a href="https://en.wikipedia.org/wiki/Pushdown_automata">pushdown automata</a> so it is easy to show that a given language is context-free.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for <em>all</em> grammars (or automata) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n', 'Tags': '<formal-languages><context-free><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-12-04T20:04:21.587', 'CommentCount': '0', 'AcceptedAnswerId': '276', 'CreationDate': '2012-03-12T23:57:46.817', 'Id': '265'},77_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '920', 'Title': 'What is coinduction?', 'LastEditDate': '2012-04-22T15:52:25.520', 'AnswerCount': '2', 'Score': '27', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '8', 'Body': "<p>I've heard of (structural) induction. It allows you to build up finite structures from smaller ones and gives you proof principles for reasoning about such structures. The idea is clear enough.</p>\n\n<blockquote>\n  <p>But what about coinduction? How does it work? How can one say anything conclusive about an infinite structure?</p>\n</blockquote>\n\n<p>There are (at least) two angles to address, namely, coinduction as a way of defining things and as a proof technique. </p>\n\n<blockquote>\n  <p>Regarding coinduction as a proof technique, what is the relationship between coinduction and bisimulation?</p>\n</blockquote>\n", 'Tags': '<logic><proof-techniques><formal-methods><terminology>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T15:52:25.520', 'CommentCount': '1', 'AcceptedAnswerId': '528', 'CreationDate': '2012-03-19T17:34:08.127', 'Id': '525'},77_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1315', 'Title': 'Proving a binary tree has at most $\\lceil n/2 \\rceil$ leaves', 'LastEditDate': '2012-03-30T02:27:43.967', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '756', 'FavoriteCount': '3', 'Body': '<p>I\'m trying to prove that a <a href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a> with $n$ nodes has at most $\\left\\lceil \\frac{n}{2} \\right\\rceil$ leaves. How would I go about doing this with induction?</p>\n\n<p><em>For people who were following in the original question about heaps, it has been moved <a href="http://cs.stackexchange.com/questions/841/proving-a-binary-heap-has-lceil-n-2-rceil-leaves">here</a>.</em></p>\n', 'Tags': '<data-structures><binary-trees><combinatorics><graph-theory><proof-techniques>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-10-01T04:35:17.907', 'CommentCount': '7', 'AcceptedAnswerId': '810', 'CreationDate': '2012-03-26T21:51:56.127', 'Id': '805'},77_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '310', 'Title': 'Showing that a problem in X is not X-Complete', 'LastEditDate': '2012-04-22T15:55:25.283', 'AnswerCount': '4', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '1', 'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Existential_theory_of_the_reals" rel="nofollow">Existential Theory of the Reals</a> is in <strong>PSPACE</strong>, but I don\'t know whether it is  <strong>PSPACE-Complete</strong>. If I believe that it is not the case,  how could I prove it?</p>\n\n<p>More generally, given a problem in some complexity class <strong>X</strong>, how can I show that it is <em>not</em> <strong>X-Complete</strong>? For example, <strong>X</strong> could be <strong>NP</strong>, <strong>PSPACE</strong>, <strong>EXPTIME</strong>.</p>\n', 'Tags': '<complexity-theory><proof-techniques>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T15:55:25.283', 'CommentCount': '1', 'AcceptedAnswerId': '1324', 'CreationDate': '2012-04-03T00:28:28.780', 'Id': '1002'},77_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '11911', 'Title': 'How to prove that a language is not regular?', 'LastEditDate': '2013-06-06T13:54:20.203', 'AnswerCount': '5', 'Score': '26', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '21', 'Body': '<p>We learned about the class of regular languages $\\mathrm{REG}$. It is characterised by any one concept among regular expressions, finite automata and left-linear grammars, so it is easy to show that a given language is regular.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for all regular expressions (or for all finite automata, or for all left-linear grammars) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n\n<p><em><sup>This is intended to be a reference question collecting usual proof methods and application examples. See <a href="http://cs.stackexchange.com/q/265/98">here</a> for the same question on context-free languages.</sup></em></p>\n', 'Tags': '<formal-languages><regular-languages><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-07-01T12:50:16.730', 'CommentCount': '4', 'AcceptedAnswerId': '1033', 'CreationDate': '2012-04-04T10:30:32.163', 'Id': '1031'},77_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '315', 'Title': 'Confluence proof for a simple rewriting system', 'LastEditDate': '2012-04-06T04:32:54.413', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '17', 'FavoriteCount': '2', 'Body': "<p>Assume we have a simple language that consists of the terms:</p>\n\n<ul>\n<li>$\\mathtt{true}$</li>\n<li>$\\mathtt{false}$</li>\n<li>if $t_1,t_2,t_3$ are terms then so is $\\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3$</li>\n</ul>\n\n<p>Now assume the following logical evaluation rules:</p>\n\n<p>$$ \\begin{gather*}\r\n\\dfrac{}\r\n      {\\mathtt{if}\\: \\mathtt{true} \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to t_2}\r\n      \\text{[E-IfTrue]} \\quad\r\n\\dfrac{}\r\n      {\\mathtt{if}\\: \\mathtt{false} \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to t_3}\r\n      \\text{[E-IfFalse]} \\\\\r\n\\dfrac{t_1 \\to t_1&#39;}\r\n      {\\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to \\mathtt{if}\\: t_1&#39; \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3}\r\n      \\text{[E-If]} \\\\\r\n\\end{gather*} $$</p>\n\n<p>Suppose we also add the following funky rule:</p>\n\n<p>$$\r\n\\dfrac{t_2 \\to t_2&#39;}\r\n      {\\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to \\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2&#39; \\:\\mathtt{else}\\: t_3}\r\n      \\text{[E-IfFunny]}\r\n$$</p>\n\n<p>For this simple language with the given evaluation rules I wish to prove the following:</p>\n\n<p><strong>Theorem: If $r \\rightarrow s$ and $r \\rightarrow t$ then there is some term $u$ such that $s \\rightarrow u$ and $t \\rightarrow u$.</strong></p>\n\n<p>I am proving this by induction on the structure of $r$. Here is my proof so far, it all worked out well, but I am stuck at the very last case. It seems like induction on the structure of $r$ is not sufficing, can anyone help me out?</p>\n\n<p><em>Proof.</em> By induction on $r$, we will seperate all the forms that $r$ can take:</p>\n\n<ol>\n<li>$r$ is a constante, nothing to prove since a normal form does not evaluate to anything.</li>\n<li>$r=$ if true then $r_2$ else $r_3$. (a) both derivations were done with the E-IfTrue rule. In this case $s=t$, so there is nothing to prove. (b) one deriviation was done with the E-IfTrue rule, the other with the E-Funny rule. Assume $r \\rightarrow s$ was done with E-IfTrue, the other case is equivalently proven. We now know that $s = r_2$. We also know that $t =$ if true then $r&#39;_2$ else $r_3$ and that there exists some deriviation $r_2 \\rightarrow r&#39;_2$ (the premise). If we now choose $u = r&#39;_2$, we conclude the case.</li>\n<li>$r=$ if false then $r_2$ else $r_3$. Equivalently proven as above.</li>\n<li>$r=$ if $r_1$ then $r_2$ else $r_3$ with $r_1 \\neq $ true or false. (a) both deriviations were done with the E-If rule. We now know that $s =$ if $r&#39;_1$ then $r_2$ else $r_3$ and $t =$ if $r&#39;&#39;_1$ then $r_2$ else $r_3$. We also know that there exists deriviations $r_1 \\rightarrow r&#39;_1$ and $r_1 \\rightarrow r&#39;&#39;_1$ (the premises). We can now use the induction hypothese to say that there exists some term $r&#39;&#39;&#39;_1$ such that $r&#39;_1 \\rightarrow r&#39;&#39;&#39;_1$ and $r&#39;&#39;_1 \\rightarrow r&#39;&#39;&#39;_1$. We now conclude the case by saying $u =$ if $r&#39;&#39;&#39;_1$ then $r_2$ else $r_3$ and noticing that  $s \\rightarrow u$ and $t \\rightarrow u$ by the E-If rule. (b) one derivation was done by the E-If rule and one by the E-Funny rule.</li>\n</ol>\n\n<p>This latter case, where one derivation was done by E-If and one by E-Funny is the case I am missing... I can't seem to be able to use the hypotheses.</p>\n\n<p>Help will be much appreciated.</p>\n", 'Tags': '<logic><semantics><proof-techniques><term-rewriting>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-06T04:32:54.413', 'CommentCount': '3', 'AcceptedAnswerId': '1061', 'CreationDate': '2012-04-05T18:36:04.420', 'Id': '1060'},77_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have developed the following pseudocode for the sum of pairs problem:</p>\n\n<blockquote>\n  <p>Given an array $A$ of integers and an integer $b$, return YES if there are positions $i,j$ in $A$ with $A[i] + A[j] = b$, NO otherwise.</p>\n</blockquote>\n\n<p>Now I should state a loop invariant that shows that my algorithm is correct. Can someone give me a hint of a valid loop invariant? </p>\n\n<pre><code>PAIRSUM(A,b):\nYES := true;\nNO := false;\nn := length(A);\nif n&lt;2 then\n  return NO;\n\nSORT(A);\ni := 1;\nj := n;\nwhile i &lt; j do  // Here I should state my invariant\n   currentSum := A[i] + A[j];\n   if currentSum = b  then\n      return YES;\n   else \n    if currentSum &lt; b then\n      i := i + 1;\n    else\n      j := j \u2013 1;\nreturn NO;\n</code></pre>\n', 'ViewCount': '428', 'Title': 'Loop invariant for an algorithm', 'LastEditorUserId': '635', 'LastActivityDate': '2012-04-10T08:37:32.370', 'LastEditDate': '2012-04-10T03:29:03.627', 'AnswerCount': '4', 'CommentCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<algorithms><proof-techniques><loop-invariants>', 'CreationDate': '2012-04-09T10:03:11.910', 'Id': '1157'},77_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the discussion around <a href="http://cs.stackexchange.com/q/1157/98">this question</a>, Gilles mentions correctly that any correctness proof of an algorithm that uses arrays has to prove that there are no out-of-bounds array accesses; depending on the runtime model, this would cause a runtime error or access to non-array elements.</p>\n\n<p>One common technique to perform such correctness proofs (at least in undergrad studies and probably in automated verification) is by using <a href="https://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>. I am not aware that the standard set of rules containes anything relating to arrays; they seem to be restricted to monadic variables.</p>\n\n<p>I can imagine adding axioms of the form</p>\n\n<p>$\\qquad \\displaystyle \\frac{}{\\{0 \\leq i \\lt A.\\mathrm{length} \\land {P[A[i]/E]} \\}\\ A[i] := E;\\ \\{P\\}}$</p>\n\n<p>However, it is not clear to me how you would deal with an array access on the right hand side, i.e. if it is part of a complex expression $E$ in some statement $x := E$.</p>\n\n<blockquote>\n  <p>How can arrays accesses be modelled in Hoare logic so that the absence of invalid accesses can and has to be proven for program correctness?</p>\n</blockquote>\n\n<p>Answers may assume that we disallow array elements to be used in statements other than $A[i] := E$ or as part of some $E$ in $x := E$ as this does not restrict expressiveness; we can always assign a temporary variable the desired value, i.e. write $t := A[i];\\ \\mathtt{if} ( t &gt; 0 ) \\dots$ instead of $\\mathtt{if} ( A[i] &gt; 0 )\\dots$.</p>\n', 'ViewCount': '317', 'Title': 'How to deal with arrays during Hoare-style correctness proofs', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-10T16:17:41.297', 'LastEditDate': '2012-04-10T16:17:41.297', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<proof-techniques><semantics><arrays><hoare-logic><software-verification>', 'CreationDate': '2012-04-10T08:00:09.683', 'FavoriteCount': '1', 'Id': '1200'},77_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am taking a complexity course and I am having trouble with coming up with reductions between NPC problems. How can I find reductions between problems? Is there a general trick that I can use? How should I approach a problem that asks me to prove a problem is NPC?</p>\n', 'ViewCount': '417', 'Title': 'Finding reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T16:05:26.590', 'LastEditDate': '2012-04-22T16:05:26.590', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '1068', 'Tags': '<complexity-theory><np-complete><proof-techniques><reductions>', 'CreationDate': '2012-04-13T01:29:02.757', 'FavoriteCount': '8', 'Id': '1240'},77_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '450', 'Title': 'Why is Relativization a barrier?', 'LastEditDate': '2012-04-15T01:47:45.337', 'AnswerCount': '3', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '639', 'FavoriteCount': '4', 'Body': "<p>When I was explaining the Baker-Gill-Solovay proof that there exists an oracle with which we can have, $\\mathsf{P} = \\mathsf{NP}$, and an oracle with which we can have $\\mathsf{P} \\neq \\mathsf{NP}$ to a friend, a question came up as to why such techniques are ill-suited for proving the $\\mathsf{P} \\neq \\mathsf{NP}$ problem, and I couldn't give a satisfactory answer. \\</p>\n\n<p>To put it more concretely, if I have an approach to prove $\\mathsf{P} \\neq \\mathsf{NP}$ and if I could construct oracles to make a situation like above happen, why does it make my method invalid? </p>\n\n<p>Any exposition/thoughts on this topic?</p>\n", 'Tags': '<complexity-theory><proof-techniques><relativization>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-11-18T00:26:03.123', 'CommentCount': '0', 'AcceptedAnswerId': '1273', 'CreationDate': '2012-04-14T13:39:56.047', 'Id': '1271'},77_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '6747', 'Title': 'How to prove a language is regular?', 'LastEditDate': '2013-06-06T13:56:25.667', 'AnswerCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '4', 'Body': '<p>There are many methods to prove that <a href="http://cs.stackexchange.com/q/1031/157">a language is not regular</a>, but what do I need to do to prove that some language <em>is</em> regular?</p>\n\n<p>For instance, if I am given that $L$ is regular, \nhow can I prove that the following $L&#39;$ is regular, too?</p>\n\n<p>$\\qquad \\displaystyle L&#39; := \\{w \\in L: uv = w \\text{ for } u \\in \\Sigma^* \\setminus L \\text{ and } v \\in \\Sigma^+ \\}$</p>\n\n<p>Can I draw a nondeterministic finite automaton to prove this?</p>\n', 'Tags': '<formal-languages><regular-languages><automata><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-09-20T17:34:26.467', 'CommentCount': '4', 'AcceptedAnswerId': '1333', 'CreationDate': '2012-04-18T05:21:31.750', 'Id': '1331'},77_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I have a problem that I\'m looking over for an exam that is coming up in my Theory of Computation class.  I\'ve had a lot of problems with the <em>pumping lemma</em>, so I was wondering if I might be able to get a comment on what I believe is a valid proof to this problem.  From what I have seen online and in our review I don\'t think this is the customary answer to this problem so I want to know if I am applying the concepts behind the pumping lemma successfully.  The problem is <em>not</em> a homework problem and can be found on my professor\'s previous exams <a href="http://www.cs.ucf.edu/~dmarino/ucf/transparency/cot4210/exam/" rel="nofollow">here</a> under the fourth problem of his exam given in Fall of 2011, which is...</p>\n\n<blockquote>\n  <p>Let $L = \\{0^p \\mid \\text{\\(p\\) is a prime number}\\}$. Prove that $L$ is not context-free using the pumping lemma for context-free languages.</p>\n</blockquote>\n\n<p>So here is my proof:</p>\n\n<blockquote>\n  <p>Assume that the pumping length is $m$, where $m+1$ is a prime number.  I shall also assume that there is a string $uvxyz = 0^{(m/2)}00^{m/2} \\in L$.  There are two possible positions that do not violate conditions 2 and  3 of the pumping lemma for context languages, being $|vy| &gt; 0$ and $|vxy| \\leq m$.  These are:</p>\n  \n  <ol>\n  <li><p>$u = 0^{(m/2)}, v = 0, x = 0^{m/2}$, pumping by one results in $0^{m/2}000^{m/2}$.  Since m/2 + m/2 is m, which is one less than the prime number m+1, it is an even number.  m+2 is also an even number and since $|0^{m/2}000^{m/2}| = m + 2$, this number of zeroes is also even and thus cannot be prime, resulting in a contradiction.  </p></li>\n  <li><p>The other placement is to place the string on the symmetric opposite or $x = 0^{m/2}, y = 0, z = 0^{m/2}$.  This results in the same contraction as in case 1.</p></li>\n  </ol>\n</blockquote>\n\n<p>The string cannot be placed in the center such that $v = 0^{m/2}, x = 0, y = 0^{m/2}$ as this would violate condition three or $|vxy| \\leq m$, since $|vxy| = m + 1 &gt; m$.</p>\n\n<p>So my question is essentially, is this a valid proof and if not what is wrong with it?</p>\n', 'ViewCount': '744', 'Title': 'Prime number CFG and Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T21:46:05.933', 'LastEditDate': '2012-04-22T21:46:05.933', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><proof-techniques><context-free><pumping-lemma>', 'CreationDate': '2012-04-22T20:31:51.403', 'FavoriteCount': '2', 'Id': '1450'},77_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '660', 'Title': 'How to use adversary arguments for selection and insertion sort?', 'LastEditDate': '2012-04-23T06:41:39.370', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was asked to find the adversary arguments necessary for finding the lower bounds for selection and insertion sort. I could not find a reference to it anywhere.</p>\n\n<p>I have some doubts regarding this. I understand that adversary arguments are usually used for finding lower bounds for certain "problems" rather than "algorithms".</p>\n\n<p>I understand the merging problem. But how could I write one for selection and insertion sort?</p>\n', 'Tags': '<algorithms><algorithm-analysis><proof-techniques><lower-bounds>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-23T17:27:14.653', 'CommentCount': '4', 'AcceptedAnswerId': '1465', 'CreationDate': '2012-04-23T03:40:40.260', 'Id': '1455'},77_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I'm really struggling with the pumping lemma.  I think most of my problems come from not understanding how you can and can't split the string in a pumping lemma question.  Here is an example, take the problem prove that $L = \\{w | w$ contains more $0$'s than $1$'s over the language $\\{0,1\\} \\}$ is not regular via the pumping lemma.</p>\n\n<p>So I choose the string $01^{p}0^{p}$.  Since this is a regular language pumping lemma problem I know that: </p>\n\n<ol>\n<li>for each $i &gt; 0, xy^{i}z \\in A$,</li>\n<li>$|y^{i}| &gt; 0$, and</li>\n<li>$|xy| &lt; p$</li>\n</ol>\n\n<p>I am little uncertain about other possibilites though, such as if $x$, or $z$ can be null (obviously $y$ can't by condition 2).  I assume that this isn't possible since I don't think the preceding or trailing whitespace is considered part of the string, but I'm not sure.  <strong>Is it possible for $x$ or $z$ to be null?</strong></p>\n", 'ViewCount': '122', 'Title': 'Null Characters and Splitting the String in the Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-23T22:21:55.283', 'LastEditDate': '2012-04-23T22:21:55.283', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1470', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><regular-languages><proof-techniques><pumping-lemma>', 'CreationDate': '2012-04-23T19:29:10.360', 'Id': '1469'},77_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>One of the definitions of a computably enumerable (c.e., equivalent to recursively enumerable, equivalent to semidecidable) set is the following:</p>\n\n<blockquote>\n  <p>$A \\subseteq \\Sigma^*$ is c.e. iff there is a decidable language $V\\subseteq \\Sigma^*$ (called verifier) s.t. \n  for all $x\\in \\Sigma^*$, </p>\n  \n  <p>$x\\in A$ iff there exists a $y\\in\\Sigma^*$ s.t. $\\langle x, y \\rangle \\in V$.</p>\n</blockquote>\n\n<p>So one way to show that a language is not c.e. is to show that there is no decidable verifier $V$ for it. Is this method useful to show that languages are not c.e. in practice?</p>\n', 'ViewCount': '256', 'Title': 'Can we show a language is not computably enumerable by showing there is no verifier for it?', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-03T11:46:38.007', 'LastEditDate': '2012-04-30T08:01:59.740', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1314', 'Tags': '<computability><proof-techniques><undecidability>', 'CreationDate': '2012-04-30T05:32:15.673', 'Id': '1586'},77_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a general question about mapping reductions. I have seen several examples of reducing functions to $A_{TM}$</p>\n\n<p>where $A_{TM} = \\{\\langle M, w \\rangle : \\text{ For } M \\text{ is a turing machine which accepts string } w\\}$</p>\n\n<p>which is great for proving undecidability. But say I want to prove unrecognizability instead. That is, I want to use the corollary that given $A \\le_{m} B$, if $A$ is unrecognizable then $B$ is unrecognizable.</p>\n\n<p>So for any arbitrary unrecognizable language $C$ which can be reduced to $\\overline{A_{TM}}$ (any example language would suffice for sake of example), how can I reduce $\\overline{A_{TM}} \\le_{m} C$?</p>\n\n<p>For simplicity, suffice to merely consider TM in $\\overline{A_{TM}}$.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>For clarification, $\\overline{A_{TM}} = \\{ \\langle M, w \\rangle : M \\text{ is a turing machine which does not accept string } w \\}$</p>\n', 'ViewCount': '381', 'Title': 'Mapping Reductions to Complement of A$_{TM}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T13:12:53.150', 'LastEditDate': '2012-05-09T13:12:53.150', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1604', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1057', 'Tags': '<computability><proof-techniques><reductions>', 'CreationDate': '2012-05-01T00:13:40.497', 'Id': '1603'},77_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Consider this example (taken from this document: <a href="http://www.cs.nott.ac.uk/~txa/g51mal/notes-3x.pdf" rel="nofollow">Showing that language is not regular</a>):</p>\n\n<p>$$L = \\{1^n \\mid n\\text{ is even}\\} $$</p>\n\n<p>According to the Pumping Lemma, a language $L$ is regular if :</p>\n\n<ul>\n<li>$y \\ne \u03b5$</li>\n<li>$|xy| \\lt n$</li>\n<li>$\\forall k \\in N, xy^kz \\in L$</li>\n</ul>\n\n<p>In the above example, $n$ must be even. Suppose we have $n = 4$, we can express: $$xy^kz$$ such that: $x = 1$, $z = 1$, and with $k = 2$, we have $y^k = y^2 = 11$, so we get the string $1111$. However, since all $k$ must be satisfied, if $k = 1$, the string is $111$, it does not belong to $L$. Yet, I was told that the above example is a regular language. How can it be?</p>\n', 'ViewCount': '1940', 'Title': 'Why is this example a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T14:46:55.897', 'LastEditDate': '2012-05-10T14:46:55.897', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1707', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<formal-languages><regular-languages><proof-techniques>', 'CreationDate': '2012-05-07T03:45:04.323', 'Id': '1706'},77_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am doing FFT-based multiplication of polynomials with integer coefficients (long integers, in fact). The coefficients have a maximum value of $BASE-1, \\quad BASE \\in \\mathbb{n},\\quad BASE &gt; 1$. </p>\n\n<p>I would like to put forward a formal argument that if we use complex DFT for computing a convolution on a physical machine, it will yield incorrect results at some transform length $n\\in \\mathbb{N}$. </p>\n\n<p>What was easy to prove was the fact that at some big $n$ computing the convolution with DFT will not at all be possible, since, for example, the following difference of primitive roots modulo $n$:  $\\omega_n^1 - \\omega_n^2 \\rightarrow 0$ when $n \\rightarrow \\infty$, and if we are restricted by some machine epsilon $\\epsilon$, at some $n$ it will make the values indistinguishable and interpolation impossible.</p>\n\n<p>But the boundary I\'ve received using such an argument was way too big: only for $n=2^{60}$ I\'ve received $\\omega_n^1 - \\omega_n^2$ that had both components, $Re$ and $Im$, less than representable by $double$-precision type. This certainly is a boundary, but not very practical one.</p>\n\n<p>What I would like to show (if it is possible), is that much earlier than interpolation becomes theoretically impossible, the round-off errors will start to give wrong coefficients in the convolution, so that</p>\n\n<p>$$a\\cdot b \\neq IDFT(DFT(a)\\times DFT(b)),$$</p>\n\n<p>where $DFT$ and $IDFT$ are algorithm implementations that I use to calculate the Fourier transform. </p>\n\n<p>Maybe it is possible to make use of the fact that the value of the primitive root modulo $n$, $\\omega_n = \\exp(-2\\pi i / n)$, is an irrational number for the majority of $n$\'s. It will thereby be computed with inevitable error $\\psi$, defined as the value needed to "round off" everything that\'s less than the machine epsilon $\\epsilon$. Thus all the values used for DFT,</p>\n\n<p>$$\\omega_n^0, \\omega_n^1, ..., \\omega_n^{n-1},$$</p>\n\n<p>except for $\\omega_n^0$ will also be computed with errors. </p>\n\n<p>Since I\'m not a good mathematician at all, I don\'t know if and how I could use this fact to prove that the situation is going to worsen with increasing $n$ and that eventually the convolution is going to be computed incorrectly. </p>\n\n<p>I would also like to have and argument for OR against the following claim: for fixed $n$, the maximal error will be produced when all the coefficients of both polynomials are $BASE-1$.</p>\n\n<p>Thank you very much in advance!</p>\n', 'ViewCount': '101', 'Title': 'An argument for error accumulation during complex DFT', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T16:26:36.650', 'LastEditDate': '2012-05-14T15:45:22.677', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1198', 'Tags': '<algorithms><proof-techniques><numerical-analysis>', 'CreationDate': '2012-05-12T21:44:19.307', 'Id': '1814'},77_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '990', 'Title': 'Master theorem not applicable?', 'LastEditDate': '2013-02-02T13:24:28.657', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1561', 'FavoriteCount': '1', 'Body': '<p>Given the following recursive equation</p>\n\n<p>$$ T(n) = 2T\\left(\\frac{n}{2}\\right)+n\\log n$$ we want to apply the Master theorem and note that</p>\n\n<p>$$ n^{\\log_2(2)} = n.$$</p>\n\n<p>Now we check the first two cases for $\\varepsilon &gt; 0$, that is whether</p>\n\n<ul>\n<li>$n\\log n \\in O(n^{1-\\varepsilon})$ or</li>\n<li>$n\\log n \\in \\Theta(n)$.</li>\n</ul>\n\n<p>The two cases are not satisfied. So we have to check the third case, that is whether</p>\n\n<ul>\n<li>$n\\log n \\in \\Omega(n^{1+\\varepsilon})$ .</li>\n</ul>\n\n<p>I think the third condition is not satisfied either. But why? And what would be a good explanation for why the Master theorem cannot be applied in this case?</p>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><master-theorem>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-24T09:34:21.943', 'CommentCount': '5', 'AcceptedAnswerId': '2388', 'CreationDate': '2012-05-20T20:45:35.817', 'Id': '1957'},77_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '75', 'Title': 'Low-degree nodes in sparse graphs', 'LastEditDate': '2012-05-22T18:01:02.493', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': u'<p>Let $G = (V,E)$ be a graph having $n$ vertices, none of which are isolated, and $n\u22121$ edges, where $n \\geq 2$. Show that $G$ contains at least two vertices of degree one.</p>\n\n<p>I have tried to solve this problem by using the property $\\sum_{v \\in V} \\operatorname{deg}(v) = 2|E|$.  Can this problem be solved by using <a href="https://en.wikipedia.org/wiki/Pigeon_hole_principle">pigeon hole principle</a>?</p>\n', 'Tags': '<graph-theory><proof-techniques>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-05-24T19:50:20.467', 'CommentCount': '5', 'AcceptedAnswerId': '1999', 'CreationDate': '2012-05-22T17:38:43.177', 'Id': '1998'},77_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '785', 'Title': 'How to prove correctness of a shuffle algorithm?', 'LastEditDate': '2012-05-30T08:13:00.493', 'AnswerCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1642', 'FavoriteCount': '2', 'Body': "<p>I have two ways of producing a list of items in a random order and would like to determine if they are equally fair (unbiased).</p>\n\n<p>The first method I use is to construct the entire list of elements and then do a shuffle on it (say a Fisher-Yates shuffle). The second method is more of an iterative method which keeps the list shuffled at every insertion. In pseudo-code the insertion function is:</p>\n\n<pre><code>insert( list, item )\n    list.append( item )\n    swap( list.random_item, list.last_item )\n</code></pre>\n\n<p>I'm interested in how one goes about showing the fairness of this particular shuffling. The advantages of this algorithm, where it is used, are enough that even if slightly unfair it'd be okay. To decide I need a way to evaluate its fairness.</p>\n\n<p>My first idea is that I need to calculate the total permutations possible this way versus the total permutations possible for a set of the final length. I'm a bit at a loss however on how to calculate the permutations resulting from this algorithm. I also can't be certain this is the best, or easiest approach.</p>\n", 'Tags': '<algorithms><proof-techniques><probability-theory><randomized-algorithms><randomness>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-01T11:23:35.340', 'CommentCount': '5', 'AcceptedAnswerId': '2156', 'CreationDate': '2012-05-29T07:11:15.180', 'Id': '2152'},77_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': 'Finding lambda of Master Theorem', 'LastEditDate': '2013-02-02T13:23:30.387', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'Luc Peetersen', 'PostTypeId': '1', 'OwnerUserId': '1722', 'FavoriteCount': '1', 'Body': '<p>Suppose I have a recurrence like $T(n)=2T(n/4)+\\log(n)$ with $a=2, b=4$ and $f(n)=\\log(n)$.</p>\n\n<p>That should be <a href="http://en.wikipedia.org/wiki/Master_theorem#Case_1" rel="nofollow">case 1 of the Master theorem</a> because $n^{1/2}&gt;\\log(n)$. There is also a lambda in case 1: $f(n)=O(n^{(1/2)-\\lambda})$. Is this correct? And how can I find this lambda?</p>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><master-theorem>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:23:30.387', 'CommentCount': '1', 'AcceptedAnswerId': '2195', 'CreationDate': '2012-06-01T21:00:09.973', 'Id': '2192'},77_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '535', 'Title': 'How can I prove that a complete binary tree has $\\lceil n/2 \\rceil$ leaves?', 'LastEditDate': '2012-06-02T00:54:30.613', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Luc Peetersen', 'PostTypeId': '1', 'OwnerUserId': '1722', 'FavoriteCount': '2', 'Body': "<p>Given a complete binary tree with $n$ nodes. I'm trying to prove that a complete binary tree has exactly $\\lceil n/2 \\rceil$ leaves.\nI think I can do this by induction.</p>\n\n<p>For $h(t)=0$, the tree is empty. So there are no leaves and the claim holds for an empty tree.</p>\n\n<p>For $h(t)=1$, the tree has 1 node, that also is a leaf, so the claim holds.\nHere I'm stuck, I don't know what to choose as induction hypothesis and how to do the induction step.</p>\n", 'Tags': '<data-structures><graph-theory><proof-techniques><combinatorics><binary-trees>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-06-02T05:41:15.503', 'CommentCount': '6', 'AcceptedAnswerId': '2196', 'CreationDate': '2012-06-01T21:08:05.543', 'Id': '2193'},77_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>My problem is how can I prove that a grammar is unambiguous?\nI have the following grammar:\n$$S\n\u2192 statement\n\u2223 \\mbox{if } expression \\mbox{ then } S\n\u2223 \\mbox{if } expression \\mbox{ then } S \\mbox{ else } S$$</p>\n\n<p>and make this to an unambiguous grammar, I think its correct:</p>\n\n<ul>\n<li><p>$ S \u2192 S_1 \u2223 S_2 $</p></li>\n<li><p>$S_1\n\u2192 \\mbox{if } expression \\mbox{ then } S\n\u2223 \\mbox{if } expression \\mbox{ then } S_2 \\mbox{ else } S_1$</p></li>\n<li><p>$S_2\n\u2192 \\mbox{if } expression \\mbox{ then } S_2 \\mbox{ else } S_2\n\u2223 statement$</p></li>\n</ul>\n\n<p>I know that a unambiguous grammar has one parse tree for every term.</p>\n', 'ViewCount': '3778', 'Title': 'How to prove that a grammar is unambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-09T13:50:57.277', 'LastEditDate': '2013-02-09T13:50:57.277', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1594', 'Tags': '<context-free><formal-grammars><proof-techniques><ambiguity>', 'CreationDate': '2012-06-10T17:15:32.787', 'FavoriteCount': '4', 'Id': '2320'},77_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '815', 'Title': 'How to describe algorithms, prove and analyse them?', 'LastEditDate': '2012-06-16T12:29:53.190', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1715', 'FavoriteCount': '4', 'Body': "<p>Before reading <em>The Art of Computer Programming (TAOCP)</em>, I have not considered these questions deeply. I would use pseudo code to describe algorithms, understand them and estimate the running time only about orders of growth. The <em>TAOCP</em> thoroughly changes my mind.</p>\n\n<p><em>TAOCP</em> uses English mixed with steps and <em>goto</em> to describe the algorithm, and uses flow charts to picture the algorithm more readily. It seems low-level, but I find that there's some advantages, especially with flow chart, which I have ignored a lot. We can label each of the arrows with an assertion about the current state of affairs at the time the computation traverses that arrow, and make an inductive proof for the algorithm. The author says:</p>\n\n<blockquote>\n  <p>It is the contention of the author that we really understand why an algorithm is valid only when we reach the point that our minds have implicitly filled in all the assertions, as was done in Fig.4.</p>\n</blockquote>\n\n<p>I have not experienced such stuff. Another advantage is that, we can count the number of times each step is executed. It's easy to check with Kirchhoff's first law. I have not analysed the running time exactly, so some $\\pm1$ might have been omitted when I was estimating the running time.</p>\n\n<p>Analysis of orders of growth is sometimes useless. For example, we cannot distinguish quicksort from heapsort because they are all $E(T(n))=\\Theta(n\\log n)$, where $EX$ is the expected number of random variable $X$, so we should analyse the constant, say, $E(T_1(n))=A_1n\\lg n+B_1n+O(\\log n)$ and $E(T_2(n))=A_2\\lg n+B_2n+O(\\log n)$, thus we can compare $T_1$ and $T_2$ better. And also, sometimes we should compare other quantities, such as variances. Only a rough analysis of orders of growth of running time is not enough. As <em>TAOCP</em> translates the algorithms into assembly language and calculate the running time, It's too hard for me, so I want to know some techniques to analyse the running time a bit more roughly, which is also useful, for higher-level languages such as C, C++ or pseudo codes.</p>\n\n<p>And I want to know what style of description is mainly used in research works, and how to treat these problems.</p>\n", 'Tags': '<algorithms><proof-techniques><runtime-analysis>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T15:44:06.610', 'CommentCount': '9', 'AcceptedAnswerId': '2390', 'CreationDate': '2012-06-14T13:56:56.550', 'Id': '2374'},77_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In computer science, we have often have to solve <a href="http://en.wikipedia.org/wiki/Recurrence_relation">recurrence relations</a>, that is find a <strong>closed form</strong> for a recursively defined sequence of numbers. When considering runtimes, we are often interested mainly in the sequence\'s <a href="http://en.wikipedia.org/wiki/Asymptotic_analysis"><strong>asymptotic</strong> growth</a>.</p>\n\n<p>Examples are </p>\n\n<ol>\n<li><p>The runtime of a tail-recursive function stepping downwards to $0$ from $n$ whose body takes time $f(n)$:</p>\n\n<p>$\\qquad \\begin{align}\n  T(0) &amp;= 0 \\\\\n  T(n+1) &amp;= T(n) + f(n)    \n \\end{align}$</p></li>\n<li><p>The <a href="http://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci sequence</a>:</p>\n\n<p>$\\qquad \\begin{align}\n  F_0 &amp;= 0 \\\\\n  F_1 &amp;= 1 \\\\\n  F_{n+2} &amp;= F_n + F_{n+1}    \n \\end{align}$</p></li>\n<li><p>The number of <a href="http://en.wikipedia.org/wiki/Dyck_language">Dyck words</a> with $n$ parenthesis pairs:</p>\n\n<p>$\\qquad\\begin{align}\n    C_0 &amp;= 1 \\\\ \n    C_{n+1}&amp;=\\sum_{i=0}^{n}C_i\\,C_{n-i}\n  \\end{align}$</p></li>\n<li><p>The mergesort runtime recurrence on lists of length $n$:</p>\n\n<p>$\\qquad \\begin{align}\n  T(1) &amp;= T(0) = 0 \\\\\n  T(n) &amp;= T(\\lfloor n/2\\rfloor) + T(\\lceil n/2\\rceil) + n-1\n \\end{align}$</p></li>\n</ol>\n\n<p>What are methods to solve recurrence relations? We are looking for</p>\n\n<ul>\n<li>general methods and</li>\n<li>methods for a significant subclass</li>\n</ul>\n\n<p>as well as</p>\n\n<ul>\n<li>methods that yield precise solutions and</li>\n<li>methods that provide (bounds on) asymptotic growth.</li>\n</ul>\n\n<p><sup>This is supposed to become a reference question. Please post one answer per method and provide a general description as well as an illustrative example.</sup></p>\n', 'ViewCount': '1536', 'Title': 'Solving or approximating recurrence relations for sequences of numbers', 'LastEditorUserId': '6716', 'LastActivityDate': '2014-04-24T15:41:56.573', 'LastEditDate': '2013-06-06T16:02:38.220', 'AnswerCount': '8', 'CommentCount': '1', 'Score': '27', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><proof-techniques><combinatorics><recurrence-relation><reference-question>', 'CreationDate': '2012-07-17T18:31:38.607', 'FavoriteCount': '27', 'Id': '2789'},77_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Show that if $A$ is a context-free language and $B$ is finite, then $A - B$ is a context-free language.</p>\n</blockquote>\n\n<p>I'm just not sure how to use their properties to formally show this. Thanks for all the help in advance.</p>\n", 'ViewCount': '65', 'Title': 'Showing $A-B$ is a CFL where $A$ is a CFL and $B$ is finite', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-21T05:01:43.487', 'LastEditDate': '2012-07-21T05:01:43.487', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2125', 'Tags': '<formal-languages><context-free><proof-techniques>', 'CreationDate': '2012-07-20T17:58:00.223', 'Id': '2843'},77_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '291', 'Title': 'Looking for books on creating and understanding theorems targeted at Computer Science', 'LastEditDate': '2012-08-13T05:45:40.903', 'AnswerCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '2', 'Body': '<p>In studying logic to understand verifying programs I have found that there are books on logic targeted at Computer Science e.g.</p>\n\n<ul>\n<li><a href="http://rads.stackoverflow.com/amzn/click/052154310X" rel="nofollow">Logic in Computer Science: Modelling and Reasoning about Systems </a></li>\n<li><a href="http://rads.stackoverflow.com/amzn/click/1447141288" rel="nofollow">Mathematical Logic for Computer Science </a></li>\n<li><a href="http://rads.stackoverflow.com/amzn/click/0521701465" rel="nofollow">Computability and Logic </a></li>\n<li><a href="http://rads.stackoverflow.com/amzn/click/0521899575" rel="nofollow">Handbook of Practical Logic and Automated Reasoning </a></li>\n</ul>\n\n<p>With regards to books on understating theorems targeted at Computer Science I find only one that may fit. As I don\'t have the book I can\'t say for sure.</p>\n\n<ul>\n<li><a href="http://rads.stackoverflow.com/amzn/click/081764220X" rel="nofollow">Handbook of Logic and Proof Techniques for Computer Science </a></li>\n</ul>\n\n<p>Are there any books for understating theorems targeted at Computer Science? In other words are there books for understating syntax, semantics and construction of theorems that don\'t rely on a heavy math background and that give examples more from the world of computer science and explain in a style more natural to a person in computer science.</p>\n\n<p>EDIT</p>\n\n<p>After seeking more on this topic I have come upon the phrases "informal mathematics" and "mathematical discourse" which are starting to turn up useful info from Google. In particular the following: <a href="https://sites.google.com/site/clauszinn/verifying-informal-proofs/37_04.pdf?attredirects=0" rel="nofollow">Understanding Informal Mathematical Discourse</a> found at <a href="https://sites.google.com/site/clauszinn/verifying-informal-proofs/" rel="nofollow">Understanding Informal Mathematical Proofs</a></p>\n', 'Tags': '<logic><proof-techniques><books>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-12-03T00:50:57.973', 'CommentCount': '6', 'AcceptedAnswerId': '2969', 'CreationDate': '2012-07-31T14:38:51.147', 'Id': '2965'},77_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '461', 'Title': 'Solving the recurrence relation $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$', 'LastEditDate': '2012-07-31T20:30:24.733', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': '<p>Solving the recurrence relation $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$.<br>\nThe book from which this example is, falsely claims that $T(n) = O(n)$ by guessing $T(n) \\leq cn$ and then arguing  </p>\n\n<p>$\\qquad \\begin{align*} T(n) &amp; \\leq 2(c \\lfloor n/2 \\rfloor ) + n \\\\ &amp;\\leq cn +n \\\\ &amp;=O(n) \\quad \\quad \\quad \\longleftarrow \\text{ wrong!!} \\end{align*}$  </p>\n\n<p>since $c$ is constant.The error is that we have not proved the <em>exact</em> form of the inductive hypothesis.</p>\n\n<p>Above I have exactly quoted what the book says. Now my question is why cannot we write $cn+n=dn$ where $d=c+1$ and now we have $T(n) \\leq dn$ and hence $T(n) = O(n)$?</p>\n\n<p>Note: </p>\n\n<ol>\n<li>The correct answer is $T(n) =O(n \\log n).$  </li>\n<li>The book I am referring here is <em>Introduction to algorithms</em> by Cormen et al., page 86, 3rd edition.</li>\n</ol>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><landau-notation><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-01T07:09:01.457', 'CommentCount': '1', 'AcceptedAnswerId': '2972', 'CreationDate': '2012-07-31T18:15:32.510', 'Id': '2971'},77_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is homework and I'm looking for a push in the right direction. Proofs were never something I was properly taught, so now they're kind of a weak point.</p>\n\n<p>Here's the problem:</p>\n\n<blockquote>\n  <p>The following grammar generates numbers in binary notation ($C$ is the\n  start symbol):</p>\n  \n  <p>$\\qquad \\begin{align}C &amp;\\to C 0 \\mid A 1 \\mid 0 \\\\\n                       A &amp;\\to B 0 \\mid C 1 \\mid 1 \\\\\n                       B &amp;\\to A 0 \\mid B 1\n          \\end{align}$</p>\n  \n  <ol>\n  <li><p>Prove that the alternating sums of the digits of the generated\n  numbers are multiples of $3$. The alternating sum of $w=w_0\\dots w_n$ is defined as $\\sum_{i=0}^n (-1)^i \\cdot w_i$. As an example, $C$\n  generates $1001$ via $C \\Rightarrow A1 \\Rightarrow B01 \\Rightarrow A001 \\Rightarrow 1001$ with alternating sum of $0$;\n  clearly, $0$ is a multiple of $3$.</p></li>\n  <li><p>Prove that all such numbers (i.e.,\n  numbers whose alternating sum is a multiple of 3) are generated by the\n  grammar.</p></li>\n  </ol>\n</blockquote>\n\n<p>I'm thinking I need to show that the grammar can only generate strings which are made up of repeated subsequences of digits which always add up to 0, 3, or -3. But I'm not sure how to show that it can only generate those three subsequences.</p>\n\n<p>I also have worked out these thoughts:</p>\n\n<ul>\n<li><p>Consider that any even number of consecutive 1s is irrelevant, as they cancel each other out.</p></li>\n<li><p>Consider that all zeros are in of themselves irrelevant, as they add nothing.</p></li>\n<li><p>Consider then that the only relevant pattern is that of alternating 1s and zeros, and where this pattern starts and ends.</p></li>\n</ul>\n", 'ViewCount': '795', 'Title': 'Proving a grammar only generates words whose alternating digit sums is are multiples of three', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T11:59:01.517', 'LastEditDate': '2012-09-03T07:35:35.117', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2716', 'Tags': '<formal-languages><regular-languages><formal-grammars><proof-techniques>', 'CreationDate': '2012-09-02T20:45:42.667', 'Id': '3406'},77_30:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'d like to understand what approaches should one adopt when deciding/proving that a given function <em>F</em> is uncomputable, by any Turing Machine (TM). The ones I\'ve tried so far are as follows:</p>\n\n<ul>\n<li>Reduction, from a known uncomputable function (such as $UC(\\alpha)$, the uncomputable function as proved by Cantor\'s diagonalization argument in Chapter 1 of the book "Computational Complexity" by Sanjeev Arora and Boaz Barak, or $HALT(\\alpha, x)$, which is nothing but the function in the <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="nofollow">Halting problem</a>), to <em>F</em>. If such a reduction is possible, it can be argued that <em>F</em> is uncomputable as otherwise, the problems that are proved to be uncomputable would become be computable as well.</li>\n<li>Proof by contradiction, in which one shows that if there is a TM <em>M</em> that computes <em>F</em>, it would lead to some sort of inconsistency in either the <em>M</em>\'s output, or the functions evaluated value.</li>\n</ul>\n\n<p>I\'ve applied (or rather, tried to apply) both the above techniques to some reductions, two of which I now state here (for illustrating the limitations of my approach):</p>\n\n<blockquote>\n  <ol>\n  <li><p>If whenever a TM <em>M</em> accepts a string <em>w</em> $\\in$ ${\\{0,1\\}}^*$, it also accepts $w^R$, the TM <em>M</em> is said to possess property <em>R</em>. ($w^R$ is the string obtained by reversing $w$ i.e. $(110)^R$ is $011$). Let $R: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: $R(\\alpha) = 1$ if $M_\\alpha$ possesses property $R$, and $R(\\alpha) = 0$ otherwise. Prove that $R$ is uncomputable.</p></li>\n  <li><p>Let $B: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: \n  $B(\\alpha,x) = 1$ if $M_\\alpha$ writes a non-blank symbol on its output tape while computing input $x$, $B(\\alpha,x) = 0$ otherwise. Prove that function $B$ is uncomputable.</p></li>\n  </ol>\n</blockquote>\n\n<p>For problem 1, I tried reducing the uncomputable function $UC$ to $R$, but the reason I couldn\'t quite complete the reduction is because $R$ is a property of the Turing Machine, not dependent on any input instance, where $UC$ depends on the output of a specific instance $M_\\alpha(\\alpha)$. Also, for both $R(\\alpha)$ = 0 and $R(\\alpha)$ = 1, it is possible that $M_\\alpha$ can go on indefinitely for some inputs! </p>\n\n<p>For problem 2, I tried reducing the function $HALT$ to $B$ (thus attempting to make a TM that computes $HALT(\\alpha,x)$ by using the output of a TM $M_\\beta$ that computes $B$). But here as in problem 1, <em>it is possible</em> that for both outputs of $M_\\beta(\\alpha,x)$, the TM $M_\\alpha$ may not halt at all on input $x$! </p>\n\n<p>So, I\'m stumped here - I understand intuitively why these functions should be uncomputable (No TM should be able to predict whether another TM would halt/output anything on any possible input), I\'m not quite able to derive a concrete proof! So, I really want to understand what approaches am I missing here, or are there holes in the current approaches that I\'ve tried so far!</p>\n\n<p>Note: For self-containment, I\'m stating what are the functions UC and HALT here as well:</p>\n\n<p>$UC: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$UC(\\alpha) = 0$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ = 1</p>\n\n<p>$UC(\\alpha) = 1$, otherwise.</p>\n\n<p>$HALT: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$HALT(\\alpha, x) = 1$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ halts on input $x$.</p>\n\n<p>$HALT(\\alpha, x) = 0$, otherwise.</p>\n', 'ViewCount': '338', 'Title': 'What approaches are most useful when proving uncomputability of a given function?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-20T12:16:37.440', 'LastEditDate': '2012-09-16T21:19:35.027', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '476', 'Tags': '<computability><turing-machines><proof-techniques><undecidability>', 'CreationDate': '2012-09-16T20:40:29.383', 'FavoriteCount': '1', 'Id': '4577'},77_31:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this simple 'assignment' problem:</p>\n\n<p>We have a set of agents $A = \\{a_1, a_2, \\dotso, a_n\\}$ and set of tasks $T= \\{t_1, 1_2, \\dotso, t_m\\}$. Note that $m$ is not necessarily equal to $n$. Unlike the general assignment formulation in Wikipedia, a task $t_c$ can only be assigned to an agent based on the task's preferred agents $ta_c \\subseteq A$. For example, if we have $ta_1= \\{a_1, a_3\\}$, that means that task $t_1$ can only be assigned to either agents $a_1$ or $a_3$. Now, each agent $t_d$ has a qouta $q_d$ where $q_d$ is positive integer. This means that $a_d$ must be assigned with $q_d$ number of tasks. </p>\n\n<p><strong>The Problem</strong></p>\n\n<p>Given above and a set of qoutas $\\{q_1, q_2, \\dotso, q_n\\}$, is there an assignment of tasks to agents such that all agents meet their respective qouta $q$. Note that it is not necessarily that all tasks be assigned to an agent. </p>\n\n<p><strong>Possible Solution</strong></p>\n\n<p>I have tried reformulating this problem in terms of a bipartite graph $G(A, T, E = \\cup ta_c)$ and expressed as a form of matching problem where given a matching $M$, a vertex agent $a_d\\in A$ is matched up to $q_d$ times or is incident to $q_d$ edges in $M$ but the vertices in $T$ is incident to only one edge in $M$. Not really like the usual matching problem which requires that the edges in $M$ are pairwise non-adjacent.</p>\n\n<p>However, it was suggested by someone (from cstheory, he knows who he is) that I could actually work this out as a maximum matching problem, by replicating an agent $a_d$ into $q_d$ vertices and 'conceptually' treat them as different vertices as input to the matching algorithm. The set of edges $E$ is also modified accordingly. Call the modified graph as $G'$</p>\n\n<p>It is possible to have more than 1 maximum matchings from graph $G'$. Now, if I understand this correctly, I still have to check each of the resulting maximum matchings and see that at least one of them satisfies the $qouta$ constraint of each $agent$ to actually provide the solution to the problem.</p>\n\n<p>Now, I want to prove that not finding one maximum matching $M$ $\\in$ set of all maximum matchings of the graph $G'$ that satisfies the $qouta$ constraint of the problem guarantees that there really exists no solution to the problem instance, otherwise a solution exist which is $M$.</p>\n\n<p><strong>I want to show that this algorithm always give correct result.</strong> </p>\n\n<p><strong>Question</strong></p>\n\n<p>Can you share to me some intuition on how I might go to show this?</p>\n", 'ViewCount': '294', 'Title': 'Simple Task-Assignment Problem', 'LastEditorUserId': '2922', 'LastActivityDate': '2012-09-23T00:13:44.433', 'LastEditDate': '2012-09-23T00:13:44.433', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4684', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2922', 'Tags': '<algorithms><graph-theory><proof-techniques><assignment-problem>', 'CreationDate': '2012-09-22T23:22:25.637', 'Id': '4683'},77_32:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove the following lemma:</p>\n\n<p>$c$ is a positive real number and $f, g$ are functions from natural numbers to non-negative real numbers. I'm trying to prove rigorously that:</p>\n\n<p>$\\Omega(cf(n))$ = $\\Omega(f(n))$.</p>\n\n<p>I know that it is obvious but I'm trying to construct a proof that is as complete as possible. My current approach is like this:</p>\n\n<p>This lemma is equivalent to saying that: $f(n) \\in \\Omega(cf(n))$ iff $cf(n) \\in \\Omega(f(n))$.</p>\n\n<p>We can also restate that as:</p>\n\n<ol>\n<li>If $t(n) \\in \\Omega(cf(n))$ then $t(n) \\in \\Omega(f(n))$.</li>\n<li>If $t(n) \\in \\Omega(f(n))$ then $t(n) \\in \\Omega(cf(n))$.</li>\n</ol>\n\n<p>For 1.,</p>\n\n<p>$(*)$ $\\exists d_1, d_2 \\gt 0, \\forall n \\gt n_0, n_1, \\forall n \\in N$:</p>\n\n<p>$t(n) \\ge d_1cf(n)$ and $t(n) \\ge d_2f(n)$</p>\n\n<p>Now let's fix $d_1, d_2$ and $n_0, n_1$ to be any constants that fulfils $(*)$, such that:\n$n'=max\\{n_0, n_1\\}$ and $d_1c \\ge d_2$, using this we can say that:</p>\n\n<p>$t(n) \\ge d_1cf(n) \\ge d_2f(n)$ and hence the 1. is satisfied because $t(n) \\in \\Omega(cf(n)), \\Omega(f(n))$. The proof of 2. is mutatis mutandis.</p>\n\n<p>Do I have a mistake in my proof, is there a better/more elegant way to prove this lemma? Shortly how can I improve this?</p>\n", 'ViewCount': '141', 'Title': 'Proving $\\Omega(cf) = \\Omega(f)$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-03T11:34:57.393', 'LastEditDate': '2012-10-02T17:45:39.213', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2956', 'Tags': '<asymptotics><proof-techniques><check-my-proof>', 'CreationDate': '2012-10-02T12:45:11.833', 'Id': '4840'},77_33:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In my Computing Theory course, a lot of our problems involve using induction on the length of the input string to prove statements about finite automata.  I understand mathematical induction, however when strings come into play I get real tripped up.  I\'d really appreciate it if someone would go through the process of making such a proof step by step.</p>\n\n<p>Here\'s an example problem (Exercise 2.2.10 from Hopcroft and Ullman 3rd Edition):</p>\n\n<blockquote>\n  <p>Consider the DFA with the following transition table:</p>\n\n<pre>\n        0    1\n       ________\n-> A |  A    B\n  *B |  B    A\n</pre>\n  \n  <p>Informally describe the language accepted by this DFA, and prove by induction on the length of an input string that your description is correct.</p>\n</blockquote>\n\n<p>This is an answered problem in the book, so I\'m not looking for someone to do my homework.  I just need someone to explain it to me straight.</p>\n\n<p><strong>Book\'s Answer:</strong>\n(taken from <a href="http://infolab.stanford.edu/~ullman/ialcsols/sol2.html" rel="nofollow">here</a>)</p>\n\n<blockquote>\n  <p>The automaton tells whether the number of 1\'s seen is even (state A) or odd (state B), accepting in the latter case. It is an easy induction on |w| to show that dh(A,w) = A if and only if w has an even number of 1\'s.\n  Basis: |w| = 0. Then w, the empty string surely has an even number of 1\'s, namely zero 1\'s, and \u03b4-hat(A,w) = A.</p>\n  \n  <p>Induction: Assume the statement for strings shorter than w. Then w = za, where a is either 0 or 1.</p>\n  \n  <ul>\n  <li><p><strong>Case 1:</strong> a = 0. If w has an even number of 1\'s, so does z. By the inductive hypothesis, \u03b4-hat(A,z) = A. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then so does z. By the inductive hypothesis, \u03b4-hat(A,z) = B, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  <li><p><strong>Case 2:</strong> a = 1. If w has an even number of 1\'s, then z has an odd number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = B. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then z has an even number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = A, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case as well, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  </ul>\n</blockquote>\n\n<p>I understand how to prove things like $\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}$ using induction.  I\'m just confused by how this works with building strings.  I\'m confused by the bolded parts.  I don\'t understand how they are come up with/how it actually proves what is accepted/how it is inductive.</p>\n\n<p>\u03b4-hat is the extended transition function, by the way.</p>\n', 'ViewCount': '1544', 'Title': 'How do I write a proof using induction on the length of the input string?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T17:30:34.120', 'LastEditDate': '2014-02-02T17:30:34.120', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4907', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3082', 'Tags': '<automata><finite-automata><proof-techniques><reference-question><induction>', 'CreationDate': '2012-10-06T19:00:18.360', 'Id': '4905'},77_34:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's say I found  a 2-approximation algorithm for a certain problem and I want to show that the analysis is tight. </p>\n\n<p>Do I now need to come up with an example of generic size $n$ or does it suffice to show that I   have an example of size $10$ for which the algorithm yields $2OPT$?</p>\n", 'ViewCount': '398', 'Title': 'Providing Tight Example in Approximation Algorithm Analysis', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-18T18:33:07.623', 'LastEditDate': '2012-10-18T06:35:18.780', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4239', 'Tags': '<algorithms><proof-techniques><approximation>', 'CreationDate': '2012-10-17T23:07:10.890', 'FavoriteCount': '2', 'Id': '6140'},77_35:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I have the following problem:</p>\n\n<p>De\ufb01ne the keyed function F as follows: On input k \u2208 {0, 1}$^n$\nand x \u2208 {0, 1}$^n$ , Fk(x) = k \u2295 x.Rigorously prove that F is not a pseudorandom function.</p>\n\n<p>How do I approach a proof against pseudorandomness for a keyed function? I don't know where to start with this one.</p>\n", 'ViewCount': '397', 'Title': 'Rigorous proof against pseudo random function', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T13:44:19.380', 'LastEditDate': '2012-10-22T13:44:19.380', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6145', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<proof-techniques><cryptography>', 'CreationDate': '2012-10-18T00:40:36.627', 'Id': '6144'},77_36:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Doing the following exercise:</p>\n\n<blockquote>\n  <p>Let $\\overline{HALT(x,y)}$ be defined as </p>\n  \n  <p>$\\overline {HALT(x,y)} \\iff \\text{program number y never halts on input x}$</p>\n  \n  <p>Show that it is not computable.</p>\n</blockquote>\n\n<p>Just want to make sure I have understood the concept correctly. We had in a theorem that HALT(x,y) is not computable which means that we cannot determine whether program number y eventually halts on input x. I realized that $\\overline {HALT(x,y)}$ is the negation of HALT(x,y). Is it true (I cannot find it in my book or on the internet) that if a function is (not) computable, its negation is also (not) computable? A function being computable means there is a program p which computes it, we cannot say there is a program Q that computes its negation. Or can we draw such conclusion? </p>\n', 'ViewCount': '159', 'Title': 'If a predicate is not computable, what can be said about its negation?', 'LastActivityDate': '2012-10-23T23:59:04.863', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '6273', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<computability><proof-techniques>', 'CreationDate': '2012-10-23T11:34:34.550', 'Id': '6262'},77_37:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If $f(x_1,\\dots, x_n)$ is a total function that for some constant $K$, $f(x_1,\\dots, x_n) \\leq K$ for all $x_1,\\dots, x_n$ then $f$ is computable. </p>\n\n<p>I want some hints on how to prove/disprove the above claim. This an exercise from the book <a href="http://rads.stackoverflow.com/amzn/click/0122063821" rel="nofollow">Computability, Complexity, and Languages</a>. As I didn\'t find the solutions to the exercises online, I want to see a formal solution of such problems, if possible. </p>\n', 'ViewCount': '149', 'Title': 'How to prove or disprove that f is computable?', 'LastEditorUserId': '140', 'LastActivityDate': '2012-10-23T18:10:18.237', 'LastEditDate': '2012-10-23T12:14:33.447', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6269', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<computability><proof-techniques>', 'CreationDate': '2012-10-23T12:01:35.420', 'Id': '6263'},77_38:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm looking for a $\\Theta$ approximation of\n$$T(n) = T(n-1) + cn^{2}$$</p>\n\n<p>This is what I have so far:</p>\n\n<p>$$\n\\begin{align*}\nT(n-1)&amp; = T(n-2) + c(n-1)^2\\\\\nT(n) &amp;= T(n-2) + c(n-1) + cn^2\\\\[1ex]\nT(n-2) &amp;= T(n-3) + c(n-2)^2\\\\\nT(n) &amp; = T(n-3) + c(n-2)^2 + c(n-1)^2 + cn^2 \\\\[1ex]\nT(n-3) &amp;= T(n-4) + c(n-3)^2 \\\\\nT(n) &amp;= T(n-4) + c(n-3)^2 + c(n-2)^2 + c(n-1)^2 + cn^2\n\\end{align*}\n$$</p>\n\n<p>So, at this point I was going to generalize and substitute $k$ into the equation.</p>\n\n<p>$$T(n)= T(n-k) + (n-(k-1))^2 + c(k-1)^2$$</p>\n\n<p>Now, I start to bring the base case of 1 into the picture. On a couple of previous, more simple problems, I was able to set my generalized k equation equal to 1 and then solve for $k$. Then put $k$ back into the equation to get my ultimate answer.</p>\n\n<p>But I am totally stuck on the $(n-k+1)^2$ part. I mean, should I actually foil all this out? I did it and got $k^2-2kn-2k+n^2 +2n +1 = 1$. At this point I'm thinking I totally must have done something wrong since I've never see this in previous problems.</p>\n\n<p>Could anyone offer me some help with how to solve this one? I would greatly appreciate it. I also tried another approach where I tried to set $n-k = 0$ from the last part of the equation and got that $k = n$. I plugged n back into the equation towards the end and ultimately got $n^2$ as an answer. I have no clue if this is right or not.</p>\n\n<p>I am in an algorithms analysis class and we started doing recurrence relations and I'm not 100% sure if I am doing this problem correct. I get to a point where I am just stuck and don't know what to do. Maybe I'm doing this wrong, who knows. The question doesn't care about upper or lower bounds, it just wants a theta.</p>\n", 'ViewCount': '1572', 'Title': 'Recurrence relation for time complexity $T(n) = T(n-1) + n^2$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-28T00:27:27.063', 'LastEditDate': '2012-10-25T22:53:46.943', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '6275', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4336', 'Tags': '<time-complexity><algorithm-analysis><proof-techniques><recurrence-relation>', 'CreationDate': '2012-10-24T00:56:53.863', 'Id': '6274'},77_39:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/6404/runtime-of-the-binary-gcd-state-machine">Runtime of the binary-GCD state machine</a>  </p>\n</blockquote>\n\n\n\n<p><strong>Hello I am doing self study from MIT OCW exercises and I could not understand this question. Can anyone explain me,</strong></p>\n\n<ul>\n<li><p>First, why does this state machine assume it halves the $(max(a,b))$ at every two transitions beacuse we can follow steps 4 and 7 and one extra step to halve the $(max(a,b))$, which is more than 2 transitions/steps. I know it is not a common case but a case is a case unless proved.</p></li>\n<li><p>Next I dont see where an extra 3 comes from in $3+2log(max(a,b))$  </p></li>\n</ul>\n\n<p><strong>Question:</strong>\nThe binary-GCD state machine computes the GCD of a and b using only division\nby 2 and subtraction, which makes it run very efficiently on hardware that uses binary\nrepresentation of numbers. In practice, it runs more quickly than the Euclidean\nalgorithm state machine.</p>\n\n<p><strong>Prove that the machine reaches a final state in at most $3+2log(max(a,b))$\ntransitions.</strong></p>\n\n<p><strong>Hint:</strong> Strong induction on $max(a,b)$ </p>\n\n<p>states: $\\mathbb{N}^3$</p>\n\n<p>start state: $(a,b,1)$, where $a &gt;b&gt;0$</p>\n\n<p>transitions: if $min(x,y) &gt;0$, then $(x,y,e) \\rightarrow $</p>\n\n<p>the first possible state according to rules </p>\n\n<p><strong>1-</strong> $(1,0,ex)$ if $(x=y)$</p>\n\n<p><strong>2-</strong> $(1,0,e)$ if $(y=1)$</p>\n\n<p><strong>3-</strong> $(x/2,y/2,2e)$ if $(2|x \\ and \\ 2|y)$</p>\n\n<p><strong>4-</strong> $(y,x,e)$ if $(y&gt;x)$</p>\n\n<p><strong>5-</strong> $(x,y/2,e)$ if $(2|y)$</p>\n\n<p><strong>6-</strong> $(x/2,y,e)$ if $(2|x)$</p>\n\n<p><strong>7-</strong> $(x-y,y,e)$ if $(otherwise)$</p>\n', 'ViewCount': '27', 'ClosedDate': '2012-10-31T23:37:58.493', 'Title': 'The binary-GCD algorithm state machine', 'LastActivityDate': '2012-10-31T13:43:07.573', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4412', 'Tags': '<algorithms><proof-techniques>', 'CreationDate': '2012-10-31T13:43:07.573', 'FavoriteCount': '0', 'Id': '6402'},77_40:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am doing self study from <a href="http://www.myoops.org/twocw/mit/NR/rdonlyres/Electrical-Engineering-and-Computer-Science/6-042JFall-2005/3970D151-BFD3-4181-81CD-804F109B3AC2/0/ln7.pdf" rel="nofollow">MIT OCW exercises</a> and I could not understand this question.</p>\n\n<blockquote>\n  <p>The following rules define the <em>binary-GCD state machine</em> working on states in $\\mathbb{N}^3$ with start state $(a,b,1)$ for $a&gt;b&gt;0$. If multiple rules apply, smaller numbers have precedence.</p>\n  \n  <p>Provided $\\min(x,y) &gt;0$, then $(x,y,e) \\to $</p>\n  \n  <ol>\n  <li>$(1,0,ex)$ if $x=y$</li>\n  <li>$(1,0,e)$ if $y=1$</li>\n  <li>$(x/2,y/2,2e)$ if $2|x \\land 2|y$</li>\n  <li>$(y,x,e)$ if $y&gt;x$</li>\n  <li>$(x,y/2,e)$ if $2|y$</li>\n  <li>$(x/2,y,e)$ if $2|x$</li>\n  <li>$(x-y,y,e)$ otherwise</li>\n  </ol>\n</blockquote>\n\n<p>The binary-GCD state machine computes the GCD of $a$ and $b$ using only division by $2$ and subtraction, which makes it run very efficiently on hardware that uses binary representation of numbers. In practice, it runs more quickly than the Euclidean algorithm state machine.</p>\n\n<p>Each execution of a command (one of rules 1-7 according to algorithm) is a transition and the current state $(x,y,e)$ is stored in registers $A,B,E$. At first the values in the registers $a,b,1$</p>\n\n<p>Here is the question I am having trouble with:</p>\n\n<blockquote>\n  <p>Prove that the machine reaches a final state in at most $3+2\\log(\\max(a,b))$\n  transitions.</p>\n  \n  <p><strong>Hint:</strong> Strong induction on $\\max(a,b)$ </p>\n</blockquote>\n\n<ul>\n<li><p>First, why does this state machine assume it halves the $\\max(a,b)$ at every two transitions beacuse we can apply rule 4 and 7 and one extra rule to halve the $\\max(a,b)$, which is more than two transitions/steps. I know it is not a common case but a case is a case unless proved.</p></li>\n<li><p>Next I don\'t see where an extra 3 comes from in $3+2\\log(\\max(a,b))$.  </p></li>\n</ul>\n', 'ViewCount': '129', 'Title': 'Runtime of the binary-GCD state machine', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T04:01:55.783', 'LastEditDate': '2012-10-31T23:35:29.357', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4413', 'Tags': '<algorithms><finite-automata><proof-techniques>', 'CreationDate': '2012-10-31T17:37:32.330', 'FavoriteCount': '0', 'Id': '6404'},77_41:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I\'ve been scratching my head over this problem for a couple of days now.  Given some language $A$ and $B$ that is regular, show that the language $L$ which consists of all strings in $A$ whose length is equal to some string in $B$ is a regular language.</p>\n\n<p>In equation form:</p>\n\n<p>$$L = \\{x \\in A \\mid \\exists y \\in B \\text{ s.t. } |x| = |y| \\}$$</p>\n\n<p>My initial thought was to try and come up with some DFA for both languages $A$ and $B$ and map the two states to each other and hopefully get a 1:1 ratio that way I can generate a new DFA which proves that $L$ is regular.  But then I realized that $A$ and $B$ don\'t have to be over the same set of symbols.  </p>\n\n<p>I think the correct way to solve this is to use the closure properties of regular language, but I\'m not sure of how to begin/use the properties for "lengths" of strings instead of strings themselves.  </p>\n\n<p>Could someone point me in the right direction?</p>\n', 'ViewCount': '255', 'Title': 'Proving the language which consists of all strings in some language is the same length as some string in another language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-08T04:07:41.613', 'LastEditDate': '2012-11-05T08:20:14.120', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4463', 'Tags': '<formal-languages><regular-languages><finite-automata><proof-techniques><closure-properties>', 'CreationDate': '2012-11-05T05:52:51.367', 'Id': '6484'},77_42:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '610', 'Title': 'NP-Completeness - Proof by Restriction', 'LastEditDate': '2012-11-07T21:45:31.310', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4481', 'FavoriteCount': '1', 'Body': '<p>I\'m reading Garey &amp; Johnsons <em>"Computers and Intractability"</em> and I\'m at the part <em>"Some techniques for solving NP-Completeness"</em>. Here\'s the text about Proof by Restriction:</p>\n\n<blockquote>\n  <p>Proof by restriction is the simplest, and perhaps most frequently\n  applicable, of our three proof types. An NP-completeness proof by\n  restriction for a given problem $L \\in NP$ consists simply of showing that\n  $L$ contains a known NP-complete problem $L\'$ as a special case. The heart\n  of such a proof lies in the specification of the additional\n  restrictions to be placed on the instances of $L$ so that the resulting\n  restricted problem will be identical to $L\'$. We do not require that the\n  restricted problem and the known NP-complete problem be exact\n  duplicates of one another, but rather that there be an "obvious"\n  one-to-one correspondence between their instances that preserves "yes"\n  and "no" answers."</p>\n</blockquote>\n\n<p>And I\'m trying to learn this technique by example, but need some help.</p>\n\n<p>(If you have the book, my example is on page 65, 27th printing)</p>\n\n<p>They prove that <em>Multiprocessor Scheduling</em> is NP-complete with the following proof:</p>\n\n<p>(Paraphrasing):</p>\n\n<blockquote>\n  <p>Restrict to PARTITION by allowing only instances in which $m = 2$ and $D$\n  $=$ half the total sum of the "lengths".</p>\n</blockquote>\n\n<p>Here $m$ is the number of processors and $D$ is the maximum allowed sum of "lengths" per processor. </p>\n\n<p>This is obviously a special case of multiprocessor scheduling which is solvable by solving the PARTITION problem, and there\'s no confusion there.</p>\n\n<p>But, I\'m not sure why this proof holds. </p>\n\n<p>Excerpt from above: <em>"The heart of such a proof lies in the specification of additional restrictions to be placed on the instances of $L$ so that the resulting restricted problem will be identical to $L\'$ ".</em></p>\n\n<p>The way I see it that means we have to find the special case, and then find restrictions that show us that this problem can always be reduced to the special case. What we\'re trying to do here is show that Problem $A$ (MS) is at least as hard as Problem $B$ (PARTITION), so why would a simple special case be enough here? Is it because there\'s an obvious way to map to this special case that I\'m missing? Or perhaps because $m = 1$ is trivial and we know that the problem will only get harder with a higher $m$, and that $D$ is always arbitrary, therefore $A$ must be at least as hard as $B$ (I feel like I\'m just guessing now :p)</p>\n\n<p>I hope it is clear where I get lost. </p>\n\n<p><strong>TLDR; Why is it enough to find a special case that is solvable by an NP-Complete problem? Don\'t we need some reduction to complete the proof?</strong></p>\n', 'Tags': '<complexity-theory><np-complete><proof-techniques>', 'LastEditorUserId': '4481', 'LastActivityDate': '2012-11-07T23:54:51.733', 'CommentCount': '2', 'AcceptedAnswerId': '6527', 'CreationDate': '2012-11-07T08:30:41.353', 'Id': '6525'},77_43:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's start with the comparison sorting lower bound proof, which I'll summarize as follows:</p>\n\n<ol>\n<li>For $n$ distinct numbers, there are $n!$ possible orderings.</li>\n<li>There is only one correct sorted sequence of the $n$ numbers.</li>\n<li>We are given that comparison ($&lt;$) is the only operation we have that can narrow down the $n!$ possible orderings, and each comparison has only two possible outcomes.</li>\n<li>So $\\log_2(n!)$ comparisons are required.</li>\n</ol>\n\n<p>Now consider the following generalization of the argument above:</p>\n\n<ol>\n<li>Define a space of possibilities and its size (in the case of sorting, $n!$ orderings)</li>\n<li>Define the goal state and its size (in this case, only one correctly sorted answer)</li>\n<li>Define the amount of information that is gained at each step of the computation (in this case, one bit since there are only two possible outcomes per comparison)</li>\n<li>Calculate the information difference between the space of possibilities (step 1) and the goal space (step 2) and divide by the information gain per step (step 3) to yield the lower bound on the number of steps (in this case, $(\\log_2(n!)$ - $\\log_2(1))$ / 1 = $\\log_2(n!)$).</li>\n</ol>\n\n<p>Please answer all the following questions. I'm less concerned with the correctness of the particulars of step 4 than I am with the correctness of steps 1 - 3.</p>\n\n<ol>\n<li>Are there any problems with the generalized argument?</li>\n<li>If the problems can be fixed, what are the fixes?</li>\n<li>If the problems can't be fixed, please point out the fatal ones and provide directions to sources which describe these lower-bounds proofs and their pitfalls.</li>\n</ol>\n", 'ViewCount': '274', 'Title': 'Generalizing the Comparison Sorting Lower Bound Proof', 'LastEditorUserId': '19', 'LastActivityDate': '2012-12-23T05:23:41.497', 'LastEditDate': '2012-11-08T16:36:29.557', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<proof-techniques><sorting><information-theory><check-my-proof><lower-bounds>', 'CreationDate': '2012-11-08T15:48:38.323', 'FavoriteCount': '1', 'Id': '6562'},77_44:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>From <a href="http://rads.stackoverflow.com/amzn/click/0262033844" rel="nofollow">CLRS</a> (third edition, page 19), there is a footnote:</p>\n\n<blockquote>\n  <p>When the loop is a for loop, the moment at which we check the loop invariant just prior to the first iteration is immediately after the initial assignment to the loop-counter variable and just before the first test in the loop header.</p>\n</blockquote>\n\n<p>Why is the checking moment specifically chosen to be after the initial assignment but before the first test? Note the excerpt is talking about proving correctness of algorithms using loop invariants.</p>\n', 'ViewCount': '162', 'Title': 'Invariant Proof of For Loops?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-11T15:25:00.483', 'LastEditDate': '2012-11-10T12:28:54.603', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4533', 'Tags': '<proof-techniques><correctness-proof><loop-invariants>', 'CreationDate': '2012-11-10T03:23:45.817', 'Id': '6595'},77_45:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the searching problem:</p>\n\n<blockquote>\n  <p>Input: A sequence of $n$ numbers $A=(a_1, a_2, \\ldots , a_n)$ and a value $v$.</p>\n  \n  <p>Output: An index $i$ such that $v = a_i$ or the special value NIL if $v$ does not appear in $A$</p>\n</blockquote>\n\n<p>Write pseudocode for linear search, which scans through the sequence, looking for $v$. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.</p>\n\n<p>The algorithm is clearly very simple to prove. However could someone prove the correctness of the algorithm using a loop invariant? Note the "three necessary properties" are:</p>\n\n<ul>\n<li><p>Initialization: It is true prior to the first iteration of the loop.</p></li>\n<li><p>Maintenance: If it is true before an iteration of the loop, it remains true before the</p></li>\n<li><p>Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.</p></li>\n</ul>\n', 'ViewCount': '436', 'Title': 'Proof of linear search?', 'LastEditorUserId': '4528', 'LastActivityDate': '2012-11-10T18:12:56.610', 'LastEditDate': '2012-11-10T07:03:19.407', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4533', 'Tags': '<proof-techniques><correctness-proof><loop-invariants>', 'CreationDate': '2012-11-10T04:23:18.037', 'Id': '6597'},77_46:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$T(n)=2T(n/2) + n\\log^2(n)$.</p>\n\n<p>If I try to substitute $m = \\log(n)$ I end up with </p>\n\n<p>$T(2^m)=2 T(2^{m-1}) + 2^m\\log^{2}(2^m)$.</p>\n\n<p>Which isn't helpful to me. Any clues?</p>\n\n<p>PS. hope this isn't too localized. I specified that the problem was a squared logarithm which should make it possible to find for others wondering about the same thing.</p>\n", 'ViewCount': '187', 'Title': 'Solving recurrence with logarithm squared $T(n)=2T(n/2) + n \\log^2n$', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T14:51:07.147', 'LastEditDate': '2012-11-22T14:51:07.147', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6834', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2826', 'Tags': '<asymptotics><proof-techniques><recurrence-relation>', 'CreationDate': '2012-11-22T09:18:57.203', 'Id': '6833'},77_47:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I would like to show that the class of Recursively Enumerable languages are closed under the shrink operation. In other words, $\\text{shrink}_a(L) = \\{\\text{shrink}_a(w)\\mid w\\in L\\}$ and where $\\text{shrink}_a(w)$ is the string formed from $w$ by replacing every maximal substring of two or more $a$\'s by a single a. For example, $\\text{shrink}_a(baaab) = bab$.</p>\n\n<p>So I was browsing around for other examples to study, and I came across the following proof for the <strong>prefix</strong> operation: <a href="http://cs.stackexchange.com/questions/1731/proving-that-recursively-enumerable-languages-are-closed-against-taking-prefixes">Proving that recursively enumerable languages are closed against taking prefixes</a> (the proof given by the user Wu Yin). I thought that this was a very cool way of proving something like this, instead of just directly building an alternate TM. I\'m curious to know, can anyone come up with a proof that is of a similar style and flavor to the one pointed above? I would be very curious to see a similar bijective proof regarding countable/uncountable sets!!</p>\n\n<p>This has reminded me that there can be many ways to prove something, so I wanted to see what kind of flavor other people\'s proofs might have to this sample problem. I find that too often, students (and myself included) get caught up in a single procedure for finding solutions to a particular type of problem and neglect to see other ways of showing the same result.</p>\n', 'ViewCount': '195', 'Title': 'Seeking Alternate Proof Regarding Closure Of Recursively Enumerable Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-28T17:38:40.397', 'LastEditDate': '2012-11-26T11:46:51.627', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '6920', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<formal-languages><computability><proof-techniques><closure-properties>', 'CreationDate': '2012-11-26T06:27:42.250', 'Id': '6907'},77_48:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>To show that a NP problem is NP-complete, we also have to show that $L \\leq_{p} L'$  , where $L$ is proven NP-complete and you have to prove $L'$ also is. The thing I am confused is how in all NP-complete problems in CLRS they just state the reduction algorithm for $L$ to convert to $L'$ is polynomial. How can one prove it's polynomial time, provided an example such a clique or ham cycle kind of problem?</p>\n", 'ViewCount': '110', 'Title': 'How to determine the polynomial runtime of an NP reduction?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-01T14:06:20.573', 'LastEditDate': '2012-12-01T14:06:20.573', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7069', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<complexity-theory><np-complete><reductions><proof-techniques>', 'CreationDate': '2012-12-01T05:03:35.287', 'Id': '7068'},77_49:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was wondering how should I proceed in order to show that the composition of (say) two one-way functions (either weak or strong or both together) is not a one-way function?</p>\n\n<p>Specifically: Say $f$ and $g$ are one-way functions (either weak or strong).\nHow do I prove that their composition $g(f(x))$ is not necessarily a one-way function?</p>\n', 'ViewCount': '403', 'Title': 'How to show composition of one way function is not such?', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:44:40.480', 'LastEditDate': '2013-03-10T00:44:40.480', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9232', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4488', 'Tags': '<proof-techniques><cryptography><one-way-functions>', 'CreationDate': '2012-12-01T10:21:02.673', 'Id': '7076'},77_50:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the argument made in <a href="http://cs.stackexchange.com/questions/6562/generalizing-the-comparison-sorting-lower-bound-proof">this question</a> based on the comparison sorting lower-bounds proof, which runs as follows. </p>\n\n<p>First, the comparison sorting lower-bounds proof was recited:</p>\n\n<ol>\n<li>For $n$ distinct numbers, there are $n!$ possible orderings.</li>\n<li>There is only one correct sorted sequence of the $n$ numbers.</li>\n<li>We are given that comparison ($&lt;$) is the only operation we have that can narrow down the $n!$ possible orderings, and each comparison has only two possible outcomes.</li>\n<li>So $\\log_2(n!)$ comparisons are required.</li>\n</ol>\n\n<p>Then, the argument was generalized:</p>\n\n<ol>\n<li>Define a space of input possibilities</li>\n<li>Define the goal space, a subset of the input space</li>\n<li>Define the amount of information that is gained at each step of the computation </li>\n<li>Calculate the information difference between the space of possibilities and the goal space and divide by the information gain per step to yield the lower bound on the number of steps.</li>\n</ol>\n\n<p>Both arguments above rely on information arguments to prove a lower bound on the number of steps.</p>\n\n<p>Question: are there proofs and/or proof strategies like the above which: </p>\n\n<ol>\n<li>prove lower bounds,</li>\n<li>define an input space,</li>\n<li>define a goal space which is a subset of the input space, and </li>\n<li>do not rely on information arguments?</li>\n</ol>\n', 'ViewCount': '72', 'Title': 'Proofs based on narrowing down sets of possibilities', 'LastActivityDate': '2012-12-12T08:10:05.657', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7352', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<proof-techniques><lower-bounds>', 'CreationDate': '2012-12-12T03:46:21.073', 'Id': '7349'},77_51:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose we have a list of unbounded integers, written in binary, and we want to write a (formal) proof that the list is sorted in ascending order.</p>\n\n<p>Such a proof might look (informally) like: "2 &lt; 3, and 3 &lt; 5, and ... and 71 &lt; 79, so the list is sorted."</p>\n\n<p>It would seem such a proof must have length $\\Omega(n)$ where $n$ is the length of the list of integers, as you could use the same kind of argument that is used to show that comparison sorting is $\\Omega(n \\log n)$; roughly, if the proof was any shorter than $n$, it would have missed one of the integers on the list.</p>\n\n<p>Is this the case, or have I missed something?  Is there a clever way to construct an asymptotically shorter proof?</p>\n\n<p><strong>Edit</strong>: As Gilles and Yuval Filmas point out below, a specific answer can only be given if we have some constraints on the language in which the formal proof is written.  For the purposes of this question, suppose that no matter what particular proof language is used, <em>the proof must be written such that it can be verified in time at most polynomial in the length of the proof</em>.  This excludes proofs of the form "for all elements of the list, ..."  (I realize this constraint may make the question more difficult than if a particular proof language was chosen, but it really is closest to what I was thinking when I asked the question.)</p>\n', 'ViewCount': '83', 'Title': 'Lower bound on size of proof that a list of integers is sorted', 'LastEditorUserId': '5049', 'LastActivityDate': '2012-12-23T04:12:52.203', 'LastEditDate': '2012-12-15T09:43:11.183', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5049', 'Tags': '<proof-techniques><lower-bounds><descriptive-complexity>', 'CreationDate': '2012-12-14T18:05:51.623', 'FavoriteCount': '1', 'Id': '7396'},77_52:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two regular languages $L_1$ and $L_2$, we define a new language </p>\n\n<p>$$L=\\{w_1w_2\\mid \\text{ there exist two words } x,y \\text{ such that } xw_1\\in L_1, w_2y\\in L2\\}$$</p>\n\n<p>How do I show that $L$ is regular with equivalence classes?</p>\n\n<p>My assignment allows the use of closure properties that all regular languages hold, but I cannot use $\\text{rank} (L)$, as in show a limit to the number of equivalence class.</p>\n\n<p>Can someone lead me in the right direction? </p>\n', 'ViewCount': '214', 'Title': 'Proving regularity via equivalence classes', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-19T05:17:59.307', 'LastEditDate': '2012-12-15T21:16:08.037', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5074', 'Tags': '<automata><regular-languages><finite-automata><proof-techniques>', 'CreationDate': '2012-12-15T20:27:22.903', 'FavoriteCount': '1', 'Id': '7419'},77_53:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp;A1B \\\\\nA \\rightarrow &amp; 0A \\mid \\varepsilon \\\\\nB \\rightarrow &amp; 0B \\mid 1B \\mid \\varepsilon \\\\\n\\end{align}\n$$</p>\n\n<p>How can I show that this grammar is unambiguous? I need to find a grammar for the same language that is ambiguous, and demonstrate it.</p>\n\n<p>I know if I was asked to prove that the language is ambigious then I should find two different parse trees for same string, but I don't know what to do.</p>\n", 'ViewCount': '848', 'Title': 'How to show that given language is unambiguous', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-30T18:31:28.237', 'LastEditDate': '2012-12-22T07:00:56.657', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7519', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5137', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><ambiguity>', 'CreationDate': '2012-12-20T00:20:48.643', 'Id': '7518'},77_54:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I try to provide a strict and mathematical rigorous proof to the following problem in Distributed Algorithms. </p>\n\n<p>Prove or make a contradiction: if to vertices $a$ and $b$ on the network $G$ are located on the distance $k$ from each other, and there are $k^2$ different paths on different edges, so it is possible to transfer $k^2$ messages from $a$ to $b$ in time $\\text{O}(k)$.</p>\n\n<p>In my opinion. it\'s not true, I will try to show why. Let\'s say we have a network as on the picture with vertices $a$ and $b$, all vertices are different and there are 3 paths. The distance from $a$ to $b$ is $k$, in the case of synchronous communication, on every $k/2$ vertices the is collision of $k^2$ messages (the number of paths). In general, it\'s possible to build a network (not like on the picture), where the worst case occurs (first outgoing messages goes on the longest path and last outgoing message on the shortest path, finally they will make collision again).</p>\n\n<p>Finally, we will get, $\\sum_{0}^{\\frac{k}{2}} k^2$ - collisions, which is greater than $\\text{O}(k)$.</p>\n\n<p><img src="http://i.stack.imgur.com/l35N0.png" alt="enter image description here"></p>\n\n<p>Does it make sense? Is it enough rigorous?</p>\n', 'ViewCount': '93', 'Title': 'Proof of message complexity on the network', 'LastActivityDate': '2012-12-25T21:22:30.883', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<proof-techniques><distributed-systems>', 'CreationDate': '2012-12-25T21:22:30.883', 'FavoriteCount': '1', 'Id': '7598'},77_55:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is an exercise in <strong>Distributed Algorithm</strong> I have some difficulties to solve. There are few ideas, however nothing useful at the time. I will appreciate any help with it.</p>\n\n<p>Graph $G$ is a $k$-tree if it\'s possible to divide all it\'s edges to $k$ trees ($k$ subgraphs without a loop). Given network $N$ every processor knows it\'s parent and it\'s children in every tree. Using algorithm for 3-coloring of an arbitrary tree (as describe in <a href="http://disco.ethz.ch/lectures/podc_allstars/lecture/chapter1.pdf" rel="nofollow">Vertex Coloring</a>) show that the given graph $G$ is $3k$-colorable in the same time complexity $O(\\log^*n)$.</p>\n\n<p><strong>Ideas</strong>: every vertex $v$ could belong to one or more trees among $k$ trees. For every particular tree vertex $v$ belongs to, vertex $v$ knows it\'s parent in this tree and it\'s children in this tree. Exercise asks to color a graph $G$ in $3k$ colors.   Running the mentioned algorithm for any particular tree we will get correct 3-colorable $k$ trees, each vertex will have $m$ different color labels, where $m$ is number of trees, vertex $v$ belongs to.</p>\n\n<p>Now the difficult part, concatenation of all $m$ color labels in one color for vertex $v$ will result in $3^k$ different colors for graph $G$.</p>\n\n<p>In general, simplification of the problem is on the picture.</p>\n\n<p><img src="http://i.stack.imgur.com/uF8tv.png" alt="enter image description here"></p>\n\n<p>Vertices $v$ and $u$ are connected by an edge (on the picture the edge belongs to the 1 tree, in principle it doesn\'t matter, we could draw a parallel edge that belongs to 2 tree), $v$ and $u$ belong to 1 tree and 2 tree. After running 3-colorability algorithm for every tree we will get the correct colorability, now the problem is to make color assignments to vertices $v$ and $u$ as vertices of the graph $G$ based on the color assignment of these vertices for 1 tree and 2 tree, and of course because $u$ and $v$ are connected by an edge in graph $G$, the colors should be different.  </p>\n', 'ViewCount': '276', 'Title': 'k-Trees Graph Coloring', 'LastActivityDate': '2013-01-03T18:56:48.330', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<algorithms><proof-techniques><distributed-systems>', 'CreationDate': '2013-01-03T18:56:48.330', 'Id': '7736'},77_56:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Continuing in the vein of two prior questions <a href="http://cs.stackexchange.com/questions/6562/generalizing-the-comparison-sorting-lower-bound-proof">(1)</a> and <a href="http://cs.stackexchange.com/questions/7349/proofs-based-on-narrowing-down-sets-of-possibilities">(2)</a>, we started with sorting, where we had</p>\n\n<ol>\n<li>a set of $n!$ input possibilities</li>\n<li>a goal space of only one element consisting of the one correct sorted sequence</li>\n</ol>\n\n<p>We then arrived at a generalized argument which I\'ll alter slightly and call <em>A</em>:</p>\n\n<ol>\n<li>Define a space of input possibilities</li>\n<li>Define the goal space, a subset of the input space</li>\n<li>Reason about constraints in order to set a lower bound</li>\n</ol>\n\n<p>Three Questions: given that there are quadratic algorithms for sorting, </p>\n\n<ol>\n<li>Can we conclude for the quadratic sorting algorithms, where we have an input space of $n!$ input possibilities and roughly $n^2$ steps, that there are $O(n!/n^2)$ possibilities removed from the search space per step on average?</li>\n<li>Let\'s say we\'re given a problem formalizable in the form of argument <em>A</em> above where the input space is exponential in terms of the size of the input, $O(2^n)$, and the problem is solvable in polynomial time, $O(n^c)$, for some constant $c$. Can we conclude there are $O(2^n/n^c)$ possibilities removed from the search space per step on average?</li>\n<li>Can we at least conclude that a $O(2^n)$ problem cannot be solved in polynomial time by removing one element from the input space per step?</li>\n</ol>\n', 'ViewCount': '58', 'Title': 'Progress of algorithms in problem spaces', 'LastActivityDate': '2013-01-04T10:38:39.383', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7753', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<proof-techniques><lower-bounds>', 'CreationDate': '2013-01-04T05:21:31.617', 'Id': '7747'},77_57:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am new to Computability Theory and find it is both amazing and confusing. Specifically, it is difficult for me to get through the undecidability of the well-known Halting Problem. </p>\n\n<blockquote>\n  <p><strong>Halting function:</strong> The Halt function takes an input a pair $&lt;\\alpha, x&gt;$ and outputs 1 if and only if the TM $M_{\\alpha}$ represented by $\\alpha$ halts on input $x$ within a finite number of steps.</p>\n</blockquote>\n\n<p>The undecidability of Halting function is proved by reduction from another undecidable function $UC$, which is defined as follows <a href="http://www.cs.duke.edu/~reif/courses/complectures/books/AB/ABbook.pdf" rel="nofollow">Book by Arora and Barak</a>.</p>\n\n<blockquote>\n  <p><strong>$UC$:</strong> For every $\\alpha \\in \\lbrace 0,1 \\rbrace^{\\ast}$, if $M_{\\alpha}(\\alpha) = 1$, then $UC(\\alpha) = 0$; otherwise (if $M_{\\alpha}(\\alpha)$ outputs a different value or enters an infinite loop), $UC(\\alpha) = 1$.</p>\n</blockquote>\n\n<p>The undecidability of $UC$ is proved by the also well-known <em>"diagonalization"</em> technique. I can understand the technique. However, I am puzzling over a more basic problem involving the definition of $UC$.</p>\n\n<blockquote>\n  <p><strong>My Problem:</strong> The definition of $UC$ is based on the value of $M_{\\alpha}(\\alpha)$. Especially, it seem to be based on <em>whether a Turing Machine halts on an input</em>. However, the latter is undecidable (Worse still, it is undecidable due to the undecidability of $UC$!). In this sense, is the $UC$ function well-defined?</p>\n</blockquote>\n\n<p>What is wrong with my opinion? How should I understand the definition of $UC$ and the relation between $UC$ and Halting Problem?</p>\n\n<p>Thank for your help.</p>\n', 'ViewCount': '126', 'Title': 'Is the undecidable function $UC$ well-defined for proving the undecidability of Halting Problem?', 'LastActivityDate': '2013-01-07T19:26:06.113', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7788', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<computability><proof-techniques><undecidability><halting-problem>', 'CreationDate': '2013-01-05T11:29:41.143', 'Id': '7785'},77_58:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I was reading a few notes on Proof by Restriction and I am confused:</p>\n\n<p>A Valid Proof by Restriction is the following:</p>\n\n<p>Directed Hamiltonian Cycle Problem is NP Complete because if we look only at <em>instances</em> of DHC where For $G=(V,E)\\quad (u,v)\\in E \\leftrightarrow (v,u) \\in E$ then it reduces to Hamiltonian Cycle which we know is NP complete. </p>\n\n<p>A <em>wrong</em> proof is the following:</p>\n\n<blockquote>\n  <p><strong>Subset Sum problem</strong><br>\n  INSTANCE: Integers $a_1, a_2,\u2026,a_n$ and integer B.</p>\n  \n  <p>QUESTION: Is there a sequence of 0\u2019s and 1\u2019s, $x_1, x_2,\u2026,x_n$ such that:\n  $$\\sum_{i=1}^n a_ix_i \\leq B$$</p>\n</blockquote>\n\n<p>is a special case of </p>\n\n<blockquote>\n  <p><strong>Real Subset Problem</strong>\n  INSTANCE: Integers $a_1, a_2,\u2026,a_n$ and integer B.</p>\n  \n  <p>QUESTION: Is there a sequence of real numbers  $x_1, x_2,\u2026,x_n$  such that:\n  $$\\sum_{i=1}^n a_ix_i \\leq B$$</p>\n</blockquote>\n\n<p>so it is NP Complete. </p>\n\n<p>My notes say that the this proof is wrong since it restricts the question and not the instances but I don't seem to understand the difference. </p>\n\n<p>Further, I can't really understand how Proof by Restriction works; for all I know I could be restricting an NP Complete problem to a trivial case which can be solved in Polynomial time. </p>\n", 'ViewCount': '180', 'Title': 'Proof by restriction: when is it valid to restrict to a special case?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-14T19:50:05.860', 'LastEditDate': '2013-01-14T19:50:05.860', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7934', 'Score': '3', 'OwnerDisplayName': 'user6422', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-complete><proof-techniques>', 'CreationDate': '2013-01-13T22:00:32.870', 'Id': '7931'},77_59:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'What are some good hints for proving non-regularity with the pumping lemma?', 'LastEditDate': '2013-01-16T08:36:49.623', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6439', 'FavoriteCount': '2', 'Body': "<p>My CS Theory Professor said that when proving that a language is not regular by the Pumping Lemma, that there are some 'tricks' for solving languages more complicated that something like $L = \\{a^{n} b^{n}\\mid n \\in\\mathbb{N}\\}$. Although I know that these come with practice, I wondered if this community would have some input on the matter?</p>\n\n<p>If you don't quite know what I am asking, think to calculus, when your professor used something that HE knew would get you from point a to point b that if YOU don't know, you cannot solve the problem. </p>\n", 'Tags': '<formal-languages><proof-techniques><pumping-lemma>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-16T08:36:49.623', 'CommentCount': '2', 'AcceptedAnswerId': '8958', 'CreationDate': '2013-01-16T04:19:34.293', 'Id': '8957'},77_60:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question follows on previous questions <a href="http://cs.stackexchange.com/questions/6562/generalizing-the-comparison-sorting-lower-bound-proof">(1)</a>, <a href="http://cs.stackexchange.com/questions/7349/proofs-based-on-narrowing-down-sets-of-possibilities">(2)</a>, where we define an initial space of possibilities and reason about how a solution is chosen from that.</p>\n\n<p>Consider a problem P where we are given:</p>\n\n<ol>\n<li>the initial space of possibilities is exponential in the size of the input,</li>\n<li>the search space decreases monotonically as we read the input, </li>\n<li>for the algorithm that correctly computes P and has <a href="http://courses.csail.mit.edu/6.841/spring09/scribe/lect16.pdf" rel="nofollow">the minimum worst-case performance</a>, the search space is still exponential in the size of the input even after the final input is read.</li>\n</ol>\n\n<p>Can we conclude that P requires exponential time? If not, what would a polynomial-time counterexample look like?</p>\n', 'ViewCount': '110', 'Title': 'Search spaces and computation time', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T15:13:27.137', 'LastEditDate': '2013-01-18T15:13:27.137', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<complexity-theory><proof-techniques><lower-bounds>', 'CreationDate': '2013-01-18T06:25:20.673', 'Id': '9013'},77_61:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '267', 'Title': 'Questions about amortised analysis', 'LastEditDate': '2013-01-19T18:04:21.067', 'AnswerCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '5053', 'FavoriteCount': '3', 'Body': '<p>As a preperation of an exam about algorithms and complexity, I am currently solving old exercises. One concept I have already been struggling with when I encountered it for the first time is the concept of amortised analysis. What is amortised analysis and how to do it? In our lecture notes, it is stated that "amortised analysis gives bounds for the "average time" needed for certain operation and it can also give a bound for the worst case". That sounds really useful but when it comes to examples, I have no idea what I have to do and even after having read the sample solution, I have no idea what they are doing.</p>\n\n<blockquote>\n  <p>Let\'s add up 1 in base 2, i.e. 0, 1, 10, 11, 100, 101, 110, 111, 1000, ... Using amortised analysis, show that in each step only amortised constantly many bits need to be changed.</p>\n</blockquote>\n\n<p>(the exercise originally is in German, so I apologise for my maybe not perfectly accurate translation)</p>\n\n<p>Now the standard solution first defines $\\phi(i) := c \\cdot \\# \\{\\text{1-bits in the binary representation}\\}$ for some constant $c &gt; 0$. I think this is what is called the potential function which somehow corresponds to the excessive units of time (but I have no idea why I would come up with this particular definition). Assuming that we have to change $m$ bits in the $i$-th step. Such a step always is of the form</p>\n\n<p>$$\\dots \\underbrace{0 1 \\dots 1}_m \\to \\dots \\underbrace{1 0 \\dots 0}_m.$$</p>\n\n<p>This statement is understandable to me, however again I fail to see the motivation behind it. Then, out of nowhere, they come up with what they call an "estimate"</p>\n\n<p>$$a(i) = m + c(\\phi(i) - \\phi(i-1)) = m + c(-m + 2)$$</p>\n\n<p>and they state that for $c=1$, we get $a(i)=2$ which is what we had to show.</p>\n\n<p>What just happened? What is $a(i)$? Why can we choose $c=1$? In general, if I have to show that in each step only amortised constantly many "units of time" are needed, does that mean that I have to show that $a(i)$ is constant?</p>\n\n<p>There are a few other exercises regarding amortised analysis and I don\'t understand them either. I thought if someone could help me out with this one, I could give the other exercises another try and maybe that\'ll help me really grasp the concept.</p>\n\n<p>Thanks a lot in advance for any help.</p>\n', 'Tags': '<algorithm-analysis><proof-techniques><amortized-analysis>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T09:05:29.557', 'CommentCount': '2', 'AcceptedAnswerId': '9023', 'CreationDate': '2013-01-18T10:20:25.633', 'Id': '9021'},77_62:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Based on the definition of a <a href="http://mathworld.wolfram.com/Multiset.html" rel="nofollow">multiset</a> and the information in this <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.145.8728" rel="nofollow">paper</a>, why do we use multisets in proving the termination of a program?\nIs not the well-founded order enough?</p>\n', 'ViewCount': '126', 'Title': 'The use of multiset ordering in proving termination', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T10:55:18.597', 'LastEditDate': '2013-01-21T10:55:18.597', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1584', 'Tags': '<algorithm-analysis><proof-techniques><correctness-proof><sets>', 'CreationDate': '2013-01-19T23:46:45.707', 'Id': '9046'},77_63:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a regular language $L$, then it is easy to prove that there is a constant $N$ such that is $\\sigma \\in L$, with $\\lvert \\sigma \\rvert \\ge N$ there exist strings $\\alpha$, $\\beta$ and $\\gamma$ such that $\\lvert \\alpha \\beta \\rvert \\le N$ and $\\lvert \\beta \\rvert \\ne \\epsilon$, and for all $k$ it is $\\alpha \\beta^k \\gamma \\in L$. It is widely stated that the converse isn\'t true, but I haven\'t seen any clear example. Any suggestions? Clearly the proof that the offending language isn\'t regular has to use stronger methods than the typical "doesn\'t satisfy the pumping lemma". I\'d be interested in simple examples, to present in introductory formal languages classes.</p>\n', 'ViewCount': '406', 'Title': "Languages that satisfy the pumping lemma but aren't regular?", 'LastActivityDate': '2013-01-27T14:39:52.710', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9182', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6447', 'Tags': '<formal-languages><proof-techniques>', 'CreationDate': '2013-01-27T00:42:15.890', 'FavoriteCount': '1', 'Id': '9181'},77_64:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '266', 'Title': 'Proof of the Stable Matching Problem', 'LastEditDate': '2013-02-06T04:32:07.017', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6577', 'FavoriteCount': '1', 'Body': u'<p>Looking at the document <em>Fundamentals of Computing Series</em>, <a href="http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15251-f10/Site/Materials/Lectures/Lecture21/lecture21.pdf" rel="nofollow">The Stable Marriage Problem</a>.</p>\n\n<p>Theorem 1.2.3 - page 12:</p>\n\n<blockquote>\n  <p>In a man-optimal version of stable matching, each woman has worst\n  partner that she can have in any stable matching.</p>\n</blockquote>\n\n<p>Proof:</p>\n\n<blockquote>\n  <p>Suppose not. Let $M_0$ be the man-optimal stable matching, and\n  suppose there is a stable matching $M\u2019$ and a woman $w$ such\n  that $w$ prefers $m = p_{M_0}(w)$ to $m\' = p_{M\'}(w)$ . But\n  then $(m,w)$ blocks $M\'$ unless $m$ prefers $p_{M\'}(m)$ to \n  $w = p_{M_0}(m)$, in contradiction of the fact that $m$ has no\n  stable partner better than his partner in $M_0$.</p>\n</blockquote>\n\n<p>I\'m having trouble visualizing the definition of the problem and the proof (what is the contradiction?).</p>\n\n<p>First, what is the question implying?  From what I read and the fact that in most stable matching examples, all the women do not end up with the completely last person on their list ... So I\'m a bit confused.</p>\n\n<p>In the proof, here is what I am getting: in $M\'$ we suppose $w$ prefers $m$ to $m\'$.  But then if there is a stable matching containing $(m,w)$ this would leave $w$ with her worst partner and that is a contradiction.  Is this correct?</p>\n\n<p>In addition, if $m$ did prefer $w\'$ it would contradict that it is not his first pick ?</p>\n\n<p>I\'m new to computer science concepts so any help is appreciated.</p>\n', 'Tags': '<algorithms><proof-techniques><matching>', 'LastEditorUserId': '6577', 'LastActivityDate': '2013-02-06T04:32:07.017', 'CommentCount': '0', 'AcceptedAnswerId': '9197', 'CreationDate': '2013-01-27T06:02:59.647', 'Id': '9196'},77_65:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '44', 'Title': 'How i can use Mathematical induction to prove CFG production?', 'LastEditDate': '2013-01-28T10:23:01.200', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'M.B', 'PostTypeId': '1', 'OwnerUserId': '6594', 'Body': '<p>If I have production $G_n$</p>\n\n<blockquote>\n  <p>$S \\rightarrow A_i b_i \\quad$ for $1 \\le i \\le n$</p>\n  \n  <p>$A_i \\rightarrow a_j A_i \\mid a_j\\quad$   for $1 \\le i$ and $i \\ne j$</p>\n</blockquote>\n\n<ol>\n<li>Prove $G_n$ is sub-productions from $2n^2 - n$</li>\n<li>Prove $G_n$ is $LR(0)$ production from $2^n + n^2 + n$</li>\n</ol>\n', 'ClosedDate': '2013-04-14T19:11:20.580', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T10:23:01.200', 'CommentCount': '5', 'CreationDate': '2013-01-27T17:06:45.810', 'Id': '9230'},77_66:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m having a real hard time solving recurrences using the substitution method.</p>\n\n<p>Show that: $T(n) = T(n/2) + 1$ is $O(\\lg n)$</p>\n\n<p>I thought this to be relatively easy:</p>\n\n<p>We have to show that $T(n) \\leq c \\lg n$</p>\n\n<p>Substitution gives me:</p>\n\n<p>$\\qquad\n  \\begin{align}\n    T(n) &amp;\\leq c \\lg(n/2) + 1 \\\\\n         &amp;= c \\lg n - c \\lg 2 + 1 \\\\\n         &amp;= c \\lg n - c + 1 \\\\\n         &amp;\\leq  c \\lg n\n\\end{align}$ </p>\n\n<p>for every c.</p>\n\n<p>I was under the impression this was it, but when I was looking for an answer, I came around a <a href="http://classes.soe.ucsc.edu/cmps101/Spring11/hw/hw2sol.pdf" rel="nofollow">much more elaborate answer on the web</a>, given  involving subtracting a constant. I don\'t get why that\'s needed, I thought I had shown what was needed.</p>\n\n<p>Any help would be greatly appreciate, starting Monday I\'m enrolled in an algorithms class and I don\'t want to get behind!</p>\n\n<p>We are using the CLRS book (surprise) and though I appreciate the amount of information in it, I\'d rather have some more resources. I\'ve really enjoyed a datastructures class and I really think I can enjoy this as well, but more resources would be very much appreciated.</p>\n', 'ViewCount': '100', 'ClosedDate': '2013-08-07T08:13:19.483', 'Title': 'Solving a simple recurrence', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-07T06:14:56.363', 'LastEditDate': '2013-01-30T20:56:16.523', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5391', 'Tags': '<reference-request><proof-techniques><recurrence-relation>', 'CreationDate': '2013-01-30T20:13:17.710', 'Id': '9329'},77_67:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '161', 'Title': 'Convergence of Simulated Annealing Based Algorithms', 'LastEditDate': '2013-01-31T14:01:23.310', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6550', 'FavoriteCount': '2', 'Body': "<p>I designed a simulated annealing-based optimization algorithm. My simulation shows that it converge fast. I am looking for some sort of proof to show that simulation annealing-based algorithm converge fast (based on satisfying some properties) to global/local optimal point and doesn't oscillate in the optimal points (or any related fast about its stability). Are there any useful literature about it?</p>\n", 'Tags': '<algorithms><reference-request><proof-techniques><optimization>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T04:03:50.740', 'CommentCount': '7', 'AcceptedAnswerId': '9400', 'CreationDate': '2013-01-31T00:36:58.170', 'Id': '9340'},77_68:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The Master theorem is a beautiful tool for <a href="http://cs.stackexchange.com/a/2823/98">solving certain kinds of recurrences</a>. However, we often gloss over an integral part when applying it. For example, during the analysis of Mergesort we happily go from</p>\n\n<p>$\\qquad T(n) = T\\left(\\left\\lfloor \\frac{n}{2} \\right\\rfloor\\right) + T\\left(\\left\\lceil \\frac{n}{2} \\right\\rceil\\right) + f(n)$</p>\n\n<p>to </p>\n\n<p>$\\qquad T\'(n) = 2 T\'\\left(\\frac{n}{2}\\right) + f(n)$</p>\n\n<p>considering only $n=2^k$. We assure ourselved that this step is valid -- that is, $T \\in \\Theta(T\')$ -- because $T$ behaves "nicely". In general, we assume $n=b^k$ for $b$ the common denominator.</p>\n\n<p>It is easy to construct recurrences which do not allow this simplification by using vicious $f$. For example, above recurrence for $T\\,$/$\\,T\'$ with</p>\n\n<p>$\\qquad f(n) = \\begin{cases}\n                 1 &amp;, n=2^k \\\\\n                 n &amp;, \\text{else}\n               \\end{cases}$</p>\n\n<p>will yield $\\Theta(n)$ by using the Master theorem in the usual way, but there is clearly a subsequence that grows like $\\Theta(n \\log n)$. See <a href="http://cs.stackexchange.com/a/4980/98">here</a> for another, more contrived example.</p>\n\n<p>How can we make this "nicely" rigorous? I am quite certain that monotonicity is sufficient, but not even the simple Mergesort recurrence is monotone; <a href="http://cs.stackexchange.com/a/2390/98">there is a periodic component</a> (which is dominated asymptotically). Is it enough to investigate $f$, and what are necessary and sufficient conditions on $f$ that ensure the Master theorem works?</p>\n', 'ViewCount': '252', 'Title': 'Rigorous proof for validity of assumption $n=b^k$ when using the Master theorem', 'LastActivityDate': '2013-02-11T00:43:01.050', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '9654', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><proof-techniques><recurrence-relation><master-theorem>', 'CreationDate': '2013-02-07T07:35:33.753', 'FavoriteCount': '3', 'Id': '9569'},77_69:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am asking for help to explain some crucial points of the central lemma and it\'s proof of famous paper <a href="http://www.cs.princeton.edu/courses/archive/fall05/cos528/handouts/NP_is_as.pdf" rel="nofollow">NP is as easy as detecting unique solutions by L.Valiant and V.Vazirani</a>.</p>\n\n<p>The proof can be found in the section <strong>2. The proof</strong> of the paper. </p>\n\n<p><strong>The idea of the lemma</strong>: lemma shows that there is a randomized polynomial - time reduction from SAT to Unique-SAT. Lemma uses GF[2] inner product with polynomial few {0,1} vectors.</p>\n\n<p><strong>Problem in general</strong>: I have some difficulties in understanding the definition of the lemma and in usage of GF[2] for proving the lemma. </p>\n\n<p><strong>Specific questions:</strong></p>\n\n<p>Following is the number of citations from the paper with relevant question to the citation. </p>\n\n<blockquote>\n  <p><strong>Lemma 2.1.</strong> If $f$ is any CNF formula in $x_1,...,x_n$ and $w_1,...,w_k \\in \\{0,1\\}^n$, </p>\n</blockquote>\n\n<p>Q:I think $x_1,...,x_n$ are literals, but what are $w_1,..,w_k$? Are they literals or something else? If yes, why to distinct between them and $x$ literals.</p>\n\n<p>A:$w_1,..,w_k$ are the truth assignments. </p>\n\n<blockquote>\n  <p>then one can construct in linear time a formula $f\'_k$ whose solution $v$ satisfy $f$ and the equations $v\\cdot  w_1=...=v\\cdot w_k=0$. Furthermore, one can construt a polynomial-size CNF formula $f_k$ in variables $x_1,...,x_n,y_1,...y_m$,</p>\n</blockquote>\n\n<p>Q: $x_1,...x_n$ are unknown literals, how can we construct $f_k$ with unknown literals and where $y_1,...,y_m$ came from?</p>\n\n<blockquote>\n  <p>for some $m$ such that there is a bijection between solutions of $f_k$ and $f\'_k$, defined be equality on the $x_1,...,x_n$ values.</p>\n  \n  <p><strong>Proof</strong>: It is sufficient to show the lemma for $k=1$. Then, $f\'_k$ is</p>\n  \n  <p>$f \\wedge (x_{i_1} \\bigoplus x_{i_2} \\bigoplus ... \\bigoplus x_{i_j} \\bigoplus 1)$</p>\n</blockquote>\n\n<p>Q: this is the most vague point, how do we come to the such construction of $f\'_1$ and why showing only $f\'_1$ sufficient for the proof.</p>\n\n<p>I hope you forgive me for my naivety. I will appreciate any hint in accordance to the above questions.</p>\n', 'ViewCount': '106', 'Title': 'Proof of SAT is randomly reducible to UNIQUE-SAT', 'LastEditorUserId': '1379', 'LastActivityDate': '2013-02-14T17:47:28.463', 'LastEditDate': '2013-02-14T17:47:28.463', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<complexity-theory><reductions><proof-techniques>', 'CreationDate': '2013-02-14T09:57:05.487', 'Id': '9766'},77_70:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have as an assignment question to show that $QuadSat=\\{\\langle\\phi\\rangle\\mid\\phi$ is a satisfiable 3CNF formula with at least 4 satisfying assignments$\\}$ is $\\sf NP$-Complete.</p>\n\n<p>My solution is as follows, which is pretty much copied almost 100% from a textbook example with only an extra requirement for satisfiablity at the end...</p>\n\n<blockquote>\n  <p>$$QuadSat\\leq_{p} Clique$$\n  Let $\\phi$ be a formula with k clauses such as\n  $$\\phi=\\bigwedge_{1}^{k}(a_k\\vee b_k\\vee c_k)$$\n  The reduction $f$ generates the strong $\\langle G,k\\rangle$, where $G$ is an undirected graph defined as follows:</p>\n  \n  <p>The nodes in $G$ are organized into $k$ groups of three nodes each called the \\textbf{triples}, $t_1, \\dots, t_k$. Each triple corresponds to one of the clauses in $\\phi$, and each node in a triple corresponds to a literal in the associated clause. Label each node of $G$ with its corresponding literal in $\\phi$.</p>\n  \n  <p>The edges of $G$ connect all but two types of pairs of nodes in $G$: No edge is present between nodes in the same triple, and no edge is present between two nodes with contradictory labels. $QuadSat$ is satisfiable if and only if the resulting graph $G$ contains four or more $k$-$cliques$. Each unique $k$-$clique$ in $G$ represents a set of satisfying assignments to $QuadSat$.</p>\n  \n  <p>The reduction runs in polynomial time, because the construction of the graph is a polynomial function; one pass through all the triples to create all the vertices for $V$, and one pass through the same triples to create the edges.</p>\n</blockquote>\n\n<p>I feel like my explanation as to why my reduction is polynomial in time is severely weak, possibly bordering on wrong. How can I explain this better?</p>\n\n<p>And something else: I think this only proves that QuadSat is in NP, but not necessarily NP Complete. How can I prove this?</p>\n', 'ViewCount': '117', 'Title': 'How do I explain that a polynomial time reduction is in fact polynomial time?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T14:39:23.387', 'LastEditDate': '2013-02-16T14:39:23.387', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9812', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><np-complete><reductions><proof-techniques>', 'CreationDate': '2013-02-15T13:50:38.367', 'Id': '9806'},77_71:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '392', 'Title': 'How to apply the pumping lemma to $\\{0^m 1^n \\mid 2n \\leq m \\leq 3n, m,n \\geq 0 \\}$?', 'LastEditDate': '2013-02-25T18:08:15.837', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'FavoriteCount': '1', 'Body': "<p>I'm not really sure the how you would go about proving this language isn't regular with the pumping lemma:</p>\n\n<p>$L= \\{0^m 1^n | 2n \\leq m \\leq 3n, m,n \\geq 0   \\}$</p>\n\n<p>Does this indicate that $S = 2$, so we start by by using a string $\\geq 2$?</p>\n", 'Tags': '<regular-languages><proof-techniques><pumping-lemma>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-25T18:08:15.837', 'CommentCount': '10', 'AcceptedAnswerId': '10072', 'CreationDate': '2013-02-21T19:38:51.083', 'Id': '10019'},77_72:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $T$ be a Turing machine whose accepted language is $L(T)$. Let $X$ be another language. How do you approach a proof like $L(T)\\subseteq X?$</p>\n', 'ViewCount': '262', 'Title': 'Proof-sketch on the language accepted by a Turing machine', 'LastEditorUserId': '6989', 'LastActivityDate': '2013-02-23T16:47:28.233', 'LastEditDate': '2013-02-22T22:28:28.367', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10032', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6989', 'Tags': '<formal-languages><turing-machines><proof-techniques>', 'CreationDate': '2013-02-22T22:04:26.177', 'Id': '10031'},77_73:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there a general method to solve the recurrence of the form:</p>\n\n<p>$T(n) = T(n-n^c) + T(n^c) + f(n)$</p>\n\n<p>for $c &lt; 1$, or more generally</p>\n\n<p>$T(n) = T(n-g(n)) + T(r(n)) + f(n)$</p>\n\n<p>where $g(n),r(n)$ are some sub-linear functions of $n$.</p>\n\n<p><strong>Update</strong>: I have gone through the links the provided below and also sifted through all the recurrence relations in <a href="http://www.cs.illinois.edu/class/fa10/cs573/notes/99-recurrences.pdf">Jeff Erickson\'s notes</a>. This form of the recurrence is not discussed anywhere. Akkra-Bazi method applies only when the split is fractional. Any poignant reference will be apprieciated.</p>\n', 'ViewCount': '146', 'Title': 'Solving divide & conquer reccurences if the split-ratio depends on $n$', 'LastEditorUserId': '5195', 'LastActivityDate': '2013-02-28T04:29:50.800', 'LastEditDate': '2013-02-28T04:29:50.800', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '5195', 'Tags': '<proof-techniques><recurrence-relation>', 'CreationDate': '2013-02-25T16:24:13.697', 'FavoriteCount': '2', 'Id': '10088'},77_74:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I currently have a system that has <code>{f(a) = b, f(f(x)) = x}</code> (part of an <a href="http://folk.uio.no/peterol/INF3230V13/Oppgaver/midterm06.pdf" rel="nofollow">exam question</a> - look at page 5 - exercise 1).</p>\n\n<p>To start off with proving non-confluency, I am thinking along these lines:</p>\n\n<pre><code>f(f(x)) and f(a) can be unified by using {a -&gt; f(x)}. \n</code></pre>\n\n<p>Then we can rewrite:</p>\n\n<pre><code>f(f(x)) = x                 [eq.1]\nf(f(x)) = b                 [eq.2]\n</code></pre>\n\n<p>The above two cannot be reduced any further, and do not have any common ancestor or successor. Therefore the system is not confluent.</p>\n\n<p>To make this confluent, we can add a third equation to the system:</p>\n\n<pre><code>x = b\n</code></pre>\n\n<p>This way, the equation will both be confluent and terminate. Another alternative would be:</p>\n\n<pre><code>f(x) = b\n</code></pre>\n\n<p>Is there anything I have missed? Or is this pretty much the gist of it?</p>\n', 'ViewCount': '73', 'Title': 'Proving non-confluency and adding an equation to make it confluent and terminating', 'LastActivityDate': '2013-07-15T16:03:03.313', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10108', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6867', 'Tags': '<logic><proof-techniques><semantics><term-rewriting>', 'CreationDate': '2013-02-25T21:26:12.353', 'Id': '10096'},77_75:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was going through construction proofs for closure of regular languages under union, star and concatenation operation in the book: "<a href="http://rads.stackoverflow.com/amzn/click/053494728X" rel="nofollow">Introduction to Theory of Computation</a>" by Michael Sipser.</p>\n\n<p>I have doubts regarding how he wrote the transition function. </p>\n\n<p><img src="http://i.stack.imgur.com/R7KhO.jpg" alt="enter image description here"></p>\n\n<p>When $Q \\in F_1$ and $a=\\epsilon$ he wrote $\\delta_1(q,a) \\cup \\{q_2\\}$. I couldn\'t understand why its so. When the input is epsilon, the state moves to $q_2$ and what is the need for writing that $\\delta_1(q,a)$</p>\n\n<p>Also if that is so, the $A^*$ example he wrote for the transition function $\\{q_1\\}$ only  when $q=q_0$ and $a=\\epsilon$</p>\n', 'ViewCount': '171', 'Title': 'Closure of regular Language - Transition Function : Sipser Proof', 'LastEditorUserId': '947', 'LastActivityDate': '2013-04-27T13:09:00.637', 'LastEditDate': '2013-02-26T12:31:34.827', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><proof-techniques><finite-automata><nondeterminism>', 'CreationDate': '2013-02-26T11:47:09.320', 'Id': '10117'},77_76:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am studying MIT OCW lecture notes but they do not have solutions for the following problem. </p>\n\n<p><strong>Directed Acyclic Tournaments</strong></p>\n\n<p>In a round-robin tournament, every two distinct players play against each other\njust once. For a round-robin tournament with no tied games, a record of who beat\nwhom can be described with a tournament digraph, where the vertices correspond\nto players and there is an edge $x \\rightarrow y$ iff $x$ beat $y$ in their game.</p>\n\n<p>A <em>ranking</em> is a path that includes all the players. So in a ranking, each player won\nthe game against the next lowest ranked player, but may very well have lost their\ngames against much lower ranked players \u2014whoever does the ranking may have a\nlot of room to play favorites.</p>\n\n<ol>\n<li>Give an example of a tournament digraph with more than one ranking.</li>\n<li>Prove that if a tournament digraph is a DAG, then it has at most one ranking.</li>\n<li>Prove that every finite tournament digraph has a ranking.</li>\n<li>Prove that the greater-than relation, $&gt;$, on the rational numbers,\n$Q$, is a DAG and a tournament graph that has no ranking.</li>\n</ol>\n\n<p>I got stuck at  questions 2, 3, and 4. I have no idea how to solve it. I tried induction on b without a luck but still induction does not even help for infinite DAG cases.</p>\n', 'ViewCount': '357', 'Title': 'Acyclic Tournament Digraphs and Hamiltonian Paths', 'LastEditorUserId': '19', 'LastActivityDate': '2013-03-10T16:51:05.333', 'LastEditDate': '2013-03-10T00:07:24.233', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7208', 'Tags': '<graph-theory><proof-techniques>', 'CreationDate': '2013-03-09T21:42:28.243', 'Id': '10410'},77_77:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to calculate the amortized cost of a dynamic array, that\'s size becomes 4 times the size when the array is filled. (when you re-size, you create a new one and copy the elements there).</p>\n\n<p><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-13-amortized-algorithms-table-doubling-potential-method/lec13.pdf" rel="nofollow">Here</a> is what I am reading from. (starts at pg. 30)\nThis example has the array doubling when it is filled.</p>\n\n<p>This is my potential function analysis so far:\nBut in the end I am getting 7-2i, I don\'t think it can be like that. I think the i\'s should cancel out.</p>\n\n<p>Does anyone know whats wrong?</p>\n\n<p>Potential of the array after the $i^{th}$ insertion is $\\Phi(D_i) = 4i - 4^{\\left\\lceil \\log_{4}i\\right\\rceil}$.</p>\n\n<p>Assume $4^{\\left\\lceil \\log_{4}0\\right\\rceil} = 0$.</p>\n\n<p>The amortized cost of the $i^{th}$ insertion is:</p>\n\n<p>$\\^c_i = c_i + \\Phi(D_i)-\\Phi(D_{i-1})$</p>\n\n<p>$~~~= \\{ i$ if $i-1$ is an exact power of $4$</p>\n\n<p>$~~~~~~~\\{ 1$ otherwise</p>\n\n<p>$~~~~~~~+ (4i-4^{\\left\\lceil \\log_{4}i\\right\\rceil})-(4(i-1)-4^{\\left\\lceil \\log_{4}\n(i-1)\\right\\rceil})$</p>\n\n<p>$~~~= \\{ i$ if $i-1$ is an exact power of $4$</p>\n\n<p>$~~~~~~~\\{ 1$ otherwise</p>\n\n<p>$~~~~~~~+ 4-4^{\\left\\lceil \\log_{4}i\\right\\rceil}+4^{\\left\\lceil \\log_{4}(i-1)\\right\\rceil}$</p>\n\n<p>Case 1 ($i-1$ is an exact power of $4$):</p>\n\n<p>$\\^c_i = i + 4-4^{\\left\\lceil \\log_{4}i\\right\\rceil}+4^{\\left\\lceil \\log_{4}(i-1)\\right\\rceil}$</p>\n\n<p>$~~~= i + 4-4(i-1)+(i-1)$</p>\n\n<p>$~~~= i + 4-4i+4+i-1$</p>\n\n<p>$~~~= 7-2i$</p>\n', 'ViewCount': '25', 'ClosedDate': '2013-03-12T10:25:30.603', 'Title': 'Potential function in amortized analysis', 'LastActivityDate': '2013-03-12T02:25:07.893', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<algorithms><algorithm-analysis><proof-techniques><amortized-analysis>', 'CreationDate': '2013-03-12T02:25:07.893', 'Id': '10463'},77_78:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '368', 'Title': 'How to prove NP-hardness of a longest-path problem?', 'LastEditDate': '2013-11-13T17:56:10.210', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7168', 'FavoriteCount': '1', 'Body': "<p>I have this question:</p>\n\n<pre><code>Input: \nG(V, E) = an undirected graph, V={v1, v2, ..., vn} (V = set of nodes, E = set of edges)\nwhere there is a path connecting from v1 to vn.\n\nQuestion: \nWhat is the maximum number of nodes you can visit when starting from v1 and ending at vn. \n(including v1 and vn) \nEach node can only be visited at most once.\n</code></pre>\n\n<p>I want to prove that this is NP-hard by reducing it from a known NP-complete problem, such as undirected Hamiltonian path or subset-sum.</p>\n\n<p>However I don't know exactly how to do this and this is where I need help.</p>\n\n<p>Can anyone help please?</p>\n", 'Tags': '<complexity-theory><reductions><proof-techniques><np-hard>', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-13T17:56:10.210', 'CommentCount': '1', 'AcceptedAnswerId': '10734', 'CreationDate': '2013-03-24T03:02:15.400', 'Id': '10732'},77_79:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '419', 'Title': 'A pumping lemma for deterministic context-free languages?', 'LastEditDate': '2013-04-12T23:06:52.350', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2131', 'FavoriteCount': '1', 'Body': "<p>The pumping lemma for regular languages can be used to prove that certain languages are not regular, and the pumping lemma for context-free languages (along with Ogden's lemma) can be used to prove that certain languages are not context-free.</p>\n\n<p>Is there a pumping lemma for <em>deterministic</em> context-free languages?  That is, is there a lemma akin to the pumping lemma that can be used to show that a language is not a DCFL?  I'm curious because almost all of the proof techniques I know to show that a language is not a DCFL are really complicated, and I was hoping that there was an easier technique.</p>\n", 'Tags': '<context-free><proof-techniques><pumping-lemma>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T23:06:52.350', 'CommentCount': '3', 'AcceptedAnswerId': '11274', 'CreationDate': '2013-04-02T15:24:14.170', 'Id': '10974'},77_80:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1040', 'Title': 'How to show that a function is not computable?', 'LastEditDate': '2013-06-06T16:06:21.617', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '5', 'Body': "<p>I know that there exist a Turing Machine, if a function is computable. Then how to show that the function is <em>not</em> computable or there aren't any Turing Machine for that. Is there anything like a Pumping lemma?</p>\n", 'Tags': '<computability><proof-techniques><undecidability><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-08-07T07:04:22.880', 'CommentCount': '4', 'AcceptedAnswerId': '11289', 'CreationDate': '2013-04-10T02:38:54.367', 'Id': '11181'},77_81:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In computability and complexity theory (and maybe other fields), reductions are ubiquitous. There are many kinds, but the principle remains the same: show that one problem $L_1$ is at least as hard as some other problem $L_2$ by mapping instances from $L_2$ to solution-equivalent ones in $L_1$. Essentially, we show that any solver for $L_1$ can also solve $L_2$ if we allow it to use the reduction function as preprocessor.</p>\n\n<p>I have performed my share of reductions over the years, and something keeps bugging me. While every new reduction requires a (more or less) creative construction, the task can feel repetitive. Is there a pool of canonical methods?</p>\n\n<p>What are techniques, patterns and tricks one can regularly employ for constructing reduction functions?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '548', 'LastEditorDisplayName': 'user742', 'Title': 'What are common techniques for reducing problems to each other?', 'LastActivityDate': '2014-01-17T18:09:43.470', 'LastEditDate': '2013-05-15T10:15:37.360', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><computability><reductions><proof-techniques><reference-question>', 'CreationDate': '2013-04-10T21:31:03.203', 'FavoriteCount': '10', 'Id': '11209'},77_82:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Specifying formal languages by giving formal grammars is a frequent task: we need grammars not only to describe languages, but also to parse them, or even <a href="http://scholar.google.com/scholar?q=secondary%20structure%20prediction%20stochastic%20grammars" rel="nofollow">do proper science</a>. In all cases, it is important that the grammar at hand is <em>correct</em>, that is generates exactly the desired words.</p>\n\n<p>We can often argue on a high-level why the grammar is an adequate representation of the desired language, omitting a formal proof. But what if we are in doubt or need a formal proof for some reason? What are techniques we can apply?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '417', 'Title': 'How to show that L = L(G)?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T13:55:49.570', 'LastEditDate': '2013-06-06T13:55:49.570', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<formal-languages><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-04-14T19:02:14.270', 'Id': '11315'},77_83:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For the following question:</p>\n\n<p>If B is an element of PSPACE and A is an element of PSPACE-Complete, and A polynomial reduces to B, then B is an element of PSPACE-Complete.</p>\n\n<p>I am trying to prove this, but I don't understand how to get started. Can anyone help please?</p>\n", 'ViewCount': '45', 'Title': 'Showing transitivity of PSPACE?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T09:10:18.867', 'LastEditDate': '2013-04-23T09:10:18.867', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><reductions><proof-techniques><space-complexity>', 'CreationDate': '2013-04-23T02:15:09.323', 'Id': '11506'},77_84:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '173', 'Title': 'Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular', 'LastEditDate': '2013-04-30T15:54:36.220', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7492', 'FavoriteCount': '1', 'Body': "<p>Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular.</p>\n\n<p>These are the things that I would use to start.</p>\n\n<ul>\n<li>As $L_1L_2$ is regular, then the homomorphism $h(L_1L_2)$ is regular.</li>\n<li>Let $h(L_1) = L_2$ and $h(L_2) = L_1$, then $h(L_1L_2) = L_2L_1$ is regular (we already know that) or $h(L_2) = \\epsilon$ and we get $L_1$</li>\n<li>By reflexing, $L_1L_2 = (L_2L_1)^{R}$, same result.</li>\n</ul>\n\n<p>But i don't know how to, for example, intersect something that gives me $L_1$ in order to preserve closure and finally $L_1$ be regular.</p>\n\n<p>Any help?</p>\n", 'Tags': '<regular-languages><finite-automata><proof-techniques><closure-properties>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-30T15:54:36.220', 'CommentCount': '0', 'AcceptedAnswerId': '11596', 'CreationDate': '2013-04-27T03:06:35.000', 'Id': '11592'},77_85:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Hi I've read this lemma in my book:</p>\n\n<blockquote>\n  <p><strong>Lemma 2.1.</strong> Let $p(n) = \\sum_{i=0}^{k} a_in^i$ denote any polynomial and assume $a_k &gt; 0$. Then $p(n) \\in \\Theta(n^k)$</p>\n  \n  <p><strong>Proof.</strong> It suffices to show that $p(n) \\in O(n^k)$  and $p(n) \\in \\Omega(n^k)$. First observe that for $n &gt; 0$,\n  $$p(n) \\leq \\sum_{i=0}^{k} |a_i|n^i \\leq n^k \\sum_{i=0}^{k}|a_i|,$$\n  and hence $p(n) \\leq (\\sum_{i=0}^{k}|a_i|)n^k$ for all positive $n$. Thus $p(n) \\in O(n^k)$.</p>\n  \n  <p>Let $A = \\sum_{i=0}^{k-1}|a_i|$. For positive $n$ we have\n  $$p(n) \\geq a_kn^k -An^{k-1} = \\frac{a_k}{2}n^k + n^{k-1}(\\frac{a_k}{2}n - A)$$\n  and hence $p(n) \\geq (a_k/2)n^k$ for $n &gt; \\frac{2A}{a^k}$. We choose $c=a_k/2$ and $n_0 = 2A/a^k$ in the definition of $\\Omega(n^k)$, and obtain $p(n) \\in \\Omega(n^k)$.</p>\n</blockquote>\n\n<p>Can anyone explain me the part $p(n)\\in \\Omega(n^k)$ of the proof? Why should we divide $a_k\\cdot n^k$ by 2? Why can't we take $a_kn^k$ as coefficient of $n^k$? And how do we obtain that $n&gt;2A/a_k$?</p>\n", 'ViewCount': '118', 'Title': 'Understanding why the polynomial $p(n) = \\sum_{i=0}^{k} a_in^i$ is in $\\Theta(n^k)$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-14T23:41:17.610', 'LastEditDate': '2013-05-14T21:26:38.743', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8173', 'Tags': '<algorithms><algorithm-analysis><proof-techniques>', 'CreationDate': '2013-05-14T17:34:14.640', 'Id': '12022'},77_86:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>The MAX k-SAT problem is:</p>\n\n<blockquote>\n  <p>\u201cGiven a set of clauses C1,\u2026,Ck, each of length k, over a set of\n  variables x1,\u2026,xn, find a truth assignment that satisfies as many of\n  the clauses as possible.\u201d</p>\n</blockquote>\n\n<p>I'm trying for find a randomized 0.999-approximation algorithm for the MAX 10-SAT problem. Help :(</p>\n", 'ViewCount': '87', 'Title': 'MAX 10-SAT Algorithm', 'LastActivityDate': '2013-05-15T16:16:03.370', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12032', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3083', 'Tags': '<algorithms><proof-techniques><dynamic-programming>', 'CreationDate': '2013-05-15T02:48:00.273', 'Id': '12031'},77_87:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Constructivist logic is a system which removes the Law of the Excluded Middle, as well as \nDouble Negation, as axioms. It\'s described on Wikipedia <a href="http://en.wikipedia.org/wiki/Constructivist_logic">here</a> and <a href="http://en.wikipedia.org/wiki/Mathematical_constructivism">here</a>. In particular, the system doesn\'t allow for proof by contradiction.</p>\n\n<p>I\'m wondering, is anyone familiar with how this affects results regarding Turing Machines and formal languages? I notice that almost every proof that a language is undecidable relies on proof by contradiction. Both the Diagonalization argument and the concept of a reduction work this way. Can there ever be a "constructive" proof of the existence of an undecidable language, and if so, what would it look like?</p>\n', 'ViewCount': '504', 'Title': 'Do undecidable languages exist in constructivist logic?', 'LastActivityDate': '2013-07-11T06:23:13.290', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '12502', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><turing-machines><logic><proof-techniques><undecidability>', 'CreationDate': '2013-06-06T16:25:28.620', 'FavoriteCount': '2', 'Id': '12492'},77_88:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to prove a bisimulation relation on $CA_{\\tau}(N)$ (communication algebra with tau-steps) and names $N$.</p>\n\n<p>It need to prove that $p!d.x||p?d.y$ is bisimular with $p!d.(x||p?d.y)+p?d.(p!d.x||y)$ by finding a suitable bisimulation relation $R$.</p>\n\n<p>I was thinking of $R=\\{(x,x) \\mid x \\text{ is a reachable state} \\} \\cup \\{(p!d.(x||p?d.y)+p?d.(p!d.x||y) \\mid x\\text{ and }y \\text{ are reachable states} \\}$.</p>\n\n<p>Is this a suitable relation? How do I prove that.</p>\n\n<p>Note: the definition of bisimularity in this book is:\n$x$ is bisimilar with $y$ when there exists and relation $R$ on automata $M$ and $M'$ with sets of states $S$, $S'$ such that:</p>\n\n<ol>\n<li>$R$ relates the reachable states</li>\n<li>$R$ relates the initial states</li>\n<li>Whenever $sRs'$ and $s$ has an $a$ step to $t$ for some $a$ in the alphabet, then there are states $s''$ and $t'$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and $s''$ has an $a$ step to $t'$ and both $sRs''$ and $tRt'$.</li>\n<li>Whenever $sRs'$ and $s'$ has an $a$ step to $t'$, then there are states $s''$ and $t$ in $S$ such that $s$ has an $\\epsilon$ path to $s''$ and $s''$ has an $a$ step to $t$ and both $s''Rs'$ and $tRt'$.</li>\n<li>Whenever $sRs'$ and $s$ has an $\\tau$ step to $t$, then there are states $s''$ and $t'$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and either:\n<ol>\n<li>$s''=t'$ or</li>\n<li>$s''$ has an $\\tau$ step to $t'$ and both $sRs'$ and $tRt'$</li>\n</ol></li>\n<li>Same as $5$, but then from $M'$ to $M$.</li>\n<li>Whenever $sRs'$ and $s'$ terminates, then there is a state $s''$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and $s''$ terminates and $sRs''$.</li>\n<li>Same as 7, but then from $M'$ to $M$.</li>\n</ol>\n\n<p>How can I prove such relation?</p>\n", 'ViewCount': '56', 'Title': 'Prove a bisimulation relation', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-11T12:55:25.187', 'LastEditDate': '2013-06-11T12:55:25.187', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8588', 'Tags': '<automata><proof-techniques><correctness-proof>', 'CreationDate': '2013-06-10T08:50:59.530', 'Id': '12591'},77_89:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The main question is, how exactly is the big O analysis calculated on routines? Is there a specific formula that relates what each function in a program does to a big O calculation?</p>\n\n<p>Also, what about more complex iterations, such as colour conversions etc?</p>\n\n<p>I would like to point out that this is not a homework question, rather, it is a question from my own research/programming learning curve. I have code that I am working on, but would like to know how this analysis is carried out.</p>\n', 'ViewCount': '251', 'Title': "Analysis of algorithms, 'big O' question", 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-17T15:40:51.770', 'LastEditDate': '2013-07-17T10:26:48.837', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12901', 'Score': '3', 'OwnerDisplayName': 'user8872', 'PostTypeId': '1', 'Tags': '<algorithms><algorithm-analysis><proof-techniques><runtime-analysis>', 'CreationDate': '2013-06-25T19:08:19.800', 'Id': '12899'},77_90:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having some issues proving a problem I am working on. I have been sketching out examples but the proof is not jumping out at me.</p>\n\n<p>Question:\nLet $G = (V,E)$ be an undirected $r$-regular graph (that is each vertex has a degree of $r$) for some $0 &lt; r &lt; n$, where $|V| = n &gt; 1$. Prove that either $G$ or its complement $G^*$ has a hamiltonian path. </p>\n\n<p>Now the reason it's asking for $G$ or $G^*$ is because if it's not a connected undirected graph then taking the complement will make it connected.</p>\n\n<p>So lets assume that it's a connected $r$-regular graph. We start at a vertex $v$. From this vertex we can visit up to $r$ adjacent vertices. So we visit one of them, say $u$, and from there we have $r-1$ vertices to choose from because we do not want to go back to vertex $v$.</p>\n\n<p>Now I am trying to formulate a proof by going from vertex to vertex until all vertices are visited exactly once (hamiltonian path). But I do not see how to formulate the proof. Somehow each new vertex I visit will always have an uninformed neighbour until I reach the final vertex on the path.</p>\n\n<p>Am I on the right track?</p>\n", 'ViewCount': '136', 'Title': 'r-regular graph and hamiltonian path', 'LastActivityDate': '2013-06-26T20:19:10.370', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12918', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><proof-techniques>', 'CreationDate': '2013-06-26T18:24:24.753', 'Id': '12916'},77_91:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a valid binary search tree whose keys are unique real numbers, and a set of $k$ pointers to the $k$ minimum elements in the tree, will the BST property be maintained if I replace all $k$ elements with the average of the $k$ elements? </p>\n\n<p>The BST property as given in Corman:</p>\n\n<blockquote>\n  <p>Let $x$ be a node in a binary search tree. If $y$ is a node in the\n  left subtree of $x$, then $y.key \\leq x.key$. If $y$ is a node in the\n  right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n\n<p>I've tried this with a few test cases for $k=3$ and a few different trees, and it seems to hold, but I'm not sure if it actually does <em>and how I could prove it</em>.</p>\n", 'ViewCount': '122', 'Title': 'Binary Search Tree: Replace $k$ min elements with their average', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-30T20:46:51.233', 'LastEditDate': '2013-06-30T19:15:30.497', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '12998', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<data-structures><proof-techniques><search-trees>', 'CreationDate': '2013-06-30T09:09:43.920', 'Id': '12984'},77_92:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Do they need to "unwind" exactly to the same set of paths or does it suffice when one set is contained in the other ? </p>\n\n<p>Or is it sufficient to argue that M,s satisfies both LTL formulas for any starting s and a model M, that is, reaching with both at "true" ?</p>\n\n<p><strong>Generally.</strong></p>\n\n<p>Let $M$ be any model. Further, let $s$ be any state $M$ might be in.</p>\n\n<p>Let $\\phi$ and $\\psi$ be two LTL formulas.</p>\n\n<p>If $\\forall$ paths $\\pi$ in $M$ starting at $s$ it holds that $\\pi \\models \\phi \\leftrightarrow \\pi \\models \\psi $ then we say  $\\phi$ and $\\psi$ are equivalent ($\\phi \\equiv \\psi$). </p>\n\n<p>More succinct </p>\n\n<p>$(\\pi \\models \\phi \\leftrightarrow \\pi \\models \\psi) \\rightarrow (\\phi \\equiv \\psi)$.</p>\n\n<p><strong>Example.</strong> <em>Prove that $\\neg G \\chi \\equiv F \\neg \\chi$.</em></p>\n\n<p>If we can show that $(\\pi \\models \\neg G \\chi \\leftrightarrow \\pi \\models F \\neg \\chi)$ we would have proven that $(\\neg G \\chi \\equiv F \\neg \\chi)$. So we reduce to the former.</p>\n\n<p>Step 1. We show that $(\\pi \\models \\neg G \\chi \\rightarrow \\pi \\models F \\neg \\chi)$:</p>\n\n<p>$\\{(\\pi \\models \\neg G \\chi) \\leftrightarrow (\\pi \\not\\models G \\chi) \\leftrightarrow (\\forall i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\not\\models \\chi)\\} \\rightarrow \\{(\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\not\\models \\chi) \\leftrightarrow (\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\models \\neg\\chi) \\leftrightarrow (\\pi \\models F \\neg \\chi)\\}.$</p>\n\n<p>Step 2. We show that $(\\pi \\models F \\neg \\chi  \\rightarrow \\pi \\models \\neg G \\chi)$:</p>\n\n<p>$\\{(\\pi \\models F \\neg \\chi) \\leftrightarrow (\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\models \\neg\\chi) \\leftrightarrow (\\exists i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\not\\models \\chi)\\} \\rightarrow \\{?\\}.$ <em>How do I get back?</em> </p>\n\n<p><strong>Ok.</strong> I can semantically understand that if for every model and any path in it, it is true eventually that $\\neg \\chi$ holds, it cannot be the case that generally for every model and any path in it $\\chi$ will hold. How can I write this down formally?</p>\n\n<p>Would for $\\{?\\}$: $\\{\\neg (\\forall i \\geq 1, i \\in \\mathbb{N}. \\pi^i \\models \\chi) \\leftrightarrow (\\neg (\\pi \\models G \\chi)) \\leftrightarrow (\\pi \\not\\models G \\chi) \\leftrightarrow (\\pi \\models \\neg G \\chi)\\}$ be a valid argumentation ? It looks different than Step 1. and anyway is there a rule to pull $\\neg$ "out" from $\\not\\models$ this way ?</p>\n', 'ViewCount': '169', 'Title': 'Howto formally go about proving that two LTL formulas are equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-05T14:34:53.770', 'LastEditDate': '2013-07-05T14:34:53.770', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '13096', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6789', 'Tags': '<logic><proof-techniques><linear-temporal-logic>', 'CreationDate': '2013-07-05T05:55:24.307', 'Id': '13092'},77_93:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '81', 'Title': 'Why is this sequence of recurrence relevant?', 'LastEditDate': '2013-07-11T11:58:16.090', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3003', 'FavoriteCount': '1', 'Body': '<p>I am learning how to solve the time complexity for the recurrence relation</p>\n\n<p>$$\n    T(n) = 2T(n - 1) + n^2\\text{, where }T(1) = 1\n$$</p>\n\n<p>The solution notes that I should begin by considering the following sequence:</p>\n\n<p>$$\n    \\text{Define }T^k(n) = T^{k - 1}(n + 1) - T^{k - 1}(n) \\\\\n    \\text{and let }T^{(0)}(n) = T(n)\n$$</p>\n\n<p>How is the sequence $T^k(n)$ relevant to solving my original recurrence relation? This just seems to be complicating the problem by defining an entirely new sequence. </p>\n', 'Tags': '<proof-techniques><recurrence-relation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-11T11:58:16.090', 'CommentCount': '1', 'AcceptedAnswerId': '13122', 'CreationDate': '2013-07-06T21:41:21.073', 'Id': '13118'},77_94:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is a famous <a href="http://en.wikipedia.org/wiki/Two_Generals%27_Problem" rel="nofollow">Coordinated Attack Problem</a>. Let define a simple message-passing system $S$ with requirements </p>\n\n<ul>\n<li>Uniform Agreement: No two processes decide dierently.</li>\n<li>Validity:</li>\n</ul>\n\n<p>(a) If all processes start with 0, then no process decides 1.</p>\n\n<p>(b) If all processes start with 1, and there are no failures, then no process decides 0.</p>\n\n<ul>\n<li>Termination: All nonfaulty processes eventually decide.</li>\n</ul>\n\n<p>System $S$ consisting of two processes $p$ and $q$ connected by a  bidirectional communication link such that (a) processes proceed\nin synchronous rounds, (b) processes do not fail, and (c) any number of messages can be lost.</p>\n\n<p>It\'s well known that system $S$ cannot satisfy all above requirements, therefore let consider different requirements.</p>\n\n<ul>\n<li>Weak Termination: If there are no failures, then all processes eventually decide.</li>\n</ul>\n\n<p>Is the problem consisting of Agreement, Validity, and Weak Termination unsolvable in system S?</p>\n\n<blockquote>\n  <p>All processes eventually decide when there is no failures, so when inputs are $0$ and $0$ and no failures, both generals decide $0$. By dropping one of the message I cannot ensure the termination, therefore the standard reasoning doesn\'t work here.</p>\n</blockquote>\n\n<ul>\n<li>Unanimous Termination: If any process decides, then all processes eventually decide.</li>\n</ul>\n\n<p>Is the problem consisting of Agreement, Validity, and Weak Termination unsolvable in system S?</p>\n\n<blockquote>\n  <p>It\'s also very tricky requirement. Assume the both inputs are $0$ and $0$ and no failures than both decide $0$, let drop the message from $P_1$ to $P_0$, regarding to $P_1$ it is the undistinguishable execution, therefore $P_1$ still decide $0$ and according to unanimous termination, someday $P_0$ will decide the same $0$ according to agreement, noq according to the standard schema, change the input of $P_0$ to $1$ and this undistinguishable execution to $P_0$, so the same agreement and so forth we reach a contradiction, no solution. </p>\n</blockquote>\n\n<p>I am sure if it\'s correct. In addition the case with weak termination I don\'t know how to solve, even if it\'s solvable.</p>\n', 'ViewCount': '51', 'Title': 'Coordinated Attack Problem Different Requirements', 'LastEditorUserId': '4778', 'LastActivityDate': '2013-07-08T04:20:03.047', 'LastEditDate': '2013-07-08T04:08:17.387', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13147', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4778', 'Tags': '<proof-techniques><distributed-systems>', 'CreationDate': '2013-07-07T14:54:54.857', 'Id': '13133'},77_95:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an assignment to do and I\'m quite stuck with the following question :</p>\n\n<blockquote>\n  <p>Use Rice\'s theorem to show that </p>\n  \n  <p>$ \\qquad L\' = \\{ \\langle M \\rangle \\mid \\; (\\exists \\text{ TM } M\') \\; [ L(M\') = L(M) \\text{ and } M\' \\text{ has less than 29 states} ] \\}$ </p>\n  \n  <p>is undecidable.</p>\n</blockquote>\n\n<p>I have absolutely no idea how to proceed.</p>\n\n<p>Would someone be kind enough to, at least, give me some clues?</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>First, I wrote the question wrong. It is now \'$M\'$ has less than 29 states\' (not \'steps\')."</p>\n\n<p>Here\'s what I\'m thinking after more reading and consulting other students at school.</p>\n\n<p>Rice\'s theorem :</p>\n\n<blockquote>\n  <p>$L = \\{ \\langle M \\rangle \\mid L(M) \\text{ has some property } P \\}$ where :</p>\n  \n  <ol>\n  <li><p>$P$ is non-trivial, i.e. there exists at least one machine $M_1$ such that $\\langle M_1 \\rangle \\in L$, and at least one machine $M_2$ such that $\\langle M_2 \\rangle \\not \\in L$.</p></li>\n  <li><p>$P$ is indeed a property of the language of TMs, i.e. whenever $L(M_a) = L(M_b)$, we have $\\langle M_a \\rangle \\in L$ if and only if $\\langle M_b \\rangle \\in L$.</p></li>\n  </ol>\n  \n  <p>Then, $L$ is undecidable.</p>\n</blockquote>\n\n<p>So here, the property is "$M\'$ has less than 29 states".</p>\n\n<p>We can show that this property is non-trivial.</p>\n\n<p>Let\'s take the language "abcdefghijklmnopqrstuvwxyz0123456789" (only one string is accepted). We can build a TM $M$ this way :</p>\n\n<p>-> Enter in state $q_0$</p>\n\n<p>-> In $q_0$ : if you read "a", proceed to $q_a$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>-> In $q_a$ : if you read "b", proceed to $q_{ab}$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>$\\vdots$</p>\n\n<p>-> In $q_{abcdefghijklmnopqrstuvwxyz012345678}$ : if you read "9" go to $q_{accept}$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>So here we got 3 "basic states" : $q_0$, $q_{reject}$ and $q_{accept}$ and we have $|abcdefghijklmnopqrstuvwxyz0123456789| - 1$ states (there is no $q_{abcdefghijklmnopqrstuvwxyz0123456789}$ because when we read "9" at the end, we go to $q_{accept}$). So that\'s 26 + 10 - 1 = 35 states. We have a total of 35 + 3 = 38 states.</p>\n\n<p>Unless I am wrong, there can\'t be a TM $M\'$ that can test wether a string $w$ belongs to that language without having <em>at least</em> 38 states !</p>\n\n<p>So the property "$M\'$ has less than 29 steps" is non-trivial as there is at least one TM that respects it, and at least one that does not.</p>\n\n<p>Now, $P$ is indeed a property of the language of TMs, because any two machines $M_1$ and $M_2$ such that $L(M_1) = L(M_2)$ implies :</p>\n\n<p>$\\langle M_1 \\rangle  \\in L\' \\Leftrightarrow L(M_1) = L(M_2) \\Leftrightarrow \\langle M_2 \\rangle \\in L\'$.</p>\n\n<p>(I know there is at least one missing clause in there, but I can\'t figure how to write it, it\'s got something to do with that "$M\'$ has less than 29 steps")</p>\n\n<p>So, according to Rice\'s theorem, $L\'$ is undecidable.</p>\n', 'ViewCount': '352', 'Title': "Use Rice's theorem to show that the language of optimisable Turing machines is undecidable", 'LastEditorUserId': '8737', 'LastActivityDate': '2013-07-30T22:50:11.450', 'LastEditDate': '2013-07-30T22:50:11.450', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8737', 'Tags': '<computability><proof-techniques><undecidability>', 'CreationDate': '2013-07-29T06:12:15.467', 'Id': '13485'},77_96:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I don\'t "see" why the following syntax is equivalent to the second</p>\n\n<p>syntax1:</p>\n\n<pre><code>E -&gt; E + T\nE -&gt; T\n</code></pre>\n\n<p>syntax2: </p>\n\n<pre><code>E -&gt; T E\'\nE\' -&gt; + T E\'\nE\' -&gt;\n</code></pre>\n\n<p>(it is to avoid left recursion and I am not understanding why the solution works)</p>\n\n<p>How do I mathematically prove that both syntax definitions are equivalent</p>\n', 'ViewCount': '57', 'Title': 'Prove that the syntax is equivalent', 'LastActivityDate': '2013-08-09T11:54:08.293', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13688', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1700', 'Tags': '<programming-languages><proof-techniques><parsers>', 'CreationDate': '2013-08-09T10:49:22.573', 'Id': '13686'},77_97:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Ramsey's theorem states that every graph with $n$ nodes contains either a clique or an independent set with at least $\\frac{1}{2}\\log_2 n$ nodes.</p>\n\n<p>I tried to look it up at a few places (including Sipser) but I could not make out a lot of sense from the proofs. I would appreciate it if someone can give me a proof (or clear intuition) on this.</p>\n", 'ViewCount': '259', 'Title': "Proof of Ramsey's theorem: the number of cliques or anti cliques in a graph", 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-26T15:30:54.327', 'LastEditDate': '2013-08-25T11:36:47.523', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13921', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<graph-theory><proof-techniques><combinatorics><discrete-mathematics>', 'CreationDate': '2013-08-25T08:49:06.623', 'Id': '13920'},77_98:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For proofs by well-ordering principle the general template is to consider the negation of some predicate $P(n)$. Then assume the set of all elements that fulfill $\\lnot P(n)$, i.e.</p>\n\n<p>$\\qquad N = \\{ n \\mid \\lnot P(n) \\}$</p>\n\n<p>has a smallest element according to WOP, say $m = \\min N$, and if we manage to prove that there is another element $m' \\in N$ that is less than $m$ that also negates  then we contradict our assumption that $m$ is the smallest element.</p>\n\n<p>My question is that should we be proving some sort of a base case as well for the above mentioned template. As in proving that for some base case, $P(\\mathrm{base})$ is true?</p>\n", 'ViewCount': '141', 'Title': 'Does a proof using the well-ordering principle need a base case?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-03T10:24:27.257', 'LastEditDate': '2013-09-03T10:20:12.613', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9946', 'Tags': '<proof-techniques>', 'CreationDate': '2013-09-02T12:53:04.490', 'Id': '14082'},77_99:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I already have a solution for this problem but it's just not making sense to me. </p>\n\n<p>Here is the problem (It's from Introduction to Algorithms by CLRS found in CH.4): </p>\n\n<blockquote>\n  <p>Show $T(n) = 2T(\\lfloor n/2 \\rfloor +17)+n$  is $O(n \\log n)$</p>\n</blockquote>\n\n<p>This is what I have so far: </p>\n\n<p>So Assume $T(k) \\leq cn\\lg n$, for $k&lt;n$.</p>\n\n<p>$\\qquad \\begin{align*}\n  T(n) &amp;= 2T(\\lfloor n/2 \\rfloor +17)+n \\\\\n       &amp;\\leq 2c(\\lfloor n/2 \\rfloor +17)\\lg(\\lfloor n/2 \\rfloor + 17) +n \\\\\n       &amp;\\leq 2c(n/2 + 17) \\lg (n/2 + 17) + n \\\\\n       &amp;= c(n + 34) \\lg((n+34)/2)+ n\n\\end{align*}$</p>\n\n<p>And this is where I stop understanding what is going on. Looking at the solution to this problem tells me: </p>\n\n<blockquote>\n  <p>Note that $(n + 34)/2 \\leq (3n)/4$ for $n \\geq 68$\n  so that $\\lg((n + 34)/2) \\leq \\lg((3n)/4) = \\lg(n) + \\lg(3/4)$ for $n \\geq 68$.</p>\n</blockquote>\n\n<p>But it fails to tell me why/how we know that $(n+34)/2 \\leq 3n/4$ for $n \\geq 68$. Where did this number come from and how would I arrive at this if I did not know the solution beforehand? </p>\n", 'ViewCount': '1319', 'Title': 'Solving recurrences using substitution method', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-30T00:18:19.787', 'LastEditDate': '2013-09-16T08:49:52.240', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '14352', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10152', 'Tags': '<asymptotics><proof-techniques><recurrence-relation>', 'CreationDate': '2013-09-16T05:33:59.237', 'Id': '14347'},77_100:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a program consisting of variables and instructions which modify these variables, and a synchronization primitive (a monitor, mutex, java's synchronized or C#'s lock), is it possible to prove that such a program is thread safe? </p>\n\n<p>Is there even a formal model for describing things like thread safety or racing conditions? </p>\n", 'ViewCount': '110', 'Title': 'Is it possible to prove thread safety?', 'LastActivityDate': '2013-09-17T14:26:49.070', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '14365', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10169', 'Tags': '<proof-techniques><correctness-proof><concurrency><threads>', 'CreationDate': '2013-09-16T15:57:39.443', 'FavoriteCount': '2', 'Id': '14356'},77_101:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We started learning recurrences and I am having trouble with some of the problems. Our professor is having us substitute in $n=2^m$ and $S(m)=T(2^m)$ then writing down equations and summing them all up. I understand the substitution part, but not how to simplify the end result.</p>\n\n<p>One of the problems I am stuck on is $T(n)=2T(n/2)+n^3$ where $T(2)=c$, When I sub in $n=2^m$ and $S(m)=T(2^m)$ I get:</p>\n\n<p>$S(m)=2S(m-1)+(2^m)^3$</p>\n\n<p>$S(m-1)=2S(m-2)+(2^{m-1})^3$</p>\n\n<p>...</p>\n\n<p>$S(3)=2S(2)+(2^{3})^3$</p>\n\n<p>$S(2)=2S(1)+(2^{2})^3$</p>\n\n<p>$S(1)=c$</p>\n\n<p>Now because there is a coefficient on the right side we have to multiply each equation by a power of 2 so we can sum them.</p>\n\n<p>$S(m)=2S(m-1)+(2^m)^3$</p>\n\n<p>$2*S(m-1)=2^2S(m-2)+2*(2^{m-1})^3$</p>\n\n<p>...</p>\n\n<p>$2^{m-3}*S(3)=2^{m-2}S(2)+2^{m-3}(2^{3})^3$</p>\n\n<p>$2^{m-2}*S(2)=2^{m-1}S(1)+2^{m-2}(2^{2})^3$</p>\n\n<p>$2^{m-1}S(1)=c*2^{m-1}$</p>\n\n<p>So sum these and we get:</p>\n\n<p>$S(m)=(2^m)^3+2*(2^{m-1})^3+2^2*(2^{m-2})^3+...+2^{m-3}(2^{3})^3+2^{m-2}(2^{2})^3+c*2^{m-1}$</p>\n\n<p>And this is where I get stuck, how can I simplify this? I tried dividing by $(2^m)^3$ but that came out to a awful mess. The other two I'm having trouble with are $T(n)=16T(n/4)+n^2$ and $T(n)=7T(n/2)+n^2$ Any help would be appreciated.</p>\n", 'ViewCount': '43', 'Title': 'Help with recurrence solutions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-17T07:58:09.693', 'LastEditDate': '2013-09-17T07:58:09.693', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14362', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10170', 'Tags': '<proof-techniques><recurrence-relation>', 'CreationDate': '2013-09-16T18:44:57.610', 'Id': '14361'},77_102:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to learn about applying the pumping lemma and I'm not really sure how to go about proving this language isn't regular with the pumping lemma:</p>\n\n<p>$L= \\{0^n 1^m \\space | \\space m \\equiv 0 \\space mod \\space n, \\space n \\geq 2 \\}$</p>\n\n<p>Now I realize that the condition $m \\equiv 0 \\space mod \\space n$, is essentially saying that $m$ is some multiple of $n$. Is it possible that could you go about proving that $L$ is not regular in the way that you can prove that $L = \\{0^n 1^n\\}$ is not regular since $m$ is a multiple of $n$, since $m = kn$ (where $k$ is some integer)?</p>\n\n<p><em><strong>Updated:</em></strong></p>\n\n<p>-- My attempt at the proof:</p>\n\n<p>If the language $L$ is regular, then by the pumping lemma $\\exists \\space p \\space | \\space \\forall s \\in L \\cap \\Sigma ^{\\geq p}  $.</p>\n\n<p>Next by the pumping lemma $\\exists x, y, z : s = xyz$, where $s$ is a string such that:</p>\n\n<p>(1) $|y|\\geq1$</p>\n\n<p>(2) $|xy|\\leq p$</p>\n\n<p>(3) $\\forall i\\geq0, xy^iz \\in L$</p>\n\n<p>Now suppose we let $m = kp$, where $k$ is some integer, let the string $s = 0^p 1^{kp}, s\\in L$ and $|s|\\geq p$. By the pumping lemma the decomposition of $s$ is defined by $s = xyz$. Now we show that $\\forall x, y, z$ that (1)-(3) do not hold.</p>\n\n<p>If (1) and (2) hold, then $s=0^p1^{kp} = xyz$, with $|xy|\\leq p$ and $|y|\\geq 1$.</p>\n\n<p>So $x = 0^u, y=0^v, z=0^w1^{kp}$</p>\n\n<p>$u+v \\leq p$, $v \\geq 1 $, $w \\geq 0$</p>\n\n<p>$u+v+w = kp$</p>\n\n<p>But (3) fails for $i=2$ since $xy^2z = 0^u0^v0^v0^w1^{kp} = 0^{u+2v+w}1^{kp} \\not\\in L$ since $u+2v+w \\neq kp $</p>\n\n<p>Hence $L$ is <em>not</em> a regular language.</p>\n\n<p>Is this the correct way to go about this proof?</p>\n", 'ViewCount': '347', 'Title': 'Proving the language $L= \\{0^n 1^m \\space | \\space m \\equiv 0 \\space mod \\space n, \\space n \\geq 2 \\}$ is not regular using the pumping lemma', 'LastEditorUserId': '9912', 'LastActivityDate': '2013-09-20T21:10:22.973', 'LastEditDate': '2013-09-20T21:10:22.973', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '14454', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<regular-languages><proof-techniques><pumping-lemma>', 'CreationDate': '2013-09-19T23:03:21.863', 'Id': '14453'},77_103:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m doing some research on game semantics using <a href="http://www.cs.bath.ac.uk/~gam23/papers/marktoberdorf.ps.gz" rel="nofollow">these notes</a>. Currently I\'m trying to prove that the definition of composite-strategy is indeed a strategy.</p>\n\n<p>I have already proved all the conditions of strategies except that it is prefix-closed(for even-length prefixes) and respects the alternation rule. </p>\n\n<p>Can somebody give me a <strong>hint</strong> on approaching this two specific conditions? I have already tried many times but all my attempts led to unfinished proofs with a lot of cases (e.g. 10-12) and after proving most of those I couldn\'t finish the others, so I believe I\'m approaching the problem from the wrong point of view.</p>\n\n<hr>\n\n<p>For the definitions please refer to Chapter 3 of the notes linked above, not to the articles of, say, Abramsky and Hyland/Ong, since the definitions are slightly different(e.g strategies contains only even-length strings, while Hyland/Ong admit odd-length strings). <em>If</em> you refer to these you should also give some hint as to how to apply the techniques to the definitions in the notes.</p>\n\n<p>Also note that the missing conditions that I\'m trying to prove are all about proving that $u \\upharpoonright A, C$ is a legal position for $A \\multimap C$, which, in Ong\'s article, is something <em>assumed</em> in <em>their</em> definition of composite strategy.</p>\n', 'ViewCount': '48', 'Title': 'How to prove that the composite strategy is prefix-closed and respects the alternation condition?', 'LastEditorUserId': '7246', 'LastActivityDate': '2013-09-24T08:56:34.510', 'LastEditDate': '2013-09-24T08:56:34.510', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7246', 'Tags': '<proof-techniques><semantics><game-semantics>', 'CreationDate': '2013-09-24T07:59:34.780', 'Id': '14577'},77_104:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a bijection problem that I cannot get my head around. It goes like this: </p>\n\n<p>let f: A -> B and g: B -> C be functions such that g o f is a bijection. Prove that f must be one-to-one and that g must be onto. And also an example showing that it is possible for neither f nor g to be a bijection. </p>\n\n<p>This is the problem. I do not even know where to begin. Any help is appreciated. </p>\n', 'ViewCount': '64', 'ClosedDate': '2013-11-01T12:55:21.657', 'Title': 'trouble with bijection definition', 'LastEditorUserId': '10282', 'LastActivityDate': '2013-10-01T04:38:49.983', 'LastEditDate': '2013-10-01T04:16:58.313', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10282', 'Tags': '<proof-techniques><discrete-mathematics><correctness-proof><partial-order>', 'CreationDate': '2013-10-01T04:01:25.823', 'Id': '14724'},77_105:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '68', 'Title': 'Reference for an undecidability proof', 'LastEditDate': '2013-10-04T06:49:58.733', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9625', 'FavoriteCount': '1', 'Body': '<p>I\'m searching for a reference of an undecidability proof that is as simple as possible and starts "from scratch".</p>\n\n<p>With "from scratch" I mean that it does not use some other undecidable problem to prove some undecidability (which is the usual case), I cannot wrap my mind about how proving undecidability that way (without a previous proof) could be possible.</p>\n\n<p>This question may be inspiring: <a href="http://math.stackexchange.com/questions/80745/an-example-of-an-easy-to-understand-undecidable-problem">An example of an easy to understand undecidable problem</a></p>\n\n<p>Also, I know this is probably not very objective, but it is important to me, it should be something as simple as possible, hopefully enough so that even I can understand it.</p>\n', 'ClosedDate': '2013-10-04T06:52:47.623', 'Tags': '<reference-request><proof-techniques><undecidability><decision-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T06:49:58.733', 'CommentCount': '4', 'CreationDate': '2013-10-03T14:44:58.153', 'Id': '14788'},77_106:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I prove, or where can I find proof that for every regular language there is unambigous grammar?</p>\n', 'ViewCount': '379', 'Title': 'Proof that there is unambigous grammar for every regular language', 'LastActivityDate': '2013-10-14T19:42:49.000', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16085', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10738', 'Tags': '<proof-techniques><ambiguity>', 'CreationDate': '2013-10-14T17:57:05.787', 'Id': '16082'},77_107:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am a microbiologist and I am currently self-studying machine learning from some open lecture videos. I am finding it pretty difficult to understand proofs that are somewhat "obvious", my poor mathematical knowledge is to blame for that. Can you please recommend a text-book that deals with the mathematical proofs of the theorems? Or approaches machine learning from the mathematical side?</p>\n', 'ViewCount': '74', 'Title': 'Recommendations for machine learning book?', 'LastActivityDate': '2013-11-01T05:37:35.780', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10977', 'Tags': '<machine-learning><proof-techniques>', 'CreationDate': '2013-10-25T20:29:04.257', 'Id': '16430'},77_108:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know how to use the pumping lemma to do so, but I don't think that can be used for this language:</p>\n\n<p>$$L = \\{x \\in \\{0,1\\}^* : \\text{no prefix of $x$ has more $1$'s than $0$'s}\\}. $$</p>\n\n<p>What other method can I use to prove this?</p>\n", 'ViewCount': '62', 'ClosedDate': '2013-10-28T07:26:12.150', 'Title': 'Prove language is not regular?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-10-28T05:01:55.250', 'LastEditDate': '2013-10-28T05:00:25.010', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11006', 'Tags': '<regular-languages><proof-techniques>', 'CreationDate': '2013-10-27T19:45:56.497', 'Id': '16482'},77_109:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I stumbled upon this <a href="http://www.proofwiki.org/wiki/User%3aJoe" rel="nofollow">wikipage</a> that has got this proof :</p>\n\n<p><img src="http://i.stack.imgur.com/ouR52.png" alt="enter image description here"></p>\n\n<p>I rechecked <a href="http://en.wikipedia.org/wiki/Sum_rule_in_differentiation" rel="nofollow">sum rule of differentiation</a>.</p>\n\n<p>And i can not understand where is this wrong.</p>\n\n<p>Any Tips ?</p>\n\n<p>I think that the second line </p>\n\n<p>x^2 = x + x +... x times... </p>\n\n<p>being used for differentiation is wrong. but i am not sure .</p>\n', 'ViewCount': '67', 'ClosedDate': '2013-11-01T10:08:34.853', 'Title': 'What is wrong in this proof?', 'LastActivityDate': '2013-11-01T07:53:47.073', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '16614', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11032', 'Tags': '<proof-techniques><correctness-proof>', 'CreationDate': '2013-11-01T06:09:41.560', 'Id': '16613'},77_110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following grammar G:\n$$\n\\begin{align*}\n&amp;S \\to aB|bA \\\\\n&amp;A \\to a|aS|bAA \\\\\n&amp;B \\to b|bS|aBB\n\\end{align*}\n$$</p>\n\n<p>I am going to prove that this language L(G) consists of words with the same number of a's and b's by strong induction.</p>\n\n<p><strong>Inductive hypothesis</strong>: $S$ produces $m$ $a$'s and $m$ $b$'s, $A$ produces $m+1$ $a$'s and $m$ $b$'s, $B$ produces $m$ $a$'s and $m+1$ $b$'s for some integer $m$. </p>\n\n<p><strong>Base</strong>: The smallest string produced by $S$ is $ab$ or $ba$. The smallest string produced by $A$ and $B$ is $a$ and $b$ respectively. All three satisfy the IH. </p>\n\n<p><strong>Induction</strong>: Assume the inductive hypothesis is satisfied for all strings of length $k$ or less. </p>\n\n<p>For strings of length $k+1$:</p>\n\n<p><strong>(1)</strong>. $A\\to aS$; then $S$ inductively derived a string of length $k-1$ with same number of $a$'s as $b$'s. Since $A$ is initiated by $S\\to bA$, we concatenate that $b$ plus the $a$ in $aS$ and we get a string of length $k+1$ with same number of $a$'s as $b$'s.</p>\n\n<p><strong>(2)</strong>. $A\\to bAA$; then each $A$ on the right hand side has one more $a$ than $b$. Since $A$ is initiated by $S\\to bA$, we concatenate that $b$ plus the $b$ in $bAA$ and we get a string of length $k+1$ with the same number of $a$'s as $b$'s.  </p>\n\n<p>Can I continue for $B\\to bS$ and $B\\to aBB$? Am I totally wrong here? </p>\n", 'ViewCount': '104', 'Title': "Is my proof for a context free language correct? Same number of a's as b's", 'LastEditorUserId': '11155', 'LastActivityDate': '2013-11-07T05:05:43.043', 'LastEditDate': '2013-11-07T05:05:43.043', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques>', 'CreationDate': '2013-11-07T02:26:03.960', 'Id': '16787'},77_111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '93', 'Title': 'How to prove that the minimum square partition of a 3X2 rectangle has 3 squares', 'LastEditDate': '2013-11-10T10:32:47.813', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '2', 'Body': '<p>This question is motivated by an older question about <a href="http://cs.stackexchange.com/q/16661/2755">tiling an orthogonal polygon with squares</a>.</p>\n\n<p><img src="http://i.stack.imgur.com/4furns.jpg" alt="enter image description here"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <img src="http://i.stack.imgur.com/L8cYGs.jpg" alt="enter image description here"></p>\n\n<p>Given a $3\\times 2$ rectangle like the first image, the second image is a <em>square partition</em> of that rectangle. </p>\n\n<ul>\n<li>A <em>square partitioning</em> is a covering by non-overlapping squares; the entire rectangle must be covered, all the squares must be disjoint.</li>\n<li>A <em>minimum square partitioning</em> is a <em>square partitioning</em>, for which is no <em>square partitioning</em> that is made of a lesser number of squares.</li>\n</ul>\n\n<blockquote>\n  <p>How can we prove that the second image is a <i>minimum square partitioning</i> of the $3\\times 2$ rectangle?</p>\n</blockquote>\n\n<p><sub>Can we generalize this to ${\\rm M{\\small IN}S{\\small QUARES}}(R_{w,h=w-1})=w$? (see <a href="http://cs.stackexchange.com/q/16826/2755">followup question</a> )</sub></p>\n', 'Tags': '<proof-techniques><computational-geometry><tiling>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T10:32:47.813', 'CommentCount': '0', 'AcceptedAnswerId': '16812', 'CreationDate': '2013-11-08T01:05:49.080', 'Id': '16809'},77_112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm studying for my CS final and I can't seem to get the anywhere with one of the questions.</p>\n\n<p>This is the question:</p>\n\n<p>Prove that if a node in a BST has a successor, but has no right child, then its successor must be an ancestor. (We will consider only BSTs with distinct elements.)</p>\n\n<p>I know that a successor is the node that replaces the deleted node, and that we only need to worry about this case when the node being deleted has two children, but I can't seem to start this proof.</p>\n\n<p>Any help?</p>\n", 'ViewCount': '51', 'Title': 'BST Successor Proof', 'LastActivityDate': '2013-12-02T17:27:33.667', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<proof-techniques><binary-trees><binary-search>', 'CreationDate': '2013-12-01T22:36:10.517', 'FavoriteCount': '1', 'Id': '18512'},77_113:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are <a href="http://cs.stackexchange.com/q/265/755">many techniques</a> to prove that a language is <em>not</em> context-free, but how do I prove that a language <em>is</em> context-free?</p>\n\n<p>What techniques are there to prove this?  Obviously, one way is to exhibit a context-free grammar for the language.  Are there any systematic techniques to find a context-free grammar for a given language?</p>\n\n<p>For regular languages, there <em>are</em> <a href="http://cs.stackexchange.com/q/1331/755">systematic ways</a> to derive a regular grammar / finite-state automaton: for instance, the Myhill-Nerode theorem provides one way.  Is there any corresponding technique for context-free languages?</p>\n\n<hr>\n\n<p>My motivation here is to (hopefully) build up a reference question that contains a list of techniques that are often helpful, when trying to prove that a given language is context-free.  Since we have many questions here that are special cases of this, it would be nice if we could document the general approach or general techniques that one can use when facing this sort of problem.</p>\n', 'ViewCount': '156', 'Title': 'How to prove that a language is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T19:22:09.170', 'LastEditDate': '2014-01-17T22:55:11.557', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-12-02T04:18:45.460', 'FavoriteCount': '1', 'Id': '18524'},77_114:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<h2>Question</h2>\n\n<blockquote>\n  <p>How do I write more intuitive proofs of the two following results in Coq? </p>\n</blockquote>\n\n<pre><code>Theorem Course_of_values_ind: \n        InductiveRel N less\n\n  Theorem DivRem: (forall d n:N, \n      (Sigma N (fun q =&gt; (Sigma N (fun s =&gt;\n         and  (I N n (add (mul (succ d) q) s)) (less s (succ d))))))).\n</code></pre>\n\n<h2>Background</h2>\n\n<p>I recognize all of these results are already built into Coq, and so it is possible to provide much easier proofs than what I am asking for. This is something I have managed to do on my own; simply using the Coq library for this particular task. Even though this is much more concise (and thus arguably more elegant), I find don\'t find it very instructive.<strong>Luke Mathieson</strong> provided a good example of this when he gave an alternative proof in Coq of trichonomy for natural numbers:</p>\n\n<pre><code>(*\n  The following is just to show what can be done with some of the tactics\n  The omega tactic implements a Pressburger arithmetic solver, so anything\n  with natural numbers, plus, multiplication by constants, and basic logic\n  can just be solved. Not very interesting for practicing Coq, but cool to\n  know.\n*)\n\nRequire Import Omega.\n\nExample trich\' : forall (n m : nat),\n  n &lt; m \\/ n = m \\/ m &lt; n.\nProof.\n  intros.\n  omega.\nQed\n</code></pre>\n\n<p>Notice that the actual proof of the theorem in Coq does not reveal how the proof would look like informally. Thus, my hope is that someone may be kind enough to give a more, shall we say "intuitive", proof of the Euclidean division algorithm in Coq. The proof I have in mind will uses structural induction, which rests on the validity of the following lemma:</p>\n\n<blockquote>\n  <p><strong>Lemma</strong>: *$(\\mathbb{N},&lt;)$ is well founded. (Course_of_values_ind)*</p>\n</blockquote>\n\n<p>As this is so critical to the proof of the Euclidean division algorithm I decided to prove it. </p>\n\n<p><strong>Proof</strong>:</p>\n\n<p>Suppose that $P(x)$ set $(x:N$) is a progressive predicate  (definition is given below the proof of the Euclidean division algorithm) on $N$. Define \\begin{equation} Q(x)=_{def}(\\forall y:N)(y&lt;x \\subset P(y)) \\tag{*}\\end{equation}</p>\n\n<p>It is enough to prove $(\\forall x:N)Q(x)$, as then for any $x:N$ we have $x&lt;S(x)$ and so $P(x)$. $Q(0)$ follows by Peano\'s forth axiom. The inductive step $(\\forall x N)(Q(x) \\subset Q(S(x)))$ follows by theorem A (see <a href="http://cs.stackexchange.com/questions/18765/theorem-proofs-in-coq">Theorem Proofs in Coq</a>) combined with Peano 1a and 1b (see Code-file). </p>\n\n<blockquote>\n  <p>For all natural numbers $n$ and $m$ if $n&gt;0$, if $m&gt;0$ then there are natural numbers $q$ and $r$ such that $n=qm+r$ and $r&lt;m$. </p>\n</blockquote>\n\n<p>One may formalize this as:</p>\n\n<blockquote>\n  <p>\\begin{equation}(\\forall n:\\mathbb{N})(\\forall k:\\mathbb{N})(\\exists q:\\mathbb{N})(\\exists r:\\mathbb{N})(n=_{\\mathbb{N}}q\\cdot S(k)+r \\land r&lt;S(k) \\end{equation}</p>\n</blockquote>\n\n<p>where $m:=S(k)$. Now, an informal proof of the so-called Eucliean theorem can be given as:</p>\n\n<p>Proof:</p>\n\n<p>Let $k$\xa0be an arbitrary natural number, define $m:=S(k)$ and then proceed by strong induction on $n$ (this is justified by lemma). Suppose $n$ is a natural number and for every $l &lt;n$ there are natural numbers $q$ and $r$  such that $l=mq+r$ and $r &lt;m$. We now have two cases:</p>\n\n<ol>\n<li>$n&lt;m$. Let $q=0$ and $r=n$, Then clearly $n=qm+r$ and $r&lt;m$.</li>\n<li>$n \\geq m$ Let $l=n-m&lt;n$ and observe that since $n \\geq m$, $l$ is a natural number. By the inductive hypothesis one may now choose $q\'$ and $r\'$ such that $l=q\'m+r\'$ and $r\'&lt;m$. But, this means we have $n-m=q\'m+r\'$, so $n=q\'m+r\'+m=m(q\'+1)+r\'$. So, if we let $q=q\'+1$ and $r=r\'$, then we have $n=qm+r$ and $r&lt;m$. </li>\n</ol>\n\n<h1>Definitions of the terms I use in my informal proofs</h1>\n\n<pre><code>      Definition Progressive \n           (A:Set)(R: A -&gt; A -&gt; Set)(P:A -&gt; Set):=\n        (forall x:A, \n         (forall y:A, R y x -&gt; P y) -&gt; P x).\n\n        Definition InductiveRel \n        (A:Set)(R: A -&gt; A -&gt; Set):=\n        (forall P:A-&gt;Set, Progressive A R P -&gt; \n        forall x:A, P x). \n\n        Theorem Course_of_values_ind: \n        InductiveRel N less\n    Definition Decidable (A B:Set)(R: A -&gt; B -&gt; Set):Set :=\n    forall x:A, forall y:B, or (R x y) (not (R x y)).\n\n\n    Definition and (A B:Set) := prod A B.\n    Definition and_el_left (A B: Set)(p: and A B) \n    := fst p.\n    Definition and_el_right (A B: Set)(p: and A B) \n    := snd p.\n(* Euclidean Division *)\n\nTheorem DivRem: (forall d n:N, \n  (Sigma N (fun q =&gt; (Sigma N (fun s =&gt;\n     and  (I N n (add (mul (succ d) q) s)) (less s (succ d))))))).\n</code></pre>\n\n<h2>Code-file</h2>\n\n<p>This code was generously provided by <strong>cody</strong> (again see <a href="http://cs.stackexchange.com/questions/18765/theorem-proofs-in-coq">Theorem Proofs in Coq</a>). It is my intent to add the results presented above to this code as soon as they are all complete. </p>\n\n<pre><code>(* Inductive Sigma (A:Set)(B:A -&gt; Set) :Set := Spair: forall a:A, forall b : B a,Sigma A B. *)\n\n(* Definition E (A:Set)(B:A -&gt; Set) (C: Sigma A B -&gt; Set) (c: Sigma A B)  *)\n(*   (d: (forall x:A, forall y:B x, C (Spair A B x y))): C c := *)\n(*   match c as c0 return (C c0) with  *)\n(*     | Spair a b =&gt; d a b  *)\n(*   end. *)\n\nPrint sigT.\n\n(* Binary sum type *)\n\n(* Inductive sum\' (A B:Set):Set := inl\': A -&gt; sum\' A B | inr\': B -&gt; sum\' A B. *)\n\n(* Print sum\'_rect. *)\n\n(* Definition D (A B : Set)(C: sum\' A B -&gt; Set) (c: sum\' A B)  *)\n(*   (d: (forall x:A, C (inl\' A B x))) (e: (forall y:B, C (inr\' A B y))): C c := *)\n(*   match c as c0 return C c0 with  *)\n(*     | inl\' x =&gt; d x  *)\n(*     | inr\' y =&gt; e y  *)\n(*   end. *)\n\nPrint sum.\n\n(* Three useful finite sets *)\n\n(* Inductive N_0: Set :=. *)\n\n(* Definition R_0 (C:N_0 -&gt; Set) (c: N_0): C c :=  *)\n(*   match c as c0 return (C c0) with end. *)\n\nPrint False.\n\n\n(* Inductive N_1: Set :=  *)\n(*   zero_1 : N_1. *)\n\n(* Definition R_1 (C:N_1 -&gt; Set) (c: N_1) (d_zero: C zero_1): C c :=  *)\n(*   match c as c0 return (C c0) with  *)\n(*     | zero_1 =&gt; d_zero  *)\n(*   end. *)\n\nPrint unit.\n\n\n(* Inductive N_2: Set :=  *)\n(*  | zero_2 : N_2  *)\n(*  | one_2 : N_2. *)\n\n(* Definition R_2 (C:N_2 -&gt; Set) (c: N_2) (d_zero: C zero_2) (d_one: C one_2): C c :=  *)\n(*   match c as c0 return (C c0) with  *)\n(*     | zero_2 =&gt; d_zero  *)\n(*     | one_2 =&gt; d_one  *)\n(*   end. *)\n\nPrint bool.\n\n(* Natural numbers *)\n\n(* Inductive N:Set :=  *)\n(* |zero: N  *)\n(* | succ : N -&gt; N. *)\n\n(* Print N. *)\n\n(* Print N_rect. *)\n\n(* Definition R (C:N -&gt; Set) (d: C zero) (e: (forall x:N, C x -&gt; C (succ x))): (forall n:N, C n) :=  *)\n(*   fix F (n: N): C n :=  *)\n(*   match n as n0 return (C n0) with  *)\n(*     | zero =&gt; d  *)\n(*     | succ n0 =&gt; e n0 (F n0)  *)\n(*   end. *)\n\nPrint nat.\n\n(* Boolean to truth-value converter *)\n\n(* Definition Tr (c:N_2) : Set :=  *)\n(*   match c as c0 with  *)\n(*     | zero_2 =&gt; N_0  *)\n(*     | one_2 =&gt; N_1  *)\n(*   end. *)\n\nDefinition Tr (b : bool) : Type := if b then unit else False.\n\n(* Identity type *)\n\n(* Inductive I {A: Type}(x: A) : A -&gt; Type :=  *)\n(*   r : I x x. *)\n\n(* Print I_rect. *)\n\n(* Hint Resolve r.  *)\n\nPrint identity.\n\nNotation "x ~ y" := (identity x y)(at level 60).\n\nNotation "#":=(identity_refl)(at level 10).\n\nDefinition J \n  (A : Type)\n  (C: (forall x y : A, forall e : x ~ y, Type)) \n  (d: (forall x:A, C x x (# x))) :\n  (forall (a : A)(b : A)(e : a ~ b),  C a b e) :=\n    fun a b e =&gt;\n      match e in _ ~ b with\n        | # =&gt; d a\n      end.\n\nCheck J.\n\n(* functions are extensional wrt identity types *)\n\nDefinition id_ext {A B: Type} {x y : A} (f: A -&gt; B): \n  (x ~ y -&gt; (f x) ~ (f y))\n  := fun p =&gt;\n    match p with\n      # =&gt; # (f x)\n    end.\n\n(* addition *)\n\n(* Definition add (m n:N) : N := R (fun z=&gt; N) m (fun x y =&gt; succ y) n. *)\n\nPrint plus.\n\n(* multiplication *)\n\n(* Definition mul (m n:N) : N := R (fun z=&gt; N) zero (fun x y =&gt; add y m) n. *)\n\nPrint mult.\n\n(* Axioms of Peano verified *)\n\nRequire Import Arith.\n\nTheorem P1a: (forall x: nat, (0 + x) ~ x).\nProof.\n  simpl; auto.\nDefined.\n\n\nTheorem P1b: forall x y: nat, ((S x) + y) ~ (S (x + y)).\nProof.\n  simpl; auto.\nDefined.\n\nTheorem P2a: (forall x: nat, (0 * x) ~ 0).\nProof.\n  simpl; auto.\nDefined.\n\nTheorem P2b: forall x y: nat, ((S x) * y) ~ (y + (x * y)).\nProof.\n  simpl; auto.\nDefined.\n\n(* Definition pd (n: N): N := R (fun _=&gt; N) zero (fun x y=&gt; x) n. *)\n\nPrint pred.\n\nTheorem P3: (forall x y: nat, (S x) ~ (S y) -&gt; x ~ y).\nProof.\n intros x y p.\n apply (id_ext pred p).\nDefined.\n\n(* Definition not (A:Set): Set:= (A -&gt; N_0). *)\n\nPrint notT.\n\nDefinition isnonzero (n: nat): bool:= if n then false else true.\n\nEval compute in isnonzero 1.\nEval compute in isnonzero 0.\n\nNotation "x !~ y":= (notT (x ~ y))(at level 60).\n\nDefinition false_if_succ (n : nat) : Type := if n then unit else False.\n\nHint Resolve tt.\n\nTheorem P4 : (forall x: nat, (S x) !~ 0).\nProof.\n  intro x.\n  intro.\n  assert (false_if_succ (S x)).\n  rewrite H.\n  simpl; auto.\n  simpl in X; auto.\nQed.\n\n\nTheorem P5 (P:nat -&gt; Type): P 0 -&gt; (forall x:nat, P x -&gt; P (S x)) -&gt; (forall x:nat, P x).\nProof.\n  intros; induction x; auto.\nDefined.\n\n(* I(A,-,-) is an equivalence relation *)\n\n(*All these are in the std library *)\n\nLemma Ireflexive (A:Set): (forall x:A, x ~ x).\nProof.\n  auto.\nDefined.\n\nLemma Isymmetric (A:Set): (forall x y:A, x ~ y -&gt; y ~ x).\nProof.\n  auto.\nDefined.\n\nLemma Itransitive (A:Set): (forall x y z:A, x ~ y -&gt; y ~ z -&gt; x ~ z).\nProof.\n  intros x y z e1 e2.\n  rewrite e1; auto.\nDefined.\n\nLemma S_cong : (forall m n:nat, m ~ n -&gt; (S m) ~ (S n)).\nProof.\n  intros m n e; rewrite e; auto.\nDefined.\n\nLemma zeroadd: (forall n:nat, (n + 0) ~ n).\nProof.\n  induction n; simpl; auto.\n  rewrite IHn; auto.\nDefined.\n\nHint Rewrite zeroadd.\n\nLemma Sadd: (forall m n:nat, (m + (S n)) ~ (S (m + n))).\nProof.\n  induction m; intro n; auto.\n  simpl; rewrite IHm; auto.\nDefined.\n\nHint Rewrite Sadd.\n\nLemma commutative_add: (forall m n:nat, (m + n) ~ (n + m)).\nProof.\n  induction m; intro n.\n  rewrite zeroadd; auto.\n  simpl; rewrite IHm.\n  rewrite Sadd; auto.\nDefined.\n\nLemma associative_add: (forall m n k:nat, ((m + n) + k) ~ (m + (n + k))).\nProof.\n  induction m; auto.\n  intros n k; simpl.\n  rewrite IHm; auto.\nDefined.\n\nPrint sum.\n\nOpen Scope type_scope.\n\n(* Definition or (A B : Set):= (A + B). *)\n\nDefinition less (m n: nat) := { z : nat &amp; S (z + m) ~ n}.\n\nNotation "m &lt; n" := (less m n)(at level 70).\n\nLemma less_lem : forall n m : nat, n &lt; (S m) -&gt; (n &lt; m) + (n ~ m).\nProof.\n  intros n m leq.\n  elim leq.\n  induction x; simpl; intro e.\n  right.\n  apply P3; auto.\n  left.\n  exists x.\n  apply P3; auto.\nDefined.\n\n\nTheorem nattrichotomy: forall n m:nat, (n &lt; m) + (n ~ m) + (m &lt; n).\nProof.\n  induction n; induction m; simpl.\n  left; right; auto.\n  left; left.\n  exists m; rewrite zeroadd; auto.\n  right; exists n; rewrite zeroadd; auto.\n  destruct IHm as [ leq | gt ].\n  destruct leq as [lt | eq].\n  left; left; destruct lt.\n  exists (S x).\n  simpl; rewrite i; auto.\n  left; left; exists 0.\n  rewrite eq; simpl; auto.\n  generalize (less_lem _ _ gt); intro less_eq.\n  destruct less_eq as [less| eq].\n  right.\n  destruct less.\n  exists x.\n  rewrite Sadd; rewrite&lt;- i; auto.\n  left;right; rewrite eq; auto.\nDefined.\n</code></pre>\n', 'ViewCount': '115', 'Title': 'Euclidean Algorithm in Coq', 'LastEditorUserId': '11942', 'LastActivityDate': '2013-12-12T20:56:15.797', 'LastEditDate': '2013-12-12T12:25:32.687', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11942', 'Tags': '<proof-techniques><automated-theorem-proving><proof-assistants><mathematical-programming><coq>', 'CreationDate': '2013-12-12T00:51:07.960', 'Id': '18908'},77_115:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>How would one go about proving that one PDA that may only pop one symbol from its stack per transition, is equivalent to a second PDA that is allowed to pop any number of symbols?</p>\n\n<p>That is a PDA with transitions of type $(Q\xd7(\u03a3\u222a{\u03b5})\xd7(\u0393\u222a{\u03b5}))\xd7(Q\xd7\u0393^*)$ is equivalent to a PDA with transitions of type $(Q\xd7(\u03a3\u222a{\u03b5})\xd7(\u0393^*))\xd7(Q\xd7\u0393^*)$.</p>\n', 'ViewCount': '41', 'Title': 'Equivalency of two pushdown automata', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-12-18T01:03:00.653', 'LastEditDate': '2013-12-18T01:03:00.653', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user12200', 'PostTypeId': '1', 'Tags': '<proof-techniques><pushdown-automata>', 'CreationDate': '2013-12-18T00:53:11.713', 'Id': '19078'},77_116:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Foldl and folr are 2 very important functions for FP and Haskell, but I have never heard much about the unsided fold:</p>\n\n<pre><code>fold f [a,b,c,d] = (f (f a b) (f c d))\n</code></pre>\n\n<p>That is, a fold that operates on binary associative functions (so the order of application doesn't matter). If I recall correctly, this is very common in databases as it can be parallelized. So, about it, I ask:</p>\n\n<ol>\n<li>Is it, like foldr, universal?</li>\n<li>Like foldr, can you define every important function using it?</li>\n<li>Is there a fusion rule for it, similar to those for foldr/build and unfoldr/destroy?</li>\n<li>Why is it barely mentioned?</li>\n<li>Any consideration worth mentioning?</li>\n</ol>\n", 'ViewCount': '29', 'Title': 'What are the properties of the unsided fold?', 'LastActivityDate': '2014-01-06T02:07:05.993', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11547', 'Tags': '<algorithms><algorithm-analysis><proof-techniques><functional-programming>', 'CreationDate': '2014-01-06T02:07:05.993', 'Id': '19524'},77_117:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I recently was introduced to solving recurrence bounds by substitution but there's something i don't understand about it.</p>\n\n<p>In standard induction proofs you prove a base case, assume it holds for n then show it holds for n+1 and therefore show it applies to integers larger than the base case.</p>\n\n<p>For when you solve recurrences like T(n) = T(n/2) the proof has a base, assumes T(n/2) then proves it holds for T(n). Does this proof not only hold for the numbers that are multiples of two of the base cases? Would this not require an infinitely large number of base cases to show what it holds for?</p>\n\n<p>Could someone please explain this to me?</p>\n", 'ViewCount': '108', 'Title': 'How to apply the substitution method to n/2?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T09:04:11.990', 'LastEditDate': '2014-01-20T08:51:55.257', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Shawn', 'PostTypeId': '1', 'Tags': '<proof-techniques><recurrence-relation><induction>', 'CreationDate': '2014-01-20T03:23:36.953', 'Id': '19840'},77_118:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know that this is a known theorem but I can't find its proof. The theorem is: </p>\n\n<blockquote>\n  <p>The write-contention of any $n$-process wait-free consensus algorithm (implemented from any read-modify-write operations) is $n$.</p>\n</blockquote>\n\n<p>Can someone link me to a proof or an explanation?</p>\n", 'ViewCount': '38', 'Title': 'Proof of contention of the wait-free consensus algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T13:30:08.410', 'LastEditDate': '2014-02-12T13:30:08.410', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14602', 'Tags': '<algorithms><reference-request><proof-techniques><concurrency>', 'CreationDate': '2014-02-12T10:02:18.260', 'Id': '21566'},77_119:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '61', 'Title': 'Induction proof, base case not working but induction step works?', 'LastEditDate': '2014-02-13T05:24:32.683', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Body': '<p>$1+3+5+...+(2n+3)=n^2+4n$</p>\n\n<p>For this series using induction proof. </p>\n\n<p>Base case 1,2,3,.. not working. But induction step works well. </p>\n\n<p>Base case is not given in question.</p>\n', 'ClosedDate': '2014-02-17T09:15:23.240', 'Tags': '<proof-techniques><induction>', 'LastEditorUserId': '947', 'LastActivityDate': '2014-02-13T10:01:41.927', 'CommentCount': '5', 'AcceptedAnswerId': '21595', 'CreationDate': '2014-02-13T05:11:15.257', 'Id': '21593'},77_120:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://courses.cs.vt.edu/~cs5204/fall07-kafura/Papers/TransactionalMemory/Linearizability.pdf" rel="nofollow">Linearizability</a> is a well-known correctness condition for concurrent objects.  It provides the illusion that each operation applied by concurrent processes takes effect instantaneously at some point between its invocation and its response. To prove linearizability of an implementation, it is necessary and sufficient to show that all its possible executions are linearizable with respect to some sequential specification. For this purpose, two common methods have been developed, as summarized in the paper <a href="http://dl.acm.org/citation.cfm?id=1993687" rel="nofollow">"Linearizable Implementations Do Not Suffice for Randomized Distributed Computation [@STOC\'2011]"</a>. </p>\n\n<p>However, what are typical methods for showing that some implementation is <em>not</em> linearizable? Logically, it is necessary to identify an execution which is not linearizable. But, how to achieve it? Are there some typical examples of demonstrating the non-linearizablity of an implementation in the literature?</p>\n', 'ViewCount': '30', 'Title': 'What are methods for showing that concurrent objects are not linearizable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T13:05:12.033', 'LastEditDate': '2014-02-18T13:05:12.033', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<reference-request><proof-techniques><concurrency>', 'CreationDate': '2014-02-18T12:24:11.333', 'Id': '21760'},77_121:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading the proof of PCP theorem in <a href="http://people.csail.mit.edu/madhu/papers/1992/almss-conf.pdf" rel="nofollow">Proof Verication and Hardness of Approximation Problems</a>. The following paragraph appears in section 3 (page 4), <em>"Outline of the Proof of the Main Theorem"</em>.</p>\n\n<blockquote>\n  <p>The results of these sections show that $NP \\subset OPT (poly(n), 1)$ (Theorem 5) and $NP \\subset OPT (\\log n, poly \\log n)$ (Theorem 8). Theorems 9 and 10 show that the recursion idea applies to these proof systems, and in particular shows the following:</p>\n  \n  <ol>\n  <li>$OPT (f (n), g(n)) \\subset OPT (f (n) + O(\\log g(n)), (\\log g(n))^{O(1)} )$ and</li>\n  <li>$OPT (f (n), g(n)) \\subset OPT (f (n) + (g(n))^{O(1)} , 1)$.</li>\n  </ol>\n  \n  <p>This allows us to conclude that $NP \\subset OPT (\\log n, poly \\log \\log n)$ (<strong>by composing</strong> two $OPT (\\log n, poly \\log n)$ proof systems) and then <strong>by composing</strong> this system with the $OPT (poly(n), 1)$ proof system we obtain $OPT (\\log n, 1)$ proof system for $NP$.</p>\n</blockquote>\n\n<p><strong>Edit.</strong> Composition of verifiers is defined in <a href="http://www.cs.umd.edu/~gasarch/pcp/AS.pdf" rel="nofollow">Probabilistic Checking of Proofs: A New Characterization of NP</a>  section 3 (page 13) <em>"Normal Form Verifiers and Their Use in Composition"</em>.</p>\n\n<blockquote>\n  <p>Let $r, q, s, t$ be any functions defined on the natural integers. Suppose there is a normal-form verifier $V_2$ that is $(r(n), s(n), q(n), t(n))$-constrained. Then, for all functions $R, Q, S, T$, $$RPCP(R(n), S(n), Q(n), T(n)) \\subseteq \\\\RPCP(R(n) + r(\\tau), s(\\tau), Q(n) + q(\\tau), Q(n)t(\\tau))$$ where $\\tau$ is a shorthand for $O((T(n))^2)$.</p>\n</blockquote>\n\n<p>Where $RPCP(r, s, q, t)$ is a $PCP(r, s \\cdot q)$ which takes $t$ time to accept of reject <em>after</em> reading the $s \\cdot q$ bits.</p>\n\n<p>I still don\'t see how this composition works. Is $OPT(r, q) = RPCP(r, q, 1, q)$ and a normal form verifier? In that case it seems to work, but then just composing $OPT(poly(n), 1)$ with $OPT(\\log n, poly \\log n)$ is enough, so why bother with $OPT(\\log n, poly \\log \\log n)$ or relations $1.$ and $2.$?</p>\n', 'ViewCount': '83', 'Title': 'Proof of PCP theorem', 'LastEditorUserId': '5167', 'LastActivityDate': '2014-03-23T10:41:07.547', 'LastEditDate': '2014-03-23T10:41:07.547', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '5167', 'Tags': '<complexity-theory><proof-techniques><probabilistic-algorithms>', 'CreationDate': '2014-03-15T07:51:32.813', 'Id': '22644'},77_122:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading the reduction given by Sipser in his textbook "Introduction to the Theory of Computation," on page 303. The reduction is:</p>\n\n<p>\\begin{equation} 3SAT \\leq_p KCLIQUE \\end{equation}</p>\n\n<p>I am really trying to understand everything formally -- putting everything in a strict logical notation helps me learn Math. To clarify, the content of this proof, has not helped me give other reductions because I don\'t understand one direction of the $\\iff$ in the logic of reductions.</p>\n\n<p>In this reduction, $f$ must be s.t:\n\\begin{equation} w\\in 3SAT \\iff f(w) \\in KCLIQUE \\end{equation}\nand $f$ computes within a polynomial number of steps of the input size. The polynomial part is easy for me to understand, so no problem here!</p>\n\n<p>I see that the above logical statement is equivalent to:\n\\begin{equation} w\\in 3SAT \\implies f(w) \\in KCLIQUE \\land w\\not\\in 3SAT \\implies f(w) \\not\\in KCLIQUE\\end{equation}\nThe above just says yes-instances map to yes-instances and no-instances map to no-instances.</p>\n\n<p>It appears that Sipser shows us:\n\\begin{equation} w\\in 3SAT \\implies f(w) \\in KCLIQUE \\land f(w) \\in KCLIQUE \\implies w\\in 3SAT\\end{equation}</p>\n\n<p>Which is also equivalent to the above by taking the contrapositive of the second implication.</p>\n\n<p>Here is my understanding of the $\\implies$ direction. Given a yes-instance of $3SAT$, show that the reduction $f$ gives us a yes-instance for $KCLIQUE$. This seems completely natural.</p>\n\n<p><strong>I don\'t really understand the other direction</strong> -- namely, given a yes-instance of KCLIQUE we are supposed to show that we get a yes-instance of $3SAT$. However since the reduction goes from $3SAT$ to $KCLIQUE$ i.e. the domain is the language $3SAT$ and the Codomain is the language $KCLIQUE$, I don\'t understand <strong>how</strong> we show this. </p>\n\n<p>It appears that the argument is; Our reduction has provided us this graph, from which we can create a satisfying assignment from?</p>\n\n<p>Please help me understand the other direction, and thanks for your time.</p>\n', 'ViewCount': '40', 'Title': 'Polynomial Reduction 3SAT to K-Clique', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-25T10:07:17.047', 'LastEditDate': '2014-03-25T08:48:36.160', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<complexity-theory><np-complete><reductions><proof-techniques>', 'CreationDate': '2014-03-25T06:23:45.563', 'Id': '23030'},77_123:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm a freshman CS student at my university and i'm struggling with understanding my professor through his thick accent. I've asked him to explain the proof for this multiple times and still have trouble comprehending what he's trying to tell me.</p>\n\n<p>The question is: </p>\n\n<p>Prove that:  $P\\rightarrow(Q\\rightarrow R)$ is equivalent to $(P \\wedge Q) \\rightarrow R$</p>\n\n<p>He wants us to prove it using math and goes on to tell me that $P \\rightarrow (Q \\rightarrow R) = \\neg P \\vee (\\neg Q \\vee R)$</p>\n\n<p>From that point on, I was completely lost and unable to follow along.</p>\n", 'ViewCount': '83', 'Title': 'How can I prove $P \\rightarrow (Q \\rightarrow R)$ is equivalent to $(P \\wedge Q) \\rightarrow R$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-03T05:40:14.150', 'LastEditDate': '2014-03-27T15:13:20.313', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16154', 'Tags': '<logic><proof-techniques><propositional-logic>', 'CreationDate': '2014-03-26T16:24:58.947', 'Id': '23087'},77_124:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to prove that a language is not $\\omega$-regular. </p>\n\n<p>The language I\'m working with can be defined as:</p>\n\n<p>$$L = \\{ a_1 \\dots a_n x^\\omega ~ | ~ n &gt; 0, a_1 \\dots a_n \\in L^\\prime \\}$$</p>\n\n<p>where $L^\\prime$ is a specific non regular language (I omit the definition $L^\\prime$ because I think it is of no help for my problem), $a_i$ are symbols in $L^\\prime$ alphabet and $x$ is any symbol not in $L^\\prime$ alphabet.</p>\n\n<p>I\'m aware of several proof techniques for proving a language is not regular (see e.g. <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a> ). </p>\n\n<p>Are there similar proof techniques for proving that a language is not $\\omega$-regular?</p>\n', 'ViewCount': '54', 'Title': u'Proving that the continuation of a non-regular language is not \u03c9-regular', 'LastEditorUserId': '14441', 'LastActivityDate': '2014-03-29T23:41:34.323', 'LastEditDate': '2014-03-29T23:41:34.323', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '23235', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14441', 'Tags': '<formal-languages><regular-languages><proof-techniques><buchi-automata>', 'CreationDate': '2014-03-29T18:56:27.080', 'Id': '23227'},77_125:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this context-free grammar and I want to find out whether its language is finite or infinite.</p>\n\n<pre><code>S -&gt; XY|bb  Step 1\nX -&gt; XY|SS  Step 2\nY -&gt; XY|SS  Step 3\n</code></pre>\n\n<p>So I would do</p>\n\n<pre><code>S -&gt; XY            From step 1\nS -&gt; YYY           From step 2\nS -&gt; SSYY          From step 3\nS -&gt; SSSSY         From step 3\nS -&gt; SSSSSS        From step 3\nS -&gt; bbSSSSS       From step 1\nS -&gt; bbbbSSS       From step 1\nS -&gt; bbbbbbSSS     From step 1\nS -&gt; bbbbbbbbSS    From step 1\nS -&gt; bbbbbbbbbbS   From step 1\nS -&gt; bbbbbbbbbbbb  From step 1\n\nbbbbbbbbbbbb \n</code></pre>\n\n<p>So I know how to generate words like this but how to find out whether the language is finite or infinite?</p>\n', 'ViewCount': '159', 'Title': "How to find whether a grammar's language is finite or infinite?", 'LastEditorUserId': '8321', 'LastActivityDate': '2014-04-03T14:05:21.387', 'LastEditDate': '2014-04-03T09:22:59.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23368', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><induction>', 'CreationDate': '2014-04-02T20:30:27.960', 'Id': '23367'},77_126:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to prove the following 2 properties of the Small-step semantics of the WHILE programming language:</p>\n\n<ul>\n<li>If $\\langle C_1; C_2, s\\rangle \\rightarrow^k s'$ then there is a\nstate $s''$ and natural numbers $k_1$ and $k_2$ such that $\\langle C_1;s\n   \\rangle \\rightarrow^{k_1} s''$ and $\\langle C_2; s'' \\rangle\n   \\rightarrow^{k_2} s'$ where $k_1 + k_2 = k$.</li>\n<li>If $\\langle C_1, s \\rangle \\rightarrow^k s'$ then $\\langle C_1; C_2,\n   s \\rangle \\rightarrow^k \\langle C_2, s'\\rangle$.</li>\n</ul>\n\n<p>I am not quite sure which kind of induction I should use. I am not asking for a full proof, I would rather appreciate some hints on which kind of induction I should use in this case. Thanks in advance!</p>\n", 'ViewCount': '13', 'Title': 'How to prove the following properties of Small-step semantics?', 'LastEditorUserId': '15669', 'LastActivityDate': '2014-04-04T16:47:11.947', 'LastEditDate': '2014-04-04T16:47:11.947', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23415', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15669', 'Tags': '<proof-techniques><operational-semantics>', 'CreationDate': '2014-04-04T00:28:36.010', 'Id': '23406'},77_127:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to obtain the proof of the proposition:</p>\n\n<p>$(\\forall x \\in \\mathbb{N}, P(x)) \\vee (\\neg \\forall x, P(x))$</p>\n\n<p>given that the property $P$ is decidable for every $x \\in \\mathbb{N}$, i.e.</p>\n\n<p>$\\forall x \\in \\mathbb{N}, P(x) \\vee \\neg P(x)$</p>\n\n<p>This is easy to prove (even without using the decidability of $P$) if I include the law of excluded middle, i.e.,</p>\n\n<p>$\\forall P, P \\vee \\neg P$.</p>\n\n<p>However, I am trying to obtain a constructive proof for the same. Is the proposition true without including the law of excluded middle? If so, how do I prove it? This seemingly simple property is needed to prove something about a complex system, and I am trying to not use the law of excluded middle unless it's absolutely necessary.</p>\n\n<p>The best I could come up with is the following:</p>\n\n<p>$\\forall y, (\\forall x \\le y, P(x)) \\vee \\neg (\\forall x \\le y, P(x))$</p>\n\n<p>I do not know how to proceed beyond this (or if this is even useful).</p>\n\n<p>Any help would be appreciated.</p>\n", 'ViewCount': '54', 'Title': 'Constructively deciding whether a decidable predicate holds universally', 'LastEditorUserId': '1329', 'LastActivityDate': '2014-04-08T16:15:49.483', 'LastEditDate': '2014-04-07T20:38:00.083', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'user16488', 'PostTypeId': '1', 'OwnerUserId': '16488', 'Tags': '<logic><proof-techniques><first-order-logic>', 'CreationDate': '2014-04-06T04:30:20.567', 'Id': '23509'},77_128:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are lots of <a href="/questions/tagged/algorithm-analysis" class="post-tag" title="show questions tagged &#39;algorithm-analysis&#39;" rel="tag">algorithm-analysis</a> questions around. Many are similar, for instance those asking for an analysis of nested loops or divide &amp; conquer algorithms, but most answers seem to be tailor-made.</p>\n\n<p>On the other hand, the answers <a href="http://cs.stackexchange.com/questions/192/how-to-come-up-with-the-runtime-of-algorithms">to another general question</a> explain the larger picture (in particular regarding asymptotic analysis) with some examples, but not how to get your hands dirty.</p>\n\n<p>Is there a structured, general method for analysing algorithms?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a> that can be used to point beginners to; hence its broader-than-usual scope. Please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '2051', 'Title': 'Is there a system behind the magic of algorithm analysis?', 'LastActivityDate': '2014-04-10T15:08:23.810', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '32', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<algorithms><algorithm-analysis><proof-techniques><reference-question>', 'CreationDate': '2014-04-09T12:59:52.003', 'FavoriteCount': '30', 'Id': '23593'},77_129:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am having difficulty with the concept of $LK-\\Phi$ proofs, here is a question I have been working on:</p>\n\n<blockquote>\n  <p>Let $\\Phi = \\{Pafa\\}$, where $P$ is a binary predicate symbol and $f$ is a unary function symbol. Give an $LK-\\Phi$ proof of $\\exists y Pby$. You do not need to show exchanges and weakenings.</p>\n</blockquote>\n\n<p>My intution for these questions is very little unless it is blatantly obvious over what to do, but I do know that in the system $LK$ we have a $LK-\\Phi$ proof if we have $A\\to A$ or $\\to A$ where $A\\in\\Phi$. So in this situation I think I set this up as the following:</p>\n\n<p>$$\\to \\exists y Pby$$and then I would have a sequent above it where I would apply the $\\exists R$ rule, which would create the sequent above as: $$\\to Pba$$ but from here I am not sure at all what to do whether I need to rely on some sort of trick or anything? Any help would be greatly greatly appreciated, this is for an exam I am studying.</p>\n', 'ViewCount': '28', 'Title': 'LK-$\\phi$ proof of $\\exists y Pby$', 'LastActivityDate': '2014-04-24T14:02:42.203', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<logic><proof-techniques>', 'CreationDate': '2014-04-24T13:02:18.923', 'Id': '24080'},77_130:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Hello I am having difficulty with this question, I am not even sure what strategy one would go about proving something like this:</p>\n\n<blockquote>\n  <p>Suppose $L$ is a language which includes an infinite list $c_1,c_2,\\cdots$ of constant symbols. Let $\\Gamma$ be a set of sentences $\\Gamma = \\{c_i \\neq c_j \\mid i,j\\in N, i &lt; j\\}$. Let A be a sentence such that $\\Gamma \\Rightarrow A$. Prove that $A$ has a finite model.</p>\n</blockquote>\n\n<p>I am not sure whether I would prove this via a contradiction (i.e., assume $A$ has an infinite model, or if I show a finite model that works or some how assume that we can have an infinite model and then use some sort of compactness to show it can be finite. I am a little all over the place with this question, please any help would be great!</p>\n', 'ViewCount': '30', 'Title': 'Finding a finite model', 'LastEditorUserId': '31', 'LastActivityDate': '2014-04-24T20:00:46.950', 'LastEditDate': '2014-04-24T19:58:10.593', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '24086', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<logic><proof-techniques>', 'CreationDate': '2014-04-24T19:22:29.030', 'Id': '24085'},77_131:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can we prove that:</p>\n\n<p>$$\nL = \\{ w_1\\#w_2 \\mid w_1 \\in w_2;\\; |w_2| &gt; |w_1|;\\; w_1 , w_2 \\in \\{0, 1\\}^*\\}\n$$</p>\n\n<p>is not context-free? </p>\n\n<p>The language defines $w_1$ as a sub-string of $w_2$, and they are separated by a $\\#$. This is easy with the CFG pumping-lemma for a slightly different language with $|w_2| \\ge |w_1|$ by using the special case of $|w_2| = |w_1|$ (i.e. $w_1 = w_2$). </p>\n\n<p>But here, $w_1$ is a proper sub-string of $w_2$ so I can't do the same. I fail to push the string out since we can always pump, for example the first symbol of $w_2$.</p>\n", 'ViewCount': '51', 'Title': 'Prove not context free', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-25T14:20:46.833', 'LastEditDate': '2014-04-25T12:55:52.150', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '24104', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8805', 'Tags': '<formal-languages><context-free><proof-techniques><pumping-lemma>', 'CreationDate': '2014-04-25T12:28:16.643', 'Id': '24100'},77_132:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>You have a description of a language that you have to prove is regular, context free, or other. In order to prove that it does <em>not</em> belong to a certain class of languages, you might think that it will be more convenient to prove it by using a subset of that language. The problem is that a subset of a language does not necessarily belong to the same language class as the superset language. For example: with $\\Sigma = \\{0,1\\}$, $\\Sigma^*$ is a regular language, while $ A = \\{ 0^n1^n \\mid n \\geq 0\\} \\subseteq \\Sigma^* $ is a context free language. </p>\n\n<p>(<a href="http://math.stackexchange.com/questions/718141/prove-or-disprove-that-the-language-l-1-anbm-mid-n-m-is-regular">I have fallen in the trap</a> of trying to use subsets of languages in order to try to prove that they belong to a certain class of languages.)</p>\n\n<p>An example:</p>\n\n<blockquote>\n  <p>Let $\\Sigma = \\{0,1\\} $ and $L = \\{ w \\in \\Sigma^* \\mid \\text{w contains less 1\'s than 0\'s} \\}$</p>\n  \n  <p>Is $L$ regular, context free, or neither?</p>\n</blockquote>\n\n<p>My intuition says that it is not regular, since finite state machines <em>can\'t count</em>. I think it is context free. </p>\n\n<p>The strategy I\'m thinking of is to show that this language is context free:</p>\n\n<blockquote>\n  <p>$ L_2 = \\{ 0^n1^m \\mid n \\gt m\\}$</p>\n</blockquote>\n\n<p>This language is clearly a proper subset of $L$. But, like we\'ve seen, that may not be a very useful fact if we want to prove things about the proper superset (to my understanding). It <em>seems</em> that $L_2$ is <em>easier</em> to generate than $L$: it seems easier to count how many consecutive 0\'s there are rather than counting the number of 0\'s in a string. (Especially if you consider using a PDA to count it, since then it just boils down to pushing consecutive 0\'s and then popping when you start seeing 1\'s, accepting the language if there are 0\'s left on the stack when you have consumed the word.) Consequently, if this intuition of <em>hardness</em> is correct, then $L$ is at least not regular. But then another problem reveals itself; maybe $L$ is not context free? So then you have at least shown it to not be regular, but you still have to show that it is context free or not.</p>\n\n<p>This is not the only problem for which I want to use this strategy. For example:</p>\n\n<blockquote>\n  <p>$L_p = \\{ w \\in \\Sigma^* \\mid \\text{the number of 0\'s in w is prime}\\}$</p>\n</blockquote>\n\n<p>Here I think it might be more convenient to use something like the Pumping Lemma on this language:</p>\n\n<blockquote>\n  <p>$L_{p2} = \\{ 0^n \\mid \\text{n is prime}\\}$</p>\n</blockquote>\n\n<p>Is this kind of strategy valid?</p>\n', 'ViewCount': '58', 'Title': 'Proving that a language does not belong to a language class by using more specific instances of that language', 'LastEditorUserId': '11089', 'LastActivityDate': '2014-05-01T13:28:48.180', 'LastEditDate': '2014-05-01T13:28:48.180', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '24181', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11089', 'Tags': '<formal-languages><proof-techniques>', 'CreationDate': '2014-04-28T09:54:09.097', 'Id': '24180'},77_133:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>i posted this on mathematics stack exchange <a href="http://math.stackexchange.com/questions/772617/induction-proof-for-kleene-star">here</a> before i realised this one existed.</p>\n\n<p>i am going through some past exam paper questions on regular languages for some revision, and i am having a bit of trouble with converting general ideas into formal mathematical proofs.</p>\n\n<p>the question is: <strong>given regular expression $S$, prove formally that $S^* = (S^*)^*$</strong></p>\n\n<p><strike>intuitively i can tell that because $S^*$ is an infinite set, then concatenating any number of elements from that infinite set, to that same infinite set, still yields an infinite set of the same size; ie. anything that is in $(S^*)^*)$ must also be in $S^*$.</strike></p>\n\n<p>(EDIT: thanks to David Richerby for pointing out this is wrong)</p>\n\n<p>my problem is expressing this in a formal proof. here is what i have worked through so far (it is a bit all over the place and just a collection of ways to express the problem mostly)</p>\n\n<p>$S^* = (S^*)^*$</p>\n\n<p>this implies:</p>\n\n<p>$S^* \\subseteq (S^*)^*$ <strong>and</strong> $S^* \\supseteq (S^*)^*$</p>\n\n<p>if we assume that there exists $w_k$ such that $w_k \\in S^*$</p>\n\n<p>then the base case for the proof is:</p>\n\n<p>$k = 0$   $(w_k = \\epsilon)$ (empty word, always in $S^*$ and $(S^*)^*$ by definition)</p>\n\n<p>$k = 1$   $(w_k \\in S^*)$</p>\n\n<p>and that\'s kind of where my ability to reason ends.</p>\n\n<p>i think the rest of it will be something like:</p>\n\n<p>$w_{k+1} = w_kx$</p>\n\n<p>ie. $w_k$ concatenated with $x$ where $x \\in S^*$</p>\n\n<p>but how can i show that $w_{k+1} \\in (S^*)^*$</p>\n\n<p>any help to push me in the right direction would be greatly appreciated..</p>\n', 'ViewCount': '52', 'Title': 'induction proof for kleene star', 'LastEditorUserId': '17142', 'LastActivityDate': '2014-04-29T06:05:16.453', 'LastEditDate': '2014-04-29T06:05:16.453', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17142', 'Tags': '<regular-languages><proof-techniques><induction>', 'CreationDate': '2014-04-28T11:28:50.607', 'Id': '24182'},77_134:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '28', 'Title': 'How does one figure out where a class of languages falls under some complexity class?', 'LastEditDate': '2014-04-30T17:33:52.967', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Body': '<p><img src="http://i.imgur.com/fKkk9Aq.png" alt="enter image description here"></p>\n\n<p>I was wondering how can someone prove that one class of languages is of a certain complexity? For example, how could I show the Turing-recognizable languages are in P?</p>\n\n<p>Would I have to come up with an algorithm that runs in deterministic polynomial time?</p>\n', 'ClosedDate': '2014-05-02T12:48:31.513', 'Tags': '<complexity-theory><formal-languages><proof-techniques>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-30T17:33:52.967', 'CommentCount': '1', 'AcceptedAnswerId': '24257', 'CreationDate': '2014-04-30T14:20:55.117', 'Id': '24256'}