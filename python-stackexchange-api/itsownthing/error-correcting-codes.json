2300:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2246', 'Title': 'Is the 2nd parity bit in RAID 6 a simple calculation?', 'LastEditDate': '2012-06-30T11:11:30.360', 'AnswerCount': '4', 'Score': '5', 'OwnerDisplayName': 'Mitchell Kaplan', 'PostTypeId': '1', 'OwnerUserId': '2016', 'FavoriteCount': '2', 'Body': '<p>I\'m trying to understand how the 2nd parity bit or byte is set in RAID 6. I\'m reading a <a href="http://kernel.org/pub/linux/kernel/people/hpa/raid6.pdf" rel="nofollow">paper by H. Peter Anvin</a>, and it goes into Galois field algebra, which is somewhat new to me. Anyway, a rep from HP was trying to explain RAID 6 to me and she thought it was merely two XOR operations, one for the 1st parity bit and one for the 2nd.  This doesn\'t make sense to me, but since I\'m still working through the paper I don\'t know if it reduces to something simple for RAID 6 as opposed to RAID n. It looks to me like the 2nd parity bit is quite a bit more complicated than the XOR based 1st parity bit. Is that true?</p>\n', 'Tags': '<operating-systems><storage><error-correcting-codes>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-10T16:49:24.050', 'CommentCount': '0', 'CreationDate': '2012-06-29T23:45:44.393', 'Id': '2554'},2301:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '201', 'Title': 'Commonly used Error Correcting Codes', 'LastEditDate': '2012-11-05T20:43:28.147', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2250', 'FavoriteCount': '1', 'Body': '<p>We know error correcting codes are parameterized as (n,k,d) codes. I wanted to know the values of these parameters for some commonly used error correcting codes in computer memories or in DRAMs, etc.</p>\n\n<p>I just wanted to see some values for these parameters, used in real life applications.</p>\n', 'Tags': '<computer-architecture><error-correcting-codes>', 'LastEditorUserId': '2806', 'LastActivityDate': '2012-11-05T20:43:28.147', 'CommentCount': '0', 'AcceptedAnswerId': '6481', 'CreationDate': '2012-11-05T04:08:50.493', 'Id': '6480'},2302:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am very familiar with error correcting codes. However, it is not obvious how to apply them to adaptive streaming data. There also doesn't seem to be much literature on the problem.</p>\n\n<p>The naive approach might be to take small codewords of data and use forward error correction until there is a statistically significant chance that the client has received them. Then, move to the next codeword.</p>\n\n<p>My question is whether there are known pitfalls with the naive approach and whether there exists a more comprehensive or performant solution (let's ignore the use of locally decodeable codes for now).</p>\n", 'ViewCount': '25', 'Title': 'Forward Error Correction for streaming data', 'LastActivityDate': '2013-07-11T06:48:18.127', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9125', 'Tags': '<streaming-algorithm><error-correcting-codes>', 'CreationDate': '2013-07-11T06:48:18.127', 'Id': '13222'},2303:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>What is the range of \u201cthe\u201d CRC-32, the one used by <a href="http://pubs.opengroup.org/onlinepubs/009695299/utilities/cksum.html" rel="nofollow">Unix</a>, Ethernet, zip, and many other industrial standards?</p>\n\n<p>Mathematically, a <a href="http://en.wikipedia.org/wiki/CRC" rel="nofollow">CRC</a> is defined as follows: let $G$ be the CRC polynomial in $\\mathbb{F}_2[X]$, and $M$ be a representation of the input bitstring in $\\mathbb{F}_2[X]$. Let $Q$ be the quotient of $M \\cdot X^{\\deg G}$ by $G$; the CRC value is $\\bar Q(2)$ where $\\bar Q$ is the canonical injection of $Q$ into $\\mathbb{Z}[X]$. The codomain of the CRC function is thus the integer range $[0,2^{\\deg G}-1]$ (or equivalently the set of polynomials of degree $\\le \\deg G$). Which values are reachable?</p>\n\n<p>This question is specifically about $$\\scriptstyle G = G_{Ethernet} = X^{32}+X^{26}+X^{23}+X^{22}+X^{16}+X^{12}+X^{11}+X^{10}+X^{8}+X^{7}+X^{5}+X^{4}+X^{2}+X^{1}+X^{0}$$\nthough I\'m curious whether the result generalizes to other <a href="https://en.wikipedia.org/wiki/CRC-32#Commonly_used_and_standardized_CRCs" rel="nofollow">common CRC</a>.</p>\n\n<p>Bonus: is there anything known and interesting about the relative density of preimages?</p>\n', 'ViewCount': '43', 'Title': 'Range of CRC-32', 'LastActivityDate': '2013-12-01T01:19:48.777', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18433', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<arithmetic><error-correcting-codes>', 'CreationDate': '2013-11-28T00:33:47.417', 'Id': '18431'},2304:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We have 2 stations that communicate with each other, but we need to detect (or even correct) when something is wrong.</p>\n\n<p>We use 8 binary words: each consisting of 3 bits <img src="http://i.stack.imgur.com/JbRtH.gif" alt="enter image description here"> and to send it we code it as \n<img src="http://i.stack.imgur.com/u2nA8.gif" alt="enter image description here">  where <img src="http://i.stack.imgur.com/4tjIk.gif" alt="enter image description here"> is the complement of <img src="http://i.stack.imgur.com/mdnEQ.gif" alt="enter image description here"> and <img src="http://i.stack.imgur.com/BMDVh.gif" alt="enter image description here"> is the even parity check bit of <img src="http://i.stack.imgur.com/0msIo.gif" alt="enter image description here"> .</p>\n\n<p>We need to find the capabilities of this code (up to how many can we detect and how many can we correct). BUT, a <strong>proof</strong> is required.</p>\n\n<p>This is how far I\'ve reached so far:</p>\n\n<p>First we find the hamming distance:\nIf <img src="http://i.stack.imgur.com/mdnEQ.gif" alt=""> changes then <img src="http://i.stack.imgur.com/4tjIk.gif" alt=""> changes, also <img src="http://i.stack.imgur.com/BMDVh.gif" alt=""> changes. So we have a hamming distance of 3.</p>\n\n<p>This means that we can detect two bit errors <strong>or</strong> correct a single error. </p>\n\n<p>Can you help me write the proof for that?</p>\n\n<p>(also the tags may need some refinement - comments about the downvote are welcome)</p>\n', 'ViewCount': '53', 'Title': 'Error detection/correction algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-06T15:52:06.677', 'LastEditDate': '2014-02-04T09:49:52.927', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'user2692669', 'PostTypeId': '1', 'Tags': '<coding-theory><error-correcting-codes>', 'CreationDate': '2014-02-03T17:43:37.823', 'Id': '20276'}