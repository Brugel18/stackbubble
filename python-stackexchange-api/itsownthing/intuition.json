2010:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am a graduate student taking a course in theory of computation and I have serious trouble producing content once I'm asked to. I'm able to follow the textbook (Introduction to the Theory of Computation by Michael Sipser) and lectures; however when asked to prove something or come up with a formal description of a specific TM, I just choke. </p>\n\n<p>What can I do in such situations? I guess my issue is with fully comprehending abstract concepts to the point I can actually use them. Is there a structured way to approaching a new, abstract concept and eventually build intuition?</p>\n", 'ViewCount': '390', 'Title': 'Strategies for becoming unstuck in understanding TCS', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-04T18:07:41.553', 'LastEditDate': '2012-09-02T15:23:23.673', 'AnswerCount': '4', 'CommentCount': '7', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '196', 'Tags': '<computability><education><intuition>', 'CreationDate': '2012-03-13T08:04:00.633', 'FavoriteCount': '3', 'Id': '294'},2011:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2045', 'Title': 'Intuition for logarithmic complexity', 'LastEditDate': '2012-06-18T13:16:23.193', 'AnswerCount': '7', 'Score': '44', 'PostTypeId': '1', 'OwnerUserId': '385', 'FavoriteCount': '16', 'Body': "<p>I believe I have a reasonable grasp of complexities like $\\mathcal{O}(1)$, $\\Theta(n)$ and $\\Theta(n^2)$.</p>\n\n<p>In terms of a list, $\\mathcal{O}(1)$ is a constant lookup, so it's just getting the head of the list.\n$\\Theta(n)$ is where I'd walk the entire list, and $\\Theta(n^2)$ is walking the list once for each element in the list.</p>\n\n<p>Is there a similar intuitive way to grasp $\\Theta(\\log n)$ other than just knowing it lies somewhere between $\\mathcal{O}(1)$ and $\\Theta(n)$?</p>\n", 'Tags': '<algorithms><complexity-theory><time-complexity><intuition>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-18T13:16:23.193', 'CommentCount': '6', 'AcceptedAnswerId': '582', 'CreationDate': '2012-03-21T05:51:41.653', 'Id': '581'},2012:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m looking for intuition about when a language is regular and when it is not. For example, consider:</p>\n\n<p>$$ L = \\{ 0^n 1^n \\mid n \\geq 1 \\} = \\{ 01, 0011, 000111, \\ldots \\}$$</p>\n\n<p>which is not a regular language. Intuitively it seems a very simple language, there doesn\'t seem to be anything complicated going on. What is the difference between $L$ and a regular language like:</p>\n\n<p>$$L\' = \\{ w \\mid w \\text{ does not contain } 11 \\} = \\{0,10\\}^*\\cdot (1 \\mid \\varepsilon).$$</p>\n\n<p>I know how to <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">prove that $L$ is not regular</a>, using the Pumping Lemma. Here I am looking for <strong>intuition</strong> about what makes a language regular.</p>\n', 'ViewCount': '524', 'Title': 'Why is $L= \\{ 0^n 1^n | n \\geq 1 \\}$ not regular language?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-22T20:37:44.957', 'LastEditDate': '2012-05-22T20:37:44.957', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<formal-languages><regular-languages><intuition>', 'CreationDate': '2012-05-14T02:35:11.657', 'Id': '1830'},2013:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '783', 'Title': 'Rule of thumb to know if a problem could be NP-complete', 'LastEditDate': '2012-05-16T01:26:33.580', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '851', 'FavoriteCount': '3', 'Body': '<p>This question was inspired by <a href="http://stackoverflow.com/questions/10589995/algorithm-have-a-set-of-points-g-that-can-see-other-points-c-need-an-al/10590173#comment13716914_10590173">a comment on StackOverflow</a>.</p>\n\n<p>Apart from knowing NP-complete problems of the Garey Johnson book, and many others; is there a rule of thumb to know if a problem looks like an NP-complete one?</p>\n\n<p>I am not looking for something rigorous, but to something that works in most cases.</p>\n\n<p>Of course, every time we have to prove that  a problem is NP-complete, or a slight variant of an NP-complete one; but before rushing to the proof it would be great to have certain confidence in the positive result of the proof.</p>\n', 'Tags': '<complexity-theory><np-complete><intuition>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-17T17:15:47.970', 'CommentCount': '4', 'AcceptedAnswerId': '1863', 'CreationDate': '2012-05-15T18:27:59.127', 'Id': '1859'},2014:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I get the proof of going from an enumerator to a Turing Machine (keep running enumerator and see if it matches input) but I don't see how the other way works.</p>\n\n<p>According to my notes and the book (Intro to the Theory of Computation - Sipser), to get Turing enumerator from a Turing machine, we basically write all combinations of the alphabet. You then run the TM on this input, if it accepts print it out, replace with new string repeat ad infinitum.</p>\n\n<p>The problem I am having is surely this requires the language to be decidable. Otherwise it might get stuck on the third word in some infinite loop doomed never to accept or reject and certainly never print out the whole language. </p>\n\n<p>What am I missing?</p>\n", 'ViewCount': '117', 'Title': 'Turing Recognisable => enumerable', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-06T11:16:44.820', 'LastEditDate': '2012-06-06T11:16:44.820', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2239', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1759', 'Tags': '<computability><turing-machines><intuition>', 'CreationDate': '2012-06-05T19:38:42.417', 'Id': '2238'},2015:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '475', 'Title': 'How to feel intuitively that a language is regular', 'LastEditDate': '2012-06-16T16:14:26.113', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1877', 'FavoriteCount': '2', 'Body': '<p>Given a language $ L= \\{a^n b^n c^n\\}$, how can I say directly, without looking at production rules, that this language is not regular?</p>\n\n<p>I could use pumping lemma but some guys are saying just looking at the grammar that this is not regular one. How is it possible?</p>\n', 'Tags': '<formal-languages><regular-languages><pumping-lemma><intuition>', 'LastEditorUserId': '851', 'LastActivityDate': '2012-06-22T14:12:38.223', 'CommentCount': '5', 'AcceptedAnswerId': '2396', 'CreationDate': '2012-06-16T15:32:24.460', 'Id': '2393'},2016:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am not sure I see it. From what I understand, edges and vertices are complements for each other and it is quite surprising that this difference exists.</p>\n\n<p>Is there a good / quick / easy way to see that in fact finding a Hamiltonian path should be much harder than finding a Euler path?</p>\n', 'ViewCount': '332', 'Title': 'Is it intuitive to see that finding a Hamiltonian path is not in P while finding Euler path is?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-24T06:14:09.933', 'LastEditDate': '2012-07-21T05:02:56.917', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '2839', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1558', 'Tags': '<complexity-theory><graph-theory><np-complete><intuition>', 'CreationDate': '2012-07-20T08:16:19.113', 'Id': '2837'},2017:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>Below, assume we\'re working with an infinite-tape Turing machine.</em></p>\n\n<p>When explaining the notion of time complexity to someone, and why it is measured relative to the input size of an instance, I stumbled across the following claim:</p>\n\n<blockquote>\n  <p>[..] For example, it\'s natural that you\'d need more steps to multiply two integers with 100000 bits, than, say multiplying two integers with 3 bits.</p>\n</blockquote>\n\n<p>The claim is convincing, but somehow hand-waving. In all algorithms I came across, the larger the input size, the more steps you need. In more precise words, the time complexity is a <a href="http://mathworld.wolfram.com/IncreasingFunction.html">monotonically increasing function</a> of the input size.</p>\n\n<blockquote>\n  <p>Is it the case that time complexity is <em>always</em> an increasing function in the input size? If so, why is it the case? Is there a <em>proof</em> for that beyond hand-waving?</p>\n</blockquote>\n', 'ViewCount': '222', 'Title': 'Why larger input sizes imply harder instances?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-14T13:24:07.873', 'LastEditDate': '2012-08-14T02:13:38.747', 'AnswerCount': '3', 'CommentCount': '10', 'AcceptedAnswerId': '3181', 'Score': '11', 'OwnerDisplayName': 'user20', 'PostTypeId': '1', 'Tags': '<complexity-theory><time-complexity><intuition>', 'CreationDate': '2012-08-13T23:09:10.920', 'Id': '3161'},2018:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read many documents about <a href="https://en.wikipedia.org/wiki/Convolution" rel="nofollow"><em>convolution</em></a> in image processing, and most of them say about its formula, some additional parameters. No one explains the intuition and real meaning behind doing convolution on an image. For example, intuition of derivation on the graph is make it more linear for example.</p>\n\n<p>I think a quick summary of the definition is: convolution is multiplied overlap square between image and kernel, after that sum again and put it into anchor. And this doesn\'t make any sense with me.</p>\n\n<p>According to <a href="http://www.aishack.in/2010/08/image-convolution-examples/" rel="nofollow">this article about convolution</a> I cannot imagine why convolution can do some "unbelievable" things. For example, line and edge detection on the last page of this link. Just choose appropriate convolution kernel can make a nice effects (detect line or detect edge). </p>\n\n<p>Can anyone provide some intuition (doesn\'t need to have to be a neat proof) on how it can do that?</p>\n', 'ViewCount': '241', 'Title': 'Intuition for convolution in image processing', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-13T20:38:44.307', 'LastEditDate': '2012-08-16T09:55:11.913', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2538', 'Tags': '<terminology><intuition><graphics><computer-vision>', 'CreationDate': '2012-08-16T08:41:24.633', 'Id': '3215'},2019:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2134', 'Title': 'What are the characteristics of an $O(n \\log n)$ time complexity algorithm?', 'LastEditDate': '2013-02-26T07:32:50.337', 'AnswerCount': '6', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '7007', 'FavoriteCount': '3', 'Body': '<p>Sometimes it\'s easy to identify the time complexity of an algorithm my examining it carefully. Algorithms with two nested loops of $N$ are obviously $N^2$. Algorithms that explore all the possible combinations of $N$ groups of two values are obviously $2^N$.</p>\n\n<p>However I don\'t know how to "spot" an algorithm with $O(N \\log N)$ complexity. A recursive mergesort implementation, for example, is one. What are the common characteristics of mergesort or other $O(N \\log N)$ algorithms that would give me a clue if I was analyzing one?</p>\n\n<p>I\'m sure there is more than one way an algorithm can be of $O(N \\log N)$ complexity, so any and all answers are appreciated. BTW I\'m seeking general characteristics and tips, not rigorous proofs.</p>\n', 'Tags': '<algorithms><time-complexity><algorithm-analysis><intuition>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-26T19:08:10.450', 'CommentCount': '5', 'AcceptedAnswerId': '10102', 'CreationDate': '2013-02-25T21:02:00.667', 'Id': '10091'},20110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If you have a language L, without doing any proofs, is there a way to tell if it's recognizable or co-recognizable or decidable?</p>\n\n<p>Basically any hints or tricks that can be used to tell. Or maybe the common patterns to search for to tell which kind it is?</p>\n", 'ViewCount': '452', 'Title': 'How to tell if a language is recognizable, co-recognizable or decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T18:02:58.057', 'LastEditDate': '2013-04-23T09:12:19.267', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<computability><undecidability><intuition>', 'CreationDate': '2013-04-22T21:00:40.460', 'Id': '11500'},20111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What does it mean to multiply or divide polynomials?</p>\n\n<p>I have used them so many times, in error correcting codes, cryptography, etc. but it was never clear to me what would be a graphical representation/ interpretation.</p>\n\n<p>I have always pondered what did it mean when someone multiplies a line with a curve to get another hyperplane of a bigger dimension.</p>\n\n<p>I know the formulae and properties of polynomial multiplication &amp; division, I am specifically looking for a graphical/algebraic interpretation of it.</p>\n', 'ViewCount': '109', 'Title': 'What does it mean to multiply or divide polynomials?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-20T03:52:30.580', 'LastEditDate': '2013-09-18T09:15:33.427', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<mathematical-analysis><intuition><polynomials>', 'CreationDate': '2013-09-18T00:11:09.867', 'Id': '14393'},20112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose you have an NP problem, and a polynomial time verifier which accepts valid solutions within <code>f(n)</code> operations.</p>\n\n<p>You make a tweak to the verifier program, so that if it takes more than <code>f(n)</code> operations it unconditionally rejects. Then you place it into an NP machine and run it on all possible certificates for some instance of the problem where you\'re not sure if it has a solution. The unconditional reject after <code>f(n)</code> operations ensures the computation terminates within <code>f(n)</code> operations, even when rejecting. So this NP machine can solve the co-NP dual of the NP problem, where you want to reject in polynomial time when there is no solution.</p>\n\n<p>Except that can\'t be right, because it seems to imply <code>NP=co-NP</code> and that\'s not believed to be true. I have an incorrect assumption or inference somewhere. What is it? Why can\'t I avoid NP\'s "negatives might run for a long time or even forever" with algorithm-specific time cutoffs?</p>\n\n<p>A concrete example: suppose you have a 3-SAT verifier that takes no more than <code>42 n^2</code> operations to check a solution to an <code>n</code> clause problem (involving up to <code>3n</code> variables). You then make an NP program like "non-deterministically choose a variable assignment, run verifier for up to 42 n^2 steps, return its result else reject if it didn\'t finish". So within <code>42 n^2</code> operations we\'ll have an answer, and flipping it gives the "is there no satisfying assignment" answer. Why is this not an NP algorithm for the co-NP problem of determining if there is no satisfying assignment to a 3-SAT problem?</p>\n', 'ViewCount': '41', 'Title': "Why doesn't a time cutoff convert NP problems into co-NP?", 'LastEditorUserId': '535', 'LastActivityDate': '2014-03-02T21:08:48.943', 'LastEditDate': '2014-03-02T20:56:00.557', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '535', 'Tags': '<np><intuition><paradox><co-np>', 'CreationDate': '2014-03-02T20:31:20.237', 'FavoriteCount': '2', 'Id': '22204'}