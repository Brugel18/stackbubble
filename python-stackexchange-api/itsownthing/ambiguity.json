{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>My problem is how can I prove that a grammar is unambiguous?\nI have the following grammar:\n$$S\n\u2192 statement\n\u2223 \\mbox{if } expression \\mbox{ then } S\n\u2223 \\mbox{if } expression \\mbox{ then } S \\mbox{ else } S$$</p>\n\n<p>and make this to an unambiguous grammar, I think its correct:</p>\n\n<ul>\n<li><p>$ S \u2192 S_1 \u2223 S_2 $</p></li>\n<li><p>$S_1\n\u2192 \\mbox{if } expression \\mbox{ then } S\n\u2223 \\mbox{if } expression \\mbox{ then } S_2 \\mbox{ else } S_1$</p></li>\n<li><p>$S_2\n\u2192 \\mbox{if } expression \\mbox{ then } S_2 \\mbox{ else } S_2\n\u2223 statement$</p></li>\n</ul>\n\n<p>I know that a unambiguous grammar has one parse tree for every term.</p>\n', 'ViewCount': '3778', 'Title': 'How to prove that a grammar is unambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-09T13:50:57.277', 'LastEditDate': '2013-02-09T13:50:57.277', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1594', 'Tags': '<context-free><formal-grammars><proof-techniques><ambiguity>', 'CreationDate': '2012-06-10T17:15:32.787', 'FavoriteCount': '4', 'Id': '2320'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the grammar: </p>\n\n<p>$\\qquad \\begin{align}\n S &amp;\\to S = P \\mid S \\neq P \\mid P  \\\\\n P &amp;\\to NUM\n\\end{align}$</p>\n\n<p>This grammar suffers from left recursion. To eliminate left recursion, I got: </p>\n\n<p>$\\qquad \\begin{align}\n S &amp;\\to PS' \\\\\n S' &amp;\\to\\, = PS' \\mid\\, \\neq PS' \\mid \\varepsilon \\\\\n P &amp;\\to NUM\n\\end{align}$</p>\n\n<p>However when constructing the LL(1) parsing table, it turns out the grammar is ambiguous. Is there a way to disambiguate the grammar without changing the generated language, or did I make a mistake somewhere?</p>\n\n<p>This is my work so far: </p>\n\n<pre><code>Non-terminal Nullable First            Follow\nS            False    NUM              $\n    S'           True     !=, ==, epsilon  $\nP            False    NUM              $, ==, !=\n\nParse Table\n     !=       ==    NUM      $\nS                   -&gt;PS'\nS'  -&gt;!=PS'  -&gt;==PS'        -&gt;epsilon\nP                   -&gt;NUM\n</code></pre>\n", 'ViewCount': '270', 'Title': 'Is this grammar ambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-16T22:57:05.150', 'LastEditDate': '2012-07-17T22:44:58.257', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'OwnerDisplayName': 'barq', 'PostTypeId': '1', 'Tags': '<formal-grammars><parsers><ambiguity>', 'CreationDate': '2012-05-17T22:56:12.917', 'Id': '2794'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What I mean by a "symbolic regular expression" (if there already is a different name for this I\'m not aware of it) is a regular expression that may include exponents that are symbolic arithmetic expressions.  </p>\n\n<p>Example 1: $a^k|b^*$ means "either $k$ copies of $a$ or zero or more copies of $b$".<br>\nExample 2: $a^{k+1}|a^k$ means "either $k$ or $k+1$ copies of $a$".</p>\n\n<p>What I\'d like to do is disambiguate such regular expressions.  I know that to disambiguate a normal regular expression, you can convert it to an NFA, then a DFA, then back to a regular expression.</p>\n\n<p>The problem is not completely straightforward.  For example, $a^k|a^j$ is ambiguous if $j=k$ and unambiguous otherwise.  Thus, the appropriate output would be, for example,\n$$a^k \\text{ if } k=j, \\qquad a^k|a^j \\text{ otherwise.}$$</p>\n\n<p>Does anyone know if there has been anything written about this problem?</p>\n', 'ViewCount': '135', 'Title': 'How to disambiguate symbolic regular expressions', 'LastActivityDate': '2012-08-09T22:51:51.757', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2242', 'Tags': '<formal-languages><reference-request><regular-languages><regular-expressions><ambiguity>', 'CreationDate': '2012-08-09T22:51:51.757', 'Id': '3112'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '160', 'Title': 'What precisely is infinite ambiguity in a grammar?', 'LastEditDate': '2012-10-28T13:39:38.737', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': u'Jakub L\xe9dl', 'PostTypeId': '1', 'OwnerUserId': '4383', 'Body': "<p>From what I've read, an example of infinite ambiguity is usually given in a form of a loop:</p>\n\n<p>$S \\rightarrow aA \\\\\nA \\rightarrow B \\\\\nB \\rightarrow A \\\\\nB \\rightarrow b$</p>\n\n<p>But a grammar is called <em>ambiguous</em> if there's more than 1 way to derive the input string &omega;. What if I then take this well-known ambiguous grammar:</p>\n\n<p>$S \\rightarrow SSS \\\\\nS \\rightarrow SS \\\\\nS \\rightarrow b$</p>\n\n<p>and extend it with $S \\rightarrow \\epsilon$\nso that for any member of $\\left\\{ b^n \\middle| n \\geq 0\\right\\}$ there's infinitely many ways to derive it? Does this make the grammar <em>infinitely</em> ambiguous?</p>\n", 'Tags': '<terminology><formal-grammars><ambiguity>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T10:22:03.010', 'CommentCount': '1', 'AcceptedAnswerId': '9228', 'CreationDate': '2012-10-27T22:17:07.123', 'Id': '6357'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A <a href="http://en.wikipedia.org/wiki/Formal_grammar" rel="nofollow">grammar</a> is <em><a href="http://en.wikipedia.org/wiki/Ambiguous_grammar" rel="nofollow">ambiguous</a></em> if at least one of the words in the\nlanguage it defines can be parsed in more than one way. A simple example of an ambiguous grammar\n$$\n   E \\rightarrow E+E \\ |\\ E*E \\ |\\ 0 \\ |\\ 1 \\ |\\ ...\n$$\nbecause the string 1+2*3 can be parsed as (1+2)*3 and 1+(2*3).  For\ncontext free grammars (CFGs) ambiguity is not decidable [1, 2]. This implies that non-ambiguity is also not decidable. Moreover, at least one of ambiguity and\nnon-ambiguity cannot even be recursively enumerable, for otherwise\nambiguity of a given CFG $G$ could be decided by running the\nenumeration of ambiguity and non-ambiguity together and seeing which\none contains $G$ (and one of them must).</p>\n\n<p>So which problem is harder in this sense? Ambiguity or non-ambiguity?</p>\n\n<ol>\n<li><p>D. G. Cantor, On The Ambiguity Problem of Backus Systems.</p></li>\n<li><p>R. W. Floyd, On ambiguity in phrase structure languages.</p></li>\n</ol>\n', 'ViewCount': '127', 'Title': 'Hardness of ambiguity/non-ambiguity for context-free grammars', 'LastEditorUserId': '2887', 'LastActivityDate': '2012-11-03T16:47:16.880', 'LastEditDate': '2012-11-03T16:47:16.880', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6464', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<computability><formal-grammars><context-free><undecidability><ambiguity>', 'CreationDate': '2012-11-03T14:29:51.043', 'Id': '6463'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '550', 'Title': 'Inherent ambiguity of the language $L_2 = \\{a^nb^mc^m \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^m \\;|\\; m,n \\geq 1\\}$', 'LastEditDate': '2012-11-09T06:57:09.207', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4422', 'FavoriteCount': '0', 'Body': "<p>I went through a question asking me to choose the inherently ambiguous language among a set of options.</p>\n\n<p>$$L_1 = \\{a^nb^mc^md^n \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^md^m \\;|\\; m,n \\geq 1\\}$$\n$$and$$\n$$L_2 = \\{a^nb^mc^m \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^m \\;|\\; m,n \\geq 1\\}$$</p>\n\n<p>The solution said that $L_1$ is ambiguous while $L_2$ isn't. It generated the following grammar for $L_1$</p>\n\n<p>$S \\rightarrow S_1\\;|\\;S_2$</p>\n\n<p>$S_1 \\rightarrow AB$</p>\n\n<p>$A \\rightarrow aAb\\;|\\;ab$</p>\n\n<p>$B \\rightarrow cBd\\;|\\;cd$</p>\n\n<p>$S_2 \\rightarrow aS_2d\\;|\\;aCd$</p>\n\n<p>$C \\rightarrow bCc\\;|\\;bc$</p>\n\n<p>Now for the string <code>abcd</code>, it will generate two parse trees; so it is ambiguous.</p>\n\n<p>But a similar grammar can be created for $L_2$ too</p>\n\n<p>$S \\rightarrow S_1|S_2$</p>\n\n<p>$S_1 \\rightarrow Ac$</p>\n\n<p>$A \\rightarrow aAb\\;|\\;\\epsilon$</p>\n\n<p>$S_2 \\rightarrow aB$</p>\n\n<p>$B \\rightarrow bBc\\;|\\;\\epsilon$</p>\n\n<p>And it will also generate two parse trees for <code>abc</code>. Why isn't it ambiguous then?</p>\n\n<p>If you need,\n$L_2$ can be written as $\\{a^nb^pc^m\\;|\\; n=p \\;\\; or \\;\\; m=p\\}$</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free><ambiguity>', 'LastEditorUserId': '4422', 'LastActivityDate': '2012-11-09T06:57:09.207', 'CommentCount': '4', 'AcceptedAnswerId': '6573', 'CreationDate': '2012-11-09T04:40:14.713', 'Id': '6568'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Say I have a context-free grammar defined by the following rule.</p>\n\n<p>$$\n\\langle EXPR\\rangle \\rightarrow \\langle EXPR\\rangle + \\langle EXPR\\rangle~|~\\langle EXPR\\rangle \\times \\langle EXPR\\rangle~|~(\\langle EXPR \\rangle)~|~x\n$$</p>\n\n<p>This grammar is ambiguous since, for instance, I can generate the string $x + x \\times x$ via more than 1 leftmost derivation.</p>\n\n<p>How could I make this grammar unambiguous? Should I make sure that no $\\langle EXPR\\rangle + \\langle EXPR\\rangle$ is evaluated after a $\\langle EXPR\\rangle \\times \\langle EXPR\\rangle$ as such:</p>\n\n<p>$$\n\\langle EXPR\\rangle \\rightarrow \\langle EXPR\\rangle + \\langle EXPR\\rangle~|~\\langle MUL\\_EXPR\\rangle \\times \\langle MUL\\_EXPR\\rangle~|~(\\langle EXPR \\rangle)~|~x \\\\\n\\langle MUL\\_EXPR \\rangle \\rightarrow \\langle EXPR\\rangle \\times \\langle EXPR\\rangle~|~(\\langle EXPR \\rangle)~|~x \\\\\n$$</p>\n', 'ViewCount': '427', 'Title': 'In general, how does one make a context-free grammar unambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-16T10:51:37.453', 'LastEditDate': '2013-01-16T10:19:57.650', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<formal-grammars><context-free><ambiguity>', 'CreationDate': '2012-12-16T18:45:58.600', 'FavoriteCount': '0', 'Id': '7443'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp;A1B \\\\\nA \\rightarrow &amp; 0A \\mid \\varepsilon \\\\\nB \\rightarrow &amp; 0B \\mid 1B \\mid \\varepsilon \\\\\n\\end{align}\n$$</p>\n\n<p>How can I show that this grammar is unambiguous? I need to find a grammar for the same language that is ambiguous, and demonstrate it.</p>\n\n<p>I know if I was asked to prove that the language is ambigious then I should find two different parse trees for same string, but I don't know what to do.</p>\n", 'ViewCount': '848', 'Title': 'How to show that given language is unambiguous', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-30T18:31:28.237', 'LastEditDate': '2012-12-22T07:00:56.657', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7519', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5137', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><ambiguity>', 'CreationDate': '2012-12-20T00:20:48.643', 'Id': '7518'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The basic idea is to have one or more symbol that clearly indicate the end. For example:</p>\n\n<p>Non-ambiguous:</p>\n\n<blockquote>\n  <p>$ab^*c$<br>\n  $(a|b)c$<br>\n   $ab^+c$<br>\n   $ab?c$<br>\n   $a(b|c)$<br>\n   $c(ab)^*ccc$<br>\n   $acc^*d$<br>\n   $abc|bcd$  </p>\n</blockquote>\n\n<p>Ambiguous:</p>\n\n<blockquote>\n  <p>$abc^*$<br>\n  $abc^+$<br>\n  $abc?$<br>\n  $acc^*$ or $ac^*c$</p>\n</blockquote>\n\n<p>An alternative definition of a non-ambiguous ending would be that the corresponding DFA can have multiple final states, but none of them can have a outgoing transition.</p>\n', 'ViewCount': '194', 'Title': 'Is there a name/interest for regular languages that have a non-ambiguous ending?', 'LastEditorUserId': '1053', 'LastActivityDate': '2013-01-25T16:19:20.677', 'LastEditDate': '2013-01-25T15:20:19.237', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9094', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1053', 'Tags': '<regular-languages><finite-automata><regular-expressions><ambiguity>', 'CreationDate': '2013-01-22T12:50:22.110', 'Id': '9091'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there an algorithm which decides whether a regular tree grammar $G$ is ambiguous, i.g. there exists a tree $t\\in L(G)$ which can be parsed by the grammar in more than one ways, using only leftmost derivations?</p>\n\n<p>Is there a proof available about the decidability, or a cite to a paper which proposes such an algorithm?</p>\n', 'ViewCount': '241', 'Title': 'Is the ambiguity of a regular tree grammar decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:40:05.507', 'LastEditDate': '2013-02-14T06:40:05.507', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6866', 'Tags': '<formal-languages><computability><formal-grammars><ambiguity><tree-grammars>', 'CreationDate': '2013-02-13T15:29:34.530', 'Id': '9745'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '84', 'Title': 'Priority in formal grammar', 'LastEditDate': '2013-02-28T11:20:49.453', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4409', 'FavoriteCount': '1', 'Body': '<p>From my recitation class, I have the following exercise:</p>\n\n<blockquote>\n  <p>$\\mathrm{EXP} = 0 \\mid 1 \\mid b \\mathrm{EXP} \\mid \\mathrm{EXP} a \\mid \\mathrm{EXP} m \\mathrm{EXP}$</p>\n  \n  <p>The above grammar is ambiguous.</p>\n  \n  <p>Make an unambiguous grammar which produce same language as the above.</p>\n  \n  <p>In the new grammar, $a$ has priority over $b$ and $b$ has priority over $m$.\n  Also $m$ is associative.</p>\n</blockquote>\n\n<p>Can you explain what the phrases</p>\n\n<ul>\n<li>"has priority over" and</li>\n<li>"$m$ is associative"</li>\n</ul>\n\n<p>mean?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsing><ambiguity>', 'LastEditorUserId': '4409', 'LastActivityDate': '2013-02-28T14:58:59.373', 'CommentCount': '1', 'AcceptedAnswerId': '10151', 'CreationDate': '2013-02-27T19:11:49.933', 'Id': '10142'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm reading the book: <em>Formal Syntax and Semantics of Programming Languages</em>. I don't understand this exercise:</p>\n\n<blockquote>\n  <p>Consider the following two grammars, each of which generates strings of correctly balanced parentheses and brackets. Determine if either or both is ambiguous. The Greek letter \u03b5 represents an empty string.</p>\n\n<pre><code>&lt;string&gt; ::= &lt;string&gt; &lt;string&gt; | ( &lt;string&gt; ) | [ &lt;string&gt; ] | \u03b5\n&lt;string&gt; ::= ( &lt;string&gt; ) &lt;string&gt; | [ &lt;string&gt; ] &lt;string&gt; | \u03b5\n</code></pre>\n</blockquote>\n", 'ViewCount': '135', 'Title': 'Determine if two grammars for the same language are ambiguous', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-08-12T08:46:36.553', 'LastEditDate': '2013-08-11T19:28:59.790', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13718', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9615', 'Tags': '<context-free><formal-grammars><ambiguity>', 'CreationDate': '2013-08-11T19:12:20.367', 'Id': '13711'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I prove, or where can I find proof that for every regular language there is unambigous grammar?</p>\n', 'ViewCount': '379', 'Title': 'Proof that there is unambigous grammar for every regular language', 'LastActivityDate': '2013-10-14T19:42:49.000', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16085', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10738', 'Tags': '<proof-techniques><ambiguity>', 'CreationDate': '2013-10-14T17:57:05.787', 'Id': '16082'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading through Context Free Grammar, and I came across ambiguous grammar. If the language produced by CFG has more then 1 parse tree, then CFG is an ambiguous grammar. Is there any way by which I can find out or prove that the grammar is Unambiguous. In general I can test some language produced by CFG and check whether more than 1 parse tree is generated from that language, to show that grammar is ambiguous. But how do I check or prove that give CFG is unambiguous?</p>\n', 'ViewCount': '13', 'ClosedDate': '2014-02-02T13:21:21.190', 'Title': 'Unambiguous Context free Grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:21:32.037', 'LastEditDate': '2014-02-02T13:21:32.037', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13042', 'Tags': '<formal-languages><context-free><formal-grammars><ambiguity>', 'CreationDate': '2014-02-02T08:51:12.323', 'Id': '20205'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a VHDL elaboration engine/simulator. As I understand it, the language syntax allows for ambiguities at syntax level. That is, an assignment</p>\n\n<pre><code>pin_value &lt;= bus(5)\n</code></pre>\n\n<p>can be interpreted as picking a child of the bus by index. Here the bus is a signal (an object). However, it can also be that paranthis are applied to a type</p>\n\n<pre><code>int_signal &lt;= integer(1.1)\n</code></pre>\n\n<p>which should be interpreted as type conversion.</p>\n\n<p>I wonder. The elaborator should take the parse tree, instantiate objects and tie them together resolving the names. However, the parser has no idea if the prefix at the parensis is a type or array. So, it treats all parensis as indexed objects.</p>\n\n<pre><code>simple_assignment ::= target &lt;= value_expression { , value_expression } \nvalue_expression ::= name | literal | function_call | type_conversion \nname ::= simple_name | indexed_name \nindexed_name ::= prefix ( expression { , expression } ) // example: REG_ARRAY(5)    \ntype_conversion ::= type_mark ( expression )\n</code></pre>\n\n<p>I do not see how can I distinguish between value_expression and type_conversion at syntactic level. My parser parses both as indexed_name and name resolution, when fails to find array object, falls back into type conversion. I am asking if such case analysis it the only way to handle the problem or more strighnforward approach exists that I am missing?</p>\n', 'ViewCount': '49', 'Title': 'parsing at semantic level due to ambiguities', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T22:10:45.090', 'LastEditDate': '2014-04-22T22:10:45.090', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<formal-grammars><parsers><ambiguity>', 'CreationDate': '2014-04-22T20:11:35.043', 'Id': '24032'}