{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>The problem is:</p>\n\n<p>$$\\exists x \\forall y (x \\ge y)$$</p>\n\n<p>With a domain of all real positive integers.</p>\n\n<p>The negation is:</p>\n\n<p>$$\\forall x \\exists y (x &lt; y)$$</p>\n\n<p>so, if $y = x + 1$, the negation is true.</p>\n\n<p>That means the negation of the negation (i.e. the original problem) is false.</p>\n\n<p>My question is, that if the original problem is $\\exists x \\forall y (x \\ge y)$, why can't I take $x = y$ and prove the problem true?</p>\n", 'ViewCount': '179', 'Title': 'Negation of nested quantifiers', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-08T14:14:31.510', 'LastEditDate': '2012-09-08T14:14:31.510', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '3464', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2756', 'Tags': '<logic><first-order-logic>', 'CreationDate': '2012-09-08T02:28:48.533', 'Id': '3463'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've read first-order logic is in general undecidable, and that could be decidable only when working with unary operators. (I think that's propositional logic, correct me if I am wrong)</p>\n\n<p>The question is <strong>why arity leads to undecidable problems?</strong></p>\n\n<p>I would like to see some reference material, or at least some simple <em>example</em> of it, as a way to think in this passage from unary to n-ary and why it leads to undecidable problems. </p>\n", 'ViewCount': '157', 'Title': 'First-order logic arity defines decidability?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T10:58:10.357', 'LastEditDate': '2012-11-05T17:16:52.103', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6489', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<reference-request><logic><undecidability><satisfiability><first-order-logic>', 'CreationDate': '2012-11-05T15:10:08.337', 'Id': '6488'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Going through <a href="http://www.cs.toronto.edu/~sheila/384/w11/">some knowledge representation tutorials</a> on resolution at the moment, and I came across <a href="http://www.cs.toronto.edu/~sheila/384/w11/Lectures/csc384w11-Lecture-05-KR.pdf">slide 05.KR, no77</a>.</p>\n\n<p>There it is mentioned that "the procedure is also complete". </p>\n\n<p>I think this completeness can not mean that if a sentence is entailed by KB, then it will be derived by resolution. For example, resolution can not derive $(q \\lor \\neg q)$ from a KB with single clause $\\neg p$. (Example from KRR, Brachman and Levesque, page 53).</p>\n\n<p>Could anyone help me figure out what is meant in this slide? Is the completeness of slide refer to being refutaton-complete and not a complete proof procedure?</p>\n', 'ViewCount': '439', 'Title': 'Is resolution complete or only refutation-complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-11T06:34:56.667', 'LastEditDate': '2013-01-22T21:05:22.287', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9096', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6508', 'Tags': '<logic><first-order-logic>', 'CreationDate': '2013-01-22T17:44:02.287', 'Id': '9095'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have been reading on converting first order logic sentences to conjunctive normal form, and then performing resolution.</p>\n\n<p>One of the steps of converting to CNF, is to Standardize variables: rename all variables so that each quantifier has its own unique variable name.</p>\n\n<p>Most general Unifier is the least specialized unification of two clauses.</p>\n\n<p>Question 1: I have been searching to find an example that shows what are the potential problems if I don\'t standardize variables, but all the online resources I found only explain the "How" and not the "Why". Could you provide me with an example of a potential problem?</p>\n\n<p>Question 2: The same problem as the first question. What if we don\'t use MGU, and use a more specialized unifier? What are the potential problems? Could you provide me with an example?</p>\n\n<p>My sincere thanks.\nFelipe</p>\n', 'ViewCount': '112', 'Title': 'MGU and Variable Standardization - CNF', 'LastActivityDate': '2013-01-27T21:31:17.487', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9224', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2436', 'Tags': '<logic><artificial-intelligence><knowledge-representation><first-order-logic>', 'CreationDate': '2013-01-27T02:24:52.357', 'Id': '9186'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am currently reading "Artificial Intelligence - A modern approach" and I really do not get the difference between intended interpretation and extended interpretation in first-order logic.</p>\n\n<p>Are extended interpretations all possible assignments from a symbol in my knowledge base to an object in the world? And is the intended interpretation the interpretation the "author" of the sentences wanted to have?</p>\n\n<p>So when there is a symbol like "John" in my sentences does that mean that it really refers to the human being John in the real world (if I have intended interpretation).</p>\n\n<p>And the extended interpretation could be: "John" in my sentences refers to the human being Mary in the real world.</p>\n\n<p>Are the extended interpretations a set of all possible interpretations and is the intended interpretation one specific interpretation in this set?</p>\n\n<p>So do I interpret my sentences either intended or extended?</p>\n\n<p>And if I say in my interpretation that John and Mary (as constants) refer to the same object in my model can I unify them then, i.e. UNIFY(John,Mary) = {John/Mary}?</p>\n', 'ViewCount': '124', 'Title': 'Difference between intended interpretation and extended interpretation in first-order logic', 'LastActivityDate': '2013-02-08T10:00:40.560', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6735', 'Tags': '<logic><artificial-intelligence><first-order-logic>', 'CreationDate': '2013-02-06T17:26:31.733', 'Id': '9552'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Assuming I have shown part of the knowledge base in the clausal format:</p>\n\n<pre><code>[1] p1(banana).\n\n[2] not p1(X) or p2(Y).\n[3] p1(X) or not p3(F).\n</code></pre>\n\n<p>... and more rules.</p>\n\n<p>Most of the books, would do something like this:</p>\n\n<pre><code>[1,2] {X=banana} p2(Y).\n</code></pre>\n\n<p>and more steps.</p>\n\n<p>First question: is it equally correct to do something like follows:</p>\n\n<pre><code>[2,3] {X=X} p2(Y) or not p3(F).\n</code></pre>\n\n<p>and then continue with resolution.</p>\n\n<p>Second question: What if different variables were used in each clause, could I do the same as above, for example we had:</p>\n\n<pre><code>[2] not p1(X1) or p2(Y1).\n[3] p1(X2) or not p3(F2).\n\n[2,3] {X1=X2} p2(Y) or not p3(F2).\n</code></pre>\n\n<p>Thank you in advance</p>\n', 'ViewCount': '197', 'Title': 'first order logic resolution unification', 'LastEditorUserId': '6966', 'LastActivityDate': '2013-02-24T23:10:37.647', 'LastEditDate': '2013-02-24T23:10:37.647', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10060', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6966', 'Tags': '<artificial-intelligence><first-order-logic><knowledge-representation>', 'CreationDate': '2013-02-24T18:11:41.153', 'Id': '10059'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Suppose $\\sigma$ is a vocabulary of First Order logic consisting of one binary relation $E$ and let $\\phi$ be a $\\sigma$ sentence (FO formula with no free variables). Is it decidable whether there is a finite directed graph $G$, with all in- and out-degrees $0$ or $1$, such that $G\\models \\phi$ ?</p>\n', 'ViewCount': '114', 'Title': 'Decidability over finite graphs of small degree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-14T15:24:32.167', 'LastEditDate': '2013-03-14T15:24:32.167', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<graphs><logic><undecidability><first-order-logic><finite-model-theory>', 'CreationDate': '2013-03-13T10:55:07.910', 'Id': '10509'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>The rules I am considering are $\\frac{\\neg A, \\ \\Gamma \\implies \\Delta}{\\Gamma \\implies \\Delta, \\ A} (\\neg L)$ and $\\frac{\\Gamma \\implies \\Delta, \\ \\neg A}{A, \\ \\Gamma \\implies \\Delta} (\\neg R)$</p>\n\n<p>I am trying to get my head around some of the sequent calculus rules, and while I think I understand most of them, I am struggling to apply any intuition to the negation rules shown above.</p>\n\n<p>The intuition of looking at the left as a conjunction of literals and the right as a disjunction of literals seems to break down, and I am unclear how to explain these rules to myself.</p>\n\n<p>What is a sensible way to view such rules and put some understanding on them?</p>\n', 'ViewCount': '100', 'Title': 'Why do the sequent calculus NOT left and NOT right rules work?', 'LastActivityDate': '2013-05-20T10:42:06.080', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '12151', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7928', 'Tags': '<logic><first-order-logic>', 'CreationDate': '2013-05-20T09:48:59.810', 'Id': '12150'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '140', 'Title': 'Differences between basic, complex and terminological facts in a Knowledge Base using First-Order Logic', 'LastEditDate': '2013-06-23T16:02:05.360', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8759', 'FavoriteCount': '1', 'Body': '<p>I\'ve been reading the excellent book <a href="http://books.google.pt/books/about/Knowledge_representation_and_reasoning.html?id=OuPtLaA5QjoC&amp;redir_esc=y" rel="nofollow">Knowledge Representation and Reasoning</a> by Ronald Brachman and Hector Levesque.</p>\n\n<p>In the beginning of Section 3.2 "Vocabulary" of Chapter 3 "Expressing Knowledge" they state:</p>\n\n<blockquote>\n  <p>In creating a KB (Knowledge Base) it is a good idea to start with the set of domain-dependent predicates and functions that provide the basis for the facts about the KB\'s domain.</p>\n</blockquote>\n\n<p>In the same section these facts are separated in three categories:</p>\n\n<ul>\n<li>Basic facts</li>\n<li>Complex facts</li>\n<li>Terminological facts</li>\n</ul>\n\n<p>After reading the entire chapter I could not entirely understand the differences between these types of facts.</p>\n\n<p>Can someone help me to understand the differences in these concepts?</p>\n', 'Tags': '<terminology><logic><knowledge-representation><first-order-logic><reasoning>', 'LastEditorUserId': '8759', 'LastActivityDate': '2013-08-16T06:14:52.863', 'CommentCount': '0', 'AcceptedAnswerId': '13748', 'CreationDate': '2013-06-23T14:57:35.450', 'Id': '12841'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>In my descriptive complexity class, we've been asked to find a formula that characterises the language $(aa)^*$ (over the alphabet $\\{a\\}$) with a first order formula over the language $\\{&lt;, P_a\\}$.</p>\n\n<p>This was the first class, so I will recall what we've learned to be sure that I understood. To a $L$-formula $\\phi$ we associate a language $\\mathcal L(\\phi)$ which is the class of all $L$-structures in which $\\phi$ is valid.</p>\n\n<p>In my case, we then are looking for a $\\{&lt;, P_a\\}$-formula for which words of even length are models. I guess I have to say in $\\phi$ that $&lt;$ is a total order, so that I can interpret the models as words, and that $\\forall x, P_a(x)$ to say that all points are labelled as 'a'. But how to say that there has to be an even number of points in the model? The definition of having an even number of points seems recursive, so I get the impression that a formula for $(aa)^*$ should be of infinite length in first-order logic..</p>\n", 'ViewCount': '115', 'Title': 'Characterising $(aa)^*$ in first order logic', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-23T11:22:12.363', 'LastEditDate': '2013-09-23T07:23:27.313', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14548', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10157', 'Tags': '<formal-languages><regular-languages><logic><first-order-logic>', 'CreationDate': '2013-09-23T06:16:13.087', 'Id': '14545'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $x=(x_1,\\dots,x_n)$ and $y=(y_1,\\dots,y_n)$ be $n$-vectors of boolean variables.  I have a boolean predicate $Q(x,y)$ on $x,y$.  I give my friend Priscilla $Q(x,y)$.  In response, she gives me $P(x)$, a boolean predicate on $x$, and she claims that</p>\n\n<p>$$P(x) \\equiv \\exists y . Q(x,y),$$</p>\n\n<p>or in other words, that</p>\n\n<p>$$\\forall x . [P(x) \\Leftrightarrow \\exists y . Q(x,y)].$$</p>\n\n<p>I would like to verify her claim somehow.  How can Priscilla help me verify this claim?</p>\n\n<p>You can assume that both $P$ and $Q$ are represented as CNF formulas, and that they\'re not too large (polynomial size, or something).</p>\n\n<p>In an ideal world, it\'d be awesome if I could reduce the problem of verifying this claim to SAT: I have a SAT solver, and it\'d be great if I can use the SAT solver to verify this claim.  However, I\'m pretty sure that it\'s not going to be possible to formulate the problem of verifying this claim directly as a SAT instance; <a href="http://cstheory.stackexchange.com/q/11022/5038">testing the validity of a 2QBF formula</a> is almost certainly harder than SAT.  (The $\\Leftarrow$ direction is easy to formulate as a SAT instance, but the $\\Rightarrow$ direction is hard because it inherently involves two alternating quantifiers.)</p>\n\n<p>But suppose Priscilla could give me some additional evidence to support her claim.  Is there some additional evidence or witness Priscilla could give me, which would make it easy for me to verify her claim?  In particular, is there some additional evidence or witness she could give me, which would make it easy for me to formulate the problem of verifying her claim as an instance of SAT (which I can then apply my SAT solver to)?</p>\n\n<p>One unusual aspect of my setting is that I\'m assuming (heuristically) that I have an oracle for SAT.  If you like complexity theory, you can think about it this way: I am taking the role of a machine that can compute things in $P^{NP}$ (i.e., in $\\Delta^P_2$), and I\'m looking to verify Priscilla\'s claim using an algorithm in $P^{NP}$.  My thanks to mdx for this way of thinking about things.</p>\n\n<hr>\n\n<p>My motivation/application: I\'m looking to do formal verification of a system (e.g., symbolic model checking), and a key step in the reasoning involves quantifier elimination (i.e., starting from $Q$, obtain $P$).  I\'m hoping for some clean way to verify that the quantifier elimination was done correctly.</p>\n\n<p>If there\'s no solution that works for all possible $P,Q$, feel free to suggest a solution that is "sound but not complete", i.e., a technique that for many $P,Q$ lets me verify the claimed equivalence. (Even if it fails to verify the claim on some $P,Q$ that do satisfy the claim, I can still try this as a heuristic, as long as it never inappropriately claims to have verified a false claim.  On any given $P,Q$, it might work, or it might not; if it doesn\'t work, I\'m no worse off than where I started.)</p>\n', 'ViewCount': '109', 'Title': 'Verify correctness of quantifier elimination, using SAT', 'LastEditorUserId': '755', 'LastActivityDate': '2013-10-09T00:35:46.483', 'LastEditDate': '2013-10-07T02:09:21.303', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<logic><satisfiability><first-order-logic><software-verification><model-checking>', 'CreationDate': '2013-10-04T20:40:24.817', 'FavoriteCount': '2', 'Id': '14816'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>It is well known that in Descriptive Complexity Theory FO is equivalent to AC0.</p>\n\n<p>However, this accepts a couple of a theory and a string <code>&lt;T,s&gt;</code> iff the interpretation of s as a query is satisfied by the theory T.</p>\n\n<p>My question now is if there is an interpretation of which is stronger than AC0. For example, is there an interpretation of s as a theory so that the formalism accepts if s is a theory that is logically entailed by T. This problem is undecidable, but maybe it is possible to express problems in it which are stronger than AC0. (Reachability would be an interesting example if anyone could make this work)</p>\n', 'ViewCount': '61', 'Title': 'On the Turing Completeness of First Order Logic', 'LastActivityDate': '2013-11-20T11:53:17.923', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '11502', 'Tags': '<complexity-theory><logic><turing-completeness><first-order-logic>', 'CreationDate': '2013-11-20T11:53:17.923', 'FavoriteCount': '1', 'Id': '18197'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>While reading an <a href="http://lesswrong.com/lw/93q/completeness_incompleteness_and_what_it_all_means/" rel="nofollow">article</a> on logic, there is a sentence "No number is equal to zero" and we have to assign truth values to this sentence. I hope this is true and the article says it as false. </p>\n\n<p>Can someone explain me why it is false? Or the author of the article is wrong?</p>\n', 'ViewCount': '153', 'Title': 'No number is equal to Zero, is this statement true or false?', 'LastEditorUserId': '268', 'LastActivityDate': '2013-12-20T22:48:49.000', 'LastEditDate': '2013-12-20T17:30:27.037', 'AnswerCount': '4', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12239', 'Tags': '<logic><first-order-logic>', 'CreationDate': '2013-12-20T10:41:22.620', 'Id': '19152'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a question about predicate logic. Suppose we have the following predicates:</p>\n\n<p>$\\text{Study}(x,y)$: x studies y</p>\n\n<p>$\\text{Comp}(x)$: x is a computing student</p>\n\n<p>I want to encode the following sentence in predicate logic: "Some, but not all computer students study logic."</p>\n\n<p>A potential answer is:</p>\n\n<p>$$\\exists x(\\text{Comp}(x)\\land \\text{Study}(x,l))\\land\\neg \\forall x(\\text{Comp}(x)\\implies \\text{Study}(x,l))$$</p>\n\n<p>Why is there an $\\implies$ and not a $\\land$? Is this formulation correct?</p>\n', 'ViewCount': '34', 'Title': 'Logic Question - Why is This an Implication?', 'LastEditorUserId': '2253', 'LastActivityDate': '2014-02-11T04:23:40.600', 'LastEditDate': '2014-02-11T04:23:40.600', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14556', 'Tags': '<logic><first-order-logic><reasoning>', 'CreationDate': '2014-02-11T00:14:19.980', 'Id': '21512'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I read a book which says that in Predicate Calculus, syntactic theorem proving is identical (complete and sound) with semantic entailment and this is very useful because it is easier to prove positive witnesses in natural deduction whereas when you seem to fail you better switch to semantic account to demonstrate a counter-example.</p>\n\n<p>Particularly <a href="http://www.google.ee/search?q=%22%20when%20we%20look%20at%20predicate%20logic,%20we%20will%20find%20that%20there%20are%20infinitely%20many%20valuations%22" rel="nofollow">Logic in computer science</a> says</p>\n\n<blockquote>\n  <p>to show that \u0393  \u22a2\u03c8 is valid, we need to provide a proof of \u03c8 from \u0393.\n  Yet, how can we show that \u03c8 is not a consequence of \u0393? Intuitively,\n  this is harder; how can you possibly show that there is no proof of\n  something? You would have to consider every \u2018candidate\u2019 proof and show\n  it is not one. Thus, proof theory gives a \u2018positive\u2019 characterisation\n  of the logic; it provides convincing evidence for assertions like \u2018\u0393\n  \u22a2 \u03c8 is valid,\u2019 but it is not very useful for establishing evidence\n  for assertions of the form \u2018\u0393 \u22a2 \u03c6 is not valid.\u2019</p>\n  \n  <p>Semantics, on the other hand, works in the opposite way. To show\n  that \u03c8 is not a consequence of \u0393 is the \u2018easy\u2019 bit: find a model in\n  which all \u03c6_i are true, but \u03c8 isn\u2019t. Showing that \u03c8 is a consequence\n  of \u0393, on the other hand, is harder in principle. For propositional\n  logic, you need to show that every valuation (an assignment of truth\n  values to all atoms involved) that makes all \u03c6_i true also makes \u03c8\n  true. If there is a small number of valuations, this is not so bad.\n  However, when we look at predicate logic, we will find that there are\n  infinitely many valuations, called \'models\' from hereon, to consider.\n  Thus, in semantics we have a \u2018negative\u2019 characterisation of the logic.\n  We find establishing assertions of the form \u2018\u0393 \u22ad \u03c8\u2019 (\u03c8 is not a\n  semantic entailment of all formulas in \u0393) easier than establishing \u2018\u0393\n  \u22a8 \u03c8\u2019(\u03c8 is a semantic entailment of \u0393), for in the former case we need\n  only talk about one model, whereas in the latter we potentially have\n  to talk about infinitely many. All this goes to show that it is\n  important to study both proof theory and semantics. For example, if\n  you are trying to show that \u03c8 is not a consequence of \u0393 and you have a\n  hard time doing that, you might want to change your strategy for a\n  while by trying to prove the validity of \u0393 \u22a2 \u03c8. If you find a proof,\n  you know for sure that \u03c8 is a consequence of \u0393. If you can\u2019t find a\n  proof, then your attempts at proving it often provide insights which\n  lead you to the construction of a counter example. The fact that proof\n  theory and semantics for predicate logic are equivalent is amazing,\n  but it does not stop them having separate roles in logic, each\n  meriting close study.</p>\n</blockquote>\n\n<p>I was sure that we can prove the opposite by proving \u22a2 \xac\u03c8 and wondered why do we need the entailment. Now I see that validity of the opposite has nothing to do with validity of affirmative statement. Thanks. What we need is the satisfaction of the \xac\u03c8, which says that there is a counterexample. We do not need the validity of \xac\u03c8. But why semantics instead of proof? Do you say that semantics is in patrimony of satisfaction whereas proof theory is dedicated to validity?</p>\n', 'ViewCount': '172', 'Title': u'Why \u22a2 for affirmative predicates and \u22a8 for \xacnegations?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T16:33:58.987', 'LastEditDate': '2014-04-02T16:33:58.987', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<terminology><logic><first-order-logic>', 'CreationDate': '2014-02-13T11:02:46.557', 'Id': '21596'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>At the needs of my HW at uni I need to transform some Horn clauses to Prolog but I cannot figure out how to do it. I found out some guides but they describe how to do it with only one fact. So can you give me a brief example on how to do it?</p>\n\n<p>Eg John is beautiful and rich </p>\n\n<p>we can transform it at: <code>not (Beautiful(John)) ^ not(Rich(John))</code> which is a Horn clause right? So how this can be translated it Prolog?</p>\n\n<p>another example Everyone loves somebody.\nHorn clause: $\\forall X \\exists Y Loves(X,Y)$ how can this be implemented in Prolog?</p>\n\n<p>Thx in advance</p>\n', 'ViewCount': '56', 'ClosedDate': '2014-04-01T22:01:14.757', 'Title': 'Horn clause to Prolog', 'LastActivityDate': '2014-03-17T20:57:50.643', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22718', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13168', 'Tags': '<first-order-logic><prolog>', 'CreationDate': '2014-03-16T15:54:54.303', 'Id': '22682'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<blockquote>\n  <p>Given Boolean variable Xij that represents whether dog i is kept in\n  kennel j.</p>\n  \n  <p>Encode in CNF clauses:</p>\n  \n  <p>Dogs that cannot be kept together must be kept in separate kennels</p>\n</blockquote>\n\n<p>Here is what I came up with, given m dogs and n kennels (I am new with notation):</p>\n\n<pre><code>(i through m) AND (r through m) AND (j through n)  (!Xij AND !Xrj)\n</code></pre>\n\n<p>What I'm trying to say <strong>at most one</strong> of those dogs that can't be together is in kennel j</p>\n\n<p>also, </p>\n\n<blockquote>\n  <p>Dogs that need be kept together must be kept in the same kennel</p>\n</blockquote>\n\n<pre><code>(i through m) AND (r through m) AND (j through n)  (Xij AND Xrj)\n</code></pre>\n\n<p>What I'm trying to say is that those dogs i and r have to be in same kennel j</p>\n\n<p>Do these satisfy for CNF clauses?</p>\n\n<p>Any help is really appreciated.</p>\n", 'ViewCount': '22', 'Title': 'Are these CNF clauses for at most one and the same correct?', 'LastActivityDate': '2014-04-06T19:59:02.637', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15116', 'Tags': '<logic><artificial-intelligence><first-order-logic><boolean-algebra>', 'CreationDate': '2014-04-06T19:59:02.637', 'FavoriteCount': '1', 'Id': '23483'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am trying to obtain the proof of the proposition:</p>\n\n<p>$(\\forall x \\in \\mathbb{N}, P(x)) \\vee (\\neg \\forall x, P(x))$</p>\n\n<p>given that the property $P$ is decidable for every $x \\in \\mathbb{N}$, i.e.</p>\n\n<p>$\\forall x \\in \\mathbb{N}, P(x) \\vee \\neg P(x)$</p>\n\n<p>This is easy to prove (even without using the decidability of $P$) if I include the law of excluded middle, i.e.,</p>\n\n<p>$\\forall P, P \\vee \\neg P$.</p>\n\n<p>However, I am trying to obtain a constructive proof for the same. Is the proposition true without including the law of excluded middle? If so, how do I prove it? This seemingly simple property is needed to prove something about a complex system, and I am trying to not use the law of excluded middle unless it's absolutely necessary.</p>\n\n<p>The best I could come up with is the following:</p>\n\n<p>$\\forall y, (\\forall x \\le y, P(x)) \\vee \\neg (\\forall x \\le y, P(x))$</p>\n\n<p>I do not know how to proceed beyond this (or if this is even useful).</p>\n\n<p>Any help would be appreciated.</p>\n", 'ViewCount': '54', 'Title': 'Constructively deciding whether a decidable predicate holds universally', 'LastEditorUserId': '1329', 'LastActivityDate': '2014-04-08T16:15:49.483', 'LastEditDate': '2014-04-07T20:38:00.083', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'user16488', 'PostTypeId': '1', 'OwnerUserId': '16488', 'Tags': '<logic><proof-techniques><first-order-logic>', 'CreationDate': '2014-04-06T04:30:20.567', 'Id': '23509'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Say I have part of a query in the form: \u2203x<sub>a</sub>(...)\u2227\u2203x<sub>b</sub>(...)\u2227\u2203x<sub>c</sub>(...), where a, b, and c are attributes and the ellipses can be anything (I\'m looking for a general rule). Is this equivalent to saying \u2203x<sub>a</sub>,x<sub>b</sub>,x<sub>c</sub>(...\u2227...\u2227...) - i.e. compacting all the existential quantifiers into one and \'anding\' their domains together? </p>\n\n<p>For example, if I have the query:</p>\n\n<p><img src="http://i.stack.imgur.com/Y5lvo.png" alt="enter image description here"></p>\n\n<p>would it be correct (albeit unwieldy) to write it as:</p>\n\n<p>{ x<sub>pid</sub> | \u2203x<sub>pname</sub>,x<sub>color</sub>,x<sub>sid</sub>,x<sub>sname</sub>,x<sub>address</sub>,x<sub>cost</sub>,y<sub>sid</sub>,y<sub>sname</sub>,y<sub>address</sub>,y<sub>cost</sub>( PARTS(x<sub>pid</sub>,x<sub>pname</sub>,x<sub>color</sub>) \u2227 SUPPLIERS(x<sub>sid</sub>,x<sub>sname</sub>,x<sub>address</sub>... (and then the rest of the query)</p>\n', 'ViewCount': '46', 'Title': 'Can we move quantifiers to the left in predicate logic?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T12:48:40.067', 'LastEditDate': '2014-04-09T11:50:14.450', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '23592', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16564', 'Tags': '<logic><first-order-logic><normal-forms>', 'CreationDate': '2014-04-09T08:26:01.937', 'Id': '23588'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Theorem states </p>\n\n<blockquote>\n  <p>Let $\\phi$ be a sentence of predicate logic such that for any natural\n  number $n \\geq 1$, there is a model of $\\phi$ with at least $n$\n  elements. Then $\\phi$ has a model with infinitely many elements.</p>\n</blockquote>\n\n<p>IMO, it basically states that if you can always name a number larger than mine arbitrary natural number then your model is infinite. What needs to be proven here? There are no other options obviously for any school kid.</p>\n', 'ViewCount': '56', 'Title': u'What is the point of L\xf6wenheim\u2013Skolem theorem?', 'LastEditorUserId': '2879', 'LastActivityDate': '2014-04-21T14:55:15.240', 'LastEditDate': '2014-04-21T14:06:20.263', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<sets><first-order-logic>', 'CreationDate': '2014-04-21T10:07:40.160', 'Id': '23980'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $C = m(P,X,Y) \\leftarrow m(Q,X,Z), m(R,Z,Y)$. </p>\n\n<p>Is it possible to do the following substitution? </p>\n\n<p>$D = C\\theta$ where $\\theta = \\{Q/R,R/Q\\}$ s.t. $D = m(P,X,Y) \\leftarrow m(R,X,Z),m(Q,Z,Y)$</p>\n', 'ViewCount': '51', 'Title': 'FOL substitution - is it possible to substitute two variables with each other? e.g. $\\theta=\\{x/y,y/x\\}$?', 'LastActivityDate': '2014-04-21T18:09:42.753', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24000', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12643', 'Tags': '<logic><first-order-logic><logic-programming>', 'CreationDate': '2014-04-21T17:11:54.750', 'Id': '23996'}}