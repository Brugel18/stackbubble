63_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '966', 'Title': 'Do you get DFS if you change the queue to a stack in a BFS implementation?', 'LastEditDate': '2012-03-13T20:44:07.413', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '15', 'FavoriteCount': '1', 'Body': '<p>Here is the standard pseudocode for breadth first search:</p>\n\n<pre><code>{ seen(x) is false for all x at this point }\npush(q, x0)\nseen(x0) := true\nwhile (!empty(q))\n  x := pop(q)\n  visit(x)\n  for each y reachable from x by one edge\n    if not seen(y)\n      push(q, y)\n      seen(y) := true\n</code></pre>\n\n<p>Here <code>push</code> and <code>pop</code> are assumed to be queue operations. But what if they are stack operations? Does the resulting algorithm visit vertices in depth-first order?</p>\n\n<hr/>\n\n<p>If you voted for the comment "this is trivial", I\'d ask you to explain why it is trivial. I find the problem quite tricky.</p>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '15', 'LastActivityDate': '2012-03-14T23:07:45.207', 'CommentCount': '4', 'AcceptedAnswerId': '337', 'CreationDate': '2012-03-13T18:03:19.993', 'Id': '329'},63_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '377', 'Title': 'How to find a superstar in linear time?', 'LastEditDate': '2014-02-06T21:20:48.667', 'AnswerCount': '4', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '2', 'Body': '<p>Consider directed graphs. We call a node $v$ <em>superstar</em> if and only if no other node can be reached from it, but all other nodes have an edge to $v$. Formally:</p>\n\n<p>$\\qquad \\displaystyle $v$ \\text{ superstar } :\\Longleftrightarrow \\mathrm{outdeg}(v) = 0 \\land \\mathrm{indeg}(v) = n-1$</p>\n\n<p>with $n$ the number of nodes in the graph. For example, in the below graph, the unfilled node is a superstar (and the other nodes are not).</p>\n\n<p><img src="http://i.stack.imgur.com/MIGky.png" alt="A Superstar"><br>\n<sup>[<a href="https://github.com/akerbos/sesketches/blob/gh-pages/src/cs_411.dot" rel="nofollow">source</a>]</sup></p>\n\n<p>How can you identify all superstars in a directed graphs in $\\mathcal{O}(n)$ time? A suitable graph representation can be chosen from the <a href="https://en.wikipedia.org/wiki/Graph_%28abstract_data_type%29#Representations" rel="nofollow">usual candidates</a>; please refrain from using representations that move the problem\'s complexity to preprocessing.</p>\n\n<p>No assumptions regarding density can be made. We don\'t assume the graph contains a superstar; if there is none, the algorithm should recognize it.</p>\n\n<p><em>Notation</em>: $\\mathrm{outdeg}$ is a node\'s number of outgoing edges, $\\mathrm{indeg}$ similar for incoming edges.</p>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-06T21:20:48.667', 'CommentCount': '6', 'AcceptedAnswerId': '417', 'CreationDate': '2012-03-15T07:55:01.690', 'Id': '411'},63_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Definition from wikipedia:</p>\n\n<blockquote>\n  <p>A graph is an ordered pair $G = (V, E)$ comprising a set $V$ of nodes together with a set $E$ of edges, which are two-element subsets of $V$.</p>\n</blockquote>\n\n<p>The set of all finite graphs (modulo isomorphism: we don't want nodes to have identities) is countable and could be enumerated. But what would be an <em>efficient</em> (low-complexity, from a programming point of view) injection from graphs to $\\mathbb{N}$?</p>\n\n<p><em><strong>Edit:</strong> Gilles' comment indicates that it is not know whether there is a such function feasible in polynomial time. An example of an exponential-complexity function would be good enough; we can surely do better than a brute enumeration?</em></p>\n", 'ViewCount': '86', 'Title': 'An indexing function for graphs', 'LastEditorUserId': '68', 'LastActivityDate': '2012-03-15T22:15:41.130', 'LastEditDate': '2012-03-15T21:33:24.697', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '68', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-03-15T19:51:06.763', 'Id': '427'},63_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '596', 'Title': 'How Do Common Pathfinding Algorithms Compare To Human Process', 'LastEditDate': '2012-03-20T22:57:18.727', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '65', 'FavoriteCount': '2', 'Body': '<p>This might border on computational cognitive science, but I am curious as to how the process followed by common pathfinding algorithms (such as <a href="http://en.wikipedia.org/wiki/A_star_search_algorithm">A*</a>) compares to the process humans use in different pathfinding situations (given the same information). Are these processes similar?</p>\n', 'Tags': '<algorithms><graphs><artificial-intelligence>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-01T22:05:01.680', 'CommentCount': '5', 'AcceptedAnswerId': '554', 'CreationDate': '2012-03-20T20:51:22.867', 'Id': '553'},63_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How to improve the worst case scenario for a depth first search on an Euler graph, starting at some point and ending at that same point?</p>\n\n<p>I need to do the whole search but it is not fast enough for large amounts of data. I have tried <a href="https://en.wikipedia.org/wiki/Bidirectional_search" rel="nofollow">bidirectional search</a> but I can not keep the result numerically ordered. Therefore I wonder if there is any other good method to smooth the worst case scenario for the depth first search.</p>\n', 'ViewCount': '251', 'Title': 'Improve worst case time of depth first search on Euler graphs', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-20T20:09:11.067', 'LastEditDate': '2013-03-20T20:09:11.067', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '591', 'Tags': '<algorithms><graphs><graph-traversal><eulerian-paths>', 'CreationDate': '2012-03-21T16:04:53.030', 'Id': '615'},63_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '710', 'Title': 'Find shortest paths in a weighed unipathic graph', 'LastEditDate': '2012-03-21T23:24:31.727', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '512', 'FavoriteCount': '1', 'Body': '<p>A directed graph is said to be <em>unipathic</em> if for any two vertices $u$ and $v$ in\nthe graph $G=(V,E)$, there is at most one simple path from $u$ to $v$. </p>\n\n<p>Suppose I am given a unipathic graph $G$ such that each edge has a positive or negative weight, but contains no negative weight cycles.</p>\n\n<p>From this I want to find a $O(|V|)$ algorithm that finds all the the shortest paths to all nodes from a source node $s$.</p>\n\n<p>I am not sure how I would go about approaching this problem. I am trying to see how I could use the fact that it contains no negative weight cycles and of course at most one simple path between any node $u$ to $v$.</p>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-03-23T00:52:25.950', 'CommentCount': '3', 'AcceptedAnswerId': '679', 'CreationDate': '2012-03-21T19:37:01.033', 'Id': '625'},63_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A unipathic graph is a directed graph such that there is at most one simple path from any one vertex to any other vertex.</p>\n\n<p>Unipathic graphs can have cycles. For example, a doubly linked list (not a circular one!) is a unipathic graph; if the list has $n$ elements, the graph has $n-1$ cycles of length 2, for a total of $2(n-1)$.</p>\n\n<p>What is the maximum number of edges in a unipathic graph with $n$ vertices? An asymptotic bound would do (e.g. $O(n)$ or $\\Theta(n^2)$).</p>\n\n<p><sub>Inspired by <a href="http://cs.stackexchange.com/questions/625/find-shortest-paths-in-a-weighed-unipathic-graph">Find shortest paths in a weighed unipathic graph</a>; in <a href="http://cs.stackexchange.com/questions/625/find-shortest-paths-in-a-weighed-unipathic-graph/679#679">my proof</a>, I initially wanted to claim that the number of edges was $O(n)$ but then realized that bounding the number of cycles was sufficient.</sub></p>\n', 'ViewCount': '202', 'Title': 'How many edges can a unipathic graph have?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-23T12:33:19.637', 'LastEditDate': '2012-03-23T08:10:31.653', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '694', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<graphs><combinatorics>', 'CreationDate': '2012-03-23T00:57:51.913', 'Id': '680'},63_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I came across an issue with the definition of a (directed) graph in Sipser's Introduction to the theory of computation, 2nd Ed.</p>\n\n<p>On pp.10, An <strong>undirected graph</strong>, or simply a <strong>graph</strong>, is a set of points with lines connecting some of the points. The points are called nodes or vertices, and the lines are called edges, ...</p>\n\n<p>On the same page,</p>\n\n<blockquote>\n  <p><strong>No more than one edge is allowed between any two nodes</strong>.</p>\n</blockquote>\n\n<p>On pp.12,</p>\n\n<blockquote>\n  <p>If it has arrows instead of lines, the graph is a <strong>directed graph</strong>,...</p>\n</blockquote>\n\n<p>In Figure 0.16 on pp.12, there is an example of a directed graph, an arrow from node 1 to node 2 and an arrow from node 2 to node 1.</p>\n\n<p>So, we have two arrows in opposite direction between two nodes.</p>\n\n<p>I understand all of these basics.</p>\n\n<p>My question is,</p>\n\n<blockquote>\n  <p>Is directed graph a graph?</p>\n</blockquote>\n", 'ViewCount': '308', 'Title': 'Is Directed Graph a Graph?', 'LastActivityDate': '2012-03-24T15:47:16.610', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '739', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '630', 'Tags': '<graphs>', 'CreationDate': '2012-03-24T11:02:19.290', 'FavoriteCount': '0', 'Id': '737'},63_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1006', 'Title': 'NP completeness proof of a spanning tree problem', 'LastEditDate': '2012-03-31T06:45:44.153', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '763', 'FavoriteCount': '3', 'Body': '<p>I am looking for some hints in a question asked by my instructor.</p>\n\n<p>So I just figured out this decision problem is $\\sf{NP\\text{-}complete}$:</p>\n\n<p>In a graph $G$, is there a spanning tree in $G$ that contain an exact set of $S=\\{x_1, x_2,\\ldots, x_n\\}$ as leafs. I figured out we can prove that it is $\\sf{NP\\text{-}complete}$ by reducing Hamiltonian path to this decisions problem.</p>\n\n<p>But my instructor also asked us in class:</p>\n\n<blockquote>\n  <p>would it also be $\\sf{NP\\text{-}complete}$ if instead of "exact set of $S$", we do </p>\n  \n  <p>"include the whole set of $S$ and possibly other leafs" or \n     "subset of $S$"</p>\n</blockquote>\n\n<p>I think "subset of S" would be $\\sf{NP\\text{-}complete}$, but I just can\'t prove it, I don\'t know what problem I can reduce it to this. As for "include the set of $S$..." I think it can be solved in polynomial time.</p>\n', 'Tags': '<complexity-theory><graphs><np-complete>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-31T06:45:44.153', 'CommentCount': '2', 'AcceptedAnswerId': '822', 'CreationDate': '2012-03-27T03:43:11.057', 'Id': '808'},63_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Why cannot I find any information about spanning tree for DAG ?  I must be wrong somewhere.</p>\n', 'ViewCount': '427', 'Title': 'Does spanning tree make sense for DAG?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-31T07:20:13.363', 'LastEditDate': '2012-03-30T10:44:36.073', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '906', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '694', 'Tags': '<graphs><graph-theory><spanning-trees>', 'CreationDate': '2012-03-30T10:43:07.210', 'Id': '897'},63_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have noticed that different data structures are used when we implement search algorithms. For example, we use queues to implement breadth first search, stacks to implement depth-first search and min-heaps to implement the <a href="https://en.wikipedia.org/wiki/A%2a_algorithm">A* algorithm</a>. In these cases, we do not need to construct the search tree explicitly.</p>\n\n<p>But I can not find a simple data structure to simulate the searching process of the <a href="http://www.cs.cf.ac.uk/Dave/AI2/node26.html">AO* algorithm</a>. I would like to know if constructing the search tree explicitly is the only way to implement AO* algorithm? Can anybody provide me an efficient implementation?</p>\n', 'ViewCount': '994', 'Title': 'How to implement AO* algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T20:12:52.987', 'LastEditDate': '2012-09-22T09:04:58.943', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '931', 'Tags': '<algorithms><graphs><data-structures><search-algorithms>', 'CreationDate': '2012-04-04T03:05:59.537', 'FavoriteCount': '2', 'Id': '1020'},63_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '315', 'Title': 'How many shortest distances change when adding an edge to a graph?', 'LastEditDate': '2012-04-06T09:55:35.533', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '92', 'FavoriteCount': '2', 'Body': '<p>Let $G=(V,E)$ be some complete, weighted, undirected graph. We construct a second graph $G&#39;=(V, E&#39;)$ by adding edges one by one from $E$ to $E&#39;$. We add $\\Theta(|V|)$ edges to $G&#39;$ in total.</p>\n\n<p>Every time we add one edge $(u,v)$ to $E&#39;$, we consider the shortest distances between all pairs in $(V, E&#39;)$ and $(V, E&#39; \\cup \\{ (u,v) \\})$. We count how many of these shortest distances have changed as a consequence of adding $(u,v)$. Let $C_i$ be the number of shortest distances that change when we add the $i$th edge, and let $n$ be the number of edges we add in total.</p>\n\n<blockquote>\n  <p>How big is $C = \\frac{\\sum_i C_i}{n}$?</p>\n</blockquote>\n\n<p>As $C_i = O(|V|^2)=O(n^2)$, $C=O(n^2)$ as well. Can this bound be improved? Note that I define $C$ to be the average over all edges that were added, so a single round in which a lot of distances change is not that interesting, though it proves that $C = \\Omega(n)$.</p>\n\n<p>I have an algorithm for computing a geometric t-spanner greedily that works in $O(C n \\log n)$ time, so if $C$ is $o(n^2)$, my algorithm is faster than the original greedy algorithm, and if $C$ is really small, potentially faster than the best known algorithm (though I doubt that).</p>\n\n<p>Some problem-specific properties that might help with a good bound: the edge $(u,v)$ that is added always has larger weight than any edge already in the graph (not necessarily strictly larger). Furthermore, its weight is shorter than the shortest path between $u$ and $v$.</p>\n\n<p>You may assume that the vertices correspond to points in a 2d plane and the distances between vertices are the Euclidian distances between these points. That is, every vertex $v$ corresponds to some point $(x,y)$ in the plane, and for an edge $(u,v)=((x_1,y_1),(x_2,y_2))$ its weight is equal to $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2.}$</p>\n', 'Tags': '<algorithms><graphs><graph-theory><shortest-path>', 'LastEditorUserId': '92', 'LastActivityDate': '2014-01-19T02:02:00.257', 'CommentCount': '11', 'AcceptedAnswerId': '1063', 'CreationDate': '2012-04-05T19:15:54.200', 'Id': '1062'},63_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to implement bidirectional search in a graph. I am using two breadth first searches from the start node and the goal node. The states that have been checked are stored in two hash tables (closed lists).\nHow can I get the solution (path from the start to the goal), when I find that a state that is checked by one of the searches is in the closed list of the other?</p>\n\n<p>EDIT </p>\n\n<p>Here are the explanations from the book:\n<em>"Bidirectional search is implemented by having one or both of the searches check each\nnode before it is expanded to see if it is in the fringe of the other search tree; if so, a solution has been found... Checking a node for membership in the other search tree can be done in constant time with a hash table..."</em></p>\n\n<p>Some pages before: \n<em>"A node is a boolkkeeping data structure used to represent the search tree. A state corresponds to a configuration of the world... two different nodes can contain the same world state, if that state is generated via two different search paths."</em> So from that I conclude that if nodes are kept in the hash tables than a node from the BFS started from the start node would not match a node constructed from the other BFS started from the goal node.</p>\n\n<p>And later in general Graph search algorithm the states are stored in the closed list, not the nodes, but it seems to me that even that the states are saved in the hash tables after that the nodes are retrieved from there.</p>\n', 'ViewCount': '546', 'Title': 'How to construct the found path in bidirectional search', 'LastEditorUserId': '770', 'LastActivityDate': '2012-05-01T21:04:41.210', 'LastEditDate': '2012-04-07T21:08:01.660', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '1620', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '770', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2012-04-07T16:12:39.053', 'Id': '1113'},63_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am implementing a set of path finding algorithms such as Dijkstra's, Depth First, etc.</p>\n\n<p>At first I used a couple of self made graphs, but now I'd like to take the challenge a bit further and thus I'm looking for either</p>\n\n<ol>\n<li>graphs used in benchmarks;</li>\n<li>graphs of real world cities (or a way to download that kind of info off google maps, or any other kind of source, if possible).</li>\n</ol>\n\n<p>I'd like those sources to either have or allow me to easily create frontiers such that I can try my algorithms for different sized sets of graphs, if possible.</p>\n\n<p>I'm looking for simple solutions, as I'd prefer not to be diverted from main goal (compare a set of different algorithms), so I'd need a quick way to convert that graph data into my own format (basically, a set of connected <code>(x, y)</code> points).</p>\n\n<p>To be more concrete, what I'm looking for are 2D cyclic graphs. If those graphs reflect real world city streets (taking into consideration one-way streets, two-way streets, etc, better yet!).</p>\n", 'ViewCount': '327', 'Title': 'Where to get graphs to test my search algorithms against?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-08T23:01:11.637', 'LastEditDate': '2012-04-09T11:16:45.717', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '8073', 'Tags': '<algorithms><graphs><data-sets><benchmarking>', 'CreationDate': '2012-04-09T03:37:40.150', 'FavoriteCount': '5', 'Id': '1151'},63_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am writing a Program, solving the <a href="http://en.wikipedia.org/wiki/Route_inspection_problem" rel="nofollow">Chinese Postman Problem</a> (also known as route inspection problem) in an undirected draph and currently facing the problem to find the best additional edges to connect the nodes with odd degree, so I can compute an Eulerian circuit.</p>\n\n<p>There might be (considering the size of the graph that wants to be solved) an enormous combination of edges which need to be computed and evaluated.</p>\n\n<p>As an example there are the odd-degree nodes $A, B, C, D, E, F, G, H$. The best combinations could be:</p>\n\n<ol>\n<li>$AB$, $CD$, $EF$, $GH$</li>\n<li>$AC$, $BD$, $EH$, $FG$</li>\n<li>$AD$, $BC$, $EG$, $FH$</li>\n<li>$AE$ ....</li>\n</ol>\n\n<p>where $AB$ means "edge between node $A$ and node $B$".</p>\n\n<p>Therefore my question is: is there a known algorithm to solve that problem in a complexity better than pure brute force (computing and evaluating them all)?</p>\n\n<p>\u20ac:After some research effort I found <a href="http://web.mit.edu/urban_or_book/www/book/chapter6/6.4.4.html" rel="nofollow">this</a> article, speaking about the "Edmonds\' minimum-length matching algorithm" but I cannot find any pseudo-code or learners-descriptions of this algorithm (or at least I do not recognize them, as Google offers a lot of hits an matching algorithms by J. Edmonds)</p>\n', 'ViewCount': '1120', 'Title': 'Chinese Postman Problem: finding best connections between odd-degree nodes', 'LastEditorUserId': '78', 'LastActivityDate': '2014-01-02T12:01:32.207', 'LastEditDate': '2012-04-15T00:21:19.243', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '78', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-04-13T21:05:09.293', 'FavoriteCount': '1', 'Id': '1257'},63_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I thought this (though somewhat basic) question belonged here:</p>\n\n<p>Say I have a graph of size 100 nodes arrayed in a 10x10 pattern (think chessboard). The graph is undirected, and unweighted. Moving through the graph involves moving three spaces forward and one space to either right or left (similar to how a chess knight moves across a board).</p>\n\n<p>Given a fixed beginning node, how would one find the shortest path to any other node on the board?</p>\n\n<p>I imagined that there would only be an edge between nodes that are viable moves. So, given this information, I would want to find the shortest path from a starting node to an ending node.</p>\n\n<p>My initial thought was that each edge is weighted with weight 1. However, the graph is undirected, so Djikstras would not be an ideal fit. Therefore, I decided to do it using an altered form of a depth first search.</p>\n\n<p>However, I couldn't for the life of me visualize how to get the shortest path using the search.</p>\n\n<p>Another thing I tried was putting the graph in tree form with the starting node as the root, and then selecting the shallowest (lowest row number) result that gave me the desired end node... this worked, but was incredibly inefficient, and thus would not work for a larger graph.</p>\n\n<p>Does anyone have any ideas that might point me in the right direction on this one?</p>\n\n<p>Thank you very much.</p>\n\n<p>(I tried to put in a visualization of the graph, but was unable to due to my low reputation)</p>\n", 'ViewCount': '2595', 'Title': 'Shortest Path on an Undirected Graph?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-01T22:38:48.113', 'LastEditDate': '2012-04-18T05:56:13.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '1330', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<algorithms><graphs><graph-theory><search-algorithms><shortest-path>', 'CreationDate': '2012-04-18T04:23:36.273', 'Id': '1329'},63_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So, I'm trying to conceptualize something:</p>\n\n<p>Say we have a weighed graph of size N. A and B are nodes on the graph. You want to find the shortest path from A to B, given a few caveats:</p>\n\n<ol>\n<li><p>movements on the graph are regulated by a circular cycle of length 48, in such a manner that:</p>\n\n<blockquote>\n  <p>cycle{</p>\n\n<pre><code>     0 &lt;= L &lt;= 24  movement IS possible\n\n    25 &lt;= L &lt;= 48 movement IS NOT possible\n</code></pre>\n  \n  <p>}</p>\n</blockquote>\n\n<p>For simplicity's sake, we will call this cycle 'time'.</p></li>\n<li><p>The distance between nodes A and B is equal to:</p>\n\n<blockquote>\n  <p>shortest_distance(A to B) - 1 OR shortest_distance(A to B) + 1</p>\n</blockquote>\n\n<p>Depending on their orientation</p></li>\n<li><p>the weight of the edges represents the 'time' it takes to travel between nodes.</p></li>\n</ol>\n\n<p>I'd like to create an algorithm that will give me the shortest path with these constraints in mind, assuming one is leaving from node A at time(cycle) = 12, traveling towards node B. The shortest path would be defined as the path which takes the least 'time'.</p>\n\n<p>Step one would obviously be to take into account the orientation affecting the shortest distance (i.e. which way are they oriented by above), which would be a simple addition or substraction to the result of djikstra's algorithm</p>\n\n<p>What I'm having trouble figuring out is how to account for the cycle in the algorithm... could it be as simple as just an if statement checking to see if the current cycle time is within the constraints that allow movement?</p>\n\n<p>Would my idea be viable? If not, does anyone h ave any suggestions at different ways I should look at this problem?</p>\n\n<p>I know this question seems really basic, but I just can't wrap my head around it.</p>\n", 'ViewCount': '155', 'Title': "Modified Djikstra's algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T15:00:39.803', 'LastEditDate': '2012-04-18T05:48:56.107', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '1341', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2012-04-18T05:30:45.100', 'Id': '1332'},63_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a <a href="https://www.iis.se/docs/DNS-bok-sid-14.jpg">tree</a> ( in graph theory sense) such as this:</p>\n\n<p><img src="http://i.stack.imgur.com/sK90D.jpg" alt="enter image description here"></p>\n\n<p>This is a directed tree with one starting node and many ending nodes. Each of the edge has a length assigned to it.</p>\n\n<p>My question is, how to find the longest path connecting from the starting node to any of the ending node? The brute force approach is to check all the root-leaf paths and taking the one with maximal length, but I would prefer a more efficient algorithm if there is one. </p>\n', 'ViewCount': '4475', 'Title': 'Find the longest path in a tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-25T07:50:26.063', 'LastEditDate': '2012-04-25T07:48:32.063', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '1497', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '304', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-04-25T03:22:55.250', 'Id': '1494'},63_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have two problems related to paths in a directed graph. Let $G=(V,E)$ be a directed graph with source $s \\in V$ and target $t \\in V$. Let $v \\in V \\setminus \\{s,t\\}$ be another vertex in $G$. </p>\n\n<ol>\n<li><p>Find a simple directed path\xb9 from $s$ to $t$ through $v$. </p></li>\n<li><p>Find a simple directed path from $s$ to $t$ that goes through two fixed edges in $G$.</p></li>\n</ol>\n\n<p>I do not know if there are polynomial time algorithms for them. Does anyone have solutions or references for them?</p>\n\n<hr>\n\n<ol>\n<li>A simple directed path does not allow any vertex to appear more than once. </li>\n</ol>\n', 'ViewCount': '193', 'Title': 'Simple paths with halt in between in directed graphs', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-08T13:30:06.013', 'LastEditDate': '2012-04-26T21:08:51.690', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'Bin Fu', 'PostTypeId': '1', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-04-26T18:01:42.210', 'FavoriteCount': '1', 'Id': '1516'},63_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I asked this <a href="http://stackoverflow.com/questions/10326446/how-to-approach-dynamic-graph-related-problems">question</a> at generic stackoverflow and I was directed here.</p>\n\n<p>It will be great if some one can explain how to approach partial or fully dynamic graph problems in general.</p>\n\n<p>For example:</p>\n\n<ul>\n<li>Find Shortest Path between two vertices $(u,v)$ in a undirected weighted graph for $n$ instances, when an edge is removed at each instance.</li>\n<li>Find number of connected components in an undirected graph for n instances when an edge is remove at each instance, etc.</li>\n</ul>\n\n<p>I recently encountered this genre of problems in a programming contest. I searched through the web and I found lot of research papers concerning with dynamic graphs [1,2]. I read couple of them and and I couldnt find anything straight forward (clustering, sparsification etc). Sorry for being vague.</p>\n\n<p>I really appreciate if some can provide pointers to understand these concepts better.</p>\n\n<hr>\n\n<ol>\n<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.8372"><em>Dynamic Graph Algorithms</em></a> by D. Eppstein , Z. Galil , G. F. Italiano (1999)</li>\n<li><a href="http://www.lix.polytechnique.fr/~liberti/sppsurvey.pdf"><em>Shortest paths on dynamic graphs</em></a> by G. Nannicini, L. Liberti (2008)</li>\n</ol>\n', 'ViewCount': '453', 'Title': 'How to approach Dynamic graph related problems', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-23T15:24:36.313', 'LastEditDate': '2012-04-27T07:08:12.330', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1262', 'Tags': '<algorithms><data-structures><graphs>', 'CreationDate': '2012-04-27T01:05:51.733', 'FavoriteCount': '1', 'Id': '1521'},63_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '299', 'Title': 'Approximation algorithm for TSP variant, fixed start and end anywhere but starting point + multiple visits at each vertex ALLOWED', 'LastEditDate': '2012-04-28T09:30:21.653', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1282', 'FavoriteCount': '1', 'Body': '<p>NOTE: Due to the fact that the trip does not end at the same place it started and also the fact that every point can be visited more than once as long as I still visit all of them, this is not really a TSP variant, but I put it due to lack of a better definition of the problem.</p>\n\n<p>This problem was originally posted on StackOverflow, but I was told that this would be a better place. I got one pointer, which converted the problem from non-metric to a metric one.</p>\n\n<p>So..</p>\n\n<p>Suppose I am going on a hiking trip with n points of interest. These points are all connected by hiking trails. I have a map showing all trails with their distances, giving me a directed graph.</p>\n\n<p>My problem is how to approximate a tour that starts at a point A and visits all n points of interest, while ending the tour anywhere but the point where I started and I want the tour to be as short as possible.</p>\n\n<p>Due to the nature of hiking, I figured this would sadly not be a symmetric problem (or can I convert my asymmetric graph to a symmetric one?), since going from high to low altitude is obviously easier than the other way around.</p>\n\n<p>Since there are no restrictions regarding how many times I visit each point, as long as I visit all of them, it does not matter if the shortest path from a to d goes through b and c. Is this enough to say that triangle inequality holds and thus I have a metric problem?</p>\n\n<p>I believe my problem is easier than TSP, so those algorithms do not fit this problem. I thought about using a minimum spanning tree, but I have a hard time applying it to this problem, which under the circumstances, should be a metric asymmetric directed graph?</p>\n\n<p>What I really want are some pointers as to how I can come up with an approximation algorithm that will find a near optimal tour through all n points</p>\n', 'Tags': '<algorithms><complexity-theory><graphs><graph-theory><approximation>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-28T21:59:47.610', 'CommentCount': '5', 'AcceptedAnswerId': '1551', 'CreationDate': '2012-04-28T07:45:11.773', 'Id': '1542'},63_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to search for an algorithm that can tell me which node has the highest download (or upload) capacity given a weighted directed graph, where weights correspond to individual link bandwidths. I have looked at the maximal flow problem and at the Edmond-Karp algorithm. My questions are the following: </p>\n\n<ol>\n<li>Edmond-Karp just tells us how much throughput we can get (at the sink) from source to sink if any of the paths were used. Correct?</li>\n<li>Edmond-Karp does not tell us which path can give us the maximum flow. Correct?</li>\n</ol>\n', 'ViewCount': '473', 'Title': 'Finding the maximum bandwidth along a single path in a network', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:52:42.887', 'LastEditDate': '2012-06-10T11:42:16.480', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '1639', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1289', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2012-04-30T14:17:06.293', 'Id': '1591'},63_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Say I have a weighted undirected complete graph $G = (V, E)$. Each edge $e = (u, v, w)$ is assigned with a positive weight $w$. I want to calculate the minimum-weighted $(d, h)$-tree-decomposition. By $(d, h)$-tree-decomposition, I mean to divide the vertices $V$ into $k$ trees, such that the height of each tree is $h$, and each non-leaf node has $d$ children. </p>\n\n<p>I know it is definitely $\\text{NP}$-Hard, since minimum $(1, |V|-1)$-tree-decomposition is the minimum Hamilton path. But are there any good approximation algorithms?</p>\n', 'ViewCount': '214', 'Title': 'Approximate minimum-weighted tree decomposition on complete graphs', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T11:59:46.367', 'LastEditDate': '2012-05-10T11:59:46.367', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '11', 'OwnerDisplayName': 'Geni', 'PostTypeId': '1', 'OwnerUserId': '1354', 'Tags': '<algorithms><complexity-theory><graphs><graph-theory><approximation>', 'CreationDate': '2012-05-02T21:38:35.253', 'Id': '1640'},63_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for an algorithm to find a minimal traversal of a directed graph of the following type. Two vertices are given, a start vertex and a terminating vertex. The traversal consists of several runs; each run is a path from the start vertex to the terminating vertex. A run may visit a node more than once. The length of a traversal is the total number of vertices traversed by the runs, with multiplicity; in other words, the length of a traversal is the number of runs plus the sum of the lengths of the runs.</p>\n\n<p>If there are edges that are not reachable (i.e. the origin of the edge is not reachable from the start vertex, or the terminating vertex is not reachable from the target of the edge), they are ignored.</p>\n\n<p>To illustrate my needs, I give a simple graph and post the result, I would like to receive by the algorithm (start vertex $1$, terminating vertex $4$):</p>\n\n<p>Graph edges:</p>\n\n<ul>\n<li>$1 \\to 2,3$</li>\n<li>$2 \\to 1,3,4$</li>\n<li>$3 \\to 4$</li>\n</ul>\n\n<p>Result:</p>\n\n<ul>\n<li>Run A: $1, 2, 1, 3, 4$</li>\n<li>Run B: $1, 2, 4$</li>\n<li>Run C: $1, 2, 3, 4$</li>\n</ul>\n\n<p>Each edge (also each direction) has been covered. Each run begins with vertex $1$ and ends with vertex $4$. The minimum total number of visited vertices is searched. In the given example, the minimum number is $5+3+4=12$. There is no unreachable edge in this example.</p>\n', 'ViewCount': '364', 'Title': 'Find the minimal number of runs to visit every edge of a directed graph', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-08T18:36:00.010', 'LastEditDate': '2012-05-06T23:29:42.950', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1397', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-05-06T22:00:02.643', 'FavoriteCount': '3', 'Id': '1698'},63_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am a novice(total newbie to computational complexity theory) and I have a question.</p>\n\n<p>Lets say we have 'Traveling Salesman Problem' ,will the following application of Dijkstra's Algorithms solve it?</p>\n\n<p>From a start point we compute the shortest distance between two points. We go to the point. We delete the source point. Then we compute the next shortest distance point from the current point and so on...</p>\n\n<p>Every step we make the graph smaller while we move the next available shortest distance point. Until we visit all the points.</p>\n\n<p>Will this solve the traveling salesman problem.</p>\n", 'ViewCount': '5562', 'Title': "Dijsktra's algorithm applied to travelling salesman problem", 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-12T18:30:15.427', 'LastEditDate': '2012-05-12T18:30:15.427', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '5', 'OwnerDisplayName': 'Kamaal', 'PostTypeId': '1', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-05-09T06:55:45.493', 'FavoriteCount': '1', 'Id': '1749'},63_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Having extracted the data-flow in some rather large programs as directed, acyclic graphs, I'd now like to optimize the order of evaluation to minimze the maximum amount of memory used.</p>\n\n<p>That is, given a graph {1 -> 3, 2 -> 3, 4 -> 5, 3 -> 5}, I'm looking for an algorithm that will decide the order of graph reduction to minimize the number of 'in-progress' nodes, in this particular case to decide that it should be reduced in the order 1-2-3-4-5; avoiding the alternative ordering, in this case 4-1-2-3-5, which would leave the output from node 4 hanging until 3 is also complete.</p>\n\n<p>Naturally, if there are two nodes using the output from a third, then it only counts once; data is not copied unnecessarily, though it does hang around until both of those nodes are reduced.</p>\n\n<p>I would also quite like to know what this problem is called, if it has a name. It looks similar to the graph bandwidth problem, only not quite; the problem statement may be defined in terms of path/treewidth, but I can't quite tell, and am unsure if I should prioritize learning that branch of graph theory right now.</p>\n", 'ViewCount': '126', 'Title': 'Optimizing order of graph reduction to minimize memory usage', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-10T03:23:26.373', 'LastEditDate': '2012-05-10T03:23:26.373', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1425', 'Tags': '<algorithms><graphs><optimization><software-engineering><program-optimization>', 'CreationDate': '2012-05-09T12:07:24.633', 'FavoriteCount': '1', 'Id': '1752'},63_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a degree distribution, how fast can we construct a graph that follows the given degree distribution? A link or algorithm sketch would be good. The algorithm should report a "no" incase no graph can be constructed and any one example if multiple graphs can be constructed.</p>\n', 'ViewCount': '270', 'Title': 'Reconstructing Graphs from Degree Distribution', 'LastActivityDate': '2012-05-17T14:43:13.887', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '1885', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '661', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-05-17T12:53:27.080', 'FavoriteCount': '1', 'Id': '1883'},63_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In a directed graph with a starting node and an ending node, how to find a small (doesn't have to be smallest. &lt;10 for example) set S of nodes such that every possible path from the starting node to the ending node contains at least one member of set S. The graph may have loops. This may be NP hard. Is there an approximate method to find one or several such S from the graph? Enumerating and testing every candidate seems not work. thanks.</p>\n", 'ViewCount': '58', 'Title': 'Finding small node sets that can not be avoided on paths from source to sink', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T22:05:04.273', 'LastEditDate': '2012-05-23T22:05:04.273', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2032', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1620', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-05-23T20:39:40.190', 'Id': '2028'},63_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a "smarter" version of Bellman-Ford here; this version is more clever about choosing the edges to relax.</p>\n\n<pre><code>//Queue Q; source s; vertices u, v; distance to v d(v)\nQ \u2190 s // Q holds vertices whose d(v) values have been updated recently.\nWhile (Q !empty) {\n  u \u2190 Dequeue(Q)\n  for each neighbor v of u {\n    Relax(u, v)\n    if d(v) was updated by Relax and v not in Q\n      Enqueue(v)\n  }\n}\n</code></pre>\n\n<p>But, can anyone explain why this improved version correctly finds the shortest path from $s$ to every other vertex in a directed graph with no negative cycles?</p>\n\n<p>Also, what is the <em>worst-case</em> runtime if every shortest path uses at most $v$ edges?</p>\n', 'ViewCount': '458', 'Title': 'Bellman-Ford variation', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-25T05:17:22.893', 'LastEditDate': '2012-05-24T07:55:34.530', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1624', 'Tags': '<algorithms><graphs><graph-theory><runtime-analysis><shortest-path>', 'CreationDate': '2012-05-24T01:44:55.237', 'FavoriteCount': '2', 'Id': '2039'},63_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Solving the <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem" rel="nofollow">maximum flow problem</a> yields one qualified minimal cut. But I want several (maybe hundreds) small cuts as candidates. The cuts don\'t have to be minimum cuts, as long as they are small (in weight). How do I do that?</p>\n', 'ViewCount': '154', 'Title': 'In s-t directed graph, how to find many small cuts?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-02T17:30:29.300', 'LastEditDate': '2012-05-25T11:18:35.083', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1620', 'Tags': '<algorithms><graphs><graph-theory><optimization><approximation>', 'CreationDate': '2012-05-24T20:19:25.250', 'FavoriteCount': '2', 'Id': '2052'},63_30:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For my pet project I need to cluster some data which could be easily represented as graph, so I want to use this as an opportunity to educate myself and play with various algorithms. I'd prefer the book on graph clustering as it often more self contained but articles are fine too. Back in the days I used to work in the field of numerical linear algebra so I'd also prefer algebraical view on things (so books which view graph as a matrix with specific properties are more accessible to me).</p>\n\n<p>p.s. I've tried scholar.google.com but was overwhelmed by vast number of results.  </p>\n", 'ViewCount': '81', 'Title': 'Could someone suggest me a good introductory book or an article on graph clustering?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-25T14:29:21.953', 'LastEditDate': '2012-05-25T14:19:42.963', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2077', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1647', 'Tags': '<algorithms><graphs><graph-theory><reference-request><books>', 'CreationDate': '2012-05-25T13:00:28.593', 'Id': '2076'},63_31:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is a family of random graphs $G(n, p)$ with $n$ nodes (<a href="https://en.wikipedia.org/wiki/Random_graph">due to Gilbert</a>). Each possible edge is independently inserted into $G(n, p)$ with probability $p$. Let $X_k$ be the number of cliques of size $k$ in $G(n, p)$.</p>\n\n<p>I know that $\\mathbb{E}(X_k)=\\tbinom{n}{k}\\cdot p^{\\tbinom{k}{2}}$, but how do I prove it?</p>\n\n<p>How to show that $\\mathbb{E}(X_{\\log_2n})\\ge1$ for $n\\to\\infty$? And how to show that $\\mathbb{E}(X_{c\\cdot\\log_2n}) \\to 0$ for $n\\to\\infty$ and a fixed, arbitrary constant $c&gt;1$?</p>\n', 'ViewCount': '297', 'Title': 'Number of clique in random graphs', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-28T09:46:02.827', 'LastEditDate': '2012-05-28T09:46:02.827', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2119', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1393', 'Tags': '<graph-theory><combinatorics><probability-theory><random-graphs>', 'CreationDate': '2012-05-27T23:41:29.403', 'Id': '2118'},63_32:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '630', 'Title': 'NP-Completeness of a Graph Coloring Problem', 'LastEditDate': '2012-06-26T21:18:06.560', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1672', 'FavoriteCount': '3', 'Body': '<p><strong>Alternative Formulation</strong></p>\n\n<p>I came up with an alternative formulation to the below problem. The alternative formulation is actually a special case of the problem bellow and uses bipartite graphs to describe the problem. However, I believe that the alternative formulation is still NP-hard. The alternative formulation uses a disjoint set of incoming and outgoing nodes that simplifies the problem definition.</p>\n\n<p>Given $n$ outgoing and $n$ incoming nodes (the red and blue nodes in the figure respectively), and a set $w_{ij}$\'s of size $n \\times n$ of edge weights between the outgoing and incoming vertices. The goal of the problem is to color the thick edges in the figure so that for every incoming node, a condition holds.</p>\n\n<p><img src="http://i.stack.imgur.com/CsXJr.png" alt="Bipartite graph of the problem"></p>\n\n<blockquote>\n  <p>Given a set $\\{ O_i \\; | \\; i=1 \\dots n \\}$ of output vertices, a set $\\{ I_i\\; | \\; i=1 \\dots n \\}$ of input vertices, $n \\times n$ weights\n  $w_{ij} \\ge 0$ between $O_i$\'s and $I_j$\'s for $i,j=1 \\dots n$, and a positive\n  constant $\\beta$, find the minimum number of colors for the edges\n  $e_{ii}$ (thick edges in the above figure) such that for all $j=1 \\dots n$,</p>\n  \n  <p>$$ \\frac{w_{jj}}{1+\\sum_{c(i)=c(j),i \\neq j} w_{ij}} \\ge \\beta $$</p>\n  \n  <p>where $c(i)$ shows the color of the edge $e_{ii}$.</p>\n</blockquote>\n\n<hr>\n\n<p><strong>Old Formulation</strong></p>\n\n<p>The following problem looks NP-hard to me, but I couldn\'t show it. Any proof/comment to show the hardness or easiness of it is appreciated.</p>\n\n<blockquote>\n  <p>Assume $K_n=\\langle V,E \\rangle$ is a complete weighted directed graph\n  with $n$ nodes and $n(n-1)$ edges. Let $w_{ij} \\ge 0$ show the weight\n  of the edge $ij$ and $c(ij)$ shows the color of edge $ij$. Given a subset\n  of the edges $T \\subseteq E$ and a positive constant $\\beta$ the goal is:\n  find the minimum number of colors such that for each $e_{ij} \\in T$:</p>\n  \n  <p>$$ \\frac{w_{ij}}{1+\\sum_{c(kl)=c(ij),kl \\neq ij} w_{kj}} \\ge \\beta. $$\n  and\n  $$ c(ij) \\neq c(ik) \\quad for \\quad j \\neq k $$</p>\n</blockquote>\n\n<p>Please note that in the above problem, only the edges in $T$ needs to be colored. That is the problem can be solved in $\\mathcal{O}(|T|!)$.</p>\n\n<p><strong>Update:</strong></p>\n\n<p>After Tsuyoshi Ito\'s comment I updated the problem. The denominator is changed from $1+\\sum_{c(kj)=c(ij),k \\neq i,e_{kj} \\in T} w_{kj}$ to $1+\\sum_{c(kl)=c(ij),kl \\neq ij} w_{kj}$. Therefore, the denominator contains the weights outside $T$ as well. That\'s actually why I mentioned the complete graph in the definition.</p>\n\n<p>I also added an additional constraint $c(ij) \\neq c(ik) \\quad for \\quad j \\neq k$. That means, the outgoing edges from a node must be of different colors (but the incoming colors can be the same as long as the inequality holds). This puts an intuitive lower bound on the number of colors, which is the maximum out-degree of the nodes in $T$.</p>\n\n<p>As Tsuyoshi mentioned, $w_{ij}$\'s, $T$, and $\\beta$ are inputs to the problem and the edge colors are the output.</p>\n\n<p><strong>Update 2:</strong></p>\n\n<p>Problem does not enforce the edges $e_{ij}$ and $e_{ji}$ be of a same color.</p>\n', 'Tags': '<complexity-theory><graphs><graph-theory><np-complete>', 'LastEditorUserId': '1672', 'LastActivityDate': '2012-07-10T23:58:44.517', 'CommentCount': '11', 'AcceptedAnswerId': '2687', 'CreationDate': '2012-05-29T08:27:39.603', 'Id': '2157'},63_33:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a directed acyclic graph where edge (A,B) means that vertex A depends on vertex B. </p>\n\n<p>Vertex deletions have the following restrictions:</p>\n\n<ol>\n<li>When vertex B is removed, all dependent vertexes should also be removed. </li>\n<li>When vertex  A is removed and vertex A was the only vertex that depends on B, vertex B should also be removed.</li>\n</ol>\n\n<p><img src="http://i.stack.imgur.com/qeDQd.png" alt="enter image description here"></p>\n\n<p>I need to list the vertixes which are deleted when</p>\n\n<ol>\n<li><p>Vertex B is deleted. My solution is B, E and J because</p>\n\n<ul>\n<li>B -- deleted</li>\n<li>E -- because of condition 2, B is removed and B was the only vertex that depends on E</li>\n<li>J -- because of condition 2</li>\n</ul></li>\n<li><p>Vertex C is deleted. My solution is C, F, A, G, ... ?</p>\n\n<ul>\n<li>C -- deleted</li>\n<li>F -- because of condition 2 (C is the only vertex to F)</li>\n<li>A -- condition 1 (depends on C)</li>\n<li>G -- condition 2 (C is the only vertex to G)</li>\n<li>I think here the process goes on and cascades. Is that correct?</li>\n</ul></li>\n</ol>\n\n<p>What could be an algorithm for such vertexes dependency network which allows for the vertex deletion?</p>\n\n<p>PS: this is an old exam exercise (2008/09); I use it as exercise for my one middle of June.</p>\n', 'ViewCount': '454', 'Title': 'Dependency Graph - Acyclic graph', 'LastEditorUserId': '31', 'LastActivityDate': '2012-06-01T20:50:34.107', 'LastEditDate': '2012-06-01T08:54:17.570', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-06-01T07:35:22.473', 'Id': '2186'},63_34:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a weighted graph $G$ has two different minimum spanning trees $T_1 = (V_1, E_1)$ and $T_2 = (V_2, E_2)$, then is it true that for any edge $e$ in $E_1$, the number of edges in $E_1$ with the same weight as $e$ (including $e$ itself) is the same as the number of edges in $E_2$ with the same weight as $e$? If the statement is true, then how can we prove it?</p>\n', 'ViewCount': '1156', 'Title': 'Do the minimum spanning trees of a weighted graph have the same number of edges with a given weight?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-14T20:29:01.367', 'LastEditDate': '2012-06-02T23:23:48.057', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2211', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<graph-theory><spanning-trees><weighted-graphs>', 'CreationDate': '2012-06-02T22:25:00.557', 'Id': '2204'},63_35:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>A graph is 2\u2200-connected if it remains connected even if any single edge is removed. Let G = (V, E) be a connected undirected graph. Develop an algorithm as fast as possible to check 2\u2200-connectness of G.</p>\n\n<p>I know the basic idea is to build a DFS searching tree and then check each edge is not on a circle with DFS. Any help would be appreciated.</p>\n\n<p>What I expect to see is a detailed algorithm description(especially the initialization of needed variables which is obscure sometimes), complexity analysis could be omitted.</p>\n', 'ViewCount': '100', 'Title': u'Algorithm to check the 2\u2200-connectness property of a graph', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-17T13:44:12.877', 'LastEditDate': '2012-06-17T13:39:54.627', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2397', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1875', 'Tags': '<algorithms><graphs><efficiency>', 'CreationDate': '2012-06-16T15:33:06.990', 'Id': '2394'},63_36:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose we have a directed graph $G=(V,E)$ and two nodes $A$ and $B$.\nI would like to know if there are already algorithms for calculating the following decision problem: </p>\n\n<blockquote>\n  <p>Are there at least two paths between $A$ and $B$ of the same length?</p>\n</blockquote>\n\n<p>How about the complexity? Can I solve it in polynomial time?</p>\n\n<hr>\n\n<p>I would like to add a new constrain on the graph, maybe the problem is more solvable.\nOn adjacency matrix, every column is not empty. So, every node has at least one arrow on input and there is also at least one node connected to itself. So if the node is the $i$-th node, then $(i,i)$ is an edge in the graph.</p>\n', 'ViewCount': '363', 'Title': 'Finding at least two paths of same length in a directed graph', 'LastEditorUserId': '1974', 'LastActivityDate': '2012-07-03T20:59:07.823', 'LastEditDate': '2012-06-27T16:49:56.487', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '17', 'PostTypeId': '1', 'OwnerUserId': '1974', 'Tags': '<complexity-theory><graph-theory><time-complexity><graphs>', 'CreationDate': '2012-06-26T12:12:27.963', 'FavoriteCount': '6', 'Id': '2498'},63_37:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '383', 'Title': 'Getting parallel items in dependency resolution', 'LastEditDate': '2012-06-28T22:30:03.503', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1995', 'FavoriteCount': '2', 'Body': '<p>I have implemented a topological sort based on the <a href="http://en.wikipedia.org/wiki/Topological_sort" rel="nofollow">Wikipedia article</a> which I\'m using for dependency resolution, but it returns a linear list. What kind of algorithm can I use to find the independent paths?</p>\n', 'Tags': '<algorithms><graphs><parallel-computing><scheduling>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-06-28T22:30:03.503', 'CommentCount': '1', 'AcceptedAnswerId': '2525', 'CreationDate': '2012-06-28T09:12:35.827', 'Id': '2524'},63_38:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for an algorithm, which given a graph $G$ and a natural number $t$, determines if $G$ is <a href="http://en.wikipedia.org/wiki/Symmetric_graph">$t$-transitive</a>.</p>\n\n<p>I am also interested in knowing if this problem is in P, NP, NPC or some other interesting facts about its complexity class.</p>\n', 'ViewCount': '105', 'Title': 'Algorithm to test a graph for $t$-transitivity', 'LastEditorUserId': '1350', 'LastActivityDate': '2012-07-01T19:45:15.080', 'LastEditDate': '2012-06-28T13:52:50.560', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1350', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-06-28T12:59:46.923', 'Id': '2527'},63_39:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a run-time implementation question regarding the 3-dimensional (unweighted 2-)approximation algorithm below:\nHow can I construct the maximum matching M_r in S_r in linear time in line 8?</p>\n\n<p>$X, Y, Z $ are disjoint sets; a matching $M$ is a subset of $S$ s.t. no two triples in $M$ have the same coordinate at any dimension.</p>\n\n<p>$\n\\text{Algorithm: unweighted 3-dimensional matching (2-approximation)} \\\\\n\\text{Input: a set $S\\subseteq X \\times Y \\times Z$ of triples} \\\\\n\\text{Output: a matching M in S}\n$</p>\n\n<pre><code> 1) construct maximal matching M in S;  \n 2) change = TRUE;  \n 3) while (change) {  \n 4)   change = FALSE;  \n 5)   for each triple (a,b,c) in M {  \n 6)     M = M - {(a,b,c)};  \n 7)     let S_r be the set of triples in S not contradicting M;  \n 8)     construct a maximum matching M_r in S_r;  \n 9)     if (M_r contains more than one triple) {  \n10)       M = M \\cup M_r;  \n11)       change = TRUE;  \n12)     } else {  \n13)       M = M \\union {(a,b,c)};  \n14)     }  \n15) }  \n</code></pre>\n\n<hr>\n\n<p>[1] <a href="http://faculty.cse.tamu.edu/chen/courses/cpsc669/2011/notes/ch9.pdf" rel="nofollow">http://faculty.cse.tamu.edu/chen/courses/cpsc669/2011/notes/ch9.pdf</a>, p. 326</p>\n', 'ViewCount': '459', 'Title': '3-dimensional matching approximation algorithm (implementation details)', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T19:29:47.290', 'LastEditDate': '2013-01-13T19:29:47.290', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2574', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2037', 'Tags': '<algorithms><graphs><approximation><matching>', 'CreationDate': '2012-07-01T17:27:37.793', 'Id': '2571'},63_40:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '110', 'Title': 'Proof of NP-completeness of graph isomorphism through edge contractions that reduce a metric', 'LastEditDate': '2013-10-08T10:13:01.373', 'AnswerCount': '0', 'Score': '4', 'OwnerDisplayName': 'Yinfang Zhuang', 'PostTypeId': '1', 'FavoriteCount': '0', 'Body': '<blockquote>\n  <p><strong>Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2634/np-completeness-or-not">NP-completeness of graph isomorphism through edge contractions with an edge validity condition</a>  </p>\n</blockquote>\n\n\n\n<p>I know that graph contractability is $NP$-complete. To be specific given $G=(V_1,E_1)$ and $H=(V_2,E_2)$, can a graph isomorphic to H be obtained from G by a sequence of edge contractions ?</p>\n\n<p>However my problem is a little bit different from the traditional graph contractability. In the traditional graph contractability problem we contract the original graph by different sequences of edge mergings. However in my problem each node is associated with some metric. At each step only a subset of edges are candidates for contracting or merging. Contracting one edge may affect the subset of edges that are legal for contracting at next step. By contracting one edge, we also replace the metrics of the two endpoint nodes with a new smaller metric. We are trying to find an H such that the sum of the metrics of nodes in H is minimal. </p>\n\n<p>Any hint on whether this problem is $NP$-hard($NP$-complete) or not. If so any hint on how to prove it ?</p>\n\n<p><strong>Here are more descriptions: Each node has a 0/1-string label. We define a function to measure the similarity between two labels of the adjacent nodes(i.e. the length of the common prefix of the two labels). At each step only the two adjacent nodes with maximal similarity can be merged (there may be several of them). After we merge the two nodes we label the new node with the common prefix of the original two labels. We also have to preserve the uniqueness of the label. We do no merge if it violates uniqueness of labels. We add up the length of the label of each node in the final graph and try to find the minimum of this number. Or in a more abstract sense, Is labeled graph G contractible (while maintaining our needed invariants e.g. uniqueness of labels) to (given) labeled graph H ?</strong></p>\n', 'ClosedDate': '2012-07-09T09:29:20.120', 'Tags': '<graph-theory><graphs><np-complete>', 'LastEditorUserId': '917', 'LastActivityDate': '2013-10-08T10:13:01.373', 'CommentCount': '5', 'CreationDate': '2012-06-30T15:25:26.993', 'Id': '2573'},63_41:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2349', 'Title': 'Prove that every two longest paths have at least one vertex in common', 'LastEditDate': '2012-07-17T06:12:37.340', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': '<p>If a graph $G$ is connected and has no path with a length greater than $k$, prove that every two paths in $G$ of length $k$ have at least one vertex in common.  </p>\n\n<p>I think that that common vertex should be in the middle of both the paths. Because if this is not the case then we can have a path of length $&gt;k$. Am I right?</p>\n', 'Tags': '<graph-theory><graphs><combinatorics>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T06:12:37.340', 'CommentCount': '5', 'AcceptedAnswerId': '2622', 'CreationDate': '2012-07-04T16:17:48.280', 'Id': '2615'},63_42:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given Graphs $G=(V_1,E_1)$ and $H=(V_2,E_2)$. Can a graph isomorphic to $H$ be obtained from $G$ by a sequence of edge contractions ? We know this problem is NP-complete. What about if only a subset of edges are valid for contraction at each step of the sequence. For example when deciding the first edge for contraction, there are only a subset $E'\\subset E_1$ of edges eligible for contraction. If you pick $e\\in E'$ for contraction and get an intermediate graph then when deciding the second edge for contraction in this intermediate graph there are a subset $E''$ of edges eligible for contraction and so on. </p>\n\n<p>Does this problem stay NP-complete ? </p>\n", 'ViewCount': '267', 'Title': 'NP-completeness of graph isomorphism through edge contractions with an edge validity condition', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-09T09:35:13.907', 'LastEditDate': '2012-07-09T09:35:13.907', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2090', 'Tags': '<complexity-theory><computability><graphs><np-complete><np-hard>', 'CreationDate': '2012-07-06T02:40:35.660', 'Id': '2634'},63_43:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to understand the approach for this problem:</p>\n\n<blockquote>\n  <p>"If all streets are one way, there is still a legal way to drive from\n  one intersection to another"</p>\n</blockquote>\n\n<p>The question is to prove that it can be done in linear time. I am not looking for direct answers but the approach to this problem.</p>\n\n<p>How can I think about this problem in terms of graph theory? AFAI understand, this will result in a DAG. But then should I choose BFS or DFS and why to prove it? (both are liner time algos)</p>\n', 'ViewCount': '122', 'Title': 'Existence of a route following one-way streets', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-23T23:19:37.897', 'LastEditDate': '2012-07-17T05:56:03.863', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '271', 'Tags': '<algorithms><graphs><algorithm-analysis>', 'CreationDate': '2012-07-10T17:53:32.663', 'Id': '2674'},63_44:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the set of graphs in which the maximum degree of the vertices is a constant number $\\Delta$ independent of the number of vertices. Is the vertex coloring problem (that is, color the vertices with minimum number of colors such that no pair of adjacent nodes have the same color) on this set still NP-hard? Why?</p>\n', 'ViewCount': '92', 'Title': 'Vertex coloring with an upper bound on the degree of the nodes', 'LastActivityDate': '2012-07-17T14:39:49.543', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2692', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1672', 'Tags': '<algorithms><complexity-theory><graph-theory><graphs><np-complete>', 'CreationDate': '2012-07-11T10:26:02.150', 'Id': '2690'},63_45:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '130', 'Title': 'Assign m agents to N points by minimizing the total distance', 'LastEditDate': '2012-07-16T20:18:03.193', 'AnswerCount': '2', 'Score': '4', 'OwnerDisplayName': 'd. th. man', 'PostTypeId': '1', 'OwnerUserId': '2192', 'Body': '<p>Suppose we have $N$ fixed points (set $S$ with $|S|=N$) on the plane and $m$ agents with fixed, known initial positions ($m&lt;N$) outside $S$. We should transfer the agents so that in our final configuration they are all positioned to different points of $S$. How could we achieve it by minimizing the total distance covered by the agents? </p>\n', 'Tags': '<algorithms><graphs><optimization>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-18T01:55:49.667', 'CommentCount': '3', 'AcceptedAnswerId': '2772', 'CreationDate': '2012-07-15T16:18:37.857', 'Id': '2771'},63_46:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is there a way to reconstruct a binary tree just from its in-order representation?</p>\n\n<p>I've searched the internet, but I could only find solutions for reconstructing a binary tree from inorder and preorder representations, but none for only inorder.</p>\n", 'ViewCount': '316', 'Title': 'From in-order representation to binary tree', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-19T21:10:44.540', 'LastEditDate': '2012-07-19T08:49:01.357', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'papen', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><binary-trees>', 'CreationDate': '2012-07-18T19:23:00.627', 'Id': '2817'},63_47:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is there a way to create a single edge on a graph that connects 3 or more nodes? For example, let's say that the probability of Y occurring after X is 0.1, and the probability of Z occurring after Y is 0.001, but the probability of Z occurring after <em>both</em> X and Y occur is 0.95. If the probabilities are assigned to each edge as weights, how can I make this happen?</p>\n\n<p>$$X _\\overrightarrow{0.1} Y$$</p>\n\n<p>$$Y _\\overrightarrow{0.001} Z$$</p>\n\n<p>$$\\overrightarrow{X \\underrightarrow{} Y \\underrightarrow{0.95}} Z$$</p>\n", 'ViewCount': '110', 'Title': 'An edge that connects more than two nodes in a graph?', 'LastEditorUserId': '2214', 'LastActivityDate': '2012-07-20T01:26:43.280', 'LastEditDate': '2012-07-19T21:55:12.563', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2214', 'Tags': '<algorithms><graphs><probabilistic-algorithms><weighted-graphs>', 'CreationDate': '2012-07-19T21:42:57.053', 'Id': '2826'},63_48:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Lets say I have node A that connects to 10 other nodes. 6 of those nodes have Property 1 and the other 4 have Property 2. How can I easily determining the probability of landing on a node with property 1 randomly while traversing the graph?</p>\n\n<h1>Abstract Example</h1>\n\n<p>To clarify this problem, I\'m trying to choose the most probable path.</p>\n\n<p>I have a node $v$ with 10 edges going out, and 6 of the nodes on the other end have a certain property $A$, while 4 have a certain property $B$. Now, each of the 10 nodes also has 10 edges going out, and at the end there are 10 nodes, some with property $A$, some with property $B$. The key here is that each property denotes <strong>an occurrence of something.</strong> Using multiple nodes here is basically a replacement for weighted edges. Rather than having an edge with weight 6 leading to $A$, I have 6 occurrences of $A$. I know this sounds counterintuitive, but this is actually a smaller part of a much, much large problem.</p>\n\n<p>I want to find the most likely sequence of something occurring. We can see that there is a 0.6 probability of $A$ occurring. How can I easily determine that?</p>\n\n<p>Basicslly, the question comes down to how can I traverse a graph of probabilities made from a graph of occurrences without having to completely generate a new graph. The brute force method to this would be to start at $v$, count the number of occurrences of $A$ and the number of occurrences of $B$, determine the probability of each, and then on a new graph have an edge from $v$ to $A$ with a weight 0.6. Adter that, you would then go to each occurrence of A, make a list of the difference occurrences branching from that, find the probability of each (with the many occurrences of $A$ acting as one node), then on the new graph, add an edge to each occurrence.</p>\n\n<p>This may seem like a lot of work, but with the algorithm that I am designing, each node may have a dozen properties. I want to be able to quickly traverse the graph taking the most likely path through certain properties, which could be different for each property of every combination of properties.</p>\n\n<h1>Applied Example</h1>\n\n<p><img src="http://i.stack.imgur.com/GHJwZ.jpg" alt="The basic graph."></p>\n\n<p>Now, let\'s say that each node on this graph represents an event. Each event can have 9 different properties, and each event is dependent on the last one. For the sake of argument, let\'s that that the property being considered here is property 4. That doesn\'t really matter, I\'m only noting it to point out that different properties lead to different simplified graphs (more below).</p>\n\n<p>On <em>Level 0</em> of the first graph (the black graph), we have event 1 takes occurs. Causing event 1 to occur causes a set of 13 other events to occur on <em>Level 1</em>, $\\{A,A,A,A,A,A,B,B,B,B,C,C,D\\}$. We can see that out of all of the events, $A$ is the most common result for property 4.</p>\n\n<p>Now that we know what property to look for, we can look at the events on <em>Level 2.</em> The first occurrence of $A$ causes a set of events where property 4 is $\\{E,G,G\\}$, the second occurrence of $A$ causes a set of events where property 4 is $\\{E,F,G\\}$, and so on. Now, we have all these separate nodes, but we can pretend that they are actually one big node since we are only looking at one property.</p>\n\n<p>Because of this, the set of property 4 of events that occur on <em>Level 2</em> is $\\{E,G,G,E,F,G,G,H,I,G,G,G,G,E,F,G\\}$. The highest probability of the next event is that of $G$ where the probability is $9/16$.</p>\n\n<p>This yields us the simplified graph shown below:</p>\n\n<p><img src="http://i.stack.imgur.com/mF7GZ.jpg" alt=""></p>\n\n<p>This shows us the most likely value of property 4 after we initiate event 1 and allow it to go two steps. If event 1 occurs, the most likely value for property 4 will be $A$. After another event in the chain reaction occurs, the most likely value of property 4 will be $G$.</p>\n\n<p>And before you ask, <strong>no, a longest-path algorithm is not appropriate for this application.</strong> It would take another 3 pages to explain why that is, but basically, it doesn\'t matter if $D$ has the lowest probability but the events after it all have very high probabilities, we need to look at each edge independently.</p>\n\n<h1>Methods that Won\'t Work</h1>\n\n<p>One possible method I could use would be to render a graph for each separate property, but that would just be too much. I could generate the graph for property 4 and yield the graph in the second image, but if I added one more occurrence anywhere in the original graph, I would have to regenerate the graph for every single property, which is too much work when you are dealing with tens or hundreds of thousands of nodes.</p>\n\n<p>So, the question remains: is there a tried and true algorithm for calculating probabilities for the next level as I move along the graph, or will I have to develop something on my own?</p>\n', 'ViewCount': '280', 'Title': 'Determining Probability from a Graph', 'LastEditorUserId': '2214', 'LastActivityDate': '2014-01-21T22:53:27.153', 'LastEditDate': '2012-07-23T18:16:33.980', 'AnswerCount': '1', 'CommentCount': '28', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2214', 'Tags': '<graphs><probability-theory>', 'CreationDate': '2012-07-23T12:30:30.980', 'FavoriteCount': '2', 'Id': '2875'},63_49:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '415', 'Title': 'Generating inputs for random-testing graph algorithms?', 'LastEditDate': '2012-08-04T16:01:43.273', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '2', 'Body': '<p>When testing algorithms, a common approach is random testing: generate a significant number of inputs according to some distribution (usually uniform), run the algorithm on them and verify correctness. Modern testing frameworks can generate inputs automatically given the algorithms signature, with some restrictions.</p>\n\n<p>If the inputs are numbers, lists or strings, generating such inputs in straight-forward. Trees are harder, but still easy (using stochastic context-free grammars or similar approaches).</p>\n\n<p>How can you generate random graphs (efficiently)? Usually, picking graphs uniformly at random is not what you want: they should be connected, or planar, or cycle-free, or fulfill any other property. Rejection sampling seems suboptimal, due to the potentially huge set of undesirable graphs.</p>\n\n<p>What are useful distributions to look at? Useful here means that</p>\n\n<ul>\n<li>the graphs are likely to test the algorithm at hand well and</li>\n<li>they can be generated effectively and efficiently.</li>\n</ul>\n\n<p>I know that there are many models for random graphs, so I\'d appreciate some insight into which are best for graph generation in this regard.</p>\n\n<p>If "some algorithm" is too general, please use shortest-path finding algorithms as a concrete class of algorithms under test. Graphs for testing should be connected and rather dense (with high probability, or at least in expectation). For testing, the optimal solution would be to create random graphs around a shortest path so we <em>know</em> the desired result (without having to employ another algorithm).</p>\n', 'Tags': '<algorithms><graphs><randomness><software-testing>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-08T16:33:06.190', 'CommentCount': '1', 'AcceptedAnswerId': '2953', 'CreationDate': '2012-07-30T21:36:29.087', 'Id': '2952'},63_50:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3695', 'Title': 'Algorithm that finds the number of simple paths from $s$ to $t$ in $G$', 'LastEditDate': '2012-08-07T19:18:18.717', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '8', 'Body': '<p>Can anyone suggest me a linear time algorithm that takes as input a directed acyclic graph $G=(V,E)$ and two vertices $s$ and $t$ and returns the number of simple paths from $s$ to $t$ in $G$.<br>\nI have an algorithm in which I will run a DFS(Depth First Search) but if DFS finds $t$ then it will not change the color(from white to grey) of any of the nodes which comes in the path $s \\rightsquigarrow t$ so that if this is the subpath of any other path then also DFS goes through this subpath again.For example consider the adjacency list where we need to find the number of paths from $p$ to $v$.<br>\n$$\\begin{array}{|c|c c c|}\n\\hline \np &amp;o &amp;s &amp;z \\\\ \\hline\no &amp;r &amp;s &amp;v\\\\ \\hline\ns &amp;r \\\\ \\hline\nr &amp;y \\\\ \\hline\ny &amp;v \\\\ \\hline\nv &amp;w \\\\ \\hline\nz &amp; \\\\ \\hline\nw &amp;z \\\\ \\hline\n\\end{array}$$\nHere DFS will start with $p$ and then lets say it goes to $p \\rightsquigarrow z$ since it doesnot encounter $v$ DFS will run normally.Now second path is $psryv$ since it encounter $v$ we will not change the color of vertices $s,r,y,v$ to grey.Then the path $pov$ since color of $v$ is still white.Then the path $posryv$ since color of $s$ is white and similarly of path $poryv$.Also a counter is maintained which get incremented when $v$ is encountered.</p>\n\n<p>Is my algorithm correct? if not, what modifications are needed to make it correct or any other approaches will be greatly appreciated.</p>\n\n<p><strong>Note</strong>:Here I have considered the DFS algorithm which is given in the book <em>"Introduction to algorithms by Cormen"</em> in which it colors the nodes according to its status.So if the node is unvisited , unexplored and explored then the color will be white,grey and black respectively.All other things are standard.</p>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '778', 'LastActivityDate': '2012-08-09T22:57:36.403', 'CommentCount': '2', 'AcceptedAnswerId': '3087', 'CreationDate': '2012-08-07T19:11:55.220', 'Id': '3078'},63_51:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For some graphs, DFS and BFS search algorithms process nodes in the exact same order provided that they both start at the same node. Two examples are graphs that are paths and graphs that are star-shaped (trees of depth $1$ with an arbitrary number of children). Is there some way for categorizing graphs that satisfy this property?</p>\n', 'ViewCount': '478', 'Title': 'Graphs that cause DFS and BFS to process nodes in the exact same order', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-28T11:36:04.370', 'LastEditDate': '2012-09-24T11:25:55.257', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<algorithms><graphs><graph-traversal>', 'CreationDate': '2012-08-20T04:22:07.603', 'FavoriteCount': '2', 'Id': '3263'},63_52:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The rules are that you can only build from an existing part, so in the example below, B is the only option for the first move = A.</p>\n\n<p>A mechanical assembly might be represented as follows:</p>\n\n<pre><code>  E\n  |\n  C\n  |\nA-B\n  |\n  D\n  |\n  F\n</code></pre>\n\n<p>Where the valid assembly paths when starting from A are:</p>\n\n<pre><code>A, B, C, E, D, F\nA, B, C, D, E, F\nA, B, C, D, F, E\nA, B, D, F, C, E\nA, B, D, C, F, E\nA, B, D, C, E, F\n</code></pre>\n\n<p>This is a fairly simple example, but providing an upper bound for an arbitrary assembly is difficult since it\'s related to the "connectivity" of the parts.</p>\n\n<p>n! would be an absolute upper bound I guess, but I\'m hopping to find something a little better.</p>\n\n<p>I\'ve also looked at representing the graph with the parts (A, B, C, etc) as the edges and doing Kirchhoff\'s theorem, but that doesn\'t work for sparsely connected graphs like the example above.</p>\n\n<p>Any information about the problem would help.  I\'m not sure if there\'s a formal description of this type of problem or not.</p>\n', 'ViewCount': '60', 'Title': 'Given a mechanical assembly as a graph, how to find an upper bound on number of assembly paths', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-18T07:33:36.180', 'LastEditDate': '2012-08-25T04:09:37.150', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '4602', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2569', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-08-24T16:26:19.600', 'Id': '3314'},63_53:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a problem from CLRS 23-2 that I'm trying to solve. The problem assumes that given graph G is very sparse connected. It wants to improve further over Prim's algorithm $O(E + V \\lg V)$. The idea is to contract the graph, i.e. collapse two or more nodes into one node. So each reduction will reduce the graph by at least half nodes. The question is to come up with implementation such that time complexity of MST-REDUCE is $O(E)$. This uses set operations. MakeSet, Union and Find-Set. I've annotated my analysis in the picture along with algorithm. \nI'm thinking to implement the set as linked list here. So my make-set and find-set are $O(1)$. But Union sucks: $O(V)$. Since we are doing union for all the elements, we have total $O(V^2)$ time spent in union. Which gives amortized $O(V)$. Now the problem isn't clear whether it is expecting amortized time complexity or not. So I'm wondering if any better approach is possible. Note the algorithm is running for all nodes and all edges. Hence I think amortized makes sense.</p>\n\n<p>Here is my analysis (line, complexity)</p>\n\n<p>1-3 $V$ </p>\n\n<p>4-9 $\\frac{V}{2} \\cdot union = \\frac{V}{2} \\cdot \\frac{V}{2} = V^2 = V$ (amortized)</p>\n\n<p>10 $V \\cdot findset = V$</p>\n\n<p>12-21 $E \\cdot findset = E$</p>\n\n<p>Since $E &gt;= V - 1$, we have overall time complexity of $O(E)$. </p>\n\n<pre><code>0   MST-REDUCE(G, orig, c T)\n1   for each v in V[G]\n2       mark[v] &lt;- FALSE\n3       MAKE-SET(v)\n4   for each u in V[G]\n5       if mark[u] = FALSE\n6           choose v in Adj[u] such that c[u,v] is minimized.\n7           UNION(u,v)\n8           T &lt;- T union { orig(u,v) }\n9           mark[u] &lt;- mark[v] &lt;- TRUE\n10  V[G'] &lt;- { FIND-SET(v) : v in V[G] }\n11  E[G'] &lt;- { }\n12  for each (x,y) in E[G]\n13      u &lt;- FIND-SET(x)\n14      v &lt;- FIND-SET(y)\n15      if (u,v) doesn't belong E[G']\n16          E[G'] &lt;- E[G'] union {(u,v)}\n17          orig'[u,v] &lt;- orig[x,y]\n18          c'[u,v] &lt;- c[x,y]\n19      else if c[x,y] &lt; c'[u,v]\n20          orig'[u,v] &lt;- orig[x,y]\n21          c'[u,v] &lt;- c[x,y]\n22  construct adjacency list Adj for G'\n23  return G', orig', c', T\n</code></pre>\n", 'ViewCount': '671', 'Title': 'Show that the Minimum spanning tree Reduce Algorithm runs in O(E) on sparse graphs', 'LastEditorUserId': '2375', 'LastActivityDate': '2012-08-31T08:37:11.837', 'LastEditDate': '2012-08-31T08:37:11.837', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2375', 'Tags': '<algorithms><graph-theory><graphs><algorithm-analysis><runtime-analysis>', 'CreationDate': '2012-08-30T22:19:05.153', 'Id': '3375'},63_54:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to write an algorithm to find whether a directed circuit whose length is odd exists in a strongly connected digraph.</p>\n\n<p>Can anyone help me how to proceed with this problem???</p>\n', 'ViewCount': '476', 'Title': 'Finding odd directed circuit', 'LastEditorUserId': '72', 'LastActivityDate': '2012-09-12T22:41:45.780', 'LastEditDate': '2012-09-12T22:41:45.780', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2803', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-09-12T18:42:39.927', 'FavoriteCount': '1', 'Id': '3517'},63_55:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let Alice and Bob be two users chosen uniformly at random from a social network (e.g. Facebook). What is the probability that they are friends assuming that they share $k$ mutual friends?</p>\n\n<p>I am interested both in the experimental values (or estimates) from currently existing social networks (e.g. Facebook) and values predicted by random graph models for these social networks.</p>\n', 'ViewCount': '193', 'Title': 'What is the probability of friendship conditioned on the number of mutual friends', 'LastActivityDate': '2012-09-17T07:17:51.607', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<graph-theory><combinatorics><social-networks><random-graphs>', 'CreationDate': '2012-09-16T00:29:01.343', 'Id': '4571'},63_56:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>At my local squash club, there is a <a href="http://en.wikipedia.org/wiki/Ladder_tournament" rel="nofollow">ladder</a> which works as follows.</p>\n\n<ol>\n<li>At the beginning of the season we construct a table with the name of each\nmember of the club on a separate line.</li>\n<li>We then write the number\nof games won and the number of games played next to each name (in the form: player wins/games).</li>\n</ol>\n\n<p>Thus at the beginning of the season the table looks like this:</p>\n\n<pre><code>Carol 0/0\nBilly 0/0\nAlice 0/0\nDaffyd 0/0\n</code></pre>\n\n<p>Any two players may play a match, with one player winning. If the player nearest the bottom of the table wins, then the position of the players is switched. We then repeat step 2., updating the number of wins and games next to each player. For example, if Alice beats Billy, we have</p>\n\n<pre><code>Carol 0/0\nAlice 1/1\nBilly 0/1\nDaffyd 0/0\n</code></pre>\n\n<p>These matches go on throughout the season and eventually result in players being listed in approximate strength order.</p>\n\n<p>Unfortunately, the updating happens in a rather haphazard way, so mistakes are made. Below are some examples of invalid tables, that is, tables which could not be produced by correctly following the above steps for some starting order (we have forgotten the order we used at the beginning of the season) and sequence of matches and results:</p>\n\n<pre><code>Alice 0/1\nBilly 1/1\nCarol 0/1\nDaffyd 0/0\n\nAlice 2/3\nBilly 0/1\nCarol 0/0\nDaffyd 0/0\n\nAlice 1/1\nBilly 0/2\nCarol 2/2\nDaffyd 0/1\n</code></pre>\n\n<p>Given a table, how can we efficiently determine whether it is valid? We could start by noting the following:</p>\n\n<ol>\n<li><p>The order of the names doesn\'t matter, since we have forgotten the original starting order.</p></li>\n<li><p>The total number of wins should be half the sum of the number of games played. (This shows that the first example above is invalid.)</p></li>\n<li>Suppose the table is valid. Then there is a <a href="http://en.wikipedia.org/wiki/Multigraph" rel="nofollow">multigraph</a> - a graph admitting multiple edges but no loops - with each vertex corresponding to a player and each edge to a match played. Then the total number of games played by each player corresponds to the degree of the player\'s vertex in the multigraph. So if there\'s no multigraph with the appropriate vertex degrees, then the table must be invalid. For example, there is no multigraph with one vertex of degree one and one of degree three, so the second example is invalid. [We can efficiently check for the existence of such a multigraph.]</li>\n</ol>\n\n<p>So we have two checks we can apply to start off with, but this still allows invalid tables, such as the third example. To see that this table is invalid, we can work backwards, exhausting all possible ways the table could have arisen.</p>\n\n<p>I was wondering whether anyone can think of a polynomial time (in the number of players and the number of games) algorithm solving this decision problem?</p>\n', 'ViewCount': '398', 'Title': 'How to efficiently determine whether a given ladder is valid?', 'LastEditorUserId': '2883', 'LastActivityDate': '2013-08-19T09:10:40.150', 'LastEditDate': '2013-07-04T18:19:58.500', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '22', 'PostTypeId': '1', 'OwnerUserId': '2883', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-09-19T17:14:22.300', 'FavoriteCount': '5', 'Id': '4617'},63_57:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Am I correct in my observation that the cardinality of the maximum matching $M$ of a bipartite graph $G(U, V, E)$ is always equal to $\\min(|U|, |V|)$?</p>\n', 'ViewCount': '233', 'Title': 'Size of Maximum Matching in Bipartite Graph', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T19:28:25.763', 'LastEditDate': '2013-01-13T19:28:25.763', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4676', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2922', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2012-09-22T20:14:11.160', 'Id': '4675'},63_58:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a directed graph and two distinct vertices S and T, is there a polynomial-time algorithm which finds every vertex which is on at least one simple path from S to T?</p>\n\n<p>It is not difficult to find all vertices that are both successors of S and predecessors of T but this is only a superset of the set above. For example, consider the following graph:\nS -> a; a -> b; b -> c; b-> T; c -> a</p>\n\n<p>While a, b and c are all successors of S and predecessors of T, there is no simple path from S to T going through c (because every path from S to T going through c contains twice a and b).</p>\n\n<p>A closely related problem is the following:\nGiven a directed graph and three distinct vertices S and T and I, is there a polynomial-time algorithm to decide if there exist a simple path from S to T going through I.</p>\n\n<p>A polynomial-time algorithm to this latter problem can be use to build a polynomial algorithm to the former since we can apply it succesively by replacing I by every node in the graph (or more efficiently to every node that is both a succesor of S and a predecessor of T).</p>\n', 'ViewCount': '428', 'Title': 'How to find the vertices on simple path between two given vertices in a directed graph', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-29T11:34:22.223', 'LastEditDate': '2012-09-28T14:36:39.057', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2989', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-09-27T21:53:33.433', 'FavoriteCount': '1', 'Id': '4771'},63_59:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am learning about graph coloring. One of the exercise problems(grimaldi) led me to derive the chromatic polynomial for any cycle($C_n, n \\ge 3$).</p>\n\n<p>$P(C_n, \\lambda) = (\\lambda - 1)^n + (-1)^n(\\lambda - 1)$, where $\\lambda$ is the number of colours available</p>\n\n<p>Is it possible to interpret the terms of above polynomial? I need help doing the same.</p>\n', 'ViewCount': '132', 'Title': 'Chromatic polynomial of a cycle - Interpreting its terms', 'LastActivityDate': '2012-10-01T04:13:37.883', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2012-09-29T01:51:45.017', 'Id': '4787'},63_60:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to create an algorithm in linear time where if given a directed acyclic graph I can add edges to make it strongly connected components.</p>\n\n<p>I believe I have an algorithm to identify sources and sinks in the input list of edges in form</p>\n\n<pre><code>1 2\n2 5\n3 1 \netc\n</code></pre>\n\n<p>And I know that the minimum number of edges to be added in order to create connected components is equal to MAX(sources,sinks).</p>\n\n<p>My question is, is there a way to come up with where I should add edges so that I can have the minimum number and still be linear complexity?</p>\n\n<p>Here is an example of what I'm after.</p>\n\n<p>Given this input edges:</p>\n\n<pre><code>1 3\n1 4\n2 3\n2 4\n5 7\n5 8\n6 8\n6 9\n</code></pre>\n\n<p>Output these edges to be added:</p>\n\n<pre><code>3 1\n4 5\n7 6\n8 1\n9 2\n</code></pre>\n", 'ViewCount': '379', 'Title': 'If I have sources and sinks of a DAG can I find the minimum number of edges to be added to make it Strongly Connected?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-03T15:45:33.350', 'LastEditDate': '2012-10-03T11:58:04.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'ZAX', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-10-03T01:00:34.353', 'Id': '4848'},63_61:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>G{V, E} is directed, <strong>cyclic</strong>, weighted graph. What is the algorithm of finding all paths between any given two nodes?<br>\nCan you suggest any good reading?</p>\n', 'ViewCount': '465', 'Title': 'The path between any two nodes in cyclic directed graph', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-09T03:17:05.620', 'LastEditDate': '2012-10-09T03:17:05.620', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3067', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-10-05T12:01:57.987', 'FavoriteCount': '1', 'Id': '4883'},63_62:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm in a programming course and one Problem given to us is to mark the order in which BFS visits nodes in a weighted graph.</p>\n\n<p>My question is whether BFS adds the distance of the previous path while adding a new vertex, as that will definitely change the order in which the vertices are added?</p>\n", 'ViewCount': '727', 'Title': 'Does a weighted Breadth First search have "memory" when moving to the next vertex?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-10T09:35:03.177', 'LastEditDate': '2012-10-09T18:49:19.053', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'user73142', 'PostTypeId': '1', 'OwnerUserId': '3125', 'Tags': '<graphs>', 'CreationDate': '2012-10-09T12:05:47.543', 'Id': '4973'},63_63:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am studying <a href="http://en.wikipedia.org/wiki/Best-first_search" rel="nofollow">best first search</a> as it compares to BFS (breadth-first search) and DFS (depth-first search), but I don\'t know when BFS is better than best-first search. So, my question is </p>\n\n<blockquote>\n  <p>When would best-first search be worse than breadth-first search?</p>\n</blockquote>\n\n<p>This question is one of the back exercises in <em>Artificial Intelligence</em> by Rich &amp; Knight, and it asks for an answer in terms of time &amp; space complexity and allows you to define any heuristic function.</p>\n', 'ViewCount': '2151', 'Title': 'When would best first search be worse than breadth first search?', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-04T08:12:23.923', 'LastEditDate': '2012-11-04T06:23:27.297', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '6461', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1267', 'Tags': '<graphs><artificial-intelligence><search-algorithms>', 'CreationDate': '2012-10-17T15:52:14.500', 'Id': '6125'},63_64:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><strong>Inputs.</strong> I am given a finite set $S$ of symbols.  I know there should exist some total order $&lt;$ on $S$, but I\'m not given this ordering and it could be anything.</p>\n\n<p>I am also given a collection of assertions.  Each assertion takes the form $s_1&lt;s_2&lt;\\cdots&lt;s_m$, where $s_1,\\dots,s_m$ form a subset of the symbols of $S$.  The assertion probably won\'t mention all of the symbols of $S$, just a subset.  Each assertion will probably cover a different subset.</p>\n\n<p><strong>Warmup problem.</strong> The starter problem is: Given $n$ assertions, identify whether they are all internally self-consistent, i.e., whether there exists a total order on $S$ that is consistent with all of the assertions, and if so, output an example of such a total order.</p>\n\n<p><strong>The real problem.</strong> In practice, a few assertions might be faulty.  Almost all of them should be correct, though.  So, the real problem is: if the assertions are not all internally self-consistent, find a minimal subset of assertions to label as "probably-erroneous", such that if you remove the probably-erroneous assertions, the remainder are all self-consistent.</p>\n\n<p><strong>What I know.</strong> I know how to solve the warmup problem (just compute the transitive closure of the union of the partial orders given by each assertion, and check that the result is antisymmetric; or, in other words, create a graph with $S$ as vertex set and an edge $s\\to t$ if $s&lt;t$ appears in any assertion, then check for cycles).  However, I don\'t know how to solve the real problem.  Any ideas?</p>\n\n<p><strong>Real-world parameters.</strong> In the application domain where I\'ve run into this, $S$ might have up to a few hundred symbols, and I might have up to a few thousand assertions, with each assertion typically mentioning dozens of symbols.</p>\n', 'ViewCount': '112', 'Title': 'Given many partial orders, check them for consistency and report any that are not consistent', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-19T22:21:54.297', 'LastEditDate': '2012-10-19T18:36:26.050', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><graphs><approximation><finite-sets><partial-order>', 'CreationDate': '2012-10-19T17:25:00.620', 'FavoriteCount': '1', 'Id': '6173'},63_65:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a bipartite graph with $|E|=O(|V|^2)$, a super-source and a super-sink. I am looking for the min-cost max-flow (the max-flow of all possible max-flows that has the minimum cost).</p>\n\n<p>For the sake of my question, denote $n=|E|$.</p>\n\n<p>Are there algorithms that will run in $O(n^2)$, or even $O(n\\log(n))$, or for that matter anything less than $O(n^3)$? In my case, $n$ is ~100,000, so $O(n^3)$ is impractical for me.</p>\n\n<p>\'Extra\' questions (should these go under a separate question?):</p>\n\n<ol>\n<li>Do any of these supper multi-graphs (I have 2 edges from my super-source node to each of the "blue" nodes in my bipartite graph, and 2 edges from each of the "red" nodes to my super-sink node)?</li>\n<li>Are there efficient implementations of such algorithms (that run in less than $O(n^3)$, and support multi-graphs) in C++, C, or Python?</li>\n<li>If the answer is \'no\', what are popular approximation algorithms and their associated run times?</li>\n</ol>\n', 'ViewCount': '500', 'Title': 'Min cost max flow in bipartite run time', 'LastEditorUserId': '4283', 'LastActivityDate': '2014-03-18T21:51:17.517', 'LastEditDate': '2012-10-23T05:03:44.203', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4283', 'Tags': '<graph-theory><graphs><optimization>', 'CreationDate': '2012-10-22T17:25:16.093', 'Id': '6234'},63_66:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that the disjoint set datastructure is used   to keep track of the connected components of an undirected graph when the edges are added to the graph dynamically . I also know that is is used in <a href="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm" rel="nofollow">Kruskal\'s  algorithm for minimum spanning trees</a> . What are the other possible applications of this datastructure ?</p>\n', 'ViewCount': '487', 'Title': 'Practical applications of disjoint set datastructure', 'LastActivityDate': '2012-10-25T21:10:04.077', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6318', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graph-theory><data-structures><graphs>', 'CreationDate': '2012-10-25T12:40:07.410', 'FavoriteCount': '3', 'Id': '6308'},63_67:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We know that the clique problem is NP-complete. Is the restriction of the problem to bipartite graphs or planar graphs still NP-complete?</p>\n', 'ViewCount': '358', 'Title': 'Is the clique problem NP-complete also on bipartite or planar graphs?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T00:00:07.960', 'LastEditDate': '2012-10-29T21:57:01.987', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1402', 'Tags': '<complexity-theory><graph-theory><graphs><np-complete>', 'CreationDate': '2012-10-29T21:24:06.577', 'Id': '6375'},63_68:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m writing a JavaScript library for calculating graph measurements such as degree centrality, eccentrality, closeness and betweenness.</p>\n\n<p>In order to validate my library I use two exist applications <a href="http://gephi.org" rel="nofollow">Gephi</a> and <a href="http://nodexl.codeplex.com/" rel="nofollow">NodeXL</a> to run calculation with them.\nThe problem is I got what looks like different results.</p>\n\n<p>I build simple graph:</p>\n\n<pre><code>  (A) ----- (B)\n   |         |\n   |         | \n  (C) ----- (D)\n</code></pre>\n\n<p>Gephi gave those results:</p>\n\n<pre><code>A ecc=2 close=1.333 bet=0.5\nB ecc=2 close=1.333 bet=0.5\nC ecc=2 close=1.333 bet=0.5\nD ecc=2 close=1.333 bet=0.5\n</code></pre>\n\n<p>NodeXL gave those results:</p>\n\n<pre><code>A close=0.25 bet=0.5\nB close=0.25 bet=0.5\nC close=0.25 bet=0.5\nD close=0.25 bet=0.5\n</code></pre>\n\n<p>Note that NodeXL does not calculate eccentrality.</p>\n\n<p>Which one is right?<br>\nAre the results really different?</p>\n\n<p>I didn\'t normalize (or at least not intend to normalize) any results.</p>\n', 'ViewCount': '153', 'Title': 'Graph Closeness - Different result with gephi and NodeXL', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T14:54:03.650', 'LastEditDate': '2012-10-30T14:54:03.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6384', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4395', 'Tags': '<graph-theory><terminology><graphs>', 'CreationDate': '2012-10-30T09:37:41.223', 'Id': '6382'},63_69:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '985', 'Title': "Base of logarithm in runtime of Prim's and Kruskal's algorithms", 'LastEditDate': '2012-11-01T22:48:50.390', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'CodeKingPlusPlus', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Body': "<p>For Prim's and Kruskal's Algorithm there are many implementations which will give different running times. However suppose our implementation of Prim's algorithm has runtime $O(|E| + |V|\\cdot \\log(|V|))$ and Kruskals's algorithm has runtime $O(|E|\\cdot \\log(|V|))$.</p>\n\n<p>What is the base of the $\\log$?</p>\n", 'Tags': '<algorithms><time-complexity><graphs><algorithm-analysis><runtime-analysis>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T22:48:50.390', 'CommentCount': '3', 'AcceptedAnswerId': '6436', 'CreationDate': '2012-10-27T20:48:47.810', 'Id': '6435'},63_70:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am currently working on a project where I\'m using an implementation of Hoffman and Pavley\'s "<a href="http://dl.acm.org/citation.cfm?doid=320998.321004" rel="nofollow">Method for the Solution of the Nth Best Path Problem</a>" to find n-th best path through a directed graph. The implementation is based on <a href="http://quickgraph.codeplex.com/wikipage?title=Ranked%20Shortest%20Path" rel="nofollow">QuickGraph\'s Ranked Shortest Path implementation</a>.</p>\n\n<p>I have been trying to determine the complexity of Hoffman and Pavley\'s algorithm as well as QuickGraph\'s implementation, but without any luck -- so basically my question is if someone knows the complexity of the original method proposed by Hoffman and Pavley as well as the complexity of QuickGraph\'s implementation?</p>\n', 'ViewCount': '175', 'Title': "What is the complexity of Hoffman and Pavley's Nth best path algorithm?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T10:09:43.120', 'LastEditDate': '2012-11-02T10:09:43.120', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4433', 'Tags': '<algorithms><time-complexity><graphs><algorithm-analysis><shortest-path>', 'CreationDate': '2012-11-02T08:43:34.007', 'FavoriteCount': '1', 'Id': '6444'},63_71:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Take a Turing machine, with a terminating program, convert it to some representation of the machine which captures, in a lossless manner, its state as it performs the computation.</p>\n\n<p>So you have a complete representation of the machine, the program, and its internal organisation as it performs the computation.</p>\n\n<p>I am going to suggest a graphical form, nodes and edges, names for nodes.</p>\n\n<p>Take a second Turing machine with a slightly different program. This program is identical save that it performs a single unit of function from the first program in a non optimal way, say it performs the single unit 3 times, changing some value to the correct output the first time, taking it to some second result the second time and then finally returning again to the correct first result. Like a reflection.</p>\n\n<p>Would it not be possible for some statistical technique to analyse the graph of the two machines including their process and find a compression of the graph of the second machine, which is smaller in terms of the size of the graph of its process and yet consistent with the mode of operation of the machine.</p>\n\n<p>For instance a graph matching algorithm could find that there is a subgraph match between one portion of the the process graph of the first machine and one part of the process graph of the second machine and replace the subgraph of the second machine with the subgraph of the process of the first machine.</p>\n\n<p>How it would then alter the program of the second machine to generate that altered graph I am unsure of.</p>\n\n<p>Do such techniques exist? Where would I find them, or is the analysis flawed or incomplete in some way which prevents its operation? What should I learn to understand its implementation or the truth of its deficiency?</p>\n', 'ViewCount': '104', 'Title': 'Is it possible to analyse computation?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-02T21:06:44.393', 'LastEditDate': '2012-11-02T21:06:44.393', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4340', 'Tags': '<graphs><optimization><runtime-analysis><compilers><artificial-intelligence>', 'CreationDate': '2012-11-02T12:58:51.063', 'Id': '6452'},63_72:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We are given a graph with $n$ vertices, $m$ edges, and path edge costs of $x$. For vertices without a direct path that are distant exactly one neighbor, we can add new edge with edge cost $y$. Our task is to find shortest path (i.e minimum cost) between the start vertex and all others vertices.</p>\n\n<p>I have developed an algorithm, but I would like to create something faster than adding edges to the graph (via breadth-first search) and <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a>. Here are a couple examples:</p>\n\n<p><em>Example 1 Input:</em> For $x=3$, $y=1$</p>\n\n<p><img src="http://i.stack.imgur.com/RrBPA.png" alt="Example 1 Graph"></p>\n\n<p><em>Possible $y$ paths included:</em></p>\n\n<p><img src="http://i.stack.imgur.com/1lgvX.png" alt="Example 1 Graph with y"></p>\n\n<p><em>Output</em>: cost of shortest path from start node to node $i$ (assume that from start node to start node is 0)</p>\n\n<blockquote>\n  <p>1: 0<br>\n  2: 2<br>\n  3: 2<br>\n  4: 1<br>\n  5: 1<br>\n  6: 3  </p>\n</blockquote>\n\n<p><em>Example 2 Input</em>: For $x=3, y=2$</p>\n\n<p><img src="http://i.stack.imgur.com/Bsm7F.png" alt="Example 2 Graph"> </p>\n\n<p><em>Output</em>:  </p>\n\n<blockquote>\n  <p>1: 0<br>\n  2: 3<br>\n  3: 3<br>\n  4: 2<br>\n  5: 5  </p>\n</blockquote>\n', 'ViewCount': '264', 'Title': 'Shortest path in graph - upgrade an algorithm', 'LastEditorUserId': '4304', 'LastActivityDate': '2013-01-08T15:48:50.643', 'LastEditDate': '2012-11-03T04:47:38.037', 'AnswerCount': '0', 'CommentCount': '12', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4440', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-11-02T16:25:24.033', 'Id': '6453'},63_73:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I ran into the following problem:</p>\n\n<p>Given a directed acyclic graph with real-valued edge weights, and two vertices s and t, compute the minimum s-t cut.</p>\n\n<p>For general graphs this is NP-hard, since one can trivially reduce max-cut to it by simply reversing the edge weights (correct me if I'm wrong).</p>\n\n<p>What is the situation with DAGs? Can min-cut (or max-cut) be solved in polynomial time? Is it NP-hard and, if so, are there any known approximation algorithms?</p>\n\n<p>I tried to find work on this but wasn't able to (maybe I'm just using wrong keywords in my searches), so I was hoping somebody may know (or find) something about this.</p>\n", 'ViewCount': '521', 'Title': 'Minimum s-t cut in weighted directed acyclic graphs with possibly negative weights', 'LastActivityDate': '2012-11-05T21:05:51.660', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '6498', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '691', 'Tags': '<algorithms><complexity-theory><graph-theory><weighted-graphs>', 'CreationDate': '2012-11-04T18:19:49.463', 'Id': '6476'},63_74:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Looking for some tutorials / references that discuss Breadth First Search that takes into consideration the cost of paths, but could not find much information.</p>\n\n<p>Could someone refer a tutorial?</p>\n', 'ViewCount': '292', 'Title': 'Breadth First Search with cost', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-07T08:02:23.767', 'LastEditDate': '2012-11-06T14:28:43.053', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '6523', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4476', 'Tags': '<algorithms><reference-request><graphs><search-algorithms>', 'CreationDate': '2012-11-06T14:22:03.630', 'Id': '6514'},63_75:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As the net-evergreen <a href="http://www.snopes.com/holidays/christmas/santa/physics.asp">The Physics of Santa</a> establishes, it is physically impossible for Santa to get a gift to every kid on the planet. Route planning won\'t help much there, but can a good planning algorithm at least make sure that every kid gets a gift once in a while while Santa <em>also</em> serves as many kids as possible each year?</p>\n\n<hr>\n\n<p>Consider a complete graph with real, positive weights and a constant $k$. We want to solve a variant of the Travelling Sales Person problem:</p>\n\n<blockquote>\n  <p>Is there a circular route of length at most $k$ that serves more than $m$ nodes?</p>\n</blockquote>\n\n<p>The optimisation version would be:</p>\n\n<blockquote>\n  <p>Maximise the number of nodes that can be served with a circular route of length at most $k$.</p>\n</blockquote>\n\n<p>This is motivated by real-world limitations on routes: Santa has one night to deliver as many gifts as possible, a sales person has eight hours for one day\'s route, and so on.</p>\n\n<p>The first, but not final question is: how hard is this problem? Let\'s assume we can start at any node, but that should not make too much of a difference.</p>\n\n<p>Now, in order to model fairness, let\'s assume there are $N$ nodes and we can visit at most $M$ with every tour. Ideally, we would want that every node is visited $t\\cdot\\frac{M}{N}$ times across $t$ efficient tours. Since there may be bottleneck nodes that have to be visited more often in order to ensure routes visit many nodes, some will inevitably have to be visited less often. That also excludes the trivial approximation of removing once visited nodes until all have been visited.</p>\n\n<p>So, here is the final question. Let $T$ be the number of tours needed until all nodes have been visited by <em>efficient</em> $k$-tours. How can we algorithmically determine the minimal value of $T$ (and all the necessary routes)? How complex is this problem?</p>\n\n<p>I guess this is really a multi-criterial problem: each tour should visit as many nodes as possible while we want to keep tours as disjoint as possible.</p>\n', 'ViewCount': '179', 'Title': 'Can Santa be both fair and efficient?', 'LastActivityDate': '2012-11-09T03:48:37.460', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><graphs><scheduling>', 'CreationDate': '2012-11-07T11:10:15.287', 'FavoriteCount': '2', 'Id': '6531'},63_76:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For directed graph $(G=(V, E),s,t,{Ce})$ in which we want to maximize max flow. All edge capacities are at least one. Define the capacity of an $s \\to t$ path to be the smallest capacities of constituent edges. The fastest path from $s$ to $t$ is the path with the most capcity.</p>\n\n<p>b) Show that the fastest path from $s$ to $t$ in a graph can be computed by Dijkstra's algorithm.</p>\n\n<p>c) Show that the maximum flow in $G$ is the sum of individual flows along at most $|E|$ paths from $s$ to $t$.</p>\n\n<p>It's one of the questions from my algorithms assignment, and I figured out (a), but can't get these two above.</p>\n", 'ViewCount': '418', 'Title': "Dijskstra's algorithm, maximum flow", 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-11T17:50:53.390', 'LastEditDate': '2012-11-09T22:10:28.233', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '4523', 'Tags': '<algorithms><graphs><optimization><shortest-path><network-flow>', 'CreationDate': '2012-11-09T19:31:05.533', 'Id': '6586'},63_77:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There may be a large number of algorithms proposed for generating graphs satisfying some common properties (e.g., clustering coefficient, average shortest path length, degree distribution, etc).</p>\n\n<p>My question concerns a specific case: I want to generate a few <em>undirected regular</em> graphs (i.e., every node in these graphs has the same number of neighbors) with different clustering coefficients and average shortest path lengths. More generally, by fixing a degree distribution, I want to generate graphs with different clustering coefficients and average shortest path lengths.</p>\n\n<p>I wonder what are the well-known algorithms for doing this (or in fact, is there any?), and what are the recommended software for the same purpose?</p>\n', 'ViewCount': '358', 'Title': 'Algorithms for graph generation using given properties', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T10:21:38.160', 'LastEditDate': '2012-11-18T18:43:46.823', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4641', 'Tags': '<algorithms><graph-theory><graphs><sampling>', 'CreationDate': '2012-11-18T17:26:39.090', 'FavoriteCount': '1', 'Id': '6744'},63_78:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A depth first search produces a spanning tree. If you perform DFS using all possible orderings of the adjacency list, wouldn't you find the minimum spanning tree? In other words, there is no example of a graph where a DFS won't find the minimum spanning tree regardless of how the adjacency list is ordered. Is this correct or not? I can't come up with a counter example and intuitively it seems correct...</p>\n", 'ViewCount': '703', 'Title': 'Depth First Search to find Minimum spanning tree', 'LastActivityDate': '2012-11-19T09:40:43.430', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4645', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2012-11-19T00:37:02.580', 'FavoriteCount': '1', 'Id': '6749'},63_79:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assume that we are given a real life graph, DBLP network in my case, where degree distribution of nodes follows a power law (many nodes have 1, 2 neighbors, and only a few nodes have hundreds of neighbors).</p>\n\n<p>A random walk ends when it returns to the initial node or when the walk takes 3 steps.\nIf we start random walks from each node on this graph, should we start equal number of walks from each node? If so, nodes with small degrees will often return to where they started, and we will not learn big portions of the network. This is because small degree nodes are neighbors of small degree nodes more often, so there will not be many paths to walk on.</p>\n\n<p>I believe there should be a way to decide on the number of walks to minimize computational costs. </p>\n', 'ViewCount': '174', 'Title': 'How many random walks to start from each node?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T03:31:55.453', 'LastEditDate': '2012-11-22T03:31:55.453', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4649', 'Tags': '<graph-theory><graphs><probability-theory><random-walks>', 'CreationDate': '2012-11-19T06:40:05.413', 'FavoriteCount': '1', 'Id': '6758'},63_80:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1104', 'Title': u"Modifying Dijkstra's algorithm for edge weights drawn from range $[1,\u2026,K]$", 'LastEditDate': '2012-11-21T08:01:32.647', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '2', 'Body': '<p>Suppose I have a directed graph with edge weights drawn from range $[1,\\dots, K]$ where $K$ is constant. If I\'m trying to find the shortest path using <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a>, how can I modify the algorithm / data structure and improve the time complexity to $O(|V|+|E|)$?</p>\n', 'Tags': '<algorithms><data-structures><shortest-path><weighted-graphs>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T20:43:49.977', 'CommentCount': '6', 'AcceptedAnswerId': '6820', 'CreationDate': '2012-11-21T03:08:52.193', 'Id': '6797'},63_81:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let us say you have a group of guys and and a group of girls. Each girl is either attracted to a guy or not, and vice versa. You want to match as many people as possible to a partner they like.</p>\n\n<p>Does this problem have a name? Is it feasibly solvable? Sounds hard to me...</p>\n\n<p>Ps. note that since the attraction is not neccessarily mutual the standard max-flow solution does not work.</p>\n', 'ViewCount': '120', 'Title': 'Matching girls with boys without mutual attraction (variant of maximum bipartite matching)', 'LastActivityDate': '2012-11-21T13:16:46.817', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6811', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2826', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2012-11-21T10:50:19.373', 'Id': '6807'},63_82:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3522', 'Title': 'Getting negative cycle using Bellman Ford', 'LastEditDate': '2012-11-26T15:11:04.630', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '2', 'Body': '<p>I have to find a negative cycle in a directed weighted graph. I know how the Bellman Ford algorithm works, and that it tells me if there is a reachable negative cycle. But it does not explicitly name it.</p>\n\n<p>How can I get the actual path $v1, v2, \\ldots vk, v1$ of the cycle?</p>\n\n<p>After applying the standard algorithm we already did $n-1$ iterations and no further improvement should be possible. If we can still lower the distance to a node, a negative cycle exists.</p>\n\n<p>My idea is: Since we know the edge that can still improve the path and we know the predecessor of each node, we can trace our way back from that edge until we meet it again. Now we should have our cycle.</p>\n\n<p>Sadly, I did not find any paper that tells me if this is correct. So, does it actually work like that?</p>\n\n<p><strong>Edit:</strong> This example proofs that my idea is wrong.\nGiven the following graph, we run Bellman-Ford from node $1$.</p>\n\n<p><img src="http://i.stack.imgur.com/pNLTw.png" alt="enter image description here"></p>\n\n<p>We process edges in the order $a, b, c, d$. After $n-1$ iterations we get <strong>node distances:</strong><br>\n$1: -5$<br>\n$2: -30$<br>\n$3: -15$</p>\n\n<p>and <strong>parent table:</strong><br>\n$1$ has parent $3$<br>\n$2$ has parent $3$<br>\n$3$ has parent $2$<br></p>\n\n<p>Now, doing the $n$th iteration we see that the distance of node $1$ can still be improved using edge $a$. So we know that a negative cycle exists and $a$ is part of it.</p>\n\n<p>But, by tracing our way back through the parent table, we get stuck in another negative cycle $c, d$ and never meet $a$ again.</p>\n\n<p>How can we solve this problem?</p>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '4298', 'LastActivityDate': '2013-05-22T22:30:41.320', 'CommentCount': '0', 'AcceptedAnswerId': '6921', 'CreationDate': '2012-11-26T14:27:26.067', 'Id': '6919'},63_83:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '151', 'Title': 'Showing that Independent set of size $k$ can be decided using logarithmic space', 'LastEditDate': '2012-11-27T08:05:39.133', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2329', 'FavoriteCount': '1', 'Body': "<p>An independent set $I$ is a subset of the nodes of a graph $G$ where: no 2 nodes in $I$ are adjacent in $G$. For natural number $k$, the problem $k-\\text{IND}$ asks if there is an independent set of size $k$.</p>\n\n<p>I'd really love your help with showing that $k-\\text{IND} \\in {\\sf L}$, i.e., can be decided using deterministic logarithmic space.</p>\n", 'Tags': '<complexity-theory><graphs><space-complexity>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-27T18:19:38.020', 'CommentCount': '3', 'AcceptedAnswerId': '6946', 'CreationDate': '2012-11-26T21:58:10.790', 'Id': '6933'},63_84:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for O(V+E) algorithm for finding the <a href="http://en.wikipedia.org/wiki/Transitive_reduction">transitive reduction</a> given a DAG. </p>\n\n<p>That is remove as many edges as possible so that if you could reach v from u, for arbitrary v and u, you can still reach after removal of edges.</p>\n\n<p>If this is a standard problem, please point me to some model solution.</p>\n', 'ViewCount': '475', 'Title': 'Transitive reduction of DAG', 'LastEditorUserId': '4717', 'LastActivityDate': '2012-12-07T05:06:19.067', 'LastEditDate': '2012-12-02T06:11:56.987', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4717', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-12-02T05:18:30.017', 'FavoriteCount': '1', 'Id': '7096'},63_85:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose\n$$A = \\left\\{\\langle G, d, s, t\\rangle \\;\\Bigg|\\;\n\\begin{array}{l}\n  \\text{\\(G\\) undirected}, \\\\\n  \\text{\\(s\\) and \\(t\\) are nodes in \\(G\\)}, \\\\\n  \\text{there is a path of length \\(d\\) from \\(s\\) to \\(t\\) and no path of shorter length}\n\\end{array}\\right\\}$$\nI can easily see that this language is in NL, but I am having trouble proving that this is NL-complete.</p>\n', 'ViewCount': '236', 'Title': 'Prove the following problem is NL-complete', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-03T21:04:47.773', 'LastEditDate': '2012-12-03T21:04:47.773', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<complexity-theory><graphs><space-complexity>', 'CreationDate': '2012-12-03T01:40:51.520', 'Id': '7115'},63_86:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a graph $G = (V,E)$, where $|V| = n$. What is a fast algorithm for generating the collection of all 2-hop neighborhood lists of all nodes in $V$. </p>\n\n<p>Naively, you can do that in $O(n^3)$. With power of matrices, you can do that with $O(n^{2.8})$ using Strassen algorithm. You can do better than this using another matrix multiplication algorithm. Any better method ? Any Las Vegas algorithm ? </p>\n', 'ViewCount': '422', 'Title': 'Algorithm to find all 2-hop neighbors lists in a graph', 'LastActivityDate': '2012-12-06T15:48:01.947', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7183', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '867', 'Tags': '<algorithms><algorithm-analysis><graphs><randomized-algorithms>', 'CreationDate': '2012-12-05T04:50:09.537', 'Id': '7169'},63_87:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the multiway cut problem, the input is an undirected graph $G= (V, E)$ and set of terminal nodes $s_1, s_2,\\ldots s_k$ are in $V$. The goal is to find a minimum\nset of edges in $E$ whose removal leaves all terminals in different components.</p>\n\n<ol>\n<li><p>How do we show that this problem can be solved exactly in polynomial time when\n$k= 2$?</p></li>\n<li><p>How do we get an approximation algorithm with ratio at most 2 for the case when $k \\geq 3$?</p></li>\n</ol>\n', 'ViewCount': '353', 'Title': '2OPT Approximation Algorithm for Multiway Cut Problem', 'LastEditorUserId': '19', 'LastActivityDate': '2013-04-02T15:47:46.743', 'LastEditDate': '2013-04-02T14:17:26.360', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'lam lae', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><approximation><network-flow>', 'CreationDate': '2012-12-02T22:34:14.450', 'Id': '7205'},63_88:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to solve a graph problem (it's not for homework, just to practice my skills). A DAG $G(V,E)$ is given, where $V$ is the set of vertices and $E$ the edges. The graph is represented as an adjacency list, so $A_v$ is a set containing all the connections of $v$. My task is to find which vertices are reachable from each vertex $v\\in V$. The solution I use has a complexity of  $O(V^3)$, with transitive closure, but i read that in a blog it can be faster, although it didn't reveal how. Could anyone tell me another way (with better complexity) to solve the transitive closure problem in a DAG? </p>\n", 'ViewCount': '1090', 'Title': 'Efficient algorithm for retrieving the transitive closure of a directed acyclic graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-08T07:54:26.363', 'LastEditDate': '2012-12-07T17:07:54.007', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4916', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-12-07T16:11:31.303', 'FavoriteCount': '1', 'Id': '7231'},63_89:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '904', 'Title': 'Retrieving the shortest path of a dynamic graph', 'LastEditDate': '2012-12-10T15:45:53.627', 'AnswerCount': '3', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '4916', 'FavoriteCount': '3', 'Body': "<p>I'm studying shortest paths in directed graphs currently. There are many efficient algorithms for finding the shortest path in a network, like dijkstra's or bellman-ford's. But what if the graph is dynamic? By saying dynamic I mean that we can insert or remove vertices during the execution of the program. I'm trying to find an efficient algorithm for updating the shortest paths from a vertex $v$ to every other vertex $u$, after inserting an edge $e$, without needing to run the shortest path algorithm in the new graph again. How can I do this? Thanks in advance.</p>\n\n<ul>\n<li><em>Note:</em> the changes can be done after the first iteration of the algorithm</li>\n<li><em>Note[2]:</em> two nodes are given, $s$ the source and $t$ the target. I need to find the shortest path between these nodes. When the graph is updated I only have to update $\\pi(s,t)$, which is the shortest path between $s$ and $t$.</li>\n<li><em>Note[3]:</em> I'm only interested in the edge insertion case.</li>\n</ul>\n\n<blockquote>\n  <p><strong>A formal definition</strong>: Given a graph $G = (V,E)$. Define an <em>update operation</em> as 1) an insertion of an edge $e$ to $E$ or 2) a a deletion of an edge $e$ from $E$. The objective is to find efficiently the cost of all pairs shortest paths after an update operation. By efficiently, we mean at least better than executing an All-Pairs-Shortest-Path algorithm, such as Bellman-Ford algorithm, after each update operation.</p>\n</blockquote>\n\n<hr>\n\n<p><strong>Edit:</strong> Below there is a simplified version of the problem:</p>\n\n<blockquote>\n  <p>A weighted graph $G(V,E)$ is given, consisting of unidirectional edges, and two critical vertices $s$ and $t$. A set $C$ of candidate <em>bidirectional</em> edges is also given. I have to build an edge $(u,v) \\in C$ to minimize the distance from $s$ to $t$.</p>\n</blockquote>\n", 'Tags': '<algorithms><data-structures><graphs><efficiency><shortest-path>', 'LastEditorUserId': '4916', 'LastActivityDate': '2013-06-12T10:15:55.483', 'CommentCount': '7', 'AcceptedAnswerId': '7260', 'CreationDate': '2012-12-08T11:22:28.103', 'Id': '7250'},63_90:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a homework question. I do not want the solution - I'm offering the solution I've been thinking of and wish to know whether is it good or why is it flawed.</p>\n\n<p>My motivation is to find what edges of an weighted, undirected graph are not a part of any MST. This problem only makes sense when several edges have the same weight, otherwise the MST is unique.</p>\n\n<p>My idea comes from Prim's Algorithm with a slight change - instead of adding the minimum edge from S to T on every step (where S and T being the two sets of vertex) - instead look for the minimum edge and more edges of the same value going from S to the vertex the minimum edge goes to. By doing that, (so I suppose) we will receive a graph containing all the edges which appear in any MST. If this is right, I can simply XOR the edges list with the original graph edges list to find what edges are not in any MST.</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '130', 'Title': 'What edges are not in any MST', 'LastEditorUserId': '5026', 'LastActivityDate': '2012-12-11T05:49:35.473', 'LastEditDate': '2012-12-11T05:49:35.473', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5026', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-10T22:51:01.253', 'Id': '7318'},63_91:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Below is the general code for DFS with logic for marking back edges and tree edges. My doubt is that back edges from a vertex go back and point to an ancestor and those which point to the parent are not back edges (lets assume undirected graph). In an undirected graph we have an edge back and forth between 2 vertices $x$ and $y$. So after visiting $x$ when I process $y$, $y$ has $x$ as an adjacent vertex, but as its already visited, the code will mark it as a back edge. Am I right in saying that? Should we add any extra logic to avoid this, in case my assumption is valid?</p>\n\n<pre><code>DFS(G)\n    for v in vertices[G] do\n         color[v] = white       \n         parent[v]= nil\n         time = 0       \n\n    for v in vertices[G] do\n        if color[v] = white then\n            DFS-Visit(v)\n</code></pre>\n\n<p>Induce a depth-first tree on a graph starting at $v$.</p>\n\n<pre><code>DFS-Visit(v)\n    color[v]=gray\n    time=time + 1\n    discovery[v]=time\n    for a in Adj[v] do\n        if color[a] = white then\n            parent[a] = v\n            DFS-Visit(a)&lt;br&gt;\n            v-&gt;a is a tree edge\n        elseif color[a] = grey then     \n            v-&gt;a is a back edge\n    color[v] = black \n    time = time + 1\n</code></pre>\n\n<p>white means <code>unexplored</code>, gray means <code>frontier</code>, black means `processed' </p>\n", 'ViewCount': '199', 'Title': 'Does the DFS algorithm differentiate between an ancestor and a parent while computing back edges?', 'LastEditorUserId': '4254', 'LastActivityDate': '2012-12-12T15:24:36.360', 'LastEditDate': '2012-12-12T15:24:36.360', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7353', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5038', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-12-11T19:09:53.367', 'Id': '7331'},63_92:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Consider a directed graph $G$ on which one can dynamically add edges and make some specific queries.</p>\n\n<h3>Example: disjoint-set forest</h3>\n\n<p>Consider the following set of queries:</p>\n\n<pre><code>arrow(u, v)\nequiv(u, v)\nfind(u)\n</code></pre>\n\n<p>the first one adds an arrow $u\u2192v$ to the graph, the second one decides if $u\u2194^*v$, the last one finds a canonical representative of the equivalence class of $\u2194^*$, i.e. a $r(u)$ such that $u\u2194^*v$ implies $r(v)=r(u)$.</p>\n\n<p>There is a <a href="http://en.wikipedia.org/wiki/Disjoint-set_data_structure#Disjoint-set_forests">well-known algorithm using the disjoint-set forest data structure</a> implementing these queries in quasi-constant amortized complexity, namely $O(\u03b1(n))$. Note that in this case <code>equiv</code> is implemented using <code>find</code>.</p>\n\n<h3>More complex variant</h3>\n\n<p>Now I\'m interested in a more complex problem where the directions do matter:</p>\n\n<pre><code>arrow(u, v)\nconfl(u, v)\nfind(u)\n</code></pre>\n\n<p>the first adds an arrow $u\u2192v$, the seconds decides if there is a node $w$ reachable from both $u$ and $v$, i.e. $u\u2192^*\u2190^*v$. The last one should return an object $r(u)$ such that $u\u2192^*\u2190^*v$ implies $r(u) \\bullet r(v)$ where $\\bullet$ should be easily computable. (In order to, say, computes <code>confl</code>). The goal is to find a good data structure such that these operations are fast.</p>\n\n<h3>Cycles</h3>\n\n<p>The graph can contain cycles.</p>\n\n<p>I don\'t know if there is a way to efficiently <em>and incrementally</em> compute the strongly connected components, in order to only consider DAGs for the main problem.</p>\n\n<p>Of course I would appreciate a solution for DAGs, too. It would correspond to an incremental computation of the least common ancestor.</p>\n\n<h3>Naive approach</h3>\n\n<p>The disjoint-set forest data structure is not helpful here, since it disregards the direction of the edges. Note that $r(u)$ cannot be a single node, in the case the graph is not confluent.</p>\n\n<p>One can define $r(u)=\\{v \u2223 u\u2192^*v\\}$ and to define $\\bullet$ as $S_1\\bullet S_2$ when $S_1 \u2229 S_2\u2260\u2205$. But how to compute this incrementally?</p>\n\n<p>Probably that computing such a big set is not useful, a smaller set should be more interesting, as in the usual union-find algorithm.</p>\n', 'ViewCount': '401', 'Title': 'Directed union-find', 'LastEditorUserId': '82', 'LastActivityDate': '2013-01-15T11:49:18.190', 'LastEditDate': '2012-12-15T13:34:20.250', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '82', 'Tags': '<algorithms><graphs><search-algorithms>', 'CreationDate': '2012-12-12T17:52:23.180', 'FavoriteCount': '1', 'Id': '7360'},63_93:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '8637', 'Title': 'How many edges must a graph with N vertices have in order to guarantee that it is connected?', 'LastEditDate': '2012-12-13T15:28:57.800', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/6801/every-simple-undirected-graph-with-more-than-n-1n-2-2-edges-is-connected">Every simple undirected graph with more than $(n-1)(n-2)/2$ edges is connected</a>  </p>\n</blockquote>\n\n\n\n<p>At lesson my teacher said that a graph with $n$ vertices to be certainly connected should have<br>\n$ {\\frac{n(n-1)}{2}+1 \\space }$ edges showing that (the follow is taken from the web but says the same thing):</p>\n\n<blockquote>\n  <p>The non-connected graph on n vertices with the most edges is a complete graph on \n  $n-1$ vertices and one isolated vertex. So you must have $ 1+\n{\\frac{n(n-1)}{2} \\space}$ edges to guarantee connectedness. </p>\n</blockquote>\n\n<p><strong>My idea:</strong> a complete graph $K_{n-1}$ with $n-1$ vertices has ${n-1 \\choose 2}$edges,  so ${\\frac{(n-1)*(n-2)}{2}}$ edges, added to the edge to connect the complete graph to the isolate vertex,</p>\n\n<p>so shouldn\'t be ${\\frac{(n-1)*(n-2)}{2}}+1$ edges?</p>\n\n<p>What am I doing wrong?</p>\n\n<p>Thanks.</p>\n', 'ClosedDate': '2012-12-17T00:47:19.893', 'Tags': '<graph-theory><graphs>', 'LastEditorUserId': '4765', 'LastActivityDate': '2012-12-13T15:42:26.470', 'CommentCount': '3', 'AcceptedAnswerId': '7375', 'CreationDate': '2012-12-13T10:57:30.183', 'Id': '7373'},63_94:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A question about the clique problem (specifically k-clique). Is there any algorithm that takes advantage of the properties of connected graphs to find cliques of a given size <code>k</code>, if such cliques exist?</p>\n', 'ViewCount': '308', 'Title': 'K-Clique in Connected Graphs', 'LastEditorUserId': '5063', 'LastActivityDate': '2012-12-15T09:48:55.380', 'LastEditDate': '2012-12-14T06:22:29.520', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5063', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-12-14T00:23:50.477', 'Id': '7393'},63_95:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to find a polynomial time algorithm for finding the minimum vertex cover for a graph. I've written the algorithm below; I know this problem is $\\mathsf{NP}$-hard, which means there are probably some graphs for which this algorithm will not work.</p>\n\n<p>I need some help in finding the flaw in this algorithm and also, an indication for what restrictions should be imposed on graphs such that this algorithm works.</p>\n\n<p>In the algorithm below I have a graph $G=(V,E)$. I also define the $\\text{priority}(v)$ function; in rough terms, it is the number of edges that are covered by vertex $v$. The function has the property that</p>\n\n<p>$$\\sum_{v \\in V} \\text{priority}(v) = \\text{number of edges}.$$</p>\n\n<p>In other words, an edge is counted as covered by only one of its vertices, not both. </p>\n\n<pre><code>Define degree : V -&gt; NaturalNumbers\ndegree(v) = number of edges connected to v, for all v in V\n\nDefine priority : V -&gt; NaturalNumbers\nInitialize priority(v) = 0 for all v in V\n\nFor all (u, v) in E:\n    If degree(u) &gt;= degree(v):\n        priority(u) = priority(u) + 1\n    Else\n        priority(v) = priority(v) + 1\n\nDefine S as the solution to the vertex cover problem\nInitialize S to the empty set\n\nFor all v in V:\n    If priority(v) != 0:\n        Add v to the set S\n\nOutput S as the solution\n</code></pre>\n", 'ViewCount': '219', 'Title': 'For what special cases does this vertex cover algorithm fail or work?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-05T17:23:44.537', 'LastEditDate': '2013-03-23T17:44:07.647', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7401', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5063', 'Tags': '<algorithms><graphs><np-complete><np-hard>', 'CreationDate': '2012-12-14T20:39:37.110', 'Id': '7400'},63_96:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given an undirected weighted graph $G$ with two edges of minimum weight and all other edges are distinct. Does G have a unique minimum spanning tree?</p>\n\n<p>I know the proof for if all edge weights are distinct (it does give a unique MST) and I am thinking that if two edges of minimum weight are in $G$ then I should be able to show a counter example. But so far I have not been able to produce one.</p>\n\n<p>So my question is does it give a unique MST if the graph $G$ contains two minimum weight edges?</p>\n', 'ViewCount': '1396', 'Title': 'Minimum spanning tree with two minimum edge weights', 'LastActivityDate': '2013-04-17T10:28:33.490', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-15T18:14:13.453', 'FavoriteCount': '1', 'Id': '7414'},63_97:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a random undirected graph with $n$ nodes, where each node has $k$ incident edges ($nk/2$ edges in total), the vertex set is  partitioned into two sets each having $n/2$ nodes.  </p>\n\n<blockquote>\n  <p>What is the order of the number of edges that start in one partition and end in the other?  </p>\n</blockquote>\n\n<p>My back of the napkin calculation is half of total number of edges, $nk/4$. If I place randomly an edge it has $1/4$ chance of having both ends in one partition, $1/4$ chance of having both ends in the other partition and $1/2$ chance of having the ends in both. I find it surprising that it could be half.</p>\n', 'ViewCount': '52', 'Title': 'Mean number of edges between two equal partitions', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-16T19:05:20.267', 'LastEditDate': '2012-12-16T19:05:20.267', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7435', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5081', 'Tags': '<graph-theory><graphs><random-graphs>', 'CreationDate': '2012-12-16T10:12:42.143', 'Id': '7433'},63_98:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to design an efficienct algorithm to color a unicyclic graph. I know if a graph does not contain any cycles (it's a tree) then it is 2-colorable. But cycles are either 2 (is even number of vertices) or 3 (is odd number of vertices) colorable. So if there contains just one cycle then the chromatic number of this unicyclic graph should be 3 (if the cycle contains an odd number of vertices).</p>\n\n<p>So enough of that. on to the algorithm.</p>\n\n<p>I would start at a vertex and color it color1. Now I would perform a BSF from the originator. Then each vertex that is adjacent to the originator vertex i would color it color 2, and continue this process of switching from color1 to color 2 unless if one of the vertices has an adjacent vertex that is already colored the same color. That means i found the cycle and will color that vertex color 3. If it had an adajcent vertex that was a different color than what i was going to color it then its an even number cycle and it would be 2-colorable.</p>\n\n<p>So that means, each step of the BFS I would check each vertex adjacent to the vertex selected for that step of the BFS. Therefore $O(|E|)$?</p>\n\n<p>is there a more efficient algorithm to color a unicyclic graph and is my time complexity correct?</p>\n", 'ViewCount': '124', 'Title': 'Coloring a Unicyclic Graph', 'LastActivityDate': '2012-12-25T11:21:47.680', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7462', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2012-12-16T19:45:56.453', 'FavoriteCount': '0', 'Id': '7444'},63_99:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Applying a max-flow algorithm to the graph it's trivially possible to find one or two vertex covers, inverting source and sink and the directions of the flows. Is it possible to find more?</p>\n", 'ViewCount': '54', 'Title': 'Can you obtain more than two vertex covers from a bipartite graph using a max-flow algorithm?', 'LastEditorUserId': '5111', 'LastActivityDate': '2012-12-18T09:13:16.797', 'LastEditDate': '2012-12-18T09:13:16.797', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'OwnerDisplayName': 'Boanerghes', 'PostTypeId': '1', 'OwnerUserId': '5111', 'Tags': '<graphs>', 'CreationDate': '2012-12-14T00:04:15.577', 'Id': '7474'},63_100:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are polynomial time algorithms to find maximum weighted matching in a general graph. Is there any algorithm that also handles negative weights in the general graph and find maximum weighted matching for that graph with negative weights ?</p>\n', 'ViewCount': '148', 'Title': 'Maximum weight matching', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T05:16:27.090', 'LastEditDate': '2013-01-13T05:16:27.090', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'user12902', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><matching>', 'CreationDate': '2012-12-19T17:54:18.953', 'Id': '7526'},63_101:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a question about the stable marriage algorithm, for what I know it can only be used when I have arrays with the same number of elements for building the preference and the ranking matrices.</p>\n\n<p>For example if we have 10 students that should be assigned to 10 dorms, then I can build the preference and ranking matrix of this data. The question that I have is what to do in the case that I have, for example, only 5 students to assign and for example 10 dorms. Can I still apply the stable marriage algorithm?</p>\n\n<p>Maybe this question is a little bit foolish, but as I said I only saw this algorithm applied to quadratic arrays.</p>\n', 'ViewCount': '261', 'Title': 'The stable marriage algorithm with asymmetric arrays', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-25T21:15:03.620', 'LastEditDate': '2012-12-25T21:15:03.620', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7546', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5164', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-12-22T20:33:36.160', 'Id': '7545'},63_102:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I  found the algorithm for finding the negative cycle in a graph after running <a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm" rel="nofollow">Bellman-Ford algorithm</a>.</p>\n\n<p>The algorithm is to perform another relax iteration over all the edges. Than if we find an edge to relax we stop and start to follow it parent vertex starting from $V$ that $u$ is its parent until we close a cycle.</p>\n\n<p>I\'m having little problem proving this. I want to prove now that no matter when I stop the algorithm - if $p[v] = u$ always $d[v]\\le d[u]+w(u,v)$ and to prove that a cycle in parent pointer is necessarily a negative cycle.</p>\n', 'ViewCount': '163', 'Title': 'Bellman-Ford algorthm and negative cycle proof', 'LastEditorUserId': '3094', 'LastActivityDate': '2012-12-24T02:51:57.977', 'LastEditDate': '2012-12-24T02:51:57.977', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5170', 'Tags': '<algorithms><graphs>', 'CreationDate': '2012-12-23T17:43:25.143', 'FavoriteCount': '1', 'Id': '7565'},63_103:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '213', 'Title': 'XOR-like behavior in flow networks', 'LastEditDate': '2013-03-03T11:44:38.840', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '2', 'Body': '<p><em>XOR is not the correct name, but I am looking for some kind of exclusive behavior.</em></p>\n\n<p>I am currently solving a set of different (assignment) problems by modeling flow networks and running a min-cost-max-flow algorithm. Flow networks are quite handy because a lot of problems can be reduced to them in an easy and understandable way. In my case these are matchings with some additional constraints. As these constraints are getting more complex I\'ve been wondering if there are some existing constructions to model specific behaviors.</p>\n\n<p>In this case I want to restrict the outgoing flow of a node to a single edge.</p>\n\n<p>Given a graph $G=(V, E)$, integral capacities $c(u,v)$ and costs $k(u,v)$. An arbitrary node is called $A$. It\'s direct neighbors are called $B_1, ..B_n$. Can we replace the edges $AB_1,...AB_n$ (red) with some construction so that <strong>only one edge can receive flow</strong>? Which means that if $AB_1$ gets some flow (e.g. $5/10$) no other (red) edge can receive flow.</p>\n\n<p><img src="http://i.stack.imgur.com/1Cli7.png" alt=""></p>\n\n<p>We could add intermediate nodes/edges and play with costs and capacities. The total capacity of our new construction has to stay the same and the cost of the different alternatives have to stay somehow proportional.</p>\n\n<p>So my questions are:</p>\n\n<ol>\n<li>Are there constructions like this in general? (Any keywords, links, papers)</li>\n<li>Can you suggest a solution to my specific problem?</li>\n</ol>\n', 'Tags': '<algorithms><graph-theory><graphs><network-flow><assignment-problem>', 'LastEditorUserId': '4298', 'LastActivityDate': '2013-10-29T15:14:57.683', 'CommentCount': '9', 'AcceptedAnswerId': '7623', 'CreationDate': '2012-12-26T22:37:50.973', 'Id': '7610'},63_104:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I saw in <a href="http://www.youtube.com/watch?v=7ayAEHS1-F8" rel="nofollow">this</a> video that computing clustering coefficient of central node  of a star graph using the following algorithm is $\\Theta(n^2)$ and for a clique it is $\\Theta(n^3)$. is that correct?</p>\n\n<pre><code>def clustering_coefficient(G,v):\n    neighbors = G[v].keys()\n    if len(neighbors) == 1: return 0.0\n    links = 0.0\n    for w in neighbors:\n        for u in neighbors:\n            if u in G[w]: links += 0.5\n    return 2.0*links/(len(neighbors)*(len(neighbors)-1))\n</code></pre>\n', 'ViewCount': '255', 'Title': 'Computing the clustering coefficient', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-28T17:39:00.513', 'LastEditDate': '2012-12-28T12:03:27.460', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7626', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5202', 'Tags': '<graphs><algorithm-analysis><runtime-analysis>', 'CreationDate': '2012-12-28T10:30:04.533', 'Id': '7624'},63_105:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>my assumption:<br/>\n- we have an undirected graph with only positive edges<br/>\n- the edges are sorted alphabetically: <br/>\n&nbsp;&nbsp;&nbsp;&nbsp;e.g A-B, A-C, B-D <br/>\n&nbsp;&nbsp;&nbsp;&nbsp;and e.g not C-A, D-B, A-B </p>\n\n<p>I do not understand, why we need the first loop (line 1) here.\nI executed the algorithm on paper on 3-4 different undirected graphs.\nAnd everytime the first iteration of line1 ends, the algorithms finishes to find the shortest path and the remaining iterations are doing just garbage check.</p>\n\n<p>Can anyone give a concrete graph example where we need the first loop?\nDoes the first loop to do something with the negative edges or edge direction perhaps ?</p>\n\n<pre><code>1 for i=1 to vertices.length-1\n2    foreach e in edges\n3        if e.v2.cost &gt; e.v1.cost + e.weight\n4            e.v2.cost := e.v1.cost + e.weight\n5            e.v2.pre := e.v1  \n</code></pre>\n', 'ViewCount': '169', 'Title': 'Bellman-Ford: shortest path', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-29T00:42:39.700', 'LastEditDate': '2012-12-29T00:42:39.700', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7631', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2012-12-28T15:48:15.470', 'Id': '7628'},63_106:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>my question is simple.\nIs it possible to use plants as a medium to store data?</p>\n\n<p>My opinion is: Possible, but we need to solve, how to distinguish 2 states. \nDuplication and CRC of stored DATA is quiet simple. Growing new plants is easiest possibility, but we need to create unit, which will take care about raid and duplicating informations between all plants.</p>\n\n<p>Could there be a different data-structure? What is a potential of storing data into plants? What about security? How would you write data into plants without losing that information?</p>\n\n<p>No, this is not a joke. Think about it. It grows everywhere, it is protected against water, cold, wet, dry, magnetic field, shaking and so on.</p>\n\n<p>Try to remember, you can use your own garden as a datastore for your music, films and data. Or just use public garden to share media, photographs, messages or opinions by connecting remotely to plants.</p>\n', 'ViewCount': '154', 'Title': 'Is it possible to use plants as a medium to store data? By what data structure?', 'LastActivityDate': '2013-01-11T13:57:43.113', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7639', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5227', 'Tags': '<data-structures><graphs>', 'CreationDate': '2012-12-29T01:30:59.710', 'Id': '7637'},63_107:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1495', 'Title': 'What is the fastest algorithm for finding all shortest paths in a sparse graph?', 'LastEditDate': '2013-05-24T03:12:57.407', 'AnswerCount': '4', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '5233', 'FavoriteCount': '2', 'Body': '<p>In an unweighted, undirected graph with $V$ vertices and $E$ edges such that $2V \\gt E$, what is the fastest way to find all shortest paths in a graph? Can it be done in faster than Floyd-Warshall which is $O(V^3)$ but very fast per iteration?</p>\n\n<p>How about if the graph is weighted?</p>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-05-01T00:54:19.510', 'CommentCount': '0', 'AcceptedAnswerId': '7646', 'CreationDate': '2012-12-29T17:41:54.350', 'Id': '7644'},63_108:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>INPUT: "an undirected, weighted graph (negative weights allowed)"</p>\n\n<p>Could someone give an example for an undirected graph with negative edges where Dijkstra\'s algorithm doesn\'t work?\nAs far as i understood it only fails by directed graphs in case of negative edges.<br/>\nAm i right ?</p>\n', 'ViewCount': '1876', 'Title': "Dijkstra's algorithm for undirected graphs with negative edges", 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-01T16:12:50.547', 'LastEditDate': '2012-12-30T15:13:01.697', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7657', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<graphs><shortest-path>', 'CreationDate': '2012-12-30T06:44:36.953', 'Id': '7649'},63_109:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Does anyone have a pointer to a resource or, even better, a tip to provide on how to efficiently generate a very large matrix representing a connected graph.</p>\n\n<p>Graph can be randomly created although I would ideally generate a graph of desired size and topology similar to what one can do with <a href="https://github.com/jgrapht/jgrapht" rel="nofollow">JGraphT</a>. </p>\n\n<p>My general intent is to create a very large graph representation (billions of nodes and edges) in parallel by first generating an adjacency matrix to ensure connectedness and then create a representation (RDF, etc) in parallel. </p>\n\n<p>Any further suggestions or alternative approaches are welcome.</p>\n', 'ViewCount': '321', 'Title': 'Generating a adjacency matrix representing a DAG', 'LastActivityDate': '2013-01-04T14:30:43.903', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7758', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2409', 'Tags': '<graphs><adjacency-matrix>', 'CreationDate': '2013-01-04T03:47:37.503', 'Id': '7746'},63_110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m currently studying the book "Introduction to Algorithms - Cormen". Although a proof of correctness for the BFS algorithm is given, there isn\'t one any for the DFS in the book. So I was courious about how it can be shown that DFS visits all the nodes.\nI also googled for it. But it seems that every lecturer do some copy-paste work from this book in their pdf\'s, so I couldn\'t find anything useful. <br/><br/>\nBy DFS we had to show that it found the shortest path. But since DFS does not calculate something like that I have no idea how to prove it.<br/></p>\n\n<hr>\n\n<p>Off the topic, why are those proofs so important? Throughout the book there are so many lemmas and theorems which can be really boring sometimes. I understand how an algorithm works in 10 minutes, perhaps need another 5 to 10 minutes to understand how to analyse the running time, but then I\'m loosing 1 hour just for some useless lemmas. Besides, and worse even, I studied almost 50 proofs/lemmas of different algorithms till now, I never managed to solve one of them by myself. How can I gain the "proving ability"? Is there a systematical way to learn that? I don\'t mean the Hoare logic way with invariants, rather the informal way described in the book "Introduction to Algorithms". Is there any book which focuses on "how to prove algorithms" and show that in a systematical, introductory way ?</p>\n', 'ViewCount': '800', 'Title': 'DFS - Proof of Correctness', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-05T11:11:50.160', 'LastEditDate': '2013-01-05T10:16:22.507', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graph-theory><graphs><correctness-proof>', 'CreationDate': '2013-01-04T05:53:53.593', 'Id': '7749'},63_111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am struggling in trying to figure out a non-deterministic algorithm for the following problem.</p>\n\n<p>Consider the following problem, called the \ufb01gure-of-eight problem (FOE). An instance is an undirected graph $G = (V,E)$ with vertices $V$ and edges $E$. $G$ is a yes-instance if there is a sequence of vertices $(v_{0},v_{1},...,v_{k+1})\\ (some\\ k \\geq 6)$ such that</p>\n\n<p>\u2022 Each pair $(v_{i},v_{i+1})$ is an edge $(each\\ i &lt; k \u2212 1)$ and $(v_{k\u22121},v_{0})$ is an edge. </p>\n\n<p>\u2022 Every vertex in $V$ occurs at least once in the sequence. </p>\n\n<p>\u2022 There is $j$ with $2 &lt; j &lt; k \u2212 2$ such that $v_{0} = v_{j}$. </p>\n\n<p>\u2022 No other vertex in the sequence is counted twice, i.e. if $v_{s} = v_{t} (any\\ s,t &lt; k)$ then either $s = t$ or ${s,t} = {0,j}$.</p>\n\n<p>If there is no such sequence of vertices then $G$ is a no-instance of FOE.</p>\n\n<p>Thanks</p>\n', 'ViewCount': '106', 'Title': 'Non-deterministic algorithm for solving figure of 8', 'LastActivityDate': '2013-01-04T14:17:12.447', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7757', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5300', 'Tags': '<algorithms><complexity-theory><graphs><nondeterminism>', 'CreationDate': '2013-01-04T13:03:33.720', 'Id': '7756'},63_112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have 2 questions regarding Bipartiteness with corresponding examples.</p>\n\n<p>1) Can a non-connected graph be bipartite if it has an isolated vertex? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/AzAxV.png" alt="enter image description here">\n<br/>\nI would say YES with this partition:\nV<sub>1</sub> = {A, D, G}\n; V<sub>2</sub> = {B, C, E, F, H}\n<br/>But what confuses me is that A is isolated.\n<br/>Is that a contradiction to the bipartitiness of G ?</p>\n\n<p>2) Is there a rule about the uniqueness of the partitions ? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/dbQww.png" alt="enter image description here">\n<br/>choice1:\nV<sub>1</sub>= {A, C}; V<sub>2</sub> = {B, D}\n<br/>choice2:\nV<sub>1</sub>= {A, D}; V<sub>2</sub> = {B, C}</p>\n\n<p>Does it matter which one i choose?</p>\n', 'ViewCount': '82', 'Title': 'Graph Bipartiteness', 'LastActivityDate': '2013-01-08T02:45:16.330', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7824', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2013-01-08T02:10:47.957', 'Id': '7823'},63_113:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Let\'s consider distributed version of algorithm for finding MIS of any graph $A$.</p>\n\n<p>For details, MIS - <a href="http://en.wikipedia.org/wiki/Maximal_independent_set" rel="nofollow">Maximimal Independent Set</a>.</p>\n\n<p>Slow version of distributed algorithm for MIS, page 2 -  <a href="http://disco.ethz.ch/lectures/podc_allstars/lecture/chapter7.pdf" rel="nofollow">Distributed algorithms. Maximal Independent Set</a></p>\n\n<p>In worst case, time complexity of the algorithm is $\\text{O}(n)$ and a message complexity is $\\text{O}(m)$. If nodes of the network are not unique than it\'s not possible to find MIS.</p>\n\n<p>I am interested in few special cases, when the graph is a <strong>path</strong> and <strong>ring</strong>.</p>\n\n<p><strong>Exercise</strong>: Consider a path graph $G$ with vertex UIDs to be a random permutation of $\\{1,\u2026,n\\}$, time complexity of MTS_Slow is $T \\leq c\\log n$ for a constant $c$ with probability $1-\\frac{1}{n}$.\nWhat is a time complexity and it\'s probability on a ring $G$ with vertex UIDs to be a random permutation of $\\{1,\u2026,n\\}$.</p>\n\n<p><strong>Ideas:</strong> Time complexity has $\\log n$ factor, therefore on each phase number of candidates for MIS nodes from a path graph $G$ should be divided by constant factor. Lets consider the worst case, when only one node is choicen to join MIS on each phase, it occurs when the nodes\' UID\'s are located in increasing or decreasing order, it happes with probability $P(B)=\\frac{1}{2^n}$, $P(A)=\\frac{1}{2}$, where B - nodes\' UID is placed in increasing order, A - the next node\'s UID is bigger the the current one. But how to show that the number of candidates is getting lower by any arbitrary constant factor. The problem is I have a difficulties in defining probability for taking arbitrary constant factor of nodes on each phase. </p>\n\n<p>Case with ring should be similar to a path graph case.</p>\n\n<p>I will appreciate any help in solving this exercise.</p>\n', 'ViewCount': '145', 'Title': 'Maximimal Independent Set on Ring and Path', 'LastActivityDate': '2013-01-15T01:57:56.640', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '8940', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<algorithms><graphs><distributed-systems>', 'CreationDate': '2013-01-08T13:45:19.680', 'Id': '7832'},63_114:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is it possible to use Warshall's algorithm (calculating the transitive closure) to determine if a directed graph is acyclic or not? </p>\n\n<p>I'm trying to achieve this but getting stuck on the reflexive property of the transitive closure!</p>\n", 'ViewCount': '248', 'Title': 'Using transitive closure to determine acyclic property on directed graph', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-17T13:39:46.343', 'LastEditDate': '2013-01-17T13:39:46.343', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Azz', 'PostTypeId': '1', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-01-16T22:06:41.957', 'Id': '8979'},63_115:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can someone tell me why almost in every book/website/paper authors use the following:</p>\n\n<pre><code>foreach vertex v in Adjacent(u)\n    relax(u,v)\n</code></pre>\n\n<p>when relaxing the edges, instead of:</p>\n\n<pre><code>foreach vertex v in Adjacent(u)\n    if (v is in Q)\n        relax(u,v)\n</code></pre>\n\n<p>This is extremely confusing for someone when learning the algorithm. Is there any reason why the people are omitting the IF ?</p>\n\n<p>Anyway I wrote a semi-Javascript (I changed it here to a readable syntax) implementation of Dijkstra and I wanted to be sure if it is correct because of this IF case. Here is my code excluding the initialising:</p>\n\n<pre><code>while (queue.length != 0)\n    min = queue.getMinAndRemoveItFromQ()\n    foreach v in min.adjacentVertices\n        // inspect edge from "min" to "v"\n        if ( queue.contains(v) AND min.priority + weight(min,v) &lt; v.priority )\n            v.priority = min.priority + weight(min,v)\n            v.pre = min\n</code></pre>\n\n<p>Is this implementation correct or am I missing something ?</p>\n', 'ViewCount': '204', 'Title': "Why not relax only edges in Q in Dijkstra's algorithm?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T13:23:47.117', 'LastEditDate': '2013-01-25T11:30:42.873', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '9121', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-01-23T22:07:29.570', 'Id': '9120'},63_116:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the CLRS book (<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">http://en.wikipedia.org/wiki/Introduction_to_Algorithms</a>) Chapter 26 (Maximum Flow) page 744 (third edition), there is the following equation -</p>\n\n<p>$$\n\\sum_{u \\in U}e(u) \\;=\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in U}f(v, u) \\;+\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in \\bar{U}}f(v, u) \\;-\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in U}f(u, v) \\;-\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in \\bar{U}}f(u, v)\n$$</p>\n\n<p>where $f(u, v)$ is the flow between vertices $u$ and $v$, $e(u)$ is the excess flow at a particular vertex, $U$ is the set of vertices which are reachable from the source, and $\\bar{U}$ is the set of remaining vertices.</p>\n\n<p>In the next line, the first and third terms disappear. I don\'t understand why that holds. I do realize that those are flow values from vertex $u$ to vertex $v$ where both of them are in the same set $U$, but I don\'t understand why they cancel out to zero.</p>\n', 'ViewCount': '102', 'Title': 'Push relabel algorithms in flow networks', 'LastEditorUserId': '2152', 'LastActivityDate': '2013-04-03T16:18:22.383', 'LastEditDate': '2013-04-03T16:18:22.383', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10993', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6558', 'Tags': '<algorithms><graph-theory><graphs><network-flow>', 'CreationDate': '2013-01-25T16:14:49.193', 'Id': '9153'},63_117:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is an algorithm to calculate the maximum "score" possible in a directed graph, with the constraint that edges with the same value can only be traversed once? For example, in the graph below, given that you can use each of <em>a</em>, <em>b</em>, and <em>c</em> once, the best path is to use <em>a</em> and <em>b</em> to get to 7, and <em>c</em> to get to 2, for a score of 9.</p>\n\n<p><img src="http://i.stack.imgur.com/YDBLh.png" alt="enter image description here"></p>\n\n<p><strong>Edit:</strong> This is another way to formulate the problem:<br>\n<strong>Given:</strong> A set $S$ of $(key:value)$ pairs, where the key itself is a non-empty set of variables, eg - $S = \\{(\\{a\\}:2), (\\{c\\}:2), (\\{a, b\\}:7), (\\{b\\}:3), (\\{c\\}:1)\\}$. Keys may not be unique, so the word \'key\' may be misleading.<br>\n<strong>Required:</strong> A subset $S\' \\subseteq S$ such that the total sum of values of each member of $S\'$ is maximized.<br>\n<strong>Constraint:</strong> Each variable present in any of the keys of $S$ (eg. $a, b$ etc.) belongs to the list (key) of exactly one member of $S\'$<br>\nFor example, $S\' = \\{(\\{c\\}:2), (\\{a, b\\}:7)\\}$ has a total value of 9, and each of $a, b, c$ occur in exactly one list.</p>\n', 'ViewCount': '88', 'Title': 'Maximal value of directed graph with constraints', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-26T18:55:29.827', 'LastEditDate': '2013-01-26T18:55:29.827', 'AnswerCount': '0', 'CommentCount': '12', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6563', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-01-25T23:22:30.377', 'Id': '9158'},63_118:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Do we need to use BFS or DFS algorithm to find the k shortest loopless paths in a graph between any two nodes? \nIf so where can it be useful?</p>\n', 'ViewCount': '148', 'Title': 'BFS in K shortest paths', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-28T13:31:19.390', 'LastEditDate': '2013-01-28T10:05:21.847', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '5328', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal>', 'CreationDate': '2013-01-27T16:54:04.673', 'FavoriteCount': '1', 'Id': '9208'},63_119:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose that we take an initial search problem and we add $c &gt; 0$ to the costs on all edges. Will <a href="http://en.wikipedia.org/wiki/Uniform-cost_search" rel="nofollow">uniform-cost search</a> return the same answer as in the initial search problem?</p>\n\n<p>Definitions: Uniform-cost search is also known as lowest cost first. Initial search problem can be any graph with a start and a goal state. You just apply the uniform cost search algorithm on the graph. </p>\n', 'ViewCount': '426', 'Title': 'Uniform-cost Search Problem', 'LastEditorUserId': '867', 'LastActivityDate': '2013-11-19T07:11:47.707', 'LastEditDate': '2013-01-29T03:40:50.913', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6601', 'Tags': '<graphs><search-algorithms><search-trees><search-problem>', 'CreationDate': '2013-01-29T02:33:45.660', 'Id': '9265'},63_120:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Problem:</strong> Consider a graph $G = (V, E)$ on $n$ vertices and $m &gt; n$ edges, $u$ and $v$ are two vertices of $G$.</p>\n  \n  <p>What is the asymptotic complexity to calculate the shortest path from $u$ to $v$ with Dijkstra\'s algorithm using <a href="http://en.wikipedia.org/wiki/Binary_heap" rel="nofollow">Binary Heap</a> ?</p>\n</blockquote>\n\n<p>To clarify, Dijkstra\'s algorithm is run from the source and allowed to terminate when it reaches the target. Knowing that the target is a neighbor of the source, what is the time complexity of the algorithm?</p>\n\n<p><strong>My idea:</strong></p>\n\n<p>Dijkstra\'s algorithm in this case makes $O(n)$ <strong>inserts</strong> ( $n$ if the graph is complete) and 1 <strong>extract min</strong> in the binary heap, before calculate the shortest path from $u$ to $v$.</p>\n\n<p>In a binary heap insert costs $O(\\log n)$ and extract min $O(\\log n)$ too.</p>\n\n<p>So the cost in my opinion is $O(n \\cdot \\log n + \\log n) = O(n \\log n)$</p>\n\n<p>But the answer is $\\Theta(n)$, so there is something wrong in my thinking.</p>\n\n<p>Where is my mistake?</p>\n', 'ViewCount': '793', 'Title': "What's the complexity of calculating the shortest path from $u$ to $v$ with Dijkstra's algorithm using binary heap?", 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-30T17:46:35.080', 'LastEditDate': '2013-01-30T17:41:32.873', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '9319', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<algorithms><graphs><algorithm-analysis><runtime-analysis><shortest-path>', 'CreationDate': '2013-01-30T16:17:56.463', 'Id': '9314'},63_121:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it true or false that for running a dfs on an undirected graph G with a simple cycle than this cycle will have exactly one back edge?</p>\n\n<p>Looks to me likes its true ,is it?</p>\n', 'ViewCount': '122', 'Title': 'Dfs algorithm and cycles question', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-04T12:13:14.260', 'LastEditDate': '2013-02-04T12:13:14.260', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Nusha', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><search-algorithms><graph-traversal>', 'CreationDate': '2013-02-03T11:26:50.813', 'Id': '9458'},63_122:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '269', 'Title': 'Are link-cut trees ever used in practice, for max flow computation or other applications?', 'LastEditDate': '2013-02-05T10:22:43.413', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '6701', 'FavoriteCount': '2', 'Body': '<p>Many max flow algorithms that I commonly see implemented, Dinic\'s algorithm, push relabel, and others, can have their asymptotic time cost improved through the use of <a href="http://en.wikipedia.org/wiki/Link/cut_tree">dynamic trees</a> (also known as link-cut trees).</p>\n\n<ul>\n<li>Push relabel runs in $O(V^2E)$ or $O(V^3)$ or $O(V^2\\sqrt{E})$ normally, but with dynamic trees $O(VE \\log(V^2/E))$</li>\n<li>Dinic\'s algorithm runs in $O(V^2E)$, but with dynamic trees $O(VE\\log(V))$</li>\n</ul>\n\n<p>However, practical implementations of max-flow algorithms in most libraries don\'t seem to make use of this data structure.  Are dynamic trees ever used in practice for max flow computation? Or do they carry too much overhead to be useful for real world problem sizes?</p>\n\n<p>Are there any other problem domains where link cut trees are used?</p>\n\n<p>This question is related to a question that I asked on cstheory: <a href="http://cstheory.stackexchange.com/questions/16347/are-any-of-the-state-of-the-art-maximum-flow-algorithms-practical">Are any of the state of the art Maximum Flow algorithms practical?</a></p>\n', 'Tags': '<reference-request><graphs><data-structures><network-flow>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-05T21:59:44.773', 'CommentCount': '2', 'AcceptedAnswerId': '9521', 'CreationDate': '2013-02-05T04:36:34.087', 'Id': '9501'},63_123:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>The Floyd-Warshall algorithm is defined as follows:</p>\n\n<pre><code>   for k from 1 to |V|\n      for i from 1 to |V|\n         for j from 1 to |V|\n            if dist[i][k] + dist[k][j] &lt; dist[i][j] then\n               dist[i][j] \u2190 dist[i][k] + dist[k][j]\n</code></pre>\n\n<p>Why doesn't it work if I simply use</p>\n\n<pre><code>for i from 1 to |V|\n  for j from 1 to |V|\n     for k from 1 to |V|\n        if dist[i][k] + dist[k][j] &lt; dist[i][j] then\n           dist[i][j] \u2190 dist[i][k] + dist[k][j]\n</code></pre>\n\n<p>In this case, the intermediate node k is iterated in the innermost loop. I expect it will make the same comparisons, but maybe different order. Why is the result different and incorrect?</p>\n", 'ViewCount': '265', 'Title': "Why doesn't the Floyd-Warshall algorithm work if I put k in the innermost loop", 'LastEditorUserId': '31', 'LastActivityDate': '2013-02-10T20:15:19.823', 'LastEditDate': '2013-02-10T15:11:05.887', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6805', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-02-10T12:07:12.883', 'Id': '9636'},63_124:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '641', 'Title': 'The purpose of grey node in graph depth-first search', 'LastEditDate': '2013-02-11T17:33:21.087', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6805', 'FavoriteCount': '1', 'Body': '<p>In many implementations of depth-first search that I saw (for example: <a href="http://ramos.elo.utfsm.cl/~lsb/elo320/aplicaciones/aplicaciones/CS460AlgorithmsandComplexity/lecture9/COMP460%20Algorithms%20and%20Complexity%20Lecture%209.htm" rel="nofollow">here</a>), the code distinguish between a grey vertex (discovered, but not all of its neighbours was visited) and a black vertex (discovered and all its neighbours was visited). What is the purpose of this distinction? It seems that DFS algorithm will never visit a visited vertex regardless of whether it\'s grey or black.</p>\n', 'Tags': '<algorithms><graphs><search-algorithms><graph-traversal>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-12T00:43:33.593', 'CommentCount': '0', 'AcceptedAnswerId': '9681', 'CreationDate': '2013-02-11T13:10:44.110', 'Id': '9676'},63_125:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '88', 'Title': 'Bipartite graph question', 'LastEditDate': '2013-02-11T22:39:58.533', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2003', 'FavoriteCount': '1', 'Body': "<p>Assume you are given a bipartite graph $G = (U, V, E)$ and you are given an integer $n$. Assume also that for each $v \\in V$, you are given two integers $v_{min}$ and $v_{max}$ (where $v_{min} \\le v_{max}$).</p>\n\n<p>The problem is to find a subset $U'$ of $U$ of size $n$ such that for each $v \\in V$, the number of edges coming into $v$ from $U'$ is between $v_{min}$ and $v_{max}$.</p>\n\n<p>Given a problem like this, can we determine efficiently whether there is a solution? And, if there is a solution, can we find one efficiently?</p>\n\n<p>If we can't do so efficiently, is there an approximation algorithm?</p>\n", 'Tags': '<algorithms><graphs><bipartite-matching>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-11T22:57:36.760', 'CommentCount': '2', 'AcceptedAnswerId': '9694', 'CreationDate': '2013-02-11T22:35:47.340', 'Id': '9693'},63_126:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1436', 'Title': "Is Dijkstra's algorithm just BFS with a priority queue?", 'LastEditDate': '2013-02-24T16:18:24.030', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Barry Fruitman', 'PostTypeId': '1', 'OwnerUserId': '7007', 'Body': '<p>According to <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=graphsDataStrucs3" rel="nofollow">this page</a>, Dijkstra\'s algorithm is just BFS with a priority queue. Is it really that simple? I think not.</p>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-24T16:18:24.030', 'CommentCount': '3', 'AcceptedAnswerId': '10048', 'CreationDate': '2013-02-24T07:46:57.263', 'Id': '10047'},63_127:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have this confusion. What is the local minimum of a complete binary tree?</p>\n\n<p>Consider an $n$-node complete binary tree $T$, where $n = 2^d \u2212 1$ for some $d$. Each node $v \\in V(T)$ is labeled with a real number $x_v$.  You may assume that the real numbers labeling the nodes are all distinct.  A node $v \\in V(T)$ is a local minimum if the label $x_v$ is less than the label $x_w$ for all nodes $w$ that are joined to $v$ by an edge.</p>\n', 'ViewCount': '377', 'Title': 'What is the local minimum of a complete binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-26T06:13:57.493', 'LastEditDate': '2013-02-25T07:15:14.690', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6999', 'Tags': '<terminology><graphs><binary-trees>', 'CreationDate': '2013-02-24T21:49:00.743', 'Id': '10071'},63_128:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose $\\sigma$ is a vocabulary of First Order logic consisting of one binary relation $E$ and let $\\phi$ be a $\\sigma$ sentence (FO formula with no free variables). Is it decidable whether there is a finite directed graph $G$, with all in- and out-degrees $0$ or $1$, such that $G\\models \\phi$ ?</p>\n', 'ViewCount': '114', 'Title': 'Decidability over finite graphs of small degree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-14T15:24:32.167', 'LastEditDate': '2013-03-14T15:24:32.167', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<graphs><logic><undecidability><first-order-logic><finite-model-theory>', 'CreationDate': '2013-03-13T10:55:07.910', 'Id': '10509'},63_129:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there a sequence of undirected graphs $\\{C_n\\}_{n\\in \\mathbb N}$, where each $C_n$ has exactly $n$ vertices and the problem </p>\n\n<blockquote>\n  <p>Given $n$ and a graph $G$, is $C_n$ an induced subgraph of $G$?</p>\n</blockquote>\n\n<p>is known to be in class $\\mathsf{P}$?</p>\n', 'ViewCount': '183', 'Title': 'Is induced subgraph isomorphism easy on an infinite subclass?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-05T10:06:27.850', 'LastEditDate': '2013-03-18T07:35:29.710', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '11032', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '667', 'Tags': '<complexity-theory><graphs>', 'CreationDate': '2013-03-17T12:13:37.153', 'Id': '10576'},63_130:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working on a type system and hit upon a problem that seems similar to lowest common ancestor. Given two types, I need to find the smallest sequence of conversions which will result in the same target type. If I had a simple type tree I know how to get the result, but unfortunately I have a slightly more complex graph structure.</p>\n\n<p>That graph has a few key points. It is unidirectional and no loops are ever formed. Due to an unlimited number of types however it cannot be produced statically. The distance of a path is generally quite low. It "feels" more like a tree with a bunch of shortcut edges.</p>\n\n<p>Initially I looked at lowest common ancestor, but it is mainly described as a tree algorithm. I\'ve not yet given up hope that I could adapt it. The other possibility would be a more generic path-finding algorithm.</p>\n\n<p>I\'m hoping somebody has seen this problem before, or a similar one, and can give me some references on how to further approach it. It seems familiar enough that I assume something must exist and I\'m just searching for the wrong terms/names.</p>\n\n<hr>\n\n<p>Here\'s my attempt to describe this more formally. </p>\n\n<p>Let there be a graph $G = \\{ V \\}$ such that each vertex has a set of outgoing edges $V = \\{ E=V_x \\}$. Note, as the graph is dynamic, possibly infinite, there is no way to construct the form $G = \\{V, E=(V_x,V_y)\\}$ for the entire graph.</p>\n\n<p>A path is formed from a vertex by following any of the available edges from that node. $Pnm_x = V_n, ..., V_m$. The length of this path is equal to the number of vertices in the sequence. There is no cycle possible. The set of all paths between two nodes is expressed as $Pnm = \\{ V_n, ..., V_m \\}$. </p>\n\n<p>Note that $Pnm$ can be determined to be empty in a finite number of steps. Enumerating the entire $Pnm$ set is not practically possible.</p>\n\n<p>The problem is finding the shortest path from two vertices to a third vertex. That is, given $V_a, V_b$, find $V_c$ such that paths $Pac_x$ and $Pbc_y$ exist and $length(Pac_x) + length(Pbc_y)$ is minimal.</p>\n', 'ViewCount': '624', 'Title': 'Lowest common ancestor similar algorithm for a graph', 'LastEditorUserId': '1642', 'LastActivityDate': '2013-03-19T04:11:32.030', 'LastEditDate': '2013-03-19T04:11:32.030', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1642', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-03-18T19:03:14.890', 'Id': '10603'},63_131:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Just a quick question,</p>\n\n<p>If i were to alter the general DFS algorithm to do this:</p>\n\n<pre><code>minDFS(Vertex v)\n{\n   if (!v.getVisted())\n   {\n       v.setVisited();\n       Vertex temp = findClosestVertex();\n       graph.addEdge(v, temp);\n       minDFS(temp);\n   }\n}\n</code></pre>\n\n<p>Would I eventually (at the end of DFS) get  minimum spanning tree? I know there are other ways of getting the MST (Kruskal's, Prim's etc..),but I was just wondering if this would work.</p>\n", 'ViewCount': '88', 'Title': 'DFS miniumum spanning tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T10:04:43.703', 'LastEditDate': '2013-03-25T10:04:43.703', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10721', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7381', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2013-03-23T19:28:16.987', 'Id': '10717'},63_132:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What does it mean when we say that a run of Prim's algorithm is <em>trivial</em>? What are example graphs for either case, that is with and without trivial runs?</p>\n", 'ViewCount': '134', 'Title': "Non-trivial runs of Prim's algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T02:02:34.337', 'LastEditDate': '2013-03-26T13:42:55.697', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '10809', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<algorithms><terminology><graphs>', 'CreationDate': '2013-03-26T11:52:10.267', 'Id': '10804'},63_133:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $B = G(L, R, E)$ be a bipartite graph. I want to find out whether this graph has a perfect matching. One way to test whether this graph has a perfect matching is Hall's Marriage Theorem, but it is inefficient (i.e $|\\mathcal P(L)| = 2^{|L|}$ tests -- not polynomial). I can always find out whether a perfect matching exists by computing a maximum cardinality matching and testing its perfectness, but this involves computing that perfect matching. </p>\n\n<p>Is there an <em>efficient</em> way of deciding whether a perfect bipartite matching exists without computing the matching it self? Ideally I would want an algorithm which is faster than algorithms like Hopcroft Karp or matrix based matching algorithms, which explicitly find out the matching (i.e so not computing the matching makes sense).</p>\n\n<p>Edit: The italic part.</p>\n", 'ViewCount': '380', 'Title': 'Existence of bipartite perfect matching', 'LastEditorUserId': '7312', 'LastActivityDate': '2013-03-29T13:21:34.500', 'LastEditDate': '2013-03-29T12:55:00.763', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10895', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7312', 'Tags': '<graphs><bipartite-matching>', 'CreationDate': '2013-03-29T12:12:45.210', 'Id': '10891'},63_134:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Counting all possible paths, or all possible paths with a given length, between a couple of nodes in a directed or undirected graph is a classical problem. Attention should be given to what <em>all</em> means, due to the possibles cycles.</p>\n\n<p>This question is slightly different, or at least I think.</p>\n\n<p><strong>INPUT:</strong>  Be <strong>G</strong> a directed graph. <strong>G</strong> can have cycles and also selfconnected nodes. Let <strong>A(G)</strong> be the adjacency matrix of <strong>G</strong> (with a 1 in <strong>G</strong><sub>i,j</sub> if there's a link going from i to j and a 0 otherwise). Define <strong>T</strong> and <strong>B</strong> two subset of nodes of <strong>G</strong>, possibly with void intersection.</p>\n\n<p><strong>OUTCOME:</strong> A list of all paths of length <em>at most</em> k going from one node in <strong>T</strong> to one node in <strong>B</strong>. Paths can contain multiple time the same edges, as long as they go from the source node to the target node in strictly less than k+1 steps.</p>\n\n<p><strong>QUESTION:</strong> I would like to know which algorithm perform best in this task. I'm trying to develop a possible answer based on the fact that the n-th power of the adjacency matrix, if computed symbolically (with a different variable for each entry instead of a 1), keep traks of all this paths (and it reduces to the counting of paths if computed numerically with 1 in the entries). But I really don't know if this is the fastest way of doing the task (probably not).</p>\n\n<p><strong>CAVEAT:</strong> I'm not asking for the counting problem, nor for the shortest paths, the length of a path is defined as the number of edges used (counting the repetition). I'm using R, but if you prefer think about it in any other language! I'm really sorry if the question was already posed and solved. Thank you for the kind help!</p>\n\n<p><strong>additional info:</strong> I tried a matrix power series approach (A^3 gives all the 3 long path, ...) and dfs / bfs. I think the latter two are far from optimality as they don' take into account that I'm working on sets of sources and targets, and hence do a lot of redundant work...</p>\n", 'ViewCount': '793', 'Title': 'All paths of less than a given length in a directed graph between couple of nodes', 'LastActivityDate': '2013-04-01T16:54:58.877', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10954', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7521', 'Tags': '<algorithms><graphs><search-algorithms><shortest-path>', 'CreationDate': '2013-03-31T21:50:11.637', 'FavoriteCount': '1', 'Id': '10949'},63_135:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I (will, at the end) have a connected, undirected graph with N nodes and 2N-3 edges. You can consider the graph as it is built onto an existing initial graph , which has 3 nodes and 3 edges, iteratively. Every node added onto the graph and has 2 connections with the existing nodes (not necessarily with the initial 3 only) in the graph. When all nodes are added to the graph (N-3 nodes added in total), the final graph is constructed.</p>\n\n<p>I\'m asked, what is the maximum number of nodes in this graph that can be visited exactly once (except for the initial node), i.e., what is the maximum number of nodes contained in the largest Hamiltonian path of the given graph. <em>(Okay, saying largest Hamiltonian path is not a valid phrase, but considering the question\'s nature, I need to find a max. number of nodes that are visited once and the trip ends at the initial node. I thought it can be considered as a sub-graph which is Hamiltonian, and consists max. number of nodes, thus largest possible Hamiltonian path).</em></p>\n\n<p>I tried to apply <a href="http://en.wikipedia.org/wiki/Ore%27s_theorem" rel="nofollow">Ore\'s Theorem</a> but even for a small example graph, the Ore\'s Theorem might not be sufficient to tell if the graph is Hamiltonian even though it strikes you directly that it is Hamiltonian.</p>\n\n<p>I thought I might use BFS since It\'s used to detect cycles in a graph: I needed to find the largest cycle which contained all the nodes in that cycle but given a large number of nodes, this approach might be slow and not desirable in my case since the timing will be crucial. For now this option is the last option if I can\'t come up with a solution.</p>\n\n<p>After some thinking, I thought whatever the number of nodes will be, the graph seems to be Hamiltonian due to node addition criteria. The problem is I can\'t be sure and I can\'t prove it. Does adding nodes in that fashion, i.e. adding new nodes with 2 edges which connect the added node to the existing nodes, alter the Hamiltonian property of the graph? If it doesn\'t alter the Hamiltonian property, how so? If it does alter, again, how so?\nThanks.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>I, again, realized that building the graph the way I described might alter the Hamiltonian property. Consider an input given as follows:</p>\n\n<pre><code>1 3\n2 3\n1 5\n1 3\n</code></pre>\n\n<p>these input says that 4th node is connected to node 1 and node 3, 5th to node 2 and node 3 . . .</p>\n\n<p>4th and 7th node are connected to the same nodes, thus lowering the maximum number of nodes that can be visited exactly once, by 1. If i detect these collisions (including an input such as 3 3) and lower the maximum number of nodes, starting from N, I believe I can get the right result.</p>\n\n<p>See, I do not choose the connections, they are given to me and I have to find the max. number of nodes.</p>\n\n<p>I think counting the same connections while building the graph and subtracting it from N will give the right result? Can you confirm this or is there a flaw with this?</p>\n', 'ViewCount': '132', 'Title': 'Is this graph a hamiltonian graph?', 'LastEditorUserId': '6998', 'LastActivityDate': '2013-04-07T14:12:52.047', 'LastEditDate': '2013-04-07T12:39:16.870', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6998', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-04-06T22:20:40.597', 'Id': '11081'},63_136:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm looking for an algorithm which would find a minimal spanning tree given certain constraints (CSP) about importance of some nodes, e.g. consider a graph with next distance matrix:\n$$\n\\left[ \\begin{array}{c}\n- &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F \\\\\nA &amp; 0 &amp; 120 &amp; 100 &amp; inf &amp; inf &amp; 30 \\\\\nB &amp; 120 &amp; 0 &amp; 70 &amp; inf &amp; 150 &amp; inf \\\\\nC &amp; 100 &amp; 70 &amp; 0 &amp; 60 &amp; 60 &amp; inf \\\\\nD &amp; inf &amp; inf &amp; 60 &amp; 0 &amp; inf &amp; 50 \\\\\nE &amp; inf &amp; 150 &amp; 60 &amp; inf &amp; 0 &amp; inf \\\\\nF &amp; 30 &amp; inf &amp; inf &amp; 50 &amp; inf &amp; 0 \\\\\n\\end{array} \\right]\n$$\nPrim's algorithm will result in something like this:\n$$\n\\left[ \\begin{array}{c}\n- &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F \\\\\nA &amp; 0 &amp; inf &amp; inf &amp; inf &amp; inf &amp; 30 \\\\\nB &amp; inf &amp; 0 &amp; 70 &amp; inf &amp; inf &amp; inf \\\\\nC &amp; inf &amp; 70 &amp; 0 &amp; 60 &amp; 60 &amp; inf \\\\\nD &amp; inf &amp; inf &amp; 60 &amp; 0 &amp; inf &amp; 50 \\\\\nE &amp; inf &amp; inf &amp; 60 &amp; inf &amp; 0 &amp; inf \\\\\nF &amp; 30 &amp; inf &amp; inf &amp; 50 &amp; inf &amp; 0 \\\\\n\\end{array} \\right]\n$$</p>\n\n<p>However, node A is now zoned and it will take at least 3 transitions from $A$ to get to $C$ and for my specific CSP I need at most 2 transitions. It is fairly easy to incorporate such CSP into Prim's algorithm. <strong>The question is: are there any generic algorithms which deal with finding a minimal spanning tree given a set of constraints ?</strong></p>\n", 'ViewCount': '62', 'Title': "Node-weighted CSP in Prim's algorithm?", 'LastEditorUserId': '6793', 'LastActivityDate': '2013-04-07T14:44:13.350', 'LastEditDate': '2013-04-07T14:44:13.350', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6793', 'Tags': '<algorithms><graphs><graph-traversal><constraint-programming>', 'CreationDate': '2013-04-07T13:37:16.603', 'Id': '11100'},63_137:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In a depth first tree, there are the edges define the tree (i.e the edges that were used in the traversal).</p>\n\n<p>There are some leftover edges connecting some of the other nodes. What is the difference between a cross edge and a forward edge?</p>\n\n<p>From wikipedia:</p>\n\n<blockquote>\n  <p>Based on this spanning tree, the edges of the original graph can be divided into three classes: forward edges, which point from a node of the tree to one of its descendants, back edges, which point from a node to one of its ancestors, and cross edges, which do neither. Sometimes tree edges, edges which belong to the spanning tree itself, are classified separately from forward edges. If the original graph is undirected then all of its edges are tree edges or back edges.</p>\n</blockquote>\n\n<p>Doesn't an edge that is not used in the traversal that points from one node to another establish a parent-child relationship? </p>\n", 'ViewCount': '1017', 'Title': 'Difference between cross edges and forward edges in a DFT', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:37:35.677', 'LastEditDate': '2013-04-08T14:37:35.677', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11125', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '863', 'Tags': '<algorithms><terminology><graphs><graph-traversal>', 'CreationDate': '2013-04-07T22:57:20.517', 'Id': '11116'},63_138:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '59', 'Title': 'Independent set where two vertices need to have distance >= c', 'LastEditDate': '2013-04-08T03:03:23.500', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4259', 'FavoriteCount': '1', 'Body': "<p>An independent set (IS) in a graph is a set $V' \\subseteq V(G)$ of pairwise non-adjacent vertices. </p>\n\n<p>I am interested in the generalization $c$-IS where two nodes in  $V' \\subseteq V(G)$ need to have distance at least $c$ to any other vertex in $V'$.</p>\n\n<p>Has this problem been studied before? </p>\n", 'Tags': '<algorithms><reference-request><graphs>', 'LastEditorUserId': '4259', 'LastActivityDate': '2013-04-08T03:23:27.007', 'CommentCount': '1', 'AcceptedAnswerId': '11131', 'CreationDate': '2013-04-08T02:56:45.800', 'Id': '11129'},63_139:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '216', 'Title': 'Average length of s-t (simple) paths in a directed graph', 'LastEditDate': '2013-04-08T19:10:43.587', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7644', 'FavoriteCount': '3', 'Body': '<p>Given the fact that $s$-$t$ path enumeration is a #P-complete problem, could there be efficient methods that compute (or at least approximate) the average length of $s$-$t$ path without enumerating them? <strike>What if paths are allowed to revisit vertices?</strike> </p>\n\n<p>Relevant results on special graphs could also be helpful.</p>\n', 'Tags': '<algorithms><complexity-theory><graphs><approximation><enumeration>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T04:41:12.817', 'CommentCount': '5', 'AcceptedAnswerId': '11184', 'CreationDate': '2013-04-08T18:28:42.923', 'Id': '11146'},63_140:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '731', 'Title': "Tarjan's Strongly Connected Component algorithm", 'LastEditDate': '2013-04-08T21:29:36.877', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'wrick', 'PostTypeId': '1', 'OwnerUserId': '7647', 'FavoriteCount': '0', 'Body': u'<p>I am trying to understand Tarjan\'s strongly connected component algorithm and I have a few questions (the line numbers I am referring to are from <a href="http://en.algoritmy.net/article/44220/Tarjans-algorithm" rel="nofollow">Algoritmy.net</a>):</p>\n\n<ol>\n<li><p>On line 33 why is <code>node.lowlink = min(node.lowlink, n.index)</code> \u2014 shouldn\'t it be same as line 31: <code>node.lowlink = min(node.lowlink, **n.lowlink**)</code>?</p></li>\n<li><p>Do we have to generate the components on line 40 in the while loop as we pop? Isn\'t it true that when the algorithm finishes, all the vertices grouped by <code>lowLink</code> should be the SCC?</p></li>\n<li><p>Is it ever true that after we recurse in line 30, <code>n</code> may not be in stack? If not and (1) is true we can simplify line 29-33 as follows:</p>\n\n<pre><code>if n.index == -1 \n   tarjanAlgorithm(n, scc, s, index)\nif stack.contains(n)\n   node.lowlink = min(node.lowlink, n.lowlink)\n</code></pre></li>\n<li><p>I went ahead and <a href="https://github.com/pathikrit/scalgos/blob/master/src/main/scala/scalgos/Graph.scala#L129" rel="nofollow">implemented</a> the algorithm in Scala. However, I dislike the code - it is very imperative/procedural with lots of mutating states and book-keeping indices. Is there a more "functional" version of the algorithm? I believe imperative versions of algorithms hide the core ideas behind the algorithm unlike the functional versions. I found <a href="http://clj-me.cgrand.net/2013/03/18/tarjans-strongly-connected-components-algorithm/" rel="nofollow">someone else encountering the same problem</a> with this particular algorithm but I have not been able to translate his Clojure code into idomatic Scala.</p></li>\n</ol>\n\n<p>Note: If anyone wants to experiment, I have a good setup that generates random graphs and <a href="https://github.com/pathikrit/scalgos/blob/master/src/test/scala/scalgos/GraphSpec.scala#L50" rel="nofollow">tests your SCC algorithm vs running Floyd-Warshall</a></p>\n\n<p>Here is the full pseudocode (\xa9 Algoritmy.net, <a href="http://en.algoritmy.net/article/39416/About" rel="nofollow">MIT licensed</a>).</p>\n\n<pre><code>index = 0\n\n/*\n* Runs Tarjan\'s algorithm\n* @param g graph, in which the SCC search will be performed\n* @return list of components\n*/\nList executeTarjan(Graph g)\nStack s = {}\nList scc = {} //list of strongly connected components\nfor Node node in g\nif (v.index is undefined)\ntarjanAlgorithm(node, scc, s)\n\nreturn scc\n\n/*\n* Tarjan\'s algorithm\n* @param node processed node\n* @param SCC list of strongly connected components\n* @param s stack\n*/\nprocedure tarjanAlgorithm(Node node, List scc, Stack s)\nv.index = index\nv.lowlink = index\nindex++\ns.push(node) //add to the stack\nfor each Node n in Adj(node) do //for all descendants\nif n.index == -1 //if the node was not discovered yet                  // &lt;--- line 29\ntarjanAlgorithm(n, scc, s, index) //search\nnode.lowlink = min(node.lowlink, n.lowlink) //modify parent\'s lowlink  // &lt;--- line 31\nelse if stack.contains(n) //if the component was not closed yet\nnode.lowlink = min(node.lowlink, n.index) //modify parents lowlink     // &lt;--- line 33\n\nif node.lowlink == node.index //if we are in the root of the component\nNode n = null\nList component //list of nodes contained in the component\ndo\nn = stack.pop() //pop a node from the stack\ncomponent.add(n) //and add it to the component                         // &lt;--- line 40\nwhile(n != v) //while we are not in the root\nscc.add(component) //add the compoennt to the SCC list\n</code></pre>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-04-09T08:20:07.607', 'CommentCount': '1', 'CreationDate': '2013-04-08T18:30:45.350', 'Id': '11148'},63_141:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A bridge (critical edge) in an undirected graph is an edge whose removal increases the number of connected components.</p>\n\n<p>I need to determine all critical edges in an undirected graph, in $O(V+E)$ time. From what I found out, I need to use a modified DF search, but all pseudo-code algorithms I found have <code>low[v]</code> and <code>d[v]</code> which I don't understand.</p>\n\n<p>Can someone please explain to me the $O(V+E)$ bridge determination algorithm?</p>\n", 'ViewCount': '257', 'Title': 'Bridge determination in undirected graphs', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-11T14:22:16.190', 'LastEditDate': '2013-04-11T14:22:16.190', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'user7681', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal>', 'CreationDate': '2013-04-11T13:18:37.097', 'Id': '11229'},63_142:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have been reading up on algorithm for finding the strongly connected components in a directed graph $G=(V,E)$. It considers two DFS search and the second step is transposing the original graph $G^T$. </p>\n\n<p>The algorithm is the following :</p>\n\n<ol>\n<li>Execute DFS on $G$ (starting at an arbitrary starting vertex), keeping track of the \ufb01nishing times of all vertices.</li>\n<li>Compute the transpose, </li>\n<li>Execute DFS on $G^T$, starting at the vertex with the latest \ufb01nishing time, forming a tree rooted at that vertex. Once a tree is completed, move on to the unvisited vertex with the next latest \ufb01nishing time and form another tree using DFS and repeat until all the vertices in $G^T$ are visited.</li>\n<li>Output the vertices in each tree formed by the second DFS as a separate strongly connected component.</li>\n</ol>\n\n<p>My question is :</p>\n\n<ol>\n<li>What is the intuition behind this middle step of computing a transpose?</li>\n</ol>\n', 'ViewCount': '460', 'Title': 'Correctness of Strongly Connected Components algorithm for a directed graph', 'LastEditorUserId': '2223', 'LastActivityDate': '2013-04-12T11:29:20.083', 'LastEditDate': '2013-04-11T15:32:00.840', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11257', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graphs><graph-traversal>', 'CreationDate': '2013-04-11T15:08:51.047', 'Id': '11232'},63_143:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '773', 'Title': 'How to find the minimum number of vertices whose removal make the graph disjoint', 'LastEditDate': '2013-04-14T10:36:16.130', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7711', 'FavoriteCount': '2', 'Body': '<p>Given a graph $G = (V,E)$.</p>\n\n<p>Is there any algorithm which finds the minimum number of vertices to be removed from $G$ so that every vertex in the graph becomes disjoint, <em>i.e.</em>, every vertex is disconnected from every other vertex?</p>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T10:36:16.130', 'CommentCount': '2', 'AcceptedAnswerId': '11283', 'CreationDate': '2013-04-13T11:32:28.130', 'Id': '11281'},63_144:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3059', 'Title': 'Finding shortest and longest paths between two vertices in a DAG', 'LastEditDate': '2013-04-14T16:59:17.863', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7715', 'FavoriteCount': '3', 'Body': '<p>Given an unweighted DAG (directed acyclic graph) $D = (V,A)$ and two vertices $s$ and $t$, is it possible to find the shortest and longest path from $s$ to $t$ in polynomial time?  Path lengths are measured by the number of edges.</p>\n\n<p>I am interested in finding the range of possible path lengths in polynomial time.</p>\n\n<p>Ps., this question is a duplicate of the StackOverflow question <a href="http://stackoverflow.com/questions/10712495/longest-path-in-a-dag">Longest path in a DAG</a>.</p>\n', 'Tags': '<algorithms><graphs><shortest-path><polynomial-time>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-15T00:36:10.273', 'CommentCount': '0', 'AcceptedAnswerId': '11296', 'CreationDate': '2013-04-14T00:02:56.393', 'Id': '11295'},63_145:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a positively weighted DAG (directed acyclic graph) $D = (V,E)$, can you create a new non-weighted DAG $D'$ by converting each edge with weight $w(e) = x$ into x non-weighted edges and vertices? I believe this would take $O(|E|+W)$ time where $|E|$ is the number of edges and $W$ is the total weight of all edges. My concern is whether I can include this weight variable and still consider this algorithm to be in polynomial time.</p>\n\n<p>(NOTE: This algorithm may apply to all positively weighted graphs, not just DAGs.)</p>\n", 'ViewCount': '37', 'Title': 'Can you convert a positively weighted DAG into a non-weighted DAG in polynomial time?', 'LastActivityDate': '2013-04-15T22:05:19.823', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11344', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7715', 'Tags': '<algorithms><graph-theory><graphs><algorithm-analysis><polynomial-time>', 'CreationDate': '2013-04-15T20:19:10.183', 'Id': '11343'},63_146:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given an undirected graph $G = (V,E)$, what is the clique number $\\omega(G)$ given $|E|$, <em>i.e.</em>, the size of the largest clique in a graph with $|E|$ edges.</p>\n\n<p>I think this is doable after realizing that the number of edges in a clique is equal to the <em><a href="http://en.wikipedia.org/wiki/Triangular_number" rel="nofollow">triangular number</a></em>:\n$$|E(K_k)| = \\frac{1}{2}k(k-1).$$</p>\n\n<p>I am looking for a closed formula.</p>\n', 'ViewCount': '219', 'Title': 'Size of maximum clique given a fixed amount of edges?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-17T14:16:52.153', 'LastEditDate': '2013-04-17T14:16:52.153', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7715', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-04-16T19:12:03.283', 'Id': '11360'},63_147:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>First of all, let me preface by saying that this question is not completly new but the original question hasn\'t been answered. More important, this is only basic question on understanding the proof itself.</p>\n\n<p>So after some search in the site I found the following question : <a href="http://cs.stackexchange.com/questions/7565/bellman-ford-algorthm-and-negative-cycle-proof">Bellman-Ford algorthm and negative cycle proof</a>.</p>\n\n<p>The guy is trying to understand how to prove <em>that a cycle in parent pointer is necessarily a negative cycle</em>.</p>\n\n<p>My question is very basic and isn\'t duplicate, I just couldn\'t find anything in the document on the related question which answers my question.</p>\n\n<p>What does it mean a cycle in the parent pointer? I mean I could a graph whereas the cycle in the parent pointer isn\'t a negative cycle... I don\'t understand why It must be a negative cycle.</p>\n\n<p>See an example of a graph I have in mind :</p>\n\n<p><img src="http://i.stack.imgur.com/DSlY3.jpg" alt="enter image description here"></p>\n\n<p>Now suppose the first node we start with is (a) and suppose the we travling the edges in the following order: ab,bc,cd.</p>\n\n<p>and here we goes, we have a cycle in the parent pointer, and as far as I understand that is (c) becuase it is the parent of (d) and yet the cycle isn\'t negative cycle.</p>\n', 'ViewCount': '154', 'Title': 'Bellman-Ford parent pointer (?) negative cycle', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T14:01:36.147', 'LastEditDate': '2013-04-21T14:16:44.637', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11482', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-04-20T14:15:41.437', 'Id': '11428'},63_148:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Prove that if G is an undirected connected graph, then each of its edges is either in the depth-first search tree or is a back edge.</p>\n\n<p>Now, from intuition and in class lectures by Steven Skiena, I know that the above holds true, since it dives all the way down, and then throw a rope back to a previous vertex. I also know that DFS is great in finding cycles.</p>\n\n<p>However, my problem here is that I don't know how to <em>prove</em> that the edge is either a tree edge or a back edge.</p>\n", 'ViewCount': '1467', 'Title': 'Why does DFS only yield tree and back edges on undirected, connected graphs?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-25T09:39:45.153', 'LastEditDate': '2013-04-21T14:32:57.923', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><graphs><algorithm-analysis><graph-traversal>', 'CreationDate': '2013-04-20T19:03:21.160', 'FavoriteCount': '1', 'Id': '11438'},63_149:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is NOT HW, this is from Skienas book, and I just couldn't solve it at all.</p>\n\n<p>Please give me a hand here, in understanding and solving it, thanks.</p>\n\n<p>Let G = (V, E) be a binary tree. The distance between two vertices in G is the length of the path connecting these two vertices, and the diameter of G is the maximal distance over all pairs of vertices. Give a linear-time algorithm to find the diameter of a given tree. (*)</p>\n\n<p>I figured I'd do a DFS, and increment on each node in terms of the depth of the tree</p>\n", 'ViewCount': '51', 'ClosedDate': '2013-04-21T23:06:21.807', 'Title': 'LInear time algorithm to find the diameter of a tree', 'LastEditorUserId': '139', 'LastActivityDate': '2013-04-21T23:43:53.940', 'LastEditDate': '2013-04-21T19:20:21.703', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><graph-theory><graphs><algorithm-analysis><search-problem>', 'CreationDate': '2013-04-21T17:47:36.077', 'Id': '11470'},63_150:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Basically, I am looking for a (well-defined) term for some "<em>borderline</em>" vertexes interconnecting other vertices <em>in</em> and <em>outside of</em> a given connected component.</p>\n\n<p>More specifically, given directed graph $G = (V_G, E_G)$ and (strongly) connected component $C = (V_C, E_C)$, how do people refer to such vertices $x$, where,</p>\n\n<ol>\n<li>$x \\in V_C$;</li>\n<li>$\\exists\\ v \\in V_G \\setminus V_C$ such that $(x, v) \\in E_G \\setminus E_C$;</li>\n</ol>\n\n<p>My friends have suggested names such as <em>gateway vertex</em> and <em>border vertex</em>. But I feel obliged to make sure we are not reinventing something well-known / well-defined.</p>\n\n<p>It would be helpful if someone can help identify an equivalent (or likewise) definition of this concept in the literature. Thanks a lot.</p>\n\n<p>EDIT:</p>\n\n<p>Please note that -- unlike the well-defined concept of <em>cut vertex</em> -- the concept of <em>borderline vertex</em> (or whatever it should be called) is with respect to a <em>specific</em> given <strong>component</strong>, <em>not</em> the entire graph.</p>\n', 'ViewCount': '67', 'Title': 'Terminology for vertices in graph connecting vertices "in" and "outside of" a given component', 'LastEditorUserId': '7644', 'LastActivityDate': '2013-04-22T14:51:24.510', 'LastEditDate': '2013-04-22T14:51:24.510', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7644', 'Tags': '<graph-theory><terminology><graphs>', 'CreationDate': '2013-04-22T11:09:18.577', 'Id': '11485'},63_151:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can you help me with this problem ?</p>\n\n<blockquote>\n  <p>Given an undirected graph $G$ and an integer $n$, prove that determining whether the graph has wheel on $n$ vertices $W_{n}$ (a wheel $W_{i}$ is such that $i$ nodes form a cycle and a $i+1$st node is connected to all other nodes, resulting in $2i$ edges) is NP-complete.</p>\n</blockquote>\n', 'ViewCount': '187', 'Title': 'Proving that finding wheel subgraphs is NP-complete', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T06:56:08.333', 'LastEditDate': '2013-04-24T06:50:24.760', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11508', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Tags': '<complexity-theory><graphs><np-complete>', 'CreationDate': '2013-04-23T01:42:26.310', 'Id': '11505'},63_152:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider this problem: </p>\n\n<blockquote>\n  <p>Given an undirected graph $G = (V, E)$, find $G' = (V', E')$ such that:</p>\n  \n  <ol>\n  <li>$G'$ is an induced subgraph of $G$</li>\n  <li>$G'$ has no 3-cliques</li>\n  <li>$|V'|$ is maximal</li>\n  </ol>\n</blockquote>\n\n<p>So the least number of vertices must be eliminated from $G$ so that 3-cliques are eliminated.</p>\n\n<p>An equivalent problem would be to find a 2-coloring for $G$ such that if $(v_1, v_2, v_3) \\in V$ and $((v_1, v_2), (v_2, v_3), (v_3, v_1)) \\in V$, </p>\n\n<ol>\n<li><p>$(v_1.color == v_2.color \\wedge v_2.color == v_3.color \\wedge v_3.color == v_1.color) = False$</p></li>\n<li><p>The (absolute) difference between the number of nodes with color 1 and the number of nodes with color 2 is maximal.</p></li>\n</ol>\n\n<p>Can anyone think of a polynomial-time algorithm to solve one of these problems?</p>\n", 'ViewCount': '155', 'Title': 'Finding the largest 3-clique-free induced subgraph', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T10:36:57.313', 'LastEditDate': '2013-04-24T06:13:48.183', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '11534', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3101', 'Tags': '<algorithms><graph-theory><graphs><optimization>', 'CreationDate': '2013-04-23T15:30:56.217', 'Id': '11518'},63_153:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a question, i was trying to reduce 3-SAT to a particular graph problem and i'm not quite sure about a thing i used in the reduction.\nIn fact the reduction build a bipartite graph, the edge $(x_1,c_1)$ exist if the variable $x_1$ is in the clause number 1, the costs on that edge are dependent on the truthfulness of the variable $x_1$, cost 1 if $x_1$ is true and 0 elsewhere. My question :is it permitted in a reduction or should i have the entire graph instance independent from values taken by the variables ?</p>\n\n<p>Thank you all!</p>\n", 'ViewCount': '110', 'Title': 'Reduction from 3-SAT to a graphe problem', 'LastEditorUserId': '7934', 'LastActivityDate': '2013-04-28T00:16:23.053', 'LastEditDate': '2013-04-28T00:16:23.053', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '11544', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7880', 'Tags': '<complexity-theory><graphs><np-complete><reductions><3-sat>', 'CreationDate': '2013-04-24T22:56:55.940', 'Id': '11541'},63_154:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>From graph isomorphism, we know that two graphs A and B are isomorphic if there is a permutation matrix P such that \n$A = P \\times B \\times P^{-1}$</p>\n\n<p>So, to solve the problem, if two graphs are isomorphic, we need to find such a permutation matrix P. The problem is believed to be NP (and NP complete for the case of subgraph isomorphism). However, I found an example to solve for P which seemed promising to me and can be found in \n<a href="http://en.wikipedia.org/wiki/Permutation_matrix" rel="nofollow">http://en.wikipedia.org/wiki/Permutation_matrix</a>\nin section: solving for P. </p>\n\n<p>The confusion I have now is, does that work for larger matrices? very large? am I right the above equation is hard to solve and can be candidate for a cryptographic system?</p>\n', 'ViewCount': '112', 'Title': 'How hard is it to solve for $P$ in $A = PBP^{-1}$?', 'LastEditorUserId': '755', 'LastActivityDate': '2013-04-26T23:40:13.320', 'LastEditDate': '2013-04-25T22:09:10.967', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'boFatom', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><cryptography><graph-isomorphism>', 'CreationDate': '2013-04-16T21:10:39.030', 'Id': '11553'},63_155:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What's the time complexity of the clique problem for input graphs where each connected component has size at most $3\\log|V|$? Is it in P?</p>\n", 'ViewCount': '69', 'Title': "Clique in P when the input graph's connected components have at most $3\\log|V|$ vertices?", 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-06T21:59:39.687', 'LastEditDate': '2013-05-06T21:59:39.687', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11839', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8072', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-05-06T19:08:54.887', 'Id': '11838'},63_156:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is it true that the heaviest edge in a directed graph can not be in the MST of that graph?</p>\n\n<p>I don't think it is true because we might end up with a heaviest edge that is <em>not</em> part of a cycle. </p>\n\n<p>Can anyone confirm?</p>\n", 'ViewCount': '129', 'Title': 'Can the heaviest edge ever be in an MST?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-09T14:56:54.367', 'LastEditDate': '2013-05-09T14:56:54.367', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11903', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Tags': '<graphs>', 'CreationDate': '2013-05-08T22:38:27.387', 'Id': '11902'},63_157:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assume there exists some algorithm that solves vertex cover problem in time polynomial in terms of $n$ and exponential for $k$ with the run time that looks like this $O(k^2 55^k n^3)$. Can we claim that independent set can also be solved in time polynomial in terms of $n$ and exponential in terms of $k$ ? ($k$ here stands for the minimum size of an independent set) </p>\n', 'ViewCount': '831', 'Title': 'Reduction from Vertex Cover to an Independent Set problem', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-05-10T12:12:20.603', 'LastEditDate': '2013-05-10T12:12:20.603', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11905', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Tags': '<graphs><np-complete><np><p-vs-np><parametrized-complexity>', 'CreationDate': '2013-05-08T23:39:30.063', 'Id': '11904'},63_158:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '153', 'Title': 'Wheel subgraph problem', 'LastEditDate': '2013-05-11T11:16:56.337', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7336', 'FavoriteCount': '0', 'Body': '<p>In the following two threads I specified the question in the wrong way (easier to solve that way). \n<a href="http://cs.stackexchange.com/questions/11505/proving-that-finding-wheel-subgraphs-is-np-complete">Proving that finding wheel subgraphs is NP-complete</a></p>\n\n<p><a href="http://cs.stackexchange.com/questions/11915/reducing-from-hamiltonian-cycle-problem-to-the-graph-wheel-problem">Reducing from Hamiltonian Cycle problem to the Graph Wheel problem</a></p>\n\n<p>My sincere apologies.. I hope moderators will let me post this final version of the question.</p>\n\n<p>In reality the question is different and much harder: is there a way to determine whether a graph $G$ with $n$ vertices has a subgraph that is a wheel $W_{k}$ ? Is possible to show that this is NP-Complete problem ? </p>\n\n<p>The follwig solution offered by Saeed Amiri seems to only work if the problem is to determine whether the entire graph is a wheel.</p>\n\n<blockquote>\n  <p>We will add one extra vertex $v$ to the graph $G$ and we make new\n  graph $G\'$, such that $v$ is connected to the all other vertices of\n  $G$, then $G$ has a Hamiltonian cycle if and only if $G\'$ has a\n  $W_{n+1}$, is easy to check that if $G$ has a Hamiltonian cycle then\n  $G\'$ has a $W_{n+1}$ wheel (just set $v$ as a center), on the other\n  hand, if $G\'$ has a $W_{n+1}$ then there are two possibility:</p>\n  \n  <ol>\n  <li>$v$ is the center of $W_{n+1} \\rightarrow G $ has a Hamiltonian cycle.</li>\n  <li>Another vertex $u$ is the center of $W_{n+1}$ in $G\'$, but both $deg(u) = deg(v) = n$ so we can change the labeling of this two\n  vertices (actually they are equivalence under isomorphic), now we have\n  again first possibility.</li>\n  </ol>\n  \n  <p>P.S: By $W_n$ I mean the wheel with $n$ vertex.</p>\n</blockquote>\n\n<p>It seems that Hamiltonian Cycle approach is wrong because with this approach we are forced to think of the cycles across entire set of vertices. Since the problem is asking do determine presence of subset graph $W_{k}$ the strategy needs to be different. </p>\n', 'ClosedDate': '2013-05-12T08:34:30.470', 'Tags': '<graphs><np-complete><np>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-05-12T07:22:38.820', 'CommentCount': '2', 'AcceptedAnswerId': '11958', 'CreationDate': '2013-05-10T19:57:40.330', 'Id': '11942'},63_159:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We are given a graph $G=(V,E)$ with positive edge weights $w_{i}$ and numerical {0,1,-1} labels $l$ for all vertices . We know that $G$ has a subset $G'$ with all vertices labeled 0. The problem is to assign labels to the vertices in $G'$ in such way that this sum is maximized $\\sum_{e_{u,v}\\in E} w_{i}l_ul_v.$ The question is whether this problem is NP-complete or not. If it is not then what is the polynomial algorithm?</p>\n\n<p>Personally I believe that this problem is essentially a form of 3-Coloring. The challenge is to chose the labels {1,-1} depending on the neighbors. Say the boundary between $G$ and $G'$ has a lot of 1s  then it is better to chose 1s for the labeling of vertices in $G'$, similarly if the boundary has lots of -1s then it is better to chose -1s for labeling because $-1*-1=1$. So essentially this becomes some sort of reverse 3-Coloring problem where the neighbors have to have matched color.</p>\n\n<p>Can you help reduce this problem to 3-Coloring (or vice-versa) ? Or perhaps there is polynomial time algorithm ?</p>\n", 'ViewCount': '97', 'Title': 'Strategic vertex labeling', 'LastEditorUserId': '7336', 'LastActivityDate': '2013-05-13T02:04:44.517', 'LastEditDate': '2013-05-13T01:43:16.263', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '11978', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Tags': '<graphs><np-complete><np><colorings>', 'CreationDate': '2013-05-11T05:33:52.827', 'Id': '11946'},63_160:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I saw a proof by Saeed Amiri,\nWe will add one extra vertex v to the graph G and we make new graph G\u2032, such that v is connected to the all other vertices of G. G has a Hamiltonian cycle if and only if G\u2032 has a Wn+1. It is easy to check that if G has a Hamiltonian cycle then G\u2032 has a Wn+1 wheel (just set v as a center). On the other hand, if G\u2032 has a Wn+1 then there are two possibility:</p>\n\n<p>v is the center of Wn+1\u2192G has a Hamiltonian cycle.\nAnother vertex u is the center of Wn+1 in G\u2032. So both deg(u)=deg(v)=n. Then we can change the labeling of this two vertices (actually they are equivalence under isomorphic), now we have again first possibility.\nP.S1: By Wn I mean the wheel with n vertex.</p>\n\n<p>P.S2: In this proof we say if we fix k=n+1 (size of the artificial graph), then the problem is NP-Complete in this restricted version, So it's also NP-Complete in the case k is as input parameter.</p>\n\n<p>The proof is valid one way. If a graph has a hamiltonian cycle adding a node to the graph converts it a wheel. If the graph of k+1 nodes has a wheel with k nodes on ring. It has a hamiltonian cycle. BUT IF THE GRAPH OF N nodes has a wheel of size k. Then identifying which k nodes cannot be done in polynomial time. Thus the reduction cannot be done in polynomial time.</p>\n", 'ViewCount': '106', 'ClosedDate': '2013-05-18T03:40:01.500', 'Title': 'Reducing from Hamiltonian Cycle problem to the Graph Wheel problem cannot be proved vice versa', 'LastActivityDate': '2013-05-15T07:51:32.010', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12034', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8160', 'Tags': '<algorithms><graphs><np-complete><polynomial-time>', 'CreationDate': '2013-05-14T08:13:46.597', 'Id': '12009'},63_161:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the Hopcroft-Karp algorithm for bipartite matching, I don't understand the purpose of the breadth first search.  I think it's used to find a set of vertex disjoint augmenting paths, but I'm not sure what the significance of that is or even what that means.  Why do the augmenting paths have to be the shortest?  And why do they have to be vertex disjoint?</p>\n", 'ViewCount': '169', 'Title': 'In the Hopcroft-Karp algorithm, what is the purpose of the breadth first search?', 'LastActivityDate': '2013-08-17T13:24:49.037', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2013-05-15T02:46:31.397', 'Id': '12030'},63_162:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a directed graph with the following attributes: - a chain from node $a$ to node $z$ passing nodes $b$ to $y$ exists and is unidirectional. - additionally a set of nodes having bidirectional vertices to at least two of the nodes $a \\ldots z$ exists. These nodes are connected in a second unidirectional chain.</p>\n\n<p><img src="http://i.stack.imgur.com/W1NjY.png" alt="enter image description here"></p>\n\n<p>(the red route is the requested result, the squares are the first chain (unidirectional) and the circles are the second chain (unidirectional). $1$ is the start node and $5$ is the destination node.)</p>\n\n<p>Is it possible to find the shortest path from $a$ to $z$ that includes nodes $b$ to $y$ and the additional nodes once without probing all possibilities?</p>\n\n<p>I think the problem is roughly the same as the minimal traveling salesman problem since adding a vertex from $z$ to $a$ will result in the min-TSP - but this problem is slightly easier since a path from $a$ to $z$ is already known.</p>\n', 'ViewCount': '145', 'Title': u'Is \u201cFind the shortest tour from a to z passing each node once in a directed graph\u201d NP-complete?', 'LastEditorUserId': '8188', 'LastActivityDate': '2013-05-16T07:26:57.557', 'LastEditDate': '2013-05-16T06:17:36.050', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12061', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8188', 'Tags': '<algorithms><graph-theory><graphs><np-complete>', 'CreationDate': '2013-05-15T11:03:35.493', 'Id': '12036'},63_163:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1087', 'Title': 'Graph Has Two / Three Different Minimal Spanning Trees?', 'LastEditDate': '2013-05-15T20:00:02.037', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8202', 'FavoriteCount': '0', 'Body': "<p>I'm trying to find an efficient method of detecting whether a given graph G has two different minimal spanning trees. I'm also trying to find a method to check whether it has 3 different minimal spanning trees. The naive solution that I've though about is running Kruskal's algorithm once and finding the total weight of the minimal spanning tree. Later , removing an edge from the graph and running Kruskal's algorithm again and checking if the weight of the new tree is the weight of the original minimal spanning tree , and so for each edge in the graph. The runtime is O(|V||E|log|V|) which is not good at all, and I think there's a better way to do it.</p>\n\n<p>Any suggestion would be helpful, thanks in advance</p>\n", 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-17T21:55:27.857', 'CommentCount': '5', 'AcceptedAnswerId': '12058', 'CreationDate': '2013-05-15T18:45:13.007', 'Id': '12048'},63_164:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $G = (V,E)$ be a directed graph  with a weight function $w$ such that there are no negative-weight cycles, and let $v \\in V$ be a vertex such that there is a path from $v$ to every other vertex. Let $f : V \\to \\mathbb R$ be a given function. Describe an algorithm that runs in $O(|V| + |E|)$ time that answers yes/no to the question: is it true that for all $u \\in V, f(u) = \\delta(v,u)$, where $\\delta(v,u)$ is the weight of the shortest path from $v$ to $u$?</p>\n\n<p>Obviously what comes to mind is Bellman-Ford algorithm, but it doesn't satisfy the time requirement. I don't really see how having the candidate $f$ function helps us in this regard.</p>\n", 'ViewCount': '194', 'Title': 'Shortest paths candidate', 'LastActivityDate': '2013-06-05T15:32:06.230', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12126', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8247', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-05-18T19:19:11.787', 'Id': '12120'},63_165:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1483', 'Title': 'Finding the path of a negative weight cycle using Bellman-Ford', 'CommunityOwnedDate': '2013-05-21T19:50:47.733', 'LastEditDate': '2013-05-22T15:08:01.357', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8248', 'Body': '<p>I wrote a program which implements Bellman-Ford, and identifies when negative weight cycles are present in a graph. However what I\'m actually interested in, is given some starting vertex and a graph, which path do I actually trace to get to the original vertex having traveled a negative amount. </p>\n\n<p>So to be clear say I have a graph with vertexes, a, b, c, and d and there is a negative cycle between a, b, and d, then when I check for negative weight cycles </p>\n\n<pre><code>// Step 1: initialize graph\n   for each vertex v in vertices:\n       if v is source then distance[v] := 0\n       else distance[v] := infinity\n       predecessor[v] := null\n\n   // Step 2: relax edges repeatedly\n   for i from 1 to size(vertices)-1:\n       for each edge (u, v) with weight w in edges:\n           if distance[u] + w &lt; distance[v]:\n               distance[v] := distance[u] + w\n               predecessor[v] := u\n\n   // Step 3: check for negative-weight cycles\n   for each edge (u, v) with weight w in edges:\n       if distance[u] + w &lt; distance[v]:\n           "Graph contains a negative-weight cycle"\n</code></pre>\n\n<p>Instead of it just telling me that a negative cycle is there, I would like it to tell me, go from <code>a -&gt; b -&gt; d -&gt; a</code>.  After the relaxing step what do I have to change in my check for negative weight cycles to get it to output this information? </p>\n\n<ul>\n<li><p><a href="http://blog.alirabiee.com/?p=576" rel="nofollow">Here</a> is the best information I\'ve been able to find, but I\'m still having trouble making sense of it.  </p></li>\n<li><p>Also <a href="http://www.cs.ucdavis.edu/~amenta/f05/hw5.pdf" rel="nofollow">this</a> which suggests that I need to run breadth first search on the predecessor array to find the information, but I\'m not exactly sure where to start (what do I queue first?) </p></li>\n<li><p><a href="http://stackoverflow.com/questions/2282427/interesting-problem-currency-arbitrage">Here</a> is a stack overflow question which shows how to find one of the nodes in the path.</p></li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '8248', 'LastActivityDate': '2013-05-22T15:08:01.357', 'CommentCount': '3', 'AcceptedAnswerId': '12206', 'CreationDate': '2013-05-19T04:41:17.347', 'Id': '12129'},63_166:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was wondering. May the source and sink have in-out going edges in a flow-network, and if so - does Ford-Fulkerson and the max-flow min-cut theorem apply ?</p>\n\n<p>Flow-networks are always pictures with no edges entering source, and no edges leaving sink.</p>\n\n<p>I've tried to search the web for an answer, but did not come across an answer i fully understand. Also, I've yet to see a flow network pictured with these edges from source/sink.</p>\n\n<p>Could I transform an undirected graph into a flow-network ? This network will have edges going into source and edges leaving sink ?? This hypothesis is the reason for my question.</p>\n", 'ViewCount': '206', 'Title': 'In flow networks, may source/sink have incoming/outgoing edges?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T18:57:23.833', 'LastEditDate': '2013-05-19T15:03:37.647', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8254', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2013-05-19T14:20:17.700', 'Id': '12134'},63_167:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let G be a directed graph with non-negative weights. We call a path between two vertices an "odd path" if its weight is odd.</p>\n\n<p>We are looking for an algorithm for finding the weight of the shortest odd path between any two vertices in the graph.</p>\n\n<p>If possible, describe one algorithm that is reduction-based (that is, make some modification to the graph so that application of Floyd-Warshall, or any other "known" algorithm, and then deciphering the answer will give the result, see <a href="http://en.wikipedia.org/wiki/Reduction_(complexity)" rel="nofollow">http://en.wikipedia.org/wiki/Reduction_(complexity)</a>) and one that is "direct" (that is, make some modification to Floyd-Warshall in order for it to solve this problem).</p>\n', 'ViewCount': '301', 'Title': 'Shortest path with odd weight', 'LastActivityDate': '2013-05-22T07:57:41.470', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '12155', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8247', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-05-20T11:52:45.343', 'Id': '12154'},63_168:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a weighted digraph, I can check whether a given vertex belongs to a negative cycle in $O(|V|\\cdot|E|)$ using Bellman-Ford. But what if I need to find all vertices on negative cycles? Is there a way to do it faster than Floyd-Warshall's $O(|V|^3)$?</p>\n", 'ViewCount': '102', 'Title': 'Finding all vertices on negative cycles', 'LastActivityDate': '2013-12-12T18:42:02.590', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18933', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8329', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-05-24T03:25:43.543', 'Id': '12243'},63_169:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '185', 'Title': 'Team construction in tri-partite graph', 'LastEditDate': '2013-06-05T04:54:04.320', 'AnswerCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1342', 'FavoriteCount': '1', 'Body': '<p>The government wants to create a team with one <em>alchemist</em>, one <em>builder</em>, and one <em>computer-scientist</em>. </p>\n\n<p>In order to have good cooperation, it is important that the 3 team-members like each other. </p>\n\n<p>Therefore, the government gathers $k$ candidates of each profession, and creates their "liking" graph. This is a tri-partite graph, where there is an edge between $a$ and $b$ iff $a$ likes $b$.</p>\n\n<p>(Note that the "like" relation is symmetric but not transitive, i.e.: if $a$ likes $b$ then $b$ likes $a$, but if $a$ likes $b$ and $b$ likes $c$, then not necessarily $a$ likes $c$).</p>\n\n<p>Is this always possible to create a team? Of course not. For example, it is possible that no alchemist likes any builder.</p>\n\n<p>However, suppose the "liking" graph has the following property: <em>in each group of 3 alchemists and 3 builders, there is at least a single alchemist-builder pair that like each other; ditto for alchemists-computerists and builders-computerists</em>.</p>\n\n<p>Given this property, is this always possible to create a team where all 3 members like each other? If so, what is the minimum number of candidates of each type ($k$) that the government will have to gather?</p>\n\n<p>I would like to both find k and prove that it is the minimum.</p>\n\n<p>A possibly related sub-question is: in a group of $k$ alchemists and $k$ builders, what is the minimum number of pairs that like each other? For $k=3$, by the assumption of the question, that number is 1. What about $k&gt;3$?</p>\n\n<p>A third question is: what is the name of this kind of problems?</p>\n', 'Tags': '<graph-theory><graphs><combinatorics>', 'LastEditorUserId': '1342', 'LastActivityDate': '2013-06-27T12:54:50.907', 'CommentCount': '8', 'AcceptedAnswerId': '12926', 'CreationDate': '2013-05-25T19:02:19.567', 'Id': '12275'},63_170:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a network $G=(V,E)$ , a max flow f and an edge $e \\in E$ , I need to find an efficient algorithm in order to detect whether there is some min cut which contains $e$.\nAnother question is, how do I decide whether if $e$ is the lightest edge of at least one minimal cut?</p>\n\n<p>I've thought about running Ford-Fulkerson algorithm, and then increasing / decreasing the capacity of the given edge and see what happens, but I haven't came up with something that might help me solve the problem.</p>\n\n<p>I'd be grateful if anyone could point me to the solution, thanks in advance.</p>\n", 'ViewCount': '178', 'Title': 'Max-Flow: Detect if a given edge is found in some Min-Cut', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-08T15:56:02.467', 'LastEditDate': '2013-06-07T20:49:03.987', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8202', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-06-07T13:10:00.247', 'Id': '12507'},63_171:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Apparently, if we use Djikstra's algorithm to find the shortest path between the root node and all other nodes in a weighted graph with no negative cycles, we are done after updating the distance of each node $|V| - 1$ times.</p>\n\n<p>This puzzles me because I think that a single round of breadth first search is enough. Why must we do $|V| - 1$ of these searches?</p>\n", 'ViewCount': '59', 'Title': "For Djikstra's algorithm, why are we surely done if we update all edges $|V|-1$ times?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:44:37.167', 'LastEditDate': '2013-06-10T09:44:37.167', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12572', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<algorithms><graphs><shortest-path><correctness-proof>', 'CreationDate': '2013-06-09T09:20:18.353', 'Id': '12558'},63_172:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have n commodities with each a unique source and sink node. Each source-sink pair is connected in some manner on a directed acyclic graph. All arc weights are non-negative. The goal is to find the shortest paths to transport the commodities between their respective source-sink pairs.</p>\n\n<p>Is there any algorithm that can solve this kind of problem rapidly, possibly using topological sorting first? How is this affected if there is unlimited/limited capacity on the arcs?</p>\n\n<p>Many thanks!</p>\n', 'ViewCount': '52', 'Title': 'Multicommodity shortest path problem on a directed acyclic graph', 'LastActivityDate': '2013-06-11T10:46:16.073', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8620', 'Tags': '<shortest-path><weighted-graphs>', 'CreationDate': '2013-06-11T10:46:16.073', 'Id': '12616'},63_173:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need your help with an exercise on <a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" rel="nofollow">Ford-Fulkerson</a>.</p>\n\n<blockquote>\n  <p>Suppose you are given a flow network with capacities $(G,s,t)$ and you are also given the max flow $|f|$ in advance.</p>\n  \n  <p>Now suppose you are given an arc $e$ in $G$ and suppose this arc\'s capacity is increased by one.</p>\n  \n  <p>Give an efficent algorithm which returns true iff the increase of the capacity of the arc $e$ will allow an increase in the max flow.</p>\n</blockquote>\n\n<p>I suppose we shouldn\'t run Ford-Fulkerson again but somehow use the given $|f|$\u2026 Any ideas how?</p>\n', 'ViewCount': '237', 'LastEditorDisplayName': 'user742', 'Title': 'Effect of increasing the capacity of an edge in a flow network with known max flow', 'LastActivityDate': '2013-06-17T23:03:08.163', 'LastEditDate': '2013-06-17T23:03:08.163', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'SyndicatorBBB', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<algorithms><graph-theory><network-flow><weighted-graphs>', 'CreationDate': '2013-06-16T16:41:05.080', 'Id': '12703'},63_174:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Find the number of topological sorts in a tree that has nodes that hold the size of their sub-tree including itself.</p>\n\n<p>I've tried thinking what would be the best for m to define it but couldn't get anything specific. </p>\n\n<p>Maybe $\\mbox{Number of sorts =}\\prod\\limits_{x\\in \\mbox{children}}\\mbox{Number of sorts}(x)$\nMeaning that starting at the root I call the the method recursively multilying each result by the previous children's result. When we reach a node with size 1 we assume that there's just 1 topological sort;</p>\n\n<p>If this is correct I'd really appreciate some help with proving correctness and if not a explanation why and a clue could be nice :)</p>\n", 'ViewCount': '50', 'Title': 'Find the number of topological sorts in a tree', 'LastEditorUserId': '8709', 'LastActivityDate': '2013-06-17T16:06:57.213', 'LastEditDate': '2013-06-17T15:42:53.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12716', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8709', 'Tags': '<graph-theory><graphs><algorithm-analysis><trees>', 'CreationDate': '2013-06-17T15:29:23.190', 'Id': '12713'},63_175:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve been working on this graph and just completely botching it. I mean to say that my solution may be the worst possible other than if a monkey had thrown darts at the graph to decide the next path.  Anyhow, I\'m lost and really trying to get a grasp of where my conclusion and the proper conclusion diverged dramatically.</p>\n\n<p>I wanted to perform a DFS, show discovery/finish times, the DF forest, and edge classifications. I assumed that: 1) The vertices are listed in alphabetical order in each adjacency list. 2) The vertices are taken in the alphabetical order in the main loop of the DFS algorithm.</p>\n\n<p><img src="http://i.stack.imgur.com/fgGDu.jpg" alt=""></p>\n\n<p>Should I be treating this as a directed acyclic graph?</p>\n', 'ViewCount': '103', 'Title': 'How to perform alphabetically ordered DFS?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-18T00:02:57.537', 'LastEditDate': '2013-06-17T21:22:38.820', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12729', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<graph-theory><graphs><search-algorithms>', 'CreationDate': '2013-06-17T20:47:29.400', 'Id': '12728'},63_176:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having some issues proving a problem I am working on. I have been sketching out examples but the proof is not jumping out at me.</p>\n\n<p>Question:\nLet $G = (V,E)$ be an undirected $r$-regular graph (that is each vertex has a degree of $r$) for some $0 &lt; r &lt; n$, where $|V| = n &gt; 1$. Prove that either $G$ or its complement $G^*$ has a hamiltonian path. </p>\n\n<p>Now the reason it's asking for $G$ or $G^*$ is because if it's not a connected undirected graph then taking the complement will make it connected.</p>\n\n<p>So lets assume that it's a connected $r$-regular graph. We start at a vertex $v$. From this vertex we can visit up to $r$ adjacent vertices. So we visit one of them, say $u$, and from there we have $r-1$ vertices to choose from because we do not want to go back to vertex $v$.</p>\n\n<p>Now I am trying to formulate a proof by going from vertex to vertex until all vertices are visited exactly once (hamiltonian path). But I do not see how to formulate the proof. Somehow each new vertex I visit will always have an uninformed neighbour until I reach the final vertex on the path.</p>\n\n<p>Am I on the right track?</p>\n", 'ViewCount': '136', 'Title': 'r-regular graph and hamiltonian path', 'LastActivityDate': '2013-06-26T20:19:10.370', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12918', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><proof-techniques>', 'CreationDate': '2013-06-26T18:24:24.753', 'Id': '12916'},63_177:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '236', 'Title': 'What is a good algorithm for generating random DFAs?', 'LastEditDate': '2013-06-29T08:40:23.377', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I am generating random DFAs to test a DFA reduction algorithm on them.</p>\n\n<p>The algorithm that I'm using right now is as follows: for each state $q$, for each symbol in the alphabet $c$, add $\\delta (q, c)$ to some random state.  Each state has the same probability of becoming a final state.</p>\n\n<p>Is this a good method of generating unbiased DFAs?  Also, this algorithm doesn't generate a trim DFA (a DFA with no obsolete states) so I'm wondering if there is a better way of generating random DFAs that can somehow ensure that it is trim?</p>\n", 'Tags': '<algorithms><finite-automata><random><pseudo-random-generators><random-graphs>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-18T10:13:05.943', 'CommentCount': '9', 'AcceptedAnswerId': '12949', 'CreationDate': '2013-06-28T05:14:15.410', 'Id': '12943'},63_178:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A <em>binary sequence</em> of length $n$ is just an ordered sequence $x_1,\\ldots,x_n$ so that each $x_j$ is either $0$ or $1$. In order to generate all such binary sequences, one can use the obvious binary tree structure in the following way: the root is "empty", but each left child corresponds to the addition of $0$ to the existing string and each right child to a $1$. Now, each binary sequence is simply a path of length $n+1$ starting at the root and terminating at a leaf. </p>\n\n<p>Here\'s my question:</p>\n\n<blockquote>\n  <p>Can we do better if we only want to generate all binary strings of length $2n$ which have precisely $n$ zeros and $n$ ones?</p>\n</blockquote>\n\n<p>By "can we do better", I mean we should have lower complexity than the silly algorithm which first builds the entire tree above and then tries to find those paths with an equal number of "left" and "right" edges.</p>\n', 'ViewCount': '257', 'Title': "How does one efficiently produce all binary sequences with an equal number of 0's and 1's?", 'LastActivityDate': '2013-07-01T08:25:02.287', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12994', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8940', 'Tags': '<algorithms><graphs><binary-trees>', 'CreationDate': '2013-06-30T14:02:49.333', 'Id': '12992'},63_179:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>While I was doing\n<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">CLRS</a> (3rd\nedition), I came across this question on page 629:</p>\n\n<p><strong>Professor Sabatier conjectures</strong> the following converse of Theorem\n23.1:</p>\n\n<blockquote>\n  <p>Let $G = (V,E)$ be a connected, undirected graph with a real-valued\n   weight function $w$ defined on $E$. Let $A \\subseteq E$ that is\n   included in some minimum spanning tree for $G$, let $(S,V -S)$ be any cut of $G$ that respects $A$, and let $(u,v)$ be a safe\n   edge for $A$ crossing $(S, V - S)$. Then, $(u,v)$ is a light\n   edge for the cut.</p>\n</blockquote>\n\n<p>Show that the professor\u2019s conjecture is incorrect by giving a\ncounterexample.</p>\n\n<p><strong>Theorem 23.1</strong>:</p>\n\n<blockquote>\n  <p>Let $G = (V,E)$ be a connected, undirected graph with a real-valued\n   weight function $w$ defined on $E$. Let $A$ be a subset of $E$ that\n   is included in some minimum spanning tree for $G$, let $(S, V\n - S)$ be any cut of $G$ that respects $A$, and let $(u,v)$\n   be a light edge crossing $(S, V - S)$.  Then, edge $(u,v)$\n   is safe for $A$.</p>\n</blockquote>\n\n<p>Can anybody please give a proof or a counterexample to the conjecture\nalso because I used to think that all safe edges added to the graph\nare light edges.  </p>\n\n<blockquote>\n  <p><strong>DEFINITIONS</strong> :<br>\n  1. <strong>Cut (S ,V-S)</strong> : of an undirected graph G = (V,E) is a partition of V(as defined in CLRS Book) .You can think it as a line that divides graph into two disjoint sets of vertices on its either side.<br>\n  2. <strong>Light edge</strong>:Any edge crossing a cut is light edge if its weight is the minimum of all the edge crossing the cut.Light edge is defined with respect to a particular Cut.<br>\n  3. A cut <strong>Respects</strong> a set A of edges if no edge in A crosses the cut.<br>\n  4. <strong>Safe edge</strong> is the edge which we can add to MST without any violation of MST\'s property.These are those edges which are the part of final MST.  </p>\n</blockquote>\n\n<p>I have written most of the definition but for more queries you can also refer to CLRS chapter 23.</p>\n', 'ViewCount': '340', 'Title': 'Sabatier conjectures', 'LastEditorUserId': '8951', 'LastActivityDate': '2014-05-03T17:00:51.560', 'LastEditDate': '2013-07-03T21:58:06.263', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '13071', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8951', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-07-01T08:06:55.030', 'Id': '13008'},63_180:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '406', 'Title': 'About metric TSP instances', 'LastEditDate': '2013-07-03T21:59:48.323', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8997', 'FavoriteCount': '1', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Christofides_algorithm" rel="nofollow">Christofides\' 1.5-approximation</a> considers complete graphs as inputs, and as I understand this is essential. If the input graph is not complete, how can I add new edges with suitable weights such that the resulting complete graph still satisfies the triangle inequality, and, of course, the TSP solution for the complete graph only uses original edges? Thank you.  </p>\n', 'Tags': '<graphs><approximation><traveling-salesman>', 'LastEditorUserId': '8997', 'LastActivityDate': '2013-07-04T00:20:24.543', 'CommentCount': '0', 'AcceptedAnswerId': '13077', 'CreationDate': '2013-07-03T21:27:28.363', 'Id': '13070'},63_181:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an  algorithmic problem.</p>\n\n<p>I have a set of different polygons in the 2D space. Each polygon is represented according to its vertex representation (<code>x</code> and <code>y</code> coordinates) and may contain up to <code>N</code> different vertices. </p>\n\n<p>Assuming I have a set of <code>N</code> polygons, then for a new polygon <code>k</code>, how do I determine whether or not <code>k</code> overlaps with each one of the <code>N</code> polynomials in the set AND what is the overlapping reign percentage?</p>\n\n<p>This is a purely algorithmic question but I plan on writing the algorithm in parallel using the CUDA platform, therefore any highly parallel solution would be preferred.   </p>\n', 'ViewCount': '57', 'Title': 'How to find polygons overlap reign', 'LastActivityDate': '2013-07-06T12:56:54.447', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9046', 'Tags': '<algorithms><graphs><computational-geometry>', 'CreationDate': '2013-07-06T09:43:23.897', 'Id': '13107'},63_182:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given two graphs $G_{1}(E_{G1},V_{G1})$ and $G_{2}(E_{G2},V_{G2})$, with scalar weights on the vertices, I would like to find a subgraph $H_{1}$ of $G_{1}$ that best matches some subgraph $H_{2}$ of $G_{2}$.  However, in most papers I've seen the weights are usually on the edges, $H_{1}$ is pre-specified and the matching being attempted was exact. I would be grateful if somebody could point me in the right direction.</p>\n\n<p>Clarification edit: I'm looking for $H_1(E_{H1},V_{H1})\\subset G1(E_{G1},V_{G1})$ and an injective function $f:V_{H1}\\rightarrow V_{G2}$ so that $|\\{(f(u),f(v))$ $\\in$ $E_{G2}$ | $(u,v) \\in E_{H1}\\}| / |E_{H1}|$ is maximized while the sum of the node weight differences - $\\sum_{v \\in V_{H1}} |w(f(v))-w(v)|$ is minimized.     </p>\n", 'ViewCount': '65', 'Title': 'What are the popular approaches to inexact attributed-subgraph matching?', 'LastEditorUserId': '9095', 'LastActivityDate': '2013-07-11T14:15:08.310', 'LastEditDate': '2013-07-11T05:48:25.567', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9095', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-07-09T14:08:46.273', 'Id': '13175'},63_183:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $G$ be a directed graph, and $H$ a subgraph of $G$ that contains all the vertices of $G$. (In other words, $H$ is obtained by deleting some of the edges of $G$, but not any of the vertices of $G$.)</p>\n\n<p>A subgraph isomorphism $\\varphi$ from $G$ to $H$ is a graph isomorphism from some subgraph of $G$ to $H$.  In other words, it is a bijective function $\\varphi:V\\to V$ (where $V$ is the vertex set of $G$) such that if $(\\varphi(u),\\varphi(v))$ is an edge in $H$, then $(u,v)$ is an edge in $G$.</p>\n\n<p>Let $\\Phi$ denote the set of all subgraph isomorphisms from $G$ to $H$.  For a vertex $v \\in V$, define the out-expansion of $u$ in $\\Phi$ to be $|\\{\\varphi(v) : \\varphi \\in \\Phi\\}|$ (i.e., the number of vertices that $v$ can be mapped to, under some subgraph isomorphism), and the in-expansion of $v$ to be $|\\{\\varphi^{-1}(v) : \\varphi \\in \\Phi\\}|$ (i.e., the number of vertices that can map to $v$, under some subgraph isomorphism).</p>\n\n<p>Consider the following proposition:</p>\n\n<blockquote>\n  <p>If every vertex has out-expansion $\\ge k$, then every vertex has in-expansion $\\ge k$.</p>\n</blockquote>\n\n<p>Is this proposition true for all $G,H$?</p>\n\n<p>I haven't been able to find any reason why it should be true.  (For instance, I don't think $\\Phi$ is closed under inversion: $\\varphi \\in \\Phi$ doesn't seem to imply $\\varphi^{-1} \\in \\Phi$.)  However, playing with a few small examples, I haven't found a counter-example yet.  That said, I only tried a few simple examples, so it's possible that more trial-and-error might give a better sense.  But I thought I'd check whether anyone here has any suggestions for how to answer this.</p>\n\n<p>Motivation: this problem arises in the security analysis of a proposed scheme for obfuscating/protecting circuits.  The graph represents the circuit (actually, they use a colored graph, where each vertex is given a color, and the isomorphism has to respect the color scheme; but that can probably be ignored, for simplicity), and subgraph isomorphisms represent different possible ways that the circuit might have been hidden/obfuscated.</p>\n", 'ViewCount': '36', 'Title': 'Subgraph isomorphisms: does large out-expansion imply large in-expansion?', 'LastActivityDate': '2013-07-10T16:08:36.300', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13204', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<graph-theory><graphs><discrete-mathematics><graph-isomorphism>', 'CreationDate': '2013-07-09T19:24:18.013', 'Id': '13183'},63_184:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>This is a cross-post of <a href="http://stackoverflow.com/questions/17538933/route-planning-in-public-transport-application">this StackOverflow question</a>, (I\'m not aware of linking questions between StackExchange sites). You can ignore the part about programming.</p>\n\n<p>I\'m making a journey planner (or a general timetable application) for all the public transport in my country (bus/train/air).</p>\n\n<p>The state of the project is at midpoint, now I\'m having a bit of a hard time getting the more difficult part of the application done.</p>\n\n<p>Currently, I have all the stops, routes and departure/arrival times.</p>\n\n<p>When there are direct connections between two points, all is fine, I can get the trips for a chosen day. The hard part is getting a complete journey when there are no direct lines.</p>\n\n<p>Say the user wants to travel from <code>city A</code> to <code>city D</code>, but because there are no direct lines between those cities, he needs to pass through <code>city B</code> and <code>city C</code>.</p>\n\n<p>How can I get the optimized routes and <em>transfers</em> for this situation?</p>\n\n<p>My ideas so far a gravitating towards using a graph, but in that case I need a <strong>Time-Dependant Directed Weighted Multigraph</strong>, and I really have no idea at the moment how to implement the <strong>Time-Dependant</strong> part.</p>\n\n<p>Getting just the route can be done by using <code>Dijkstra</code>, <code>A*</code> or <code>Floyd\u2013Warshall</code> algorithms , but because there are departures at different times, I\'m not sure how will this be implemented, to get the optimal solution. I need to take into consideration the duration of a segment (A to B, B to C), waiting time for the transfer, maybe the distance too.</p>\n\n<p>Just to clarify, I don\'t need a single result. I want to get a daily list of all departures from <code>city A</code> that can get the user to <code>city D</code>, with transfers if needed.</p>\n\n<p>Basically, what I\'m trying to get is something like this (taken from Bulgarian Railways, or for that matter, whichever railway site), a list of all departures for a chosen day going from <code>Sofia</code> to <code>Kystendil</code> making transfer in <code>Radomir</code> if needed:</p>\n\n<p><img src="http://i.stack.imgur.com/Yrron.jpg" alt="Sample Result"></p>\n\n<p>If I\'m not clear enough, please ask.</p>\n\n<p>I know that this is done so many times (almost any train website has the solution), but I don\'t know by which terms to even search.</p>\n\n<p><strong>So, my question is: can someone give me guidance how this type of problem is solved?</strong></p>\n\n<p><strong>Or at least by which terms should I search for ideas and how should it be done.</strong></p>\n\n<p>Maybe some suggestions for other sites in the StackExchange network.</p>\n', 'ViewCount': '210', 'Title': 'Route planning in public transport application', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-10T07:46:09.137', 'LastEditDate': '2013-07-10T07:46:09.137', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9100', 'Tags': '<algorithms><graphs><dynamic-programming><shortest-path>', 'CreationDate': '2013-07-09T21:26:13.667', 'FavoriteCount': '1', 'Id': '13189'},63_185:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there an efficient algorithm which gives the minimum cost closed walk in an undirected graph, which visits all vertices?</p>\n\n<p>Does this problem have a name? I tried to reduce this to similar problems (in particular the traveling salesman problem) to see if it was NP-hard, but was unsuccessful.</p>\n\n<p>Here\'s an example:</p>\n\n<p><img src="http://i.stack.imgur.com/3dxzt.png" alt="enter image description here"></p>\n\n<p>Then a possible closed walk is: A,B,C,D,C,B,A, with a cost of 6.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '203', 'Title': 'Minimum cost closed walk in a graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-15T11:10:55.033', 'LastEditDate': '2013-07-14T09:51:41.813', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '13283', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9173', 'Tags': '<algorithms><graphs><np-hard><graph-traversal><traveling-salesman>', 'CreationDate': '2013-07-14T05:04:52.683', 'Id': '13267'},63_186:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m attepting to model a process flow where the transition to the next state is occasionally based on not only the input to the current state, but a prior state as well.</p>\n\n<p>Below is an example graph descibring the process. The essence is: If both State Q1 and State Q3 recieve an input of one, after State 3, transition to State Q4, otherwise transition to State Q5.</p>\n\n<p><img src="http://i.stack.imgur.com/DcBTc.png" alt="Non-state dependent machine"></p>\n\n<p>I understand that it would be possible to model this using a finite-state machine where we duplicate any states between those that we are interested in. The example below demonstrates this with States Q2a and Q2b corresponding to the differences in input at state Q1</p>\n\n<p><img src="http://i.stack.imgur.com/r9cMs.png" alt="State-dependent"></p>\n\n<p>However, as the number of conditions and the gaps between them grows (both of which are possible in the process I\'m looking at), the number of states grows exponentially.</p>\n\n<p>The question is, what other computational models could be used to describe a process where an arbitrary number of inputs could be used to control transition between states?</p>\n', 'ViewCount': '96', 'Title': 'State machine with knowledge of prior states?', 'LastActivityDate': '2013-07-22T11:24:27.433', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8632', 'Tags': '<graphs><automata><network-flow>', 'CreationDate': '2013-07-22T00:27:48.457', 'Id': '13379'},63_187:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose that I have run maxflow algorithm on a graph G and, as a result, I have a set of edges with flow on them.\nI would like to enumerate all possible sets of paths that comprise the maxflow.\nThat is, each set of paths will make the max flow.\nBut I suspect there could be multiple set of such paths.</p>\n', 'ViewCount': '102', 'ClosedDate': '2013-11-28T21:50:32.407', 'Title': 'Finding paths from the result of max flow', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-24T09:17:42.807', 'LastEditDate': '2013-08-26T08:28:54.027', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9311', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2013-07-23T22:13:52.240', 'Id': '13403'},63_188:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are a number of collections of network (or graph) data sets freely available on the web, e.g.</p>\n\n<ul>\n<li><a href="http://snap.stanford.edu/data/index.html" rel="nofollow">http://snap.stanford.edu/data/index.html</a></li>\n<li><a href="http://www.cc.gatech.edu/dimacs10/downloads.shtml" rel="nofollow">http://www.cc.gatech.edu/dimacs10/downloads.shtml</a></li>\n</ul>\n\n<p>I am looking for dynamic network data sets, i.e. networks whose structure varies over time. They seem to be quite rare: The SNAP collection contains only a few "temporal" graphs.</p>\n\n<p>Do you known any other possible sources?</p>\n', 'ViewCount': '56', 'Title': 'Looking for dynamic network data sets', 'LastActivityDate': '2013-07-31T15:18:51.787', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9450', 'Tags': '<graphs><data-sets><social-networks><big-data>', 'CreationDate': '2013-07-31T15:18:51.787', 'Id': '13542'},63_189:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been looking for an algorithm which divides an undirected, weighted, planar and simple graph into $k$ disjoint subgraphs. Here, the graph is sparse, $k$ is fixed, and there are no negative edge weights. After cutting, each subgraph must be connected (i.e. there must be a path between any two vertices of the subgraph which is only composed of vertices in that subgraph).</p>\n\n<p>However, unlike most existing work on graph partitioning out there, I don't intend to obtain subgraphs that contain the same approximate number of vertices. Instead, I would like these subgraphs to have similar sum of edge weights. In other words, I would like to minimize the sum of edge weights of the subgraph with maximal weight and ideally cut long (weighted) edges.</p>\n\n<p>Is there a name for this problem? I wasn't able to find anything about this on the web. Also, how can I approach this problem?</p>\n", 'ViewCount': '185', 'Title': 'Dividing a weighted planar graph into $k$ subgraphs with balanced weight', 'LastEditorUserId': '9431', 'LastActivityDate': '2013-11-06T15:14:17.837', 'LastEditDate': '2013-08-03T14:22:17.707', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9431', 'Tags': '<graph-theory><weighted-graphs><cluster><partition-problem>', 'CreationDate': '2013-08-02T04:01:20.273', 'FavoriteCount': '1', 'Id': '13571'},63_190:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The following question is related to the <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://en.wikipedia.org/wiki/Maximum_cut&amp;ei=wMQTUuXxLuny4QS55oHgAw&amp;usg=AFQjCNF7PelNFUITFjPfjyXHqig7ivCgvw&amp;sig2=JVB560isHX3-zBpX2khJTQ&amp;bvm=bv.50952593,d.bGE" rel="nofollow">max cut problem</a> in <em>cubic graphs</em>. In <a href="http://www.cs.armstrong.edu/greenlaw/research/cubic.ps" rel="nofollow">this</a> survey paper Theorem 6.5 states</p>\n\n<blockquote>\n  <p>A maximal cut of a cubic graph can be computed in polynomial time</p>\n</blockquote>\n\n<p>Browsing through some other related results (for example <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://www.cs.tau.ac.il/~zwick/papers/cubic-MAXCUT-SODA.pdf&amp;ei=ycUTUvvrH6fV4gT25IHQBA&amp;usg=AFQjCNG6njoPJo3VO7GHk9dQvdiN23WOTA&amp;sig2=z706i_jNpl-wljwko3W6QQ&amp;bvm=bv.50952593,d.bGE" rel="nofollow">this</a> SODA paper) one gets the impression that this problem is actually NP complete even for cubic instances. In particular, the last paper states that this is indeed so if the graph is subcubic.</p>\n\n<p>That makes me wonder.. What\'s going on? Is the survey paper (and the result cited therein) faulty or is there some point that I am missing?</p>\n', 'ViewCount': '49', 'Title': 'Max cut in cubic graphs', 'LastActivityDate': '2013-08-20T21:01:07.307', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13848', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<complexity-theory><graph-theory><graphs><np-complete><np>', 'CreationDate': '2013-08-20T19:42:20.570', 'Id': '13845'},63_191:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to construct a complete graph where each node is connected to every other node. The link between the nodes give a distance function (does not follow triangle inequality) between them. What I require is to merge the closest nodes, (bounded by a threshold) into a single node and recompute the graph each time, recursively. This is because if two nodes are merged, then all the links connected to the new node has to be updated with the newly computed distance for the new edge. Since its a complete graph this would be an expensive operation. </p>\n\n<p>I would have a large number of nodes with $N*(N-1)/2$ links for $N$ nodes , and $N=60$ or more , \nWhat I want to do is to reduce this complete graph into clusters of  sub graphs with low intra node distance, yet with a relatively high distance between the subgraphs. So,How can I go about solving this problem?</p>\n\n<p>This is like applying the graph partitioning techniques to complete graphs.</p>\n\n<p>One of the solutions is <a href="http://www.cs.berkeley.edu/~malik/papers/SM-ncut.pdf" rel="nofollow">this paper</a> which proposes the normalized cut criterion for partitioning the graph  minimizing normalized cuts on graphs which is clearly NP-complete,Is there a practically efficient way and what are the recent developments to achieve this?</p>\n\n<p>So what I want is an efficient solution to the above problem which is not NP complete ? Since this problem is NP Complete , answers using randomization or approximation methods would be welcome</p>\n', 'ViewCount': '173', 'Title': 'Algorithm for Graph merge and recompute', 'LastEditorUserId': '9881', 'LastActivityDate': '2013-09-01T18:21:45.387', 'LastEditDate': '2013-09-01T18:21:45.387', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9881', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-08-29T07:32:27.390', 'Id': '14014'},63_192:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assume that I have a file that consists of pairs of numbers separated by a space. These numbers are the labels for vertices in my graph. For example:</p>\n\n<pre><code>0 5\n0 7\n2 3\n4 5\n1 5\n.\n.\n.\n</code></pre>\n\n<p>I want to create a graph (adjacency list) by reading this file line-by-line. For each line, I will create an edge between the two vertices. Of course, if the vertex doesn\'t exist yet, then I will add it before creating the edge.</p>\n\n<p>I read <a href="https://vismor.com/documents/network_analysis/graph_algorithms/S4.php" rel="nofollow">here</a> of an algorithm that builds a graph with a time complexity of $O(|V| + |E|)$ where $V$ = set of vertices and $E$ = set of edges. That makes sense to me. However my algorithm doesn\'t insert the vertices in a loop first and then insert all of the edges in another loop second. My algorithm just adds the vertices as it\'s looping through the edges.</p>\n\n<p>My question is if my algorithm is $O(|E|)$? It seems like that can\'t be right, but I read <a href="http://stackoverflow.com/questions/12231499/do-if-statements-affect-in-the-time-complexity-analysis">here</a> that when calculating the time complexity you don\'t take into account if statements. That\'s exactly what my vertex creation would be -- an if statement that checks if the node exists in the middle of my looping through all the edges.</p>\n', 'ViewCount': '261', 'Title': 'Time Complexity for Creating a Graph from a File', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T12:29:22.547', 'LastEditDate': '2013-09-09T12:29:22.547', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14224', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10045', 'Tags': '<algorithms><graphs><algorithm-analysis><runtime-analysis>', 'CreationDate': '2013-09-09T04:28:52.703', 'Id': '14223'},63_193:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Suppose I have a connected graph with $n$ vertices and $n\u22121$ edges, that is in form of a tree. Now, I will add the number of vertices in the tree and uniformly randomly select a vertex. I break the graph at this selected vertex, deleting the vertex and the edges connected to it. Now, I again repeat the same thing at all of the left components (sub-trees) until I am left with one vertex for which the answer is inherently $1$. What will be the expectation of the sum obtained by adding the number of vertices recursively in such a problem?</p>\n\n<p>For example, I have 3 vertices, A, B and C in which A is connected to B as well as C, but B and C are not connected. Like, B--A--C. Now, I could select any one vertex out of three with probability 1/3, so I add 3. Now, if I had selected A, I would repeat this for B and C separately adding one for each case. Otherwise, selecting B or C, I would have repeated it on A--C or B--A respectively, adding 2 and selecting each node again with probability 1/2.</p>\n\n<p>I agree the problem is weakly written, here is a formulation suggested by <a href="http://cs.stackexchange.com/users/5167/karolis-juodel">Karolis Juodel\u0117</a>:\nI\'m looking for the expected value of $f(G) = \\left|V_G\\right| + \\sum f(G_i)$ where $G_i$ are components remaining after removing a random vertex of $G$.</p>\n', 'ViewCount': '61', 'Title': 'Which component sizes do we observe while randomly deconstructing a tree?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:37:06.417', 'LastEditDate': '2013-11-28T21:37:06.417', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8619', 'Tags': '<graphs><probability-theory><trees>', 'CreationDate': '2013-09-10T17:58:03.147', 'Id': '14252'},63_194:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '237', 'Title': 'Minimal size of contracting a DAG into a new DAG', 'LastEditDate': '2013-11-03T18:16:54.507', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '10273', 'FavoriteCount': '3', 'Body': "<p>We have a DAG. We have a function on the nodes $F\\colon V\\to \\mathbb N$ (loosely speaking, we number the nodes). We would like to create a new directed graph with these rules: </p>\n\n<ol>\n<li>Only nodes with the same number can be contracted into the same new node. $F(x) \\neq F(y) \\Rightarrow x' \\neq y'$. (However, $x' \\neq y'\\nRightarrow F(x) \\neq F(y)$.)</li>\n<li>We add all the old edges between new nodes: $(x,y) \\in E \\land x' \\neq y' \\iff (x',y')\\in E'$.</li>\n<li>This new graph is still a DAG.</li>\n</ol>\n\n<p>What is the minimal $|V'|$? What is an algorithm creating a minimal new graph?</p>\n", 'Tags': '<algorithms><graphs><np-complete><reductions>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T04:56:53.490', 'CommentCount': '9', 'AcceptedAnswerId': '16277', 'CreationDate': '2013-09-23T08:24:13.643', 'Id': '14552'},63_195:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Imagine I have an ordering on a bunch of elements like so:</p>\n\n<p><img src="http://i.imgur.com/Sl2kUC0.png" alt="enter image description here"></p>\n\n<p>Where an arrow $X \\leftarrow Y$ means $X &lt; Y$. It is also transitive: $\\left(X &lt; Y\\right) \\wedge \\left(Y &lt; Z\\right) \\implies \\left(X &lt; Z\\right)$.</p>\n\n<p>In order efficiently answer queries like $A \\stackrel {?}{&lt;} D$, some sort of labeling or data structure is required. For example, you could number the nodes from left to right, and thus you can simply do integer comparison to answer the query: $A \\stackrel {?}{&lt;} D \\implies 1 &lt; 4 \\implies T$. It would look something like this:</p>\n\n<p><img src="http://i.imgur.com/YQ28co3.png" alt="enter image description here"></p>\n\n<p>Where the number is the ordering, and the letter is just a name.</p>\n\n<p>But what if you needed to insert elements "in between" two other elements in the ordering, like so:</p>\n\n<p><img src="http://i.imgur.com/aLuLJRH.png" alt="enter image description here"></p>\n\n<p><img src="http://i.imgur.com/HTSllkZ.png" alt="enter image description here"></p>\n\n<p><img src="http://i.imgur.com/DaytZtk.png" alt="enter image description here"></p>\n\n<p>How can you maintain such an ordering? With simple numbering, you run into the problem that there are no integers "in between" $2,3$ to use.</p>\n', 'ViewCount': '881', 'Title': 'Maintaining an efficient ordering where you can insert elements "in between" any two other elements in the ordering?', 'LastActivityDate': '2013-10-01T13:49:11.323', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14728', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<data-structures><graphs><linked-lists><partial-order><order-theory>', 'CreationDate': '2013-09-30T17:58:23.563', 'FavoriteCount': '2', 'Id': '14708'},63_196:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Suppose I have a set of small subgraphs $A=\\{G_i\\}$ of an original directed acyclic graph $G$, typically $|G_i| \\ll |G|$, which together span the original graph</p>\n\n<p>$$\nG= \\bigcup_i G_i\n$$\nMy question is if I take a arbitrary subset of these graphs $A\u2032 \\subset A$, and a single subgraph from this graph, $ a \\in A\u2032$, is there a simple way (or known algorithm) of reassembling the subgraph $G\u2032 \\subset G$ given by that portion of the union of $A\u2032$ connected to $a$?</p>\n\n<p>In words, this is rather like a jigsaw problem where $A$ is the total collection of pieces that originally came in the box, $A\u2032$ is the subset left after half of them got lost and $a \\in A\u2032$ the random selected piece you put down the start the puzzle off. The question is then what is the largest connected graph (connected subset of pieces $x \\in A\'$) that you can lay down all on the board.</p>\n\n<p>The actual application arises where each subgraph $G_i$ of A represents a rule and (e.g. $x \\wedge y \\Rightarrow z$) and the objective is to find the largest rule implied transitively from an initial seed rule $a \\in A\u2032$ and the remaining rules contained in thinned out subset $A\u2032 \\subset A$.</p>\n\n<p>I suspect I maybe able to do something by brute force here but would be most interested in knowing if there is any area or known application of this problem elsewhere.\n I think similar things are possible in declarative language such as Prolog but I suspect that Prolog can actually do any more. Any good up-to-date reference on declarative programming languages would also be very useful.</p>\n\n<p>I originally posted a version of this question on the <a href="http://scicomp.stackexchange.com/questions/8637/a-jigsaw-problem-recreating-a-subgraph-from-a-limited-number-of-fragments-on-an">Computational Science</a> site but was advised that this forum could be better.</p>\n', 'ViewCount': '46', 'Title': 'a jigsaw problem: recreating a subgraph from a limited number of fragments on an original graph', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-09-30T23:47:50.627', 'LastEditDate': '2013-09-30T22:14:53.810', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '14716', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10416', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-09-30T19:20:47.333', 'Id': '14712'},63_197:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<hr>\n\n<p>Is there an incremental directed graph data structure that has the following properties:</p>\n\n<ul>\n<li>Keeps an internal graph structure as a DAG, and the graph is accessible (notwithstanding other helper data-structures)</li>\n<li>The accessible DAG is kept as a transitive reduction (notwithstanding other helper data-structures)</li>\n<li>It should be optimized for a sparse graph (adjacency lists)</li>\n<li>It should condense cycles as they are introduced, keeps a mapping between equivalent vertices that are all replaced with one "representative" vertex</li>\n<li>Ability to quickly answer quickly ancestor/descendant/transitive/relationship queries (in $\\mathcal{O}(1)$ or $\\sim\\mathcal{O}\\left(\\log \\left|V\\right|\\right)$ time)</li>\n<li>Should support vertex, edge insertion, deletion would be nice too</li>\n<li>Mutable operations  (such as insertion) should be as output-sensitive as possible; in other words, the complexity should depend as much as possible on how much the operation must change the graph</li>\n<li>Ability to record changes over an operation, if requested. Obviously this might necessarily increase the complexity, but the increase should be output-sensitive. Examples:\n<ul>\n<li>set of deleted vertices (due to condensation)</li>\n<li>set of deleted edges (due to reduction)</li>\n<li>set of new decendent relationships from $u$ ( example: $insert(G,u,v) \\rightarrow \\left\\{t ~|~ path(u,t)\\in G\'\\wedge path(u,t)\\not\\in G\\right\\}$ )</li>\n<li>set of new ancestor relationships from $v$ ( example: $insert(G,u,v) \\rightarrow \\left\\{t ~|~ path(t,v)\\in G\'\\wedge path(t,v)\\not\\in G\\right\\}$ )</li>\n</ul></li>\n</ul>\n\n<p>The closest I can find is <a href="http://code-o-matic.blogspot.com/2010/07/graph-reachability-transitive-closures.html" rel="nofollow">here</a>, <a href="http://code.google.com/p/transitivity-utils" rel="nofollow">implementation</a>. I think you can build on this to do have most of the properties I list, but I am wondering if there is anything better/well known, or perhaps if there is a name for this problem.</p>\n\n<hr>\n\n<p><strong>EDIT:</strong></p>\n\n<h3>Related:</h3>\n\n<ul>\n<li><a href="http://cstheory.stackexchange.com/q/14343/3377">What is the fastest deterministic algorithm for dynamic digraph reachability with no edge deletion?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/18787/3377">What is the fastest deterministic algorithm for incremental DAG reachability?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/5176/3377">Does an algorithm exist to efficiently maintain connectedness information for a DAG in presence of inserts/deletes?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/2548/3377">Is there an online-algorithm to keep track of components in a changing undirected graph?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/17135/3377">Dynamic shortest path data structure for DAG</a></li>\n</ul>\n', 'ViewCount': '150', 'Title': 'An incrementally-condensed transitive-reduction of a DAG, with efficient reachability queries', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-04T05:16:35.877', 'LastEditDate': '2013-10-04T04:51:04.030', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><data-structures><graphs><shortest-path><online-algorithms>', 'CreationDate': '2013-10-03T21:12:35.287', 'FavoriteCount': '1', 'Id': '14798'},63_198:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I used this generalized transition graph with 3 states and got an equivalent generalized\ntransition graph with 2 states:</p>\n\n<p>GTG:</p>\n\n<p><img src="http://i.stack.imgur.com/LSUfs.jpg" alt="enter image description here"></p>\n\n<p>Equivalent with 2 states:</p>\n\n<p><img src="http://i.stack.imgur.com/nenwS.jpg" alt="enter image description here"></p>\n\n<p>I\'m not sure about the regular expressions linking the nodes $q0$ and $q2$, if someone can clarify where I may have gone wrong here.</p>\n', 'ViewCount': '44', 'Title': 'Reducing states of a GTG', 'LastActivityDate': '2013-10-06T09:56:23.350', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14856', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><graphs><automata><formal-grammars>', 'CreationDate': '2013-10-06T04:19:51.400', 'Id': '14852'},63_199:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading a paper on <a href="http://talukdar.net/papers/adsorption_ecml09.pdf" rel="nofollow">Semi Supervised Learning</a> and I am confused about a term. The paper talks about graphs that are invariant to permutations of the vertices. Can somebody explain or perhaps give an example? Is it same a regular graphs?</p>\n', 'ViewCount': '43', 'Title': 'Graphs invariant to permutations of vertices', 'LastActivityDate': '2013-10-08T11:42:31.550', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1972', 'Tags': '<graph-theory><graphs><machine-learning>', 'CreationDate': '2013-10-08T11:42:31.550', 'Id': '14906'},63_200:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In class we saw the followin problem but i didnt undestand the solution. Do anybody could explain me with more detail the procedure to solve this problem or give me a better solution?:</p>\n\n<blockquote>\n  <p>Assume that $n$ points in the plane are given. Find a polygonal arc with $n-1$ sides whose vertices are given points, and whose sides do not intersect. (Adjacent sides may form a $180$ angle). The number of operations shold be of order $n$ $log$ $n$.</p>\n</blockquote>\n\n<p>The teacher solution was:</p>\n\n<blockquote>\n  <p>Sort all the points with respect to the x-coordinate; when x-coordinates are equal, take the y-coordinate into account, then connect all the vertices by line segments(in that order).</p>\n</blockquote>\n', 'ViewCount': '45', 'ClosedDate': '2013-11-28T21:51:16.080', 'Title': 'Finding a polygonal arc algorithm?', 'LastActivityDate': '2013-10-09T15:57:50.583', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10610', 'Tags': '<algorithms><algorithm-analysis><graphs><sorting>', 'CreationDate': '2013-10-09T15:57:50.583', 'Id': '14955'},63_201:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to find an efficient solution to my problem. Let's assume that I have positive weighted graph <code>G</code> containing 100 nodes(each node is numbered) and it is an acyclic graph. So there cannot be any edge like 2,2 or 2,1. I have got a list of nodes let's say 10 from graph <code>G</code>. Let's say each of these nodes are also in an array. I am looking for a way to find the shortest path's total weight from node 1 to 100 that passes through at least some particular(let's say 5) of those nodes from that list.</p>\n\n<p>To simplify it, consider graph with 6 nodes, 0...5, now node 1 and 4 are marked as points where we could specify to pass. Let's say existing paths are 0-1-2-5, 0-3-4-5, and 1-4. Now let's say all edges are weighted as 5 except 3 to 4 is weighted as 1. If we run a shortest path algorithm this would basically find the path 0-3-4-5 as it is weighted 11. However if we run an algorithm specifying minimum amount of specified points and try the amount 2. Then the algorithm should be running on 0-1-4-5 which is weighted as 15.</p>\n\n<p>I have written this way</p>\n\n<pre><code>    shortestPath(destinationNode, minAmount) \n\n        if(destinationNode == srcNode &amp;&amp; minAmount &lt; 1) \n            return 0\n\n        else if(destinationNode == srcNode &amp;&amp; minAmount &gt; 1) \n            return INFINITY\n\n        int destNo = destinationNode get number\n        int cost = INFINITY\n        for (int i = 0; i &lt; destNo; i++)\n            if (d[i][destNo] != null) \n                int minimumAmountCount = minAmount;\n                for (int j = 0; j &lt; marked.length(); j++) \n                    if (marked[j] == i) \n                        minimumAmountCount = minimumAmountCount - 1;\n\n                cost = MIN(cost, shortestPath(Node(i), minimumAmountCount);\n\n        return cost;\n</code></pre>\n\n<p>Basically we call this algorithm by using the our destination node and minimum amount of nodes from that list. Firstly we want to make sure that this is a recursive function and it should have a stopping point, which would be when passed destination is equal to source node(which is essentially node #0). The second case we need to check is whether we visited enough amount, so if it is less than 1(0 or negative number) then we visited enough points and return 0 as distance from node #0 to node #0 would be 0. If we did not visit enough amount then we return infinity so that algorithm would consider other paths.</p>\n\n<p>So in order for the returning part to work, we have to define the destination node's number(if we consider that we have 100 nodes it would be node #99 at the initial start) and initialise cost as infinity.</p>\n\n<p>Then we run a for loop that starts from 0(essentially node #0) till our current node number, this is because there are no backwards edges on the graph. By using node number we check from the matrix whether there is an existing weight for those nodes. If it exist then we initialise a variable for our current minimum amount and then run a loop and check if source to the current destination is in the list of marked nodes. If it is marked then we simply decrement the minimum amount.</p>\n\n<p>For the final step we run the function again by changing destination as the current source and with the current minimum amount.</p>\n\n<p>But it seems very expensive, considering the fact that the worst case complexity of  nested loop takes O(|Node|^2) and total recurrence would take O(|Node|^2 * |Edges|). So is there any other efficient solution for this problem?</p>\n", 'ViewCount': '799', 'Title': 'Shortest path that passes through specific node(s)', 'LastEditorUserId': '8849', 'LastActivityDate': '2013-10-11T03:40:33.580', 'LastEditDate': '2013-10-10T23:46:31.867', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8849', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T06:29:19.223', 'FavoriteCount': '0', 'Id': '14977'},63_202:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have written an A* algorithm to find the shortest path through a directed cyclic graph.  I am trying to modify it to find the longest path through the same graph.</p>\n\n<p>My attempt was to write it so that all I change is [1] the weights per edge (making them negative instead of positive) and [2] the heuristic function.</p>\n\n<p>I seem to be having trouble getting it to do this. It is pretty good at finding the longest path sometimes, but it is not guaranteed.  </p>\n\n<p>It seems that the problem lies with [2] the heuristic -- for shortest path an L2 norm is a good optimistic way to get it to head towards the goal, but for longest path I want the heuristic to point it at paths that are further from the goal to continue to increase total length. </p>\n\n<p>If I set the heuristic to return 0 so that it's a Dijkstra's search, it's less predictable as there's no incentive to search from nodes further away (using [1] negative weights per edge).</p>\n\n<p>I think if I keep the weights positive and try to maximize the score instead of minimize it may work, but I was attempting to do this without changing the algorithm, only the edge weights and the heurstic.</p>\n\n<p>I have found similar posts on stackExchange but they don't answer my specific questions:</p>\n\n<p>Q1) Can this be done with A*</p>\n\n<p>Q2) Is setting the weights negative the right thing to do</p>\n\n<p>Q3) Is the only way to do this is to set the heuristic to zero and keep the weights positive and try to maximize the score instead of minimize it?</p>\n", 'ViewCount': '1136', 'Title': 'A* to find the longest path in a directed cyclic graph', 'LastActivityDate': '2013-10-10T22:54:53.123', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14996', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10643', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T18:39:05.643', 'Id': '14991'},63_203:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a tree $T$ with $n$ vertices, we want to find the number of triplets of vertices $(a,b,c)$ such $d(a,b) = d(b,c) = d(c,a)$ where $d$ is the distance function (length of the shortest path between two nodes).</p>\n\n<p>It's pretty easy to do it in $O(n^3)$ time. Is it possible to do it faster?<br>\nI think that on-line algorithm and pre-processing should help.</p>\n", 'ViewCount': '86', 'Title': 'Find equidistant triplets in a tree', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-14T02:33:40.063', 'LastEditDate': '2013-10-13T18:35:08.433', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10555', 'Tags': '<algorithms><graphs><dynamic-programming><trees>', 'CreationDate': '2013-10-13T18:28:25.567', 'FavoriteCount': '0', 'Id': '16047'},63_204:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>To find the maximum flow in a graph, why doesn't it suffice to only saturate all augmenting paths with the minimum edge capacity in that path without considering the back-edges? I mean, what is the point calling it a back-edge if we assume flow from it?</p>\n", 'ViewCount': '52', 'Title': 'Saturating all augmenting paths with the minimum edge capacity in max flow', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T21:07:48.467', 'LastEditDate': '2013-10-18T21:07:48.467', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10525', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs><network-flow>', 'CreationDate': '2013-10-18T17:15:17.717', 'Id': '16202'},63_205:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '708', 'Title': 'Shortest non intersecting path for a graph embedded in a euclidean plane (2D)', 'LastEditDate': '2013-12-10T03:44:41.487', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '7', 'Body': '<p>What algorithm would you use to find the shortest path of a graph, which is embedded in an euclidean plane, such that the path should not contain any self-intersections (in the embedding)?</p>\n\n<p>For example, in the graph below, you want to go from $(0,0) \\rightarrow (-3,2)$. Normally, an algorithm like Dijkstra\'s algorithm would produce a sequence like:</p>\n\n<p>$$\\left[ (0,0) \\stackrel {3}{\\rightarrow} (0,3) \\stackrel{\\sqrt{2}}{\\rightarrow} (1,2) \\stackrel{4}{\\rightarrow} (-3,2) \\right] = 7+\\sqrt{2}.$$</p>\n\n<p>Full graph:</p>\n\n<p><img src="http://i.stack.imgur.com/l3OkDm.jpg" alt="enter image description here"></p>\n\n<p>Shortest path:</p>\n\n<p><img src="http://i.stack.imgur.com/HwDQtm.jpg" alt="enter image description here"></p>\n\n<p>Shortest non-intersecting path:</p>\n\n<p><img src="http://i.stack.imgur.com/sIj1wm.jpg" alt="enter image description here"></p>\n\n<p>However, this path intersects itself on the euclidean plane, therefore I <em>want</em> an algorithm that would give me the shortest non-intersecting sequence, in this case:</p>\n\n<p>$$\\left[(0,0) \\stackrel{3}{\\rightarrow} (0,3) \\stackrel{3}{\\rightarrow} (0,6) \\stackrel{5}{\\rightarrow} (-3,2) \\right] = 11.$$</p>\n\n<p>This path is longer than the shortest path, but it is the shortest non-intersecting path.</p>\n\n<p><strong>Is there an (efficient) algorithm that can do this?</strong></p>\n\n<h2>TikZ sources</h2>\n\n<ul>\n<li><a href="https://www.writelatex.com/read/jzkhmqgmqcnj" rel="nofollow">Full graph</a>.</li>\n<li><a href="https://www.writelatex.com/read/kwpwzzcfyjcy" rel="nofollow">Shortest path</a>.</li>\n<li><a href="https://www.writelatex.com/read/qzrbvwxgpbtp" rel="nofollow">Shortest non-intersecting path</a>.</li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal><weighted-graphs>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T03:44:41.487', 'CommentCount': '20', 'AcceptedAnswerId': '16281', 'CreationDate': '2013-10-20T23:27:17.370', 'Id': '16269'},63_206:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an euclidean graph, I want to add new node to it, and create edges between that node and all the rest of the nodes, keeping it euclidean. Now I want to sort all the nodes in the graph by distance from the node that I just added.</p>\n\n<p>What would be the best way to do it? Is there any solution better than $O(NLog(N))$?</p>\n', 'ViewCount': '149', 'Title': 'Find neighbors of node in euclidean graph', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-10-21T22:38:13.503', 'LastEditDate': '2013-10-21T08:19:28.800', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<graphs><computational-geometry>', 'CreationDate': '2013-10-21T07:01:17.450', 'FavoriteCount': '1', 'Id': '16279'},63_207:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an Euclidean, undirected graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.</p>\n\n<ul>\n<li>The number of vertices with no edges is small in comparison to the total number of vertices. </li>\n<li>No vertex has more than two edges connected to it.</li>\n</ul>\n\n<p>How can I convert this graph to a closed shape, so each vertex will have exactly two edges connected to it and there will be a path between any two vertices? I want to do it with minimum change in the total weight of all the edges.</p>\n', 'ViewCount': '126', 'Title': 'Converting graphs to sets of paths', 'LastEditorUserId': '917', 'LastActivityDate': '2013-12-10T03:14:40.417', 'LastEditDate': '2013-12-10T03:14:40.417', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><weighted-graphs>', 'CreationDate': '2013-10-23T07:11:44.910', 'Id': '16351'},63_208:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices, also all the vertices are connected with edges.</p>\n\n<p>I want to change the vertices values, so that the average ratio between the length of two edges (taken over all pairs of edges), will be as small as possible, I want to keep just one rule. For any vertex on the graph, it's neighbors sorted by Euclidean distance from that vertex, must remind in the same order.</p>\n\n<p>The idea behind this, if solution could be provided, that it will be possible to treat groups of vertices as one. It will reduce the difficulty of solving TSP.</p>\n", 'ViewCount': '64', 'Title': 'Trim graph to minimum', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-10-23T13:50:52.117', 'LastEditDate': '2013-10-23T13:50:52.117', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-23T12:39:35.833', 'Id': '16361'},63_209:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I have the question:</p>\n\n<p>Prove that any directed cycle in the graph of a partial order must only involve one node.</p>\n\n<p>So I know that a partial order must be transitive, antisymmetric, and reflective, but from there I am pretty lost. I also know that any path of one or more edges from a node to itself is a directed cycle, but from there I am having trouble connecting everything.</p>\n\n<p>I kind of need help as to where to start thinking, and the first step as to how to answer this question.</p>\n', 'ViewCount': '99', 'Title': 'Prove that any directed cycle in the graph of a partial order must only involve one node', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-24T13:28:57.787', 'LastEditDate': '2013-10-24T02:09:46.897', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10282', 'Tags': '<graphs><graph-traversal><partial-order><order-theory>', 'CreationDate': '2013-10-24T01:39:01.753', 'Id': '16389'},63_210:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.</p>\n\n<p>I am randomly creating a path thru all the vertices and I want to know if there is any efficient way to find all the intersections on my path.</p>\n', 'ViewCount': '124', 'Title': 'Efficient way to find intersections', 'LastActivityDate': '2013-10-25T07:39:59.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '16422', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><weighted-graphs>', 'CreationDate': '2013-10-25T06:16:51.257', 'Id': '16418'},63_211:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Eagle, et al [1] discuss the notion of node entropy and this is captured in igraph via the diversity metric. I was wondering if there was any relationship between these node entropies and the idea of the entropy for the entire graph.</p>\n\n<p>A related question: Does the concept of edge entropy make sense? The probability would be the ratio of the weight of the edge in question and the sum of the weights of all edges connected to the nodes incident to the edge in question.</p>\n\n<p>[1]: N. Eagle, M. Macy, and R. Claxton, \u201cNetwork Diversity and Economic Development,\u201d Science, vol. 328, no. 5981, pp. 1029\u20131031, May 2010.</p>\n', 'ViewCount': '47', 'Title': 'Is there a relationship between graph entropy and node entropy?', 'LastActivityDate': '2013-10-25T20:57:44.423', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10978', 'Tags': '<graphs><entropy><weighted-graphs>', 'CreationDate': '2013-10-25T20:57:44.423', 'Id': '16432'},63_212:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.  I found a <a href="http://tsp-vs-world.blogspot.co.il/2013/10/intersections-optimal-tsp-route.html" rel="nofollow">geometric proof</a> that every optimal TSP solution contains no intersections.</p>\n\n<p>How many non-intersecting routes could be there? Or in other words: what is the probability to guess an optimal solution to a TSP problem if we just enumerate or sample non-intersecting routes?</p>\n\n<p><strong>Edit:</strong> I want to ignore the case that D.W. mentioned. For every path that you can swap between two neighbors vertices(If we represent the path as an array of vertices so neighbors will be two vertices with consecutive indexes) without changing its non-intersecting quality, all of those paths will be considered as one.</p>\n\n<p><strong>Edit</strong> I found that this kind of removing crossings from the graph also know as <a href="http://en.wikipedia.org/wiki/2-opt" rel="nofollow">2-OPT</a> </p>\n', 'ViewCount': '236', 'Title': 'Calculating the number of non-intersecting routes in an Euclidean graph', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-11-03T12:37:57.193', 'LastEditDate': '2013-11-03T12:37:57.193', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-26T09:50:01.253', 'FavoriteCount': '1', 'Id': '16439'},63_213:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am interested in what sort of metrics are there that try to give a measure of how complex a given graph is, what are the corresponding algorithms, and what is their time complexity. A short description or list of relevant paper would be great.</p>\n\n<p>It might help to say that I have two graphs and I want to somehow tell which one is ``more complex." I will use this metric as a heuristic, so I would like to try various metrics on empirical data. (It might help even more if I say that those graphs represent two FSMs.)</p>\n', 'ViewCount': '88', 'Title': 'Metrics and algorithms for complexity of a graph', 'LastActivityDate': '2013-11-05T19:40:41.493', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '16518', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<graphs><regular-languages><time-complexity>', 'CreationDate': '2013-10-28T20:28:08.857', 'FavoriteCount': '1', 'Id': '16512'},63_214:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Although this seems rather obvious, I couldn't prove it rigorously. Any ideas how to prove it? The graph is assumed to be simple and connected.</p>\n\n<p>Explanation of the terms:</p>\n\n<ul>\n<li>$k$-regular means that all vertices have degree $k$;</li>\n<li>bipartite means that there are 2 sets of vertices $X, Y$, where vertices from $X$ only have edges with vertices $Y$ and vertices from $Y$ only have edges with vertices from $X$;</li>\n<li>cut-edge is an edge which removal disconnects the graph;</li>\n</ul>\n\n<p>This is b) part of the exercise, maybe a) part can help:</p>\n\n<p>a) If all vertices $v \\in G$ have an even degree, $G$ does not have cut-edge</p>\n\n<p>From a) it actually follows that for even $k$, b) is true, thus only case with odd $k$ left to prove.</p>\n", 'ViewCount': '250', 'Title': 'Prove that a $k$-regular bipartite graph with $k \\geq 2$ has no cut-edge', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-30T10:11:29.557', 'LastEditDate': '2013-10-30T10:10:21.863', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8770', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-10-29T10:44:19.740', 'Id': '16537'},63_215:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider the next problem. Given a large oriented graph find its diameter: maximal length over all shortest directed paths between every pair of vertices. Graph is strongly connected. It is allowed to give lower and upper bounds on the answer. Time complexity should be linear or close to it.</p>\n\n<p>Suppose I solved the problem and I want to prove it. Moreover I want the proof can be checked in linear time: graph is large. </p>\n\n<p>Lower bound is easy. Just let me give two vertices on neccessary distance. Upper bound is harder. I can give a vertex and ask to estimate the furthest vertex reachable by forward, and then by backward, edges. Then I sum up these distances and call it upper bound.</p>\n\n<p>The problem that my upper bound doesn't look tight. Can anybody suggest something better?</p>\n", 'ViewCount': '143', 'Title': 'Upper bound on graph diameter. Linear certificate', 'LastActivityDate': '2013-11-01T11:34:39.277', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11114', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-11-01T11:34:39.277', 'FavoriteCount': '2', 'Id': '16617'},63_216:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to generate a random but realistic network topology so I can test the performance of some routing algorithms. I came across Waxman\'s model described in <a href="http://www.huaxiaspace.net/academic/classes/fa00/cse202/project/08Waxman.pdf" rel="nofollow">Routing of Multipoint Connections</a>, which seems pretty simple:</p>\n\n<ol>\n<li>Distribute $N$ nodes randomly across a plane (uniform in x and y).</li>\n<li>For each pair of nodes, generate an edge between them with the probability $ P = \\beta \\exp \\frac{-d}{L\\alpha}$, where $d$ is the euclidean distance between the nodes, $L$ is the maximum distance between two nodes, and $\\alpha$ and $\\beta$ are parameters in the range $(0, 1]$.</li>\n</ol>\n\n<p>I\'ve implemented my current understanding of Waxman\'s algorithm as <a href="http://codepen.io/blendmaster/full/uqibt" rel="nofollow">a simple web-based demo</a>, which visualizes a generated topology from chosen parameters $\\alpha$, $\\beta$, and $N$.</p>\n\n<p>However, I want to be able to generate a <em>connected</em> network topology for \na specific number of nodes. Since Waxman\'s algorithm generates edges probabilistically, I usually end up with disconnected nodes. How do I connect the rest of the nodes to the topology in a way consistent with Waxman\'s algorithm, i.e. simulates a real network topology?</p>\n\n<p>There are plenty of ways to "finish" the topology by connecting the disconnected nodes, but I don\'t know which one is the most compatible with the already-generated edges. Waxman\'s paper doesn\'t seem to mention how disconnected nodes are treated.</p>\n', 'ViewCount': '140', 'Title': 'How to generate a connected random network topology for a specific number of nodes?', 'LastActivityDate': '2013-12-20T19:31:08.647', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11143', 'Tags': '<graphs><computer-networks>', 'CreationDate': '2013-11-03T04:13:49.333', 'FavoriteCount': '1', 'Id': '16664'},63_217:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $T$ be a tree, and there is a weight function on the edges $w:E\\to X$. $(X,\\oplus)$ is a monoid structure.</p>\n\n<p>Define $f(u,v) = \\bigoplus_{i=1}^k w(e_i)$, where $e_1,\\ldots,e_k$ is the unique path from $u$ to $v$.</p>\n\n<p>Can we preprocess the tree, such that we can use linear space (or close to linear space), so we can answer queries $f(u,v)$ in $O(\\mathrm{polylog} (n))$ monoid operations? The problem become more interesting if we allow removing edges and add edge between two vertices in distinct trees.</p>\n\n<p>We can also ask the question on a DAG, with weights from a commutative monoid. We want to preprocess in linear time, and query the result of $f(u,v)= \\sum_{e} w(e)$, where $e$ is in some path from $u$ to $v$, in $O(\\mathrm{polylog} (n))$ time.</p>\n\n<p>If we consider the very special case where the entire graph is just a path, then what we want is a dynamic version of a Fenwick tree. A finger tree can solve the problem in $O(\\log n)$ time.</p>\n', 'ViewCount': '185', 'Title': 'Data structure for finding the sum of edge weights on a path', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-04T19:51:46.153', 'LastEditDate': '2013-11-04T16:22:02.107', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '220', 'Tags': '<data-structures><graphs>', 'CreationDate': '2013-11-04T12:48:28.100', 'FavoriteCount': '1', 'Id': '16703'},63_218:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have found an interesting exercise in my introduction to graphs workbook:</p>\n\n<p>Let $ad(G) = \\frac{2\\vert E(G)\\vert}{\\vert V(G) \\vert}$ and $mad(G) = max\\{ad(H): H\\ is\\ an\\ induced\\ subgraph\\ of\\ G\\}$.</p>\n\n<p>Given a graph $G$ and a number $k \\geq 3$, prove that if $\\chi(G) &gt; k \\wedge mad(G) \\leq k \\Rightarrow \\exists A \\subseteq V(G)$ such that $[A]_{G}$ is $k - regular$.</p>\n\n<p>I believe this can proved by contradiction:</p>\n\n<p>Given a $G$ and $k$ for which the properties hold, we assume that $G$ has no induced subgraph $H$ that is $k - regular$. We then prove that if $\\nexists H$ then at least one of the property is false and thus we contradict ourselves however I can't quite figure out the connection between $H$ and the mentioned properties.</p>\n\n<p>How would you go about solving this?</p>\n", 'ViewCount': '74', 'Title': 'How can I prove that if $\\chi(G) > k \\wedge \\vert\\{ad(H): H\\ is\\ an\\ induced\\ subgraph\\ of\\ G\\}\\vert$ then $G$ has a $k-regular$ induced subgraph?', 'LastActivityDate': '2013-11-05T07:16:43.693', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11183', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-11-04T19:35:20.957', 'Id': '16720'},63_219:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose I have an undirected graph which is stored as an adjacency matrix. The graph contains a single cycle; all other vertices are isolated.</p>\n\n<p>How can I efficiently find the length of the cycle?</p>\n\n<p>The best I've been able to come up with:</p>\n\n<ol>\n<li>Starting at row 0 of the matrix, traverse through rows until an initial <code>1</code> is found, say at row <code>startVertex</code> and column <strong>k</strong>. Increment a counter.</li>\n<li>Search column <strong>k</strong> for its other <code>1</code>, say at row <strong>j</strong>. Increment the counter.</li>\n<li>Search row <strong>j</strong> for its other <code>1</code> value. Increment the counter.</li>\n<li>Repeat steps <strong>2</strong> and <strong>3</strong> until a row or column which matches <code>startVertex</code> is found.</li>\n</ol>\n\n<p>The complexity of this algorithm is $\\mathcal{O}(V^2)$.</p>\n\n<p>Is there a better algorithm out there?</p>\n", 'ViewCount': '49', 'Title': 'Find Cycle Length', 'LastActivityDate': '2013-11-06T01:35:39.257', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1025', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-11-05T23:39:17.893', 'Id': '16754'},63_220:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm playing around with tournaments and currently have the problem that I need to check whether a given subset of the edges of a tournament is transitive (it need not be acyclic). I'm aware that I can always take the transitive closure of the edge set and see whether it terminates without adding a single edge or not, but I was wondering if there might be a simpler way than that.</p>\n\n<p>Note that I'm specifically going for simplicity, not efficiency; the tournaments I want to check are over a maximum of $7$ vertices, so complexity really isn't an issue. I would prefer simple, easy to implement ways. The simplest I could find so far is Floyd-Warshall, but maybe someone knows anything that's simpler still.</p>\n", 'ViewCount': '65', 'Title': 'Simplest way to check edge set for transitivity', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T12:59:44.767', 'LastEditDate': '2013-11-08T12:59:44.767', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16760', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6689', 'Tags': '<algorithms><graphs><transitivity>', 'CreationDate': '2013-11-06T00:54:33.107', 'Id': '16757'},63_221:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am aware of a logarithmic-time algorithm to maintain the connected components of graphs in the Euclidean plane <a href="http://web.cs.swarthmore.edu/~adanner/cs97/s08/pdf/eppstein92maintenance.pdf" rel="nofollow">(D. Eppstein, GF Italiano, R. Tamassia, RE Tarjan, J. Westbrook, and M. Yung. Maintenance of a minimum spanning forest in a dynamic plane graph. <em>J. Algorithms</em>, 13 (1): 33 {54, 1992.).</a></p>\n\n<p>Does anyone know if there is an implementation of this work or if there are other results that are easier to implement?</p>\n', 'ViewCount': '50', 'Title': 'Help for implementing the maintenance of the connected components in the Euclidean plane in logarithmic time', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-06T16:03:25.510', 'LastEditDate': '2013-11-06T16:03:25.510', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11227', 'Tags': '<graph-theory><graphs><computational-geometry>', 'CreationDate': '2013-11-06T14:54:30.473', 'FavoriteCount': '1', 'Id': '16773'},63_222:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '247', 'Title': 'Algorithm to check whether a complete, undirected graph is fullfilling the triangle inequality', 'LastEditDate': '2013-11-08T16:09:55.873', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11258', 'FavoriteCount': '2', 'Body': '<p>I am searching for an algorithm to check whether a complete, undirected graph is fullfilling the triangle inequality( $\\text{weight}(u,v) \\le \\text{weight}(u,w) + \\text{weight}(w,v)$ for all vertices $u, v, w$).</p>\n\n<p>My first naive try was to use an algorithm for solving the all-pairs-shortest-path-problem and compare the result to the vertices connecting two nodes directly.</p>\n\n<p>However, I think this might be overkill. Is there any better way to check?</p>\n\n<p>Thanks a lot.</p>\n', 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-09T03:27:41.780', 'CommentCount': '2', 'AcceptedAnswerId': '16830', 'CreationDate': '2013-11-08T16:04:04.330', 'Id': '16827'},63_223:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a given acyclic graph $G$, a topological sort is an ordering $v_1, \\dots, v_n$ of the vertices such that the arrows in the graph are all directed forward under that ordering.</p>\n\n<p>Question: can all topological orders of a graph $G$ be obtained from a single ordering by iteratively swapping two vertices that are not connected by an edge?</p>\n\n<p>Motivation. In a certain context I am trying to prove that all topological sorts of an acyclic graph are in fact "equivalent". I want to do this by comparing $v_1, \\dots, v, v\', \\dots v_n$ and $v_1, \\dots, v\', v, \\dots v_n$ where there is no edge between $v,v\'$.</p>\n', 'ViewCount': '104', 'Title': 'topological sort equivalence', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-19T11:41:08.957', 'LastEditDate': '2013-11-09T15:23:59.883', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<graph-theory><graphs><sorting>', 'CreationDate': '2013-11-09T14:47:39.720', 'FavoriteCount': '1', 'Id': '16848'},63_224:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been given a graph with n nodes. Now, I have to color every node of this graph by k colors, number from 0 to k-1. Now, there is a rule.</p>\n\n<p>For a node $x$ with adjacent nodes $y_1 , y_2, y_3, y_4,... y_m$, $color(x)=(color(y_1)+color(y_2)+color(y_3)+...+color(y_m)) \\pmod k $</p>\n\n<p>where $color(a)$ indicates a color number from 0 to k-1. I have to find number of ways I can color the whole graph.</p>\n\n<p>My approach to the problem was simple. I was constructing a $n*n$ matrix for n nodes in graph with equations like $col(x)-col(y_1)-col(y_2)-col(y_3)...-col(y_m)$. And trying to find number of all zero rows, which will provide us number of free variable. Is my approach correct?</p>\n', 'ViewCount': '56', 'Title': 'Solving a graph problem by Gaussian elimination', 'LastActivityDate': '2013-11-11T03:05:35.403', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '17903', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7890', 'Tags': '<graphs><linear-algebra><mathematical-programming>', 'CreationDate': '2013-11-10T03:10:23.457', 'Id': '17864'},63_225:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So say we have a bipartite graph G=(X,Y,E). Let\'s make a game out of it.</p>\n\n<p>I go first. I pick a node in X. You go next. You pick a node in Y that is connected by an edge to the node I picked. Next it\'s my turn. I pick another node in X (must be a new one that hasn\'t been used before) that is also connected to the node in Y you just picked. We continue playing in this manner, until someone cannot pick a node (i.e. all edges out of the current node have already been used). When that happens, the person who cannot pick a next node loses.</p>\n\n<p>I\'m supposed to find a polynomial time algorithm to decide which of the two players (you or me) can force a "win" for a given bipartite graph.</p>\n\n<p>I\'m stumped. I\'ve approached this in many different ways, including the following two:</p>\n\n<p>1) 1) each node in the xy "path" played will use two edges, except for the first and last nodes which will only use one edge. Idea: add one new node on each side of the bipartite graph, and connect to all opposite nodes. Then check for a perfect (or maximal) matching twice, removing the edges used in the first perfect (maximal) matching when finding the second one. I don\'t think this really helps us with the problem, though, as there are many different nodes you could visit next given a current node.</p>\n\n<p>2) A second idea was to work with alternating/augmenting paths (as we "zig-zag" between the two sides). I again got stuck since at any given node there are many possible nodes to visit next.</p>\n\n<p>Does anyone have any suggestions for this problem? I\'m thinking it has to do with matching, but I could be wrong.</p>\n\n<p>Thanks in advance!</p>\n', 'ViewCount': '120', 'Title': 'Bipartite Graph Game', 'LastActivityDate': '2013-11-13T08:27:30.500', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '17976', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10680', 'Tags': '<graph-theory><graphs><combinatorics><computer-networks><bipartite-matching>', 'CreationDate': '2013-11-12T22:58:47.500', 'Id': '17974'},63_226:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Is it possible to modify Dijkstra\xb4s algorithm in order to get the longest path from $s$ to $t$ ?.</p>\n\n<blockquote>\n  <p>My intuition says that I\xb4ll need a different algorithm entirely. Finding the longest path is the same as finding the shortest path on a graph with negative weights. However, Dijkstra\u2019s algorithm requires that the weights are positive, so it cannot be modified to calculate the longest path. A better algorithm to use could be: <a href="http://en.wikipedia.org/wiki/Longest_path_problem" rel="nofollow">http://en.wikipedia.org/wiki/Longest_path_problem</a></p>\n</blockquote>\n\n<p>Any idea of how to modify it?</p>\n', 'ViewCount': '1734', 'ClosedDate': '2013-11-17T01:20:19.727', 'Title': 'Is it possible to modify dijkstra algorithm in order to get the longest path?', 'LastActivityDate': '2013-11-14T03:25:44.443', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10610', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs>', 'CreationDate': '2013-11-13T07:40:20.250', 'Id': '17980'},63_227:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I will be given some kind of this graph as in the picture below. I\'ve searched some algorithms but it seams as if it is something impossible for me to figure them out. In fact using <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">Floyd\u2013Warshall algorithm</a> it is kinda of possible, but unfortunately I\'m only allowed to use stacks (instead of matrices). I also looked for <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a> but I could not get the relationship with my problem.<img src="http://i.stack.imgur.com/z6bfG.png" alt="picture"></p>\n\n<p>Clearly my aim is to get all <strong>shortest paths</strong> from one point to another one. As I mentioned I will just output the solution from my <strong>stack</strong> in a vector string. I guess I have to visit each node and what I am most afraid is of getting stacked in a loop or even loosing the track during the search.\nAlso note that this is <strong>not a directed graph</strong>. If  Dijkstra\'s algorithm is applicable here I would be very grateful if anyone of you would guide me and I would really appreciate any help, suggestion, idea or even a vision for not getting stacked in a loop or loosing the track while searching.</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '81', 'Title': 'Finding Shortest Paths of weighted graph using stacks', 'LastActivityDate': '2013-11-16T11:28:27.430', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11406', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-11-16T11:28:27.430', 'Id': '18071'},63_228:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have asked this question in StackOverflow. I was asked to move in here. so here it is:</p>\n\n<p>I need some clarifications and inputts regarding <code>Dijktra\'s algorithm</code> vs <code>breath first search</code> in directed graphs, if these are correct.</p>\n\n<p><code>Dijktra\'s</code> algorithm finds the shortest path from Node <code>A</code> to Node <code>F</code> in a <code>weighted</code> graph regardless of if there is a cycle or not (as long as there are no negative weights)</p>\n\n<p>but for that, All paths from <code>A to all other Nodes in the graph are calculated and we grab the path from</code>A<code>to</code>F<code>by reversing the sequences of nodes in</code>prev`.</p>\n\n<p>BFS: finds the shortest path from <code>Node A</code> to <code>Node F</code> in a non-weighted graph, but if fails if  a cycle detected. </p>\n\n<p>however, <code>BFS</code> just calculates the path from Node A to Node F and not necessarily all path from Node A.\nif Node F is reached early, it just returns the path.<img src="http://i.stack.imgur.com/A0hho.png" alt="enter image description here"></p>\n', 'ViewCount': '216', 'Title': 'Dijktra algorithm vs breath first search for shortest path in graph', 'LastActivityDate': '2013-11-19T22:06:59.357', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11469', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-11-19T02:18:27.230', 'Id': '18138'},63_229:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given N finite subsets of the finite universe set E, it is necessary to find the intersection which contains maxumum number of subsets. Let call this problem MSI (Maximum Subset Intersetion).</p>\n\n<p>Firstly I had thought that it is variation of well-known Maximum Clique Problem where vertices are subsets and edges are relations of intersection, so the classic Bron-Kerbosch algorithm or Tomita et al. algorithm can be easily used. But the k-size clique is certainly not the same that the mutual intesection of k subsets (cause subset A can intersect B, B can intersect C, A can intersect C, but at the same time A, B and C may not have common points of intersection).</p>\n\n<p>Actually the multiple intersections form edges in <strong>hypergraph</strong>, so the main task is to find edge of maximal cardinality.</p>\n\n<p>I found an article by Eduardo C. Xavier <a href="http://www.ic.unicamp.br/~eduardo/publications/ipl12.pdf" rel="nofollow">A Note on a Maximum k-Subset Intersection Problem\n</a> where he proves that the MSI-problem is a variation of Maximum Edge Biclique (MEB) problem which is in turn NP-hard.</p>\n\n<p>My naive solution is to implement branch and bound greedy algorithm (in other words, to adopt Bron-Kerbosch algorithm to this domain).</p>\n\n<p>May be there are already any implementations or acadimic paper on that problem?</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>Actually the exact problem I met in my work is the following:</p>\n\n<p>Suppose that I can run some function which returns the cardinality of one subset or N subsets intersection. The function is time-consuming. I am interested in finding optimal or approximately optimal argorithm to find the intersection of maximum number of subsets (next thing is to find the whole set of such intersections in cardinality decreasing order).\nWorking on element-level is even more costly from the time consumption point of view.</p>\n\n<p>I thought firstly to take cardinalities of all subsets (N operations) and then run Bron-Kerbosh kind of search for subsets sorted by cardinality decreasing order. So I will start with the largest subset, check if it intersects with the 2nd largest subset and so on.</p>\n', 'ViewCount': '134', 'Title': 'Maximum subset intersection problem', 'LastEditorUserId': '10736', 'LastActivityDate': '2013-11-21T23:49:34.870', 'LastEditDate': '2013-11-21T23:49:34.870', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10736', 'Tags': '<graph-theory><graphs><optimization>', 'CreationDate': '2013-11-21T13:58:09.430', 'Id': '18221'},63_230:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am implementing a learner to learn a DAG model $G=\\langle V,E\\rangle$ where $V$ and $E$ represent both variables and dependencies respectively ( similar to Bayesian networks). Each variable $v\\in V$ is associated with possible values (domain) $D_v$ and a function $\\theta_v$.</p>\n\n<p>I assume the learner knows the number of variables $n$ (i.e. vertices) and their possible values (domain). The goal is to find $E$ (dependencies) and $\\theta_v$ for every variable $v$. I also assume there is a target function $c$ exist (the realizable case).</p>\n\n<p>The hypothesis class is defined as the set of consistent hypotheses i.e. $H=\\{h|\\ h(x)=c(x)\\} \\forall x\\in S$ where $S$ is set of examples seen so far. </p>\n\n<p>I am trying to find a way to represent my hypotheses class. Initially, before receiving any example, it contains:</p>\n\n<ol>\n<li>all possible DAGs over $V$.</li>\n<li>all different combinations of $E$ as long as its acyclic.</li>\n<li>For every Graph $G$ generated from (1) and (2),all different function values over $G$. </li>\n</ol>\n\n<p>Beside my naive representation, I do not know how to compute (1) precisely. To put my question in another way, how to represent the hypotheses class over Bayesian networks? </p>\n', 'ViewCount': '63', 'Title': 'How to represent/implement the hypotheses class for a DAG learner', 'LastEditorUserId': '4598', 'LastActivityDate': '2014-01-03T20:51:01.397', 'LastEditDate': '2013-11-21T20:46:51.080', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graphs><machine-learning>', 'CreationDate': '2013-11-21T20:08:17.023', 'FavoriteCount': '1', 'Id': '18239'},63_231:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose we have a graph $H$, where each vertex represents a spanning tree of another graph $G$.</p>\n\n<p>We create an edge between 2 vertices in $H$ if $ST_1$ (spanning tree) contains exactly one edge not in $ST_2$ (and vice versa).</p>\n\n<p>How do we show that $H$ is connected?</p>\n', 'ViewCount': '60', 'Title': 'Showing that graph of spanning trees are connected', 'LastEditorUserId': '9863', 'LastActivityDate': '2013-11-25T14:57:33.637', 'LastEditDate': '2013-11-25T14:36:00.353', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11608', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-11-25T13:29:31.623', 'Id': '18325'},63_232:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I tried to solve the above NP-completeness exercise by making a bipartite graph from a general one (undirected) by inserting a vertice in the middle of every edge of the first (general) graph. This generates problems as suggested here: <a href="http://cs.stackexchange.com/questions/1527/finding-the-flaw-in-a-reduction-from-hamiltonian-cycle-to-hamiltonian-cycle-on-b">Finding the flaw in a reduction from Hamiltonian cycle to Hamiltonian cycle on bipartitie graphs</a> \nAnyone can give a hint on how to make a bipartite graph from a general one without using the above method and how the hamiltonian property can be passed to it?</p>\n', 'ViewCount': '877', 'Title': 'Proof that the existence of a Hamilton Path in a bipartite graph is NP-complete', 'LastActivityDate': '2013-11-30T00:12:54.147', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '18482', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11617', 'Tags': '<graph-theory><graphs><np-complete>', 'CreationDate': '2013-11-25T21:13:27.677', 'Id': '18335'},63_233:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been trying to implement an algorithm to detect cycles (probably how many of them) in a <code>directed and undirected graph</code>. That is the code should apply for both directed and undirected graphs.</p>\n\n<p>Using <code>DFS or topological sort</code> is mostly recommended in various posts. But largely, everything is addressed for undirected graph. </p>\n\n<p><a href="http://pages.cs.wisc.edu/~vernon/cs367/notes/13.GRAPH.html" rel="nofollow">This link</a> describes one approach for cycle detection. To my understanding this works for directed graphs.</p>\n\n<p><a href="http://algs4.cs.princeton.edu/41undirected/CC.java.html" rel="nofollow">This link</a> has the code for cycle detection in undirected graphs. but I fail to understand how it ignores the back edge. That is it must ignore any cycles with two nodes, say D to C and C to D.\nwhich means it must remember it parent as the DFS recurses. But the code does not seem take care of that.</p>\n\n<p>Any suggestions welcome..</p>\n\n<p><img src="http://i.stack.imgur.com/YA7NX.png" alt="enter image description here"></p>\n', 'ViewCount': '120', 'Title': 'single algorithm to work on both directed and undirected graph to detect cycles?', 'LastActivityDate': '2013-11-27T16:11:53.180', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11469', 'Tags': '<algorithms><graphs><recursion>', 'CreationDate': '2013-11-26T00:35:32.907', 'Id': '18342'},63_234:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to come up with a good algorithm to merge a set of Trails. I have described what is meant by a Trail and the conditions which\ndetermine if the merge is good or bad.</p>\n\n<p><strong>Trail - Linear sequence of n nodes obtained by traversing a graph.</strong></p>\n\n<p>E.g., </p>\n\n<pre><code>A--B--C--D--E--F\nB--C--D--E\nP--Q--R--S--T\nD--E--F--G--H\n</code></pre>\n\n<p>Each Trail has a maximum capacity of 500. There is a cost of 2 associated with each Trail.</p>\n\n<p>2 Trails can be merged if they overlap and their combined capacity is &lt; 500</p>\n\n<hr>\n\n<p>Examples of merging</p>\n\n<p>Format below is Trail followed by capacity and cost in brackets.</p>\n\n<p>Example 1</p>\n\n<pre><code>A--B--C--D--E--F : 200(2)\nA--B--C : 200(2)\nD--E--F : 200(2)\n</code></pre>\n\n<p>Total cost = 6</p>\n\n<p>We can merge A--B--C--D--E--F and A--B--C because they overlap and their combined capacity 400 &lt; 500. </p>\n\n<p>Similarly we can merge A--B--C--D--E--F and D--E--F. We end up with</p>\n\n<pre><code>A--B--C : 400(2)\nD--E--F : 400(2)\n</code></pre>\n\n<p>Total cost  = 4\nThis is a good merge and we have reduced total cost.</p>\n\n<hr>\n\n<p>Example 2</p>\n\n<pre><code>A--B--C--D--E--F : 200(2)\nB--C--D--E : 200(2)\n</code></pre>\n\n<p>Total cost = 4</p>\n\n<p>Merging the Trails we have</p>\n\n<pre><code>A--B : 200(2)\nB--C--D--E : 400(2)\nE--F : 200(2)\n</code></pre>\n\n<p>Total cost = 6\nThis merge is not good because it increase the cost.</p>\n\n<p>We can have merges that keep the cost the same. They are also acceptable</p>\n\n<p>Currently I have a simple 2 loop solution. The loops iterate over a sorted(in decreasing Trail length) list and check one by one if merges can be done.</p>\n\n<p>I am not aware if this falls into any known algorithm category. If anyone can point me to them or give an idea for a better solution, that will be great.</p>\n', 'ViewCount': '34', 'Title': 'Efficient way to merge a set of Trails (sequence of nodes in a Graph)', 'LastActivityDate': '2013-11-26T10:38:05.267', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'OwnerDisplayName': 'user3030022', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><graph-traversal>', 'CreationDate': '2013-11-25T14:39:45.633', 'Id': '18374'},63_235:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>According to CLRS, each iteration of the outermost loop (on $k$) makes a new copy of the adjacency matrix. Is it safe not to copy the matrix on every iteration?</p>\n\n<p>What I mean is, according to CLRS:</p>\n\n<p>$d_{ij}^K = \\min(d_{ij}^{K-1}, d_{ik}^{K-1} + d_{kj}^{K-1})$</p>\n\n<p>Is the following possible?</p>\n\n<p>$d_{ij} = \\min(d_{ij}, d_{ik} + d_{kj})$</p>\n\n<p>I have tried not copying the matrix, and got the same result before as the one which makes a copy after each iteration, but did I just get lucky?</p>\n', 'ViewCount': '82', 'Title': 'Can Floyd-Warshall be used to solve an APSP problem without copying the matrix?', 'LastEditorUserId': '11637', 'LastActivityDate': '2013-11-26T18:09:21.957', 'LastEditDate': '2013-11-26T16:10:04.703', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18392', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11637', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-11-26T15:49:45.417', 'Id': '18389'},63_236:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m looking for a way to position nodes on a 2-dimensional plane in such a way that the distances between the nodes, which are entered exogenously, are represented visually in a way that as good as possible communicates the logical distance between those nodes. Basically, I have a set of nodes A, B, C etc. and between some of them I have a distance: A is 10 from B, 20 from C etc. Some nodes are not connected at all. The distances are not internally geometrically consistent: A may be 10 from B, and 10 from C, but B and C may be 100 from each other.</p>\n\n<p>I want to do this in a way that is \'stable\' - i.e. generates the exact same layout each time the algorithm is run. Multi-dimensional scaling algorithms seem to be the way to go about this, but I\'m having a hard time finding practical properties of the various MDS algorithms that exist, and the one I\'ve tried is based on iterating from a random start position and therefore doesn\'t generate the same result every time. It also cannot handle not-connected nodes, afaik.</p>\n\n<p>The practical application for this, and more detail on what I\'ve tried, is described in this question: <a href="http://stackoverflow.com/questions/20263829/stable-multi-dimensional-scaling-algorithm">http://stackoverflow.com/questions/20263829/stable-multi-dimensional-scaling-algorithm</a></p>\n\n<p>(Original post:\nI\'m not sure what the etiquette is on this (repost question here or just link), but I asked a question on Stackoverflow that I was advised might fit better here. The question is here: <a href="http://stackoverflow.com/questions/20263829/stable-multi-dimensional-scaling-algorithm">http://stackoverflow.com/questions/20263829/stable-multi-dimensional-scaling-algorithm</a> . I can repost here if that is the custom, but I thought I\'d err on the side of fewest fragmentation and duplication. Thanks.)</p>\n', 'ViewCount': '77', 'Title': "'Stable' multi-dimensional scaling algorithm", 'LastEditorUserId': '11681', 'LastActivityDate': '2013-11-28T13:55:38.880', 'LastEditDate': '2013-11-28T13:55:38.880', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11681', 'Tags': '<algorithms><graphs>', 'CreationDate': '2013-11-28T12:37:03.300', 'Id': '18439'},63_237:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '110', 'Title': 'Peer grading design - choosing a graph, to get accurate rankings/ratings', 'LastEditDate': '2013-12-02T23:49:34.417', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11721', 'FavoriteCount': '3', 'Body': "<p><strong>Background.</strong> I am writing some code for semi-automated grading, using peer grading as part of the grading process. Students are given pairs of essays at a time, and the students have a slider to choose which is better and how much better it is.  e.g., the slider might look something like this:</p>\n\n<p><code>A---X-B</code></p>\n\n<p>Based on the results of the peer grading, essays are ranked and the teacher will then grade the top X% and bottom X% and scores for all essays will be automatically calculated based on this.  I have already come up with methods for doing this ranking/scoring process; that part works well.</p>\n\n<p><strong>My question.</strong> How should I select which pairs of essays to give to students?</p>\n\n<p>Simulations suggest we need an essay to be peer-graded at least 3 times, to get an accurate ranking.  Thus, each essay should appear in at least 3 of the pairs that are presented for peer grading.</p>\n\n<p>We can think of this as a graph problem.  Think of the essays as nodes.  Each edge represents a pair of essays that are presented during the peer grading process.  The accuracy results above suggest that the degree of each node (or of most nodes) should be at least 3.  What sort of graph should I use?  How should I generate the graph to be used during peer grading?</p>\n\n<p>One challenge is that if you have clusters in the graph, this will skew the peer-gradings.  For example, we wouldn't want to have high-quality essays peer-graded mostly against high-quality essays, because that would skew the results of the peer grading.</p>\n\n<p>What would you recommend?</p>\n\n<p>I think this problem could be modelled with a undirected graph using something like the following:</p>\n\n<ul>\n<li>Start by taking the node with the least degree and link it with the next least</li>\n<li>Continue until your average degree is at least 3</li>\n<li>Maximise node connectivity</li>\n<li>Minimise number of cliques</li>\n</ul>\n\n<p>Is this a good approach? If not what would you recommend instead?</p>\n", 'Tags': '<algorithms><graphs><modelling>', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-02T23:49:34.417', 'CommentCount': '5', 'AcceptedAnswerId': '18494', 'CreationDate': '2013-11-30T22:26:52.017', 'Id': '18493'},63_238:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an ensemble of points in 3D space, represented by their coordinates $\\mathbf{c_i}\\equiv(x_i,y_i,z_i)^\\top$ . I need to calculate</p>\n\n<ul>\n<li>the distance between all these points: $\\quad\\forall i,j\\quad d_{ij} \\equiv |\\mathbf{d_{ij}}|\\equiv |\\mathbf{c_j}-\\mathbf{c_i}|$</li>\n<li>the scalar product between all distances that share a common coordinate. $\\quad\\forall i,j,k\\quad \\mathbf{d_{ij}}\\cdot\\mathbf{d_{ik}}$</li>\n</ul>\n\n<p>What is the fastest way to do this on a single thread? Is Fourier space going to be of any use? Can it be parallelized to make it even faster? If approximations are proposed, they should come with an error bound.</p>\n', 'ViewCount': '26', 'Title': 'fastest way to compute scalar product of an ensemble of vectors', 'LastActivityDate': '2013-12-01T01:22:24.163', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11724', 'Tags': '<algorithms><graphs><parallel-computing><fourier-transform>', 'CreationDate': '2013-12-01T01:22:24.163', 'Id': '18497'},63_239:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to modify the Dijkstra's algorithm to get the shortest path in a directed graph and get the one with the least amount of edges if there are equal paths. </p>\n\n<p>I am thinking to add another data field to count the number of edges from start and compare them in same way as weights. Would that work?</p>\n", 'ViewCount': '143', 'Title': u'Modifying Dijkstra\u2019s algorithm to favor the path with least amount of edges', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-02T04:28:20.353', 'LastEditDate': '2013-12-02T04:28:20.353', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18516', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '11747', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-12-02T00:29:23.490', 'Id': '18515'},63_240:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '137', 'Title': 'Widest path algorithm steps', 'LastEditDate': '2013-12-02T06:02:56.707', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11747', 'FavoriteCount': '1', 'Body': u'<p>I need to compute the bottleneck shortest paths from s to all vertices of a graph by modifying the Dijkstra\u2019s algorithm. I found this explanation on Wikipedia(<a href="http://en.wikipedia.org/wiki/Widest_path_problem" rel="nofollow" title="Link">Link to Wikipedia</a>) but I would appreciate if you can elaborate it a bit for me.</p>\n\n<blockquote>\n  <p>If the edges are sorted by their weights, then a modified version of\n  Dijkstra\'s algorithm can compute the bottlenecks between a designated\n  start vertex and every other vertex in the graph, in linear time. The\n  key idea behind the speedup over a conventional version of Dijkstra\'s\n  algorithm is that the sequence of bottleneck distances to each vertex,\n  in the order that the vertices are considered by this algorithm, is a\n  monotonic subsequence of the sorted sequence of edge weights;\n  therefore, the priority queue of Dijkstra\'s algorithm can be replaced\n  by an array indexed by the numbers from 1 to m (the number of edges in\n  the graph), where array cell i contains the vertices whose bottleneck\n  distance is the weight of the edge with position i in the sorted\n  order. This method allows the widest path problem to be solved as\n  quickly as sorting; for instance, if the edge weights are represented\n  as integers, then the time bounds for integer sorting a list of m\n  integers would apply also to this problem</p>\n</blockquote>\n\n<p>So I need to sort my vertex by weight starting from A? I would appreciate if you can explain me the steps in this algorithm. </p>\n\n<p>Thanks</p>\n', 'ClosedDate': '2014-01-19T02:13:52.897', 'Tags': '<algorithms><graph-theory><graphs>', 'LastEditorUserId': '11747', 'LastActivityDate': '2013-12-02T06:09:22.450', 'CommentCount': '4', 'AcceptedAnswerId': '18527', 'CreationDate': '2013-12-02T03:04:42.707', 'Id': '18522'},63_241:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I can see from <a href="http://math.stackexchange.com/questions/421233/turans-theorem-clique-free-graph-and-minimum-independent-set-size">this</a> question that a $K_{r + 1}$-free graph with $n$ vertices and $e$ edges contains an independent set of order at least\n$$\\frac{n}{2e/n + 1} \\tag{1} $$\nSince for a $C_{n}$/$P_{n}$ we know how many edges it contains it is easy to determine (1).</p>\n\n<p>However, are there any particularities of cycle graphs and path graphs that would allow me, for such a graph $G$, to determine exactly $\\min\\{\\mathopen|A\\mathclose| : A\\text{ is a maximal independent set of } G\\}$, i.e. the minimum number of vertices that a <a href="http://en.wikipedia.org/wiki/Maximal_independent_set" rel="nofollow">maximal independent set</a> of $G$ must contain.</p>\n', 'ViewCount': '56', 'Title': 'On the minimum order of a maximal independent set in cycle graphs and path graphs', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-02T18:43:48.307', 'LastEditDate': '2013-12-02T17:41:33.393', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18544', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11184', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-12-02T14:26:28.537', 'Id': '18535'},63_242:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What type of algorithm would you suggest me to use for this problem? I want to implement an algorithm that minimize the total distance in a graph (TSP) but for only X nodes. Also, we can go as many times we want on every vertices and/or edges. Let\'s say, on my graph, that I want the minimum distance for visiting every blue node. What algorithm and heuristic would you recommand me? An approximation running in reasonable time would be acceptable.</p>\n\n<p>For this example, this is an undirected graph, the vertices are points in the plane and the cost of an edge is the distance between its endpoints.</p>\n\n<p><img src="http://i.imgur.com/YheHQPT.jpg" alt="graph"></p>\n', 'ViewCount': '74', 'Title': 'Algorithm to use for a TSP variant', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-12-04T00:26:11.793', 'LastEditDate': '2013-12-04T00:26:11.793', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18593', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11797', 'Tags': '<algorithms><graphs><heuristics><traveling-salesman>', 'CreationDate': '2013-12-03T23:17:30.113', 'Id': '18589'},63_243:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am working on my thesis which involves using ant based techniques for graph clustering. I am testing the algorithm currently and I was wondering if there is a way that I can visualize the clusters of a given graph.</p>\n\n<p>In this case, I have the graph as a file and another file corresponding to the clustering where each node is given its cluster. Is there a software using which I can visualize this graph where nodes belonging to the same cluster have like the same color or something?</p>\n\n<p>The graph is represented as an edge list, or in the ".net" format or Graph Modelling Language ".gml" format. I know there are a lot of programs out there for networks such as gephi, graphviz, networkx, pajek etc but I don\'t know how to do this. Any help/ideas would be greatly appreciated!</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '84', 'Title': 'Visualize Graph Clusters', 'LastActivityDate': '2013-12-04T18:06:46.093', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18601', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5020', 'Tags': '<graphs><cluster>', 'CreationDate': '2013-12-04T03:37:08.370', 'FavoriteCount': '2', 'Id': '18596'},63_244:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was given a graph problem with 3 different questions and 1 set of answers. The problem is described below. The problem that I'm having is that it seems to me that the answer to all the questions is the same. I keep trying to find a caveat but I don't see one. What am I missing?</p>\n\n<p>Here is the problem</p>\n\n<p>Undirected graph $G$. $n$ - number of vertices. $m$ - number of edges. $d$ - maximum degree of a graph. </p>\n\n<ol>\n<li>The maximum clique size of $G$ is no larger than </li>\n<li>The minimum vertex cover size of $G$ is no larger than</li>\n<li>The maximum independent set size of $\\overline{G}$, the complement of $G$, is no larger than</li>\n</ol>\n\n<p>Set of answers</p>\n\n<ul>\n<li>(a) $d+1$ </li>\n<li>(b) $n$</li>\n<li>(c) $n-1$</li>\n<li>(d) $n/2$</li>\n<li>(e) $d$</li>\n<li>(f) $n-d$</li>\n</ul>\n\n<p>It looks to me that the answer to every problem is (b) $n$, because</p>\n\n<ol>\n<li>Clique cannot have more vertices than there are in a graph</li>\n<li>Vertex cover cannot be larger than the number of vertices in a graph</li>\n<li>Maximum independent set cannot be larger than the number of vertices in a graph. </li>\n</ol>\n\n<p>I feel like I'm missing something, because the answers seem too obvious. </p>\n\n<p>Any help is appreciated</p>\n", 'ViewCount': '122', 'Title': 'clique, independent set, and minimum vertex cover', 'LastEditorUserId': '10511', 'LastActivityDate': '2013-12-06T22:55:56.513', 'LastEditDate': '2013-12-06T22:55:56.513', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-12-06T17:57:56.600', 'FavoriteCount': '0', 'Id': '18689'},63_245:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $ G=(V,E) $ be a directed graph with a real weight function $w$ defined on the edges and $ a,b \\in V$. Let $\\alpha$ denote the minimal weight of all paths from $a$ to $b$ and $\\beta$ denote the minimal weight of all paths from $b$ to $a$. How do you find two paths $l_1,l_2$  such that:</p>\n\n<ol>\n<li>$l_1=(a,v_1,..,v_n,b)$</li>\n<li>$l_2=(b,u_1,..,u_m,a)$</li>\n<li>$w(l_1) + w(l_2)\\leq 1.1(\\alpha + \\beta)$</li>\n<li>From all the paths holding the above, bring to minimum the sum of weights on the edges $e=(u,v)\\in l_1$ such that $(v,u)\\in l_2$</li>\n</ol>\n\n<p>Less formally, I want to find a path starting at $a$ ending with $b$ and returning to $a$ such that the path is not too long (at most 10% longer than the optimal solution) and tries to use as much as different roads as possible (if it used some road $(x,y)$ when going from $a$ to $b$ , it would try to avoid the road $(y,x)$ when going back to $a$)</p>\n', 'ViewCount': '88', 'Title': 'Path finding under constraints', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T19:10:15.007', 'LastEditDate': '2014-01-07T10:00:27.157', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-12-07T22:12:38.000', 'Id': '18725'},63_246:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>According to Wikipedia, the <a href="http://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29" rel="nofollow">Independent Set</a> problem is a special case of the <a href="http://en.wikipedia.org/wiki/Set_packing" rel="nofollow">Set Packing</a> problem. But, it seems to me that these problems are equivalent.</p>\n\n<p>The <a href="http://en.wikipedia.org/wiki/Independent_set_%28graph_theory%29" rel="nofollow">Independent Set</a> search problem is: given a graph $G(V,E)$ and an integer $n$, find $n$ vertices no two of which are adjacent.</p>\n\n<p>The <a href="http://en.wikipedia.org/wiki/Set_packing" rel="nofollow">Set Packing</a> search problem is: given a finite collection $C$ of finite sets and an integer $n$, find $n$ sets that are pairwise disjoint.</p>\n\n<p>I think they are equivalent based on the following bidirectional reduction:</p>\n\n<p>&rarr;: Given an independent set problem on a graph $G(V,E)$, create a collection of $C$ of sets, where for each vertex $v \\in V$ there is a set $S_v \\in C$ containing all edges adjacent to $v$. Now, every set packing in $C$ corresponds to a set of vertices no two of which have an edge in common, i.e., this is an independent set in $G$ of the same size.</p>\n\n<p>&larr;: Given a set packing problem on a collection $C$, create a graph $G(V,E)$ where for every set $S \\in C$ there is a vertex $v_S \\in V$, and there is an edge between $v_{S_1}$ and $v_{S_2}$ iff the sets $S_1$ and $S_2$ intersect. Now, every independent vertex set in $G$ corresponds to a set of sets from $C$ no two of which intersect, i.e., this is a set packing in $C$ of the same size.</p>\n\n<p>My question is: is my reduction correct? If so, are these problem equivalent? Is it possible to use approximation algorithms for one problem on the other problem?</p>\n', 'ViewCount': '145', 'Title': 'Equivalence of independent set and set packing', 'LastActivityDate': '2013-12-08T11:18:43.767', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18741', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<algorithms><graphs><sets><packing>', 'CreationDate': '2013-12-08T08:50:02.567', 'FavoriteCount': '1', 'Id': '18736'},63_247:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a weighted digraph $G=V,E$, and a weight function, $d(u,v)$, one can normally use Dijkstra's algorithm to obtain the shortest path. What I am interested in, is how to obtain the $2^{nd}$-shortest path, the $3^{rd}$-shortest, and so on.</p>\n\n<p>Questions:</p>\n\n<blockquote>\n  <p>Is there an efficient algorithm to get the i-th-most-shortest-path between two nodes in a weighted graph?</p>\n  \n  <p>Is there an efficient algorithm to get the k-most-shortest-paths between two nodes in a weighted graph?</p>\n</blockquote>\n\n<p>An answer to either one is OK, though I wonder if an answer to the second question can be done more efficiently than $k$ calls to an answer to the first question.</p>\n", 'ViewCount': '67', 'Title': 'k-shortest paths', 'LastActivityDate': '2013-12-11T00:25:44.833', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal>', 'CreationDate': '2013-12-11T00:25:44.833', 'FavoriteCount': '1', 'Id': '18849'},63_248:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $A$ be a set of integers: $A=\\left \\{ x_1, x_2...x_n \\mid 10&lt;x_i&lt;100\\right \\}$</p>\n\n<p>A <em>valid permutation</em> $x_{i_1}x_{i_2}...x_{i_n}$ is a permutation that holds the following property:</p>\n\n<p>For every adjacent numbers $x_{i_j}x_{i_{j+1}}$, the unit's digit of $x_{i_j}$ is equal to the ten's digit of $x_{i_{j+1}}$.</p>\n\n<p>For example, if $A=\\left\\{ 24,87,48,12 \\right \\}$ then $92-24-48-87$ is a valid permutation, whereas if $A=\\left\\{ 46,83,58 \\right \\}$, there is no valid permutation of $A$.</p>\n\n<p>Now, given such a set $A$, I need to find an algorithm that prints a valid permutation if such exist, otherwise, it returns that there is no valid permutation of $A$.</p>\n\n<p>I need to solve it using a graph, with a reasonable complexity, and I've been instructed to use some of the Eulerian path's properties, so it might play some role in getting the solution to that problem.</p>\n\n<p>This is what I have in mind so far:</p>\n\n<p>Setting a directed graph $G=(V,E)$ with: $V=\\left\\{ x_1, x_2...x_n\\right \\}$, and $E$ will contain all the arcs $(x_{i_j}, x_{i_{j+1}})$ s.t. $x_{i_j} x_{i_{j+1}}$ is valid (i.e the unit's digit of $x_{i_j}$ is equal to the ten's digit of $x_{i_{j+1}}$).</p>\n\n<p>Now, if a valid permutation of $A$ exist, there is a path in $G$ that travel through every vertex only once.</p>\n\n<p>There are two things that troubles me with this thought. First of all, it has nothing to do with Eulerian path, or Eulerian graph, or Eulerian anything, which makes me believe I'm way off target here. Second, the complexity of such algorithm is a nightmare: creating $G$ alone is $O(|V|^2)$, but that's nothing compared to finding <strong>some</strong> path in $G$ that traverse through <strong>all</strong> vertices only once, considering that I can't determine at which vertex to start the search.</p>\n\n<p>Does anyone have an idea on how to approach this problem? Are there any observations I fail to see? Maybe searching the graph differently, or maybe even setting the graph in some other configuration?</p>\n", 'ViewCount': '85', 'Title': 'Finding valid permutation using a graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-20T10:48:55.790', 'LastEditDate': '2013-12-20T10:48:55.790', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18886', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<graphs><eulerian-paths>', 'CreationDate': '2013-12-11T16:55:36.880', 'Id': '18883'},63_249:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For my homework I have a problem that I can't solve and it makes me wonder about 2 different MST:</p>\n\n<blockquote>\n  <p>Let $G=(V,E)$ be a graph that has a minimum spanning tree $T$.</p>\n  \n  <p>I want to find another minimum spanning tree $T'$ that has at least 1 different edge $e'$\n  such that the weight of $e'$ is differ from any weight of edges in $T$.</p>\n</blockquote>\n\n<p>If $T'$ doesn't exist I can claim that every 2 different MST must have the same weight for each edge. </p>\n\n<p>My intuition says that this claim is wrong but on the other hand I can't find example of $T'$ to contradict this claim.</p>\n", 'ViewCount': '72', 'Title': 'Find a diffrent minimal spanning tree for a graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-19T10:57:54.237', 'LastEditDate': '2013-12-19T10:57:54.237', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19116', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9292', 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-12-16T17:31:17.433', 'Id': '19049'},63_250:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a problem and I guess it NP-hard, but I cannot prove it.</p>\n\n<p>Here is a layer graph, where layer 0 is the hignest layer and layer L the lowest.</p>\n\n<p>there are some directed edge between layers, where an edge (A, B) indicates that node A can [cover] node B. And when A can cover B, every node on any path from A to B can cover B, B can cover itself.</p>\n\n<p>Finally here comes a set of node S. I need to choose another set of node ANS, and ensure that for each node q in S, there exists a node p in ANS and p covers q.</p>\n\n<p>For every node there is a cost, and I need to make the total cost of set ANS minimal.</p>\n\n<p>Is this a NP-hard problem? I think so but I cannot prove it. </p>\n\n<p>Could you help me?</p>\n\n<p>Thank you very much.</p>\n', 'ViewCount': '142', 'Title': 'Is this NP-hard? I cannot prove it.', 'LastActivityDate': '2013-12-16T20:33:03.003', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '9', 'OwnerDisplayName': 'qin.sun', 'PostTypeId': '1', 'OwnerUserId': '12307', 'Tags': '<graphs><np>', 'CreationDate': '2013-12-16T03:32:05.013', 'Id': '19051'},63_251:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am working on a special case of the longest path problem. For a cyclic directed graph $G=(V, E)$, where the edge-weights are probability values (i.e., $P(\\_) = w(s, q)$ with $s,q \\in V$), my aim is to find the least 'probable' path between two vertices. </p>\n\n<p>My initial approach is to generate an graph $G'$ where the weights are the complementary probabilities $1- w(s, q)$ (with strictly positive values), and compute Dijkstra's shortest path on $G'$. Is this reasoning sound? Or am I getting myself into an NP-hard disaster?</p>\n", 'ViewCount': '141', 'Title': 'Find least probable path in graph', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T02:10:13.287', 'LastEditDate': '2014-01-19T02:10:13.287', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19217', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12300', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-12-23T12:08:42.880', 'Id': '19207'},63_252:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given simple, udirected and connected graph with $n$ verticies. Every edge in this graph has some weight. I have to find (in polynomial time) a set of edges such that :  </p>\n\n<p>1.every simple cycle in graph contains at least one edge from this set<br>\n2.sum of weights of these edges is the least possible  </p>\n\n<p>I have derived the following algorithm to solve this problem.  </p>\n\n<p>First, apply DFS algorithm, starting from 1. vertex, to get all back edges. It is known that every simple cycle in this graph will contain at least one back edge, so 1. condition will be satisfied. To satisfy the 2. condition, we must apply DFS algorithm starting from 2. vertex, 3. vertex .... n. vertex, to get different sets of back edges, that all satisfy 1. condition, and choose set with the least sum of weights.  </p>\n\n<p>My question is will this algorithm give the right answer ? And if it won't, then why?  </p>\n\n<p>I have some doubdts about it, for example, is the set of back edges, given by DFS algorithm, is least possible to satisfy the condition that every simple cycle in the graph contain at least one edge from this set? For example, DFS has given me that $BE =  \\left\\{ e_1, e_2, e_3, e_4 \\right\\}$ are the back edges of graph. So every simple cycyle will contain at least one edge from $BE$. But, is it possible that we can throw out, say, $e_3$ and still every simple cycle in graph will contain at least one edge from $\\left\\{ e_1, e_2, e_4 \\right\\}$ ?</p>\n", 'ViewCount': '86', 'Title': 'Finding edges with minimal weight sum, such that every simple cycle contain at least one edge', 'LastActivityDate': '2013-12-24T15:46:23.037', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19251', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11315', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-12-24T10:19:44.943', 'Id': '19237'},63_253:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose I want to run Dijkstra's algorithm on a graph whose edge weights are integers in the\nrange 0, ..., W, where W is a relatively small number.\nHow can I modify that algorithm so that it takes time just O((|V| + |E|) logW) and relatively easy implement that in C/C++?</p>\n", 'ViewCount': '259', 'Title': "Dijkstra's algorithm for edge weights in range 0, ..., W", 'LastActivityDate': '2013-12-25T17:06:47.797', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12351', 'Tags': '<algorithms><algorithm-analysis><data-structures><shortest-path><weighted-graphs>', 'CreationDate': '2013-12-24T16:15:19.157', 'Id': '19252'},63_254:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two sets A and B of sizes |A| = n and |B| = m, where m >= n.\nThere are edges from set A to set B.\nI need to find the <code>number</code> of matchings where all of vertices in set A have been matched with one vertex in set B.\nIs it possible to caclulate this quantity ?</p>\n\n<p>(I have very little knowledge of Graph Thory and Bipartite Matching or how it is computed)</p>\n', 'ViewCount': '38', 'Title': 'Number of Matchings in a Bipartite', 'LastActivityDate': '2013-12-25T14:20:27.127', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19276', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graphs><combinatorics><bipartite-matching><matching>', 'CreationDate': '2013-12-25T14:06:18.887', 'Id': '19275'},63_255:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Hi I'm trying to prove the following proposition:</p>\n\n<hr>\n\n<p>Given a network $G,s,t,\\omega$ where $\\omega$ is the capacity, create a minimal cut cut  ${S=\\left\\{ (s,v)\\in E_{G_{r\\_max}}\\right\\} }$ where $G_{r\\_max}$  is graph representing the the residual network(meaning we take the group of all vertices that are reachable from s in $G_{r\\_max}$). So that the cut is $\\left(S,V\\backslash S\\right)$.</p>\n\n<p>Given two maximal flows $f_1\\neq f_2$ prove that $\\left(S_1,V\\backslash S_1\\right)=\\left(S_2,V\\backslash S_2\\right)$ (which are defined in the above mentioned form for each maximal flow).</p>\n\n<hr>\n\n<p>I've tried proving by assuming the contrary and saying that $S_1 $ is not subset of $S_2$.\nTried to say that this leads to $\\exists \\ v\\in S_1 \\ \\ \\mbox{s.t} \\ \\ v\\notin S_2$.\nTried looking at the intersection and union of these groups but to no avail.</p>\n\n<p>I'd appreciate some guidance\\explanation as to how best prove this claim.</p>\n", 'ViewCount': '77', 'Title': 'Prove that every maximal flow yields the same minimal cut', 'LastEditorUserId': '8709', 'LastActivityDate': '2014-01-01T20:19:13.333', 'LastEditDate': '2014-01-01T20:19:13.333', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8709', 'Tags': '<graphs><network-flow>', 'CreationDate': '2014-01-01T18:34:05.833', 'Id': '19436'},63_256:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a digraph $D = (V, A)$ and $m \\in \\mathbb{N}$, the question is is there a subset $A' \\subseteq A$, such that $\\lvert A' \\rvert \\geq m$ and $d_{D'}^+(u) \\leq d_{D'}^-(v)$ holds for every arc $(u, v) \\in A'$ in the subgraph $D' = (V, A')$, i.e. the out-degree of $u$ is not larger than the in-degree of $v$? Note that the degree constraints should hold in the subgraph $D'$.</p>\n\n<p>This seems like a straight-forward problem, alas I am unable to connect it to some more familiar graph problem. I am mostly interested in its complexity.</p>\n", 'ViewCount': '85', 'Title': 'Digraph problem relating in- and out-degrees', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-04T04:46:54.440', 'LastEditDate': '2014-01-02T15:51:52.913', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12522', 'Tags': '<graphs><time-complexity><decision-problem>', 'CreationDate': '2014-01-01T23:59:45.053', 'Id': '19443'},63_257:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a Bayesian Network DAG $G$, we can transform it into a junction tree $T_G$ by performing two steps: </p>\n\n<ol>\n<li>moralisation (connect variables that have the same child, drop directions)</li>\n<li>triangulation (fill-in edges) i.e chordal graphs. </li>\n</ol>\n\n<p>Are there known conditions/assumptions over $G$ under which for any junction tree $T_G$, $T_G$ will have tree width at most $k$? In other words, bounded treewidth for the triangulated graph of $G$? </p>\n', 'ViewCount': '47', 'ClosedDate': '2014-01-05T15:21:05.217', 'Title': 'How to go from a DAG model to bounded treewidth?', 'LastEditorUserId': '4598', 'LastActivityDate': '2014-01-03T00:36:05.477', 'LastEditDate': '2014-01-03T00:36:05.477', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graphs><trees>', 'CreationDate': '2014-01-03T00:15:21.217', 'Id': '19467'},63_258:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In the last 2 paragraphs of the paper about Hopcroft\u2013Karp algorithm to find the maximum cardinality matching in bipartite graph:</p>\n\n<blockquote>\n  <p><a href="https://dl.dropboxusercontent.com/u/64823035/04569670.pdf" rel="nofollow">https://dl.dropboxusercontent.com/u/64823035/04569670.pdf</a></p>\n  \n  <p>The execution time of a phase is O(m+n), where m is the number of\n  edges in G, and n is the number of vertices. Hence the execution time\n  of the entire algorithm is O((m+n)s), where s is the cardinality of a\n  maximum matching.</p>\n  \n  <p>If G has n vertices then m &lt;= n^2 / 4 and s &lt; n / 2 so that the\n  execution time is bounded by O(n^(5/2)).</p>\n</blockquote>\n\n<p>I don\'t understand given:</p>\n\n<pre><code>m &lt;= n^2 / 4\ns &lt;= n / 2\n</code></pre>\n\n<p>why they concluded:</p>\n\n<pre><code>O((m+n)s) = O(n^(5/2))\n</code></pre>\n\n<p>Shouldn\'t it be:</p>\n\n<pre><code>O((m+n)s) = O(n^3)\n</code></pre>\n\n<p>Any idea?</p>\n', 'ViewCount': '78', 'Title': u'Hopcroft\u2013Karp algorithm time complexity', 'LastEditorUserId': '12572', 'LastActivityDate': '2014-01-03T14:30:49.710', 'LastEditDate': '2014-01-03T14:30:49.710', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12572', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal><bipartite-matching>', 'CreationDate': '2014-01-03T13:58:38.513', 'Id': '19486'},63_259:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a set of elements U = {1, 2, .... , n} and a set S of k sets whose union form the whole universe. Each of these sets is associated with a cost.</p>\n\n<p>I have a fixed number of colors, C = {1 , 2, ... , m}. Some of the sets mentioned above interfere with each other. I cannot assign same color to both those sets together.</p>\n\n<p>I want to pick the sets and color them from my available color list in the following way:</p>\n\n<p>**Objective: Minimize the total cost of the selected sets</p>\n\n<p>Constraints:</p>\n\n<ol>\n<li><p>All elements of the universe are covered</p></li>\n<li><p>No two sets that interfere with each other is assigned the same color**</p></li>\n</ol>\n\n<p>If the second constraint, i.e., coloring constraint, is taken out, the problem reduces to standard weighted set covering problem. I can solve that using a greedy manner. For example, greedy unweighted set covering will work in the following way: -- 1. pick the set with the highest number of elements at first, 2. Remove that set and the associated elements from the universe, 3. Repeat step 1 until all elements of the universe are covered.</p>\n\n<p>But the coloring constraint in the presence of interference among sets and a fixed number of colors complicates the issue.</p>\n\n<p>For example, let\'s assume,</p>\n\n<p>U = {1, 2, 3, 4, 5}.</p>\n\n<p>There are three sets, {1, 2, 3}; {2, 3, 4, 5} ; {4, 5}.</p>\n\n<p>Assume {2, 3, 4, 5} interferes with both {1, 2, 3} and {4, 5}. {1, 2, 3} and {4, 5} do not interfere with each other. Assume that there is only one color in the system.</p>\n\n<p>A standard greedy unweighted set coloring solution will pick {2, 3, 4, 5} at first and {1, 2, 3} in the second round. But that is an infeasible solution to my problem since they interfere with each other and I have only one color in my system. A feasible solution will be the selection of {1, 2, 3} and {4, 5}.</p>\n\n<p>I wonder how I can minimize the total cost while meeting the color constraint. Any hint on the unweighted version of the problem (where all sets have equal cost) will be very helpful, too.</p>\n\n<p>Thanks,</p>\n\n<p>Nazmul</p>\n\n<p>Additional information: The coloring of the sets and the interference can be understood by my application scenario. </p>\n\n<p>I am looking at a wireless cell. I have a set of frequencies, possible base station locations and their associated users. Each set is associated with a station and it shows the set of users that the base station can serve. </p>\n\n<p>"Interference" from one set to the other means that the users\' signals of one set reaches the other set\'s base station. In a wireless setting, this interference is not symmetric. But assumption of symmetry is OK in the algorithm because if set A interferes with set B, A &amp; B both should get different colors if they are selected. </p>\n\n<p>The interference among sets is not transitive. Set A may interfere with set B (A\'s users may interfere with B\'s base station) and set B may interfere with set C (B\'s users may interfere with C\' base station) but that does not mean that set A will interfere with set C.</p>\n\n<p>The current example is showing that two sets interfere if they intersect. This is just a coincidence. I will have a pre-generated look up table that shows which set interferes with which set before the algorithm starts. This pre-generated table will be an input to the optimization problem</p>\n', 'ViewCount': '76', 'Title': 'Weighted Set covering problem with a fixed number of colors', 'LastEditorUserId': '12596', 'LastActivityDate': '2014-03-06T18:52:06.767', 'LastEditDate': '2014-01-05T07:54:04.203', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '19516', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12596', 'Tags': '<algorithms><graphs><optimization>', 'CreationDate': '2014-01-05T01:30:35.303', 'Id': '19503'},63_260:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '88', 'Title': 'What is the order of the Pancake graph in Given example & what are the properties of Pancake graph?', 'LastEditDate': '2014-05-03T21:04:17.810', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9665', 'FavoriteCount': '2', 'Body': '<p>Pancake graph have least diameter &amp; degree (log n/ log log n)</p>\n\n<p>pancake Graph with order-2 will be one single line with two nodes, labeled with permutation of node {12, 21}.</p>\n\n<p>pancake Graph with order-3 will be one single line with one hexagonal, labeled with permutation of node {123, 132, 213, 231, 312, 321}.</p>\n\n<p>Similarly for order-4 graph will be with 4-hexagonal.\n<img src="http://i.stack.imgur.com/RFsZY.png" alt="enter image description here"></p>\n\n<p><strong>This graph is in three dimension or four dimension?\nif this graph is in four dimension, then how graph will look like in three dimension?</strong></p>\n', 'ClosedDate': '2014-01-09T23:26:42.547', 'Tags': '<graph-theory><graphs><graph-traversal>', 'LastEditorUserId': '9665', 'LastActivityDate': '2014-05-03T21:04:17.810', 'CommentCount': '1', 'AcceptedAnswerId': '19579', 'CreationDate': '2014-01-08T11:26:51.350', 'Id': '19578'},63_261:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In directed graph, to find strongly connected components why do we have to transpose adjacency matrix (reverses the direction of all edges) if we could use reversed list of nodes by they finishing time and then traverse original graph.\nIn other words, we would find finish times of all vertices and start traversing from lowest finish time to greatest (by increasing finish time)? </p>\n\n<p>Additionally, if we do topological sorting on some DAG, and then reverse edges (transpose adjacency matrix) and do topological sorting again - should we get to equal arrays, just in reversed order?</p>\n\n<p>EDIT:\nAlgorithm description from other topic:\n<a href="http://cs.stackexchange.com/questions/11232/correctness-of-strongly-connected-components-algorithm-for-a-directed-graph?rq=1">Correctness of Strongly Connected Components algorithm for a directed graph</a></p>\n', 'ViewCount': '137', 'Title': u'Kosaraju\u2019s Algorithm - why transpose?', 'LastEditorUserId': '12752', 'LastActivityDate': '2014-04-07T20:21:21.567', 'LastEditDate': '2014-01-11T11:01:38.880', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12752', 'Tags': '<algorithms><graphs>', 'CreationDate': '2014-01-11T09:48:32.243', 'Id': '19652'},63_262:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The first chapter of the book "Graphs and their uses" by Oystein Ore says that interval graphs can be used to resolve authorship disputes, but I couldn\'t find any details.  How does this work?  What is the algorithm?</p>\n\n<p><strong>From the text (Chapter 1.7):</strong></p>\n\n<blockquote>\n  <p>Interval graphs have also been used to investigate the likely authorship of disputed pieces of writing, such as certain works of Plato. Various features of an authors prose style are studied for their appearance in several literary works. By drawing a graph in which the vertices correspond to these literary features and the edges correspond to pairs of them which occur together in the same work, we obtain a situation very similar to our archaeological example. As before, we can then investigate whether the resulting graph can be represented as an interval graph, and we can thereby attempt to arrange the works in chronological order. By doing this, it has sometimes been possible to relate the style of the disputed piece of writing to that of the author in question, and thereby to determine the likely authorship.</p>\n</blockquote>\n', 'ViewCount': '64', 'Title': 'Using interval graphs to find authorship disputes', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-13T13:14:32.097', 'LastEditDate': '2014-01-13T12:58:54.237', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<graph-theory><graphs><natural-lang-processing>', 'CreationDate': '2014-01-13T01:54:11.963', 'Id': '19680'},63_263:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for an algorithm to convert a digraph (directed graph) to an undirected graph in a reversible way, ie the digraph should be reconstructable if we are given the undirected graph. I understand that this will come in expense of the undirected graph having more vertices but I do not mind.</p>\n\n<p>Does one know how to do this or can suggest any references? Thanks in advance.</p>\n\n<hr>\n\n<p>Update: Regarding the answer of AdrianN below. It might be a good starting point but I don\'t think it works in its current form. Here is an image of why I think it doesn\'t:\n<img src="http://i.stack.imgur.com/Kh4eq.png" alt="enter image description here"></p>\n\n<hr>\n\n<p>Update after D.W.\'s comment: I consider the vertices of the graphs to be unlabeled. If a solution involves labeling the vertices (like AdrianN\'s does), then it should give the same (isomorphic) undirected graph no matter how the labeling is done. My definition of "isomorphic" for graphs with labeled vertices is that there is a permutation of the labeling that relates the two graphs, but I am not sure of the exact definition for unlabeled graphs...</p>\n', 'ViewCount': '127', 'Title': 'Converting a digraph to an undirected graph in a reversible way', 'LastEditorUserId': '12348', 'LastActivityDate': '2014-01-16T18:45:39.390', 'LastEditDate': '2014-01-15T19:07:50.007', 'AnswerCount': '4', 'CommentCount': '4', 'AcceptedAnswerId': '19758', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12348', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2014-01-15T10:30:23.683', 'Id': '19744'},63_264:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to write an algorithm that detects the most common subset of at least size $k$, from a collection of sets.  If there are ties for the most common subset, I want the one of them whose size is as large as possible.</p>\n\n<p>For example if I have:</p>\n\n<pre><code>s1 = {A, B, C   }\ns2 = {A, B, C, D}\ns3 = {   B, C, D}\n</code></pre>\n\n<p>Then the most common subset of size $\\ge k=2$ is {B, C}. As another example, if I have:</p>\n\n<pre><code>s1 = {A, B, C  D}\ns2 = {A, B, C, D}\ns3 = {   B, C, D}\n</code></pre>\n\n<p>Then the most common subset of size $\\ge k=2$ is {B, C, D}. It's important that in this instance the algorithm would give me {B, C, D} and not {B, C}, {B, D} etc. Note that I'm not interested in the longest common subset (a different problem), I'm interested in the longest most common subset if you will. I also don't care about enumerating all the different subsets, I just want to find the most common.</p>\n\n<p>Is there an efficient algorithm for this problem?</p>\n\n<p>I have an algorithm for this problem, but I don't think it's very efficient. For $k=2$ I enumerate all subsets of size 2 and count how many times each one appears in the collection. If the most-frequently occurring pair is more frequently occurring than any other pair then that must be the most common subset. If there is more than one with the same (maximum) frequency then I look at the sets they are contained in. If these overlap exactly then I take the union of the pairs and that gives me the most common subset (with size > 2).</p>\n\n<p>I think this could be related to the maximum clique problem but I'm not certain.</p>\n\n<p>Note that just taking the intersection does not give the correct answer.  For instance, if I have</p>\n\n<pre><code>s1 = {A, B      }\ns2 = {      C, D}\ns3 = {A,    C, D}\n</code></pre>\n\n<p>then the intersection is the empty set, but the most common subset is {C, D}.</p>\n", 'ViewCount': '69', 'Title': 'Most common subset of size $k$', 'LastEditorUserId': '755', 'LastActivityDate': '2014-01-16T22:42:41.270', 'LastEditDate': '2014-01-16T22:42:41.270', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19762', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12876', 'Tags': '<algorithms><graphs><sets><data-mining>', 'CreationDate': '2014-01-15T21:58:59.930', 'Id': '19755'},63_265:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to generate all possible paths in a directed, acyclic weighted graph with edge costs. I also have to sort them in order of shortest path. </p>\n\n<p>The simplest way that comes to mind is to do a depth-first search (DFS) for all paths, accumulating their edge costs as I traverse the paths, and then doing an NlogN sort on the result. </p>\n\n<p>But I wondering if there is a better way to do this task. Are there any algorithms that could optimize this problem (combining DFS and a shortest path algorithm such as Dijkstra's maybe?). </p>\n", 'ViewCount': '261', 'Title': 'Optimal algorithm to traverse all paths in the order of shortest path', 'LastEditorUserId': '10519', 'LastActivityDate': '2014-01-19T16:10:53.177', 'LastEditDate': '2014-01-16T17:08:00.273', 'AnswerCount': '1', 'CommentCount': '13', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10519', 'Tags': '<algorithms><graphs><shortest-path><search-algorithms>', 'CreationDate': '2014-01-16T01:40:27.343', 'FavoriteCount': '1', 'Id': '19761'},63_266:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '331', 'Title': "Why does Dijkstra's algorithm fail on a negative weighted graphs?", 'LastEditDate': '2014-01-16T22:51:53.690', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '11972', 'FavoriteCount': '1', 'Body': '<p>I know this is probably very basic, I just can\'t wrap my head around it.<br>\nWe recently studied about Dijkstra\'s algorithm for finding the shortest path between two vertices on a weighted graph.<br>\nMy professor said this algorithm will not work on a graph with negative edges, so I tried to figure out what could be wrong with shifting all the edges weights by a positive number, so that they all be positive, when the input graph has negative edges in it.<br>\nFor example, let\'s consider the following input graph:<br>\n<img src="http://i.stack.imgur.com/GlrNb.png" alt="input graph"><br>\nNow if I\'ll add 3 to all edges, it\'s obvious that the shortest path (between $s$ and $t$) has changed:\n<img src="http://i.stack.imgur.com/NgPpM.png" alt="graph after adding 3"><br>\nThus this kind of operation might result in wrong output. \nAnd this, basically, what I don\'t get. Why does this happen? Why is shifting the values has such a dramatic effect on the shortest path? This is totally counter-intuitive, at least for me.<br>\nIn probability, when you have some (discrete) distribution probability given by some random variable $X$, and you want to calculate the variance, then for every constant $c$, it holds that $Var(X+c)=Var(X)$, and this happens, of-course, because shifting the distribution values left or right does not effect how $X$ spreads.<br>\nNow, I\'m well aware that these are two different things here, and finding the shortest path is not exactly the same as calculating the variance of a random distribution function, but I\'m just saying that this is why to me it seems so counter-intuitive.</p>\n\n<p>Your thoughts?</p>\n', 'Tags': '<algorithms><graphs><shortest-path><weighted-graphs>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T22:51:53.690', 'CommentCount': '3', 'AcceptedAnswerId': '19775', 'CreationDate': '2014-01-16T18:47:20.783', 'Id': '19771'},63_267:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Graphs with degree $\\Delta$ have a maximum independent set of size $\\alpha \\geqslant \\frac{n}{\\Delta}$ where $n$ is the number of vertices. \nBut, are there graphs such that $\\alpha \\approx \\frac{n}{\\Delta}$, or even $\\alpha = c \\frac{n}{\\Delta}$ for some constant $c \\leqslant 1$?</p>\n', 'ViewCount': '67', 'Title': 'Graphs with bounded degree and small max independent set', 'LastActivityDate': '2014-01-21T19:16:55.893', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13008', 'Tags': '<graphs>', 'CreationDate': '2014-01-21T18:20:50.460', 'Id': '19874'},63_268:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a directed graph with $N$ vertices. Every pair of vertices is connected by two edges (one in each direction), and each of these edges has a weight which may be negative.</p>\n\n<p>On various occasions 'edge update' operations occur, where the weight of an edge is modified (although the edge is never deleted, and no new edges or vertices are added). After each of these operations I wish to know the length of the shortest path between one 'root' vertex and every other vertex in the graph. I don't care what the path is, and I already know it must exist. I don't mind how negative weight cycles are handled.</p>\n\n<p>I care about optimizing the running time of the single update operation and the $N$ queries that follow.</p>\n\n<p>The obvious approach would be Bellman-Ford, which would take $O(|V||E|)$ which is $O(n^3)$.</p>\n\n<p>Is there a faster way to do it?</p>\n", 'ViewCount': '37', 'Title': 'Update SSSPP solution on complete digraph on weight changes', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T13:06:42.687', 'LastEditDate': '2014-01-30T13:06:42.687', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6986', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-01-29T23:13:29.900', 'FavoriteCount': '2', 'Id': '20089'},63_269:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '54', 'Title': 'Simple path in a graph, within a given range of lengths', 'LastEditDate': '2014-02-03T08:54:42.827', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13327', 'FavoriteCount': '1', 'Body': '<p>Given an undirected graph $G(V,E)$ and two nodes $s$ and $t$, $s,t\\in V$, find a path whose length $L$ is bounded by a lower bound $N$ and an upper bound $M$, $N\\leq L\\leq M$.</p>\n\n<p>So, for example, $N=4, M=7$, I want to confirm that there is at least one simple path of 4,5,6 and 7 between two nodes in a graph? Nodes of the graph may appear in more than one path.</p>\n\n<p>Typical problem size:  </p>\n\n<ul>\n<li>10,000 nodes   </li>\n<li>Mean of 20 edges per node   </li>\n<li>Cycles in graph  </li>\n<li>Unweighted edges</li>\n</ul>\n', 'ClosedDate': '2014-02-03T09:54:06.393', 'Tags': '<graph-theory><graphs><graph-traversal>', 'LastEditorUserId': '1337', 'LastActivityDate': '2014-02-03T08:54:42.827', 'CommentCount': '2', 'CreationDate': '2014-02-02T14:17:32.063', 'Id': '20217'},63_270:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been reading about Dijkstra\'s algorithm and I think I understand it. I followed the algorithm in pseudo-code from Wikipedia, and now I wonder:</p>\n\n<ol>\n<li><p>If my graph is bi-directional and I add each edge to my graph <em>twice</em> (once "forwards", once "backwards"), will the "standard" Dijkstra\'s algorithm work?</p></li>\n<li><p>Is it ok that some of my edges are zero cost? (the rest are all positive - none are negative)</p></li>\n</ol>\n\n<p>And finally, what is a Dijkstra "heap" algorithm? Is it the same as Dijkstra\'s algorithm using a PriorityQueue?</p>\n', 'ViewCount': '106', 'Title': 'Does "standard" Dijkstra\'s algorithm work with bi-directional edges and zero cost edges?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-04T10:06:37.453', 'LastEditDate': '2014-02-04T10:06:37.453', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21281', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14379', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-02-04T07:55:47.223', 'Id': '21280'},63_271:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '64', 'Title': 'Finding all paths with lengths in a fixed interval in sparse graphs', 'LastEditDate': '2014-02-06T16:31:43.573', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Andrew S.', 'PostTypeId': '1', 'OwnerUserId': '13327', 'Body': '<p>What is the most efficient way to find all paths of length M to N in a large sparse graph?</p>\n\n<p>Some general information:</p>\n\n<ul>\n<li>Graph has 30,000 to 50,000 nodes</li>\n<li>Average number of edges per node ~ 10</li>\n<li>M=4, N=7</li>\n<li>Graph has cycles</li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T19:11:38.457', 'CommentCount': '2', 'AcceptedAnswerId': '21382', 'CreationDate': '2014-02-01T17:56:44.383', 'Id': '21381'},63_272:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '70', 'Title': "Why can't you write the 2-paths problem as a max-flow problem?", 'LastEditDate': '2014-02-12T19:55:24.250', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8877', 'FavoriteCount': '1', 'Body': '<p>This is a follow-up question to <a href="http://cstheory.stackexchange.com/questions/20989/graph-problems-which-are-np-complete-on-directed-graphs-but-polynomial-on-undire/20991#comment55620_20991">this</a>. Consider the 2-paths problem:</p>\n\n<blockquote>\n  <p>Given a directed graph $D=(V,A)$ and pairs of vertices $(s_1,t_1)$ and $(s_2,t_2)$, are there paths $P_1 = (s_1,\\dots, t_1)$ and $P_2=(s_2,\\dots,t_2)$ such that $P_1$ and $P_2$ are vertex-disjoint?</p>\n</blockquote>\n\n<p>This problem has been shown to be NP-complete (references <a href="http://cstheory.stackexchange.com/questions/20989/graph-problems-which-are-np-complete-on-directed-graphs-but-polynomial-on-undire/20991#comment55620_20991">here</a>). \nThis struck me as unusual, because there seems to be a natural way to formulate this as a max flow problem: </p>\n\n<ul>\n<li>Add new vertices $s$ and $t$ to $D$.</li>\n<li>Add arcs $(s,s_1),(s,s_2),(t_1,t),(t_2,t)$.</li>\n<li>Let all vertices have capacity one (besides $s$ and $t$).</li>\n</ul>\n\n<p>It seems to me that the max $s-t$ flow of this new graph (call it $D\'$) should be two iff $D$ has those desired paths $P_1$ and $P_2$. Surely there must be some mistake here, because this seems to imply that an NP-complete problem can be solved in polytime. Where is the mistake?</p>\n', 'Tags': '<complexity-theory><graphs><network-flow>', 'LastEditorUserId': '8877', 'LastActivityDate': '2014-02-12T22:50:32.903', 'CommentCount': '2', 'AcceptedAnswerId': '21577', 'CreationDate': '2014-02-12T18:35:27.667', 'Id': '21574'},63_273:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a question regarding a graph algorithm which is as follows:</p>\n\n<p>Given a graph $G = (V,E)$ whose vertices are uniquely labeled $\\{1, 2,\\dots ,n\\}$ we want to determine the smallest integer $k$ such that deleting vertices $1$ through $k$ results in a graph whose largest connected component has at most $n/2$ vertices (when we delete a vertex we also delete all edges incident to that vertex). Give an $O(m \\log^* n)$ algorithm that determines $k$.</p>\n\n<p>The graph at the beginning could be disconnected, nor at the end need it be connected.\nSince $O(m \\log^*n)$ is almost linear, $\\log^*n$ grows very very slowly like in union-find data structure so this algorithm is almost linear time like union-find. I am trying to solve it through union find but it seems I am doing something wrong. Now I think that I should use union-find as a black box, but I ca'nt figure it out.</p>\n\n<p>This is a practice problem, not homework.</p>\n", 'ViewCount': '83', 'Title': 'Deleting vertices so that largest connected component has at most $n/2$ vertices', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T07:53:23.507', 'LastEditDate': '2014-02-19T07:53:23.507', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6688', 'Tags': '<algorithms><graphs>', 'CreationDate': '2014-02-19T02:02:46.737', 'Id': '21795'},63_274:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we were using a priority queue(PQ) to implement Prim's algorithm. My understanding is that initially the weight of all vertices is set to $\\infty$. The weight of the starting vertex is then set to 0. All of the vertices are then inserted into the PQ. </p>\n\n<p>1) Does that mean that we can insert the vertices in any order into the PQ? </p>\n\n<p>2) Given that we can insert the vertices in any order, suppose we have a graph with the<br>\n$\\quad$following vertices a, b and c and the following weights w(a,$\\,$b) = 1, w(a,$\\,$c ) = 2. Once we set a.key = 0 $\\quad$and then extract a from PQ, we have b.key = 1 and c.key = 2. Given the answer to (1) was yes,my<br>\n$\\quad$understanding would be that in a binary tree representation of the heap, b would now be the root and c<br>\n$\\quad$would be a child of b. However, depending on the order in which the a, b and<br>\n$\\quad$c were added to the heap, c could be either the left or right child of b, right?</p>\n\n<p>3) Suppose now that the graph has vertices a, b, c, d and edges (a, b), (a, c), (a, d). Suppose they were<br>\n$\\quad$inserted into the heap in the order a, b, c, d. The binary tree representation of the heap should then be:       </p>\n\n<p>$\\quad\\quad$ a is the root, left(a) = b, right(a) = c, left(b) = d    </p>\n\n<p>$\\quad$ So, that would mean that the parent-child relationships do not correspond to the parent-child<br>\n$\\quad$ relationships in the original graph and they don't have to, right? </p>\n", 'ViewCount': '98', 'Title': "Prim's Algorithm - Building the Priority Queue", 'LastEditorUserId': '8639', 'LastActivityDate': '2014-02-19T15:22:41.730', 'LastEditDate': '2014-02-19T15:22:41.730', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8639', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2014-02-19T05:32:02.400', 'FavoriteCount': '1', 'Id': '21801'},63_275:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G=(L,R,E)$ be a bipartite graph, are there conditions on the degree of the vertices under which the condition of Hall\'s theorem is surely satisfied? (meaning a perfect matching exists in the graph).</p>\n\n<p><a href="http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29" rel="nofollow">Konig\'s theorem</a> proves that every $k$-regular bipratite graph has exactly $k$ edge disjoint perfect matchings, so the answer is obviously yes for any $k$-regular bipartite graph with $k&gt;0$ (it\'s not hard to see why hall\'s condition is satisfied in this case).</p>\n\n<p>Is there a wider rule? </p>\n\n<p>For example: Let $|L|=|R|=n$, What is the minimal degree as a function of $n$ of every vertex in the graph such that the graph must admit a perfect matching?</p>\n\n<p>I\'m also wondering if these conditions will hold in general graphs (satisfying Tutte\'s theorem), and if not, then are there similar conditions for general graphs.</p>\n', 'ViewCount': '92', 'Title': "Degree conditions sufficient for Hall's theorem", 'LastEditorUserId': '10438', 'LastActivityDate': '2014-02-21T12:42:04.250', 'LastEditDate': '2014-02-21T12:42:04.250', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<graph-theory><graphs><matching>', 'CreationDate': '2014-02-19T07:49:04.013', 'Id': '21803'},63_276:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is my problem: I have a directed weighted graph with a substantial amount of vertices (few thousands), no cycles, in fact, it includes a starting node, a final node and an $m \\times n$ grid between them, where edges can be directed from the left to the right only. The weights of the edges depend on the path in which they are included (for example, if the path includes v.15, then the weights of several edges change).</p>\n\n<p>I tried to get all possible paths and then calculate their final sum post factum, but that turned out to be very inefficient method due to the number of paths. Is there an effective method which allows to find shortest paths in these kind of graphs?</p>\n', 'ViewCount': '74', 'Title': 'Finding shortest path in a graph when edge weights depend on the chosen vertices', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T09:41:29.690', 'LastEditDate': '2014-02-19T09:41:29.690', 'AnswerCount': '0', 'CommentCount': '13', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14837', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-02-19T09:31:23.923', 'Id': '21807'},63_277:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G=(V,E)$ be a directed graph. The <strong>connectivity</strong> of a graph is the defined as the cardinality of a smallest separator of $G$. A <strong>separator</strong> of $G$ is a subset $U$ of $V$, such that $G-U$ is not strongly connected.</p>\n\n<p>Why does the following algorithm compute the connectivity of a graph correctly?</p>\n\n<p>\\begin{equation}\n\\begin{split}\n&amp;\\text{Connectivity}(\\text{graph }G=(V,E)) \\\\\n&amp;\\;\\;\\;\\;01\\text{:}\\;\\;k=\\infty \\\\\n&amp;\\;\\;\\;\\;02\\text{:}\\;\\;\\text{for }i=1,\\ldots,|V| \\\\\n&amp;\\;\\;\\;\\;03\\text{:}\\;\\;\\{\\\\\n&amp;\\;\\;\\;\\;04\\text{:}\\;\\;\\;\\;\\;\\;\\text{for each }v\\in V\\\\\n&amp;\\;\\;\\;\\;05\\text{:}\\;\\;\\;\\;\\;\\;\\{\\\\\n&amp;\\;\\;\\;\\;06\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{compute a minimum }v_i,v\\text{-seperator }U_{v_i,v}\\\\\n&amp;\\;\\;\\;\\;07\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;k=\\min\\left\\{k,\\left|U_{v_i,v}\\right|\\right\\}\\\\\n&amp;\\;\\;\\;\\;08\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if }(i&gt;k+1) \\text{ return }k\\\\\n&amp;\\;\\;\\;\\;09\\text{:}\\;\\;\\\\\n&amp;\\;\\;\\;\\;10\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{compute a minimum }v,v_i\\text{-seperator }U_{v,v_i}\\\\\n&amp;\\;\\;\\;\\;11\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;k=\\min\\left\\{k,\\left|U_{v,v_i}\\right|\\right\\}\\\\\n&amp;\\;\\;\\;\\;12\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if }(i&gt;k+1) \\text{ return }k\\\\\n&amp;\\;\\;\\;\\;13\\text{:}\\;\\;\\;\\;\\;\\;\\}\\\\\n&amp;\\;\\;\\;\\;14\\text{:}\\;\\;\\}\n\\end{split}\n\\end{equation}</p>\n\n<p>More precisely, why can we return $k$ in line 08 (resp. 12) without concerning the other $u,v$-seperators?</p>\n', 'ViewCount': '41', 'Title': 'Proving the correctness of an algorithm, which computes the connectivity of a directed graph', 'LastActivityDate': '2014-02-19T23:39:35.870', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21828', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12502', 'Tags': '<algorithms><graph-theory><graphs><correctness-proof>', 'CreationDate': '2014-02-19T15:58:02.890', 'FavoriteCount': '1', 'Id': '21819'},63_278:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that depth-first search can be used to produce a depth-first spanning tree, which classifies all edges as tree edges, forward edges, backward edges or cross edges. Are there any algorithms that make use of the depth-first spanning tree?</p>\n', 'ViewCount': '78', 'Title': 'Applications of Depth-First Spanning Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-20T15:01:48.333', 'LastEditDate': '2014-02-20T11:08:14.503', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14872', 'Tags': '<algorithms><graphs><graph-traversal><spanning-trees>', 'CreationDate': '2014-02-20T07:12:38.657', 'Id': '21839'},63_279:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an undirected graph where each node is labelled with an integer key and I\'m asked to detect every <em>simple</em> 4-cycle, which can be seen as an empty square (i.e. the two opposite nodes of the cycle have not to be connected).</p>\n\n<p>I know the labels of a generic square in the graph can be permuted in $4! = 24$ ways, but on his <a href="http://www.adjoint-functors.net/su/web/354/references/graph-processing-w-mapreduce.pdf" rel="nofollow">paper</a> (pages 33-36) Cohen states that the symmetric group $S_4$ has $S_4 = 8$ elements, and this should allow me to focus only on $24/8 = 3$ distinct cases.</p>\n\n<p>I don\'t understand this last point. Well, I know he probably means that the suqare has $8$ isometries (four reflections and four rotations), but I don\'t understand why this leads to the three cases in Figure 7 of the paper.</p>\n\n<p>Thank you.</p>\n', 'ViewCount': '27', 'Title': 'How many times an empty 4-cycle can be counted in an undirected graph?', 'LastEditorUserId': '13243', 'LastActivityDate': '2014-02-20T14:55:43.497', 'LastEditDate': '2014-02-20T14:27:28.440', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13243', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2014-02-20T13:09:38.950', 'Id': '21844'},63_280:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I read that determining the size of the maximum independent set (and also a clique of maximum size) is in P. The versions that find the actual solution are known to be NP-hard. </p>\n\n<p>With respect to finding clique size, you can sort the node degrees, decrement $i$ from $|V|$ to $0$, and each time check if you have $i$ elements of node degree $i$, pick the power set of those $\\geq i$ elements and verify the clique. However, picking the power set is exponential, and this algorithm would give you the solution itself. I have a hard time figuring out how you can construct an algorithm that decides the presence of a clique (or independent set) of a certain size in polytime, but doesn't give you the solution.</p>\n", 'ViewCount': '101', 'Title': 'Why is determining the size of a maximum independent set or a clique in P?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-27T07:22:20.957', 'LastEditDate': '2014-02-27T07:22:20.957', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22083', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<algorithms><complexity-theory><graph-theory><graphs><time-complexity>', 'CreationDate': '2014-02-27T05:41:09.613', 'Id': '22080'},63_281:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given n, I want to randomly generate a binary tree (unlabelled) that has n end nodes. Could someone kindly provide a reference containing an algorithm for doing that?</p>\n\n<p>I attempted to do as follows: From a PRNG obtain n PRNs in [0.0, 1.0) as (relative) frequencies of n symbols for generating a Huffman tree (used in data compression). But, if the PRNs used are uniform, then I think this would highly favour generation of those Huffman trees that are more flat and Huffman trees corresponding to widely different frequencies of the symbols would be highly suppressed in the generation process. If this is correct, how could one do better? Thanks in advance.</p>\n', 'ViewCount': '63', 'Title': 'Generation of random binary trees', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-20T13:47:45.200', 'LastEditDate': '2014-02-28T08:39:33.350', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6437', 'Tags': '<data-structures><sampling><random-graphs>', 'CreationDate': '2014-02-27T17:34:00.827', 'Id': '22098'},63_282:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I understand the basis of A* as being a derivative of Dijkstra, however, I recently found out about D*. From Wikipedia, I can understand the algorithm. What I do not understand is why I would use D* over Dijkstra. To my understanding, Dijkstra gives a best path and D* works backwards from the end goal, but unlike A* it seems to do many calculations, so it doesn't seem as efficient.</p>\n", 'ViewCount': '116', 'Title': 'Why choose D* over Dijkstra?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-05T09:28:49.120', 'LastEditDate': '2014-03-05T07:08:16.793', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22299', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '15288', 'Tags': '<algorithms><graphs><search-algorithms><efficiency>', 'CreationDate': '2014-03-05T00:30:16.657', 'Id': '22284'},63_283:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G$ be a DAG. We know that some nodes in $G$ are "bad", while the others are "good"; a descendant of a bad node is bad while the ancestors of a good node are good. We also know that bad nodes have a unique minimal element in $G$ which we\'d like to find querying as few nodes as possible with queries of the type "Are you good or bad?".</p>\n\n<p>This problem is solved in Git, the popular version control system, by the command <code>git-bisect</code>, which helps a programmer find the first commit in which a bug was introduced.</p>\n\n<p>At the start, the algorithm implemented by Git assumes to know a single bad commit and one or more good commits. At each step of its execution, the algorithm finds a commit using the following steps (taken from <a href="https://github.com/git/git/blob/master/Documentation/git-bisect-lk2009.txt#L407" rel="nofollow">here</a>):</p>\n\n<ol>\n<li><p>Keep only the commits that:</p>\n\n<p><em>a)</em> are an ancestor of the bad commit (including the bad commit itself), and</p>\n\n<p><em>b)</em> are not an ancestor of a good commit (excluding the good commits).</p></li>\n<li><p>Starting from the good ends of the resulting graph, associate to each\ncommit the number of ancestors it has plus one.</p></li>\n<li><p>Associate to each commit $\\min(X, N-X)$, where $X$ is the value associated to the commit in step 2, and $N$ is the total number of commits in the graph (after it was reduced in step 1).</p></li>\n<li><p>The best bisection point is the commit with the highest associated\nnumber.</p></li>\n</ol>\n\n<p>This algorithm is essentially finding the commit that achieves the "worst best case": in fact, $\\min(X,N-X)$ is the number of nodes in the DAG at the next iteration in the best case, thus $\\max\\min(X,N-X)$ is the worst best case.</p>\n\n<p>I\'m wondering:</p>\n\n<ul>\n<li>Does it make any difference if we select the "best worst case", that is, the node that achieves $\\min\\max(X,N-X)$?</li>\n<li>Is this algorithm worst-case optimal?</li>\n</ul>\n\n<p>EDIT: I\'ve noticed that this problem has a $\\Omega(N)$ bound. Consider the DAG formed by a single node $b$ with $N-1$ parents called $g_1,\\dots,g_{N-1}$. If we know that $b$ is bad then we have check each of the parents to see if they are the minimal bad node.</p>\n\n<p>EDIT 2: The previous is actually a $\\Omega(w)$ bound, where $w$ is the width of the poset. An alternative algorithm for this problem is given in <a href="http://cstheory.stackexchange.com/a/8943/12419">this answer</a> on cstheory.stackexchange that uses $O(w\\log{n})$ queries.</p>\n', 'ViewCount': '132', 'Title': 'Is the algorithm implemented by git bisect optimal?', 'LastEditorUserId': '4511', 'LastActivityDate': '2014-03-16T15:12:21.663', 'LastEditDate': '2014-03-16T15:12:21.663', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4511', 'Tags': '<algorithms><graphs>', 'CreationDate': '2014-03-10T03:11:55.213', 'FavoriteCount': '1', 'Id': '22451'},63_284:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Let\'s say we have a directed graph $G = (V, E)$ for which $(v, w) \\in E$ and/or $(w,v) \\in E$ holds true for all $v, w \\in V$. My feeling is that this graph most definitely is Hamiltonian, and I want to find a Hamiltonian path in it (from any vertex to any other vertex, I don\'t care where to start or stop).</p>\n\n<p>I wanted to refer to <a href="http://en.wikipedia.org/wiki/Hamiltonian_path#Bondy.E2.80.93Chv.C3.A1tal_theorem" rel="nofollow">Meylien\'s theorem</a> for this:</p>\n\n<blockquote>\n  <p>A strongly connected simple directed graph with $n$ vertices is Hamiltonian if the sum of full degrees of every pair of distinct non-adjacent vertices is greater than or equal to $2n \u2212 1.$</p>\n</blockquote>\n\n<p>There are two subtleties that I\'m not sure about with this theorem:</p>\n\n<ul>\n<li>What is meant by "adjcent vertices". Does the order matter here? Is the pair $(v,w)$ adjacent even if $(w,v) \\in E$ but not $(v,w)$ itself? If that is the case and the graph is strongly connected, than it must obviously be Hamiltonian, since there are no non-adjacent pairs of vertices at all.</li>\n<li>A graph with the above property is not necessarily strongly connected. I think this is easy to solve: We can just decompose the graph into SCCs. We will still have no non-adjacent pairs of vertices in the components and all of them are Hamiltonian. We can then construct a Hamiltonian path of the whole graph by connecting them in topological order.</li>\n</ul>\n\n<p>Is the above reasoning correct and the theorem applicable? Or is there some other argument we can use to show that there is a Hamiltonian path in the graph?</p>\n\n<p>In the end I want to actually <em>find</em> the Hamiltonian cycles in the SCCs, but haven\'t had much luck finding a constructive proof of the theorem, let alone an algorithm that solves this. Can it be done in a straightforward way? I feel like some kind of greedy approach could work, where we take the nodes in decreasing order of outdegree or something similar.</p>\n', 'ViewCount': '27', 'Title': "Meyniel's theorem + finding a Hamiltonian path for a specific graph family", 'LastEditorUserId': '13167', 'LastActivityDate': '2014-03-12T03:08:19.193', 'LastEditDate': '2014-03-12T03:02:15.303', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22527', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13167', 'Tags': '<algorithms><graph-theory><graphs><hamiltonian-path>', 'CreationDate': '2014-03-12T02:51:07.913', 'Id': '22525'},63_285:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to work out centrality in a network using Freeman's network centrality. I have an in degree of 83 and an out degree of 110. I want to work out the network centrality using my out degree using the following formula: \n$$\n\\frac{\\sum_{i=1}^{g}[{C}^d ({n*})-C^{d}]}\n {[(N-1)(N-2)]}\n$$</p>\n\n<p>This is where \n$$\n{n}\n$$\nis node in my graph and presuming the out- degree. Any suggestions on how to apply this formula?</p>\n\n<p>Thanks in advance!</p>\n", 'ViewCount': '28', 'Title': 'Minimizing the following objective function with matrices', 'LastActivityDate': '2014-04-12T14:10:01.060', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2014-03-13T09:35:48.593', 'Id': '22578'},63_286:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My teacher pointed out to us during lectures that we could use <strong>Graph Search</strong> to help us solve Sudoku puzzles which has left me puzzled . </p>\n\n<p>I dont see how this is possible as <strong>Graph Search</strong> is mostly about getting from Node A to Node B. He mentioned about how its a directed graph where the nodes correspond to partially completed puzzle</p>\n\n<p>What is the general idea behind using <strong>Graph Search</strong> to solve Sudoku Puzzle</p>\n', 'ViewCount': '108', 'Title': 'How to implement graph search to solve Sudoku puzzle', 'LastEditorUserId': '12448', 'LastActivityDate': '2014-03-17T12:30:24.120', 'LastEditDate': '2014-03-17T07:52:15.367', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12448', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs>', 'CreationDate': '2014-03-17T07:45:30.290', 'FavoriteCount': '1', 'Id': '22695'},63_287:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $T = (V, E)$ be a tree with a designated root $r \\in V$. The fact that the tree is rooted allows us to speak of "subtrees of $T$ rooted at some node $x \\in V$". Let\'s say we have a (not necessarily injective) function $c: V \\rightarrow \\mathbb{N}$ that assigns a color to every node. </p>\n\n<p>We want to find for every node $x \\in V$ the number of distinct colors in the subtree rooted at $x$. So if $A(x)$ is the set of children of $x$, we want to find for every node $x$, the cardinality of the set </p>\n\n<p>$S(x) = \\bigcup_{y\\in A(x)} S(y) \\cup \\{c(x)\\}$</p>\n\n<p>There is a rather simple algorithm that solves this problem offline in $O(n \\log^2 n)$:</p>\n\n<ul>\n<li>Process the nodes in depth-first order</li>\n<li>Represent the sets $S(x)$ as a persistent, self-balancing binary search trees</li>\n<li>For every node $x$, let $y \\in A(x)$ be the child of $x$ that maximizes $|S(y)|$.  Now we just merge for every other child $z \\in A(x) \\setminus {y}$ the set $S(z)$ into the set $S(y)$ via insertion. We also insert $c(x)$ and now have $S(x)$ as a binary search tree and can give the answer for node $x$</li>\n</ul>\n\n<p>We can even avoid the persistent trees by mutating the subresult for the heaviest child instead of creating a new set.</p>\n\n<p>The typical argument I have seen to justify the bound is the following:</p>\n\n<blockquote>\n  <p>A "move" consist of taking an element from a set and inserting it in another set.\n  Let\'s prove that there\'s at most $O(n \\log n)$ moves, each move can be done in $O(\\log n)$, the total complexity is $O(n \\log^2 n)$.</p>\n  \n  <p>When you are merging two sets you move all elements from smaller set (assume its size is $k$) to the bigger one, so every element in the smaller set now is in a set with at least size $2k$. In other words every element that has been moved $t$ times is in a set with at least size $2^t$, thus every element will be moved at most $O(\\log n)$ and we have $n$ elements so in total there will be at most $O(n \\log n)$ move operations.</p>\n</blockquote>\n\n<p>(Quote from a <a href="http://codeforces.com/blog/entry/10696" rel="nofollow">Codeforces comment</a>).</p>\n\n<p>While this is a beautiful argument, it\'s not <em>quite</em> correct, because usually we remove duplicates, so sets don\'t in fact grow exponentially (for example if every node has the same color). </p>\n\n<p>I am convinced that the bound holds, because I can prove it using structural induction. What I want to know is the following:</p>\n\n<ul>\n<li>Is there a way to prove the $O(n \\log^2 n)$ bound using an argument similar to the above, by bounding the number of "moves" of the color of a node? In other words, can the proof be "fixed" easily?</li>\n<li>The argument from above would also hold in DAGs, not only in trees. However it seems unlikely that we could achieve a runtime better than $O(n \\cdot m)$ to solve this problem in a DAG, so I guess there is no fix for the proof idea in this case. Am I right? Is there a good intuition for that?</li>\n</ul>\n', 'ViewCount': '36', 'Title': 'Merge-by-weight to solve reachability problems in trees and DAGs', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-18T06:54:34.033', 'LastEditDate': '2014-03-18T06:54:34.033', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22744', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13167', 'Tags': '<graphs><trees><complexity-proof>', 'CreationDate': '2014-03-17T22:31:30.940', 'Id': '22725'},63_288:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to solve this problem:</p>\n\n<blockquote>\n  <p>Given a collection of cities and the number of commuters between cities, design a network of roads for minimal cost where cost includes the cost of building the roads, and traveling of commuters. (So if more commuters use one edge, that edge will have a modified cost since the commuters want to get to their destination quickly)</p>\n</blockquote>\n\n<p>I've been treating the cities as nodes in a graph and the roads as edges. I want the weight of the edges to be dependent on the length of the edge (longer edges cost more) and somehow dependent on how many commuters are using that edge.</p>\n\n<p>My thought was to try doing something like a Minimum Steiner Tree, which if cost didn't depend on the commuters would minimize the cost of building the roads, but I'm not convinced that the solution to this should be a tree. And if I try to find a Minimal Spanning Tree or Minimum Steiner Tree I'm not sure how to deal with the fact that I don't know the edge cost until I know the full tree/graph. That is if people want to travel from A to B and we remove the edge from A to B, those people will now have to travel from A to C then from C to B which will modify the edge cost between A and C and C and B.</p>\n\n<p>Does anyone have any ideas on how to deal with the changing edge costs or know of a better way to solve this problem?</p>\n\n<p><strong>edit:</strong> You can make any sort of network you want, the roads can go straight from one city to another, or to any intermediate node(s) which can be placed anywhere in the plane. I'm planning on making the cost of building a road just a constant times the length of the road. For the cost of commuters I think another fractional constant times the distance they have to travel along the roads times the number of commuters traveling along that section of road.</p>\n", 'ViewCount': '87', 'ClosedDate': '2014-03-27T07:59:50.773', 'Title': 'Algorithm to determine a minimal cost graph', 'LastEditorUserId': '15844', 'LastActivityDate': '2014-03-19T16:50:47.457', 'LastEditDate': '2014-03-19T16:50:47.457', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15844', 'Tags': '<algorithms><graph-theory><graphs><weighted-graphs>', 'CreationDate': '2014-03-18T23:49:12.033', 'Id': '22782'},63_289:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am reading Prim's MST for the first time and wanted to implement the fast version of it . </p>\n\n<p>$m$ - The number of edges in the graph </p>\n\n<p>$n$ - The number of vertices in the graph </p>\n\n<p>Here's the algorithm :</p>\n\n<p>1) Create a Min Heap of size $V$ where $V$ is the number of vertices in the given graph. Every node of min heap contains vertex number and key value of the vertex.</p>\n\n<p>2) Initialize Min Heap with first vertex as root (the key value assigned to first vertex is $0$ ). The key value assigned to all other vertices is $\\infty$ .</p>\n\n<p>3) While Min Heap is not empty, do following</p>\n\n<p>\u2026..a) Extract the min value node from Min Heap. Let the extracted vertex be u.</p>\n\n<p>\u2026..b) For every adjacent vertex $v$ of $u$, check if $v$ is in Min Heap (not yet included in MST). If $v$ is in Min Heap and its key value is more than weight of $u-v$, then update the key value of $v$ as weight of $u-v$.</p>\n\n<p>Now my point is during implementation ( I am doing in C++) in step 3(b) I have to check whether the vertex is there in the heap or not . As we know , searching in a heap is done in $O(n)$ time . So in the main while loop which will run ( $n$ number of times ) although extract-min is $O(\\log n)$ but the search ( whether $v$ is min heap or not takes time proportional to size of the heap ( although it is decreasing in each step ) . </p>\n\n<p>So is it correct to say that the above algorithm is $O(m+n\\log n)$</p>\n", 'ViewCount': '86', 'Title': "Prim's Minimum Spanning Tree implementation $O(mn)$ or $O(m+n \\log n)$?", 'LastEditorUserId': '15879', 'LastActivityDate': '2014-03-19T19:06:06.820', 'LastEditDate': '2014-03-19T18:56:58.260', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15879', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs><runtime-analysis>', 'CreationDate': '2014-03-19T18:20:22.067', 'Id': '22817'},63_290:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://cs.stackexchange.com/q/11263/8660">This</a> link provides an algorithm for finding the diameter of an undirected tree <strong>using BFS/DFS</strong>. Summarizing:</p>\n\n<blockquote>\n  <p>Run BFS on any node s in the graph, remembering the node u discovered last. Run BFS from u remembering the node v discovered last. d(u,v) is the diameter of the tree. </p>\n</blockquote>\n\n<p>Why does it work ?</p>\n\n<p>Page 2 of <a href="http://courses.csail.mit.edu/6.046/fall01/handouts/ps9sol.pdf" rel="nofollow">this</a> provides a reasoning, but it is confusing. I am quoting the initial portion of the proof:</p>\n\n<blockquote>\n  <p>Run BFS on any node s in the graph, remembering the node u discovered last. Run BFS from u remembering the node v discovered last. d(u,v) is the diameter of the tree.</p>\n  \n  <p>Correctness: Let a and b be any two nodes such that d(a,b) is the diameter of the tree. There is a unique path from a to b. Let t be the first node on that path discovered by BFS. If the paths $p_1$ from s to u and $p_2$ from a to b do not share edges, then the path from t to u includes s. So</p>\n  \n  <p>$d(t,u) \\ge d(s,u)$</p>\n  \n  <p>$d(t,u) \\ge d(s,a)$</p>\n  \n  <p>....(more inequalities follow ..)</p>\n</blockquote>\n\n<p><img src="http://i61.tinypic.com/rji9uq.png" alt=""> </p>\n\n<p>The inequalities do not make sense to me.</p>\n', 'ViewCount': '232', 'Title': 'Algorithm to find diameter of a tree using BFS/DFS. Why does it work?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-20T23:37:16.420', 'LastEditDate': '2014-03-20T13:30:18.160', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8660', 'Tags': '<algorithms><graphs><search-algorithms><graph-traversal>', 'CreationDate': '2014-03-20T07:09:10.287', 'Id': '22855'},63_291:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a found a small article [1] saying (the first paragraph of the introduction) that the minimum-weight independent dominating set is NP-complete in chordal graphs, but at the same time, seems to contradict that exact statement.</p>\n\n<p>Moreover, I have found another reference [2] saying that in chordal graphs, it is polynomial time solvable. So which one is it?</p>\n\n<p>Note: I am just trying to reference this result in a project of mine. No need for a proof.</p>\n\n<p>Edit: I am referring to this piece of the introduction: "Domination and most of its variations are NP-complete for chordal graphs (even for the subclass of split graphs) with the exception of independence domination (see [3]). On the other hand, an unpublished proof for the NP-completeness of the weighted independent domination in chordal graphs by the author 20 years ago..." Then in my reference [2], it also states that the weighted version is polynomial time solvable, yet here they say that there is an NP-completeness proof. Am I missing something fundamental?</p>\n\n<hr>\n\n<ol>\n<li><a href="http://dx.doi.org/10.1016/j.dam.2003.05.004" rel="nofollow">The weighted independent domination problem is NP-complete for chordal graphs</a> by G. J. Chang (2004)</li>\n<li>Fundamentals of Domination in Graphs by T. W. Haynes, S. Hedetniemi and P. Slater (1998)</li>\n</ol>\n', 'ViewCount': '26', 'Title': 'Is the minimum weight independent dominating set np-complete in chordal graphs?', 'LastEditorUserId': '4734', 'LastActivityDate': '2014-03-25T00:53:34.463', 'LastEditDate': '2014-03-25T00:52:30.127', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<complexity-theory><graphs><np-complete>', 'CreationDate': '2014-03-25T00:30:21.693', 'Id': '23025'},63_292:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for more information/references on how graph search is utilized in social media. Papers, books , anything really. </p>\n', 'ViewCount': '47', 'ClosedDate': '2014-03-27T08:31:21.653', 'Title': 'Looking for sources: Graph search in social media', 'LastActivityDate': '2014-03-26T23:04:22.817', 'AnswerCount': '1', 'CommentCount': '11', 'AcceptedAnswerId': '23103', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16167', 'Tags': '<graphs>', 'CreationDate': '2014-03-26T21:00:58.497', 'FavoriteCount': '1', 'Id': '23100'},63_293:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>My question is that I'm trying to find the sparsest cut in a connected, undirected graph (all weights are = 1). Basically, I am looking trying to find the smallest cut (i.e., number of edges cut since all weights = 1) while maximizing the number of vertices in the resulting subgraph. How do I approach this problem with flow?</p>\n", 'ViewCount': '20', 'ClosedDate': '2014-04-16T23:02:28.523', 'Title': 'Minimum cut versus sparsest cut?', 'LastActivityDate': '2014-04-14T02:32:51.203', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16201', 'Tags': '<algorithms><graphs><network-flow>', 'CreationDate': '2014-03-27T15:31:57.593', 'Id': '23133'},63_294:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If given that all edges in a graph $G$ are of equal weight $c$, can one use breadth-first search (BFS) in order to produce a minimal spanning tree in <strong>linear time</strong>?</p>\n\n<p>Intuitively this sounds correct, as BFS does not visit a node twice, and it only traverses from vertex $v$ to vertex $u$ iff it hasn't visited $u$ before, such that there aren't going to be any cycles, and if $G$ is connected it will eventually visit all nodes. Since the weight of all edges is equal, it doesn't matter which edges the BFS chose.</p>\n\n<p>Does my reasoning make any sense?</p>\n", 'ViewCount': '318', 'Title': 'If all edges are of equal weight, can one use BFS to obtain a minimal spanning tree?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-29T19:58:59.877', 'LastEditDate': '2014-03-29T19:58:59.877', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23181', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2014-03-28T13:34:40.343', 'Id': '23179'},63_295:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've a subset of the simple paths in a graph. The length of the paths is bounded by $d$. </p>\n\n<p>What's the most compact way (memory-wise) I can represent the paths such that no other paths apart from the selected ones are represented? </p>\n\n<p>Note that I want to use this representation in an algorithm that will iterate through this subset of paths over and over again and that I want to be fairly fast, so for instance, I can't use any standard compression algorithms.</p>\n\n<p>One representation that came to my mind was representing them as a set of trees. I'm guessing though that getting it down to an optimal number of trees is NP-hard? What other representations would be good?</p>\n", 'ViewCount': '96', 'Title': 'Compact representation of paths in a graph', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-31T14:47:48.067', 'LastEditDate': '2014-03-29T11:56:06.693', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8', 'Tags': '<graphs><data-structures>', 'CreationDate': '2014-03-29T06:40:49.770', 'FavoriteCount': '1', 'Id': '23213'},63_296:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the problem:</p>\n\n<blockquote>\n  <p>Given an undirected graph and two of its vertices, is there a path between them? </p>\n</blockquote>\n\n<p>I often read that this problem can be solved in linear time in the number of vertices! I am not sure why this claim holds.</p>\n\n<p>Can this really be done in linear time (not amortized) without preprocessing?</p>\n', 'ViewCount': '189', 'Title': 'Can we test whether two vertices are connected in time linear in the number of nodes?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T17:56:51.647', 'LastEditDate': '2014-04-01T17:55:46.217', 'AnswerCount': '3', 'CommentCount': '10', 'AcceptedAnswerId': '23323', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16358', 'Tags': '<algorithms><graphs>', 'CreationDate': '2014-04-01T15:36:52.380', 'Id': '23320'},63_297:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was wondering how I could go about creating an algorithm that gets all the cliques in a graph in PSPACE</p>\n\n<p>So far, based on some of the readings I've done, I am considering to use bit-strings (that have a length equal to the number of vertices in the graph). Then, for every possible subset of the vertices, a turing machine writes bit-strings in order and checks if the subset is a clique. On the side there will also be a counter that counts the number of cliques </p>\n\n<p>This is where I am stuck so far. Can anyone help me improve my solution (or tell me whats wrong with it)? Thanks very much</p>\n", 'ViewCount': '48', 'ClosedDate': '2014-04-02T06:20:16.330', 'Title': 'Clique and PSPACE', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T06:20:01.417', 'LastEditDate': '2014-04-02T06:20:01.417', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16368', 'Tags': '<complexity-theory><graphs><space-complexity><enumeration>', 'CreationDate': '2014-04-02T01:55:22.447', 'Id': '23331'},63_298:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>The following may contain errors. It is precisely because I am not\nsure I understand the topic that I am asking questions. I do not have\nbooks about it and could not find an adequate reference on the web.</em></p>\n\n<p>I am discussing a problem regarding an enumeration of strings that\nshould be in <strong>amortized constant delay</strong>. From what I understood (but\nunderstanding that is part of my question), this means that the average\ntime taken for each answer should be independent of the size of the\nanswer, so that the total cost is $O(n)$ where $n$ is the number of\nanswers.</p>\n\n<p>My discussion partner went on to assert (I believe) that amortized\nconstant delay is possible for enumerating the strings accepted by a\ntrie, but not for enumerating the paths of a DAG. And I am at loss to\nsee a significant difference, since proper use of a stack should let\nme explore the DAG as if it had been exploded into a trie (by\nduplicating whatever is below a merge vertex).</p>\n\n<p>The only real difference I can see is that the accepting nodes of a\ntrie can be labeled with a single symbol identifier characterizing the accepted word (turning the trie\ninto a Moore machine) so that the total cost is only a traversal of\nthe trie, with single step output of the symbol label when traversing an\naccepting node.</p>\n\n<p>Such labeling identification is not possible for a DFA structured as a DAG, since an\naccepting node can correspond to different paths. The only way to name\npaths is to describe them in extenso (or nearly so: enough to disambiguate merges), so that the cost\nof the output by itself is already something like $O(n\\times s)$ where\n$s$ is the size of the longest path, thus entailing the same time cost\njust for doing the output.</p>\n\n<p>Where do I err, and what is the accepted wisdom and knowledge on this topic?\nPointers to web references are useful too.</p>\n', 'ViewCount': '31', 'Title': 'What is hiding behind amortized constant delay enumeration?', 'LastActivityDate': '2014-04-02T10:58:09.810', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<complexity-theory><graphs><strings><amortized-analysis><enumeration>', 'CreationDate': '2014-04-02T10:58:09.810', 'Id': '23337'},63_299:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a problem that I encountered that boils down to the following:</p>\n\n<p>Considered this directed graph I found on Google: <img src="http://i.stack.imgur.com/BTt0Z.png" alt="enter image description here"></p>\n\n<p>I have the following information available to me</p>\n\n<pre><code>Node: Ancestors\n\n1 : 3\n2 : 1 3 5 7\n3 : Null\n4 : 3 5\n5 : 3\n6 : 1 2 3 4 5 7 \n7 : 1 3\n8 : 1 2 3 4 5 6 7\n</code></pre>\n\n<p>How can I re-construct the original graph in a reasonably efficient manner? I basically have large sets of data that I would like to have visualized as branches and merges(similar to a code repository, but not quite).</p>\n\n<p>Note: While I believe my data shouldn\'t be disjoint, I\'m somewhat certain my data is incomplete and will produce disjoint graphs, or at the very least have many separate "roots". There is no ordering to the data, everything must be considered random, the lists can also be thought of as sets. </p>\n', 'ViewCount': '39', 'Title': 'Reconstruct directed graph from list of ancestors for each node', 'LastEditorUserId': '16433', 'LastActivityDate': '2014-04-04T13:27:17.890', 'LastEditDate': '2014-04-04T02:55:04.440', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16433', 'Tags': '<algorithms><graph-theory><graphs><sets>', 'CreationDate': '2014-04-04T02:30:23.000', 'Id': '23408'},63_300:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The question is:</p>\n\n<p>How many different undirected graphs are there with n nodes and no parallel edges but may include self-loops?</p>\n\n<p>I've been wracking my brain over this for hours now. Basically, I know that for 1 vertex, there are 2 graphs. For 2 vertices, there are 8 graphs. For 3 vertices, there are 64 graphs. However, I can't connect these numbers without my answer for 1 vertices not working. For example, the equation number of graphs equals $2^{3n-3}$ works for 2 and 3 vertices, but not for 1. Any opinions on the connecting equation?</p>\n", 'ViewCount': '28', 'Title': 'number of different undirected graphs?', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-05T01:37:42.160', 'LastEditDate': '2014-04-05T01:35:33.577', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16465', 'Tags': '<graphs>', 'CreationDate': '2014-04-05T01:06:05.667', 'Id': '23440'},63_301:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '477', 'Title': 'Best solutions to 6 degrees of separation', 'LastEditDate': '2014-04-06T21:52:34.007', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11306', 'FavoriteCount': '2', 'Body': '<p>From purely my knowledge of computer science a simple breadth first search from root A in search of node B, while keeping track of the depth of the tree, would be the most effective way to check whether A and B have 6 degrees of separation. If I simply wanted to check whether B is within 6 degrees I could also limit my depth to 6. </p>\n\n<p>I have heard however that there are better ways of doing this using bidirectional methods which involve some heuristics. I was wondering if someone could explain the most effective way of doing this and compare space and time complexity between the different approaches. Thanks!</p>\n\n<p>And as a followup, what would be a good algorithm for finding the degree of separation between two arbitrary nodes A and B and the path between them?</p>\n', 'Tags': '<algorithms><graphs><search-algorithms>', 'LastEditorUserId': '11306', 'LastActivityDate': '2014-04-06T21:52:34.007', 'CommentCount': '3', 'AcceptedAnswerId': '23479', 'CreationDate': '2014-04-06T18:03:22.393', 'Id': '23477'},63_302:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I got a problem related to graph theory - </p>\n\n<p>Consider an undirected graph \u0729 where self-loops are not allowed. The vertex set of G is\n{(i,j):1&lt;=i,j &lt;=12}. There is an edge between (a, b) and (c, d) if |a-c|&lt;=1 and |b-d|&lt;=1\nThe number of edges in this graph is </p>\n\n<p>Answer is given as 506\nbut I am calculating it as 600, please see attachment.</p>\n\n<p>I am unable to get why it is coming as 506 instead of 600.</p>\n\n<p>Thanks<img src="http://i.stack.imgur.com/IKmgx.png" alt="enter image description here"></p>\n', 'ViewCount': '53', 'Title': 'number of edges in a graph', 'LastEditorUserId': '16546', 'LastActivityDate': '2014-04-08T14:01:25.283', 'LastEditDate': '2014-04-08T07:50:57.403', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23533', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11750', 'Tags': '<graph-theory><graphs><combinatorics><counting>', 'CreationDate': '2014-04-08T06:39:12.977', 'Id': '23532'},63_303:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose I have a source node $S$, destination node $D$ and a set $A$ of intermediate nodes $P_1, P_2, \\dots$ in an edge-weighted undirected graph. I want to find the vertex $P_i\\in A$ that minimizes $\\mathrm{dist}(S, P_i) + \\mathrm{dist}(D, P_i)$?  In addition, the overall path from $S$ to $D$ should contain only one node from the set $A$.  What is an efficient algorithm for this? I don't want to go with brute-force approach.</p>\n", 'ViewCount': '114', 'Title': 'Minimum path between two vertices passing through a given set exactly once', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T19:05:53.140', 'LastEditDate': '2014-04-09T13:09:03.500', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16563', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-04-08T18:26:55.787', 'FavoriteCount': '1', 'Id': '23558'},63_304:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '37', 'Title': 'Construct a digraph given its in-degree and out-degree distribution', 'LastEditDate': '2014-04-09T09:53:02.030', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16571', 'FavoriteCount': '1', 'Body': "<p>Could anyone help me with this algorithmic problem:</p>\n\n<p>Given the in and out degrees of a set of vertices, is it possible to determine if there exist a valid graph respecting this constraint? The graph can allow self loops but not parallel edges.</p>\n\n<p>Here's an example: </p>\n\n<pre><code>Vertex A: in=1 out=1\nVertex B: int=2 out=2\n</code></pre>\n\n<p>For which we can construct this graph:</p>\n\n<pre><code>A =&gt; B\nB =&gt; A\nB =&gt; B\n</code></pre>\n\n<p>Here's another example:</p>\n\n<pre><code>Vertex A: in=0 out=1\nVertex B: in=1 out=1\n</code></pre>\n\n<p>Here, we obviously cannot construct such graph.</p>\n\n<p>I have been scratching my head around this problem. \nFor an undirected graph, there exist a simple algorithm to solve this problem but I cannot find any way to derive a solution for directed graphs.</p>\n\n<p>I have the intuition that we could find a matching algorithm in the bipartite graph representing the in and out edges of the graph and where each out-edge would be matched to an in-edge. </p>\n\n<p>However the usual approach can produce a graph with parallel edges.</p>\n\n<p>For example 1, a valid solution could be:</p>\n\n<pre><code>A- A+: A =&gt; A\nB- B+: B =&gt; B\nB- B+: B =&gt; B\n</code></pre>\n\n<p>Which is not a valid graph.</p>\n\n<p>Also, please note that I am more interested in determining if a valid solution exists. It's not necessary to provide or construct such solution.  </p>\n", 'Tags': '<algorithms><graphs>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T09:53:02.030', 'CommentCount': '2', 'AcceptedAnswerId': '23578', 'CreationDate': '2014-04-09T00:39:42.843', 'Id': '23575'},63_305:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '265', 'Title': 'Possible to connect arbitrary number of dots without intersections?', 'LastEditDate': '2014-04-11T19:03:57.950', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16060', 'FavoriteCount': '0', 'Body': "<p>A (now closed) question on SO made me think about the following problem:</p>\n\n<blockquote>\n  <p>Given an arbirtary number of points (2D), draw a path that consists of\n  straight lines between points, visits each point exactly once and does\n  not intersect with itself.</p>\n</blockquote>\n\n<p>I came to the conclusion that this is easy if I can chose starting and ending point:</p>\n\n<pre><code>sort points by their x coordinate\nuse point with mininmal x coordinate as starting point\nconnect remaining points in left-to-right order\n</code></pre>\n\n<p>If there are multiple points with the same x value, start with the point with minimal y value and go bottom-up. This way, no intersections can occur.</p>\n\n<p>Now my question is: <strong>is this still possible if start and end point are fixed?</strong>\nI assume that there are well known algorithms for this problem, but my search didn't reveal any useful results.</p>\n\n<p>As @hyde points out, there is no solution if more than two points are on a straight line and start/end points are not the outermost points.</p>\n", 'Tags': '<graphs><computational-geometry>', 'LastEditorUserId': '16060', 'LastActivityDate': '2014-04-11T19:12:40.240', 'CommentCount': '3', 'AcceptedAnswerId': '23672', 'CreationDate': '2014-04-11T12:35:50.710', 'Id': '23671'},63_306:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What is the difference between maximal flow and maximum flow. I am reading these terms while working on Ford Fulkerson algorithms and they are quite confusing. I tried on internet, but couldn't get a reasonable answer. I believe maximum flow is quite clear as it means maximum amount of flow that can be transferred from source to sink in a network, but what exactly is maximal flow.</p>\n\n<p>Please answer in layman terms if possible.</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '100', 'Title': 'What is the difference between maximal flow and maximum flow?', 'LastActivityDate': '2014-04-14T01:38:17.857', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16750', 'Tags': '<algorithms><graph-theory><graphs><network-flow>', 'CreationDate': '2014-04-14T00:31:01.150', 'Id': '23763'},63_307:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '57', 'Title': 'Shortest directed path connecting given subset of vertices', 'LastEditDate': '2014-04-14T18:27:40.627', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6615', 'FavoriteCount': '1', 'Body': '<p>Given</p>\n\n<ul>\n<li>weighted directed graph $G = (V,E,w)$, where $w : E \\to \\mathbb R^+$</li>\n<li>source vertex $v \\in V$</li>\n<li>vertex subset $U \\subset V$</li>\n</ul>\n\n<p>how to find a shortest directed path from $v$ containing all vertices from $U$? Note that such path may contain vertices that are not in $U$.</p>\n\n<ol>\n<li>Does such problem have a name?</li>\n<li>How to find a solution?</li>\n</ol>\n', 'Tags': '<graph-theory><terminology><shortest-path><weighted-graphs>', 'LastEditorUserId': '6615', 'LastActivityDate': '2014-04-14T18:27:40.627', 'CommentCount': '2', 'AcceptedAnswerId': '23789', 'CreationDate': '2014-04-14T14:52:04.890', 'Id': '23784'},63_308:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29#Proof" rel="nofollow">Wikipedia</a> shows how one can determine the minimum vertex cover in a bipartite graph ($G(X \\cup Y, E)$) in polytime from a maximum flow using alternating paths. However, I read that the (S,T) cut (extracted from the final residual network) can also be used to determine the minimum vertex cover:</p>\n\n<p>$$(X\\cap T)\\cup(Y\\cap S)$$</p>\n\n<p>If this expression is a correct alternative, I don\'t have an intuition for why it\'s true. The best intuition I\'ve been able to come up with is: Select each vertex on the left (X) that has a positive flow leading up to it and select each vertex on the right if there is no flow leading up to it. Why is this set equal to the minimum vertex cover?</p>\n', 'ViewCount': '13', 'Title': 'Determining the minimum vertex cover in a bipartite graph from a maximum flow/matching using the residual network rather than alternating paths', 'LastActivityDate': '2014-04-17T01:33:45.290', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23873', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graphs><network-flow><bipartite-matching>', 'CreationDate': '2014-04-17T00:27:40.150', 'Id': '23871'},63_309:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading a paper for recognizing interval graphs. Here is an excerpt from the paper:</p>\n\n<blockquote>\n  <p>Each interval graph has a corresponding interval model in which two intervals overlap if\n      and only if their corresponding vertices are adjacent. Such a representation is usually far\n      from unique. To eliminate uninteresting variations of the endpoint orderings, we shall\n      consider the following block structure of endpoints: Denote the right (resp. left) endpoint of\n      an interval $u$ by $R(u)$ (resp. $L(u)$). In an interval model, define a maximal contiguous set of\n      right (resp. left) endpoints as an R-block (resp. L-block). Thus, the endpoints can be grouped\n      as a left-right block sequence. Since an endpoint block is a set, the endpoint orderings within\n      a block are ignored. It is easy to see that the overlapping relationship does not change if one\n      permute the endpoint order within each block. Define two interval models for $G$ to be\n      equivalent if either their left-right block sequences are identical or one is the reversal of the\n      other. </p>\n</blockquote>\n\n<p>I am unable to understand the notion of equivalent intervals. Can someone help me?</p>\n', 'ViewCount': '37', 'Title': 'Recognizing interval graphs--"equivalent intervals"', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-18T06:40:51.167', 'LastEditDate': '2014-04-18T06:40:51.167', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23890', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11703', 'Tags': '<algorithms><graph-theory><graphs><intervals>', 'CreationDate': '2014-04-17T11:39:56.467', 'Id': '23885'},63_310:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '49', 'Title': 'Control flow graphs - Tree decomposition', 'LastEditDate': '2014-04-18T03:42:01.937', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11108', 'FavoriteCount': '1', 'Body': '<p><img src="http://i.stack.imgur.com/k1d7R.png" alt="Control flow graphs"></p>\n\n<p>Considering above terminologies for drawing control flow graphs for any program, it is very simple. For example :</p>\n\n<pre><code>While A\nif B\ndo ..\nelse do ..\nend while\n</code></pre>\n\n<p>For above example, while doing decomposition, I can say its </p>\n\n<blockquote>\n  <p>D2 (D1)</p>\n</blockquote>\n\n<p>i.e while  and then inside while, its if-then-else.</p>\n\n<p>Considering same situation. How can you represent </p>\n\n<blockquote>\n  <p>CONTINUE and BREAK statements</p>\n</blockquote>\n\n<p>Ever for  <code>FOR statement</code> there is no defined terminology like for <code>while</code> and <code>if then else</code>. <code>FOR statement</code> falls under <code>while</code>.</p>\n\n<p>My prof says in theory, there is nothing about <code>Break and continue statement</code> and I couldnt find anything online too.</p>\n\n<p>For example :</p>\n\n<pre><code># include &lt;stdio.h&gt;\nint main(){\n   float num,average,sum;\n   int i,n;\n   printf("Maximum no. of inputs\\n");\n   scanf("%d",&amp;n);\n   for(i=1;i&lt;=n;++i){\n       printf("Enter n%d: ",i);\n       scanf("%f",&amp;num);\n       if(num&lt;0.0)\n       break;                     //for loop breaks if num&lt;0.0\n       sum=sum+num;\n}\n  average=sum/(i-1);       \n  printf("Average=%.2f",average);\n  return 0;\n}\n</code></pre>\n\n<p>Control flow graph for this is as below: the nodes has line number written : (Sorry the image is side ways)\n<img src="http://i.stack.imgur.com/jVqRO.jpg" alt="enter image description here"></p>\n\n<p>I decomposed this as : </p>\n\n<pre><code>P1;P1;D2(P1;P1;D1);P1\n\n* P1 represents set of statements outside loops\n</code></pre>\n\n<p>I\'m not sure if this is correct. My professors says to use something as D22 for break, like create a new term from above image.</p>\n\n<blockquote>\n  <p>My main question here is the decomposition. I Know that i drew the\n  CFG correctly, but is the decomposition correct according to the first\n  image?. The break state kind of creates a while as you can see in CFG,\n  but i\'m not sure if it has to be considered as while and I guess we\n  cannot, as per my professor.</p>\n</blockquote>\n\n<p>I am working on this and wanted to know, if anyone has come across something for Break and continue statements while decomposition of graphs, please let me know.</p>\n\n<p>Thanks.</p>\n\n<p>PS : Please, Let me know, if am unclear and if anymore info is needed. I can probably write down an example and upload the picture.</p>\n', 'Tags': '<graphs><software-engineering><software-testing>', 'LastEditorUserId': '11108', 'LastActivityDate': '2014-04-18T12:33:07.703', 'CommentCount': '5', 'AcceptedAnswerId': '23912', 'CreationDate': '2014-04-18T03:27:21.750', 'Id': '23905'},63_311:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm given a graph and two weight functions, $w_1$ and $w_2$, such that there doesn't exist a negative loop in the graph in $w_1$ and $w_2$. I'm also given two vertices, $s$ and $t$, and am asked to find the lightest path from $s$ to $t$ in relation to $w_1$, out of all the lightest paths from $s$ to $t$ in relation to $w_2$.</p>\n\n<p>I get that this question begs for me to modify Dijkstra somehow, but I just can't seem to find the intuition to do so. Any guidance would be appreciated!</p>\n", 'ViewCount': '35', 'Title': 'Using Dijkstra to find shortest path in relation to two weight functions?', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-20T20:26:30.380', 'LastEditDate': '2014-04-20T20:26:30.380', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16769', 'Tags': '<shortest-path><weighted-graphs>', 'CreationDate': '2014-04-19T18:02:17.503', 'Id': '23938'},63_312:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a bipartite graph similar to the marriage problem, where there are M males and N females, and a 1:1 matching between males and females is desired (with the remainder of the more populous gender remaining unmatched).</p>\n\n<p>The differences between my problem and existing research I've found:</p>\n\n<ol>\n<li>Want to maximize the number of pairings at the expense of stability. Stability is nice as a secondary objective, but not required.</li>\n<li>Preference lists are not exhaustive. Eg. m_1 only wants n_3 and cannot be matched with any other.</li>\n</ol>\n\n<p>Can anyone point me in some possible directions?</p>\n", 'ViewCount': '33', 'Title': 'Marriage algorithm that maximizes number of pairings', 'LastActivityDate': '2014-04-21T22:40:51.340', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16969', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2014-04-21T22:40:51.340', 'Id': '24008'},63_313:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '39', 'Title': 'Concrete and simple applications for bipartite graphs', 'LastEditDate': '2014-04-23T19:27:43.003', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16536', 'Body': '<p>I am looking for concrete and simple problems that may be solved using bipartite graphs or bipartite graph properties. Any idea along with explanations are welcome.</p>\n', 'ClosedDate': '2014-04-24T17:37:00.217', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'LastEditorUserId': '16536', 'LastActivityDate': '2014-04-24T17:03:52.407', 'CommentCount': '3', 'AcceptedAnswerId': '24083', 'CreationDate': '2014-04-23T19:20:35.893', 'Id': '24057'},63_314:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G$ be a undirected simple graph with 1000 nodes. My aim to enumerate all minimum cuts in the graph, but we have exponential many minimum cuts. So instead of enumerating all minimum cuts can we do the following task in polynomial time.</p>\n\n<ol>\n<li>Enumerating first $n^2$ mincuts in increasing order of size. </li>\n</ol>\n', 'ViewCount': '18', 'ClosedDate': '2014-04-25T07:05:28.190', 'Title': 'Finding the minimum size of mincut in graph', 'LastEditorUserId': '6522', 'LastActivityDate': '2014-04-27T16:37:41.930', 'LastEditDate': '2014-04-27T16:37:41.930', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6522', 'Tags': '<algorithms><graphs><search-algorithms>', 'CreationDate': '2014-04-25T06:13:20.707', 'Id': '24096'},63_315:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to find a graph that does not get optimally colored by the Briggs coloring algoritm. Any suggestions on a type of graph to look for?</p>\n', 'ViewCount': '18', 'ClosedDate': '2014-04-29T22:38:59.250', 'Title': 'Briggs algorithm non optimal situation', 'LastActivityDate': '2014-04-25T16:11:04.377', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17080', 'Tags': '<algorithms><graph-theory><graphs><colorings>', 'CreationDate': '2014-04-25T16:11:04.377', 'Id': '24110'},63_316:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G$ be a graph of diameter 2 ($\\forall u,v\\in V: d(u,v)\\leq2$).</p>\n\n<blockquote>\n  <p><strong>Can we decide if $G$ has Hamiltonian path in poly time? What about digraphs?</strong></p>\n</blockquote>\n\n<hr>\n\n<p>Perhaps some motivation is in place:</p>\n\n<p>the question arises from Dirac\'s theorem which states that if $\\forall v\\in V:d(v)\\geq \\frac{n}{2}$ then the graph is Hamiltonian, as well as it\'s generalizations (the Ghouila-Houri theorem and the result from Bang-Jensen and Gutin\'s book).</p>\n\n<p><a href="http://cstheory.stackexchange.com/questions/22247/does-deltag-delta-g-geq-n-imply-strong-connectivity/22299#22299">I\'ve shown here</a> that these degree requirements imply that the graph has diameter 2, and was wondering if such graphs can be decided without the degree requirements (strong gut feeling: No).</p>\n', 'ViewCount': '72', 'Title': 'Is Hamiltonian path NP-hard on graphs of diameter 2?', 'LastEditorUserId': '12969', 'LastActivityDate': '2014-04-28T11:16:29.733', 'LastEditDate': '2014-04-28T11:16:29.733', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12969', 'Tags': '<graph-theory><graphs><np-complete><hamiltonian-path>', 'CreationDate': '2014-04-27T22:41:46.630', 'Id': '24159'},63_317:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I get how to reduce 3-SAT to 3-COLOR, but I'm not sure how to do it the other way around. Does anyone  have any hints or insight?  </p>\n", 'ViewCount': '73', 'ClosedDate': '2014-04-29T11:50:26.703', 'Title': 'Reducing from 3-COLOR to 3-CNF SAT?', 'LastActivityDate': '2014-04-28T17:53:31.043', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'OwnerDisplayName': 'user17148', 'PostTypeId': '1', 'Tags': '<graphs>', 'CreationDate': '2014-04-28T17:24:47.323', 'Id': '24190'},63_318:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '26', 'Title': 'Given a complete, weighted and undirected graph $G$, complexity of finding a path with a specific cost', 'LastEditDate': '2014-04-29T18:42:14.217', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17185', 'FavoriteCount': '1', 'Body': '<p>Given a fully connected graph $G$, suppose that we are searching for a simple path $P$ with a specific cost $c$. </p>\n\n<p>Is answering to that problem <em>yes</em> or <em>no</em> equivalent to subset-sum problem?\nWhat would be the complexity of finding such path?</p>\n\n<p>I have made a reduction from subset-sum problem:</p>\n\n<p>If each number in a set $S$ is a vertex of $G$ and weight of $&lt;i,j&gt;$ is $|i-j|$, then answering the question above <em>yes</em> or <em>no</em> is the same as solving the sumbet-sum problem.</p>\n\n<p>P.S. The initial vertex I have visited is added to the cost.</p>\n\n<p><strong>Edit: Edge weights</strong></p>\n', 'Tags': '<algorithms><graph-theory><graphs><decision-problem>', 'LastEditorUserId': '17185', 'LastActivityDate': '2014-04-29T20:37:29.247', 'CommentCount': '4', 'AcceptedAnswerId': '24233', 'CreationDate': '2014-04-29T17:40:06.137', 'Id': '24231'},63_319:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Can anyone provide an example of an ordered graph for which the following algorithm produces the the incorrect longest path?</p>\n\n<pre><code>let A = V[1]\nlongestPath = 0\n\nwhile there is an edge out of A do\n     choose edge (A,V[i]) for which i is as small as possible\n     set A = V[i]\n     LongestPath = LongestPath + 1\nend while\nreturn longestPath\n</code></pre>\n\n<p>Thanks for the comments. I've tried several examples but I dont see why this algorithm would not work</p>\n\n<p>If we start with a small 3 node graph with nodes A,B,C. If node A has an edge that goes to B and and edge that goes to C, And B has one edge that goes to C. Then starting with node A we would take the shortest path per the algorithm and go to node b. From node b we would go to node c and the algorithm works.</p>\n", 'ViewCount': '28', 'ClosedDate': '2014-05-01T02:46:10.497', 'Title': 'Longest path of a directed ordered graph', 'LastEditorUserId': '15850', 'LastActivityDate': '2014-05-01T03:14:35.177', 'LastEditDate': '2014-05-01T03:14:35.177', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15850', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2014-05-01T00:36:13.987', 'Id': '24278'},63_320:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have been assigned a fun project: design and implement a program that maintains the data of a simple social network. Each person in the network should have a profile that contains his name, current status, and a friends list.</p>\n\n<p>I think it is clear that the project calls for the use of the ADT graph. Each vertex represents a person in the network and an edge between vertices a friendship. Now, the graph may not be connected because some members do not have any friends in the network. With that in mind, consider this feature that must be implemented:</p>\n\n<p><strong>\u2022The network must have a feature that computes the \u201cemergency phone chain," make sure that each member in the network is contacted, and only by one person. Any of the people in the network may initiate the first call. Utilize a depth-first graph traversal algorithm.</strong></p>\n\n<p>Now, what I think my professor is suggesting is merely a full traversal of the graph. How is that possible for an unconnected graph? Any suggestions?</p>\n\n<p>(btw, the wording above is somewhat unclear - does the professor mean that everyone in the network is contact by the same one person? Thoughts? I would ask her, but she is unavailable until next week.)</p>\n', 'ViewCount': '20', 'Title': 'Is traversing an unconnected graph possible?', 'LastActivityDate': '2014-05-03T04:06:37.753', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17288', 'Tags': '<graphs><weighted-graphs>', 'CreationDate': '2014-05-03T01:31:11.387', 'Id': '24334'}