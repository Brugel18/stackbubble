{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>If I were to let the variables be the propositions and, constraint be all clauses being satisfied, which technique would be more effective in solving 3-SAT? <a href="http://en.wikipedia.org/wiki/Look-ahead_%28backtracking%29#Look_ahead_techniques" rel="nofollow">Forward checking</a> or <a href="http://en.wikipedia.org/wiki/Arc_consistency#Arc_consistency" rel="nofollow">arc consistency</a>? From what I gathered forward-checking is $O(n)$, while Arc consistency is about $O(8c)$ where c is the number of constraints (According to this <a href="http://www.cs.ubc.ca/~kevinlb/teaching/cs322%20-%202006-7/Lectures/lect11.pdf" rel="nofollow">page</a>). So perhaps forward -checking is faster somehow? How should I determine which to use?</p>\n', 'ViewCount': '591', 'Title': 'Forward checking vs arc consistency on 3-SAT', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-28T18:01:07.223', 'LastEditDate': '2012-05-28T18:01:07.223', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1556', 'Tags': '<algorithms><satisfiability><heuristics><3-sat><sat-solvers>', 'CreationDate': '2012-05-28T07:03:31.467', 'Id': '2120'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>EDIT: ad hoc speed-ups are excluded.</p>\n\n<p>We have the result that <a href="http://homepages.cwi.nl/~rdewolf/resolutionlowerbound.pdf" rel="nofollow">propositional resolution requires exponential time</a>. The resolution result uses the proof of the pigeonhole principle as an example of a proof that takes exponential time. </p>\n\n<p>Let\'s also say we have a hypothetical algorithm M for SAT that runs in polynomial time. \n<strong>EDIT : M is correct, complete, sound, and general-purpose; it contains no ad hoc speed-up rules for the pigeonhole principle or any other theorem that requires exponential length in resolution.</strong> M takes its input in clausal form; we\'ll set up the input like a resolution proof where the consequent is negated to lead to unsatisfiability if the theorem is true. Now let\'s consider how the proof of the pigeonhole principle works in algorithm M with a strong condition C added:</p>\n\n<p>C. We are given that M simply transforms one clause (or set of clauses) to another clause (or set of clauses). Every such transformation is logically sound.</p>\n\n<p>Some questions; please point out the most fatal flaws:</p>\n\n<ol>\n<li>Given condition C above, and since M\'s rule system must be finite, correct, and complete, can we conclude that there is a translation from M\'s rule system to an equivalent set of expansions based on resolution?</li>\n<li>Are we now in a place where we can conclude that M would produce a computation that could be mapped by the translation in point 1 above into an impossible polynomial-time resolution proof of the pigeonhole principle?</li>\n</ol>\n', 'ViewCount': '178', 'Title': 'Resolution complexity versus a constrained SAT algorithm', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-05T20:21:32.660', 'LastEditDate': '2012-06-05T20:21:32.660', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<complexity-theory><logic><satisfiability><sat-solvers>', 'CreationDate': '2012-06-05T04:12:51.750', 'FavoriteCount': '1', 'Id': '2230'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Modern SAT-solvers are very good at solving many real-world examples of SAT instances. However, we know how to generate hard ones: for instance use a <a href="http://cstheory.stackexchange.com/q/6755/1037">reduction from factoring to SAT</a> and give the RSA numbers as input.</p>\n\n<p>This raises the question: what if I take an easy example of factoring. Instead of taking two large primes on $n/2$ bits, what if I take a prime $p$ on $\\log n$ bits and a prime q on $n/\\log n$ bits, let $N = pq$ and the encode $\\mathrm{FACTOR}(N)$ as a SAT instance. $N$ would be an easy number to factor by brute-force search or sieve methods since one of the factors in so small; does a modern SAT-solver with some standard reduction from factoring to SAT also pick up on this structure?</p>\n\n<p><strong>Can top SAT-solvers factor $N = pq$ where $|p| = \\log n$ quickly?</strong></p>\n', 'ViewCount': '190', 'Title': 'Can top SAT-solvers factor easy numbers?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-22T05:29:43.467', 'LastEditDate': '2012-07-22T05:14:29.103', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<complexity-theory><satisfiability><sat-solvers><factoring>', 'CreationDate': '2012-07-22T00:41:51.747', 'FavoriteCount': '4', 'Id': '2857'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>What's the complexity of Conflict-Driven Clause Learning SAT solvers, compared to DPLL solvers? Was it proven that CDCL is faster in general? Are there instances of SAT that are hard for CDCL but easy for DPLL?</p>\n", 'ViewCount': '138', 'Title': 'Running time of CDCL compared to DPLL', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-25T21:52:35.260', 'LastEditDate': '2012-11-25T21:52:35.260', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3015', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2345', 'Tags': '<complexity-theory><time-complexity><efficiency><satisfiability><sat-solvers>', 'CreationDate': '2012-08-03T07:31:02.560', 'Id': '3014'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '205', 'Title': 'Introduction into first order logic verification', 'LastEditDate': '2012-08-13T05:27:52.237', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2436', 'FavoriteCount': '1', 'Body': '<p>I am trying to teach myself different approaches to software verification. I have read some articles. As far as I learned, propositional logic with temporal generally uses model checking with SAT solvers (in ongoing - reactive systems), but what about first order Logic with temporal? Does it use theorem provers? Or can it also use SAT?</p>\n\n<p>Any pointers to books or articles for beginners in this matter is much appreciated.</p>\n', 'Tags': '<reference-request><logic><formal-methods><sat-solvers><software-verification>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-13T05:27:52.237', 'CommentCount': '2', 'AcceptedAnswerId': '3114', 'CreationDate': '2012-08-09T20:52:33.677', 'Id': '3110'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>How can i prove that the conversion from CNF to DNF is NP-Hard. I'm not asking for an answer, just some suggestions about how to go about proving it.</p>\n", 'ViewCount': '646', 'Title': u'CNF to DNF \u2014 conversion is NP Hard', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-12T22:32:03.810', 'LastEditDate': '2012-09-12T22:32:03.810', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '7', 'OwnerDisplayName': 'jkjk', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-hard><satisfiability><sat-solvers>', 'CreationDate': '2011-12-14T15:46:55.587', 'FavoriteCount': '4', 'Id': '3513'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '158', 'Title': 'Unification vs. SAT solver', 'LastEditDate': '2012-09-21T13:12:01.017', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2879', 'FavoriteCount': '1', 'Body': '<p>I read on Wikipedia that <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29">unification</a> is a process of solving the satisfability problem.</p>\n\n<p>At the same time, I know that such solvers are called "SAT solvers" or "SMT solvers". So, are they different names for the same thing?</p>\n\n<p>If you say that they are different, please point out a flaw in my treatment. </p>\n', 'Tags': '<terminology><sat-solvers><unification>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-21T13:12:01.017', 'CommentCount': '1', 'AcceptedAnswerId': '4652', 'CreationDate': '2012-09-21T08:05:59.773', 'Id': '4650'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>If I have a system of N polynomial equations with N unknowns in GF(2):</p>\n\n<ul>\n<li>What are some good methods to solve them?</li>\n<li>What are some software packages or libraries that implement this?</li>\n<li>What's the highest value of N that can be reasonable solved?</li>\n</ul>\n\n<p>Now, my root interest isn't GF, it's crypto.  Here's my reasoning:</p>\n\n<ol>\n<li>Any function from a n-dimensional binary vector to {0,1} can be represented as a GF(2) polynomial function of n variables.</li>\n<li>Thus, for instance, any cipher from (Plaintext, Key) to Ciphertext can be represented as a series of equations (one for each bit in the ciphertext), each a GF(2) polynomial of (p-bits + k-bits) variables.</li>\n<li>Thus, if we know P and C, and we can solve systems of GF(2) equations, we can determine K.</li>\n</ol>\n", 'ViewCount': '115', 'Title': 'Complexity of GF(2) and applications to cryptography', 'LastActivityDate': '2013-09-11T23:27:21.163', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9682', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '6824', 'Tags': '<algorithms><cryptography><discrete-mathematics><sat-solvers>', 'CreationDate': '2013-02-11T13:38:17.613', 'FavoriteCount': '1', 'Id': '9678'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '521', 'Title': 'Understanding DPLL algorithm', 'LastEditDate': '2013-03-31T14:44:46.170', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7509', 'FavoriteCount': '1', 'Body': u'<p>I\'m trying to understand <a href="http://en.wikipedia.org/wiki/DPLL_algorithm" rel="nofollow">DPLL algorithm</a> for solving SAT problem. And here it is:</p>\n\n<pre><code>Algorithm DPLL\n  Input: A set of clauses \u03a6.\n  Output: A Truth Value.\nfunction DPLL(\u03a6)\n   if \u03a6 is a consistent set of literals\n       then return true;\n   if \u03a6 contains an empty clause\n       then return false;\n   for every unit clause l in \u03a6\n      \u03a6 \u2190 unit-propagate(l, \u03a6);\n   for every literal l that occurs pure in \u03a6\n      \u03a6 \u2190 pure-literal-assign(l, \u03a6);\n   l \u2190 choose-literal(\u03a6);\n   return DPLL(\u03a6 \u2227 l) or DPLL(\u03a6 \u2227 not(l));\n</code></pre>\n\n<p>At first, I don\'t clearly understand how <code>unit-propagate(l, \u03a6)</code>, <code>pure-literal-assign(l, \u03a6)</code> and <code>choose-literal(\u03a6)</code> work. I\'ll try to guess on particular examples. Correct me please if I do something wrong. </p>\n\n<ul>\n<li><p>For the first one </p>\n\n<p><code>unit-propagate(a, (0 v -a) \u2227 (a v b) \u2227 (b v d) \u2227 (f v g) v ...)</code> </p>\n\n<p>we will have </p>\n\n<p><code>((0 v -0) \u2227 (0 or 1) \u2227 (1 v d) \u2227 (f v g) \u2227 ... = (f v g) v ...</code>,</p>\n\n<p>having <code>a = 0</code>, <code>b = 1</code>.</p></li>\n<li><p>For second procedure</p>\n\n<p><code>pure-literal-assign(a, (a v b v c) \u2227 (d v -b v a) \u2227 (-d v b))</code></p>\n\n<p>result is </p>\n\n<p><code>(b v c) \u2227 (d v -b) \u2227 (-d v b)</code>,</p>\n\n<p>assigning <code>a = 1</code>.</p></li>\n<li><p>And finally <code>choose-literal(\u03a6)</code> just returns some random (in common case) unassigned literal for further computations.</p></li>\n</ul>\n\n<p>Now, I don\'t understand why algorithm has such strange conditions for finishing? Why does it work?</p>\n\n<p>Thanks!</p>\n', 'Tags': '<algorithms><logic><satisfiability><sat-solvers>', 'LastEditorUserId': '7509', 'LastActivityDate': '2013-03-31T17:36:48.023', 'CommentCount': '0', 'AcceptedAnswerId': '10933', 'CreationDate': '2013-03-31T08:26:51.050', 'Id': '10932'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>If I have a hard problem, one standard approach is to express it as a SAT instance and try running a SAT solver on it.  Another standard approach is to express it as a constraint satisfaction problem, and try using a CSP solver.  The two feel somehow vaguely similar in what sorts of problems can be naturally expressed in their input format.</p>\n\n<p>Are there any guidelines or rules of thumb for how to recognize, for a given problem, which approach is more likely to yield good results?  Is there any guidance anyone can offer about which sorts of problems can be handled better by SAT solvers than by CSP solvers, or vice versa?</p>\n\n<p>(Obviously, there are some easy problems that can be solved by both approaches.  There are also some hard problems that can't be usefully solved by either approach.  Let's set those aside.  The case where guidance is most helpful are problems where either SAT solvers perform better than CSP solvers, or where CSP solvers perform better than SAT solvers.  How do I recognize when a SAT solver is likely to be a better fit than a CSP solver, or when a CSP solver is likely to be a better fit than a SAT solver -- i.e., which approach to try first?)</p>\n", 'ViewCount': '140', 'Title': 'When to use SAT vs Constraint Satisfaction?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-28T15:06:43.883', 'LastEditDate': '2013-05-28T07:15:02.563', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<heuristics><sat-solvers><constraint-programming>', 'CreationDate': '2013-05-28T04:15:12.777', 'FavoriteCount': '1', 'Id': '12325'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m using a SAT solver to encode a problem, and as part of the SAT instance, I have boolean variables $x_1,x_2,\\dots,x_n$ where it is intended that exactly one of these should be true and the rest should be false.    (I\'ve sometimes seen this  described as a "one-hot" encoding.)</p>\n\n<p>I want to encode the constraint "exactly one out of $x_1,\\dots,x_n$ must be true" in SAT.  What is the best way to encode this constraint, to make the SAT solver run as efficiently as possible?</p>\n\n<p>I can see many ways to encode this constraint:</p>\n\n<ul>\n<li><p><em>Pairwise constraints.</em> I could add pairwise constraints $\\neg x_i \\lor \\neg x_j$ for all $i,j$ to ensure that at most one $x_i$ is true, and then add $x_1 \\lor x_2 \\lor \\cdots \\lor x_n$ to ensure that at least one is true.</p>\n\n<p>This adds $\\Theta(n^2)$ clauses and no extra boolean variables.</p></li>\n<li><p><em>Binary encoding.</em>  I could introduce $\\lg n$ new boolean variables $i_1,i_2,\\dots,i_{\\lg n}$ to represent (in binary) an integer $i$ such that $1 \\le i \\le n$ (adding a few boolean constraints to ensure that $i$ is in the desired range).  Then, I can add constraints enforcing that $x_i$ is tree and that all other $x_j$\'s are false.  In other words, for each $j$, we add clauses enforcing that $i=j \\Leftrightarrow x_j$.</p>\n\n<p>This adds $\\Theta(n \\lg n)$ clauses and I don\'t know how many extra boolean variables.</p></li>\n<li><p><em>Count the number of true values.</em>  I could implement a tree of boolean adder circuits and require that $x_1+x_2+\\dots+x_n=1$, treating each $x_i$ as 0 or 1 instead of false or true, and use the Tseitin transform to convert the circuit to SAT clauses.  A tree of half-adders suffices: constrain the carry output of each half-adder to be 0, and constrain the final output of the final half-adder in the tree to be 1.  The tree can be chosen to be of any shape (balanced binary tree, or unbalanced, or whatever).</p>\n\n<p>This can be done in $\\Theta(n)$ gates and thus adds $\\Theta(n)$ clauses and $\\Theta(n)$ new boolean variables.</p>\n\n<p>A special case of this approach is to introduce boolean variables $y_1,\\dots,y_n$, with the idea that $y_i$ should contain the value of $x_1 \\lor x_2 \\lor \\cdots \\lor x_i$.  This intent can be enforced by adding the clauses $y_i \\lor \\neg x_i$, $y_i \\lor \\neg y_{i-1}$, and $\\neg y_i \\lor x_i \\lor y_{i-1}$ (where we treat $y_0$ as a synonym for false) for $i=1,\\dots,n$.  Next, we can add the restrictions $\\neg y_i \\lor \\neg x_{i+1}$ for $i=1,2,\\dots,n-1$.  This is basically equivalent to the Tseitin transform of a half-adder tree, where the tree has a maximally unbalanced shape.</p></li>\n<li><p><em>Butterfly network.</em> I could build a <a href="https://en.wikipedia.org/wiki/File%3aButterfly_multitree.svg">butterfly network</a> on $n$ bits, constrain the $n$-bit input to be $000\\cdots 01$, constrain the $n$-bit output to be $x_1 x_2 \\cdots x_n$, and treat each 2-bit butterfly gate as an independent gate that either swaps or does not swap its input with the decision of which to do based upon a fresh new boolean variable that is left unconstrained.  Then, I can apply the Tseitin transform to convert the circuit to SAT clauses.</p>\n\n<p>This requires $\\Theta(n \\lg n)$ gates and thus adds $\\Theta(n \\lg n)$ clauses and $\\Theta(n \\lg n)$ new boolean variables.</p></li>\n</ul>\n\n<p>Are there any other methods I have overlooked?  Which one should I use?  Has anyone tested this or tried them experimentally, or does anyone have any experience with any of these?  Is the number of clauses and/or the number of new boolean variables a good stand-in metric for estimating the impact of this on SAT solver performance, or if not, what metric would you use?</p>\n\n<hr>\n\n<p>I just noticed that <a href="http://cs.stackexchange.com/a/6522/755">this answer</a> has some references on enforcing cardinality constraints for SAT, i.e., enforcing the constraint that exactly $k$ out of the $n$ variables are true.  So, my question comes down to a special case where $k=1$.  Maybe the literature on cardinality constraints will help shed light on my question.</p>\n', 'ViewCount': '301', 'Title': 'Encoding 1-out-of-n constraint for SAT solvers', 'LastEditorUserId': '755', 'LastActivityDate': '2013-07-10T16:31:28.367', 'LastEditDate': '2013-07-10T16:31:28.367', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<satisfiability><sat-solvers><applied-theory>', 'CreationDate': '2013-07-09T20:56:13.173', 'FavoriteCount': '1', 'Id': '13188'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><a href="http://alloy.mit.edu/alloy/" rel="nofollow">Alloy\'s front page</a> doesn\'t mention ASP, but the description sounds like ASP (finding solutions consistent with a logical spec).  And Alloy isn\'t listed in the <a href="http://en.wikipedia.org/wiki/Answer_set_programming" rel="nofollow">Wikipedia ASP article</a>.  Yet ASP systems and Alloy both seem to built on top of SAT solvers.  So how do they differ?</p>\n\n<p>[edit: Would it be fair to say, for example, that Alloy is ASP extended with a pile of useful built-in abstractions that make it more useful for writing and checking specs?  Or are there things that Alloy can do that ASP cannot?]</p>\n', 'ViewCount': '59', 'Title': 'Why Is Alloy not an Answer Set Programming system?', 'LastEditorUserId': '1326', 'LastActivityDate': '2013-09-27T00:55:42.583', 'LastEditDate': '2013-09-27T00:55:42.583', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1326', 'Tags': '<sat-solvers><answer-set-programming>', 'CreationDate': '2013-09-26T22:23:11.027', 'Id': '14633'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '122', 'Title': 'Convert $\\sum x_i = y$ to 3-sat', 'LastEditDate': '2013-09-27T16:42:08.333', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10359', 'FavoriteCount': '1', 'Body': '<p>I have a simple looking question. What is the most efficient conversion of  $\\sum_{i=1}^n x_i = y$ to 3-sat?  Here $x_i$ is either $1$ or $0$ and $y$ is some positive integer.</p>\n\n<p>Can you do better than making a SATISFIABILITY instance with $\\binom{n}{y}$ clauses, each of which is the conjunction of $y$ positive literals and $n-y$ negative literals and then just feeding the whole thing into the <a href="http://en.wikipedia.org/wiki/Tseitin-Transformation" rel="nofollow">Tseitin transform</a>?</p>\n', 'Tags': '<satisfiability><sat-solvers>', 'LastEditorUserId': '10359', 'LastActivityDate': '2013-10-02T04:31:49.637', 'CommentCount': '4', 'AcceptedAnswerId': '14667', 'CreationDate': '2013-09-27T11:40:14.670', 'Id': '14640'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am trying to solve a 25k clauses 5k variables SAT problem. As it has been running for an hour (precosat) and I'd like to solve bigger ones afterwards, I'm looking for a multi-core SAT-Solver.</p>\n\n<p>As there seem to be many SAT-Solvers, I'm quite lost.</p>\n\n<p>Could anyone point me out the best one for my case?</p>\n\n<p>I'd also be happy if someone could give me the approximate time (if possible).</p>\n", 'ViewCount': '141', 'Title': 'Multicore SAT Solver', 'LastEditorUserId': '11382', 'LastActivityDate': '2014-02-05T14:17:31.637', 'LastEditDate': '2013-11-17T20:27:40.670', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '11382', 'Tags': '<algorithms><reference-request><parallel-computing><sat-solvers>', 'CreationDate': '2013-11-14T16:25:35.683', 'FavoriteCount': '1', 'Id': '18021'}}