323_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need an efficient algorithm that takes input a collection of intervals and outputs the largest subset of non-intersecting intervals. </p>\n\n<p>i.e. Given a set of intervals $I =  \\{I_1, I_2, \\ldots, I_n\\}$ of the real line, we need to output a set of intervals $O = \\{O_1, O_2, \\ldots, O_k\\}$ such that</p>\n\n<ul>\n<li>$O$ is a subset of $I$.</li>\n<li>For any $i \\neq j$, $O_i$ and $O_j$ are non-intersecting.</li>\n<li>$k$ is the maximum possible.</li>\n</ul>\n\n<p>Example: if the intervals are $[1,100], [2,3], [4,5], [6,7], [3,20]$ we should return $\\{[2,3], [4,5], [6,7]\\}$.</p>\n', 'ViewCount': '503', 'Title': 'Algorithm to return largest subset of non-intersecting intervals', 'LastEditorUserId': '7391', 'LastActivityDate': '2013-03-24T21:29:01.710', 'LastEditDate': '2013-03-24T21:29:01.710', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'user2112791', 'PostTypeId': '1', 'Tags': '<algorithms><optimization><integers><intervals><set-cover>', 'CreationDate': '2013-03-23T02:48:15.283', 'FavoriteCount': '0', 'Id': '10713'},323_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '175', 'Title': 'Transforming an arbitrary cover into a vertex cover', 'LastEditDate': '2013-04-19T19:42:54.777', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4259', 'FavoriteCount': '0', 'Body': "<p>Given is a planar graph $G=(V,E)$ and let $\\mathcal{G}$ denote its embedding in the plane s.t. each edge has length $1$. \nI have furthermore a set $C$ of points where each point $c \\in C$ is contained in $\\mathcal{G}$. Furthermore, it holds  for any point $p$ in $\\mathcal{G}$ that there exists a $c \\in C$ with  geodesic distance to $p$ at most one. (The distance is measured as the shortest distance within $\\mathcal{G}$.)</p>\n\n<p>I want to argue that given a $C$ for which the above condition holds, I can easily transform it into a vertex cover, or put differently, transform it into a $C'$ of same cardinality s.t any $c \\in C'$ is placed in $\\mathcal{G}$  at a vertex of $G$, and $C'$ still covers $G$.</p>\n\n<p>My approach was to orient the edges and move the points in $C$ at the end vertex of the arc. But so far I did not find a correct orientation which yields $C'$ from $C$.</p>\n\n<p>Does anybody have an idea?</p>\n", 'Tags': '<algorithms><graph-theory><set-cover>', 'LastEditorUserId': '4259', 'LastActivityDate': '2013-04-22T16:50:16.823', 'CommentCount': '2', 'AcceptedAnswerId': '11416', 'CreationDate': '2013-04-16T00:49:10.817', 'Id': '11347'},323_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '98', 'Title': 'Time Complexity of a selection problem', 'LastEditDate': '2013-04-21T14:42:44.753', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2449', 'FavoriteCount': '1', 'Body': "<p>I wonder what's the time complexity of the following selection problem I found while thinking of a string-matching problem.</p>\n\n<p>[Assuming operations on integers take $O(1)$ time]</p>\n\n<p>We are Given $m$ sets, with $n$ integer numbers each. We want to select exactly one integer from each set, to make a set S, such that $~ l = \\max(S) - \\min(S)~$ is minimized.</p>\n\n<p>For example, n = 4, m = 3:</p>\n\n<p>$S_1 = \\{1, 43, 71, 101\\}$</p>\n\n<p>$S_2 = \\{18, 53, 80, 107\\}$</p>\n\n<p>$S_3 = \\{3, 16, 51, 208\\}$</p>\n\n<p>Now</p>\n\n<p>$~S = \\{43, 53, 51\\}$</p>\n\n<p>has one number from each set and </p>\n\n<p>$~l = \\max(S) - \\min(S) = 53 - 43 = 10 ~$ </p>\n\n<p>wich is the minimum possible value of $l$ (I think).</p>\n\n<p>First thing I tried was a reduction to the set cover problem, but I wasn't able to find one.</p>\n", 'Tags': '<complexity-theory><time-complexity><set-cover>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:42:44.753', 'CommentCount': '0', 'AcceptedAnswerId': '11430', 'CreationDate': '2013-04-20T12:51:15.197', 'Id': '11424'},323_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an index taking as keys values from the power set $P(S)$ of a set $S$, except for $\\emptyset$ and $S$.</p>\n\n<p>Then I have a query $Q=(s, k)$, where $s \\in P(S) - \\{\\emptyset \\cup S\\}$ and $ 1 &lt; k \\le |S|$.</p>\n\n<p>The result of the query is the set of covers $R$ of $S$; $\\forall r \\in R,  |r| \\le k$.</p>\n\n<p>So for instance, if $S = \\{a, b, c, d\\}$ and $Q=( \\{a,b\\}, 3 )$, $R$ should return all covers of $S$ formed by $\\{a, b\\}$ and $k = (3 - 1 = ) 2$ or less other subsets of $P(S) - \\{\\emptyset \\cup S\\}$, namely: $R = \\{$\n$$ \\{a,b\\} , \\{c\\} , \\{d\\}$$\n$$ \\{a,b\\} , \\{c, d\\} $$\n$$ \\{a,b\\} , \\{a, c, d\\} $$\n$$ \\{a,b\\} , \\{b, c, d\\} $$\n$\\}$ </p>\n\n<p>I want to know if there is an efficient algorithm that can give me all of these combinations of covers.</p>\n\n<p>In other words, I want to know if there is an efficient way to get all covers formed by at most $k$ elements, where I only know 1 element out of k.</p>\n', 'ViewCount': '41', 'Title': 'Enumerating all set covers when knowing one set at least', 'LastActivityDate': '2013-09-18T19:23:02.480', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14421', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10207', 'Tags': '<sets><set-cover>', 'CreationDate': '2013-09-18T19:02:56.177', 'Id': '14420'},323_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following problem, which seems to be similar to Set Cover.</p>\n\n<p>We are given a set $U$ of elements (the universe, e.g., $U=\\{1,2,3,4,5\\}$).\nWe're also given a set $S$ of subsets (e.g., $S=\\{\\{1\\},\\{2\\},\\{3\\},\\{4\\},\\{5\\},\\{1,2,5\\},\\{1,3,4\\},\\{2,3,4,5\\}\\}$).</p>\n\n<p>The standard set cover problem asks for the minimum subset of $S$ that covers the whole universe $U$, i.e., the smallest set-cover.  In our case this would be $\\{\\{1\\},\\{2,3,4,5\\}\\}$.</p>\n\n<p>However, I'm interested in finding a collection of set-covers where each subset from $S$ is used at most once.  I want to find the largest such collection possible, i.e., to find as many different, disjoint set-covers of $U$ as possible.  Considering our example, the three set-covers $\\{\\{1\\},\\{2,3,4,5\\}\\}$ and $\\{\\{3\\},\\{4\\},\\{1,2,5\\}\\}$ and $\\{\\{2\\},\\{5\\},\\{1,3,4\\}\\}$ would be the output, since each one is a set-cover of $U$ and they are pairwise disjoint (no subset from $S$ is used in more than one set-cover).</p>\n\n<p>Just testing all possible combinations of set-covers is definitely not an option. I have tried using an algorithm for set cover (ILP implementation) repeatedly, eliminating all used subsets in between runs. However, I'm certain that this strategy does not actually maximize the number of all possible covers.</p>\n\n<p><strong>Edit 1:</strong> I will try to describe the size of my problem a bit better. The typical size of $U$ is about 4000. $S$ consists of about 50 subsets. Each element of $S$ covers on average about 70% of $U$. Please keep in mind that I don't want to find <em>all</em> subset combinations out of $S$ that cover $U$. I just want to determine the maximum number of set covers using each subset from $S$ <em>only once</em> (or not at all). As of now I'm guessing the maximum number of possible covers is approximately 5.</p>\n", 'ViewCount': '297', 'Title': 'Variation of Set Cover Problem: Finding a maximum-sized collection of disjoint set-covers', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-13T17:28:54.193', 'LastEditDate': '2013-11-13T17:28:54.193', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11255', 'Tags': '<algorithms><optimization><set-cover>', 'CreationDate': '2013-11-08T09:43:48.263', 'FavoriteCount': '1', 'Id': '16816'},323_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Below is a homework problem where we have been asked to alter a greedy algorithm to return n element instance of a set problem. The original algorithm is also below. I was thinking that I could alter line 3 so that it would run until the size of C was equal to n, and change the logic in line 4 so that it would pick and remove vertices until the size of n. A vertex would be removed when the size of C doesn't equal to n but the cover is complete. I can't really think of any other way to do it. The real problem is that I'm not entirely sure how to make the algorithm run in exponential time like they are asking. </p>\n\n<blockquote>\n  <p>GREEDY-SET-COVER can return a number of different solutions, depending on\n  how we break ties in line 4. Give a procedure BAD-SET-COVER-INSTANCE.n/\n  that returns an n-element instance of the set-covering problem for which, depending\n  on how we break ties in line 4, GREEDY-SET-COVER can return a number of\n  different solutions that is exponential in n.</p>\n  \n  <p>$X$ \u2014 some finite set<br>\n  $F$ \u2014 a family of subsets of $X$<br>\n  $C$ \u2014 cover being constructed    </p>\n  \n  <p>GREEDY-SET-COVER($n$)<br>\n  1    let $U = X$<br>\n  2    let $C = \\varnothing$<br>\n  3    while $U \\ne \\varnothing$<br>\n  3a            select an $S \\in F$ that maximizes $\\left|S \\cap U\\right|$<br>\n  3b            set $U = U \\setminus S$<br>\n  3c            set $C = C \\cup \\{S\\}$<br>\n  4    return $C$   </p>\n</blockquote>\n\n<p>Could it be said that since the number of subsets a set has is $2^n$ and that in the worst case this algorithm will end up finding all of those subsets before settling on an n-instance set to return?</p>\n", 'ViewCount': '112', 'Title': 'Finding an instance of an n-element set cover', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:30:30.133', 'LastEditDate': '2013-11-28T21:30:30.133', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11580', 'Tags': '<algorithms><algorithm-analysis><greedy-algorithms><set-cover><approximation-algorithms>', 'CreationDate': '2013-11-23T23:48:31.680', 'Id': '18287'}