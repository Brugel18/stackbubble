{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Rewriting system is a set of rules in the form of  $A \\leftrightarrow B$. \nIf we apply that rule to a string $w$ we replace any substring $A$ in $w$ with a substring $B$ and vice versa.</p>\n\n<p>Given a starting string $AAABB$ can we derive $BAAB$ in the system with the following rules:</p>\n\n<ul>\n<li>$A \\leftrightarrow BA$</li>\n<li>$BABA \\leftrightarrow AABB$</li>\n<li>$AAA \\leftrightarrow AB$</li>\n<li>$BA \\leftrightarrow AB$</li>\n</ul>\n\n<p>Is there a general algorithm for that?</p>\n', 'ViewCount': '63', 'Title': 'Is it possible to derive a string in this rewriting system?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-16T12:16:33.377', 'LastEditDate': '2012-03-16T12:16:33.377', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '434', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '147', 'Tags': '<computability><term-rewriting>', 'CreationDate': '2012-03-16T05:05:58.920', 'Id': '433'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '315', 'Title': 'Confluence proof for a simple rewriting system', 'LastEditDate': '2012-04-06T04:32:54.413', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '17', 'FavoriteCount': '2', 'Body': "<p>Assume we have a simple language that consists of the terms:</p>\n\n<ul>\n<li>$\\mathtt{true}$</li>\n<li>$\\mathtt{false}$</li>\n<li>if $t_1,t_2,t_3$ are terms then so is $\\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3$</li>\n</ul>\n\n<p>Now assume the following logical evaluation rules:</p>\n\n<p>$$ \\begin{gather*}\r\n\\dfrac{}\r\n      {\\mathtt{if}\\: \\mathtt{true} \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to t_2}\r\n      \\text{[E-IfTrue]} \\quad\r\n\\dfrac{}\r\n      {\\mathtt{if}\\: \\mathtt{false} \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to t_3}\r\n      \\text{[E-IfFalse]} \\\\\r\n\\dfrac{t_1 \\to t_1&#39;}\r\n      {\\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to \\mathtt{if}\\: t_1&#39; \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3}\r\n      \\text{[E-If]} \\\\\r\n\\end{gather*} $$</p>\n\n<p>Suppose we also add the following funky rule:</p>\n\n<p>$$\r\n\\dfrac{t_2 \\to t_2&#39;}\r\n      {\\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2 \\:\\mathtt{else}\\: t_3 \\to \\mathtt{if}\\: t_1 \\:\\mathtt{then}\\: t_2&#39; \\:\\mathtt{else}\\: t_3}\r\n      \\text{[E-IfFunny]}\r\n$$</p>\n\n<p>For this simple language with the given evaluation rules I wish to prove the following:</p>\n\n<p><strong>Theorem: If $r \\rightarrow s$ and $r \\rightarrow t$ then there is some term $u$ such that $s \\rightarrow u$ and $t \\rightarrow u$.</strong></p>\n\n<p>I am proving this by induction on the structure of $r$. Here is my proof so far, it all worked out well, but I am stuck at the very last case. It seems like induction on the structure of $r$ is not sufficing, can anyone help me out?</p>\n\n<p><em>Proof.</em> By induction on $r$, we will seperate all the forms that $r$ can take:</p>\n\n<ol>\n<li>$r$ is a constante, nothing to prove since a normal form does not evaluate to anything.</li>\n<li>$r=$ if true then $r_2$ else $r_3$. (a) both derivations were done with the E-IfTrue rule. In this case $s=t$, so there is nothing to prove. (b) one deriviation was done with the E-IfTrue rule, the other with the E-Funny rule. Assume $r \\rightarrow s$ was done with E-IfTrue, the other case is equivalently proven. We now know that $s = r_2$. We also know that $t =$ if true then $r&#39;_2$ else $r_3$ and that there exists some deriviation $r_2 \\rightarrow r&#39;_2$ (the premise). If we now choose $u = r&#39;_2$, we conclude the case.</li>\n<li>$r=$ if false then $r_2$ else $r_3$. Equivalently proven as above.</li>\n<li>$r=$ if $r_1$ then $r_2$ else $r_3$ with $r_1 \\neq $ true or false. (a) both deriviations were done with the E-If rule. We now know that $s =$ if $r&#39;_1$ then $r_2$ else $r_3$ and $t =$ if $r&#39;&#39;_1$ then $r_2$ else $r_3$. We also know that there exists deriviations $r_1 \\rightarrow r&#39;_1$ and $r_1 \\rightarrow r&#39;&#39;_1$ (the premises). We can now use the induction hypothese to say that there exists some term $r&#39;&#39;&#39;_1$ such that $r&#39;_1 \\rightarrow r&#39;&#39;&#39;_1$ and $r&#39;&#39;_1 \\rightarrow r&#39;&#39;&#39;_1$. We now conclude the case by saying $u =$ if $r&#39;&#39;&#39;_1$ then $r_2$ else $r_3$ and noticing that  $s \\rightarrow u$ and $t \\rightarrow u$ by the E-If rule. (b) one derivation was done by the E-If rule and one by the E-Funny rule.</li>\n</ol>\n\n<p>This latter case, where one derivation was done by E-If and one by E-Funny is the case I am missing... I can't seem to be able to use the hypotheses.</p>\n\n<p>Help will be much appreciated.</p>\n", 'Tags': '<logic><semantics><proof-techniques><term-rewriting>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-06T04:32:54.413', 'CommentCount': '3', 'AcceptedAnswerId': '1061', 'CreationDate': '2012-04-05T18:36:04.420', 'Id': '1060'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m working through Simon Peyton Jones\' "The Implementation of Functional Programming Languages" and on page 20 I see:</p>\n\n<pre>\nIF TRUE ((&#955;p.p) 3) &#8596; IF TRUE 3         (per &#946; red)   (1)\n                   &#8596; (&#955;x.IF TRUE 3 x)  (per &#951; red)   (2)\n                   &#8596; (&#955;x.3)                          (3)\n</pre>\n\n<p>Step 1 to 2 is explained as &#951;-conversion. But from 2 to 3 it says "The final step is the reduction rule for IF." I\'m not sure what this reduction rule is. </p>\n', 'ViewCount': '213', 'Title': 'Reduction rule for IF?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-10T03:26:39.087', 'LastEditDate': '2012-05-10T03:26:39.087', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'OwnerDisplayName': 'galaxybeing', 'PostTypeId': '1', 'OwnerUserId': '1335', 'Tags': '<logic><programming-languages><lambda-calculus><term-rewriting><operational-semantics>', 'CreationDate': '2012-05-01T03:47:18.940', 'Id': '1607'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '154', 'Title': u'The meaning of modulo in \u201cformula modulo a background theory\u201d', 'LastEditDate': '2012-09-05T14:02:06.013', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'Cemre', 'PostTypeId': '1', 'OwnerUserId': '2743', 'Body': u'<p>I have been reading some papers where I keep reading stuff like \u201cfirst-order formula modulo a background theory\u201d. Does anyone know what modulo means in this case ? Is it something like \u201cwith respect to\u201d?</p>\n', 'Tags': '<terminology><logic><term-rewriting>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-06T00:12:20.367', 'CommentCount': '0', 'AcceptedAnswerId': '3436', 'CreationDate': '2012-09-05T12:21:36.783', 'Id': '3435'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am studying formal languages and playing with writing my own parsers for them. I have a context free grammar parser already that works well. I am wondering if anyone can point me towards actually implemented examples of rewriters. For example, suppose I had the rules</p>\n\n<p>WORD: [A-Z]+</p>\n\n<p>QUOTE: "</p>\n\n<p>And I wanted to input a lot of words,put quotes around each one, and write out the string. Or go back and forth. Something like this:</p>\n\n<p>(WORD [\' \'])+   &lt;--> (QUOTE WORD QUOTE [\' \'])+</p>\n\n<p>That seems kind of possible to implement automatically without ambiguity, but I was hoping someone had seen something along that line that already exists.</p>\n', 'ViewCount': '107', 'Title': 'Example of a parsing/rewriting system?', 'LastActivityDate': '2012-11-22T06:56:28.430', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4657', 'Tags': '<formal-languages><parsers><term-rewriting>', 'CreationDate': '2012-11-21T11:23:56.357', 'Id': '6808'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I currently have a system that has <code>{f(a) = b, f(f(x)) = x}</code> (part of an <a href="http://folk.uio.no/peterol/INF3230V13/Oppgaver/midterm06.pdf" rel="nofollow">exam question</a> - look at page 5 - exercise 1).</p>\n\n<p>To start off with proving non-confluency, I am thinking along these lines:</p>\n\n<pre><code>f(f(x)) and f(a) can be unified by using {a -&gt; f(x)}. \n</code></pre>\n\n<p>Then we can rewrite:</p>\n\n<pre><code>f(f(x)) = x                 [eq.1]\nf(f(x)) = b                 [eq.2]\n</code></pre>\n\n<p>The above two cannot be reduced any further, and do not have any common ancestor or successor. Therefore the system is not confluent.</p>\n\n<p>To make this confluent, we can add a third equation to the system:</p>\n\n<pre><code>x = b\n</code></pre>\n\n<p>This way, the equation will both be confluent and terminate. Another alternative would be:</p>\n\n<pre><code>f(x) = b\n</code></pre>\n\n<p>Is there anything I have missed? Or is this pretty much the gist of it?</p>\n', 'ViewCount': '73', 'Title': 'Proving non-confluency and adding an equation to make it confluent and terminating', 'LastActivityDate': '2013-07-15T16:03:03.313', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10108', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6867', 'Tags': '<logic><proof-techniques><semantics><term-rewriting>', 'CreationDate': '2013-02-25T21:26:12.353', 'Id': '10096'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This question arises from my reading of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">"Types and Programming Languages"</a> (<a href="http://www.worldcat.org/oclc/47705787" rel="nofollow">WorldCat</a>) by Benjamin C. Pierce.</p>\n\n<p>On page 36 is the definition for <em>satisfied</em></p>\n\n<blockquote>\n  <p>A rule is <em>satisfied</em> by a relation if, for each instance of the rule,\n  either the conclusion is in the relation or one of the premises is\n  not.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>instance</em></p>\n\n<blockquote>\n  <p>An <em>instance</em> of an inference rule is obtained by consistently replacing\n  each metavariable by the same term in the rule\'s conclusion and all its\n  premises (if any).</p>\n  \n  <p>For example </p>\n  \n  <p><code>if true then true else (if false then false else false) -&gt; true</code></p>\n  \n  <p>is an instance of <strong>E-IFTRUE</strong>, where both occurrences of $t_2$ have been\n  replaced by <code>true</code> and $t_3$ has been replaced by <code>if false then false else\n  false</code>.</p>\n</blockquote>\n\n<p>On page 15 is the definition for <em>relataion</em></p>\n\n<blockquote>\n  <p>An n-place <em>relation</em> on a collection of sets $S_1, S_2,..., S_n$ is a\n  set $R\\subseteq  S_1\\times\\;S_2\\;\\times\\;...\\;\\times\\;S_n$ of tuples\n  of elements from $S_1$ through $S_n$. We say that the elements $s_1\\in\n&gt; S_1$ thorugh $s_n\\in S_n$ are related by $R$ if $(s_1,...,s_n)$ is an\n  element or $R$.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>one-step evaluation relation ($\\rightarrow $)</em> </p>\n\n<blockquote>\n  <p>The <em>one-step evaluation relation $\\rightarrow $</em> is the smallest\n  binary relation on terms satisfying the three rules of Figure 3-1.\n  When the pair $(t,t\')$ is in the evaluation relation,  we say that "the\n  evaluation statement (or judgment) $t \\rightarrow t\'$ is derivable."</p>\n</blockquote>\n\n<p>On page 34 are the three rules from Figure 3-1</p>\n\n<p><strong>E-IFTRUE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;true\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IFFALSE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;false\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IF</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}\\frac{t_1\\rightarrow\\;t_1\'}{if\\;t_1\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;if\\;t_1\'\\;then\\;t_2\\;else\\;t_3}\\end{equation}</p>\n</blockquote>\n\n<p>Can someone explain this definition and give an example for parts of the defintion.<br>\n1. The conclusion is in the relation.<br>\n2. One of the premises is not.  </p>\n\n<p>Note: I am aware that there is a forum dedicated to questions for the book <a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list" rel="nofollow">here</a>.</p>\n\n<p>Note: You can use <a href="http://scholar.google.com/" rel="nofollow">Google Scholar</a> to see more of the details to this question in context.</p>\n\n<p>EDIT</p>\n\n<p>To connect some of the dots about my comment regarding unification and term rewriting.</p>\n\n<p>When I saw</p>\n\n<p>$$(A\\rightarrow B)\\equiv (\\neg A \\vee B)$$</p>\n\n<p>it reminded me of <a href="http://en.wikipedia.org/wiki/Horn_clause" rel="nofollow">Horn claues</a> from <a href="http://en.wikipedia.org/wiki/Prolog" rel="nofollow">Prolog</a>, that along with the example then connected with my understanding of <a href="http://en.wikipedia.org/wiki/Rewriting" rel="nofollow">term rewriting</a>. Having the book "<a href="http://www.cambridge.org/gb/knowledge/isbn/item1166682/?site_locale=en_GB" rel="nofollow">Term Rewriting and All That</a>" (<a href="http://www.worldcat.org/title/term-rewriting-and-all-that/oclc/37315354&amp;referer=brief_results" rel="nofollow">WorldCat</a>) by Franz Baader and Tobias Nipkow, I quickly looked up satisfiability and found satisfiable on page 58. This is actually the start of whole chapter on Equational Problems; but it also covers <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29" rel="nofollow">unification</a>. At that point I realized that the definition was dealing with <a href="http://en.wikipedia.org/wiki/Satisfiability" rel="nofollow">Satisfiability</a> and from there is was a topic I was already familiar. What threw me was the way Benjamin defined it. He used a very precise definition right up front in a manner I didn\'t associate with my knowledge.  </p>\n\n<p>If you work through the code as I am and understand logic programming, then the definition makes perfect sense.</p>\n', 'ViewCount': '107', 'Title': 'TAPL: Explanation and example(s) for satisfied', 'LastEditorUserId': '268', 'LastActivityDate': '2013-03-11T01:59:40.410', 'LastEditDate': '2013-03-11T01:59:40.410', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10403', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<satisfiability><operational-semantics><small-step><term-rewriting>', 'CreationDate': '2013-03-08T14:05:18.400', 'Id': '10386'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In Haskell, are datatypes converted to the "Church encoding" i.e. folding the data type.  For example, given </p>\n\n<pre><code>data N = Z | S N\n</code></pre>\n\n<p>in Haskell, it can be converted to its church encoding by </p>\n\n<pre><code>foldN Z z s = z\nfoldN (S n) z s = s (foldN z s n)\n</code></pre>\n\n<p>Where if we do foldN m, we get the church encoding:</p>\n\n<pre><code>\\z s . s (  .... s n ... )\n</code></pre>\n\n<p>In Proofs and Types, Girard shows how this works for any inductive datatype.  There are two questions I have: (1) is this actually how Haskell treats datatypes and (2) what is the equivalent construction for coinductive datatypes.</p>\n', 'ViewCount': '57', 'Title': 'Implementation of datatypes in Haskell?', 'LastActivityDate': '2013-09-11T00:13:35.923', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4775', 'Tags': '<data-structures><term-rewriting><interactive-proof-systems>', 'CreationDate': '2013-09-11T00:13:35.923', 'FavoriteCount': '0', 'Id': '14261'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Would it be possible to apply $(\\lambda x.\\lambda y. x)$ to the argument $y$? It seems to me that this must not be possible as it would give a different answer if applied to a constant, call it $\\alpha$ and $y$. Namely:</p>\n\n<p>$(\\lambda x.\\lambda y. x) \\alpha = \\alpha$</p>\n\n<p>but </p>\n\n<p>$(\\lambda x.\\lambda y. x)y = \\lambda y.y$</p>\n\n<p>I am afraid that I might be making considerable mistakes but this is only the case because I have been studying $\\lambda$-calculus for just one day.</p>\n\n<p>Thank you very much in advance for your comments and suggestions.</p>\n', 'ViewCount': '30', 'Title': 'Is this $\\beta$-reduction well defined?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-06T23:14:47.590', 'LastEditDate': '2013-10-06T23:14:47.590', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14865', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10537', 'Tags': '<programming-languages><lambda-calculus><term-rewriting><variable-binding>', 'CreationDate': '2013-10-06T22:23:47.130', 'Id': '14863'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Upon reading  <a href="http://stackoverflow.com/q/20356678/1243762">Do source code optimizers exist?</a> I knew that such programs existed but the ones I have worked with use a set of rules to drive a transformation algorithm. <a href="http://stackoverflow.com/users/120163/ira-baxter">Ira Baxter</a> provided a link to the tools running the algorithms with his <a href="http://stackoverflow.com/a/20358310/1243762">answer</a> but what I was more after from the question was the rules. In the comments Ira noted the  <a href="http://www.bayfronttechnologies.com/itc76.pdf" rel="nofollow">Irvine Program Catalog</a>.</p>\n\n<p>Are there any more papers, sites, etc. that list such rules?</p>\n\n<p>I will accept any answer but have a preference for rules used with functional languages.</p>\n', 'ViewCount': '56', 'Title': 'Where can I find rules for source to source transformation optimization rules?', 'LastActivityDate': '2013-12-04T00:24:40.743', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18590', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<reference-request><term-rewriting>', 'CreationDate': '2013-12-03T21:46:11.533', 'Id': '18583'}}