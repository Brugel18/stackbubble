{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<h3>Background:</h3>\n\n<p>In this question we care only about worst-case running-time.</p>\n\n<p>Array and (doubly) linked lists can be used to keep a list of items and implement the <strong><a href="http://en.wikipedia.org/wiki/Vector_data_structure#Efficiency_comparison_with_other_data_structures">vector</a></strong> abstract data type. Consider the following three operations:</p>\n\n<ul>\n<li>$Location(i)$: returns a pointer to the $i$th item in the list of items in the array.</li>\n<li>$Insert(k,x)$: insert the item $k$ in the list after the item pointed to by $x$.</li>\n<li>$Delete(x)$: remove the item in the list pointed to by $x$.</li>\n</ul>\n\n<p>The main operation that an <strong>array</strong> provides is location which can be computed in constant time. However delete and insert are inefficient.</p>\n\n<p>On the other hand, in a <strong>doubly linked list</strong>, it is easy to perform insert and delete in constant time, but location is inefficient.</p>\n\n<h3>Questions:</h3>\n\n<p>Can there be a data structure to store a list of items where all three operations are $O(1)$? If not, what is the best worst-case running-time that we can achieve for all operations simultaneously? </p>\n\n<p>Note that a balanced binary search tree like red-black trees augmented with size of subtrees would give $O(\\lg n)$, is it possible to do better? Do we know a non-trivial lower-bound for this problem?</p>\n', 'ViewCount': '136', 'ClosedDate': '2013-03-01T18:52:59.140', 'Title': 'Is there a data-structure which is more efficient than both arrays and linked lists?', 'LastActivityDate': '2013-02-26T01:06:49.737', 'AnswerCount': '0', 'CommentCount': '17', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<data-structures><arrays><lower-bounds><linked-lists>', 'CreationDate': '2013-02-26T01:06:49.737', 'Id': '10111'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am seeking help understanding Floyd\'s cycle detection algorithm. I have gone through the explanation on wikipedia (<a href="http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare" rel="nofollow">http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare</a>)</p>\n\n<p>I can see how the algorithm detects cycle in O(n) time. However, I am unable to visualise the fact that once the tortoise and hare pointers meet for the first time, the start of the cycle can be determined by moving tortoise pointer back to start and then moving both tortoise and hare one step at a time. The point where they first meet is the start of the cycle.</p>\n\n<p>Can someone help by providing an explanation, hopefully different from the one on wikipedia, as I am unable to understand/visualise it?</p>\n', 'ViewCount': '3398', 'Title': "Floyd's Cycle detection algorithm | Determining the starting point of cycle", 'LastActivityDate': '2013-03-07T12:24:41.433', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7183', 'Tags': '<algorithms><linked-lists>', 'CreationDate': '2013-03-07T12:24:41.433', 'Id': '10360'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1073', 'Title': 'Implement queue with a linked list; why would it be bad to insert at the head and remove at the tail?', 'LastEditDate': '2013-03-10T19:51:55.500', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '1', 'Body': '<p>In my textbook, Data Structures and Algorithms in Java, the author says when implementing a queue using a linked list you choose the front of the queue to be at the head of the list, and the rear of the queue to be at the tail of the list. In this way, you remove from the head and insert at the tail.</p>\n\n<p>The author then asks cryptically, "Why would it be bad to insert at the head and remove at the tail?" without providing an answer.</p>\n\n<p>I can\'t see what the difference really is. In effect, "Head" and "Tail" are just arbitrary names we define. What would be so bad if to enqueue() we add a head and create a reference to the old head, and to dequeue() we take from the tail and move the tail over?</p>\n\n<p>What is the answer to the author\'s question?</p>\n', 'Tags': '<time-complexity><linked-lists><abstract-data-types>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-10T19:51:55.500', 'CommentCount': '0', 'AcceptedAnswerId': '10435', 'CreationDate': '2013-03-10T19:10:25.620', 'Id': '10434'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In a circular linked list, if an elements needs to be inserted at front [just before the node pointed by head], can be done in O(1) (see the answer <a href="http://stackoverflow.com/questions/1096505/implement-an-algorithm-to-insert-a-node-into-a-circular-linked-list-without-trav">here</a>)</p>\n\n<p>But in a book currently, I have, it is mentioned that it is done in O(n) (the usual method). I also saw few lecture ppts, they all mention the usual method of traversing the list &amp; adding an element.</p>\n\n<p>My question is :</p>\n\n<ol>\n<li><p>In practical scenarios which method is used ?</p></li>\n<li><p>I am about to attend an exam, which consists of MCQs, if above question is asked shall I mark O(n), since that is the standard answer ?</p></li>\n</ol>\n', 'ViewCount': '452', 'Title': 'Complexity of algorithm inserting an element in a circular linked list at the front end', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-23T16:37:13.557', 'LastEditDate': '2013-03-23T15:58:50.753', 'AnswerCount': '1', 'CommentCount': '12', 'AcceptedAnswerId': '10704', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<data-structures><efficiency><linked-lists>', 'CreationDate': '2013-03-23T09:26:46.557', 'Id': '10701'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><strong>The Question:</strong> You are given a singly-linked list with <em>n</em> nodes that you can only iterate through once at most. You are given additional space to store one node (i.e. a pointer to it).  Devise an algorithm that can operate under these conditions, choose/select one node from the list such that the the probability of each node being selected/chosen is equal.</p>\n\n<p><strong>My Friend\'s Solution:</strong> </p>\n\n<ol>\n<li>Store the first node in the additional space. </li>\n<li>Move to the next node.</li>\n<li>Randomly select one node between the one in the additional space and the current node. </li>\n<li>Store this "winner" in the additional space.</li>\n<li>Repeat steps 2-4 until the last node in the list is processed.</li>\n<li>The node stored in the additional space at the end is the one that the algorithm selects.</li>\n</ol>\n\n<p><strong>My Issue With My Friend\'s Solution:</strong> Consider the case <em>n</em> = 3. There are 2^*(n-1) = 2^2 = 4 possible ways to go through the list in terms of which node is selected during each iteration of the algorithm:</p>\n\n<ol>\n<li>Select 1 -> from (1, 2) select 1 -> from (1, 3) select 1 -> 1 is finally selected</li>\n<li>Select 1 -> from (1, 2) select 1 -> from (1, 3) select 3 -> 3 is finally selected</li>\n<li>Select 1 -> from (1, 2) select 2 -> from (2, 3) select 3 -> 3 is finally selected</li>\n<li>Select 1 -> from (1, 2) select 2 -> from (2, 3) select 2 -> 2 is finally selected</li>\n</ol>\n\n<p>Then, node 3 has a 50% chance of being selected, whereas nodes 1 and 2 each have a 25% chance of being selected. </p>\n\n<p>Intuitively, this makes sense to me; if the first node is not selected while the beginning of the list is being processed, it can never be the one that is finally selected. However, the last node still has a chance of being selected no matter what happens while processing the the rest of the list that comes before the last node.</p>\n\n<p>However, my friend says that my issue with his solution is inconsequential because I didn\'t model the situation correctly. Can someone tell me where I went wrong?</p>\n', 'ViewCount': '147', 'Title': 'Selecting a node of a singly-linked list such that the probability of each node being selected is equal', 'LastActivityDate': '2013-08-09T19:02:48.780', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9116', 'Tags': '<linked-lists>', 'CreationDate': '2013-07-10T16:46:03.893', 'Id': '13205'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '280', 'Title': 'What linked list data structure adjustments would give me fast random lookup?', 'LastEditDate': '2013-08-07T13:56:23.087', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7284', 'FavoriteCount': '1', 'Body': "<p>I am presently using an doubly linked list (C++ <code>std::list</code>) to hold a bunch of records that each have a unique integer identifier.  The linked list is created in sorted order such that in the list, the next item always has a larger unique identifier than its predecessor.</p>\n\n<p>The issue I'm facing is that occasionally I need to be able to insert an item quickly into its  relative sorted position and using a plain linked list means this operation is $O(n)$ which is causing performance issues for me.  Generally, this would mean I want to use something like a binary tree (C++ <code>std::map</code>), however, I am also depending upon the following feature of a doubly linked list for good performance:</p>\n\n<ul>\n<li>Ability to splice a contiguous section out of one linked list into another in $O(1)$ time. (Amortized $O(1)$ or $O(\\log \\log n)$ would be good enough.)</li>\n</ul>\n\n<p>One feature of my data that I would like to leverage is that I often have long ranges of contiguous records where each one's unique integer is exactly one more than its predecessor.  When searching for an item's relative sorted position, it would always be outside such contiguous records since there are no duplicate identifiers.</p>\n\n<p>I'd like to find a replacement data structure or augmentation to a doubly linked list that will allow me to continue to splice whole sections from one list to another in constant time but allow me to locate the sorted position in which to insert a new record in better than $O(n)$ time.</p>\n\n<p>Other operations include forward and backward iteration across the items. The record indexes begin at zero and grow upwards towards 64 bits, generally sequentially, and the code works well in such cases. Occasionally some records are not available before subsequent ones, it is the insertion of these missing records that causes the performance issues now. </p>\n\n<p>One possible approach that occurs to me is to cache the location of several indexes.  The cache would get invalidated whenever a splice removes items that might overlap the cached entries.  With this cache, instead of doing a linear search, the search could instead begin from the cache point iterator whose unique index is closest to the one whose position is being  searched for.  However, I'd like to more fully utilize the feature of the contiguous records.  I also thought about a hierarchical linked list where I have a top level linked list of contiguous regions, where each region is a linked list of records that are consecutive, but I didn't see a clean way to adapt a linked list to provide this functionality.  Perhaps something like this has been done before?  I find skip lists to be close, but do not see the splice() functionality, plus a generic skip list would not leverage the fact that insertion never occurs within contiguous records.</p>\n", 'Tags': '<data-structures><time-complexity><binary-trees><linked-lists>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-08T10:37:59.160', 'CommentCount': '3', 'AcceptedAnswerId': '13646', 'CreationDate': '2013-08-05T23:00:36.700', 'Id': '13620'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Imagine I have an ordering on a bunch of elements like so:</p>\n\n<p><img src="http://i.imgur.com/Sl2kUC0.png" alt="enter image description here"></p>\n\n<p>Where an arrow $X \\leftarrow Y$ means $X &lt; Y$. It is also transitive: $\\left(X &lt; Y\\right) \\wedge \\left(Y &lt; Z\\right) \\implies \\left(X &lt; Z\\right)$.</p>\n\n<p>In order efficiently answer queries like $A \\stackrel {?}{&lt;} D$, some sort of labeling or data structure is required. For example, you could number the nodes from left to right, and thus you can simply do integer comparison to answer the query: $A \\stackrel {?}{&lt;} D \\implies 1 &lt; 4 \\implies T$. It would look something like this:</p>\n\n<p><img src="http://i.imgur.com/YQ28co3.png" alt="enter image description here"></p>\n\n<p>Where the number is the ordering, and the letter is just a name.</p>\n\n<p>But what if you needed to insert elements "in between" two other elements in the ordering, like so:</p>\n\n<p><img src="http://i.imgur.com/aLuLJRH.png" alt="enter image description here"></p>\n\n<p><img src="http://i.imgur.com/HTSllkZ.png" alt="enter image description here"></p>\n\n<p><img src="http://i.imgur.com/DaytZtk.png" alt="enter image description here"></p>\n\n<p>How can you maintain such an ordering? With simple numbering, you run into the problem that there are no integers "in between" $2,3$ to use.</p>\n', 'ViewCount': '881', 'Title': 'Maintaining an efficient ordering where you can insert elements "in between" any two other elements in the ordering?', 'LastActivityDate': '2013-10-01T13:49:11.323', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14728', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<data-structures><graphs><linked-lists><partial-order><order-theory>', 'CreationDate': '2013-09-30T17:58:23.563', 'FavoriteCount': '2', 'Id': '14708'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have a doubly link-list like this</p>\n\n<pre><code>typedef struct Record\n{\n   int i;\n   Record* next;\n   Record* prev;\n}Record;\n</code></pre>\n\n<p>I have over 5 trillions of records that I need to handle, now that I need to retrieve all of them and sort them out.\nIf its size was small, I could borrow stl's vector or list to do the job but now that it is too huge, I have no idea how to save the object data before sorting is performed</p>\n\n<p>my function prototype</p>\n\n<pre><code>void sortRec(Record**recToSort,bool bASC){}\n</code></pre>\n", 'ViewCount': '71', 'ClosedDate': '2013-10-15T10:05:09.320', 'Title': 'linklist and memory issues', 'LastActivityDate': '2013-10-03T19:11:33.200', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10450', 'Tags': '<algorithms><data-structures><data-mining><linked-lists>', 'CreationDate': '2013-10-02T03:53:31.060', 'Id': '14744'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was wondering how to remove duplicate values from a linked list in $\\mathcal{O}(n\\lg n)$ time. I have an idea that by using merge sort when we want to compare elements for choosing the small one, if they are equal advance on pointer and just consider one element. Any alternatives?</p>\n', 'ViewCount': '111', 'Title': 'How to purge a linked list in $\\mathcal{O}(n\\log n)$ time?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T21:13:42.090', 'LastEditDate': '2013-10-18T21:13:42.090', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '16162', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10030', 'Tags': '<sorting><linked-lists>', 'CreationDate': '2013-10-17T14:11:34.833', 'Id': '16160'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have the following homework question that I am struggling with. I have read the corresponding chapter from the book, but no guidance there.</p>\n\n<p>Consider a linked list $X: X_1 \\to X_2 \\to X_3 \\ldots$.\nAssume that the cost of examining a particular element $X_i$ is $C_i$. Note that to examine $X_i$, \none needs to scan through all elements in front of $X_i$. Let $P_i$ be the probability of \nsearching for element $X_i$, so the total cost for all searches is \n$$\n\\sum_{j=1}^{n} \\left( P_j \\cdot \\sum_{i=1}^{j} C_i \\right)\n$$</p>\n\n<ol>\n<li><p>Show that storing elements in non-increasing order of $P_i/C_i$ does not necessarily minimize the total cost. </p></li>\n<li><p>Show that storing elements in non-decreasing order of $P_i$ does not necessarily minimize the total cost. </p></li>\n</ol>\n\n<p>Any help and direction how to approach the problem will be highly appreciated.</p>\n', 'ViewCount': '127', 'Title': 'Impact on the order of elements on the cost of searching in a linked list', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-07T03:59:28.483', 'LastEditDate': '2014-03-04T11:09:47.673', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '22365', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15266', 'Tags': '<algorithm-analysis><data-structures><linked-lists>', 'CreationDate': '2014-03-04T09:44:59.877', 'Id': '22264'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>To prevent collisions in Hash table , <a href="http://en.wikipedia.org/wiki/Hash_table#Collision_resolution" rel="nofollow">seperate chaining with linked list</a> is used . Hash table works by hashing the key and storing the value in the bucket. </p>\n\n<p>Assuming 4 keys hash to the same bucket , and the bucket has a linked list which has 4 nodes , how would we know which value belong to the key when we try to search for the value of the key .</p>\n\n<p>For eg : These 4 key-value :<strong>a:4</strong>  , <strong>b:3</strong> , <strong>c:2</strong> , <strong>d:1</strong> ,  hash to bucket 23. At bucket 23 , there is a linked list of values : <strong>4 , 3 , 2 , 1</strong>  , how would we know which values belong to which key</p>\n', 'ViewCount': '20', 'Title': 'How to tell which value belongs to the key during hashing', 'LastActivityDate': '2014-03-15T16:54:11.963', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22654', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12448', 'Tags': '<hash-tables><linked-lists>', 'CreationDate': '2014-03-15T16:45:33.213', 'Id': '22652'}},