{'ViewCount': '360', 'Title': 'What makes type inference for dependent types undecidable?', 'LastEditDate': '2013-10-09T18:44:37.213', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '8685', 'FavoriteCount': '1', 'Body': '<p>I have seen it mentioned that dependent type systems are not inferable, but are checkable. I was wondering if there is a simple explanation of why that is so, and whether or not there is there a limit of "dependency" where types can be indexed by values, below which type inference is possible and above which it is not?</p>\n', 'Tags': '<undecidability><type-theory><type-inference><dependent-types>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:37.213', 'CommentCount': '2', 'AcceptedAnswerId': '12957', 'CreationDate': '2013-06-15T15:35:18.983', 'Id': '12691'}{'Body': u'<p>I am reading about dependent types theory in the <a href="http://homotopytypetheory.org/book/" rel="nofollow">Homotopy Type Theory</a> online book. </p>\n\n<p>In section 1.3 of the <em>Type Theory</em> chapter, it introduces the notion of hierarchy of <em>Universes</em>: $\\mathcal{U}_0 : \\mathcal{U}_1 : \\mathcal{U}_2 : \\cdots$, where</p>\n\n<blockquote>\n  <p>every universe $\\mathcal{U}_i$ is an element of the next universe $\\mathcal{U}_{i+1}$. Moreover, we assume that our universes are cumulative, that is that all the elements of the $i^{\\mathrm{th}}$ universe are also elements of\n  the $(i+1)^{\\mathrm{th}}$ universe.</p>\n</blockquote>\n\n<p>Yet, when I look at the formation rules for the various types in appendix A, at first glance, if a universe appears above the bar as a premise, the same universe appears below. For instance for the coproduct types formation rule:</p>\n\n<p>$$\\dfrac{\\Gamma \\vdash A : \\mathcal{U}_i \\quad \\Gamma \\vdash B : \\mathcal{U}i}{\\Gamma \\vdash A + B : \\mathcal{U}_i}(+\\mbox{-}FORM)$$</p>\n\n<p>So my question is why is a hierarchy necessary? <strong>Under what circumstances do you need to jump from a universe to one higher in the hierarchy?</strong> It is really not obvious to me how given any combination of $A_m: \\mathcal{U}_i$, you can end up with a type $B$ that is <strong>not</strong> in $\\mathcal{U}_i$. In more details: the formation rules in sections of the appendix A.2.4, A.2.5, A.2.6, A.2.7, A.2.8, A.2.9, A.2.10, A.3.2, either mention $\\mathcal{U}_i$ in the premise and judgement, or just in the judgement. </p>\n\n<p>The book also hints that there is a formal way to assign universes: </p>\n\n<blockquote>\n  <p>If there is any doubt about whether an\n  argument is correct, the way to check it is to try to assign levels consistently to all universes appearing in it.</p>\n</blockquote>\n\n<p><strong>What is the process for assigning levels consistently?</strong></p>\n\n<p><a href="http://cs.stackexchange.com/questions/12929/example-of-a-false-proposition-when-assuming-type-type">$\\mathcal{U}:\\mathcal{U}$ would lead to the Russell paradox</a>.\nAvoiding the Russell paradox is explicitly mentioned in the book (page 24). It also goes into more details page 54, 55 that is uses \u201cRussell-style universes\u201d rather than \u201cTarski-style universes\u201d. So at a very high level, I take for granted that the theory wants to avoid the paradox. Unfortunately I don\'t have the background to make sense of out that directly. What I am after in this question, is really just scratching the surface by getting some examples of things in $\\mathcal{U}_j$ and not in $\\mathcal{U}_i$ for $j &gt; i$ and may be anything else that give me a feel for how the hierarchies work. </p>\n', 'ViewCount': '172', 'Title': 'Universes in dependent type theory', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:30.993', 'LastEditDate': '2013-10-09T18:44:30.993', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '13296', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9179', 'Tags': '<type-theory><homotopy-type-theory><dependent-types>', 'CreationDate': '2013-07-15T13:01:16.747', 'Id': '13285'}{'Body': '<p>I understand that $\\Pi$ types are generalizations of functions and can be interpreted similar to $\\forall$ in logic. I also know that $\\Sigma$ types are generalizations of tuples and can be interpreted similar to $\\exists$ in logic. But whereas I find it easy to imagine $\\Pi$ type examples by thinking in Haskell, I am having a hard time thinking of good examples of $\\Sigma$ types. Is there a particular "canonical" $\\Sigma$ type that gives a good indication of how it can be interpreted as existence when the type is thought of as a proof? </p>\n', 'ViewCount': '101', 'Title': 'Example of existence proof in dependent typing?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:45:26.560', 'LastEditDate': '2013-10-09T18:45:26.560', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9918', 'Tags': '<type-theory><dependent-types>', 'CreationDate': '2013-08-31T16:15:52.920', 'Id': '14060'}{'Body': '<p>Is it possible to use <a href="http://en.wikipedia.org/wiki/Dependent_type" rel="nofollow">Dependent Types</a> in the existing <a href="http://docs.racket-lang.org/ts-guide/" rel="nofollow">Typed Racket</a> implementation? (ie do they exist in it?)</p>\n\n<p>Is it reasonably possible to implement a Dependent Types System using Typed Racket?</p>\n', 'ViewCount': '148', 'Title': 'Is it possible to do Dependent Types in Typed Racket?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-22T00:32:15.773', 'LastEditDate': '2013-10-09T18:43:51.303', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19183', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<programming-languages><typing><type-checking><dependent-types><lisp>', 'CreationDate': '2013-10-08T11:39:46.047', 'Id': '14905'}{'Body': '<p>In the introduction of the book by B.Jacobs, "Categorical Logic and Type Theory" (it\'s online <a href="http://synrc.com/publications/cat/Category%20Theory/Categorical%20Logic/Jacobs%20B.%20Categorical%20Logic%20and%20Type%20Theory.pdf" rel="nofollow">here</a>), he classifies type systems into three general flavours: Simply typed ones, depended typed (term depended types) and polymorphic types (type depended types). He says also there are also mix types. </p>\n\n<p>Now if you start out with a dependently types theory and introduce transitive universes, hence forcing types on the level of terms, are you automatically speaking of a polymorphic type system then?</p>\n', 'ViewCount': '31', 'Title': 'Does types being terms imply your dependend theory is considered polymorphic?', 'LastActivityDate': '2013-12-16T23:43:06.890', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19054', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2695', 'Tags': '<type-theory><dependent-types>', 'CreationDate': '2013-12-16T23:07:20.903', 'Id': '19053'}{'Body': u"<p>In the pre-history of dependent type theory, Per Martin L\xf6f\nintroduced a calculus that is in some sense the simplest dependent\ntype theory and the most general form of impredicative polymorphism.\nIt is often referred to as <strong><em>Type:Type</em></strong> because the kind <strong><em>Type</em></strong> is\nitself of type <strong><em>Type</em></strong>.  Unfortunately, it is inconsistent as a\nlogic. This was discovered by Girard in his famous dissertation [1],\nwho managed to express the Burali-Forti paradox in <strong><em>Type:Type</em></strong>.\nVarious people have analysed, generalised and simplified Girard's\nanalysis, see e.g. [2, 3]. This analysis seems to involve showing that\nnon-terminating terms can be typed.</p>\n\n<p>I have a question about non-termination: do we get non-normalisation <strong><em>at\nthe level of types</em></strong>? By that I mean, is there a type $T$ such that the\nreduction relation $\\rightarrow$ used, explicitly or implicitly, to\ndefine equality of types, gives rise to an infinite reduction sequence\n$$\n   T \\rightarrow T' \\rightarrow T'' \\rightarrow \\cdots?\n$$</p>\n\n<p>[1] J.-Y.. Girard, Une extension de l'interpretation fonctionelle de\nG\xf6del a l'analyse.</p>\n\n<p>[2] T. Coquand, A New Paradox in Type Theory.</p>\n\n<p>[3] A. J. C. Hurkens, A Simplification of Girard's Paradox.</p>\n", 'ViewCount': '68', 'Title': u"Non-termination of types in Martin-L\xf6f's Type:Type?", 'LastEditorUserId': '2887', 'LastActivityDate': '2013-12-19T12:26:08.823', 'LastEditDate': '2013-12-19T12:26:08.823', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19072', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<type-theory><functional-programming><dependent-types><curry-howard>', 'CreationDate': '2013-12-17T14:11:17.690', 'Id': '19065'}{'Body': '<p>I know that <a href="https://en.wikipedia.org/wiki/Idris_%28programming_language%29" rel="nofollow">Idris</a> has dependent types but isn\'t turing complete. What can it not do by giving up Turing completeness, and is this related to having dependent types?</p>\n\n<p>I guess this is quite a specific question, but I don\'t know a huge amount about dependent types and related type systems.</p>\n', 'ViewCount': '236', 'Title': 'What can Idris not do by giving up Turing completeness?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-18T14:35:33.427', 'LastEditDate': '2014-01-08T10:31:43.087', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12668', 'Tags': '<computability><programming-languages><type-theory><dependent-types>', 'CreationDate': '2014-01-08T09:57:09.923', 'FavoriteCount': '1', 'Id': '19577'}{'ViewCount': '99', 'Title': 'What are the difference between and consequences of using type parameters and type indexes?', 'LastEditDate': '2014-01-30T11:09:05.900', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8612', 'FavoriteCount': '1', 'Body': "<p>In type theories, like Coq's, we can define a type with parameters, like this:</p>\n\n<pre><code>Inductive ListP (Element : Type) : Type\n  := NilP  : ListP Element\n   | ConsP : Element -&gt; ListP Element -&gt; ListP Element.\n</code></pre>\n\n<p>Alternatively, we can define a type with an index, like this:</p>\n\n<pre><code>Inductive ListI : Type -&gt; Type\n  := NilI  : forall t, ListI t\n   | ConsI : forall t, t -&gt; ListI t -&gt; ListI t.\n</code></pre>\n\n<p>My questions are:</p>\n\n<ul>\n<li>Are these fundamentally different or fundamentally the same?</li>\n<li>What are the consequences of using one over the other?</li>\n<li>When is it preferable to use one over the other?</li>\n</ul>\n", 'Tags': '<type-theory><dependent-types>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T18:09:57.497', 'CommentCount': '0', 'AcceptedAnswerId': '20115', 'CreationDate': '2014-01-30T09:44:19.307', 'Id': '20100'}{'Body': '<p>the standard List type in Coq can be expressed as:</p>\n\n<pre><code>Inductive List (A:Set) : Set :=\n  nil : List A\n| cons : A -&gt; List A -&gt; List A.\n</code></pre>\n\n<p>as I understand, W-type express a well-founded tree of elements of this type. so, what if <code>nil</code> is not qualified by <code>A</code>? i.e. we have:</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil : List A</code> </p>\n</blockquote>\n\n<p>instead of</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil A: List A</code></p>\n</blockquote>\n\n<p>is this a correct W-type? can I express this in Coq?</p>\n', 'ViewCount': '38', 'Title': 'Is this a well founded inductive type? Can I express this in Coq?', 'LastActivityDate': '2014-02-16T08:07:20.807', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21693', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9922', 'Tags': '<type-theory><dependent-types><coq><inductive-datatypes>', 'CreationDate': '2014-02-14T17:40:00.397', 'Id': '21639'}{'Body': "<p>Could somebody explain the difference between dependent types and refinement types? As I understand it, a refinement type contains all values of a type fulfilling a predicate. Is there a feature of dependent types which distinguishes them? </p>\n\n<p>If it helps, I came across Refined types via the Liquid Haskell project, and dependent types via Coq and Agda. That said, I'm looking for an explanation of how the theories differ. </p>\n", 'ViewCount': '59', 'Title': 'Dependent types vs refinement types', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T05:57:58.417', 'LastEditDate': '2014-02-17T10:00:36.913', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<terminology><programming-languages><type-theory><functional-programming><dependent-types>', 'CreationDate': '2014-02-17T07:54:50.867', 'Id': '21728'}{'Body': '<p>I implemented dependently typed lambda calculus in the spirit of this article: <a href="http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf" rel="nofollow">http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf</a></p>\n\n<p>The calculus, works and I experimented with it and like it. However, I want to add inductive types to do more complex stuff. What are the options for doing this?</p>\n\n<p>I am thinking about two ways of doing so</p>\n\n<ul>\n<li>Introduce Fin-N, Product and W-types and represent inductive types with them.</li>\n<li>Generate induction and recursion axioms.</li>\n</ul>\n\n<p>What can you recommend? How inductive types are represented in systems like Coq, Idris and Agda? Which articles can you recommend me?</p>\n', 'ViewCount': '20', 'Title': 'Representing inductive types', 'LastActivityDate': '2014-03-12T02:23:41.080', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7729', 'Tags': '<dependent-types><coq>', 'CreationDate': '2014-03-12T02:23:41.080', 'Id': '22524'}