{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I need an efficient algorithm that takes input a collection of intervals and outputs the largest subset of non-intersecting intervals. </p>\n\n<p>i.e. Given a set of intervals $I =  \\{I_1, I_2, \\ldots, I_n\\}$ of the real line, we need to output a set of intervals $O = \\{O_1, O_2, \\ldots, O_k\\}$ such that</p>\n\n<ul>\n<li>$O$ is a subset of $I$.</li>\n<li>For any $i \\neq j$, $O_i$ and $O_j$ are non-intersecting.</li>\n<li>$k$ is the maximum possible.</li>\n</ul>\n\n<p>Example: if the intervals are $[1,100], [2,3], [4,5], [6,7], [3,20]$ we should return $\\{[2,3], [4,5], [6,7]\\}$.</p>\n', 'ViewCount': '503', 'Title': 'Algorithm to return largest subset of non-intersecting intervals', 'LastEditorUserId': '7391', 'LastActivityDate': '2013-03-24T21:29:01.710', 'LastEditDate': '2013-03-24T21:29:01.710', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'user2112791', 'PostTypeId': '1', 'Tags': '<algorithms><optimization><integers><intervals><set-cover>', 'CreationDate': '2013-03-23T02:48:15.283', 'FavoriteCount': '0', 'Id': '10713'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to perform some interval-operations, and for addition, subtraction, and logic-/shift-operators, that works very well.</p>\n\n<p>The only problem I have is the multiplication.</p>\n\n<p>An interval $[a, b]$ denotes all two\'s complement numbers $x$ with the property $a \\leq x \\leq b$.</p>\n\n<p>An interval-operation means that if i have a binary operation $\\circ$ and two intervals $[a, b]$ and $[c, d]$, then $[a, b] \\circ [c, d] = [e, f]$ means that for for an arbitrary $x \\in [a, b]$ and $y \\in [c, d]$: $$x \\circ y \\in [e, f].$$</p>\n\n<p>But additionally, I want to have the most precise or a very precise interval.</p>\n\n<p>"The most precise" means that there are the values $w,x \\in [a, b]$ and $y,z \\in [c, d]$ for which holds that $w \\circ y = e$ and $x \\circ z = f$</p>\n\n<p>An example of an interval-operation:</p>\n\n<ul>\n<li>$A = [7,14]$</li>\n<li>$B = [-6, 77]$</li>\n<li>$A + B = [1, 91]$</li>\n</ul>\n\n<p>It\'s correct, because there is no value outside of $[1, 91]$ that can be reached, when adding numbers out of $A$ and $B$.</p>\n\n<p>Also it\'s precise, because $7+(-6) = 1$ and $14+77 = 91$</p>\n\n<p>It seems impossible to find an efficient algorithm that handles all the overflows correctly and finds the precise (or at least a good) interval.</p>\n\n<p>Is there a good algorithm?</p>\n', 'ViewCount': '103', 'Title': "Multiplying intervals in Two's complement", 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-06T14:53:16.570', 'LastEditDate': '2013-06-06T14:53:16.570', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3133', 'Tags': '<binary-arithmetic><arithmetic><intervals>', 'CreationDate': '2013-05-29T15:43:49.867', 'Id': '12360'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I asked this question on stackoverflow, but was suggested to post to same here. So here goes.</p>\n\n<p>The following problem was asked in the recent <a href="https://www.hackerrank.com/contests/oct13/challenges/missile-defend" rel="nofollow">October 20-20 Hack on Hackerrank</a> :</p>\n\n<blockquote>\n  <p>Evil Nation A is angry and plans to launch N guided-missiles at the\n  peaceful Nation B in an attempt to wipe out all of Nation B\u2019s people.\n  Nation A\u2019s missile i will arrive in nation B at the time ti. Missile i\n  communicates with its headquarters by unique radio signals with a\n  frequency equal to fi. Can you help the peaceful Nation B survive by\n  building a defensive system that will stop the missiles dead in the\n  sky?</p>\n  \n  <p><strong>Defensive system:</strong></p>\n  \n  <p>The only way to defend Nation B from the attacking missile is by\n  counter attacking them with a hackerX missile. You have a lot of\n  hackerX missiles and each one of them has its own radio frequency. An\n  individual hackerX missile can destroy Evil Nation A\u2019s attacking\n  missile if the radio frequency of both of the missiles match. Each\n  hackerX missile can be used an indefinite number of times. Its\n  invincible and doesn\u2019t get destroyed in the collision.</p>\n  \n  <p>The good news is you can adjust the frequency of the hackerX missile\n  to match the evil missiles\u2019 frequency. When changing the hackerX\n  missile\u2019s initial frequency fA to the new defending frequency fB, you\n  will need |fB - fA| units of time to do.</p>\n  \n  <p>If two evil missles with same\n  frequency arrive at the same time, we can destroy them both with one\n  hackerX missile. You can set the frequency of a hackerX missile to any\n  value when its fired.</p>\n  \n  <p>What is the minimum number of hackerX missiles you must launch to keep\n  Nation B safe?</p>\n  \n  <p><strong>Input Format:</strong> The first line contains a single integer N denoting the\n  number of missiles.  This is followed by N lines each containing two\n  integers ti and fi denoting the time &amp; frequency of the ith missile.</p>\n  \n  <p><strong>Output Format:</strong> A single integer denoting the minimum number of\n  hackerX\u2019s you need to defend the nation.</p>\n  \n  <p><strong>Constraints:</strong> \n  1 &lt;= N &lt;= 100000</p>\n  \n  <p>0 &lt;= ti &lt;= 100000</p>\n  \n  <p>0 &lt;= fi &lt;= 100000</p>\n  \n  <p>t1 &lt;= t2 &lt;= \u2026 &lt;= tN</p>\n</blockquote>\n\n<p>The problem gets reduced to a Minimum Path Cover Problem which is to be solved in <code>O(nlogn)</code> time based on the constrainsts.\nHowever the best solution to a Minimum Path Cover Problem is using the Hopcroft\u2013Karp algorithm, that leads to the Maximal Matching Problem. The solution to which is <code>O(n^2.5)</code>.\nBut the following solution by <code>icyrhyme9733</code> solves the problem in <code>O(nlogn)</code> :</p>\n\n<pre><code>#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt; &gt; vp;\n    for(int i = 0; i &lt; n; ++i) {\n        int t, f;\n        cin &gt;&gt; t &gt;&gt; f;\n        vp.push_back(make_pair(t + f, t - f));\n    }\n    sort(vp.begin(), vp.end());\n    reverse(vp.begin(), vp.end());\n    vector&lt;int&gt; last(vp.size(), numeric_limits&lt;int&gt;::max());\n    for(int i = 0; i &lt; vp.size(); ++i) {\n        *lower_bound(last.begin(), last.end(), vp[i].second) = vp[i].second;\n    }\n    cout &lt;&lt; lower_bound(last.begin(), last.end(), numeric_limits&lt;int&gt;::max()) - last.begin() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n\n<p>Is it solving a <code>Minimum Path Cover Problem in O(nlogn)</code> time ?  Or is there an optimization that I am missing ?</p>\n\n<p>I found a similar problem on <a href="http://stackoverflow.com/a/10508198/1016784">this thread</a>. They have taken advantage of the fact that the graph is an Interval Graph. Even though being very similar, the same solution cannot be implemented, as the intervals are inverted.</p>\n', 'ViewCount': '121', 'Title': 'DAG Minimum Path Cover in O(nlogn)?', 'LastActivityDate': '2013-10-28T17:37:21.440', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><intervals>', 'CreationDate': '2013-10-28T17:37:21.440', 'Id': '16510'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Let $n$ be an integer, and let $\\mathbb{Z}$ denote the set of all integers.  Let $[a,b]$ denote the interval of integers $\\{a,a+1,a+2,\\dots,b\\}$.</p>\n\n<p>I am looking for a data structure to represent a map $f:[1,n] \\to \\mathbb{Z}$.  I want the data structure to support the following operations:</p>\n\n<ul>\n<li><p>$\\text{get}(i)$ should return $f(i)$.</p></li>\n<li><p>$\\text{set}([a,b],y)$ should update $f$ so that $f(a)=f(a+1)=\\cdots=f(b)=y$, i.e., update $f$ to a new map $f'$ such that $f'(i) = y$ for $i \\in [a,b]$ and $f'(i) = f(i)$ for $i \\notin [a,b]$.</p></li>\n<li><p>$\\text{stab}(i)$ should return the largest interval $[a,b]$ such that $i \\in [a,b]$ and $f$ is constant on $[a,b]$ (i.e., $f(a)=f(a+1)=\\cdots=f(b)$).</p></li>\n<li><p>$\\text{add}([a,b],\\delta)$ should update $f$ to a new map $f'$ such that $f'(i) = f(i) + \\delta$ for $i \\in [a,b]$ and $f'(i) = f(i)$ for $i \\notin [a,b]$.</p></li>\n</ul>\n\n<p>I want each of these operations to be efficient.  I would count $O(1)$ or $O(\\lg n)$ time as efficient, but $O(n)$ time is too slow.  It's OK if the running times are amortized running times.  Is there a data structure that simultaneously makes all of these operations efficient?</p>\n\n<p>(I've noticed a similar pattern come up in a several programming challenges.  This is a generalization that would suffice for all of those challenge problems.)</p>\n", 'ViewCount': '145', 'Title': 'Data structure for map on intervals', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-03T07:49:12.067', 'LastEditDate': '2013-12-02T20:33:03.120', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><data-structures><trees><intervals>', 'CreationDate': '2013-12-02T18:19:49.227', 'FavoriteCount': '1', 'Id': '18542'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given a list of intervals $[s_1, e_1], [s_2, e_2], \\ldots$, what's the most efficient way to determine if an interval $[a, b]$ can be covered by the intervals in the list?</p>\n", 'ViewCount': '52', 'ClosedDate': '2014-02-25T20:19:48.823', 'Title': 'Algorithm to determine if an interval is covered by a list of intervals?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-25T20:20:38.797', 'LastEditDate': '2014-02-25T20:20:38.797', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15029', 'Tags': '<algorithms><intervals>', 'CreationDate': '2014-02-25T14:27:16.193', 'Id': '22026'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to find a linear solution with a small constant factor but I\'m not sure what to search for, or even how to succinctly describe it.  The best I\'ve come up with is:</p>\n\n<blockquote>\n  <p>Given a set of rectangles on a plane find the set(s) which allow the same <code>y</code> value for some largest contiguous set of <code>x</code> values.  All rectangles are axis aligned, the same width, and do not overlap.</p>\n</blockquote>\n\n<p>I find this much easier to visualize so below is an example problem instance and solution.</p>\n\n<p><img src="http://i.stack.imgur.com/uKphj.png" alt="Longest horizontal intersection of contiguous blocks"></p>\n\n<p>Edit:</p>\n\n<p>We have a linear solution that has a constant factor on the order $y_{max} - y_{min}$ which can be pretty big.  Here is an idea of the algorithm I\'ve been trying to work out since originally posting this.</p>\n\n<ul>\n<li>Rectangles are already sorted by $x$ position.</li>\n<li>Maintain an ordered list $I$ of the intervals currently allowing a contiguous line.</li>\n<li>Maintain two variables $(i_{min}, i_{max})$ which are the min and max\n$y$ value of the current intersection (in the example solution $(5, 5.25)$).</li>\n<li>Iterate from $x_0$ to $x_{max}$</li>\n<li><p>At each $x$ position test if any of the current rectangle(s) intersect $(i_{min}, i_{max})$.</p>\n\n<ul>\n<li>1) If yes, add the rectangle to $I$ and update $(i_{min}, i_{max})$.</li>\n<li>2) If no, find the longest suffix of $I$ s.t. it allows overlap with current rectangle.</li>\n<li>3) If no suffix exists or the current $x$ position has no rectangles skip to the next $x$ position with rectangles and reinitialize $I$, and $(i_{min}, i_{max})$.</li>\n</ul></li>\n<li><p>In #2 and #3 save the current $I$ if it allows the widest contiguous line so far.</p></li>\n</ul>\n', 'ViewCount': '51', 'Title': 'What is this problem? Largest set of contiguous x values for which the same y value can be held', 'LastEditorUserId': '527', 'LastActivityDate': '2014-04-03T00:34:55.823', 'LastEditDate': '2014-04-02T23:59:58.480', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '527', 'Tags': '<algorithms><data-structures><computational-geometry><intervals>', 'CreationDate': '2014-04-02T19:00:40.687', 'FavoriteCount': '1', 'Id': '23361'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>What is the fastest way to get one of the value from set of intervals which occurs most frequently?</p>\n\n<p>For example if I have interval (0, 3) and (2, 4) the most frequent value can be 2 or 3.</p>\n', 'ViewCount': '30', 'ClosedDate': '2014-04-13T09:59:15.193', 'Title': 'The most frequent integer value from set of intervals', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-13T07:54:29.607', 'LastEditDate': '2014-04-13T07:54:29.607', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16727', 'Tags': '<algorithms><intervals>', 'CreationDate': '2014-04-12T21:41:53.963', 'Id': '23717'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was reading a paper for recognizing interval graphs. Here is an excerpt from the paper:</p>\n\n<blockquote>\n  <p>Each interval graph has a corresponding interval model in which two intervals overlap if\n      and only if their corresponding vertices are adjacent. Such a representation is usually far\n      from unique. To eliminate uninteresting variations of the endpoint orderings, we shall\n      consider the following block structure of endpoints: Denote the right (resp. left) endpoint of\n      an interval $u$ by $R(u)$ (resp. $L(u)$). In an interval model, define a maximal contiguous set of\n      right (resp. left) endpoints as an R-block (resp. L-block). Thus, the endpoints can be grouped\n      as a left-right block sequence. Since an endpoint block is a set, the endpoint orderings within\n      a block are ignored. It is easy to see that the overlapping relationship does not change if one\n      permute the endpoint order within each block. Define two interval models for $G$ to be\n      equivalent if either their left-right block sequences are identical or one is the reversal of the\n      other. </p>\n</blockquote>\n\n<p>I am unable to understand the notion of equivalent intervals. Can someone help me?</p>\n', 'ViewCount': '37', 'Title': 'Recognizing interval graphs--"equivalent intervals"', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-18T06:40:51.167', 'LastEditDate': '2014-04-18T06:40:51.167', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23890', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11703', 'Tags': '<algorithms><graph-theory><graphs><intervals>', 'CreationDate': '2014-04-17T11:39:56.467', 'Id': '23885'}}