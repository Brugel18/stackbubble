{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Am I correct in my observation that the cardinality of the maximum matching $M$ of a bipartite graph $G(U, V, E)$ is always equal to $\\min(|U|, |V|)$?</p>\n', 'ViewCount': '233', 'Title': 'Size of Maximum Matching in Bipartite Graph', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T19:28:25.763', 'LastEditDate': '2013-01-13T19:28:25.763', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4676', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2922', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2012-09-22T20:14:11.160', 'Id': '4675'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let us say you have a group of guys and and a group of girls. Each girl is either attracted to a guy or not, and vice versa. You want to match as many people as possible to a partner they like.</p>\n\n<p>Does this problem have a name? Is it feasibly solvable? Sounds hard to me...</p>\n\n<p>Ps. note that since the attraction is not neccessarily mutual the standard max-flow solution does not work.</p>\n', 'ViewCount': '120', 'Title': 'Matching girls with boys without mutual attraction (variant of maximum bipartite matching)', 'LastActivityDate': '2012-11-21T13:16:46.817', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6811', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2826', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2012-11-21T10:50:19.373', 'Id': '6807'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '437', 'Title': 'Clarification with Kuhn-Munkres/Hungarian Algorithm', 'LastEditDate': '2012-12-12T20:25:07.587', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1025', 'FavoriteCount': '1', 'Body': '<p>I have been attempting to get my mind around the <a href="http://en.wikipedia.org/wiki/Hungarian_algorithm" rel="nofollow">Kuhn-Munkres/Hungarian Algorithm</a>. I have been using the following statement of the algorithm which I found <a href="http://www.math.uwo.ca/~mdawes/courses/344/kuhn-munkres.pdf" rel="nofollow">here</a>.</p>\n\n<p><img src="http://i.stack.imgur.com/sieBq.png" alt="Kuhn-Munkres Algorithm"></p>\n\n<p>Based on my readings on the algorithm, my understanding is that the improvement of the feasible vertex labeling in step 2. is supposed to be such that $G_l \\subset G_l\'$.</p>\n\n<p>The part I\'m getting stuck on is that it seems to me that it is possible for there to be an edge $xy$ in $G_l$ with $y \\in T$ but $x \\not \\in S$ resulting in the fact that\n$$\nl\'(x) + l\'(y) = l(x) + (l(y) + \\alpha_l) \\not = w(xy)\n$$\nand so $ xy \\not \\in G_l\'$ and $G_l \\not \\subset G_l\'$.</p>\n\n<p>Can anyone point out where I\'m going wrong?</p>\n', 'Tags': '<algorithms><bipartite-matching>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-12T20:25:07.587', 'CommentCount': '8', 'AcceptedAnswerId': '7363', 'CreationDate': '2012-12-11T22:26:40.083', 'Id': '7341'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have 2 questions regarding Bipartiteness with corresponding examples.</p>\n\n<p>1) Can a non-connected graph be bipartite if it has an isolated vertex? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/AzAxV.png" alt="enter image description here">\n<br/>\nI would say YES with this partition:\nV<sub>1</sub> = {A, D, G}\n; V<sub>2</sub> = {B, C, E, F, H}\n<br/>But what confuses me is that A is isolated.\n<br/>Is that a contradiction to the bipartitiness of G ?</p>\n\n<p>2) Is there a rule about the uniqueness of the partitions ? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/dbQww.png" alt="enter image description here">\n<br/>choice1:\nV<sub>1</sub>= {A, C}; V<sub>2</sub> = {B, D}\n<br/>choice2:\nV<sub>1</sub>= {A, D}; V<sub>2</sub> = {B, C}</p>\n\n<p>Does it matter which one i choose?</p>\n', 'ViewCount': '82', 'Title': 'Graph Bipartiteness', 'LastActivityDate': '2013-01-08T02:45:16.330', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7824', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2013-01-08T02:10:47.957', 'Id': '7823'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '88', 'Title': 'Bipartite graph question', 'LastEditDate': '2013-02-11T22:39:58.533', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2003', 'FavoriteCount': '1', 'Body': "<p>Assume you are given a bipartite graph $G = (U, V, E)$ and you are given an integer $n$. Assume also that for each $v \\in V$, you are given two integers $v_{min}$ and $v_{max}$ (where $v_{min} \\le v_{max}$).</p>\n\n<p>The problem is to find a subset $U'$ of $U$ of size $n$ such that for each $v \\in V$, the number of edges coming into $v$ from $U'$ is between $v_{min}$ and $v_{max}$.</p>\n\n<p>Given a problem like this, can we determine efficiently whether there is a solution? And, if there is a solution, can we find one efficiently?</p>\n\n<p>If we can't do so efficiently, is there an approximation algorithm?</p>\n", 'Tags': '<algorithms><graphs><bipartite-matching>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-11T22:57:36.760', 'CommentCount': '2', 'AcceptedAnswerId': '9694', 'CreationDate': '2013-02-11T22:35:47.340', 'Id': '9693'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '696', 'Title': 'How to find the maximum independent set of a directed graph?', 'LastEditDate': '2013-03-06T01:05:54.933', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5218', 'FavoriteCount': '2', 'Body': u'<p>I\'m trying to solve <a href="http://www.spoj.com/problems/DIVREL/" rel="nofollow">this problem</a>.  </p>\n\n<blockquote>\n  <p><strong>Problem</strong>: Given $n$ positive integers, your task is to select a maximum number of integers so that there are no two numbers $a, b$ in which $a$ is divisible by $b$.</p>\n</blockquote>\n\n<p>I have to find the Maximum independent set and the size of this set.   The size can be found by <a href="http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29" rel="nofollow">K\xf6nig\'s theorem</a>. But how can I find the Maximum Independent Set (i.e. which vertex are part of the set).  </p>\n\n<p>I did some search also and found something <a href="http://apps.topcoder.com/forums/?module=Thread&amp;threadID=647913&amp;start=0&amp;mc=5#1127789" rel="nofollow">here</a>:</p>\n\n<p><code>If removing a vertex does not change minimum path cover then I can get the desired  result without that vertex.</code></p>\n\n<p>But I don\'t understand the underlying theorem. Any help will be greatly helpful.</p>\n', 'Tags': '<algorithms><graph-theory><bipartite-matching>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-06T01:05:54.933', 'CommentCount': '3', 'AcceptedAnswerId': '10303', 'CreationDate': '2013-03-04T22:16:02.387', 'Id': '10274'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a problem that I was able to conceptualize as following:</p>\n\n<h2>Problem</h2>\n\n<p>We have a set of n people. And m subsets representing their ethnicity like White, Hispanic, Asian etc. Given any combination of these people, I want to check if it is a diverse group.</p>\n\n<p>A diverse group is a group that satisfies several requirements, each requirement is of the form "at least $k_i$ persons in the group belong to subset $S_i$". Here is the tricky part, one person can only be used to satisfy one requirement. As in, you can\'t use him/her for multiple requirements.</p>\n\n<h2>Example:</h2>\n\n<p>Given:</p>\n\n<p>At least two people from Hispanic= {a,b,c}</p>\n\n<p>At least two people from African={a,d,e}</p>\n\n<p>Is the group {a,c,d} a diverse group?</p>\n\n<p>The group {a,c,d} is not diverse because you cant count a as Hispanic and African. But, the group {a,c,d,e} is diverse because we have two Hispanics a and c and two African d and e.</p>\n\n<h2>Attempt:</h2>\n\n<p>I think this is an instance of the Assignment problem. The jobs are the ethnicity and we can put as many ethnicity as the requirement dictate. For example, if we need two Hispanic, then we put two Hispanic jobs. However there only some people are able to do a particular job. Is there a name for such a problem? any algorithms somewhere in the internet? If not how would the implementation look like? </p>\n\n<p>This is my attempt so far:</p>\n\n<p>I will construct a bipartite graph with the set of people $P$ on one hand and the set of ethnicity on the other $S$. We will put an edge between a person $p_i$ and an ethnicity $S_i$ if he/she belongs to the ethnicity.\n Now, we will modify the graph, for every ethnicity $S_i$ duplicate it $k_i$ times ($S_{i,1}, S_{i,2}, ... , S_{i,k_i}$). And add new edges accordingly. Find the maximum matching M of this graph. </p>\n\n<p>Now, merge the $S_{i,j}$s into one $S_i$ and there you have a diverse group. However, a maximum matching is only a possible solution to to the problem. And my problem is a decision problem, I want to check if a given group is a solution or not. </p>\n', 'ViewCount': '217', 'Title': 'Assignment problem with no cost', 'LastActivityDate': '2013-03-20T13:40:37.340', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7320', 'Tags': '<graph-theory><bipartite-matching><matching><assignment-problem>', 'CreationDate': '2013-03-17T23:04:11.883', 'FavoriteCount': '1', 'Id': '10591'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $B = G(L, R, E)$ be a bipartite graph. I want to find out whether this graph has a perfect matching. One way to test whether this graph has a perfect matching is Hall's Marriage Theorem, but it is inefficient (i.e $|\\mathcal P(L)| = 2^{|L|}$ tests -- not polynomial). I can always find out whether a perfect matching exists by computing a maximum cardinality matching and testing its perfectness, but this involves computing that perfect matching. </p>\n\n<p>Is there an <em>efficient</em> way of deciding whether a perfect bipartite matching exists without computing the matching it self? Ideally I would want an algorithm which is faster than algorithms like Hopcroft Karp or matrix based matching algorithms, which explicitly find out the matching (i.e so not computing the matching makes sense).</p>\n\n<p>Edit: The italic part.</p>\n", 'ViewCount': '380', 'Title': 'Existence of bipartite perfect matching', 'LastEditorUserId': '7312', 'LastActivityDate': '2013-03-29T13:21:34.500', 'LastEditDate': '2013-03-29T12:55:00.763', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10895', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7312', 'Tags': '<graphs><bipartite-matching>', 'CreationDate': '2013-03-29T12:12:45.210', 'Id': '10891'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the Hopcroft-Karp algorithm for bipartite matching, I don't understand the purpose of the breadth first search.  I think it's used to find a set of vertex disjoint augmenting paths, but I'm not sure what the significance of that is or even what that means.  Why do the augmenting paths have to be the shortest?  And why do they have to be vertex disjoint?</p>\n", 'ViewCount': '169', 'Title': 'In the Hopcroft-Karp algorithm, what is the purpose of the breadth first search?', 'LastActivityDate': '2013-08-17T13:24:49.037', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2013-05-15T02:46:31.397', 'Id': '12030'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So say we have a bipartite graph G=(X,Y,E). Let\'s make a game out of it.</p>\n\n<p>I go first. I pick a node in X. You go next. You pick a node in Y that is connected by an edge to the node I picked. Next it\'s my turn. I pick another node in X (must be a new one that hasn\'t been used before) that is also connected to the node in Y you just picked. We continue playing in this manner, until someone cannot pick a node (i.e. all edges out of the current node have already been used). When that happens, the person who cannot pick a next node loses.</p>\n\n<p>I\'m supposed to find a polynomial time algorithm to decide which of the two players (you or me) can force a "win" for a given bipartite graph.</p>\n\n<p>I\'m stumped. I\'ve approached this in many different ways, including the following two:</p>\n\n<p>1) 1) each node in the xy "path" played will use two edges, except for the first and last nodes which will only use one edge. Idea: add one new node on each side of the bipartite graph, and connect to all opposite nodes. Then check for a perfect (or maximal) matching twice, removing the edges used in the first perfect (maximal) matching when finding the second one. I don\'t think this really helps us with the problem, though, as there are many different nodes you could visit next given a current node.</p>\n\n<p>2) A second idea was to work with alternating/augmenting paths (as we "zig-zag" between the two sides). I again got stuck since at any given node there are many possible nodes to visit next.</p>\n\n<p>Does anyone have any suggestions for this problem? I\'m thinking it has to do with matching, but I could be wrong.</p>\n\n<p>Thanks in advance!</p>\n', 'ViewCount': '120', 'Title': 'Bipartite Graph Game', 'LastActivityDate': '2013-11-13T08:27:30.500', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '17976', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10680', 'Tags': '<graph-theory><graphs><combinatorics><computer-networks><bipartite-matching>', 'CreationDate': '2013-11-12T22:58:47.500', 'Id': '17974'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two sets A and B of sizes |A| = n and |B| = m, where m >= n.\nThere are edges from set A to set B.\nI need to find the <code>number</code> of matchings where all of vertices in set A have been matched with one vertex in set B.\nIs it possible to caclulate this quantity ?</p>\n\n<p>(I have very little knowledge of Graph Thory and Bipartite Matching or how it is computed)</p>\n', 'ViewCount': '38', 'Title': 'Number of Matchings in a Bipartite', 'LastActivityDate': '2013-12-25T14:20:27.127', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19276', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graphs><combinatorics><bipartite-matching><matching>', 'CreationDate': '2013-12-25T14:06:18.887', 'Id': '19275'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question was asked in the onsite regionals for ACM ICPC 2013 at Amritapuri.\nIn short, the question asked to find the number of ways to fill a $ 2\\times N$ grid with $M$ colors such that no two cells with the same row or same column have the same color.</p>\n\n<p>The limits given are $1 \\leq N$, and $M \\leq 1000$ with 1000 test cases per input. </p>\n\n<p>Based on the constraints the approach that comes to my mind after a long struggle includes having a precomputed DP table which can be used for every test case. I tried to apply the inclusion-exclusion principle but could not come up with any solution. I also tried to solve it using bipartite perfect matchings, but no success. How should I approach this question?</p>\n', 'ViewCount': '276', 'Title': 'Number of ways to fill a 2xN grid with M colors', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-27T17:23:20.610', 'LastEditDate': '2013-12-27T17:23:20.610', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19291', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><combinatorics><permutations><bipartite-matching>', 'CreationDate': '2013-12-25T20:33:19.390', 'Id': '19288'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In the last 2 paragraphs of the paper about Hopcroft\u2013Karp algorithm to find the maximum cardinality matching in bipartite graph:</p>\n\n<blockquote>\n  <p><a href="https://dl.dropboxusercontent.com/u/64823035/04569670.pdf" rel="nofollow">https://dl.dropboxusercontent.com/u/64823035/04569670.pdf</a></p>\n  \n  <p>The execution time of a phase is O(m+n), where m is the number of\n  edges in G, and n is the number of vertices. Hence the execution time\n  of the entire algorithm is O((m+n)s), where s is the cardinality of a\n  maximum matching.</p>\n  \n  <p>If G has n vertices then m &lt;= n^2 / 4 and s &lt; n / 2 so that the\n  execution time is bounded by O(n^(5/2)).</p>\n</blockquote>\n\n<p>I don\'t understand given:</p>\n\n<pre><code>m &lt;= n^2 / 4\ns &lt;= n / 2\n</code></pre>\n\n<p>why they concluded:</p>\n\n<pre><code>O((m+n)s) = O(n^(5/2))\n</code></pre>\n\n<p>Shouldn\'t it be:</p>\n\n<pre><code>O((m+n)s) = O(n^3)\n</code></pre>\n\n<p>Any idea?</p>\n', 'ViewCount': '78', 'Title': u'Hopcroft\u2013Karp algorithm time complexity', 'LastEditorUserId': '12572', 'LastActivityDate': '2014-01-03T14:30:49.710', 'LastEditDate': '2014-01-03T14:30:49.710', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12572', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal><bipartite-matching>', 'CreationDate': '2014-01-03T13:58:38.513', 'Id': '19486'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have question on understanding the following neighborhood relation within a local-search approximation scheme. \nLet $M$ be a legal matching on any bipartite graph. \nLet $U_k$ be the neighborhood defined as follows:\n$$U_k := \\{M' : |(M' \\backslash M) \\cup (M \\backslash M')| \\leq k\\}$$</p>\n\n<p>Can somebody give me an example or explain this to me? </p>\n\n<p>If i choose a small k-value, the cardinality of $M'$ will be small as well, but how does an algorithm decide which matching pair of nodes to take?</p>\n\n<p>If we define node-values and make it a weighted matching,let say we define a weight function $w_e \\in \\mathbb{R}$ for any edge e in our graph, now the algorithm may use greedy method and take the best possible pair of nodes (with greatest weight). </p>\n\n<p>But I still don't understand the exact set definition of our neighborhood.</p>\n\n<p>I would be grateful for an example, because I'm stumped on this one. </p>\n", 'ViewCount': '59', 'Title': 'Local search: Problem with neighborhood definition', 'LastActivityDate': '2014-01-10T12:36:41.790', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19626', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12731', 'Tags': '<optimization><approximation><heuristics><bipartite-matching>', 'CreationDate': '2014-01-10T11:48:35.183', 'Id': '19625'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is a shop which consists of N items and there are M buyers. Each buyer wants to buy a specific set of items. However, the cost of all transactions is same irrespective of the number of items sold. So, the shopkeeper needs to maximize the number of buyers. The buyers will buy only if all the items are being sold. Items are unique. All items need not be sold.</p>\n\n<p>So, basically, we have a bipartite graph. We need to find a set of edges which maximize the number of nodes on Buyer vertex set such that each node on item set has only one edge. Any suggestions?</p>\n', 'ViewCount': '28', 'Title': 'How to maximize the number of buyers in a shop?', 'LastActivityDate': '2014-03-08T15:42:28.667', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15420', 'Tags': '<graph-theory><greedy-algorithms><bipartite-matching>', 'CreationDate': '2014-03-08T15:42:28.667', 'Id': '22399'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a variant of bidding problem at hand.\nThere are N bidders(~20) who bid for items from a pool of many items(~10K). Each bidder can bid many items. I want to maximize the number of bidders who are satisfied. A bidder is satisfied if he gets all the items that he bid for in the first place. For eg-</p>\n\n<pre><code>Bidders = A,B,C\nItems = 1,2,3,4\n\nBidder    Bids\nA         1,2\nB         2,3\nC         3,4\n</code></pre>\n\n<p><img src="http://i.stack.imgur.com/Xcxlu.png" alt="enter image description here">\nIn this case its only possible to satisfy 2 bidders at max.</p>\n\n<p>I\'ve tried to model the problem to a maxflow problem and have taken several approaches but to no avail\nMy approaches so far-</p>\n\n<ol>\n<li><p>Tried to model this problem as a bipartite matching problem. The only problem being that instead of a one-one mapping I have a one-many mapping with an AND condition. </p></li>\n<li><p>A maxflow problem with edges going from source to each vertex with a capacity of number of bids. Problem here being ensuring that all edges from a bidder are selcted.</p></li>\n<li><p>A maxflow problem with both upper bounded and lower bounded edge capacities.</p></li>\n</ol>\n', 'ViewCount': '155', 'Title': 'Maximum number of matched vertexes in a one-to-many bipartite graph', 'LastActivityDate': '2014-03-12T17:58:04.897', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '22548', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15606', 'Tags': '<algorithms><graph-theory><network-flow><bipartite-matching><max-cut>', 'CreationDate': '2014-03-12T16:10:00.057', 'Id': '22542'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am working out with the rooks problem. If there are m rooks on an nxn chessboard,i have to give describe a polynomial (in m and n) time algorithm that \ufb01nds a maximum-sized subset of the rooks such that if we leave this subset on the chessboard and remove all other rooks, then no two rooks attack one another. (Two rooks are said to attack one another if and only if they are either in the same row or in the same column with no other intervening rooks between them.)</p>\n\n<p>My idea for solving this problem is to consider a bipartite graph (X,Y) where X is the rows in the chessboard and Y is the columns. if a row and column have a rook placed at their intersection, then there is an edge between the those vertices from x to y. This can be converted into a maximum flow network and the value of max flow is the max matching. </p>\n\n<p>In order to find a polynomial time algorithm i can run maybe BFS.</p>\n\n<p>I wanted to know that if i build my solution on this idea shall it be correct. Is there a better algorithm (polynomial in m and n)?</p>\n\n<p>Any help is appreciated.</p>\n', 'ViewCount': '34', 'Title': 'maximum bipartite matching', 'LastActivityDate': '2014-03-20T02:28:19.897', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6688', 'Tags': '<network-flow><bipartite-matching>', 'CreationDate': '2014-03-20T01:48:01.570', 'Id': '22840'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Students will identify certain students they want to work with. I have therefore decided to split them into two groups where I want to minimize the number of people in Group 1 who want to work with students from Group 2. </p>\n\n<p>I was thinking about creating a source node <em>s</em>, and creating a node for each person ($p_i$) - followed by hooking up the <em>s</em> to each $p_i$. Then I would create, another series of nodes for each person ($q_i$) and hook up each $p_i$ to each $q_i$ if $p_i$ <strong>doesn\'t</strong> want to work with $q_i$. Then, I would hook up each $q_i$ to a terminal node <em>t</em>. Each of the edges would have weight 1.</p>\n\n<p>I was thinking about running Edmonds\u2013Karp on it. Now, the solution would yield the maximum bipartite matching of the group (see e.g. <a href="https://www.youtube.com/watch?v=c9uLwB6aUVQ" rel="nofollow">here</a>). For each active arc from $p_i$  to $q_i$ in the final diagram, I would separate those two students.</p>\n\n<p>However, I have a bad taste in my mouth after running this algorithm; the bad taste stems from modeling the instance with respect to my intention: If I maximize the complement (the desire not to work with someone), do I really minimize the desire of students to work with each other across the two groups?</p>\n\n<p>If my hunch is correct (in that I\'m wrong), please point me in the right direction.</p>\n', 'ViewCount': '53', 'Title': 'How to optimally seperate a student body?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T09:54:48.057', 'LastEditDate': '2014-04-09T09:53:59.487', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23586', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<algorithms><optimization><polynomial-time><bipartite-matching>', 'CreationDate': '2014-04-09T06:15:38.270', 'Id': '23582'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Thanks to Yuval Filmus, I got to read <a href="http://theory.stanford.edu/~trevisan/cs261/lecture14.pdf" rel="nofollow">these lecture notes by Trevisan</a>. At the bottom half of Page 5, </p>\n\n<blockquote>\n  <p>The capacity of cut $S$ is the number of edges that go from $S$ to $\\overline{S}$, that is $\\text{Capacity}(S) = |L_2|+|R_1|+\\text{edges}(L_1, R_2)$.</p>\n</blockquote>\n\n<p>Here, $L_1 = S \\cap L$, $L_2 = L \\setminus S$, $R_1 = S \\cap R$ and $R_2 = R \\setminus S$. Furthermore, $L$ are the left edges and $R$ are the right edges.</p>\n\n<p>I don\'t understand how he arrived at the conclusion that</p>\n\n<blockquote>\n  <p>number of edges that go from $S$ to $\\overline{S} = |L_2|+|R_1|+\\text{edges}(L_1, R_2)$</p>\n</blockquote>\n\n<p>I don\'t understand the meaning of this expression. I drew it out on paper (highlighting all graph elements of the expression) and I still don\'t get it. Could somebody please explain to me how this expression is generated in simple and detailed terms?</p>\n', 'ViewCount': '15', 'Title': "The min cut capacity in a network based on a bipartite graph (Hall's Theorem)", 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-16T11:50:35.420', 'LastEditDate': '2014-04-16T08:33:57.210', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23855', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graph-theory><bipartite-matching>', 'CreationDate': '2014-04-16T05:18:01.800', 'Id': '23843'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29#Proof" rel="nofollow">Wikipedia</a> shows how one can determine the minimum vertex cover in a bipartite graph ($G(X \\cup Y, E)$) in polytime from a maximum flow using alternating paths. However, I read that the (S,T) cut (extracted from the final residual network) can also be used to determine the minimum vertex cover:</p>\n\n<p>$$(X\\cap T)\\cup(Y\\cap S)$$</p>\n\n<p>If this expression is a correct alternative, I don\'t have an intuition for why it\'s true. The best intuition I\'ve been able to come up with is: Select each vertex on the left (X) that has a positive flow leading up to it and select each vertex on the right if there is no flow leading up to it. Why is this set equal to the minimum vertex cover?</p>\n', 'ViewCount': '13', 'Title': 'Determining the minimum vertex cover in a bipartite graph from a maximum flow/matching using the residual network rather than alternating paths', 'LastActivityDate': '2014-04-17T01:33:45.290', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23873', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graphs><network-flow><bipartite-matching>', 'CreationDate': '2014-04-17T00:27:40.150', 'Id': '23871'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a bipartite graph similar to the marriage problem, where there are M males and N females, and a 1:1 matching between males and females is desired (with the remainder of the more populous gender remaining unmatched).</p>\n\n<p>The differences between my problem and existing research I've found:</p>\n\n<ol>\n<li>Want to maximize the number of pairings at the expense of stability. Stability is nice as a secondary objective, but not required.</li>\n<li>Preference lists are not exhaustive. Eg. m_1 only wants n_3 and cannot be matched with any other.</li>\n</ol>\n\n<p>Can anyone point me in some possible directions?</p>\n", 'ViewCount': '33', 'Title': 'Marriage algorithm that maximizes number of pairings', 'LastActivityDate': '2014-04-21T22:40:51.340', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16969', 'Tags': '<algorithms><graphs><bipartite-matching>', 'CreationDate': '2014-04-21T22:40:51.340', 'Id': '24008'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '39', 'Title': 'Concrete and simple applications for bipartite graphs', 'LastEditDate': '2014-04-23T19:27:43.003', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16536', 'Body': '<p>I am looking for concrete and simple problems that may be solved using bipartite graphs or bipartite graph properties. Any idea along with explanations are welcome.</p>\n', 'ClosedDate': '2014-04-24T17:37:00.217', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'LastEditorUserId': '16536', 'LastActivityDate': '2014-04-24T17:03:52.407', 'CommentCount': '3', 'AcceptedAnswerId': '24083', 'CreationDate': '2014-04-23T19:20:35.893', 'Id': '24057'}