{'Body': '<p>If a weighted graph $G$ has two different minimum spanning trees $T_1 = (V_1, E_1)$ and $T_2 = (V_2, E_2)$, then is it true that for any edge $e$ in $E_1$, the number of edges in $E_1$ with the same weight as $e$ (including $e$ itself) is the same as the number of edges in $E_2$ with the same weight as $e$? If the statement is true, then how can we prove it?</p>\n', 'ViewCount': '1156', 'Title': 'Do the minimum spanning trees of a weighted graph have the same number of edges with a given weight?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-14T20:29:01.367', 'LastEditDate': '2012-06-02T23:23:48.057', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2211', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<graph-theory><spanning-trees><weighted-graphs>', 'CreationDate': '2012-06-02T22:25:00.557', 'Id': '2204'}{'Body': "<p>Is there a way to create a single edge on a graph that connects 3 or more nodes? For example, let's say that the probability of Y occurring after X is 0.1, and the probability of Z occurring after Y is 0.001, but the probability of Z occurring after <em>both</em> X and Y occur is 0.95. If the probabilities are assigned to each edge as weights, how can I make this happen?</p>\n\n<p>$$X _\\overrightarrow{0.1} Y$$</p>\n\n<p>$$Y _\\overrightarrow{0.001} Z$$</p>\n\n<p>$$\\overrightarrow{X \\underrightarrow{} Y \\underrightarrow{0.95}} Z$$</p>\n", 'ViewCount': '110', 'Title': 'An edge that connects more than two nodes in a graph?', 'LastEditorUserId': '2214', 'LastActivityDate': '2012-07-20T01:26:43.280', 'LastEditDate': '2012-07-19T21:55:12.563', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2214', 'Tags': '<algorithms><graphs><probabilistic-algorithms><weighted-graphs>', 'CreationDate': '2012-07-19T21:42:57.053', 'Id': '2826'}{'Body': "<p>I ran into the following problem:</p>\n\n<p>Given a directed acyclic graph with real-valued edge weights, and two vertices s and t, compute the minimum s-t cut.</p>\n\n<p>For general graphs this is NP-hard, since one can trivially reduce max-cut to it by simply reversing the edge weights (correct me if I'm wrong).</p>\n\n<p>What is the situation with DAGs? Can min-cut (or max-cut) be solved in polynomial time? Is it NP-hard and, if so, are there any known approximation algorithms?</p>\n\n<p>I tried to find work on this but wasn't able to (maybe I'm just using wrong keywords in my searches), so I was hoping somebody may know (or find) something about this.</p>\n", 'ViewCount': '521', 'Title': 'Minimum s-t cut in weighted directed acyclic graphs with possibly negative weights', 'LastActivityDate': '2012-11-05T21:05:51.660', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '6498', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '691', 'Tags': '<algorithms><complexity-theory><graph-theory><weighted-graphs>', 'CreationDate': '2012-11-04T18:19:49.463', 'Id': '6476'}{'ViewCount': '1104', 'Title': u"Modifying Dijkstra's algorithm for edge weights drawn from range $[1,\u2026,K]$", 'LastEditDate': '2012-11-21T08:01:32.647', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '2', 'Body': '<p>Suppose I have a directed graph with edge weights drawn from range $[1,\\dots, K]$ where $K$ is constant. If I\'m trying to find the shortest path using <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a>, how can I modify the algorithm / data structure and improve the time complexity to $O(|V|+|E|)$?</p>\n', 'Tags': '<algorithms><data-structures><shortest-path><weighted-graphs>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T20:43:49.977', 'CommentCount': '6', 'AcceptedAnswerId': '6820', 'CreationDate': '2012-11-21T03:08:52.193', 'Id': '6797'}{'Body': '<p>I have n commodities with each a unique source and sink node. Each source-sink pair is connected in some manner on a directed acyclic graph. All arc weights are non-negative. The goal is to find the shortest paths to transport the commodities between their respective source-sink pairs.</p>\n\n<p>Is there any algorithm that can solve this kind of problem rapidly, possibly using topological sorting first? How is this affected if there is unlimited/limited capacity on the arcs?</p>\n\n<p>Many thanks!</p>\n', 'ViewCount': '52', 'Title': 'Multicommodity shortest path problem on a directed acyclic graph', 'LastActivityDate': '2013-06-11T10:46:16.073', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8620', 'Tags': '<shortest-path><weighted-graphs>', 'CreationDate': '2013-06-11T10:46:16.073', 'Id': '12616'}{'Body': u'<p>I need your help with an exercise on <a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" rel="nofollow">Ford-Fulkerson</a>.</p>\n\n<blockquote>\n  <p>Suppose you are given a flow network with capacities $(G,s,t)$ and you are also given the max flow $|f|$ in advance.</p>\n  \n  <p>Now suppose you are given an arc $e$ in $G$ and suppose this arc\'s capacity is increased by one.</p>\n  \n  <p>Give an efficent algorithm which returns true iff the increase of the capacity of the arc $e$ will allow an increase in the max flow.</p>\n</blockquote>\n\n<p>I suppose we shouldn\'t run Ford-Fulkerson again but somehow use the given $|f|$\u2026 Any ideas how?</p>\n', 'ViewCount': '237', 'LastEditorDisplayName': 'user742', 'Title': 'Effect of increasing the capacity of an edge in a flow network with known max flow', 'LastActivityDate': '2013-06-17T23:03:08.163', 'LastEditDate': '2013-06-17T23:03:08.163', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'SyndicatorBBB', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<algorithms><graph-theory><network-flow><weighted-graphs>', 'CreationDate': '2013-06-16T16:41:05.080', 'Id': '12703'}{'Body': "<p>I've been looking for an algorithm which divides an undirected, weighted, planar and simple graph into $k$ disjoint subgraphs. Here, the graph is sparse, $k$ is fixed, and there are no negative edge weights. After cutting, each subgraph must be connected (i.e. there must be a path between any two vertices of the subgraph which is only composed of vertices in that subgraph).</p>\n\n<p>However, unlike most existing work on graph partitioning out there, I don't intend to obtain subgraphs that contain the same approximate number of vertices. Instead, I would like these subgraphs to have similar sum of edge weights. In other words, I would like to minimize the sum of edge weights of the subgraph with maximal weight and ideally cut long (weighted) edges.</p>\n\n<p>Is there a name for this problem? I wasn't able to find anything about this on the web. Also, how can I approach this problem?</p>\n", 'ViewCount': '185', 'Title': 'Dividing a weighted planar graph into $k$ subgraphs with balanced weight', 'LastEditorUserId': '9431', 'LastActivityDate': '2013-11-06T15:14:17.837', 'LastEditDate': '2013-08-03T14:22:17.707', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9431', 'Tags': '<graph-theory><weighted-graphs><cluster><partition-problem>', 'CreationDate': '2013-08-02T04:01:20.273', 'FavoriteCount': '1', 'Id': '13571'}{'Body': "<p>I am trying to find an efficient solution to my problem. Let's assume that I have positive weighted graph <code>G</code> containing 100 nodes(each node is numbered) and it is an acyclic graph. So there cannot be any edge like 2,2 or 2,1. I have got a list of nodes let's say 10 from graph <code>G</code>. Let's say each of these nodes are also in an array. I am looking for a way to find the shortest path's total weight from node 1 to 100 that passes through at least some particular(let's say 5) of those nodes from that list.</p>\n\n<p>To simplify it, consider graph with 6 nodes, 0...5, now node 1 and 4 are marked as points where we could specify to pass. Let's say existing paths are 0-1-2-5, 0-3-4-5, and 1-4. Now let's say all edges are weighted as 5 except 3 to 4 is weighted as 1. If we run a shortest path algorithm this would basically find the path 0-3-4-5 as it is weighted 11. However if we run an algorithm specifying minimum amount of specified points and try the amount 2. Then the algorithm should be running on 0-1-4-5 which is weighted as 15.</p>\n\n<p>I have written this way</p>\n\n<pre><code>    shortestPath(destinationNode, minAmount) \n\n        if(destinationNode == srcNode &amp;&amp; minAmount &lt; 1) \n            return 0\n\n        else if(destinationNode == srcNode &amp;&amp; minAmount &gt; 1) \n            return INFINITY\n\n        int destNo = destinationNode get number\n        int cost = INFINITY\n        for (int i = 0; i &lt; destNo; i++)\n            if (d[i][destNo] != null) \n                int minimumAmountCount = minAmount;\n                for (int j = 0; j &lt; marked.length(); j++) \n                    if (marked[j] == i) \n                        minimumAmountCount = minimumAmountCount - 1;\n\n                cost = MIN(cost, shortestPath(Node(i), minimumAmountCount);\n\n        return cost;\n</code></pre>\n\n<p>Basically we call this algorithm by using the our destination node and minimum amount of nodes from that list. Firstly we want to make sure that this is a recursive function and it should have a stopping point, which would be when passed destination is equal to source node(which is essentially node #0). The second case we need to check is whether we visited enough amount, so if it is less than 1(0 or negative number) then we visited enough points and return 0 as distance from node #0 to node #0 would be 0. If we did not visit enough amount then we return infinity so that algorithm would consider other paths.</p>\n\n<p>So in order for the returning part to work, we have to define the destination node's number(if we consider that we have 100 nodes it would be node #99 at the initial start) and initialise cost as infinity.</p>\n\n<p>Then we run a for loop that starts from 0(essentially node #0) till our current node number, this is because there are no backwards edges on the graph. By using node number we check from the matrix whether there is an existing weight for those nodes. If it exist then we initialise a variable for our current minimum amount and then run a loop and check if source to the current destination is in the list of marked nodes. If it is marked then we simply decrement the minimum amount.</p>\n\n<p>For the final step we run the function again by changing destination as the current source and with the current minimum amount.</p>\n\n<p>But it seems very expensive, considering the fact that the worst case complexity of  nested loop takes O(|Node|^2) and total recurrence would take O(|Node|^2 * |Edges|). So is there any other efficient solution for this problem?</p>\n", 'ViewCount': '799', 'Title': 'Shortest path that passes through specific node(s)', 'LastEditorUserId': '8849', 'LastActivityDate': '2013-10-11T03:40:33.580', 'LastEditDate': '2013-10-10T23:46:31.867', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8849', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T06:29:19.223', 'FavoriteCount': '0', 'Id': '14977'}{'Body': "<p>I have written an A* algorithm to find the shortest path through a directed cyclic graph.  I am trying to modify it to find the longest path through the same graph.</p>\n\n<p>My attempt was to write it so that all I change is [1] the weights per edge (making them negative instead of positive) and [2] the heuristic function.</p>\n\n<p>I seem to be having trouble getting it to do this. It is pretty good at finding the longest path sometimes, but it is not guaranteed.  </p>\n\n<p>It seems that the problem lies with [2] the heuristic -- for shortest path an L2 norm is a good optimistic way to get it to head towards the goal, but for longest path I want the heuristic to point it at paths that are further from the goal to continue to increase total length. </p>\n\n<p>If I set the heuristic to return 0 so that it's a Dijkstra's search, it's less predictable as there's no incentive to search from nodes further away (using [1] negative weights per edge).</p>\n\n<p>I think if I keep the weights positive and try to maximize the score instead of minimize it may work, but I was attempting to do this without changing the algorithm, only the edge weights and the heurstic.</p>\n\n<p>I have found similar posts on stackExchange but they don't answer my specific questions:</p>\n\n<p>Q1) Can this be done with A*</p>\n\n<p>Q2) Is setting the weights negative the right thing to do</p>\n\n<p>Q3) Is the only way to do this is to set the heuristic to zero and keep the weights positive and try to maximize the score instead of minimize it?</p>\n", 'ViewCount': '1136', 'Title': 'A* to find the longest path in a directed cyclic graph', 'LastActivityDate': '2013-10-10T22:54:53.123', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14996', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10643', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T18:39:05.643', 'Id': '14991'}{'ViewCount': '708', 'Title': 'Shortest non intersecting path for a graph embedded in a euclidean plane (2D)', 'LastEditDate': '2013-12-10T03:44:41.487', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '7', 'Body': '<p>What algorithm would you use to find the shortest path of a graph, which is embedded in an euclidean plane, such that the path should not contain any self-intersections (in the embedding)?</p>\n\n<p>For example, in the graph below, you want to go from $(0,0) \\rightarrow (-3,2)$. Normally, an algorithm like Dijkstra\'s algorithm would produce a sequence like:</p>\n\n<p>$$\\left[ (0,0) \\stackrel {3}{\\rightarrow} (0,3) \\stackrel{\\sqrt{2}}{\\rightarrow} (1,2) \\stackrel{4}{\\rightarrow} (-3,2) \\right] = 7+\\sqrt{2}.$$</p>\n\n<p>Full graph:</p>\n\n<p><img src="http://i.stack.imgur.com/l3OkDm.jpg" alt="enter image description here"></p>\n\n<p>Shortest path:</p>\n\n<p><img src="http://i.stack.imgur.com/HwDQtm.jpg" alt="enter image description here"></p>\n\n<p>Shortest non-intersecting path:</p>\n\n<p><img src="http://i.stack.imgur.com/sIj1wm.jpg" alt="enter image description here"></p>\n\n<p>However, this path intersects itself on the euclidean plane, therefore I <em>want</em> an algorithm that would give me the shortest non-intersecting sequence, in this case:</p>\n\n<p>$$\\left[(0,0) \\stackrel{3}{\\rightarrow} (0,3) \\stackrel{3}{\\rightarrow} (0,6) \\stackrel{5}{\\rightarrow} (-3,2) \\right] = 11.$$</p>\n\n<p>This path is longer than the shortest path, but it is the shortest non-intersecting path.</p>\n\n<p><strong>Is there an (efficient) algorithm that can do this?</strong></p>\n\n<h2>TikZ sources</h2>\n\n<ul>\n<li><a href="https://www.writelatex.com/read/jzkhmqgmqcnj" rel="nofollow">Full graph</a>.</li>\n<li><a href="https://www.writelatex.com/read/kwpwzzcfyjcy" rel="nofollow">Shortest path</a>.</li>\n<li><a href="https://www.writelatex.com/read/qzrbvwxgpbtp" rel="nofollow">Shortest non-intersecting path</a>.</li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal><weighted-graphs>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T03:44:41.487', 'CommentCount': '20', 'AcceptedAnswerId': '16281', 'CreationDate': '2013-10-20T23:27:17.370', 'Id': '16269'}{'Body': '<p>I have an Euclidean, undirected graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.</p>\n\n<ul>\n<li>The number of vertices with no edges is small in comparison to the total number of vertices. </li>\n<li>No vertex has more than two edges connected to it.</li>\n</ul>\n\n<p>How can I convert this graph to a closed shape, so each vertex will have exactly two edges connected to it and there will be a path between any two vertices? I want to do it with minimum change in the total weight of all the edges.</p>\n', 'ViewCount': '126', 'Title': 'Converting graphs to sets of paths', 'LastEditorUserId': '917', 'LastActivityDate': '2013-12-10T03:14:40.417', 'LastEditDate': '2013-12-10T03:14:40.417', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><weighted-graphs>', 'CreationDate': '2013-10-23T07:11:44.910', 'Id': '16351'}{'Body': "<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices, also all the vertices are connected with edges.</p>\n\n<p>I want to change the vertices values, so that the average ratio between the length of two edges (taken over all pairs of edges), will be as small as possible, I want to keep just one rule. For any vertex on the graph, it's neighbors sorted by Euclidean distance from that vertex, must remind in the same order.</p>\n\n<p>The idea behind this, if solution could be provided, that it will be possible to treat groups of vertices as one. It will reduce the difficulty of solving TSP.</p>\n", 'ViewCount': '64', 'Title': 'Trim graph to minimum', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-10-23T13:50:52.117', 'LastEditDate': '2013-10-23T13:50:52.117', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-23T12:39:35.833', 'Id': '16361'}{'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.</p>\n\n<p>I am randomly creating a path thru all the vertices and I want to know if there is any efficient way to find all the intersections on my path.</p>\n', 'ViewCount': '124', 'Title': 'Efficient way to find intersections', 'LastActivityDate': '2013-10-25T07:39:59.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '16422', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><weighted-graphs>', 'CreationDate': '2013-10-25T06:16:51.257', 'Id': '16418'}{'Body': u'<p>Eagle, et al [1] discuss the notion of node entropy and this is captured in igraph via the diversity metric. I was wondering if there was any relationship between these node entropies and the idea of the entropy for the entire graph.</p>\n\n<p>A related question: Does the concept of edge entropy make sense? The probability would be the ratio of the weight of the edge in question and the sum of the weights of all edges connected to the nodes incident to the edge in question.</p>\n\n<p>[1]: N. Eagle, M. Macy, and R. Claxton, \u201cNetwork Diversity and Economic Development,\u201d Science, vol. 328, no. 5981, pp. 1029\u20131031, May 2010.</p>\n', 'ViewCount': '47', 'Title': 'Is there a relationship between graph entropy and node entropy?', 'LastActivityDate': '2013-10-25T20:57:44.423', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10978', 'Tags': '<graphs><entropy><weighted-graphs>', 'CreationDate': '2013-10-25T20:57:44.423', 'Id': '16432'}{'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.  I found a <a href="http://tsp-vs-world.blogspot.co.il/2013/10/intersections-optimal-tsp-route.html" rel="nofollow">geometric proof</a> that every optimal TSP solution contains no intersections.</p>\n\n<p>How many non-intersecting routes could be there? Or in other words: what is the probability to guess an optimal solution to a TSP problem if we just enumerate or sample non-intersecting routes?</p>\n\n<p><strong>Edit:</strong> I want to ignore the case that D.W. mentioned. For every path that you can swap between two neighbors vertices(If we represent the path as an array of vertices so neighbors will be two vertices with consecutive indexes) without changing its non-intersecting quality, all of those paths will be considered as one.</p>\n\n<p><strong>Edit</strong> I found that this kind of removing crossings from the graph also know as <a href="http://en.wikipedia.org/wiki/2-opt" rel="nofollow">2-OPT</a> </p>\n', 'ViewCount': '236', 'Title': 'Calculating the number of non-intersecting routes in an Euclidean graph', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-11-03T12:37:57.193', 'LastEditDate': '2013-11-03T12:37:57.193', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-26T09:50:01.253', 'FavoriteCount': '1', 'Id': '16439'}{'Body': "<p>Suppose I want to run Dijkstra's algorithm on a graph whose edge weights are integers in the\nrange 0, ..., W, where W is a relatively small number.\nHow can I modify that algorithm so that it takes time just O((|V| + |E|) logW) and relatively easy implement that in C/C++?</p>\n", 'ViewCount': '259', 'Title': "Dijkstra's algorithm for edge weights in range 0, ..., W", 'LastActivityDate': '2013-12-25T17:06:47.797', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12351', 'Tags': '<algorithms><algorithm-analysis><data-structures><shortest-path><weighted-graphs>', 'CreationDate': '2013-12-24T16:15:19.157', 'Id': '19252'}{'ViewCount': '331', 'Title': "Why does Dijkstra's algorithm fail on a negative weighted graphs?", 'LastEditDate': '2014-01-16T22:51:53.690', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '11972', 'FavoriteCount': '1', 'Body': '<p>I know this is probably very basic, I just can\'t wrap my head around it.<br>\nWe recently studied about Dijkstra\'s algorithm for finding the shortest path between two vertices on a weighted graph.<br>\nMy professor said this algorithm will not work on a graph with negative edges, so I tried to figure out what could be wrong with shifting all the edges weights by a positive number, so that they all be positive, when the input graph has negative edges in it.<br>\nFor example, let\'s consider the following input graph:<br>\n<img src="http://i.stack.imgur.com/GlrNb.png" alt="input graph"><br>\nNow if I\'ll add 3 to all edges, it\'s obvious that the shortest path (between $s$ and $t$) has changed:\n<img src="http://i.stack.imgur.com/NgPpM.png" alt="graph after adding 3"><br>\nThus this kind of operation might result in wrong output. \nAnd this, basically, what I don\'t get. Why does this happen? Why is shifting the values has such a dramatic effect on the shortest path? This is totally counter-intuitive, at least for me.<br>\nIn probability, when you have some (discrete) distribution probability given by some random variable $X$, and you want to calculate the variance, then for every constant $c$, it holds that $Var(X+c)=Var(X)$, and this happens, of-course, because shifting the distribution values left or right does not effect how $X$ spreads.<br>\nNow, I\'m well aware that these are two different things here, and finding the shortest path is not exactly the same as calculating the variance of a random distribution function, but I\'m just saying that this is why to me it seems so counter-intuitive.</p>\n\n<p>Your thoughts?</p>\n', 'Tags': '<algorithms><graphs><shortest-path><weighted-graphs>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T22:51:53.690', 'CommentCount': '3', 'AcceptedAnswerId': '19775', 'CreationDate': '2014-01-16T18:47:20.783', 'Id': '19771'}{'Body': "<p>I'm trying to solve this problem:</p>\n\n<blockquote>\n  <p>Given a collection of cities and the number of commuters between cities, design a network of roads for minimal cost where cost includes the cost of building the roads, and traveling of commuters. (So if more commuters use one edge, that edge will have a modified cost since the commuters want to get to their destination quickly)</p>\n</blockquote>\n\n<p>I've been treating the cities as nodes in a graph and the roads as edges. I want the weight of the edges to be dependent on the length of the edge (longer edges cost more) and somehow dependent on how many commuters are using that edge.</p>\n\n<p>My thought was to try doing something like a Minimum Steiner Tree, which if cost didn't depend on the commuters would minimize the cost of building the roads, but I'm not convinced that the solution to this should be a tree. And if I try to find a Minimal Spanning Tree or Minimum Steiner Tree I'm not sure how to deal with the fact that I don't know the edge cost until I know the full tree/graph. That is if people want to travel from A to B and we remove the edge from A to B, those people will now have to travel from A to C then from C to B which will modify the edge cost between A and C and C and B.</p>\n\n<p>Does anyone have any ideas on how to deal with the changing edge costs or know of a better way to solve this problem?</p>\n\n<p><strong>edit:</strong> You can make any sort of network you want, the roads can go straight from one city to another, or to any intermediate node(s) which can be placed anywhere in the plane. I'm planning on making the cost of building a road just a constant times the length of the road. For the cost of commuters I think another fractional constant times the distance they have to travel along the roads times the number of commuters traveling along that section of road.</p>\n", 'ViewCount': '87', 'ClosedDate': '2014-03-27T07:59:50.773', 'Title': 'Algorithm to determine a minimal cost graph', 'LastEditorUserId': '15844', 'LastActivityDate': '2014-03-19T16:50:47.457', 'LastEditDate': '2014-03-19T16:50:47.457', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15844', 'Tags': '<algorithms><graph-theory><graphs><weighted-graphs>', 'CreationDate': '2014-03-18T23:49:12.033', 'Id': '22782'}{'ViewCount': '57', 'Title': 'Shortest directed path connecting given subset of vertices', 'LastEditDate': '2014-04-14T18:27:40.627', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6615', 'FavoriteCount': '1', 'Body': '<p>Given</p>\n\n<ul>\n<li>weighted directed graph $G = (V,E,w)$, where $w : E \\to \\mathbb R^+$</li>\n<li>source vertex $v \\in V$</li>\n<li>vertex subset $U \\subset V$</li>\n</ul>\n\n<p>how to find a shortest directed path from $v$ containing all vertices from $U$? Note that such path may contain vertices that are not in $U$.</p>\n\n<ol>\n<li>Does such problem have a name?</li>\n<li>How to find a solution?</li>\n</ol>\n', 'Tags': '<graph-theory><terminology><shortest-path><weighted-graphs>', 'LastEditorUserId': '6615', 'LastActivityDate': '2014-04-14T18:27:40.627', 'CommentCount': '2', 'AcceptedAnswerId': '23789', 'CreationDate': '2014-04-14T14:52:04.890', 'Id': '23784'}{'Body': "<p>I'm given a graph and two weight functions, $w_1$ and $w_2$, such that there doesn't exist a negative loop in the graph in $w_1$ and $w_2$. I'm also given two vertices, $s$ and $t$, and am asked to find the lightest path from $s$ to $t$ in relation to $w_1$, out of all the lightest paths from $s$ to $t$ in relation to $w_2$.</p>\n\n<p>I get that this question begs for me to modify Dijkstra somehow, but I just can't seem to find the intuition to do so. Any guidance would be appreciated!</p>\n", 'ViewCount': '35', 'Title': 'Using Dijkstra to find shortest path in relation to two weight functions?', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-20T20:26:30.380', 'LastEditDate': '2014-04-20T20:26:30.380', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16769', 'Tags': '<shortest-path><weighted-graphs>', 'CreationDate': '2014-04-19T18:02:17.503', 'Id': '23938'}{'Body': u'<p>I have been assigned a fun project: design and implement a program that maintains the data of a simple social network. Each person in the network should have a profile that contains his name, current status, and a friends list.</p>\n\n<p>I think it is clear that the project calls for the use of the ADT graph. Each vertex represents a person in the network and an edge between vertices a friendship. Now, the graph may not be connected because some members do not have any friends in the network. With that in mind, consider this feature that must be implemented:</p>\n\n<p><strong>\u2022The network must have a feature that computes the \u201cemergency phone chain," make sure that each member in the network is contacted, and only by one person. Any of the people in the network may initiate the first call. Utilize a depth-first graph traversal algorithm.</strong></p>\n\n<p>Now, what I think my professor is suggesting is merely a full traversal of the graph. How is that possible for an unconnected graph? Any suggestions?</p>\n\n<p>(btw, the wording above is somewhat unclear - does the professor mean that everyone in the network is contact by the same one person? Thoughts? I would ask her, but she is unavailable until next week.)</p>\n', 'ViewCount': '20', 'Title': 'Is traversing an unconnected graph possible?', 'LastActivityDate': '2014-05-03T04:06:37.753', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17288', 'Tags': '<graphs><weighted-graphs>', 'CreationDate': '2014-05-03T01:31:11.387', 'Id': '24334'}