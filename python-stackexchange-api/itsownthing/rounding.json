{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '197', 'Title': 'Floating point rounding', 'LastEditDate': '2012-08-14T20:48:35.540', 'AnswerCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '565', 'FavoriteCount': '2', 'Body': '<p>Can an IEEE-754 floating point number &lt; 1 (i.e. generated with a random number generator which generates a number >= 0.0 and &lt; 1.0) ever be multiplied by some integer (in floating point form) to get a number equal to or larger than that integer due to rounding?</p>\n\n<p>i.e.</p>\n\n<pre><code>double r = random() ; // generates a floating point number in [0, 1)\ndouble n = some_int ;\nif (n * r &gt;= n) {\n    print \'Rounding Happened\' ;\n}\n</code></pre>\n\n<p>This might be equivalent to saying that does there exist an N and R such that if R is the largest number less than 1 which can be represented in IEEE-754 then N * R >= N (where * and >= are appropriate IEEE-754 operators)</p>\n\n<p>This comes from <a href="http://stackoverflow.com/questions/1400505/postgresql-random-number-range-1-10/1400752#comment15929846_1400752">this question</a> based on <a href="http://www.postgresql.org/docs/9.1/static/datatype-numeric.html#DATATYPE-FLOAT">this documentation</a> and the postgresql <a href="http://www.postgresql.org/docs/8.2/static/functions-math.html#FUNCTIONS-MATH-FUNC-TABLE">random function</a></p>\n', 'Tags': '<numerical-analysis><floating-point><rounding>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-14T23:02:56.757', 'CommentCount': '3', 'AcceptedAnswerId': '3186', 'CreationDate': '2012-08-14T18:45:13.943', 'Id': '3185'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In a 32-bit floating number with normalized mantissa and excess-64 exponent base 16, the number $16^{-65}$ denotes</p>\n\n<ol>\n<li><p>Floating point overflow.</p></li>\n<li><p>Negative floating point overflow.</p></li>\n<li><p>All 0\'s in the exponent and mantissa fields.</p></li>\n<li><p>The minimum representable positive number .</p></li>\n</ol>\n\n<p>I think that minimum representable number should be $1 \\times 16^{-63}$\nbecause the minimum mantissa should be 1 and and the possible exponent range in bias form is from 1 to 127 (where 1 corresponds to most negative exponent i.e. -63, and 127 corresponds to most positive exponent i.e. 63)</p>\n\n<p>So according to me, the answer is: A positive floating point underflow.\nPlease correct me if i am wrong. The IEEE-754 representation is confusing me. </p>\n\n<p>Someone also told me something along the lines of " the mantissa part is always taken as 0.M if the base is something other than 2". However I don\'t have any reference for this statement.</p>\n', 'ViewCount': '272', 'Title': 'In a 32-bit floating number with normalized mantissa and excess-64 exponent base 16, the number $16^{-65}$ denotes', 'LastEditorUserId': '4763', 'LastActivityDate': '2013-01-13T00:37:46.217', 'LastEditDate': '2012-12-13T18:03:21.537', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4763', 'Tags': '<numerical-analysis><floating-point><rounding>', 'CreationDate': '2012-12-13T16:19:41.657', 'Id': '7382'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2499', 'Title': 'Normalizing the mantissa in floating point representation', 'LastEditDate': '2013-01-09T11:44:45.023', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4422', 'FavoriteCount': '0', 'Body': "<p>How to represent $0.148 * 2^{14}$ in normalized floating point arithmetic with the format</p>\n\n<pre><code>1 - Sign bit\n7 - Exponent in Excess-64 form\n8 - Mantissa\n</code></pre>\n\n<p>$(0.148)_{10} = (0.00100101\\;111...)_2$</p>\n\n<p>We shift it 3 bits to left to make it normalized $(1.00101\\;111)_2 * 2^{11}$. </p>\n\n<p>Exponent = $11+64 = (75)_{10} = (1001011)_2$ and Mantissa = $(01001\\;111)_2$.</p>\n\n<p>So floating point representation is $(0\\;1001011\\;00101111)_2 = (4B2F)_{16}$ <strong>Representation A</strong></p>\n\n<p>But if we store the denormalized mantissa into 8 bit register, then it won't have stored the last three $1$s and then the mantissa would have normalized from $(0.00100101)_2$ to $(1.00101\\;000)_2$ by inserting 3 $0$s instead of $1$s.</p>\n\n<p>The representation would have been $(0\\;1001011\\;00101000)_2 = (4B28)_{16}$ <strong>Representation B</strong></p>\n\n<p>So while normalizing, does the processor takes into account the denormalized mantissa bits beyond 8 bits too? Or just rounds it off? Which one is correct: <strong>A</strong> or <strong>B</strong>?</p>\n\n<p>Does it store the mantissa in fixed point representation? How does it all work?</p>\n", 'Tags': '<binary-arithmetic><floating-point><rounding>', 'LastEditorUserId': '4422', 'LastActivityDate': '2013-01-09T11:44:45.023', 'CommentCount': '0', 'AcceptedAnswerId': '7847', 'CreationDate': '2013-01-08T06:59:08.923', 'Id': '7828'}