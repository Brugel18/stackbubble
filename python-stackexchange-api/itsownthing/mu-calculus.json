{'Body': '<p>I am solving one of the past exams and I am not certain with my solution to one of the exercises. The exercise is asking to give intuitive meaning to modal $\\mu$-calculus formula:</p>\n\n<p>$$ \\phi = \\mu Z. \\langle - \\rangle tt \\wedge [-a]Z $$</p>\n\n<p>According to an article <em>Modal logics and mu-calculi: an introduction</em> by Bradfield and Stirling[1] the intuition behind $\\mu$ operator is "<em>finite looping</em>". So my reasoning is following: on every path through states in $Z$ there must be only a finite number of transitions with labels different from $a$ and then we must reach a state which is both non-terminal (from the first condition) and all transitions from it are labelled $a$ (from finiteness).</p>\n\n<p>Hence on every path through states in $Z$ there must eventually be a transition labelled $a$. (similar to CTL formula $\\forall F(a)$).</p>\n\n<p>Is my reasoning correct? I am unable to find any formal reason for my solution to be right, can you give me a little hint?</p>\n\n<p>[1] <a href="http://homepages.inf.ed.ac.uk/jcb/Research/bradfield-stirling-HPA-mu-intro.ps.gz" rel="nofollow">http://homepages.inf.ed.ac.uk/jcb/Research/bradfield-stirling-HPA-mu-intro.ps.gz</a></p>\n', 'ViewCount': '157', 'Title': 'Intuitive meaning of modal $\\mu$-calculus formula', 'LastEditorUserId': '2303', 'LastActivityDate': '2013-03-10T11:41:47.677', 'LastEditDate': '2012-12-18T11:38:50.680', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7503', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2303', 'Tags': '<modal-logic><mu-calculus>', 'CreationDate': '2012-12-15T09:58:05.747', 'Id': '7406''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a homework problem that says:</p>\n\n<p><em><strong>For $g(x,y)=xy-5$ compute $h(x) = \\mu y(g(x,y))$ and determine its domain.</em></strong></p>\n\n<p>I was under the impression that this means the least y such that $g(x,y)=0$, so then $y = \\frac{5}{x}, D=\\{x \\in \\mathbb{N}, x \\neq 0\\}$</p>\n\n<p>So $h(x)=\\frac{5}{x}$?</p>\n', 'ViewCount': '60', 'Title': 'Have I got the right understanding of the mu operator?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-04-16T00:59:05.323', 'LastEditDate': '2013-04-16T00:54:30.127', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Tags': '<terminology><computability><mu-calculus>', 'CreationDate': '2013-04-15T15:55:45.027', 'Id': '11337''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It is known that the temporal logics LTL,CTL,CTL* can be translated/embedded into the $\\mu$-calculus. In other words, the (modal) $\\mu$-calculus subsumes these logics,\n(i.e. it is more expressive.)</p>\n\n<p>Could you please explain/point me to papers/books that elaborate on this matter.\nIn particular, are there concrete fairness, liveness, etc. properties not expressible in the temporal logics but in the $\\mu$-calculus?</p>\n', 'ViewCount': '293', 'Title': 'Why use $\\mu$-calculus and not LTL,CTL,CTL*?', 'LastEditorUserId': '9950', 'LastActivityDate': '2013-11-05T19:02:14.673', 'LastEditDate': '2013-10-31T18:15:11.500', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '11105', 'Tags': '<linear-temporal-logic><mu-calculus>', 'CreationDate': '2013-10-31T16:46:17.190', 'Id': '16603''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Suppose one wants to use a \u03bc-calculus model checker, but specify things in temporal logics, which is easier (more intuitive). Is there a technique (even better, a tool) that automatically translates formulae in any of these logics (CTL,CTL* or LTL) to the \u03bc-calculus?</p>\n\n<p>Thanks very much in advance!</p>\n', 'ViewCount': '61', 'Title': u'Techniques (tools) to convert temporal logic (CTL,CTL* or LTL) to \u03bc-calculus formulae', 'LastActivityDate': '2013-11-20T14:43:23.953', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11105', 'Tags': '<linear-temporal-logic><mu-calculus>', 'CreationDate': '2013-11-20T11:01:24.603', 'Id': '18196''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '117', 'Title': 'The minimization operator is an effective operator', 'LastEditDate': '2014-02-12T18:58:57.467', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Student', 'PostTypeId': '1', 'OwnerUserId': '11762', 'Body': u'<p>Assume $\\{f_i^{(n)}\\}_{i=0}^\\infty$ is a G\xf6del enumeration of the $\\mu$-recursive functions of $n$ arguments, such that the $S^m_n$ theorem and the universal function theorem hold. Denote the set of (total and partial) functions $\\{f:\\mathbb N^k\\to\\mathbb N\\\n\\}$ by $\\mathfrak F^k$</p>\n\n<p><strong>Definition:</strong> We call an operator $G:\\mathfrak F^n\\to\\mathfrak F^k$ effective, if $(\\forall j\\in\\mathbb N)(G(f^{(n)}_j)=f^{(k)}_{g(j)})$ for some total recursive function $g$.</p>\n\n<p><strong>Claim:</strong> The minimization operator $\\mu:\\mathfrak F^{k+1}\\to\\mathfrak F^k$ defined by $$\\mu(f)(\\overline x)=\\mu y[f(y,\\overline x)=0]=y\\iff (f(y,\\overline x)=0\\land(\\forall i&lt;y) (f(i,\\overline x)&gt;0))$$ is an effective operator.</p>\n\n<p><strong>Question:</strong> How can I go about proving the statement? Hints are welcome.</p>\n\n<p><strong>Thought:</strong> By definition the $\\mu$-recursive functions are closed with respect to the $\\mu$-operator. Therefore, $\\mu(f^{(k+1)}_j)=f^{(k)}_{h(j)}$, for some unique total function $h$. But why is $h$ a computable function?</p>\n\n<p>Note that I would really like to stay within the Partial Recursive Functions Formalism. Pseudo code means nothing to me. I cannot read it. I am not familiar with most of the notation from the programming world. I would also prefer not go into Register Machine Formalisms.</p>\n', 'Tags': '<computability><recursion><mu-calculus>', 'LastEditorUserId': '11762', 'LastActivityDate': '2014-02-12T18:58:57.467', 'CommentCount': '6', 'AcceptedAnswerId': '21529', 'CreationDate': '2014-02-10T10:04:12.157', 'Id': '21509''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Hello everyone just like the title says I want to prove that $H(x) = \\mu y T(x,x,y)$ has no total computable extension such that if we had a function $BIG(x)$ that is both total and agrees with $H(x)$ whenever $H(x)$ is defined, then $BIG(x)$ is not computable. This is a homework question so I don't want a full solution just some help! </p>\n\n<p>$\\bf{NOTE}:$ The predicate $T(y,x,z)$ means that it holds iff program $y$ takes an input $x$ (could be $n$-ary) and has a computational history z! This is supposed to be the Kleene T predicate basically.  </p>\n\n<p>The function $H(x)$ I believe returns the smallest computational history $y$ such that a program $\\{x\\}(x)$ (program takes input of its own configuration and runs) runs and halts, since $\\mu y R(x,y)$ means the smallest $y$ such that $R(x,y)$ holds. Maybe I am not quite clear what it means for $BIG$ to agree with $H(x)$ or what it's own input. I think I need to create a diagonal function that uses $BIG$ if $BIG$ was computable and show that if I had some program $e$ then it must agree with $BIG$ but based on my definition of that diagonal function it isn't. If you are reading this you might see the mess of my thinking, any help would be greatly appreciated!</p>\n", 'ViewCount': '47', 'Title': 'Using diagonal argument to prove that $H(x) = \\mu y T(x,x,y)$ has no total computable extension', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-14T09:35:23.657', 'LastEditDate': '2014-03-14T09:35:23.657', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<computability><mu-calculus>', 'CreationDate': '2014-03-14T01:01:26.327', 'Id': '22601''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}