{'Body': u"<p>The question is exercise 1.9 from Arora-Barak's book <em>Computational Complexity \u2014 A Modern Approach</em>:</p>\n\n<hr>\n\n<p>Define a RAM Turing machine to be a Turing machine that has random access memory. We formalize this as follows: The machine has an infinite array A that is initialized to all blanks. It accesses this array as follows. One of the machine's work tapes is designated as the address tape. Also the machine has two special alphabet symbols denoted by R and W and an additional state we denote by q_access. Whenever the machine enters q_access, if its address tape contains 'i'R (where 'i' denotes the binary representation of i) then the value A[i] is written in the cell next to the R symbol. If its tape contains 'i'Wa (where a is some symbol in the machine's alphabet) then A[i] is set to the value a.</p>\n\n<p>Show that if a Boolean function $f$ is computable within time $T(n)$ (for some time constructible $T$) by a RAM TM, then is is in $\\mathrm{DTIME}(T(n)^2)$.</p>\n\n<hr>\n\n<p>The trivial solution by using an additional tape recording pairs (address,value) turns out to be in $\\mathrm{DTIME}(T(n)^3)$, since that tape can be of size $O(T(n)^2)$ with $O(T(n))$ pairs while the address of each pair can be of size $O(T(n))$.</p>\n", 'ViewCount': '225', 'Title': 'Prove that a boolean function computable in T(n) by a RAM machine is in DTIME(T(n)^2)', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-16T14:05:18.777', 'LastEditDate': '2012-08-17T14:04:18.113', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2121', 'Tags': '<complexity-theory><turing-machines><machine-models><simulation>', 'CreationDate': '2012-07-10T08:35:08.447', 'FavoriteCount': '1', 'Id': '2666''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $f$ be a fixed time-constructable function.</p>\n\n<p>The classical universal simulation result for TMs (Hennie and Stearns, 1966) states that there is a two-tape TM $U$ such that given</p>\n\n<ul>\n<li>the description of a TM $\\langle M \\rangle$, and</li>\n<li>an input string $x$,</li>\n</ul>\n\n<p>runs for $g(|x|)$ steps and returns $M$'s answer on $x$. And $g$ can be taken to be any function in $\\omega(f(n)\\lg f(n))$.</p>\n\n<p>My questions are:</p>\n\n<blockquote>\n  <ol>\n  <li><p>What is the best known simulation result on a single tape TM? Does the result above also still hold?</p></li>\n  <li><p>Is there any improvement on [HS66]? Can we simulate TMs on a two-tape TM for $f(n)$ steps in a faster way? \n  Can we take $g(n)$ to be in $\\omega(f(n))$ in place of $\\omega(f(n)\\lg f(n))$?</p></li>\n  </ol>\n</blockquote>\n", 'ViewCount': '278', 'Title': 'Universal simulation of Turing machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-16T13:15:01.727', 'LastEditDate': '2012-08-16T11:33:15.097', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '3220', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<complexity-theory><reference-request><turing-machines><machine-models><simulation>', 'CreationDate': '2012-07-23T15:49:05.823', 'Id': '2878''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to understand the proof of the time hierarchy theorem appearing in sipser's book.  The proof requires a TM M to simulate an arbitrary TM N without too much slowdown. In particular, it is assumed that the encoding of N's tape alphabet using M's alphabet causes only a constant factor slowdown. This seems plausible since if N's alphabet is size k then M can use $\\log k$ cells to represent each symbol that N writes to the tape.</p>\n\n<p>But my question is this: If this is how the simulation works then before the simulation starts M will have to change the input so that each bit is repeated $\\log k$ times and I don't know how to do this without adding a quadratic term to the time. I should say its assumed that N's computation is no faster than $O(n\\log(n))$.   </p>\n", 'ViewCount': '140', 'Title': 'For the time hierarchy theorem, how is the input translated efficiently?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T12:18:07.830', 'LastEditDate': '2012-08-05T12:18:07.830', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2371', 'Tags': '<complexity-theory><turing-machines><simulation>', 'CreationDate': '2012-08-05T00:21:24.043', 'FavoriteCount': '1', 'Id': '3038''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Over at <a href="http://cs.stackexchange.com/questions/3200/counting-inversion-pairs">this question about inversion counting</a>, I <a href="http://cs.stackexchange.com/questions/3200/counting-inversion-pairs#comment8724_3200">found a paper</a> that proves a lower bound on space complexity for all (exact) <a href="https://en.wikipedia.org/wiki/Streaming_algorithm">streaming algorithms</a>. I have claimed that this bound extends to all linear time algorithms. This is a bit bold as in general, a linear time algorithm can jump around at will (random access) which a streaming algorithm can not; it has to investigate the elements in order. I may perform multiple passes, but only constantly many (for linear runtime).</p>\n\n<p>Therefore my question:</p>\n\n<blockquote>\n  <p>Can every linear-time algorithm be expressed as a streaming algorithm with constantly many passes?</p>\n</blockquote>\n\n<p>Random access seems to prevent a (simple) construction proving a positive answer, but I have not been able to come up with a counter example either.</p>\n\n<p>Depending on the machine model, random access may not even be an issue, runtime-wise. I would be interested in answers for these models:</p>\n\n<ul>\n<li>Turing machine, flat input</li>\n<li>RAM, input as array</li>\n<li>RAM, input as linked list</li>\n</ul>\n', 'ViewCount': '469', 'Title': 'Is every linear-time algorithm a streaming algorithm?', 'LastActivityDate': '2012-08-16T18:15:02.147', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '3221', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<algorithms><streaming-algorithm><simulation><lower-bounds>', 'CreationDate': '2012-08-16T08:26:31.460', 'FavoriteCount': '1', 'Id': '3214''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a question and I haven't been able to figure out the answer yet. I need to do the on-line simulation of a two-head tape Turing machine using single-head tape(s). I've found some online articles for the fact that one single-head tape doesn't suffice for this problem and the simulation should be done using two single-head tapes, but I haven't been able to present an accurate simulation of two-head TM using these single-head tapes. Are there any thoughts on how to do so? Thanks,</p>\n", 'ViewCount': '198', 'Title': 'On-line simulation of a two-head tape Turing machine using single-head tape(s)', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T00:40:34.167', 'LastEditDate': '2012-09-13T06:43:33.710', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'Parsa Rastegari', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models><simulation>', 'CreationDate': '2012-09-13T00:29:00.457', 'Id': '3526''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>It's easy to see how a multi-track Turing machine can simulate a single-track Turing machine; it does so by ignoring all but the first track. But how does it work the other way? I need a specification of a transition function that does the job. If there are $k$ tracks, then we can think of symbols as being vectors and arrange them one after another in the tape; but again, what's the transition function like in the equivalent single-track machine?</p>\n", 'ViewCount': '399', 'Title': 'How does a single-track Turing machine simulate a multi-track Turing machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-14T23:20:23.407', 'LastEditDate': '2012-09-13T12:38:47.133', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '3552', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<computability><turing-machines><simulation>', 'CreationDate': '2012-09-13T11:25:55.437', 'Id': '3529''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is a Turing Machine that is allowed to read and write symbols from an infinite alphabet more powerful than a regular TM (that is the only difference, the machine still has a finite number of states)?</p>\n\n<p>Intuition tells me not, since you need an infinite number of states to differentiate each symbol. So I think some of the symbols or the transitions caused by the symbols (or some subsets of the transitions) have to be equivalent. So you can actually simulate such machine with a regular TM and a bounded subset of such symbols or transitions.</p>\n\n<p>How could I approach a formal proof of this?</p>\n', 'ViewCount': '414', 'Title': 'Infinite alphabet Turing Machine', 'LastActivityDate': '2012-09-28T13:35:38.480', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '3534', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1451', 'Tags': '<computability><turing-machines><reductions><simulation>', 'CreationDate': '2012-09-13T23:01:24.267', 'Id': '3533''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am currently reading the IEEE paper <a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1705612" rel="nofollow">A Memory-Efficient Parallel String Matching\nArchitecture for High-Speed Intrusion Detection</a> by Kai Zheng,  Bin Liu,  Xin Zhang, and  Yunhao Liu. </p>\n\n<p>In the paper they propose a model for\n a memory-efficient multiple-character-approaching architecture\nconsisting of multiple parallel DFAs. </p>\n\n<p>I have read the paper and I have understood to an extent. </p>\n\n<p>But when I think of implementation, could I simulate the SRAM, LE,BCAM etc.. as in the case of a network simulator (NS-2,OPNET,OMNET).<img src="http://i.stack.imgur.com/Y4xYV.png" alt="enter image description here"> </p>\n', 'ViewCount': '118', 'Title': 'Could I simulate the implementation of memory components', 'LastActivityDate': '2013-04-08T17:02:36.107', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3163', 'Tags': '<computer-architecture><simulation>', 'CreationDate': '2012-10-12T05:55:03.977', 'Id': '5033''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to trace back the origin of the general concept of Discrete Event Simulation and found a 1968 article by Fishman and Kiviat mentioning the term. It is titled <em>The statistics of discrete-event simulation</em>.</p>\n\n<p>However, I'm unable to verify this as the origin of the term.</p>\n\n<p>Is there further historical information on this?</p>\n", 'ViewCount': '81', 'Title': 'Who conceived the concept of Discrete Event Simulation, and when?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-10-24T19:39:30.363', 'LastEditDate': '2012-10-24T15:09:26.083', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '26', 'Tags': '<reference-request><simulation><history>', 'CreationDate': '2012-10-24T11:21:38.397', 'Id': '6285''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '376', 'Title': 'Multitape Turing machines against single tape Turing machines', 'LastEditDate': '2012-10-31T19:13:05.493', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'user7760', 'PostTypeId': '1', 'OwnerUserId': '4409', 'Body': '<p><em>Introduction</em>: I recently learned that a multi-tape Turing Machine $\\text{TM}_k$  is no more "powerful" than a single tape Turing machine $\\text{TM}$. The proof that  $\\text{TM}_k \\equiv \\text{TM}$ is based on the idea that a $\\text{TM}$ can simulate a $\\text{TM}_k$ by using a unique character to separate the respective areas of each of the $k$ tapes.</p>\n\n<p>Given this idea, how would we prove that a process taking $t(n)$ time on a $\\text{TM}_k$ can be simulated by a 2-tape Turing machine $\\text{TM}_2$ with $ O(t(n))\\log(t(n))$ time?</p>\n', 'Tags': '<time-complexity><turing-machines><simulation><tape-complexity>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-31T19:13:05.493', 'CommentCount': '0', 'AcceptedAnswerId': '6387', 'CreationDate': '2012-10-29T21:06:01.913', 'Id': '6385''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Turing completness is being typically proved via reduction to already proved Turing-complete machine.</p>\n\n<p>Can the same be obtained by showing, that the machine in question is capable of generating arbitrary output \u2013 if proper input is given?</p>\n', 'ViewCount': '60', 'Title': 'To prove Turing-completeness, is it enough to prove capability of producing arbitrary output?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T14:19:01.157', 'LastEditDate': '2012-11-01T14:19:01.157', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6416', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4418', 'Tags': '<simulation><turing-completeness>', 'CreationDate': '2012-11-01T03:53:49.950', 'Id': '6414''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How can one show that a machine with a three dimensional memory arranged in an infinite grid can be simulated by a single-tape Turing machine? I'd imagine there's some sort of mapping possible from three dimensional coordinates to single coordinates (eg. (0,0,0) -> 0, (1,0,0) -> 1, (-1,0,0) -> 2, ...) but I can't figure it out. Or maybe there's some clever way to separate the points using special symbols. Either way, I'm at a loss.</p>\n", 'ViewCount': '151', 'Title': 'Robustness of Turing Machines - 3 dimensional case', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-03T16:59:08.593', 'LastEditDate': '2012-11-03T05:45:57.907', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'Sebastian', 'PostTypeId': '1', 'Tags': '<turing-machines><simulation><machine-models>', 'CreationDate': '2012-11-02T00:06:38.447', 'Id': '6454''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/Unrestricted_grammar">this Wikipedia article</a>, unrestricted grammars are equivalent to Turing machines. The article notes that I can convert any Turing machine into an unrestricted grammar, but it only shows how to convert a grammar to a Turing machine.</p>\n\n<p>How do I indeed do that and convert the Turing machine the recognizes language $L$ into an unrestricted grammar? I have tried replacing transition rules with grammar rules, but a Turing machine can have many different configurations of states as well...</p>\n', 'ViewCount': '395', 'Title': 'How can I convert the Turing machine the recognizes language $L$ into an unrestricted grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T11:12:41.060', 'LastEditDate': '2012-11-06T10:45:20.903', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6510', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4414', 'Tags': '<formal-grammars><turing-machines><simulation>', 'CreationDate': '2012-11-06T08:24:48.120', 'Id': '6504''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've got two log-space programs $F$ and $G$.</p>\n\n<ul>\n<li>Program $F$ will get input in array $A[1..n]$ and will create the output array $B[1..n]$.</li>\n<li>Program $G$ will get as input $B$ as created by $F$ and create from it the output array $C[1..n]$.</li>\n</ul>\n\n<p>I have to write a proof that there exist a log-space program $H$, which will get input Array $A$ and create from it corresponding array $C$. But I can't find the correct way to write it. How is this done?</p>\n\n<hr>\n\n<p>A log-space program is a program which uses $O(\\log n)$ bits of memory. Here are some conditions you have to keep:</p>\n\n<ol>\n<li><p>You have to use only variables which have simple integer type (for example <code>int</code> in C++, <code>longint</code> in Pascal).</p></li>\n<li><p>Allowed range of integer is defined: if $n$ is the size of the input we can save into variables only values which are polymonial sized based on $n$.</p>\n\n<p>For example: we can have variables which can takes on values in $[-n...n]$, $[-3n^5...3n^5]$ or also values $[-4...7]$, but we can't have variables which will take on values in $[ 0...2^n]$.\nNo other types of variables are allowed, neither are arrays and iterators.</p></li>\n<li><p>Exceptions from the rules about are input and output. Input will be available in special variables (mostly arrays) which your program can only read from, and the output can only be written to other special variables. So you can't read from output, and you can't increase values of input variables etc.</p></li>\n<li><p>Your programs can't use recursion.</p></li>\n</ol>\n\n<p>Example of log-space program written in Pascal (so everyone can understand it) which will find the largest number in the array of integer</p>\n\n<pre><code>    var n: integer;  //input variable the number of elements in A\n    A: array [1..n] of integer; //input variable - the array of integers\n    m: integer;      // output variable, the position of maximum\n    i, j: integer;   //working variables\n    begin\n      j := 1;\n      for i := 2 to n do\n        if A[i] &gt; A[j] then j := i;\n      m := j;\n    end;\n</code></pre>\n\n<p>The only two variables here are <code>j</code> and <code>i</code> and they evidently take values in $[1...n]$. Therefore all conditions are fulfilled and it really is a log-space program.</p>\n", 'ViewCount': '121', 'Title': 'Simulate the concatenation of two log-space programs in log-space', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-21T06:29:00.577', 'LastEditDate': '2012-11-09T07:49:44.290', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'OwnerDisplayName': 'user12392', 'PostTypeId': '1', 'Tags': '<algorithms><complexity-theory><simulation><space-complexity>', 'CreationDate': '2012-11-06T21:30:33.060', 'Id': '6571''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1883', 'Title': 'Convert CFG to PDA', 'LastEditDate': '2013-04-10T08:39:30.413', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7405', 'FavoriteCount': '2', 'Body': '<p>Is there any set of rules or methods to convert any context free grammar to a push down automata? </p>\n\n<p>I already found <a href="http://infolab.stanford.edu/~ullman/ialc/spr10/slides/pda2.pdf" rel="nofollow">some slides online</a> but I wasn\'t able to understand them.</p>\n\n<p>In slide 10 he speaks about some rules could anyone explain that?</p>\n', 'Tags': '<context-free><formal-grammars><pushdown-automata><simulation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:39:30.413', 'CommentCount': '2', 'AcceptedAnswerId': '11186', 'CreationDate': '2013-04-10T03:00:30.087', 'Id': '11182''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a little problem to understand the proof of the Time Hierarchy Theorem (Hennie and Stearns, 1966) that ensures the existence of a language acceptable in $U(n)$ but not acceptable in $T(n)$ for any functions $T(n),U(n)$, such that $U(n)$ is time-constructible and</p>\n\n<p>$$n \\leq T(n) = o\\left(\\frac{U(n)}{\\log T(n)}\\right).$$</p>\n\n<p>This proof is based on the existence of the Universal Turing machine simulating any Turing machine with time complexity $T(n)$ in time $T(n) \\log T(n)$.</p>\n\n<p>I understand (and believe) the proof that every $k$-tape Turing machine can be simulated by a two-tape Turing machine with a logarithmic overhead. However, I understand this construction only if the simulated Turing machine is fixed, not in the case of the Universal TM simulation.</p>\n\n<p>I see one "problem" in the reasoning given in the cited paper (and also in several standard books on computational complexity) related to the construction of the Universal machine. This "problem" is that in the Universal machine simulation, one computational step of a simulated machine is supposed to be executed in constant time by the Universal machine. In other words, the length of the description of the simulated machine is supposed to be constant.</p>\n\n<p>But is this OK? Since in the proof of the Time Hierarchy Theorem, the input given to the simulated Turing machine is exactly this description, and thus, the description is somehow dependent of $n$. I am aware of that the description can be lengthened by a sequence of leading bits, but this does not seem to solve this problem. </p>\n\n<p>That is, I cannot figure out why the computation step of a simulated machine can be supposed to be executed in a constant time by the Universal machine. The paper of Hennie and Stearns does not pay much attention to this, it merely states that this time is something that is implicitly assumed to be a constant. Similarly in the textbooks I have read on the topic.</p>\n\n<p>I simply cannot figure out why the time complexity of the simulation is $T(n)\\log T(n)$, and not $n T(n) \\log T(n)$.</p>\n\n<p>I am almost sure that I am missing something. However, I am trying to understand this for a relatively long time and somehow I cannot figure this out.</p>\n', 'ViewCount': '382', 'Title': 'Time Complexity of Universal Turing Machine Simulations and the Time Hierarchy Theorem', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T10:35:19.797', 'LastEditDate': '2013-04-14T10:35:19.797', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11284', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2091', 'Tags': '<complexity-theory><turing-machines><simulation>', 'CreationDate': '2013-04-13T09:50:42.470', 'Id': '11280''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am not sure if this is an appropriate place to ask, since the question may be related to software engineering.</p>\n\n<p>In embedded control domain, model-driven engineering allows a design model to be simulated before being used for code generation. I am wondering how the consistency is preserved between the simulated objects and the generated code? I know that normally the simulated objects are wrapped for the simulation environment. Is it possible to say exactly "what you simulate is what you get" in certain approaches?</p>\n\n<p>Could you please give me some advices.</p>\n\n<p>-Wei</p>\n', 'ViewCount': '21', 'Title': 'Simulation of a model', 'LastActivityDate': '2013-05-04T05:26:26.307', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8040', 'Tags': '<simulation><modelling>', 'CreationDate': '2013-05-04T05:26:26.307', 'Id': '11771''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Does there exist a cellular automaton (in 2D) which simulates a $1/r$ force between particles?</p>\n\n<p>More specifically, I would like to know whether it is possible, with strictly local update rules, to have two objects (defined within the model) attract each other with a $1/r$ force, where $r$ is the distance separating the objects.  This would in particular entail an acceleration of the object (particles) as they get closer together.</p>\n\n<p>More generally, can long range attractive forces between objects (blobs) be simulated in a cellular automaton setting with strictly local rules?</p>\n', 'ViewCount': '142', 'Title': '1/r attractive force by cellular automaton', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-21T21:02:17.623', 'LastEditDate': '2013-05-10T13:30:34.107', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8114', 'Tags': '<simulation><cellular-automata>', 'CreationDate': '2013-05-10T12:57:12.817', 'FavoriteCount': '3', 'Id': '11933''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '724', 'Title': 'What randomness really is', 'LastEditDate': '2013-05-19T17:50:20.767', 'AnswerCount': '8', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '8255', 'FavoriteCount': '4', 'Body': '<p>I\'m a Computer Science student and am currently enrolled in System Simulation &amp; Modelling course. It involves dealing with everyday systems around us and simulating them in different scenarios by generating random numbers in different distributional curves, like IID, Gaussian etc. for instance. I\'ve been working on the boids project and a question just struck me that what exactly "random" really is? I mean, for instance, every random number that we generate, even in our programming languages like via the <code>Math.random()</code> method in Java, essentially is generated following an "algorithm".</p>\n\n<p>How do we really know that a sequence of numbers that we produce is in fact, random and would it help us, to simulate a certain model as accurately as possible?</p>\n', 'Tags': '<simulation><randomness><modelling>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-17T01:36:33.863', 'CommentCount': '2', 'AcceptedAnswerId': '12137', 'CreationDate': '2013-05-19T16:49:58.083', 'Id': '12136''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>As I understand emulation a rule of the thumb says that a computer must be around a order of magnitude more powerful to emulate another system without resorting to tricks. This is because for every clock cycle of the system to be emulated, the host machine must process that cycle in the correct time and also process its own cycles.</p>\n\n<p>A Xbox 360 uses a <code>3.2GHz PowerPC Tri-Core Xenon</code> processor, would this mean that emulating the console on a 3GHz PC CPU would be impossible, even if the host CPU was more powerful but not faster for clock cycles?</p>\n\n<p>To give a more straightforward example. A i7 that runs at the same clock speed as a Pentium 4 will not be able to emulate the Pentium 4, even though the i7 is many times more powerful. </p>\n\n<p>In addition, does this mean that to emulate the Xbox 360, The host computer must run at a speed of between 9GHz and 3.2GHz to be able to truly emulate a Xbox 360? </p>\n\n<p>If this is the case, surely there must be a way around this limitation? If we had a host computer with 10x3GHz CPU's could this system use parallelzation to somehow emulate a 3 core 3.2GHz system.</p>\n\n<p>Also the emulate should run at the speed that the user expected of the emulated system, I know if you slowed down the Xbox 360 on the emulator by a few times then it would be easier, I want to know if we can emulate a system at the speed it was meant to run.</p>\n\n<p>If this is not possible does that mean that for emulation, clock speed is king? And there is no way around this? Even if your host machine had a thousand CPU's running at 2GHz it could never ever emulate a Xbox 360 at its native speed?</p>\n\n<p>By the way I am sure this is in the domain of computer science. I am not sure exactly what it comes under but the simulation of a system within a system and inherent limitations is certainly applicable to computer science.</p>\n\n<p>What about this: could a 4 core 3GHz i7 CPU emulate in proper time a 3.8GHz single core Pentium 4?</p>\n", 'ViewCount': '160', 'Title': 'Is it impossible to truly emulate a system if its actual clock speed is the same?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-30T23:47:46.533', 'LastEditDate': '2013-05-30T23:47:46.533', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12355', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8425', 'Tags': '<simulation>', 'CreationDate': '2013-05-29T07:02:20.197', 'Id': '12354''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I recall hearing briefly about this back in one of my CS courses on hardware, but I can't recall many of the details, nor can I find anything online that talks about it. A search on Google only yields a bunch of pages about Android emulators and people complaining that PCSX2 is slow. I'd like to know, in general, why software emulation of hardware is inefficient.</p>\n\n<p>Can anybody point me to a good resource or explain briefly here?</p>\n", 'ViewCount': '127', 'Title': 'Why is software emulation of alternative architectures so hard/slow?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-07T22:58:43.460', 'LastEditDate': '2013-07-06T13:36:45.243', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<computer-architecture><simulation>', 'CreationDate': '2013-07-05T23:06:29.567', 'FavoriteCount': '1', 'Id': '13100''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is a practice problem for a midterm in a class I'm taking:</p>\n\n<blockquote>\n  <p>Given a regular language $L$, describe formally a Turing machine that recognize $L$. </p>\n</blockquote>\n\n<p>I'm not sure how I should do that.</p>\n", 'ViewCount': '440', 'Title': 'How can a Turing Machine recognize a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T15:30:56.463', 'LastEditDate': '2013-07-30T10:26:40.687', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<turing-machines><regular-languages><automata><finite-automata><simulation>', 'CreationDate': '2013-07-29T19:45:40.207', 'Id': '13500''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="http://en.wikipedia.org/wiki/Tag_system" rel="nofollow">Tag systems</a> are Turing-complete. I was wondering if there is any easy way to create tag systems that simulate finite automata. So create tag systems that recognize languages, e.g. by having at the end just one output symbol "A" for accepting the initial input or "R" for rejecting it.</p>\n\n<p>I guess a solution would be to make a Tag system simulate a specific Turing machine that simulates a finite automaton but that seems too much and too complicated. Is there perhaps a direct way from tag systems to finite automata?</p>\n', 'ViewCount': '67', 'Title': 'Make a tag system simulate a finite automaton?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:35:42.117', 'LastEditDate': '2013-08-22T14:35:42.117', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '927', 'Tags': '<computability><finite-automata><simulation><computation-models><turing-completeness>', 'CreationDate': '2013-08-19T03:42:11.630', 'FavoriteCount': '1', 'Id': '13808''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm reading Sipser and I'm finding it hard to understand what the process is such that if you give me k Turing machines with k tapes, I can spit out an equivalent Turing machine with only one tape. An example would be nice. Actually, a worked out example that shows how to go from TM that has $k$ tapes to one that has 1 tape is what I'm really looking for. I have been unable to find one so far. I'm also not looking for any proofs.</p>\n", 'ViewCount': '882', 'Title': 'Show how to k tapes of Turing machines into one dimensional Turing machine', 'LastEditorUserId': '9819', 'LastActivityDate': '2014-04-20T02:40:25.263', 'LastEditDate': '2013-09-26T18:51:37.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14621', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<turing-machines><simulation>', 'CreationDate': '2013-09-26T04:08:07.253', 'Id': '14619''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was looking at this: <a href="http://www.cs.odu.edu/~toida/nerzic/390teched/tm/othertms.html" rel="nofollow">http://www.cs.odu.edu/~toida/nerzic/390teched/tm/othertms.html</a></p>\n\n<p>At the very beginning, they show a 2d tape and (I assume) it\'s 1d equivalent. However, I cannot figure out they got from the 2d case to the 1d case. I was hoping someone could elaborate.</p>\n', 'ViewCount': '315', 'Title': 'Two Dimensional Tape of Turing Machine', 'LastActivityDate': '2013-09-26T17:07:19.787', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<computability><turing-machines><simulation>', 'CreationDate': '2013-09-26T16:50:20.973', 'Id': '14628''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '173', 'Title': 'Convert a non-deterministic Turing machine into a deterministic Turing machine', 'LastEditDate': '2013-11-08T13:11:03.730', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10685', 'FavoriteCount': '1', 'Body': '<p>How can we systematically convert a non-deterministic Turing machine into a deterministic Turing machine that recognizes the same language?</p>\n', 'Tags': '<turing-machines><simulation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T13:11:03.730', 'CommentCount': '8', 'AcceptedAnswerId': '16797', 'CreationDate': '2013-11-07T17:20:27.847', 'Id': '16796''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am interested in simulating any turing machine with a turing machine that is allowed only to move right. I guess that it should be pretty standard material and likely it is trivial (or known to be false). Does anyone have a pointer to a reference?</p>\n', 'ViewCount': '103', 'Title': 'Right moving turing machine', 'LastActivityDate': '2013-12-05T10:46:40.527', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18640', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10931', 'Tags': '<turing-machines><simulation><turing-completeness>', 'CreationDate': '2013-12-05T10:21:15.477', 'Id': '18639''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is it possible to simulate a regular Turing Machine with a TM with the following specs?</p>\n\n<ol>\n<li>There are two heads, one of which can read, one of which can write</li>\n<li>Both heads can only move right</li>\n<li>When a head reads (or it writes) it moves right</li>\n</ol>\n\n<p>I know it's possible to simulate a TM that only moves right. But, is it possible to simulate the left moves as well?</p>\n", 'ViewCount': '85', 'Title': 'Simulating a TM with a 2-head, right moving TM', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-22T13:52:53.880', 'LastEditDate': '2014-01-22T09:25:11.160', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19889', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<turing-machines><turing-completeness><simulation>', 'CreationDate': '2014-01-22T01:08:02.397', 'Id': '19885''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><sup>This is a cross-post from a post on <a href="http://math.stackexchange.com/posts/655746/edit">MathSE</a> due to lack of answers.</sup></p>\n\n<p>To illustrate my question I provide the following example.</p>\n\n<p>The website <a href="http://db.ing.puc.cl/turingmachine/" rel="nofollow">Online Turing Machine</a> provides a Turing Machine simulator. The following program adds 1 to any binary number.</p>\n\n<pre><code>q0,1  =&gt;  q0,1,&gt;\nq0,0  =&gt;  q0,0,&gt;\nq0,_  =&gt;  q1,_,&lt;\nq1,0  =&gt;  q3,1,&gt;\nq1,1  =&gt;  q1,0,&lt;\nq1,_  =&gt;  q3,1,&gt;\n</code></pre>\n\n<p>A program line has the following format:</p>\n\n<pre><code>state, character read =&gt; new state, character written, direction tape\n</code></pre>\n\n<p>In the program above q0 is the initial state and q3 is the accepting state.</p>\n\n<p>In Tilings and Patterns by Gruenbaum and Shephard, 11.4 "Computing By Tiles" I read that it is possible to convert any turing machine program to a tiling of the plane using Wang tiles. The book contains an example tiling which calculates the Fibonacci numbers. The procedure, recipe, to convert a Turing machine program to a set of Wang tiles is not entirely clear to me.</p>\n\n<p><strong>Question: What is the algorithm to convert a Turing Machine program line by line to a set of tiling of the plane using Wang Tiles?</strong> And how does it work on the Turing machine in the given example?</p>\n\n<p>Update:</p>\n\n<p>Image is that of a Wang tile that adds 1 to a binary: 111 + 1 = 1000 where 1 is red, 0 is cyan. Aiming to generate tiles like this from any Turing Machine. First row 111, last row 1000.</p>\n\n<p><img src="http://i.stack.imgur.com/w6dl0.png" alt="Wang Tile"></p>\n', 'ViewCount': '81', 'Title': 'How to convert a Turing Machine program to a tiling using Wang Tiles?', 'LastEditorUserId': '13315', 'LastActivityDate': '2014-02-11T04:14:35.720', 'LastEditDate': '2014-02-05T11:13:19.857', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13315', 'Tags': '<turing-machines><simulation><computation-models><tiling>', 'CreationDate': '2014-02-02T10:11:46.570', 'Id': '20207''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>A deterministic queue automaton (DQA) is like a PDA except the stack is replaced by a queue. A queue is a tape allowing symbols to be written (push) on the left-end and read (pull) on the right-end. </p>\n\n<p>Actually I've proved that a 2-tape Turing Machine can simulate the DQA. Now I'm proving the DQA can simulate Turing Machine TM. Let the queue store all the input and the right-end symbol is the one being read. Suppose $a$ is the right-end symbol in the queue. </p>\n\n<p>For the transition $\\delta(q,a)=(r,b,L)$ in TM, it's easy to simulate. Just pull $a$ and push $b$. Now the right-end symbol would be the symbol on the left of $a$. It's like move the head in TM to the left. </p>\n\n<p>My problem is I cannot find a way to simulate the transition $\\delta(q,a)=(r,b,R)$. Since the symbol on the right of $a$ is actually the left-end symbol, how can I let this symbol move to the right-end? I spend several hours on this and I think answers on Internet are not very clear. Could anyone give me some hint? </p>\n", 'ViewCount': '48', 'Title': 'Prove Queue Automaton is equivalent to Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T23:27:53.420', 'LastEditDate': '2014-02-09T22:51:54.143', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21465', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<turing-machines><automata><simulation>', 'CreationDate': '2014-02-09T03:01:35.187', 'Id': '21460''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It is known that a nondeterministic universal turing machine (UTM) can simulate another nondeterministic TM with running time $t(n)$ in time $c t(n)$, where $c$ is a constant. It is also known that a deterministic UTM can simulate another deterministic TM with running time $t(n)$ in time $ t(n)\\log(t(n))$. </p>\n\n<p>My question is: why is there a $\\log(t(n))$ slowdown in the simulation of a deterministic TM by a UTM, as opposed to a constant factor slowdown in the nondeterministic case?</p>\n', 'ViewCount': '164', 'Title': 'Difference between deterministic and nondeterministic universal turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-23T20:36:58.043', 'LastEditDate': '2014-02-23T20:36:58.043', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14961', 'Tags': '<complexity-theory><turing-machines><time-complexity><simulation>', 'CreationDate': '2014-02-23T17:58:30.433', 'Id': '21949''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a sphere (radius R) on a rectilinear grid. Some cells intersect the edge of that sphere, call them \'edge cells\'. Designate a given cell by indices [i,j,k] which refer to the lowest-index vertex of that cell (i.e. the inner-most cell, in the [+x,+y,+z] octant would be designated as [0,0,0]). For any given \'edge cell\', how can I calculate what fraction of its volume is within the sphere of radius R?</p>\n\n<p>In this figure, the purple surface is the surface of the sphere passing through some arbitrary cell, with origin [x0,y0,z0]. I want to know what fraction of the cell\'s volume is within this surface.</p>\n\n<p><img src="http://i.stack.imgur.com/vF22q.png" alt="enter image description here"></p>\n\n<p>I think \'edge cells\' can be calculated by finding the cells whose vertex [i,j,k] is at a radius R.</p>\n\n<p>I think there should be an analytic formula to calculate the volume fraction, but I can\'t figure out how to setup the integral. Any help would be greatly appreciated!</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-03-06T12:01:43.700', 'Title': 'fraction of volume of a rectilinear grid cell within some radius of the origin', 'LastActivityDate': '2014-03-04T17:36:17.757', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15276', 'Tags': '<algorithms><computational-geometry><simulation>', 'CreationDate': '2014-03-04T17:36:17.757', 'Id': '22276''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to implement various Randomized Distributed algorithms for MIS, Broadcast, Coloring in Radio Networks. I want use very high level language or any simulator for this. Please suggest on this.</p>\n', 'ViewCount': '23', 'ClosedDate': '2014-03-10T13:16:57.813', 'Title': 'simulation of Randomized distributed algorithms', 'LastActivityDate': '2014-03-09T12:46:57.177', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15446', 'Tags': '<distributed-systems><simulation>', 'CreationDate': '2014-03-09T12:46:57.177', 'FavoriteCount': '1', 'Id': '22427''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>When converting a CFG to a PDA I know that you get three main states, Qstart, Qloop and Qaccept. But Qloops will need a various amount of states, and my question is how many? Is there a way to find out the "worst case scenario" of how many states there can potentially be? I don\'t mean for one particular CFG, but in general. I\'m having difficulties trying to figure out how I can calculate this... </p>\n', 'ViewCount': '62', 'Title': 'How many states when converting CFG to PDA', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T14:40:54.410', 'LastEditDate': '2014-03-24T10:49:04.057', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '22994', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<context-free><automata><formal-grammars><pushdown-automata><simulation>', 'CreationDate': '2014-03-24T09:24:37.833', 'Id': '22992''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have come up with a type of simulation "game" but I cannot find anything describing it online.</p>\n\n<p>The simulation has a 2D "world" with a number of automatons on a discrete grid, similar to the game GNU Robots, although for an interesting game, their behavioral rules should be much more complex:</p>\n\n<pre><code>#.......\n#...#...\n...#....\n....#..#\n..#.....\n</code></pre>\n\n<p>Where each <code>#</code> is a robot.</p>\n\n<p>What\'s this class of simulations called?</p>\n', 'ViewCount': '23', 'Title': 'Name for a Type of Simulation', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-27T08:30:25.417', 'LastEditDate': '2014-03-27T08:30:25.417', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6727', 'Tags': '<terminology><simulation>', 'CreationDate': '2014-03-26T18:11:28.960', 'Id': '23094''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In proofs of decidability, we often want to simulate another model of computation by a Turing machine. But if I can simulate a $\\mathsf{DFA}$ by, say, a C program, then is there some result which says that the $\\mathsf{DFA}$ can be simulated by some $\\mathsf{TM}$? Could a program be used in place of a $\\mathsf{TM}$ in a proof of decidability?</p>\n\n<p>I know that Java being Turing-complete would mean that it can simulate any $\\mathsf{TM}$, so this is sort of the reverse of Turing-completeness I guess.</p>\n', 'ViewCount': '117', 'Title': 'If a DFA can be simulated by a real program, can it be simulated by a TM', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-30T11:36:35.010', 'LastEditDate': '2014-03-29T21:15:13.643', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '23230', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<computability><simulation><turing-completeness>', 'CreationDate': '2014-03-29T19:26:11.393', 'Id': '23228''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}