{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '445', 'Title': 'Is rejection sampling the only way to get a truly uniform distribution of random numbers?', 'LastEditDate': '2012-08-17T17:42:18.317', 'AnswerCount': '3', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '2', 'Body': '<p>Suppose that we have a random generator that outputs\nnumbers in the range $[0..R-1]$ with uniform distribution and we\nneed to generate random numbers in the range $[0..N-1]$\nwith uniform distribution.</p>\n\n<p>Suppose that $N &lt; R$ and $N$ does not evenly divide $R$;\nin order to get a <strong>truly uniform distribution</strong> we can use the\n<a href="http://en.wikipedia.org/wiki/Rejection_sampling">rejection sampling</a> method:</p>\n\n<ul>\n<li>if $k$ is the greatest integer such that $k N &lt; R$</li>\n<li>pick a random number $r$ in $[0..R-1]$</li>\n<li>if $r &lt; k N$ then output $r \\mod N$, otherwise keep trying with other random numbers r\', r", ... until the condition is met</li>\n</ul>\n\n<blockquote>\nIs rejection sampling the only way to get a truly uniform discrete distribution?\n</blockquote>\n\n<p>If the answer is yes, why? </p>\n\n<p>Note: if $N &gt; R$ the idea is the same: generate a random number $r\'$ in $[0..R^m-1], R^m &gt;= N$, for example $r\' = R(...R(R r_1 + r_2)...)+r_m$ where $r_i$ is a random number in the range $[0..R-1]$</p>\n', 'Tags': '<probability-theory><randomness><random-number-generator><sampling>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-18T14:29:51.573', 'CommentCount': '1', 'AcceptedAnswerId': '2619', 'CreationDate': '2012-07-04T07:46:04.420', 'Id': '2605'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '780', 'Title': 'Uniform sampling from a simplex', 'LastEditDate': '2012-08-17T09:22:28.433', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2553', 'FavoriteCount': '1', 'Body': "<p>I am looking for an algorithm to generate an array of N random numbers, such that the sum of the N numbers is 1, and all numbers lie within 0 and 1. For example, N=3, the random point (x, y, z) should lie within the triangle:</p>\n\n<pre><code>x + y + z = 1\n0 &lt; x &lt; 1\n0 &lt; y &lt; 1\n0 &lt; z &lt; 1\n</code></pre>\n\n<p>Ideally I want each point within the area to have equal probability. If it's too hard, I can drop the requirement. Thanks.</p>\n", 'Tags': '<algorithms><randomness><random-number-generator><sampling>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-09-27T21:24:11.037', 'CommentCount': '2', 'AcceptedAnswerId': '3229', 'CreationDate': '2012-08-16T19:45:16.167', 'Id': '3227'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We throw two coins in a row and thus get the event space $\\{ZZ, WW, ZW, WZ\\}$. \nEach of the 4 elementary events has a probability $1/4$.\nhow can I construct 3 binary random variable $x_1$, $x_2$, $x_3$ about this event space, which are 2-fold independent, but not independent.</p>\n', 'ViewCount': '162', 'Title': 'Construction of binary random variable', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-02T11:26:02.913', 'LastEditDate': '2012-10-30T16:41:55.883', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1402', 'Tags': '<probability-theory><sampling>', 'CreationDate': '2012-10-30T13:53:15.393', 'FavoriteCount': '0', 'Id': '6386'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We have a stochastic random source. This gives the bit $0$ (or $1$) with probability $1/2$. \nWe want to generate a uniform distribution on the set S = $\\{0, 1,..., n-1\\}$. </p>\n\n<p>Which algorithm gives with probability $1/n$ the value $i\\in S$. And how many bits are needed.</p>\n', 'ViewCount': '47', 'Title': 'Stochastical algorithm', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-06T10:58:11.537', 'LastEditDate': '2012-11-06T10:35:24.340', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1402', 'Tags': '<algorithms><random><sampling>', 'CreationDate': '2012-11-06T09:57:05.557', 'Id': '6507'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There may be a large number of algorithms proposed for generating graphs satisfying some common properties (e.g., clustering coefficient, average shortest path length, degree distribution, etc).</p>\n\n<p>My question concerns a specific case: I want to generate a few <em>undirected regular</em> graphs (i.e., every node in these graphs has the same number of neighbors) with different clustering coefficients and average shortest path lengths. More generally, by fixing a degree distribution, I want to generate graphs with different clustering coefficients and average shortest path lengths.</p>\n\n<p>I wonder what are the well-known algorithms for doing this (or in fact, is there any?), and what are the recommended software for the same purpose?</p>\n', 'ViewCount': '358', 'Title': 'Algorithms for graph generation using given properties', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T10:21:38.160', 'LastEditDate': '2012-11-18T18:43:46.823', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4641', 'Tags': '<algorithms><graph-theory><graphs><sampling>', 'CreationDate': '2012-11-18T17:26:39.090', 'FavoriteCount': '1', 'Id': '6744'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The ideal random permutation algorithm of <a href="http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm" rel="nofollow">Fisher and Yates</a> (Algorithm P in Knuth vol.2) for a sequence of $n$ objects requires $n-1$ random numbers. </p>\n\n<p>In some card games one first does a "cut" and then a ripple shuffle. The cutting point is a random value, the subsequent shuffling could be considered as deterministic. That is, only one random number is being used to generate the permutation, which understandably can\'t be ideal. On the other hand, theoretical perfection isn\'t always necessary in practice. I like hence to know whether, if one keeps the constraint of using one random number in a run, the quality of randomness of the permutation obtained couldn\'t eventually be improved through certain appropriate modifications of the procedure commonly employed in card games, if one is willing to take the trade-off of more work/time, inconvenience, etc. Such trade-offs may not be acceptable for real games, but I suppose there may be other practical applications that could advantageously exploit the same idea, thus without being required to acquire, e.g. via a chosen PRNG, the larger number of random numbers needed for executing the algorithm of Fisher and Yates.</p>\n', 'ViewCount': '184', 'Title': 'Best random permutation employing only one random number', 'LastEditorUserId': '6437', 'LastActivityDate': '2013-01-28T16:06:34.070', 'LastEditDate': '2013-01-28T11:28:18.590', 'AnswerCount': '2', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6437', 'Tags': '<randomness><random><sampling><permutations>', 'CreationDate': '2013-01-27T10:54:47.110', 'Id': '9199'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I have a graph $G$ with $M(G)$ the (unknown) set of perfect matchings of $G$. Suppose this set is non-empty, then how difficult is it to sample uniformly at random from $M(G)$? What if I am okay with a distribution that is close to uniform, but not quite uniform, then is there an efficient algorithm?</p>\n', 'ViewCount': '113', 'Title': 'Sampling perfect matching uniformly at random', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-26T10:12:47.543', 'LastEditDate': '2013-03-26T10:12:47.543', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '10758', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<algorithms><complexity-theory><matching><sampling>', 'CreationDate': '2013-03-24T21:22:33.253', 'Id': '10756'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I get values $x_t$ in an online fashion and want to buy "good" ones, where "good" means that some measure $P(x_t) &gt;T$. Consider the following simple algorithm.</p>\n\n<pre><code>T = 0.7\nN = 100 // or any value N &gt; B\nB = 20 // or any value 1 &lt; B &lt; N\n\nl = 0\n\nfor t from 1 to N:\n    input a new observation x_t\n    let P(x_t) the probability associated to x_t\n\n    if P(x_t) &gt; T:\n        l = l + 1\n        pay 1 dollar to buy y_t the label of x_t\n        output immediately the label y_t\n</code></pre>\n\n<p>If the condition $P(x_t) &gt; T$ is used then we get about $l = 100-70 = 30$, this is ok since the value of $T$ is set to $0.7$.</p>\n\n<p>Now if I want to add a constraint which is: additionally to the fact that elements $x_t$ for which the label $y_t$ is purchased are those for which $P(x_t) &gt; T$, I want also that we do not buy more than $B=20$ labels (for example because we only have 20 dollars as budget).</p>\n\n<p>But the problem is that, if I replace the the condition ($P(x_t) &gt; T$) by ($P(x_t) &gt; T \\wedge l &lt; B$), then the elements $x_t$ for which we buy a label are more likely to be among the first elements $t$ that we browse (that is, for an element $x_{95}$ for $t = 95$ for example we will never have a chance to buy its label even if its probability was $P(x_{95}) \\gg T$). But I want that all the elements from $t = 1$ to $N$ will have equal chance to buy their label (not advantaging only the first elements).</p>\n\n<p>Note: the condition that $P(x_t) &gt; T$ for buying the label of a new observation $x_t$, should not be removed from my code. This is important for me: only labels of observations for which $P(x_t)$ was higher than $T$ at time $t$, are possibly purchased; and we should not purchase more than our budget $B$. Note also that a purchased label should immediately be output after we buy it, we should not wait until the end to decide if we buy it or not.</p>\n\n<p>Also, note that we do not have the N elements beforehand; at each time $t$ we see just one new observation $x_t$. And note that you pay 1 dollar when you select a given $x_t$ to ask for its label and that you should output answer (label of selected $x_t$) immediately; so you can not select some $B$ elements then replace them with new selected other elements, because your budget $B$ will already be finished.</p>\n', 'ViewCount': '64', 'Title': 'How to sample uniformly from a stream of elements, some of which are unsuited?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-04-18T19:57:32.787', 'LastEditDate': '2013-04-18T17:53:54.317', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2895', 'Tags': '<probabilistic-algorithms><online-algorithms><sampling>', 'CreationDate': '2013-04-17T22:07:38.767', 'Id': '11370'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a set $S$ of $k$ numbers in $[0, N)$.\nThe task is to randomly generate numbers in the range $[0, N)$ such that none belongs to $S$.</p>\n\n<p><strong>Edit</strong> - Also given an API to generate random numbers between $[0, N)$. We have to use it  to randomly generate numbers in the range $[0, N)$ such that none belongs to $S$.</p>\n\n<p>I would also like a generic strategy for such questions. Another one I came across was to generate random numbers between [0,7] given a random number generator that generates numbers in range [0, 5].</p>\n', 'ViewCount': '225', 'Title': 'Generate random numbers from an interval with holes', 'LastEditorUserId': '9166', 'LastActivityDate': '2013-07-17T16:03:32.970', 'LastEditDate': '2013-07-15T07:05:30.703', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '13272', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9166', 'Tags': '<algorithms><probability-theory><sampling><random-number-generator>', 'CreationDate': '2013-07-14T13:12:52.417', 'Id': '13271'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to sample a uniformly random point in a polygon...</p>\n\n<p>If sample a large number they\'d be equally likely to fall into two regions if they have the same area.</p>\n\n<p>This would be quite simple if it were a square since I would take two random numbers in [0,1] as my coordinates.</p>\n\n<p>The shape I have is a regular polygon, but I\'d like it to work for any polygon.</p>\n\n<p><a href="http://stackoverflow.com/questions/3058150/how-to-find-a-random-point-in-a-quadrangle">http://stackoverflow.com/questions/3058150/how-to-find-a-random-point-in-a-quadrangle</a></p>\n\n<p><img src="http://mathworld.wolfram.com/images/eps-gif/TrianglePointPicking_700.gif" width="400"></p>\n', 'ViewCount': '192', 'Title': 'Random sampling in a polygon', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-29T14:38:32.687', 'LastEditDate': '2013-08-29T14:38:32.687', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><randomness><sampling><random-number-generator>', 'CreationDate': '2013-08-29T00:36:47.990', 'Id': '14007'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There is a markov chain on the states $\\Phi = \\{0,1,2\\dots n\\}$. I am also given the probabilities. E.g., the probability of going from i to i+1 is 1/2, going from i to state 0 = 1/2, and finally going from n to n is 1/2 and n to 0 is 1/2. </p>\n\n<p>I want to find the stationary distribution. And the chain is not reversible. </p>\n\n<p>So I'm not sure how to proceed. My first instinct was to try and use linear algebra but I'm not sure how to do that since I only know that there are $n$ states. Is there a way to solve this analytically, using paper and pencil?</p>\n", 'ViewCount': '47', 'Title': 'Find stationary distribution of markov chain', 'LastEditorUserId': '9819', 'LastActivityDate': '2013-10-05T02:25:57.483', 'LastEditDate': '2013-10-05T02:25:57.483', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<sampling><markov-chains>', 'CreationDate': '2013-10-05T00:52:38.613', 'Id': '14821'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $G$ be a graph, and let $s$ and $t$ be two vertices of $G$. Can we efficiently sample a shortest $s$-$t$ path uniformly and independently at random from the set of all shortest paths between $s$ and $t$? For simplicity, we can assume $G$ is simple, undirected and unweighted.</p>\n\n<p>Even in many restricted graphs, the number of shortest paths between $s$ and $t$ can be exponential in the size of $G$. Therefore, we would naturally like avoid actually computing all the shortest $s$-$t$ paths. I don't know about the general case, but it seems to me that we can achieve this for some special graph classes.</p>\n\n<p>This feels like something someone must have considered before. Is there any existing research into this, or is this in fact simple to do even for general graphs?</p>\n", 'ViewCount': '187', 'Title': 'Efficiently sampling shortest $s$-$t$ paths uniformly and independently at random', 'LastActivityDate': '2013-11-12T15:18:07.457', 'AnswerCount': '2', 'CommentCount': '14', 'AcceptedAnswerId': '17929', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<graph-theory><reference-request><shortest-path><sampling>', 'CreationDate': '2013-11-11T14:36:27.297', 'FavoriteCount': '4', 'Id': '17917'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Motivated by <a href="http://cs.stackexchange.com/q/17917/2755">Efficiently sampling shortest s-t paths uniformly and independently at random</a>,</p>\n\n<p>The answers give methods of randomly sampling shortest $s\\text{-}t$ paths. However, they use a lot of seemingly unnecessary random bits.</p>\n\n<p>My question is:</p>\n\n<blockquote>\n  <p>Can the solution be improved to use a single random number in interval $[0,w(t))$, where $w(t)$ is the total number of shortest paths from $s\\text{-}t$.</p>\n  \n  <p>Alternatively, can the solution be improved to use $\\left\\lceil \\log_2 w(t)\\right\\rceil $ random bits?</p>\n</blockquote>\n', 'ViewCount': '74', 'Title': 'Uniformly random efficient sampling of shortest s-t paths, with optimal random bits', 'LastActivityDate': '2013-11-17T19:21:56.460', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18091', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<graph-theory><shortest-path><sampling><random>', 'CreationDate': '2013-11-17T01:51:40.173', 'FavoriteCount': '1', 'Id': '18089'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given n, I want to randomly generate a binary tree (unlabelled) that has n end nodes. Could someone kindly provide a reference containing an algorithm for doing that?</p>\n\n<p>I attempted to do as follows: From a PRNG obtain n PRNs in [0.0, 1.0) as (relative) frequencies of n symbols for generating a Huffman tree (used in data compression). But, if the PRNs used are uniform, then I think this would highly favour generation of those Huffman trees that are more flat and Huffman trees corresponding to widely different frequencies of the symbols would be highly suppressed in the generation process. If this is correct, how could one do better? Thanks in advance.</p>\n', 'ViewCount': '63', 'Title': 'Generation of random binary trees', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-20T13:47:45.200', 'LastEditDate': '2014-02-28T08:39:33.350', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6437', 'Tags': '<data-structures><sampling><random-graphs>', 'CreationDate': '2014-02-27T17:34:00.827', 'Id': '22098'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I built a set of samples from an imbalanced dataset with two classes through the undersampling technique. Now, from that set of decision trees I would like to choose one representative tree. Is there any algorthm to do that?</p>\n', 'ViewCount': '9', 'Title': 'Representative tree from sets of decision trees', 'LastActivityDate': '2014-03-07T17:28:30.820', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15398', 'Tags': '<trees><sampling>', 'CreationDate': '2014-03-07T17:28:30.820', 'FavoriteCount': '1', 'Id': '22376'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '360', 'Title': 'Is this method really uniformly random?', 'LastEditDate': '2014-03-25T22:35:47.140', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16107', 'FavoriteCount': '2', 'Body': "<p>I have a list and want to select a random item from the list.</p>\n\n<p>An algorithm which is said to be random:</p>\n\n<blockquote>\n  <p>When you see the first item in the list, you set it as the selected item.</p>\n  \n  <p>When you see the second item, you pick a random integer in the range [1,2]. If it's 1, then the new item becomes the selected item. Otherwise you skip that item.</p>\n  \n  <p>For each item you see, you increase the count, and with probability 1/count, you select it. So at the 101st item, you pick a random integer in the range [1,101]. If it's 100, that item is the new selected node.</p>\n</blockquote>\n\n<p>Is it really uniformly random?</p>\n\n<p><strong>My thoughts are:</strong></p>\n\n<p>As the number of nodes increases, the probability for them being selected \ndecreases, so the best chance of selection is for items 1, 2, 3, ..., not for 20, 21, ..., 101.</p>\n\n<p>Each node will not have equal probability of being selected.</p>\n\n<p>Please clarify, as I have trouble understanding this.</p>\n", 'Tags': '<algorithms><probability-theory><randomized-algorithms><sampling>', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-25T22:35:47.140', 'CommentCount': '5', 'AcceptedAnswerId': '23041', 'CreationDate': '2014-03-25T17:55:00.713', 'Id': '23038'}