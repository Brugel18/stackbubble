{'Body': '<p>I want to know if the following problem is decidable and how to find out. Every problem I see I can say "yes" or "no" to it, so are most problems and algorithms decidable except a few (which is provided <a href="http://en.wikipedia.org/wiki/List_of_undecidable_problems" rel="nofollow">here</a>)?</p>\n\n<blockquote>\n  <p>Input: A directed and finite graph $G$, with $v$ and $u$ as vertices<br>\n  Question: Does a path in $G$ with $u$ as initial vertex and $v$ as final vertex exist?</p>\n</blockquote>\n', 'ViewCount': '327', 'Title': 'Is this finite graph problem decidable? What factors make a problem decidable?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-30T21:37:25.987', 'LastEditDate': '2012-04-30T21:37:25.987', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '153', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<algorithms><computability><graph-theory><undecidability>', 'CreationDate': '2012-03-09T00:47:22.190', 'Id': '143''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '3710', 'Title': 'The time complexity of finding the diameter of a graph', 'LastEditDate': '2012-08-08T14:16:53.283', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '2', 'Body': '<blockquote>\n  <p>What is the time complexity of finding the diameter of a graph\n  $G=(V,E)$?</p>\n  \n  <ul>\n  <li>${O}(|V|^2)$</li>\n  <li>${O}(|V|^2+|V| \\cdot |E|)$</li>\n  <li>${O}(|V|^2\\cdot |E|)$</li>\n  <li>${O}(|V|\\cdot |E|^2)$</li>\n  </ul>\n</blockquote>\n\n<p>The diameter of a graph $G$ is the longest distance between two vertices in graph.</p>\n\n<p>I have no idea what to do about it, I need a complete analysis on how to solve a problem like this.</p>\n', 'Tags': '<algorithms><time-complexity><graph-theory>', 'LastEditorUserId': '72', 'LastActivityDate': '2013-03-23T22:43:49.053', 'CommentCount': '4', 'AcceptedAnswerId': '213', 'CreationDate': '2012-03-10T12:24:48.097', 'Id': '194''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>When searching graphs, there are two easy algorithms: <strong>breadth-first</strong> and <strong>depth-first</strong> (Usually done by adding all adjactent graph nodes to a queue (breadth-first) or stack (depth-first)).</p>\n\n<p>Now, are there any advantages of one over another?</p>\n\n<p>The ones I could think of:</p>\n\n<ul>\n<li>If you expect your data to be pretty far down inside the graph, <em>depth-first</em> might find it earlier, as you are going down into the deeper parts of the graph very fast.</li>\n<li>Conversely, if you expect your data to be pretty far up in the graph, <em>breadth-first</em> might give the result earlier.</li>\n</ul>\n\n<p>Is there anything I have missed or does it mostly come down to personal preference?</p>\n', 'ViewCount': '10527', 'Title': 'Graph searching: Breadth-first vs. depth-first', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-24T23:35:26.743', 'LastEditDate': '2013-09-09T01:44:33.060', 'AnswerCount': '6', 'CommentCount': '1', 'Score': '31', 'PostTypeId': '1', 'OwnerUserId': '101', 'Tags': '<algorithms><graph-theory><search-algorithms><graph-traversal>', 'CreationDate': '2012-03-13T10:05:58.093', 'FavoriteCount': '14', 'Id': '298''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '3515', 'Title': 'How hard is counting the number of simple paths between two nodes in a directed graph?', 'LastEditDate': '2012-03-26T05:19:12.447', 'AnswerCount': '1', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '137', 'FavoriteCount': '5', 'Body': "<p>There is an easy polynomial algorithm to decide whether there is a path between two nodes in a directed graph (just do a routine graph traversal with, say, depth-first-search).</p>\n\n<p>However it seems that, surprisingly, the problem gets much harder if instead of testing for the existence we want want to <em>count</em> the number of paths.</p>\n\n<p>If we allow paths to reuse vertices then there is a dynamic programming solution to find the number of paths from <em>s</em> to <em>t</em> with <em>n</em> edges. <strong>However, if we only allow simple paths, that don't reuse vertices, the only solution I can think of is brute force enumeration of the paths</strong>, something that has exponential time complexity.</p>\n\n<p>So I ask,</p>\n\n<ul>\n<li>Is counting the number of simple paths between two vertices hard?</li>\n<li>If so, is it kind of NP-complete? (I say kind of because it is technically not a decision problem...)</li>\n<li>Are there other problems in P that have a hard counting versions like that too?**</li>\n</ul>\n", 'Tags': '<algorithms><complexity-theory><graph-theory>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-26T05:19:12.447', 'CommentCount': '3', 'AcceptedAnswerId': '445', 'CreationDate': '2012-03-15T18:22:52.533', 'Id': '423''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1315', 'Title': 'Proving a binary tree has at most $\\lceil n/2 \\rceil$ leaves', 'LastEditDate': '2012-03-30T02:27:43.967', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '756', 'FavoriteCount': '3', 'Body': '<p>I\'m trying to prove that a <a href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a> with $n$ nodes has at most $\\left\\lceil \\frac{n}{2} \\right\\rceil$ leaves. How would I go about doing this with induction?</p>\n\n<p><em>For people who were following in the original question about heaps, it has been moved <a href="http://cs.stackexchange.com/questions/841/proving-a-binary-heap-has-lceil-n-2-rceil-leaves">here</a>.</em></p>\n', 'Tags': '<data-structures><binary-trees><combinatorics><graph-theory><proof-techniques>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-10-01T04:35:17.907', 'CommentCount': '7', 'AcceptedAnswerId': '810', 'CreationDate': '2012-03-26T21:51:56.127', 'Id': '805''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '382', 'Title': 'Proving that directed graph diagnosis is NP-hard', 'LastEditDate': '2012-03-27T13:53:00.233', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '766', 'FavoriteCount': '1', 'Body': "<p>I have a homework assignment that I've been bashing my head against for some time, and I'd appreciate any hints. It is about choosing a known problem, the NP-completeness of which is proven, and constructing a reduction from that problem to the following problem I'll call DGD (directed graph diagnosis).</p>\n\n<h3>Problem</h3>\n\n<blockquote>\n  <p>An instance of DGD $(V,E,k)$ consist of vertices $V = I \\overset{.}{\\cup} O \\overset{.}{\\cup} B$, directed edges $E$ and a positive integer $k$. There are three types of vertices: vertices with only incoming edges $I$, vertices with only outgoing edges $O$ and vertices with both incoming and outgoing edges $B$. Let furthermore $D=O\\times I$. </p>\n  \n  <p>Now, the problem is whether we can cover all nodes with at most $k$ elements of $D$, i.e.</p>\n  \n  <p>$\\qquad \\displaystyle \\exists\\,S\\subseteq D, |S|\\leq k.\\ \\forall\\, v\\in V.\\ \\exists\\,(v_1,v_2) \\in S.\\ v_1 \\to^* v \\to^* v_2 $</p>\n  \n  <p>where $a\\to^* b$ means that there is a directed path from $a$ to $b$.</p>\n</blockquote>\n\n<hr>\n\n<p>I think that the Dominating Set problem is the one I should be reducing from, because this too is concerned about covering a subset of nodes with another subset. I tried creating a DGD instance by first creating two nodes for each element of the dominating set, copying all edges, and then setting the $k$ of the DGD instance equal to that of the DS instance.</p>\n\n<p>Suppose a simple DS-instance with nodes $1$, $2$ and $3$ and edges $(1,2)$ and $(1,3)$. This is a yes-instance with $k = 1$; the dominating set in this case consists of only node $1$. Reducing with the method just described, this would lead to a DGD instance with two paths $(1 \\to 2 \\to 1&#39;)$ and $(1 \\to 3 \\to 1&#39;)$; to cover all nodes, just one pair $(1, 1&#39;)$ would be sufficient. This would have worked perfectly, were it not for the fact that the dominating set of the DS-instance cannot, of course, be determined in polynomial time, which is a requirement here.</p>\n\n<p>I have found that there are many good-looking ways to transform the edges and vertices when reducing, but my problem is somehow expressing DGD's $k$ in terms of DS's $k$. Dominating Set seemed a fitting problem to reduce from, but because of this I think that maybe I should try to reduce from a problem that has no such $k$?</p>\n", 'Tags': '<complexity-theory><np-hard><graph-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:54:54.900', 'CommentCount': '2', 'AcceptedAnswerId': '812', 'CreationDate': '2012-03-27T07:03:35.207', 'Id': '811''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Why cannot I find any information about spanning tree for DAG ?  I must be wrong somewhere.</p>\n', 'ViewCount': '427', 'Title': 'Does spanning tree make sense for DAG?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-31T07:20:13.363', 'LastEditDate': '2012-03-30T10:44:36.073', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '906', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '694', 'Tags': '<graphs><graph-theory><spanning-trees>', 'CreationDate': '2012-03-30T10:43:07.210', 'Id': '897''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '371', 'LastEditorDisplayName': 'user742', 'Title': 'Optimal algorithm for finding the girth of a sparse graph?', 'LastEditDate': '2012-04-05T14:18:34.090', 'AnswerCount': '1', 'Score': '16', 'OwnerDisplayName': 'user742', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': '<p>I wonder how to find the <a href="http://en.wikipedia.org/wiki/Girth_%28graph_theory%29">girth</a> of a sparse undirected graph. By sparse I mean $|E|=O(|V|)$. By optimum I mean the lowest time complexity.</p>\n\n<p>I thought about some modification on <a href="http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan\'s algorithm</a> for undirected graphs, but I didn\'t find good results. Actually I thought that if I could find a 2-connected components in $O(|V|)$, then I can find the girth, by some sort of induction which can be achieved from the first part. I may be on the wrong track, though. Any algorithm asymptotically better than $\\Theta(|V|^2)$ (i.e. $o(|V|^2)$) is welcome.</p>\n', 'Tags': '<algorithms><time-complexity><graph-theory>', 'LastActivityDate': '2013-04-15T08:22:17.407', 'CommentCount': '9', 'AcceptedAnswerId': '1087', 'CreationDate': '2012-04-02T23:30:30.770', 'Id': '1001''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '315', 'Title': 'How many shortest distances change when adding an edge to a graph?', 'LastEditDate': '2012-04-06T09:55:35.533', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '92', 'FavoriteCount': '2', 'Body': '<p>Let $G=(V,E)$ be some complete, weighted, undirected graph. We construct a second graph $G&#39;=(V, E&#39;)$ by adding edges one by one from $E$ to $E&#39;$. We add $\\Theta(|V|)$ edges to $G&#39;$ in total.</p>\n\n<p>Every time we add one edge $(u,v)$ to $E&#39;$, we consider the shortest distances between all pairs in $(V, E&#39;)$ and $(V, E&#39; \\cup \\{ (u,v) \\})$. We count how many of these shortest distances have changed as a consequence of adding $(u,v)$. Let $C_i$ be the number of shortest distances that change when we add the $i$th edge, and let $n$ be the number of edges we add in total.</p>\n\n<blockquote>\n  <p>How big is $C = \\frac{\\sum_i C_i}{n}$?</p>\n</blockquote>\n\n<p>As $C_i = O(|V|^2)=O(n^2)$, $C=O(n^2)$ as well. Can this bound be improved? Note that I define $C$ to be the average over all edges that were added, so a single round in which a lot of distances change is not that interesting, though it proves that $C = \\Omega(n)$.</p>\n\n<p>I have an algorithm for computing a geometric t-spanner greedily that works in $O(C n \\log n)$ time, so if $C$ is $o(n^2)$, my algorithm is faster than the original greedy algorithm, and if $C$ is really small, potentially faster than the best known algorithm (though I doubt that).</p>\n\n<p>Some problem-specific properties that might help with a good bound: the edge $(u,v)$ that is added always has larger weight than any edge already in the graph (not necessarily strictly larger). Furthermore, its weight is shorter than the shortest path between $u$ and $v$.</p>\n\n<p>You may assume that the vertices correspond to points in a 2d plane and the distances between vertices are the Euclidian distances between these points. That is, every vertex $v$ corresponds to some point $(x,y)$ in the plane, and for an edge $(u,v)=((x_1,y_1),(x_2,y_2))$ its weight is equal to $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2.}$</p>\n', 'Tags': '<algorithms><graphs><graph-theory><shortest-path>', 'LastEditorUserId': '92', 'LastActivityDate': '2014-01-19T02:02:00.257', 'CommentCount': '11', 'AcceptedAnswerId': '1063', 'CreationDate': '2012-04-05T19:15:54.200', 'Id': '1062''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am writing a Program, solving the <a href="http://en.wikipedia.org/wiki/Route_inspection_problem" rel="nofollow">Chinese Postman Problem</a> (also known as route inspection problem) in an undirected draph and currently facing the problem to find the best additional edges to connect the nodes with odd degree, so I can compute an Eulerian circuit.</p>\n\n<p>There might be (considering the size of the graph that wants to be solved) an enormous combination of edges which need to be computed and evaluated.</p>\n\n<p>As an example there are the odd-degree nodes $A, B, C, D, E, F, G, H$. The best combinations could be:</p>\n\n<ol>\n<li>$AB$, $CD$, $EF$, $GH$</li>\n<li>$AC$, $BD$, $EH$, $FG$</li>\n<li>$AD$, $BC$, $EG$, $FH$</li>\n<li>$AE$ ....</li>\n</ol>\n\n<p>where $AB$ means "edge between node $A$ and node $B$".</p>\n\n<p>Therefore my question is: is there a known algorithm to solve that problem in a complexity better than pure brute force (computing and evaluating them all)?</p>\n\n<p>\u20ac:After some research effort I found <a href="http://web.mit.edu/urban_or_book/www/book/chapter6/6.4.4.html" rel="nofollow">this</a> article, speaking about the "Edmonds\' minimum-length matching algorithm" but I cannot find any pseudo-code or learners-descriptions of this algorithm (or at least I do not recognize them, as Google offers a lot of hits an matching algorithms by J. Edmonds)</p>\n', 'ViewCount': '1120', 'Title': 'Chinese Postman Problem: finding best connections between odd-degree nodes', 'LastEditorUserId': '78', 'LastActivityDate': '2014-01-02T12:01:32.207', 'LastEditDate': '2012-04-15T00:21:19.243', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '78', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-04-13T21:05:09.293', 'FavoriteCount': '1', 'Id': '1257''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '638', 'Title': 'NP-completeness of a spanning tree problem', 'LastEditDate': '2012-05-18T16:16:57.077', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1108', 'FavoriteCount': '0', 'Body': '<p>I was reviewing some NP-complete problems on this site, and I meet one interesting problem from </p>\n\n<p><a href="http://cs.stackexchange.com/questions/808/np-completeness-proof-of-a-spanning-tree-problem">NP completeness proof of a spanning tree problem</a></p>\n\n<p>In this problem, I am interested in the original problem, which the leaf set is precisely $S$. The author said that he can prove this by reducing it to the Hamiltonian path. However, I still cannot figure it out. Could anybody help me with this in details?</p>\n', 'Tags': '<complexity-theory><np-complete><graph-theory><spanning-trees>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-18T16:49:04.167', 'CommentCount': '3', 'AcceptedAnswerId': '1912', 'CreationDate': '2012-04-16T03:30:50.807', 'Id': '1299''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $M$ be a $(0, 1)$ matrix. We say two entries are neighbors if they are adjacent horizontal or vertically, and both entries are $1$'s. One wants to find minimum number of $1$'s to add, so every $1$ can reach another one through a sequence of neighbors. </p>\n\n<p>Example:</p>\n\n<pre><code>100\n000\n001\n</code></pre>\n\n<p>Here we need 3 $1$'s:</p>\n\n<pre><code>100\n100\n111\n</code></pre>\n\n<p>How can we efficiently find the minimum number of $1$'s to add, and where?</p>\n", 'ViewCount': '131', 'Title': "Find minimum number 1's so the matrix consist of 1 connected region of 1's", 'LastEditorUserId': '39', 'LastActivityDate': '2012-04-17T08:18:45.140', 'LastEditDate': '2012-04-16T19:58:48.527', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1303', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '220', 'Tags': '<algorithms><graph-theory><matrices>', 'CreationDate': '2012-04-16T10:16:09.357', 'Id': '1301''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>So I thought this (though somewhat basic) question belonged here:</p>\n\n<p>Say I have a graph of size 100 nodes arrayed in a 10x10 pattern (think chessboard). The graph is undirected, and unweighted. Moving through the graph involves moving three spaces forward and one space to either right or left (similar to how a chess knight moves across a board).</p>\n\n<p>Given a fixed beginning node, how would one find the shortest path to any other node on the board?</p>\n\n<p>I imagined that there would only be an edge between nodes that are viable moves. So, given this information, I would want to find the shortest path from a starting node to an ending node.</p>\n\n<p>My initial thought was that each edge is weighted with weight 1. However, the graph is undirected, so Djikstras would not be an ideal fit. Therefore, I decided to do it using an altered form of a depth first search.</p>\n\n<p>However, I couldn't for the life of me visualize how to get the shortest path using the search.</p>\n\n<p>Another thing I tried was putting the graph in tree form with the starting node as the root, and then selecting the shallowest (lowest row number) result that gave me the desired end node... this worked, but was incredibly inefficient, and thus would not work for a larger graph.</p>\n\n<p>Does anyone have any ideas that might point me in the right direction on this one?</p>\n\n<p>Thank you very much.</p>\n\n<p>(I tried to put in a visualization of the graph, but was unable to due to my low reputation)</p>\n", 'ViewCount': '2595', 'Title': 'Shortest Path on an Undirected Graph?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-01T22:38:48.113', 'LastEditDate': '2012-04-18T05:56:13.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '1330', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<algorithms><graphs><graph-theory><search-algorithms><shortest-path>', 'CreationDate': '2012-04-18T04:23:36.273', 'Id': '1329''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '554', 'Title': 'Is Logical Min-Cut NP-Complete?', 'LastEditDate': '2012-04-28T09:50:58.277', 'AnswerCount': '1', 'Score': '17', 'OwnerDisplayName': 'amirv', 'PostTypeId': '1', 'OwnerUserId': '1280', 'FavoriteCount': '5', 'Body': "<h3>Logical Min Cut (LMC) problem definition</h3>\n\n<p>Suppose that $G = (V, E)$ is an unweighted digraph, $s$ and $t$ are two vertices of $V$, and $t$ is reachable from $s$. The LMC Problem studies how we can make $t$ unreachable from $s$ by the removal of some edges of $G$ following the following constraints:</p>\n\n<ol>\n<li>The number of the removed edges must be minimal.</li>\n<li>We cannot remove every exit edge of any vertex of $G$.</li>\n</ol>\n\n<p>This second constraint is called logical removal. So we look for a <em>logical, minimal removal</em> of some edges of $G$ such that $t$ would be unreachable from $s$.</p>\n\n<h3>Solutions attempts</h3>\n\n<p>If we ignore the logical removal constraint of LMC problem, it will be the min-cut problem in the unweighted digraph $G$, so it will be solvable polynomially (max-flow min-cut theorem). Furthermore, if we ignore the minimal removal constraint of the LMC problem, it will be again solvable polynomially because it is sufficient to find the vertex $k$ such that $k$ is reachable from $s$ and $t$ is not reachable from $k$. Then consider a path $p$ which is an arbitrary path from $s$ to $k$. Now consider the path $p$ as a subgraph of $G$: the answer will be every exit edge of the subgraph $p$. It is obvious that the vertex $k$ can be found by some DFS in $G$ in polynomial time. Hence, by considering just one of the constraints of LMC problem, it will be solvable polynomially.</p>\n\n<p>I tried to solve the LMC problem by a dynamic programming technique but the number of required states for solving the problem became exponential. Moreover, I tried to reduce some NP-Complete problems such as 3-SAT, max2Sat, max-cut, and clique to the LMC problem I didn't manage to find a reduction.</p>\n\n<p>I personally think that the LMC problem is NP-Complete even if $G$ is a binary DAG.</p>\n\n<h3>Questions</h3>\n\n<ol>\n<li>Is the LMC problem NP-Complete in an arbitrary digraph $G$? (main question)</li>\n<li>Is the LMC problem NP-Complete in an arbitrary DAG $G$?</li>\n<li>Is the LMC problem NP-Complete in an arbitrary binary DAG $G$?</li>\n</ol>\n", 'Tags': '<complexity-theory><graph-theory><np-complete>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-16T14:07:05.917', 'CommentCount': '23', 'CreationDate': '2012-04-26T07:52:24.317', 'Id': '1531''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '299', 'Title': 'Approximation algorithm for TSP variant, fixed start and end anywhere but starting point + multiple visits at each vertex ALLOWED', 'LastEditDate': '2012-04-28T09:30:21.653', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1282', 'FavoriteCount': '1', 'Body': '<p>NOTE: Due to the fact that the trip does not end at the same place it started and also the fact that every point can be visited more than once as long as I still visit all of them, this is not really a TSP variant, but I put it due to lack of a better definition of the problem.</p>\n\n<p>This problem was originally posted on StackOverflow, but I was told that this would be a better place. I got one pointer, which converted the problem from non-metric to a metric one.</p>\n\n<p>So..</p>\n\n<p>Suppose I am going on a hiking trip with n points of interest. These points are all connected by hiking trails. I have a map showing all trails with their distances, giving me a directed graph.</p>\n\n<p>My problem is how to approximate a tour that starts at a point A and visits all n points of interest, while ending the tour anywhere but the point where I started and I want the tour to be as short as possible.</p>\n\n<p>Due to the nature of hiking, I figured this would sadly not be a symmetric problem (or can I convert my asymmetric graph to a symmetric one?), since going from high to low altitude is obviously easier than the other way around.</p>\n\n<p>Since there are no restrictions regarding how many times I visit each point, as long as I visit all of them, it does not matter if the shortest path from a to d goes through b and c. Is this enough to say that triangle inequality holds and thus I have a metric problem?</p>\n\n<p>I believe my problem is easier than TSP, so those algorithms do not fit this problem. I thought about using a minimum spanning tree, but I have a hard time applying it to this problem, which under the circumstances, should be a metric asymmetric directed graph?</p>\n\n<p>What I really want are some pointers as to how I can come up with an approximation algorithm that will find a near optimal tour through all n points</p>\n', 'Tags': '<algorithms><complexity-theory><graphs><graph-theory><approximation>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-28T21:59:47.610', 'CommentCount': '5', 'AcceptedAnswerId': '1551', 'CreationDate': '2012-04-28T07:45:11.773', 'Id': '1542''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Say I have a weighted undirected complete graph $G = (V, E)$. Each edge $e = (u, v, w)$ is assigned with a positive weight $w$. I want to calculate the minimum-weighted $(d, h)$-tree-decomposition. By $(d, h)$-tree-decomposition, I mean to divide the vertices $V$ into $k$ trees, such that the height of each tree is $h$, and each non-leaf node has $d$ children. </p>\n\n<p>I know it is definitely $\\text{NP}$-Hard, since minimum $(1, |V|-1)$-tree-decomposition is the minimum Hamilton path. But are there any good approximation algorithms?</p>\n', 'ViewCount': '214', 'Title': 'Approximate minimum-weighted tree decomposition on complete graphs', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T11:59:46.367', 'LastEditDate': '2012-05-10T11:59:46.367', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '11', 'OwnerDisplayName': 'Geni', 'PostTypeId': '1', 'OwnerUserId': '1354', 'Tags': '<algorithms><complexity-theory><graphs><graph-theory><approximation>', 'CreationDate': '2012-05-02T21:38:35.253', 'Id': '1640''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for an algorithm to find a minimal traversal of a directed graph of the following type. Two vertices are given, a start vertex and a terminating vertex. The traversal consists of several runs; each run is a path from the start vertex to the terminating vertex. A run may visit a node more than once. The length of a traversal is the total number of vertices traversed by the runs, with multiplicity; in other words, the length of a traversal is the number of runs plus the sum of the lengths of the runs.</p>\n\n<p>If there are edges that are not reachable (i.e. the origin of the edge is not reachable from the start vertex, or the terminating vertex is not reachable from the target of the edge), they are ignored.</p>\n\n<p>To illustrate my needs, I give a simple graph and post the result, I would like to receive by the algorithm (start vertex $1$, terminating vertex $4$):</p>\n\n<p>Graph edges:</p>\n\n<ul>\n<li>$1 \\to 2,3$</li>\n<li>$2 \\to 1,3,4$</li>\n<li>$3 \\to 4$</li>\n</ul>\n\n<p>Result:</p>\n\n<ul>\n<li>Run A: $1, 2, 1, 3, 4$</li>\n<li>Run B: $1, 2, 4$</li>\n<li>Run C: $1, 2, 3, 4$</li>\n</ul>\n\n<p>Each edge (also each direction) has been covered. Each run begins with vertex $1$ and ends with vertex $4$. The minimum total number of visited vertices is searched. In the given example, the minimum number is $5+3+4=12$. There is no unreachable edge in this example.</p>\n', 'ViewCount': '364', 'Title': 'Find the minimal number of runs to visit every edge of a directed graph', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-08T18:36:00.010', 'LastEditDate': '2012-05-06T23:29:42.950', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1397', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-05-06T22:00:02.643', 'FavoriteCount': '3', 'Id': '1698''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a degree distribution, how fast can we construct a graph that follows the given degree distribution? A link or algorithm sketch would be good. The algorithm should report a "no" incase no graph can be constructed and any one example if multiple graphs can be constructed.</p>\n', 'ViewCount': '270', 'Title': 'Reconstructing Graphs from Degree Distribution', 'LastActivityDate': '2012-05-17T14:43:13.887', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '1885', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '661', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-05-17T12:53:27.080', 'FavoriteCount': '1', 'Id': '1883''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '75', 'Title': 'Low-degree nodes in sparse graphs', 'LastEditDate': '2012-05-22T18:01:02.493', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': u'<p>Let $G = (V,E)$ be a graph having $n$ vertices, none of which are isolated, and $n\u22121$ edges, where $n \\geq 2$. Show that $G$ contains at least two vertices of degree one.</p>\n\n<p>I have tried to solve this problem by using the property $\\sum_{v \\in V} \\operatorname{deg}(v) = 2|E|$.  Can this problem be solved by using <a href="https://en.wikipedia.org/wiki/Pigeon_hole_principle">pigeon hole principle</a>?</p>\n', 'Tags': '<graph-theory><proof-techniques>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-05-24T19:50:20.467', 'CommentCount': '5', 'AcceptedAnswerId': '1999', 'CreationDate': '2012-05-22T17:38:43.177', 'Id': '1998''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In a directed graph with a starting node and an ending node, how to find a small (doesn't have to be smallest. &lt;10 for example) set S of nodes such that every possible path from the starting node to the ending node contains at least one member of set S. The graph may have loops. This may be NP hard. Is there an approximate method to find one or several such S from the graph? Enumerating and testing every candidate seems not work. thanks.</p>\n", 'ViewCount': '58', 'Title': 'Finding small node sets that can not be avoided on paths from source to sink', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T22:05:04.273', 'LastEditDate': '2012-05-23T22:05:04.273', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2032', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1620', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-05-23T20:39:40.190', 'Id': '2028''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I have a "smarter" version of Bellman-Ford here; this version is more clever about choosing the edges to relax.</p>\n\n<pre><code>//Queue Q; source s; vertices u, v; distance to v d(v)\nQ \u2190 s // Q holds vertices whose d(v) values have been updated recently.\nWhile (Q !empty) {\n  u \u2190 Dequeue(Q)\n  for each neighbor v of u {\n    Relax(u, v)\n    if d(v) was updated by Relax and v not in Q\n      Enqueue(v)\n  }\n}\n</code></pre>\n\n<p>But, can anyone explain why this improved version correctly finds the shortest path from $s$ to every other vertex in a directed graph with no negative cycles?</p>\n\n<p>Also, what is the <em>worst-case</em> runtime if every shortest path uses at most $v$ edges?</p>\n', 'ViewCount': '458', 'Title': 'Bellman-Ford variation', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-25T05:17:22.893', 'LastEditDate': '2012-05-24T07:55:34.530', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1624', 'Tags': '<algorithms><graphs><graph-theory><runtime-analysis><shortest-path>', 'CreationDate': '2012-05-24T01:44:55.237', 'FavoriteCount': '2', 'Id': '2039''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m trying to prove that every well-balanced <a href="https://en.wikipedia.org/wiki/Strong_orientation" rel="nofollow">orientation</a> of an <a href="https://en.wikipedia.org/wiki/Eulerian_graph" rel="nofollow">Eulerian graph</a> is Eulerian.</p>\n\n<p>I want to prove it by showing that for any two vertices $u$ and $v$, their local arc connectivities coincide, that is</p>\n\n<p>$\\qquad \\displaystyle P_D\'(u,v)=P_D\'(v,u)$ </p>\n\n<p>for every well-balanced orientation of an Eulerian graph. How can I do this?</p>\n', 'ViewCount': '137', 'Title': 'How to prove every well-balanced orientation of an Eulerian graph is Eulerian?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-02T20:52:33.310', 'LastEditDate': '2012-05-25T11:28:13.730', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'Han Xiao', 'PostTypeId': '1', 'Tags': '<graph-theory>', 'CreationDate': '2012-05-24T06:37:06.417', 'Id': '2046''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Solving the <a href="https://en.wikipedia.org/wiki/Maximum_flow_problem" rel="nofollow">maximum flow problem</a> yields one qualified minimal cut. But I want several (maybe hundreds) small cuts as candidates. The cuts don\'t have to be minimum cuts, as long as they are small (in weight). How do I do that?</p>\n', 'ViewCount': '154', 'Title': 'In s-t directed graph, how to find many small cuts?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-02T17:30:29.300', 'LastEditDate': '2012-05-25T11:18:35.083', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1620', 'Tags': '<algorithms><graphs><graph-theory><optimization><approximation>', 'CreationDate': '2012-05-24T20:19:25.250', 'FavoriteCount': '2', 'Id': '2052''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>For my pet project I need to cluster some data which could be easily represented as graph, so I want to use this as an opportunity to educate myself and play with various algorithms. I'd prefer the book on graph clustering as it often more self contained but articles are fine too. Back in the days I used to work in the field of numerical linear algebra so I'd also prefer algebraical view on things (so books which view graph as a matrix with specific properties are more accessible to me).</p>\n\n<p>p.s. I've tried scholar.google.com but was overwhelmed by vast number of results.  </p>\n", 'ViewCount': '81', 'Title': 'Could someone suggest me a good introductory book or an article on graph clustering?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-25T14:29:21.953', 'LastEditDate': '2012-05-25T14:19:42.963', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2077', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1647', 'Tags': '<algorithms><graphs><graph-theory><reference-request><books>', 'CreationDate': '2012-05-25T13:00:28.593', 'Id': '2076''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Has anyone seen this problem before? It\'s suppose to be NP-complete.</p>\n\n<blockquote>\n  <p>We are given vertices $V_1,\\dots ,V_n$ and possible parent sets for each vertex. Each parent set has an associated cost. Let $O$ be an ordering (a permutation) of the vertices. We say that a parent set of a vertex $V_i$ is consistent with an ordering $O$ if all of the parents come before the vertex in the ordering. Let $mcc(V_i, O)$ be the minimum cost of the parent sets of vertex $V_i$ that are consistent with ordering $O$. I need to find an ordering $O$ that minimizes the total cost: $mcc(V_1, O), \\dots ,mcc(V_n, O)$.</p>\n</blockquote>\n\n<p>I don\'t quite understand the part "...if all of the parents come before the vertex in the ordering." What does it mean?</p>\n', 'ViewCount': '94', 'Title': 'Need help understanding this optimization problem on graphs', 'LastEditorUserId': '1123', 'LastActivityDate': '2012-05-27T18:05:16.293', 'LastEditDate': '2012-05-27T18:05:16.293', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2104', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1556', 'Tags': '<algorithms><graph-theory><terminology><optimization>', 'CreationDate': '2012-05-27T07:00:31.647', 'Id': '2100''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There is a family of random graphs $G(n, p)$ with $n$ nodes (<a href="https://en.wikipedia.org/wiki/Random_graph">due to Gilbert</a>). Each possible edge is independently inserted into $G(n, p)$ with probability $p$. Let $X_k$ be the number of cliques of size $k$ in $G(n, p)$.</p>\n\n<p>I know that $\\mathbb{E}(X_k)=\\tbinom{n}{k}\\cdot p^{\\tbinom{k}{2}}$, but how do I prove it?</p>\n\n<p>How to show that $\\mathbb{E}(X_{\\log_2n})\\ge1$ for $n\\to\\infty$? And how to show that $\\mathbb{E}(X_{c\\cdot\\log_2n}) \\to 0$ for $n\\to\\infty$ and a fixed, arbitrary constant $c&gt;1$?</p>\n', 'ViewCount': '297', 'Title': 'Number of clique in random graphs', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-28T09:46:02.827', 'LastEditDate': '2012-05-28T09:46:02.827', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2119', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1393', 'Tags': '<graph-theory><combinatorics><probability-theory><random-graphs>', 'CreationDate': '2012-05-27T23:41:29.403', 'Id': '2118''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '630', 'Title': 'NP-Completeness of a Graph Coloring Problem', 'LastEditDate': '2012-06-26T21:18:06.560', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1672', 'FavoriteCount': '3', 'Body': '<p><strong>Alternative Formulation</strong></p>\n\n<p>I came up with an alternative formulation to the below problem. The alternative formulation is actually a special case of the problem bellow and uses bipartite graphs to describe the problem. However, I believe that the alternative formulation is still NP-hard. The alternative formulation uses a disjoint set of incoming and outgoing nodes that simplifies the problem definition.</p>\n\n<p>Given $n$ outgoing and $n$ incoming nodes (the red and blue nodes in the figure respectively), and a set $w_{ij}$\'s of size $n \\times n$ of edge weights between the outgoing and incoming vertices. The goal of the problem is to color the thick edges in the figure so that for every incoming node, a condition holds.</p>\n\n<p><img src="http://i.stack.imgur.com/CsXJr.png" alt="Bipartite graph of the problem"></p>\n\n<blockquote>\n  <p>Given a set $\\{ O_i \\; | \\; i=1 \\dots n \\}$ of output vertices, a set $\\{ I_i\\; | \\; i=1 \\dots n \\}$ of input vertices, $n \\times n$ weights\n  $w_{ij} \\ge 0$ between $O_i$\'s and $I_j$\'s for $i,j=1 \\dots n$, and a positive\n  constant $\\beta$, find the minimum number of colors for the edges\n  $e_{ii}$ (thick edges in the above figure) such that for all $j=1 \\dots n$,</p>\n  \n  <p>$$ \\frac{w_{jj}}{1+\\sum_{c(i)=c(j),i \\neq j} w_{ij}} \\ge \\beta $$</p>\n  \n  <p>where $c(i)$ shows the color of the edge $e_{ii}$.</p>\n</blockquote>\n\n<hr>\n\n<p><strong>Old Formulation</strong></p>\n\n<p>The following problem looks NP-hard to me, but I couldn\'t show it. Any proof/comment to show the hardness or easiness of it is appreciated.</p>\n\n<blockquote>\n  <p>Assume $K_n=\\langle V,E \\rangle$ is a complete weighted directed graph\n  with $n$ nodes and $n(n-1)$ edges. Let $w_{ij} \\ge 0$ show the weight\n  of the edge $ij$ and $c(ij)$ shows the color of edge $ij$. Given a subset\n  of the edges $T \\subseteq E$ and a positive constant $\\beta$ the goal is:\n  find the minimum number of colors such that for each $e_{ij} \\in T$:</p>\n  \n  <p>$$ \\frac{w_{ij}}{1+\\sum_{c(kl)=c(ij),kl \\neq ij} w_{kj}} \\ge \\beta. $$\n  and\n  $$ c(ij) \\neq c(ik) \\quad for \\quad j \\neq k $$</p>\n</blockquote>\n\n<p>Please note that in the above problem, only the edges in $T$ needs to be colored. That is the problem can be solved in $\\mathcal{O}(|T|!)$.</p>\n\n<p><strong>Update:</strong></p>\n\n<p>After Tsuyoshi Ito\'s comment I updated the problem. The denominator is changed from $1+\\sum_{c(kj)=c(ij),k \\neq i,e_{kj} \\in T} w_{kj}$ to $1+\\sum_{c(kl)=c(ij),kl \\neq ij} w_{kj}$. Therefore, the denominator contains the weights outside $T$ as well. That\'s actually why I mentioned the complete graph in the definition.</p>\n\n<p>I also added an additional constraint $c(ij) \\neq c(ik) \\quad for \\quad j \\neq k$. That means, the outgoing edges from a node must be of different colors (but the incoming colors can be the same as long as the inequality holds). This puts an intuitive lower bound on the number of colors, which is the maximum out-degree of the nodes in $T$.</p>\n\n<p>As Tsuyoshi mentioned, $w_{ij}$\'s, $T$, and $\\beta$ are inputs to the problem and the edge colors are the output.</p>\n\n<p><strong>Update 2:</strong></p>\n\n<p>Problem does not enforce the edges $e_{ij}$ and $e_{ji}$ be of a same color.</p>\n', 'Tags': '<complexity-theory><graphs><graph-theory><np-complete>', 'LastEditorUserId': '1672', 'LastActivityDate': '2012-07-10T23:58:44.517', 'CommentCount': '11', 'AcceptedAnswerId': '2687', 'CreationDate': '2012-05-29T08:27:39.603', 'Id': '2157''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a directed acyclic graph where edge (A,B) means that vertex A depends on vertex B. </p>\n\n<p>Vertex deletions have the following restrictions:</p>\n\n<ol>\n<li>When vertex B is removed, all dependent vertexes should also be removed. </li>\n<li>When vertex  A is removed and vertex A was the only vertex that depends on B, vertex B should also be removed.</li>\n</ol>\n\n<p><img src="http://i.stack.imgur.com/qeDQd.png" alt="enter image description here"></p>\n\n<p>I need to list the vertixes which are deleted when</p>\n\n<ol>\n<li><p>Vertex B is deleted. My solution is B, E and J because</p>\n\n<ul>\n<li>B -- deleted</li>\n<li>E -- because of condition 2, B is removed and B was the only vertex that depends on E</li>\n<li>J -- because of condition 2</li>\n</ul></li>\n<li><p>Vertex C is deleted. My solution is C, F, A, G, ... ?</p>\n\n<ul>\n<li>C -- deleted</li>\n<li>F -- because of condition 2 (C is the only vertex to F)</li>\n<li>A -- condition 1 (depends on C)</li>\n<li>G -- condition 2 (C is the only vertex to G)</li>\n<li>I think here the process goes on and cascades. Is that correct?</li>\n</ul></li>\n</ol>\n\n<p>What could be an algorithm for such vertexes dependency network which allows for the vertex deletion?</p>\n\n<p>PS: this is an old exam exercise (2008/09); I use it as exercise for my one middle of June.</p>\n', 'ViewCount': '454', 'Title': 'Dependency Graph - Acyclic graph', 'LastEditorUserId': '31', 'LastActivityDate': '2012-06-01T20:50:34.107', 'LastEditDate': '2012-06-01T08:54:17.570', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<algorithms><graphs><graph-theory>', 'CreationDate': '2012-06-01T07:35:22.473', 'Id': '2186''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For a given undirected graph $G$, a <a href="http://en.wikipedia.org/wiki/Gomory%E2%80%93Hu_tree" rel="nofollow">Gomory-Hu tree</a> is a graph which has the same nodes as $G$, but its edges represent the minimal cut between each pair of nodes in $G$. The Gomory-Hu algorithm finds such a tree for a graph. A representant pair of nodes is defined as follows: if $R$ and $S$ are two components of the Gomory-Hu tree, and there is an edge $e$ between them, then the nodes $r \\in R$ and $s \\in S$ are representants if the weight of the edge $(r,s)$ is the same as the weight of $e$. </p>\n\n<p>I have to learn not only the algorithm, but also all the lemmas needed to prove that it works. For this specific lemma, there is a proof given in my learning materials, but I am afraid I don\'t understand how it works. </p>\n\n<p>It starts by picking two components of the Gomory-Hu tree, $A$ and $B$, with an edge $h$ between them, $a \\in A$ and $b \\in B$ being the representants. In the next iteration, nodes $x$ and $y$ in $A$ are picked, and a new minimal $(x,y)$-cut is calculated (dividing $A$ into the subsets $X$ and $Y$), such that now $h$ connects $X$ and $B$. If $a \\in X$, then $a$ and $b$ are still representants. But if $a \\in Y$, the proof claims that $x$ and $b$ are the new representants of $h$. </p>\n\n<p>For this, it states that </p>\n\n<blockquote>\n  <p>The cut which created $h$ divides $x$ and $b$. From that, it follows that $f(x,b) \\le f(a,b)$. </p>\n</blockquote>\n\n<p>[It uses $f(a,b)$ to denote the flow in the minimal cut between nodes $a$ and $b$.] Then it goes on to prove that also $f(x,b) \\ge f(a,b)$. And then the two flows must be equal, so the flow between $x$ and $b$ is the same as the flow in the minimal $(a,b)$-cut, so $x$ and $b$ are representants. </p>\n\n<p>But as I understand the algorithm, the cut which created $h$ was a minimal cut between the nodes $a$ and $b$. The node $x$ wasn\'t even a special node at the time the graph was divided into components $A$ and B$.$ Yes, this cut happens to divide $x$ and $b$ too, but there is no guarantee that it is the minimal cut between $x$ and $b$ (this is exactly what we are trying to prove here). So I think that we can follow that $f(x,b) \\ge f(a,b)$, but not that $f(x,b) \\le f(a,b)$. I suspect that there is an error in my reasoning and not in the reasoning of the prof who wrote the learning materials, but where is it? </p>\n\n<p>And if there actually is an error in this proof, what is the correct proof? </p>\n', 'ViewCount': '79', 'Title': 'What is the proof for the lemma "For every iteration of the Gomory-Hu algorithm, there is a representant pair for each edge"?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-02T04:53:12.310', 'LastEditDate': '2012-06-02T04:53:12.310', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1717', 'Tags': '<algorithms><graph-theory><algorithm-analysis>', 'CreationDate': '2012-06-01T15:45:55.923', 'Id': '2189''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '535', 'Title': 'How can I prove that a complete binary tree has $\\lceil n/2 \\rceil$ leaves?', 'LastEditDate': '2012-06-02T00:54:30.613', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Luc Peetersen', 'PostTypeId': '1', 'OwnerUserId': '1722', 'FavoriteCount': '2', 'Body': "<p>Given a complete binary tree with $n$ nodes. I'm trying to prove that a complete binary tree has exactly $\\lceil n/2 \\rceil$ leaves.\nI think I can do this by induction.</p>\n\n<p>For $h(t)=0$, the tree is empty. So there are no leaves and the claim holds for an empty tree.</p>\n\n<p>For $h(t)=1$, the tree has 1 node, that also is a leaf, so the claim holds.\nHere I'm stuck, I don't know what to choose as induction hypothesis and how to do the induction step.</p>\n", 'Tags': '<data-structures><graph-theory><proof-techniques><combinatorics><binary-trees>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-06-02T05:41:15.503', 'CommentCount': '6', 'AcceptedAnswerId': '2196', 'CreationDate': '2012-06-01T21:08:05.543', 'Id': '2193''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If a weighted graph $G$ has two different minimum spanning trees $T_1 = (V_1, E_1)$ and $T_2 = (V_2, E_2)$, then is it true that for any edge $e$ in $E_1$, the number of edges in $E_1$ with the same weight as $e$ (including $e$ itself) is the same as the number of edges in $E_2$ with the same weight as $e$? If the statement is true, then how can we prove it?</p>\n', 'ViewCount': '1156', 'Title': 'Do the minimum spanning trees of a weighted graph have the same number of edges with a given weight?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-14T20:29:01.367', 'LastEditDate': '2012-06-02T23:23:48.057', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2211', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<graph-theory><spanning-trees><weighted-graphs>', 'CreationDate': '2012-06-02T22:25:00.557', 'Id': '2204''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1918', 'Title': 'Reducing minimum vertex cover in a bipartite graph to maximum flow', 'LastEditDate': '2012-11-09T11:07:26.610', 'AnswerCount': '2', 'Score': '7', 'OwnerDisplayName': 'Summer_More_More_Tea', 'PostTypeId': '1', 'OwnerUserId': '1727', 'FavoriteCount': '1', 'Body': '<p>Is it possible to show that the minimum vertex cover in a bipartite graph can be reduced to a maximum flow problem? Or to the minimum cut problem (then follow max-flow min-cut theorem, the claim holds).</p>\n\n<p>Intuitively: for each flow, pick one endpoint, then it is a minimum vertex cover in bipartite graph. But can it be shown rigorously?</p>\n', 'Tags': '<complexity-theory><graph-theory><reductions><network-flow>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-09T11:07:26.610', 'CommentCount': '0', 'CreationDate': '2012-06-03T02:37:49.540', 'Id': '2208''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose we have a graph G. How can we find a spanning tree that minimizes the maximum weight of all the edges in the tree? I am convinced that by simply finding an MST of G would suffice, but I am having a lot of trouble proving that my idea is actually correct. Can anyone show me a proof sketch or give me some hints as to how to construct the proof? Thanks!</p>\n', 'ViewCount': '991', 'Title': 'How to find spanning tree of a graph that minimizes the maximum edge weight?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-08T20:18:19.143', 'LastEditDate': '2012-06-04T23:30:42.360', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<algorithms><graph-theory><optimization>', 'CreationDate': '2012-06-04T16:24:30.567', 'Id': '2226''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was reading something about the concept of walks in a graph b/w a start vertex and a terminating vertex in a graph and then suddenly a problem struck me, is there any algorithm or a method that can be used to enumerate all the distinct walks from a start vertex to a terminal vertex in a graph, if so can you all point me to some relevant links to study this problem and what are some applications of solving this problem?</p>\n', 'ViewCount': '233', 'Title': 'Enumerating all the walks in a graph between a start vertex and a terminal vertex?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-09T03:44:41.467', 'LastEditDate': '2012-06-08T12:29:16.630', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'Coder', 'PostTypeId': '1', 'Tags': '<algorithms><reference-request><graph-theory>', 'CreationDate': '2012-06-05T13:10:08.960', 'FavoriteCount': '2', 'Id': '2274''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>We want to solve a minimal-cost-flow problem with a generic negative-cycle cancelling algorithm. That is, we start with a random valid flow, and then we do not pick any "good" negative cycles such as minimal average cost cycles, but use Bellman-Ford to discover a minimal cycle and augment along the discovered cycle. Let $V$ be the number of nodes in the graph, $A$ the number of edges, $U$ the maximal capacity of an edge in the graph, and $W$ the maximal costs of an edge in the graph. Then, my learning materials claim: </p>\n\n<ul>\n<li>The maximal costs at the beginning can be no more than $AUW$ </li>\n<li>The augmentation along one negative cycle reduces the costs by at least one unit </li>\n<li>The lower bound for the minimal costs is 0, because we don\'t allow negative costs </li>\n<li>Each negative cycle can be found in $O(VA)$ </li>\n</ul>\n\n<p>And they follow from it that the algorithm\'s complexity is $O(V\xb2AUW)$. I understand the logic behind each of the claims, but think that the complexity is different. Specifically, the maximal number of augmentations is given by one unit of flow per augmentation, taking the costs from $AUW$ to zero, giving us a maximum of $AUW$ augmentations. We need to discover a negative cycle for each, so we multiply the maximal number of augmentations by the time needed to discover a cycle ($VA$) and arrive at $O(A\xb2VUW)$ for the algorithm. </p>\n\n<p>Could this be an error in the learning materials (this is a text provided by the professor, not a student\'s notes from the course), or is my logic wrong? </p>\n', 'ViewCount': '258', 'Title': u'Why is the complexity of negative-cycle-cancelling $O(V\xb2AUW)$?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-06T00:47:27.197', 'LastEditDate': '2012-06-10T11:42:45.650', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1717', 'Tags': '<algorithms><graph-theory><algorithm-analysis><runtime-analysis><network-flow>', 'CreationDate': '2012-06-08T13:26:38.437', 'FavoriteCount': '1', 'Id': '2283''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am interested in the complexity of the restricted version of the vertex cover problem below:</p>\n\n<blockquote>\n  <p><strong>Instance:</strong> A bipartite graph $G =(L, R, E)$ and an integer $K$.</p>\n  \n  <p><strong>Question:</strong> Is there $S \\subset L$, $|S| \\leq K$ and every vertex in $R$ has a neighbor in $S$ $( S$ is vertex cover for $R)$</p>\n</blockquote>\n\n<p>Vertex cover is $\\mathsf{P}$ if $S \\subset L \\cup R$ and cover $L \\cup R$; and it is $\\mathsf{NP}$-complete for nonbipartite graphs. However, the problem I am looking at does not fit in either cases. Any pointers where I could find an answer will be appreciated.</p>\n', 'ViewCount': '215', 'Title': 'Restricted version of vertex cover', 'LastActivityDate': '2012-06-15T08:56:53.127', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'hbm', 'PostTypeId': '1', 'Tags': '<complexity-theory><algorithms><graph-theory>', 'CreationDate': '2012-06-09T12:55:36.820', 'FavoriteCount': '1', 'Id': '2302''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As the title says, has anyone found a polynomial time algorithm for checking whether two graphs having a Hamiltonian cycle are isomorphic? Is this problem NP-complete?</p>\n', 'ViewCount': '306', 'Title': 'Has anyone found polynomial algorithm on Hamiltonian cycle isomorphism?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:06:12.337', 'LastEditDate': '2013-05-24T03:06:12.337', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1866', 'Tags': '<complexity-theory><graph-theory><time-complexity>', 'CreationDate': '2012-06-15T15:28:43.047', 'FavoriteCount': '0', 'Id': '2383''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2302/restricted-version-of-vertex-cover">Restricted version of vertex cover</a>  </p>\n</blockquote>\n\n\n\n<p>Suppose we have a $(A,B,E)$ bipartite graph and a positive integer k. Suppose that k is smaller than $|A|$ and we want to find one of those k element subsets of $A$ which covers the most points from $B$. I can only come up wirh exponential algorithms. Is this in $P$?</p>\n\n<p>Also is mixed integer programming for maximal flows in $P$? It can be easily formulated as such.</p>\n', 'ViewCount': '36', 'ClosedDate': '2012-06-22T09:32:51.747', 'Title': 'constrained cover on biparite graphs', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-25T17:24:17.437', 'LastEditDate': '2012-06-25T17:24:17.437', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1931', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-06-21T21:36:08.990', 'Id': '2444''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can I prove that the cover time for a directed graph G can be exponential in the size of G?</p>\n', 'ViewCount': '161', 'Title': 'Prove: cover time for directed graph is exponential', 'LastEditorUserId': '472', 'LastActivityDate': '2013-01-27T02:51:16.120', 'LastEditDate': '2013-01-27T02:51:16.120', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1402', 'Tags': '<algorithms><graph-theory><random-walks>', 'CreationDate': '2012-06-22T12:29:32.200', 'Id': '2449''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I have been investigating parallel algorithms to compute certain two-dimensional dynamic programming recursions (on natural parameters); see also <a href="http://cs.stackexchange.com/questions/196/a-case-distinction-on-dynamic-programming-example-needed">here</a>. Under certain assumptions, cases one and two can actually be computed in parallel -- and very well. However, if you assume that communicating array entries from one thread to another is more expensive than a normal memory access (as might be the case on real machines), these algorithms are no longer always strongly work-efficient\xb9. In fact, I conjecture that in this scenario there is no strongly work-efficient parallel algorithm general for these classes of problems, even if we consider only non-pathological recursions.</p>\n\n<p>Towards proving this, I have made the following abstraction for the domain and parallel algorithms. Note that I assume here that such algorithms allocate computations of individual entries to processors in a deterministic way; I do not think the result changes if we allow nondeterminism/randomisation in this regard, but I have no proof.</p>\n\n<blockquote>\n  <p>Let $G_n = (V_n, \\emptyset)$ with $V_n = \\{(i,j) \\mid 1 \\leq i,j \\leq n \\}$ be a family of empty $n\\times n$ grid graphs. Let furthermore $c : \\mathbb{N} \\to (V_n \\to \\{1,\\dots,p\\})$ a coloring for this family which asymptotically divides $V_n$ in equal parts, that is</p>\n  \n  <p>$\\qquad \\displaystyle |\\{v \\in V_n \\mid c(n)(v) = c_i\\}| \\underset{n \\to \\infty}{\\longrightarrow} \\frac{n^2}{p}$</p>\n  \n  <p>for all colors $c_i \\in \\{1,\\dots,p\\}$.</p>\n</blockquote>\n\n<p>The claim is that we can choose edges so that we create no circles and no node has more than linearly many incoming edges, but there are quadratically many edges whose nodes have different colors\xb2:</p>\n\n<blockquote>\n  <p>(For any such coloring, ) There is a family of sets of directed edges $E_n = V_n \\times V_n$ so that</p>\n  \n  <ul>\n  <li>$((i,j), (i\',j\')) \\in E_n \\ \\Longrightarrow i\' \\geq i \\land j\' \\geq j$, that is edges do not point up or left\xb3,</li>\n  <li>for all $n \\in \\mathbb{N}$, $(V_n,E_n)$ has no directed cycles,</li>\n  <li>$D_n := \\max_{u \\in V_n} \\operatorname{indeg}(u) \\in O(n)$ and</li>\n  <li>$C_n := |\\{(u,v) \\in E_n \\mid c(n)(u) \\neq c(n)(v) \\}| \\in \\Omega(n^2)$.</li>\n  </ul>\n</blockquote>\n\n<p>Is this (similar to) a known problem? Does it hold, and how can you (dis)prove it?</p>\n\n<hr>\n\n<h3>Example</h3>\n\n<p>Consider this coloring (which roughly corresponds to an algorithm I have investigated):</p>\n\n<p><img src="http://i.stack.imgur.com/UclTl.png" alt="example coloring"><br>\n<sup>[<a href="https://github.com/akerbos/sesketches/blob/gh-pages/src/cs_2452.tikz" rel="nofollow">source</a>]</sup></p>\n\n<p>For edges as implied by the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow">Levenshtein distance</a> recursion, that is</p>\n\n<p>$\\qquad \\displaystyle E_n = \\bigcup_{1 \\leq i,j \\leq n}\\{(i,j)\\} \\times \\{(i-1,j), (i-1,j-1), (i,j-1) \\} \\cap \\{1,\\dots,n\\}^2$,</p>\n\n<p>we have $D_n = 3$ and $C_n = 8n-4$, so this is not the $E_n$ we are looking for. If we draw edges from every node to all others to its right, that is</p>\n\n<p>$\\qquad \\displaystyle E_n = \\{ ((i,j),(i,j\')) \\mid j\' &gt; j \\}$,</p>\n\n<p>we get $D_n = n-1$ and $C_n \\geq \\frac{3}{4}n^2$, so the coloring is defeated.</p>\n\n<hr>\n\n<ol>\n<li>"Strongly work-efficient" means here that the parallel algorithm on $p \\in \\mathbb{N}$ cores does not take more time than $\\frac{T^s}{p}$ in the limit, with $T^s$ the runtime of a (good) sequential algorithm.</li>\n<li>That corresponds to a not-too-dense dependency structure of a recursion\'s domain which causes the parallel algorithm to communicate too many results between threads.</li>\n<li>That corresponds to <a href="http://cs.stackexchange.com/questions/196/a-case-distinction-on-dynamic-programming-example-needed">case one</a>. Case two can be modelled similarly by requiring $i\' &gt; i$.</li>\n</ol>\n', 'ViewCount': '102', 'Title': 'Beating fair colorings with few edges', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:41:16.777', 'LastEditDate': '2014-01-20T08:41:16.777', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<graph-theory><colorings>', 'CreationDate': '2012-06-22T17:04:27.403', 'FavoriteCount': '1', 'Id': '2452''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '131', 'Title': 'Efficient bandwidth algorithm', 'LastEditDate': '2012-06-25T13:00:38.987', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1289', 'FavoriteCount': '0', 'Body': "<p>Recently I sort of stumbled on a problem of finding an efficient topology given a weighted directed graph. Consider the following scenario:</p>\n\n<ol>\n<li><p>Node 1 is connected to 2,3,4 at 50 Mbps. Node 1 has 100 Mbps network card.</p></li>\n<li><p>Node 3 is connected to 5 at 50 Mbps. Node 3 has 100 Mbps card.</p></li>\n<li><p>Node 4 is connected to Node 3 at 40 Mbps. Node 4 has 100 Mbps card.</p></li>\n</ol>\n\n<p>(Sorry about not having a picture)</p>\n\n<p>Problem: If Node 1 starts sending data to its immediate nodes (2 and 3), we can clearly see it's network card capacity will be drained out after Node 3. Whereas if it were to <em>skip</em> node 3 and start sending to node 4, the data will eventually reach to node 3 via 4 and hence, node 5 will be getting data via node 3.\nThe problem becomes more complicated if all the links were of 50 Mbps and we can clearly see that node 2 and node 4 are the only way to reach all nodes.</p>\n\n<p>Question: Is there an algorithm which gives the optimal path to ALL nodes keeping the network (card) capacity in mind? </p>\n\n<p>I read the shortest path algorithm,max flow algorithms but none of them seem to address my problems. perhaps,im missing something. I'll appreciate if someone can help me out.</p>\n", 'Tags': '<algorithms><graph-theory><optimization><linear-programming>', 'LastEditorUserId': '29', 'LastActivityDate': '2012-06-25T13:00:38.987', 'CommentCount': '2', 'AcceptedAnswerId': '2480', 'CreationDate': '2012-06-24T15:25:59.813', 'Id': '2470''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Most books explain the reason the algorithm doesn't work with negative edges as nodes are deleted from the priority queue after the node is arrived at since the algorithm assumes the shortest distance has been found. However since negative edges can reduce the distance, a future shorter distance might be found; but since the node is deleted it cannot be updated.</p>\n\n<p>Wouldn't an obvious solution to this be to <em>not delete the node</em>? Why not keep the node in the queue, so if a future <em>shorter</em> distance is found, it can be updated? If I am misunderstanding the problem, what <em>is</em> preventing the algorithm from being used with negative edges?</p>\n", 'ViewCount': '4441', 'Title': "Using Dijkstra's algorithm with negative edges?", 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T02:00:29.480', 'LastEditDate': '2012-06-25T17:22:17.767', 'AnswerCount': '4', 'CommentCount': '9', 'Score': '4', 'OwnerDisplayName': 'user1422', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2012-06-24T03:13:44.967', 'Id': '2482''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose we have a directed graph $G=(V,E)$ and two nodes $A$ and $B$.\nI would like to know if there are already algorithms for calculating the following decision problem: </p>\n\n<blockquote>\n  <p>Are there at least two paths between $A$ and $B$ of the same length?</p>\n</blockquote>\n\n<p>How about the complexity? Can I solve it in polynomial time?</p>\n\n<hr>\n\n<p>I would like to add a new constrain on the graph, maybe the problem is more solvable.\nOn adjacency matrix, every column is not empty. So, every node has at least one arrow on input and there is also at least one node connected to itself. So if the node is the $i$-th node, then $(i,i)$ is an edge in the graph.</p>\n', 'ViewCount': '363', 'Title': 'Finding at least two paths of same length in a directed graph', 'LastEditorUserId': '1974', 'LastActivityDate': '2012-07-03T20:59:07.823', 'LastEditDate': '2012-06-27T16:49:56.487', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '17', 'PostTypeId': '1', 'OwnerUserId': '1974', 'Tags': '<complexity-theory><graph-theory><time-complexity><graphs>', 'CreationDate': '2012-06-26T12:12:27.963', 'FavoriteCount': '6', 'Id': '2498''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I have a directed weighted graph $G = (V, E, W)$. There is always an edge from a vertex $i$ to another one $j$, the weight $w(i,j)$ could be positive infinity, and there does not exist any negative cycle. </p>\n\n<p>An execution of some algorithms will find the lengths (summed weights) of the shortest paths between all pairs of vertices though it does not return details of the paths themselves. For instance, <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">Floyd\u2013Warshall algorithm</a> is straightforward, and it works. Let us denote the result by $G\' = (V, E, W\')$.</p>\n\n<p>In $G\'$, it is possible that for an edge from $i$ to $j$, $w\'(i,j) = w\'(i, k_0) + w\'(k_0, k_1) + \\dots + w\'(k_n, j)$. Let us make from $G\'$ another graph $G\'\'$ whose any element is same as $G\'$ except $w\'\'(i,j) = \\infty \\neq w\'(i,j)$. Therefore we know that an execution of a shortest paths algorithm on $G\'\'$ will give $G\'$.</p>\n\n<p>So given a $G\'$, I would like to find all the graphs like $G\'\'$, such that for all $i$ and $j$, $w\'\'(i,j) \\in \\{ w\'(i,j), \\infty\\}$, and $G\'\'$ can be reduced to $G\'$ via a shortest paths algorithm.</p>\n\n<p>Hope my question is clear... I do not know if an algorithm for this exists already, does anyone have any idea?</p>\n', 'ViewCount': '71', 'Title': 'Find all the special graphs which can reduced to the shortest paths graph', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T13:50:18.340', 'LastEditDate': '2012-06-27T13:02:58.253', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'SoftTimur', 'PostTypeId': '1', 'OwnerUserId': '5008', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2011-12-26T05:19:48.980', 'Id': '2511''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm writing a small function to alter a graph in a certain way and was wondering if there is a formal name for the operation.  The operation takes two distinct edges, injects a new node between the existing nodes of each edge and then adds an edge between the two new nodes.  For example:</p>\n\n<pre><code>add new nodes a and b to the graph\nlet edge1 = (x,y), let edge2 = (u,v)\n\ndelete edge (x,y)\ncreate edges (x,a), (a,y)\n\ndelete edge(u,v)\ncreate edges(u,b), (b,v)\n\ncreate edge (a,b)\n</code></pre>\n", 'ViewCount': '357', 'Title': 'Is there a formal name for this graph operation?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-08-19T11:01:51.283', 'LastEditDate': '2013-07-20T09:19:50.287', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1989', 'Tags': '<graph-theory><terminology><combinatorics>', 'CreationDate': '2012-06-27T18:48:30.197', 'Id': '2517''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for an algorithm, which given a graph $G$ and a natural number $t$, determines if $G$ is <a href="http://en.wikipedia.org/wiki/Symmetric_graph">$t$-transitive</a>.</p>\n\n<p>I am also interested in knowing if this problem is in P, NP, NPC or some other interesting facts about its complexity class.</p>\n', 'ViewCount': '105', 'Title': 'Algorithm to test a graph for $t$-transitivity', 'LastEditorUserId': '1350', 'LastActivityDate': '2012-07-01T19:45:15.080', 'LastEditDate': '2012-06-28T13:52:50.560', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1350', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-06-28T12:59:46.923', 'Id': '2527''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '110', 'Title': 'Proof of NP-completeness of graph isomorphism through edge contractions that reduce a metric', 'LastEditDate': '2013-10-08T10:13:01.373', 'AnswerCount': '0', 'Score': '4', 'OwnerDisplayName': 'Yinfang Zhuang', 'PostTypeId': '1', 'FavoriteCount': '0', 'Body': '<blockquote>\n  <p><strong>Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/2634/np-completeness-or-not">NP-completeness of graph isomorphism through edge contractions with an edge validity condition</a>  </p>\n</blockquote>\n\n\n\n<p>I know that graph contractability is $NP$-complete. To be specific given $G=(V_1,E_1)$ and $H=(V_2,E_2)$, can a graph isomorphic to H be obtained from G by a sequence of edge contractions ?</p>\n\n<p>However my problem is a little bit different from the traditional graph contractability. In the traditional graph contractability problem we contract the original graph by different sequences of edge mergings. However in my problem each node is associated with some metric. At each step only a subset of edges are candidates for contracting or merging. Contracting one edge may affect the subset of edges that are legal for contracting at next step. By contracting one edge, we also replace the metrics of the two endpoint nodes with a new smaller metric. We are trying to find an H such that the sum of the metrics of nodes in H is minimal. </p>\n\n<p>Any hint on whether this problem is $NP$-hard($NP$-complete) or not. If so any hint on how to prove it ?</p>\n\n<p><strong>Here are more descriptions: Each node has a 0/1-string label. We define a function to measure the similarity between two labels of the adjacent nodes(i.e. the length of the common prefix of the two labels). At each step only the two adjacent nodes with maximal similarity can be merged (there may be several of them). After we merge the two nodes we label the new node with the common prefix of the original two labels. We also have to preserve the uniqueness of the label. We do no merge if it violates uniqueness of labels. We add up the length of the label of each node in the final graph and try to find the minimum of this number. Or in a more abstract sense, Is labeled graph G contractible (while maintaining our needed invariants e.g. uniqueness of labels) to (given) labeled graph H ?</strong></p>\n', 'ClosedDate': '2012-07-09T09:29:20.120', 'Tags': '<graph-theory><graphs><np-complete>', 'LastEditorUserId': '917', 'LastActivityDate': '2013-10-08T10:13:01.373', 'CommentCount': '5', 'CreationDate': '2012-06-30T15:25:26.993', 'Id': '2573''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a <a href="https://en.wikipedia.org/wiki/Cactus_graph" rel="nofollow">cactus</a>, we want to weight its edges in such a way that</p>\n\n<ol>\n<li>For each vertex, the sum of the weights of edges incident to the vertex is no more than 1.</li>\n<li>The sum of all edge weights is maximized.</li>\n</ol>\n\n<p>Clearly the answer is no more than $\\frac{n}{2}$ for $n$ vertices ($\\sum d_i = 2D$ where $d_i$ is the sum for one vertex and $D$ is the sum over every edge). This bound is achievable for cycle graphs by weighting each edge 1/2.</p>\n\n<p>I found a greedy algorithm for trees. Just assign 1 to edges incident to leaves and remove them and their neighbors from the graph in repeated passes. This prunes the cactus down to a bunch of interconnected cycles. At this point I assumed the remaining cycles were not interconnected and weighted each edge 1/2. This got 9/10 test cases but is, of course, incomplete.</p>\n\n<p>So, how might we solve this problem for cacti in general? I would prefer hints to full solutions, but either is fine.</p>\n\n<p><sub>\nThis question involves a problem from <a href="https://genesys.interviewstreet.com" rel="nofollow">an InterviewStreet CompanySprint</a>. I already competed but I\'d like some thoughts on a problem (solutions aren\'t released, and I\'ve been banging my head against the wall over this problem).\n</sub></p>\n', 'ViewCount': '265', 'Title': 'Balanced weighting of edges in cactus graph', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-04T21:47:55.087', 'LastEditDate': '2012-07-04T21:47:55.087', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2038', 'Tags': '<algorithms><graph-theory><greedy-algorithms>', 'CreationDate': '2012-07-03T16:09:43.020', 'FavoriteCount': '1', 'Id': '2598''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have read that the degree of nodes in a "knowledge" graph of people roughly follows a power law distribution, and more exactly can be approximated with a Pareto-Lognormal distribution.</p>\n\n<p>Where can I find a kind of algorithm that will produce a random graph with this distribution?</p>\n\n<p>See for example the paper <a href="http://www.cs.ucsb.edu/~alessandra/papers/ba048f-sala.pdf" rel="nofollow">Revisiting Degree Distribution Models for Social Graph Analysis</a> (page 4, equation 1) for a mathematical description (distribution function) of the kind of distribution I\'m interested in.</p>\n', 'ViewCount': '226', 'Title': 'How to random-generate a graph with Pareto-Lognormal degree nodes?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T04:40:16.137', 'LastEditDate': '2012-07-05T07:42:21.527', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2808', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2060', 'Tags': '<algorithms><graph-theory><probability-theory><randomness>', 'CreationDate': '2012-07-04T11:43:54.893', 'Id': '2608''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '2349', 'Title': 'Prove that every two longest paths have at least one vertex in common', 'LastEditDate': '2012-07-17T06:12:37.340', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': '<p>If a graph $G$ is connected and has no path with a length greater than $k$, prove that every two paths in $G$ of length $k$ have at least one vertex in common.  </p>\n\n<p>I think that that common vertex should be in the middle of both the paths. Because if this is not the case then we can have a path of length $&gt;k$. Am I right?</p>\n', 'Tags': '<graph-theory><graphs><combinatorics>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T06:12:37.340', 'CommentCount': '5', 'AcceptedAnswerId': '2622', 'CreationDate': '2012-07-04T16:17:48.280', 'Id': '2615''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Semi clustering algorithm is mentioned in the <a href="http://people.apache.org/~edwardyoon/documents/pregel.pdf" rel="nofollow">Google Pregel paper</a>. The score of a semi cluster is calculated using the below formula</p>\n\n<p>$\\qquad \\displaystyle S_c =\\frac{I_c - f_BB_c}{\\frac{1}{2}V_c(V_c - 1)}$</p>\n\n<p>where</p>\n\n<ul>\n<li>$I_c$ is sum of the weights of all the internal edges,</li>\n<li>$B_c$ is the sum of the weights of all the boundary edges,</li>\n<li>$V_c$ is the number of edges in the semi cluster and</li>\n<li>$f_b$ is the boundary edge score factor (user defined between 0 and 1).</li>\n</ul>\n\n<p>The algorithm is pretty straight forward, but I could not understand how the above formula was derived. Note that the denominator is the number of edges possible between $V_c$ number of vertices.</p>\n\n<p>Could someone please explain it?</p>\n', 'ViewCount': '94', 'Title': 'What is the significance of the semi clustering formula in the Google Pregel paper?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-05T21:43:57.403', 'LastEditDate': '2012-07-05T08:03:25.720', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2074', 'Tags': '<algorithms><graph-theory><terminology>', 'CreationDate': '2012-07-05T02:48:54.200', 'Id': '2621''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '202', 'Title': 'Is it possible to always construct a hamiltonian path on a tournament graph by sorting?', 'LastEditDate': '2012-07-09T09:07:50.400', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2105', 'FavoriteCount': '1', 'Body': '<p>Is it possible to always construct a hamiltonian path on a <a href="http://en.wikipedia.org/wiki/Tournament_%28graph_theory%29#Paths_and_cycles" rel="nofollow">tournament graph</a> $G=(V,E)$ by sorting (using any sorting algorithm) with the following total order:</p>\n\n<p>$\\qquad \\displaystyle a \\leq b \\iff (a,b) \\in E \\lor \\left(\\exists\\, c \\in V. a \\leq c \\land c \\leq b\\right)$</p>\n\n<p>For context, this came from an observation that the inductive construction in the above page seems to be equivalent to insertion sort using the given order. Is it possible to use other sorting algorithms?</p>\n', 'Tags': '<algorithms><graph-theory><sorting>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-21T22:52:26.573', 'CommentCount': '2', 'AcceptedAnswerId': '2652', 'CreationDate': '2012-07-08T04:56:49.143', 'Id': '2646''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1096', 'Title': 'Is finding the longest path of a graph NP-complete?', 'LastEditDate': '2012-07-17T13:39:12.770', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2114', 'FavoriteCount': '1', 'Body': '<p>The problem of finding the largest subgraph of a graph that has a Hamiltonian path can be restated as finding the longest path of a graph. Is this NP-complete? Also, is finding the $k$-length path of a graph NP-complete? Is it still NP-complete if we require the path to visit a given vertex?</p>\n', 'Tags': '<complexity-theory><graph-theory><np-complete>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-17T13:39:12.770', 'CommentCount': '0', 'AcceptedAnswerId': '2662', 'CreationDate': '2012-07-09T22:48:06.693', 'Id': '2660''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider the set of graphs in which the maximum degree of the vertices is a constant number $\\Delta$ independent of the number of vertices. Is the vertex coloring problem (that is, color the vertices with minimum number of colors such that no pair of adjacent nodes have the same color) on this set still NP-hard? Why?</p>\n', 'ViewCount': '92', 'Title': 'Vertex coloring with an upper bound on the degree of the nodes', 'LastActivityDate': '2012-07-17T14:39:49.543', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2692', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1672', 'Tags': '<algorithms><complexity-theory><graph-theory><graphs><np-complete>', 'CreationDate': '2012-07-11T10:26:02.150', 'Id': '2690''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a directed graph $G$ and two nodes $s,t$, decide whether there is some node $s\'$ such that $s\'$ is reachable from $s$ while $t$ is <em>not</em> reachable from $s\'$.</p>\n\n<p>I am wondering whether this problem is in <a href="https://en.wikipedia.org/wiki/NL_%28complexity%29" rel="nofollow">NL</a>.</p>\n', 'ViewCount': '99', 'Title': 'Is finding dead-end nodes in NL?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-17T16:21:00.543', 'LastEditDate': '2012-07-17T16:21:00.543', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2711', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1236', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2012-07-12T15:10:19.257', 'Id': '2710''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is there any formal definition about the average height of a binary tree?</p>\n\n<p>I have a tutorial question about finding the average height of a binary tree using the following two methods:</p>\n\n<ol>\n<li><p>The natural solution might be to take the average length of all possible\npaths from the root to a leaf, that is</p>\n\n<p>$\\qquad \\displaystyle \\operatorname{avh}_1(T) = \\frac{1}{\\text{# leaves in } T} \\cdot \\sum_{v \\text{ leaf of } T} \\operatorname{depth}(v)$.</p></li>\n<li><p>Another option is to define it recursively, that is the average height for a node is the average over the average heights of the subtrees plus\none, that is </p>\n\n<p>$\\qquad \\displaystyle \\operatorname{avh}_2(N(l,r)) = \\frac{\\operatorname{avh}_2(l) + \\operatorname{avh}_2(r)}{2} + 1$</p>\n\n<p>with $\\operatorname{avh}_2(l) = 1$ for leafs $l$ and $\\operatorname{avh}_2(\\_) = 0$ for empty slots.</p></li>\n</ol>\n\n<p>Based on my current understanding, for example the average height of the tree $T$</p>\n\n<pre><code>    1    \n   / \\\n  2   3\n /\n4\n</code></pre>\n\n<p>is $\\operatorname{avh}_2(T) = 1.25$ by the second method, that is using recursion.</p>\n\n<p>However, I still don't quite understand how to do the first one. $\\operatorname{avh}_1(T) = (1+2)/2=1.5$ is not correct.</p>\n", 'ViewCount': '825', 'Title': 'What is the average height of a binary tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-22T09:42:41.200', 'LastEditDate': '2012-07-22T09:42:37.330', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '2859', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1895', 'Tags': '<graph-theory><terminology><combinatorics><binary-trees>', 'CreationDate': '2012-07-16T13:55:13.860', 'Id': '2762''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know why and how the <a href="https://en.wikipedia.org/wiki/Push-relabel_algorithm" rel="nofollow">push relabel algorithm</a> works for solving the max-flow problem. But why is a global update step required? </p>\n', 'ViewCount': '224', 'Title': 'Reason for global update steps in the push-relabel algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-20T15:50:51.657', 'LastEditDate': '2012-07-20T15:50:51.657', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'user997704', 'PostTypeId': '1', 'OwnerUserId': '2212', 'Tags': '<algorithms><graph-theory><network-flow>', 'CreationDate': '2012-07-18T09:27:04.577', 'Id': '2819''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am not sure I see it. From what I understand, edges and vertices are complements for each other and it is quite surprising that this difference exists.</p>\n\n<p>Is there a good / quick / easy way to see that in fact finding a Hamiltonian path should be much harder than finding a Euler path?</p>\n', 'ViewCount': '332', 'Title': 'Is it intuitive to see that finding a Hamiltonian path is not in P while finding Euler path is?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-24T06:14:09.933', 'LastEditDate': '2012-07-21T05:02:56.917', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '2839', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1558', 'Tags': '<complexity-theory><graph-theory><np-complete><intuition>', 'CreationDate': '2012-07-20T08:16:19.113', 'Id': '2837''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '209', 'Title': 'Greedy choice and matroids (greedoids)', 'LastEditDate': '2012-07-20T14:19:38.057', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2220', 'FavoriteCount': '3', 'Body': '<p>As I was going through the material about the greedy approach, I came to know that a knowledge on matroids (greedoids) will help me approaching the problem properly. After reading about matroids I have roughly understood what matroids are. But how do you use the concept of a matroid for solving a given optimisation problem? </p>\n\n<p>Take, for example, the <a href="https://en.wikipedia.org/wiki/Activity_selection_problem" rel="nofollow">activity selection problem</a>. What are the steps to use matroid theory for solving the problem?</p>\n', 'Tags': '<algorithms><graph-theory><greedy-algorithms>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-20T14:23:46.633', 'CommentCount': '2', 'AcceptedAnswerId': '2841', 'CreationDate': '2012-07-20T09:34:21.970', 'Id': '2840''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '464', 'Title': 'Standard or Top Text on Applied Graph Theory', 'LastEditDate': '2012-07-23T07:12:08.633', 'AnswerCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1022', 'FavoriteCount': '3', 'Body': '<p>I am looking for a reference text on applied graph theory and graph algorithms.  Is there a standard text used in most computer science programs?  If not, what are the most respected texts in the field? I have Cormen et al.</p>\n', 'Tags': '<algorithms><graph-theory><reference-request><education><books>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T05:17:04.987', 'CommentCount': '6', 'AcceptedAnswerId': '2911', 'CreationDate': '2012-07-20T20:50:07.910', 'Id': '2845''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve been studying the three and I\'m stating my inferences from them below. Could someone tell me if I have understood them accurately enough or not? Thank you.</p>\n\n<ol>\n<li><p><a href="https://en.wikipedia.org/wiki/Dijkstra_algorithm" rel="nofollow">Dijkstra algorithm</a> is used only when you have a single source and you want to know the smallest path from one node to another, but fails in cases like <a href="http://i.stack.imgur.com/rmowk.png" rel="nofollow">this</a>.</p></li>\n<li><p><a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">Floyd-Warshall algorithm</a> is used when any of all the nodes can be a source, so you want the shortest distance to reach any destination node from any source node. This only fails when there are negative cycles.</p></li>\n<li><p><a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm" rel="nofollow">Bellman-Ford</a> is used like Dijkstra, when there is only one source. This can handle negative weights and its working is the same as Floyd-Warshall except for one source, right? (This is the one I am least sure about.)</p></li>\n</ol>\n', 'ViewCount': '1458', 'Title': 'Am I right about the differences between Floyd-Warshall, Dijkstra and Bellman-Ford algorithms?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-29T19:58:24.517', 'LastEditDate': '2012-07-29T13:58:33.600', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'Programming Noob', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-07-28T21:07:40.740', 'FavoriteCount': '1', 'Id': '2942''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In the general case finding a Maximum Independent Subset of a Graph is NP-Hard.</p>\n\n<p>However consider the following subset of graphs:</p>\n\n<ul>\n<li>Create an $N \\times N$ grid of unit square cells.</li>\n<li>Build a graph $G$ by creating a vertex corresponding to every cell.  Notice that there are $N^2$ vertices.</li>\n<li>Create an edge between two vertices if their cells share a side.  Notice there are $2N(N-1)$ edges.</li>\n</ul>\n\n<p>A Maximum Independent Subset of $G$ is obviously a checker pattern.  A cell at the $R$th row and $C$th column is part of it if $R+C$ is odd.</p>\n\n<p>Now we create a graph $G'$ by copying $G$ and removing some vertices and edges.  (If you remove a vertex also remove all edges it ended of course. Also note you can remove an edge without removing one of the vertices it ends.)</p>\n\n<p>By what algorithm can we find a Maximum Independent Subset of $G'$?</p>\n", 'ViewCount': '331', 'Title': 'Maximum Independent Subset of 2D Grid Subgraph', 'LastEditorUserId': '39', 'LastActivityDate': '2012-08-23T11:58:45.633', 'LastEditDate': '2012-08-03T20:24:34.503', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '3301', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1577', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-08-03T16:23:56.503', 'Id': '3022''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m trying to find the Maximum Independent Set of a Biparite Graph.</p>\n\n<p>I found this in some notes <strong>"May 13, 1998 - University of Washington - CSE 521 - Applications of network flow"</strong>:</p>\n\n<blockquote>\n  <p><strong>Problem:</strong></p>\n  \n  <p>Given a bipartite graph $G = (U,V,E)$, find an independent set $U\' \\cup V\'$ which is as large as possible, where $U\' \\subseteq U$ and $V\'\n&gt; \\subseteq V$. A set is independent if there are no edges of $E$ between\n  elements of the set.</p>\n  \n  <p><strong>Solution:</strong></p>\n  \n  <p>Construct a flow graph on the vertices $U \\cup B \\cup \\{s,t\\}$. For\n  each edge $(u,v) \\in E$ there is an infinite capacity edge from $u$ to\n  $v$. For each $u \\in U$, there is a unit capacity edge from $s$ to $u$,\n  and for each $v \\in V$, there is a unit capacity edge from $v$ to\n  $t$.</p>\n  \n  <p>Find a finite capacity cut $(S,T)$, with $s \\in S$ and $t \\in T$. Let\n  $U\' = U \\cap S$ and $V\' = V \\cap T$. The set $U\' \\cup V\'$ is\n  independent since there are no infinite capacity edges crossing the\n  cut.  The size of the cut is $|U - U\'| + |V - V\'| = |U| + |V| - |U\' \\cup V\'|$. This, in order to make the independent set as large as\n  possible, we make the cut as small as possible.</p>\n</blockquote>\n\n<p>So lets take this as the graph:</p>\n\n<pre><code>A - B - C\n    |\nD - E - F\n</code></pre>\n\n<p>We can split this into a bipartite graph as follows $(U,V)=(\\{A,C,E\\},\\{B,D,F\\})$</p>\n\n<p>We can see by brute force search that the sole Maximum Independent Set is $A,C,D,F$. Lets try and work through the solution above:</p>\n\n<p>So the constructed flow network adjacency matrix would be:</p>\n\n<p>$$\\begin{matrix}\n      &amp; s &amp; t &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F \\\\\n    s &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\\\\n    t &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\\\\n    A &amp; 1 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n    B &amp; 0 &amp; 1 &amp; \\infty &amp; 0 &amp; \\infty &amp; 0 &amp; \\infty &amp; 0 \\\\\n    C &amp; 1 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\\n    D &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 \\\\\n    E &amp; 1 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 &amp; \\infty &amp; 0 &amp; \\infty \\\\\n    F &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\infty &amp; 0 \\\\\n\\end{matrix}$$</p>\n\n<p>Here is where I am stuck, the smallest finite capacity cut I see is a trivial one: $(S,T) =(\\{s\\},\\{t,A,B,C,D,E,F\\})$ with a capacity of 3.</p>\n\n<p>Using this cut leads to an incorrect solution of:</p>\n\n<p>$$ U\' = U \\cap S = \\{\\}$$\n$$ V\' = V \\cap T = \\{B,D,F\\}$$\n$$ U\' \\cup V\' = \\{B,D,F\\}$$</p>\n\n<p>Whereas we expected $U\' \\cup V\' = \\{A,C,D,F\\}$?  Can anyone spot where I have gone wrong in my reasoning/working?</p>\n', 'ViewCount': '2163', 'Title': 'Maximum Independent Set of a Bipartite Graph', 'LastActivityDate': '2013-08-27T14:52:52.030', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '3033', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1577', 'Tags': '<algorithms><graph-theory><network-flow>', 'CreationDate': '2012-08-03T19:21:39.403', 'FavoriteCount': '1', 'Id': '3027''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Of large sparse biparite graphs (say degree 4) with N verticies, roughly speaking, which of them cause the worst case running time of the <a href="https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm" rel="nofollow">Hopcroft-Karp algorithm</a>? What is their general structure and architecture, and why does it cause a problem?</p>\n\n<p>Further, in many implementations the DFS part is implemented using recursion, eg from Wikipedia:</p>\n\n<pre><code>function DFS (v)\n    if v != NIL\n        for each u in Adj[v]\n            if Dist[ Pair_G2[u] ] == Dist[v] + 1\n                if DFS(Pair_G2[u]) == true\n                    Pair_G2[u] = v\n                    Pair_G1[v] = u\n                    return true\n        Dist[v] = \u221e\n        return false\n    return true\n</code></pre>\n\n<p>What is the approximate maximum depth of the recursion in the worst case?</p>\n', 'ViewCount': '227', 'Title': 'Worst-case sparse graphs for Hopcroft-Karp Algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-08T06:54:35.197', 'LastEditDate': '2012-08-08T06:54:35.197', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1577', 'Tags': '<algorithms><graph-theory><algorithm-analysis><runtime-analysis>', 'CreationDate': '2012-08-07T05:31:16.787', 'Id': '3064''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>There is an obvious similarity in workings between Prim\'s algorithm and Dijkstra\'s algorithm, however I see no reason for Prim\'s algorithm to keep track of  a node\'s parent.  In Dijkstra\'s algorithm, the parent of the node needs to be tracked in order to follow the chain back to the original node to determine the distance from the source, however since Prim\'s algorithm only requires knowledge of the distance from the minimal spanning tree, rather than a specific node, there would be no reason to track the parent.</p>\n\n<p>Please refer to the following <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm" rel="nofollow">pseudocode</a> as reference:</p>\n\n<pre><code>PRIM(V, E, w, r )\n  Q \u2190 { }\n  for each u in V do\n    key[u] \u2190 \u221e\n    \u03c0[u] \u2190 NIL\n    INSERT(Q, u)\n  DECREASE-KEY(Q, r, 0)    \u25b7 key[r ] \u2190 0\n  while Q is not empty do \n    u \u2190 EXTRACT-MIN(Q)\n    for each v in Adj[u] do \n      if v in Q and w(u, v) &lt; key[v] then \n        \u03c0[v] \u2190 u\n        DECREASE-KEY(Q, v, w(u, v))\n</code></pre>\n', 'ViewCount': '202', 'Title': "Why does Prim's algorithm keep track of a node's parent?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-14T20:43:37.967', 'LastEditDate': '2012-08-14T20:43:37.967', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'user1422', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-08-06T04:01:28.780', 'Id': '3174''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a connected and directed graph $G=(V,E)$ with positive weights on the edges. for every $t&gt;0$ we define $E(t)$ to be the group of edges with weight lower or equal than $t$. I need to find an efficient algorithm which computes the minimal $t$ such that $G(t)=(V,E(t))$ is connected. </p>\n\n<p>I can sort all the edges with $|E|\\log|E|$ complexity and try to take edges out of the graph from the heaviest to the easiet one, and to check with DFS if it is still connected, but its not effiecnt enough,</p>\n\n<p>Any suggestions? </p>\n', 'ViewCount': '81', 'Title': 'For a graph $G$ find the minimal $t$ such $G(t)=(V,E(t))$ is connected', 'LastEditorUserId': '2499', 'LastActivityDate': '2012-08-28T15:43:34.987', 'LastEditDate': '2012-08-28T12:33:38.540', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '3349', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-08-28T10:14:23.247', 'Id': '3347''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a directed and strongly connected graph $G=(V,E)$, weight function $w: E \\to \\mathbb{R}$ and two distinct vertices $u,v \\in V$. We know that there aren't negative cycles.\nI need to find algorithm, efficient as possible,such that for every value of $k$, $2 \\leq k \\leq |V|-1$, it will find the lightest weight of a path between $u$ to $v$ that contains no more then $k$ edges (If there's one).</p>\n\n<p>I don't know what to do. I want to use Bellman Ford somehow, I just don't sure how.</p>\n\n<p>Thanks a lot. </p>\n", 'ViewCount': '100', 'Title': "Find the lightest weight of a path between $u$ to $v$ that contains no more then $k$ edges (If there's one)", 'LastActivityDate': '2012-08-28T23:11:30.527', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '3358', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-08-28T17:00:35.717', 'Id': '3352''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is a problem from CLRS 23-2 that I'm trying to solve. The problem assumes that given graph G is very sparse connected. It wants to improve further over Prim's algorithm $O(E + V \\lg V)$. The idea is to contract the graph, i.e. collapse two or more nodes into one node. So each reduction will reduce the graph by at least half nodes. The question is to come up with implementation such that time complexity of MST-REDUCE is $O(E)$. This uses set operations. MakeSet, Union and Find-Set. I've annotated my analysis in the picture along with algorithm. \nI'm thinking to implement the set as linked list here. So my make-set and find-set are $O(1)$. But Union sucks: $O(V)$. Since we are doing union for all the elements, we have total $O(V^2)$ time spent in union. Which gives amortized $O(V)$. Now the problem isn't clear whether it is expecting amortized time complexity or not. So I'm wondering if any better approach is possible. Note the algorithm is running for all nodes and all edges. Hence I think amortized makes sense.</p>\n\n<p>Here is my analysis (line, complexity)</p>\n\n<p>1-3 $V$ </p>\n\n<p>4-9 $\\frac{V}{2} \\cdot union = \\frac{V}{2} \\cdot \\frac{V}{2} = V^2 = V$ (amortized)</p>\n\n<p>10 $V \\cdot findset = V$</p>\n\n<p>12-21 $E \\cdot findset = E$</p>\n\n<p>Since $E &gt;= V - 1$, we have overall time complexity of $O(E)$. </p>\n\n<pre><code>0   MST-REDUCE(G, orig, c T)\n1   for each v in V[G]\n2       mark[v] &lt;- FALSE\n3       MAKE-SET(v)\n4   for each u in V[G]\n5       if mark[u] = FALSE\n6           choose v in Adj[u] such that c[u,v] is minimized.\n7           UNION(u,v)\n8           T &lt;- T union { orig(u,v) }\n9           mark[u] &lt;- mark[v] &lt;- TRUE\n10  V[G'] &lt;- { FIND-SET(v) : v in V[G] }\n11  E[G'] &lt;- { }\n12  for each (x,y) in E[G]\n13      u &lt;- FIND-SET(x)\n14      v &lt;- FIND-SET(y)\n15      if (u,v) doesn't belong E[G']\n16          E[G'] &lt;- E[G'] union {(u,v)}\n17          orig'[u,v] &lt;- orig[x,y]\n18          c'[u,v] &lt;- c[x,y]\n19      else if c[x,y] &lt; c'[u,v]\n20          orig'[u,v] &lt;- orig[x,y]\n21          c'[u,v] &lt;- c[x,y]\n22  construct adjacency list Adj for G'\n23  return G', orig', c', T\n</code></pre>\n", 'ViewCount': '671', 'Title': 'Show that the Minimum spanning tree Reduce Algorithm runs in O(E) on sparse graphs', 'LastEditorUserId': '2375', 'LastActivityDate': '2012-08-31T08:37:11.837', 'LastEditDate': '2012-08-31T08:37:11.837', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2375', 'Tags': '<algorithms><graph-theory><graphs><algorithm-analysis><runtime-analysis>', 'CreationDate': '2012-08-30T22:19:05.153', 'Id': '3375''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '2398', 'Title': 'Finding the minimum cut of an undirected graph', 'LastEditDate': '2012-09-02T21:14:29.657', 'AnswerCount': '3', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1183', 'FavoriteCount': '0', 'Body': "<p>Here's a question from a past exam I'm trying to solve:</p>\n\n<p>For an undirected graph  $G$ with positive weights $w(e) \\geq 0$, I'm trying to find the minimum cut. I don't know other ways of doing that besides using the max-flow min-cut theorem. But the graph is undirected, so how should I direct it? I thought of directing edges on both ends, but then which vertex would be the source and which vertex would be the sink? Or is there another way to find the minimum cut?</p>\n", 'Tags': '<algorithms><graph-theory>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-10T02:56:02.367', 'CommentCount': '3', 'AcceptedAnswerId': '3408', 'CreationDate': '2012-09-02T08:47:15.917', 'Id': '3399''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Suppose that we redefine the residual network to disallow edges into $s$. Argue that the procedure FORD-FULKERSON still correctly computes a maximum flow.  </p>\n</blockquote>\n\n<p>I was thinking that when we augment a path the residual capacity of reverse edge increases and can be used to decrease the flow in that edge (but overall increase the network flow) if needed. So if we disallow the edges into $s$ that means we are not allowing decrease in flow in edges $s\\to x$ ($x$ is the adjacent node to $s$). So in the case when we allow edges into $s$ we can have a cycle like </p>\n\n<p>$\\qquad \\displaystyle s \\to x_1 \\leadsto y \\leadsto x_2 \\to s \\to x_3 \\leadsto t$.  </p>\n\n<p>But if we disallow edges into $s$ again we can find the same path with out the cycle. All the above are intuitive ideas but I want a formal proof.  </p>\n\n<p>The question is from <em>Introduction to Algorithms</em> by Cormen et al.</p>\n', 'ViewCount': '356', 'Title': 'A variation in Ford-Fulkerson algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-02T13:17:51.197', 'LastEditDate': '2012-09-02T13:17:51.197', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2589', 'Tags': '<algorithms><graph-theory><network-flow><correctness-proof>', 'CreationDate': '2012-09-02T12:01:27.050', 'Id': '3400''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a directed graph $G=(V,E)$ and a node $r\\in V$, I need to grow a tree $T$ rooted at $r$ that has a minimum weight and spans all reachable nodes in $G$.</p>\n\n<p>The weight function assigns a non-negative weight to each node, which depends on the node's ancestors in $T$.  Specifically, for some fixed sets of nodes $S_1, S_2, \\dots, S_k \\subseteq V$, the weight of node $v$ is the number of sets $S_i$ that contain $v$ and all its ancestors in $T$.</p>\n\n<p>Any suggestion how to approach this problem?</p>\n", 'ViewCount': '141', 'Title': 'Minimum vertex-weight directed spanning tree where the weight function depends on the tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-13T06:27:26.233', 'LastEditDate': '2012-09-13T06:27:26.233', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2774', 'Tags': '<algorithms><graph-theory><optimization><spanning-trees>', 'CreationDate': '2012-09-10T07:57:07.253', 'FavoriteCount': '1', 'Id': '3486''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let Alice and Bob be two users chosen uniformly at random from a social network (e.g. Facebook). What is the probability that they are friends assuming that they share $k$ mutual friends?</p>\n\n<p>I am interested both in the experimental values (or estimates) from currently existing social networks (e.g. Facebook) and values predicted by random graph models for these social networks.</p>\n', 'ViewCount': '193', 'Title': 'What is the probability of friendship conditioned on the number of mutual friends', 'LastActivityDate': '2012-09-17T07:17:51.607', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<graph-theory><combinatorics><social-networks><random-graphs>', 'CreationDate': '2012-09-16T00:29:01.343', 'Id': '4571''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was watching the <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-16-greedy-algorithms-minimum-spanning-trees/" rel="nofollow">video lecture from MIT on Prim\'s algorithm for minimum spanning trees</a>.\nWhy do we need to do the swap step for proving the theorem that if we choose a set of vertices  in minimum spanning tree of $G(V,E)$and let us call that $A$ such  $A\\subset B$,  the edge with the least weight connecting $A$ to $V-A$ will always be in the minimum spanning tree ?  The professor has done the swap step at point 59:07 seconds in the video.</p>\n', 'ViewCount': '179', 'Title': "Why do the swap step in Prim's algorithm for minimum spanning trees?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-20T06:52:26.807', 'LastEditDate': '2012-09-19T21:19:36.247', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4624', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graph-theory><algorithm-analysis><greedy-algorithms><spanning-trees>', 'CreationDate': '2012-09-19T13:11:11.090', 'Id': '4614''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there an algorithm for finding the shortest path in an undirected weighted graph?</p>\n', 'ViewCount': '1289', 'Title': 'Finding the Shortest path in undirected weighted graph', 'LastEditorUserId': '72', 'LastActivityDate': '2012-09-23T14:05:51.613', 'LastEditDate': '2012-09-23T14:05:51.613', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2890', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2012-09-20T13:36:31.857', 'Id': '4629''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a graph $G(V,E)$. Each edge $e$ has two weights $A_e$ and $B_e$. Find a spanning tree that minimizes the product $\\left(\\sum_{e \\in T}{A_e}\\right)\\left(\\sum_{e \\in T}{B_e}\\right)$. The algorithm should run in polynomial time with respect to $|V|, |E|$.</p>\n\n<p>I find it difficult to adapt any of the traditional algorithms on spanning trees(Kruskal, Prim, Edge-Deletion). How to solve it? Any hints?</p>\n', 'ViewCount': '250', 'Title': 'Minimal Spanning Tree With Double Weight Parameters', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-14T05:06:23.300', 'LastEditDate': '2012-09-21T13:05:45.600', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '848', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2012-09-20T14:50:02.843', 'FavoriteCount': '6', 'Id': '4635''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Am I correct in my observation that the cardinality of the maximum matching $M$ of a bipartite graph $G(U, V, E)$ is always equal to $\\min(|U|, |V|)$?</p>\n', 'ViewCount': '233', 'Title': 'Size of Maximum Matching in Bipartite Graph', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-13T19:28:25.763', 'LastEditDate': '2013-01-13T19:28:25.763', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4676', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2922', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2012-09-22T20:14:11.160', 'Id': '4675''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have this simple 'assignment' problem:</p>\n\n<p>We have a set of agents $A = \\{a_1, a_2, \\dotso, a_n\\}$ and set of tasks $T= \\{t_1, 1_2, \\dotso, t_m\\}$. Note that $m$ is not necessarily equal to $n$. Unlike the general assignment formulation in Wikipedia, a task $t_c$ can only be assigned to an agent based on the task's preferred agents $ta_c \\subseteq A$. For example, if we have $ta_1= \\{a_1, a_3\\}$, that means that task $t_1$ can only be assigned to either agents $a_1$ or $a_3$. Now, each agent $t_d$ has a qouta $q_d$ where $q_d$ is positive integer. This means that $a_d$ must be assigned with $q_d$ number of tasks. </p>\n\n<p><strong>The Problem</strong></p>\n\n<p>Given above and a set of qoutas $\\{q_1, q_2, \\dotso, q_n\\}$, is there an assignment of tasks to agents such that all agents meet their respective qouta $q$. Note that it is not necessarily that all tasks be assigned to an agent. </p>\n\n<p><strong>Possible Solution</strong></p>\n\n<p>I have tried reformulating this problem in terms of a bipartite graph $G(A, T, E = \\cup ta_c)$ and expressed as a form of matching problem where given a matching $M$, a vertex agent $a_d\\in A$ is matched up to $q_d$ times or is incident to $q_d$ edges in $M$ but the vertices in $T$ is incident to only one edge in $M$. Not really like the usual matching problem which requires that the edges in $M$ are pairwise non-adjacent.</p>\n\n<p>However, it was suggested by someone (from cstheory, he knows who he is) that I could actually work this out as a maximum matching problem, by replicating an agent $a_d$ into $q_d$ vertices and 'conceptually' treat them as different vertices as input to the matching algorithm. The set of edges $E$ is also modified accordingly. Call the modified graph as $G'$</p>\n\n<p>It is possible to have more than 1 maximum matchings from graph $G'$. Now, if I understand this correctly, I still have to check each of the resulting maximum matchings and see that at least one of them satisfies the $qouta$ constraint of each $agent$ to actually provide the solution to the problem.</p>\n\n<p>Now, I want to prove that not finding one maximum matching $M$ $\\in$ set of all maximum matchings of the graph $G'$ that satisfies the $qouta$ constraint of the problem guarantees that there really exists no solution to the problem instance, otherwise a solution exist which is $M$.</p>\n\n<p><strong>I want to show that this algorithm always give correct result.</strong> </p>\n\n<p><strong>Question</strong></p>\n\n<p>Can you share to me some intuition on how I might go to show this?</p>\n", 'ViewCount': '294', 'Title': 'Simple Task-Assignment Problem', 'LastEditorUserId': '2922', 'LastActivityDate': '2012-09-23T00:13:44.433', 'LastEditDate': '2012-09-23T00:13:44.433', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4684', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2922', 'Tags': '<algorithms><graph-theory><proof-techniques><assignment-problem>', 'CreationDate': '2012-09-22T23:22:25.637', 'Id': '4683''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If a graph has a Euler cycle, do the biconnected components have Euler cycles as well?</p>\n', 'ViewCount': '79', 'Title': 'Euler cycles in biconnected components', 'LastActivityDate': '2012-09-24T13:48:36.543', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4706', 'Score': '5', 'OwnerDisplayName': 'el diablo', 'PostTypeId': '1', 'Tags': '<graph-theory><eulerian-paths>', 'CreationDate': '2008-11-25T14:59:38.553', 'Id': '4705''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In an undirected graph, can two nodes at an identical distance n from the root of a <a href="http://en.wikipedia.org/wiki/Depth-first_search" rel="nofollow">DFS</a> tree be neighbors in the original graph? I\'m thinking no, but I\'m not sure (because of back edges)</p>\n', 'ViewCount': '58', 'Title': 'Can two neighbors in a graph be at the same depth in a DFS tree?', 'LastActivityDate': '2012-09-24T13:48:52.410', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '4708', 'Score': '3', 'OwnerDisplayName': 'el diablo', 'PostTypeId': '1', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2008-11-28T20:38:14.300', 'Id': '4707''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm designing an algorithm for a class that will determine if a directed graph is unique with respect to a vertex $v$ such that for any $u \\ne v$ there is at most one path from $v$ to $u$. I've started by using BFS (breadth-first search) to find the shortest path from v to another vertex u, and then running BFS again to see if an alternate path can be found from v to u. I think this is too time consuming however. Does anyone have any hints as to how the solution can be found with a shorter execution time?</p>\n", 'ViewCount': '221', 'Title': 'Unique path in a directed graph', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:10:52.957', 'LastEditDate': '2012-12-13T02:10:52.957', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '4713', 'Score': '6', 'OwnerDisplayName': 'el diablo', 'PostTypeId': '1', 'Tags': '<graph-theory><shortest-path><graph-traversal>', 'CreationDate': '2008-12-08T22:07:40.493', 'Id': '4711''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is a question from my homework and I need some help.</p>\n\n<p>We are trying to run <a href="https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm" rel="nofollow">Kosaraju-Sharir</a> algorithm over $G$, adirectional graph  with arcs $(u,v)$. In the first DFS pass we inserted vertex $u$ into tree $T$. Can $V$ appear in the same tree $T$, or $T$ is a tree created earlier?</p>\n\n<p>I think it can appear in both cases but I really don\'t know how I can prove it. Will be happy with some guidance.</p>\n', 'ViewCount': '262', 'Title': 'Kosaraju-Sharir algorithm and the inserted vertex', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-09-24T17:56:13.873', 'LastEditDate': '2012-09-24T17:56:13.873', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '5', 'OwnerDisplayName': 'Nusha', 'PostTypeId': '1', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2012-04-07T18:15:28.373', 'Id': '4715''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My homework is implementing algorithms BFS, DFS, depth-limited and IDS for the map as a 2D grid with 8 directions of movement. \nI read that the IDS algorithm is optimal, but in my case is not optimal paths.</p>\n\n<p>Is the IDS algorithm optimal for graphs (e.g. map as a grid), or does optimality only apply to searching trees?</p>\n', 'ViewCount': '55', 'Title': 'IDS algorithm optimality for grid?', 'LastActivityDate': '2012-09-24T18:39:36.757', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'kamil', 'PostTypeId': '1', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2012-06-11T10:36:30.690', 'Id': '4721''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a square, ABCD. Intuitively it seemed to me that its chromatic polynomial is $\\lambda(\\lambda - 1)(\\lambda - 1)(\\lambda - 2)$ where there are $\\lambda$ colours available..</p>\n\n<p>That is there are $\\lambda$ ways in which a colour for A can be picked, there are $\\lambda - 1$ ways for colours for B and D to be picked(B and D are adjacent to A) and $\\lambda - 2$ ways for colours for C to be picked.</p>\n\n<p>However using the <a href="http://www.csie.ndhu.edu.tw/~rschang/dmchap11.ppt" rel="nofollow">decomposition theorem</a> (slide 47, Example 11.33) and decomposing the square into a path of length 3 and a triangle, shows that my initial reasoning is wrong.</p>\n\n<p>Could you tell me where I am going wrong with my thinking.</p>\n', 'ViewCount': '438', 'Title': 'Chromatic polynomial of a square', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-10T04:07:58.683', 'LastEditDate': '2013-04-10T04:07:58.683', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4775', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<graph-theory><colorings>', 'CreationDate': '2012-09-27T06:41:19.257', 'Id': '4758''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a directed graph and two distinct vertices S and T, is there a polynomial-time algorithm which finds every vertex which is on at least one simple path from S to T?</p>\n\n<p>It is not difficult to find all vertices that are both successors of S and predecessors of T but this is only a superset of the set above. For example, consider the following graph:\nS -> a; a -> b; b -> c; b-> T; c -> a</p>\n\n<p>While a, b and c are all successors of S and predecessors of T, there is no simple path from S to T going through c (because every path from S to T going through c contains twice a and b).</p>\n\n<p>A closely related problem is the following:\nGiven a directed graph and three distinct vertices S and T and I, is there a polynomial-time algorithm to decide if there exist a simple path from S to T going through I.</p>\n\n<p>A polynomial-time algorithm to this latter problem can be use to build a polynomial algorithm to the former since we can apply it succesively by replacing I by every node in the graph (or more efficiently to every node that is both a succesor of S and a predecessor of T).</p>\n', 'ViewCount': '428', 'Title': 'How to find the vertices on simple path between two given vertices in a directed graph', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-29T11:34:22.223', 'LastEditDate': '2012-09-28T14:36:39.057', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2989', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-09-27T21:53:33.433', 'FavoriteCount': '1', 'Id': '4771''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am learning about graph coloring. One of the exercise problems(grimaldi) led me to derive the chromatic polynomial for any cycle($C_n, n \\ge 3$).</p>\n\n<p>$P(C_n, \\lambda) = (\\lambda - 1)^n + (-1)^n(\\lambda - 1)$, where $\\lambda$ is the number of colours available</p>\n\n<p>Is it possible to interpret the terms of above polynomial? I need help doing the same.</p>\n', 'ViewCount': '132', 'Title': 'Chromatic polynomial of a cycle - Interpreting its terms', 'LastActivityDate': '2012-10-01T04:13:37.883', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2012-09-29T01:51:45.017', 'Id': '4787''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to create an algorithm in linear time where if given a directed acyclic graph I can add edges to make it strongly connected components.</p>\n\n<p>I believe I have an algorithm to identify sources and sinks in the input list of edges in form</p>\n\n<pre><code>1 2\n2 5\n3 1 \netc\n</code></pre>\n\n<p>And I know that the minimum number of edges to be added in order to create connected components is equal to MAX(sources,sinks).</p>\n\n<p>My question is, is there a way to come up with where I should add edges so that I can have the minimum number and still be linear complexity?</p>\n\n<p>Here is an example of what I'm after.</p>\n\n<p>Given this input edges:</p>\n\n<pre><code>1 3\n1 4\n2 3\n2 4\n5 7\n5 8\n6 8\n6 9\n</code></pre>\n\n<p>Output these edges to be added:</p>\n\n<pre><code>3 1\n4 5\n7 6\n8 1\n9 2\n</code></pre>\n", 'ViewCount': '379', 'Title': 'If I have sources and sinks of a DAG can I find the minimum number of edges to be added to make it Strongly Connected?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-03T15:45:33.350', 'LastEditDate': '2012-10-03T11:58:04.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'ZAX', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-10-03T01:00:34.353', 'Id': '4848''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>G{V, E} is directed, <strong>cyclic</strong>, weighted graph. What is the algorithm of finding all paths between any given two nodes?<br>\nCan you suggest any good reading?</p>\n', 'ViewCount': '465', 'Title': 'The path between any two nodes in cyclic directed graph', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-09T03:17:05.620', 'LastEditDate': '2012-10-09T03:17:05.620', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3067', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-10-05T12:01:57.987', 'FavoriteCount': '1', 'Id': '4883''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '852', 'Title': 'Dijkstra to favor solution with smallest number of edges if several paths have same weight', 'LastEditDate': '2012-10-07T06:39:29.413', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2826', 'FavoriteCount': '1', 'Body': "<p>You can modify any graph $G$ so that Dijkstra's finds the solution with the minimal number of edges thusly:</p>\n\n<p>Multiply every edge weight with a number $a$, then add $1$ to the weight to penalize each additional edge in the solution, i.e. </p>\n\n<p>$w'(u,v)=a*w(u,v)+1$</p>\n\n<p>This does not work for all values of $a$; $a$ needs to be at least $x$ for this to work. If $a$ is not this minimum number, it might not choose the shortest path. How do I find this minimum value $x$?</p>\n\n<p>Ps. This was done recreationally, I'm done with homework long ago.</p>\n", 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '2826', 'LastActivityDate': '2012-10-07T22:16:23.373', 'CommentCount': '3', 'AcceptedAnswerId': '4936', 'CreationDate': '2012-10-05T15:07:58.803', 'Id': '4887''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is part of a larger problem, which I believe I have reduced to this. Given a tree $T$ having positive edge weights, and $k$ leaves (nodes which have exactly one connected node), I need to delete some edges in the tree so that no two leaves in the original tree are connected (by a path) in the newly formed forest (of trees). The total sum of the weights of the deleted edges needs to be minimized.</p>\n\n<p>My understanding is that atleast $k-1$ edges need to be deleted to separate out all the $k$ leaves. Any more deletions will unnecessarily increase the total cost. Thus, we need to perform exactly $k-1$ deletions.</p>\n\n<p>My hypothesis:\nFor every pair of leaf nodes $l_i$ and $l_j$, find the edge with the minimum weight in the (unique) path from $l_i$ to $l_j$. The $k-1$ least weight edges from this set of edges need to be deleted. This will minimize the sum of weights of the edges to be deleted in order to disconnect all leaves from each other.</p>\n\n<p>I am unable to prove or disprove this hypothesis. Can someone please prove the correctness of this hypothesis, or give a counter-example along with the correct algorithm to solve this problem? If this is indeed correct, is there a faster way (asymptotic complexity wise) to solve this problem? This approach will take $\\Theta({k^2})$ time. Thanks in advance!</p>\n', 'ViewCount': '210', 'Title': 'Separate all leaves of a weighted tree with minimum weight cuts', 'LastActivityDate': '2014-01-23T09:20:39.300', 'AnswerCount': '2', 'CommentCount': '8', 'AcceptedAnswerId': '6396', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '3011', 'Tags': '<algorithms><graph-theory><trees>', 'CreationDate': '2012-10-06T05:53:00.637', 'FavoriteCount': '1', 'Id': '4898''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '3252', 'Title': "Why can't DFS be used to find shortest paths in unweighted graphs?", 'LastEditDate': '2012-10-07T13:03:05.600', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2826', 'FavoriteCount': '2', 'Body': '<p>I understand that using DFS "as is" will not find a shortest path in an unweighted graph. </p>\n\n<p>But why is tweaking DFS to allow it to find shortest paths in unweighted graphs such a hopeless prospect? All texts on the subject simply state that it cannot be done. I\'m unconvinced (without having tried it myself). </p>\n\n<p>Do you know any modifications that will allow DFS to find the shortest paths in  unweighted graphs? If not, what is it about the algorithm that makes it so difficult?</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T09:21:07.067', 'CommentCount': '2', 'AcceptedAnswerId': '4927', 'CreationDate': '2012-10-07T08:07:18.370', 'Id': '4914''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $A$ be an adjacency matrix of a directed graph. What's the meaning of the $(i,j)-$entry of the matrix $((A^T)^{7} \\cdot (A^{7}))$ ? </p>\n\n<p>My initial interpretation is that $(i,j)$ of this matrix is zero whenever nodes $i$ and $j$ have no 7-length in-coming paths from a common source. Is that right? Any attention is appreciated! </p>\n", 'ViewCount': '125', 'Title': 'Meaning of the adjacency matrix product', 'LastActivityDate': '2012-10-07T19:58:49.100', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'OwnerDisplayName': 'John Smith', 'PostTypeId': '1', 'OwnerUserId': '3091', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2012-10-07T14:44:26.083', 'FavoriteCount': '1', 'Id': '4923''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '963', 'Title': 'Finding paths with smallest maximum edge weight', 'LastEditDate': '2012-10-08T09:00:08.523', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Jiew Meng', 'PostTypeId': '1', 'OwnerUserId': '3099', 'FavoriteCount': '1', 'Body': '<p>I need to find the easiest cost path between two vertices of a graph. Easiest here means the path with the smallest maximum-weigth edge. </p>\n\n<p><img src="http://i.stack.imgur.com/WWszV.png" alt="enter image description here"></p>\n\n<p>In the above graph, the easiest path from 1 to 2 is: </p>\n\n<pre><code>1 &gt; 3 &gt; 4 &gt; 2\n</code></pre>\n\n<p>Because the maximum edge weight is only 2. On the other hand, the shortest path <code>1 -&gt; 2</code> has maximum weight 4. </p>\n\n<p>So it\'s an MST problem. I am thinking I will use Kruskal\'s algorithm to build the tree, but I\'m not sure how exactly. I will know the edges but how do I "reconstruct" the path? For example, given vertices <code>3</code> and <code>2</code>, how do I know to go left (top) of right in the tree? Or do I try both ways? </p>\n', 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-08T09:00:08.523', 'CommentCount': '3', 'AcceptedAnswerId': '4943', 'CreationDate': '2012-10-08T03:50:33.827', 'Id': '4942''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '56', 'Title': 'Compute relational composition in $O(|E||V|)$', 'LastEditDate': '2012-10-14T09:37:36.983', 'AnswerCount': '2', 'Score': '7', 'OwnerDisplayName': 'Johannes', 'PostTypeId': '1', 'OwnerUserId': '3181', 'Body': '<p>Definitions: Let $G=(V,E)$ be a DAG without self-loops, and $X \\subseteq G$ and $Y \\subseteq G$ be graphs.</p>\n\n<p>Input: $X,Y$. Output: The relational composition <a href="http://en.wikipedia.org/wiki/Relation_composition">relational composition</a> $X \\circ Y$ in $\\mathcal{O}(|E||V|)$.</p>\n\n<ul>\n<li>Case 1: $|E| \\le |V|$. Two for loops over $E(X)$ and $E(Y)$: Runtime $ \\le \\mathcal{O}(|E|^2) \\le \\mathcal{O}(|E||V|)$.</li>\n<li>Case 2: $|V| \\le |E|$\n<ol>\n<li>Draw the graph $(V(G),E(X) \\cup E(Y))$: $(O(|V|)+\\mathcal{O}(|2E|)))$. We call edges from $E(X)$ black and from $E(Y)$ red.</li>\n<li>Topologically sort it (Kahn: $\\mathcal{O}(|V|) + \\mathcal{O}(|E|)$). Let the first level be $0$, and edges go from a level to a higher level.</li>\n<li>Draw this graph twice.</li>\n<li>In the first copy, remove every red edge beginning at even level, and every black edge beginning at odd level: $\\mathcal{O}(E)$.</li>\n<li>In the second copy, remove every "black even" and "red odd": $\\mathcal{O}(E)$.</li>\n<li>For the first copy:\n<ul>\n<li>for all nodes $u$ on level $2i$</li>\n<li>for all nodes $v$ on level $2i+1$</li>\n<li>report edge $(u,v)$ (Runtime $\\mathcal{O}(V^2) \\le \\mathcal{O}(EV)$).</li>\n</ul></li>\n<li>For the second copy: The same for "$2i+1$".</li>\n<li>Union the reported nodes, throw out duplicates  $\\mathcal{O}(V^2) &lt;= \\mathcal{O}(EV)$ (I hope the graph representation allows this).</li>\n</ol></li>\n</ul>\n\n<p>Could some of you please look over my algorithm and check whether </p>\n\n<ul>\n<li>it is correct</li>\n<li>it is in $\\mathcal{O}(|E||V|)$</li>\n</ul>\n\n<p>If it\'s correct, does my algorithm already "exist"? If not, could you provide an alternative? I\'ll accept the first answer, but upvote if some more people are so kind to check.</p>\n\n<p>EDIT: Step 6 Seems to be in $O(E^2)$ sometimes. I wish this would not be true. Has anyone a working algorithm?</p>\n', 'Tags': '<algorithms><graph-theory><algorithm-analysis><check-my-algorithm>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-14T09:41:40.783', 'CommentCount': '0', 'AcceptedAnswerId': '6057', 'CreationDate': '2012-10-13T08:23:35.550', 'Id': '6055''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given an adjacency matrix $A_G$ of an undirected graph $G$, it is easy and straightforward to compute the characteristic polynomial $\\chi_G(\\lambda)$. What about the other way around? The problem can be formulated as follows.</p>\n\n<blockquote>\n  <p><strong>Problem</strong> Given a polynomial $P$, decide whether there is a graph $G$ with the corresponding adjacency matrix $A_G$ such that its characteristic polynomial $\\chi_G(\\lambda)$ equals the given $P$.</p>\n</blockquote>\n\n<p>For an arbitrary $P$, it is not always the case that there is a corresponding $A_G$. The naive exhaustive algorithm for the problem uses a basic theorem in algebraic graph theory: </p>\n\n<blockquote>\n  <p><strong>Theorem</strong> Let $G=(V,E)$ be a graph with adjacency matrix $A_G$ and $\\chi_G(\\lambda) = \\lambda^n+c_1\\lambda^{n-1}+c_2\\lambda^{n-2}+\\cdots+c_{n-1}\\lambda+c_n$, then </p>\n  \n  <p><strong>(1)</strong> $c_1=0$, </p>\n  \n  <p><strong>(2)</strong> $-c_2 = |E|$, and </p>\n  \n  <p><strong>(3)</strong> $-c_3 = \\text{twice the # of triangles in G}$.</p>\n</blockquote>\n\n<p>Now, given $P$, the algorithm goes through every candidate $A_G$ of a corresponding $G$ with $|E|=-c_2$ and number of triangles ($K_3$) equal to $-c_3$. For each $A_G$, compute $\\text{det}(A_G - \\lambda I)$ and see if it equals the given $P$. If none match, return false. Otherwise, return the $A_G$.</p>\n\n<p>This works, but is clearly not fast. The exhaustive algorithm would work even without the above theorem. Its use makes the search space smaller. What's a fast and more clever algorithm?</p>\n", 'ViewCount': '173', 'Title': "What's a fast algorithm to decide whether there is an $A_G$ corresponding to a given $\\chi_G(\\lambda)$?", 'LastEditorUserId': '3092', 'LastActivityDate': '2012-10-25T20:02:19.457', 'LastEditDate': '2012-10-25T19:53:16.970', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6314', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<algorithms><graph-theory><discrete-mathematics><matrices>', 'CreationDate': '2012-10-16T22:50:02.250', 'Id': '6115''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m a none-computer-science-student and get some knowledge on AI by taking the CS188.1x Course (Artificial Intelligence) on www.edx.org .</p>\n\n<p>Currently, I am working on the "Search in Pacman" Project; the sources can be found online at <a href="http://www-inst.eecs.berkeley.edu/~cs188/pacman/projects/search/search.html" rel="nofollow">Berkley CS188</a> . I have problems finding an good solution for "Finding All the Corners", so I need a good Multiple Goal Heuristic.</p>\n\n<p>I allready tried the simple approach described in <a href="http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html" rel="nofollow">here</a>. I used the minimum of all manhattan distances to all goals. This works, but is considered a rather poor heuistic, because my A-Star Algorithm expands 2606 nodes for the given maze. Using the same with euclidean distance expands even 103081 nodes. A good heuristic should expand 1600 nodes or less. A very good one 1200 nodes, an excellent one even 800 or less.</p>\n\n<p>I got a hint by other students who use minimum spanning trees created with Kruskal\'s Algorithm. I wanted to investigate into that direction, but I am somehow confused how the Kruskal Algorithm can be used to get a Heuristic?\nAs far as I understood, this Algorithm returns a minimum spanning tree (MST) which is a path, right? So it is a solution to the Traveling Salesman Problem (TSP); it returns a sequence of nodes. But I need a heuristic, so a cost function which can be applied to this problem and called by an Algorithm (like A*).</p>\n\n<p>Can anyone of you give me a hint on how to proceed? Every help is highly appreciated!</p>\n', 'ViewCount': '1068', 'Title': 'Heuristic for Finding Multiple Goals in Graph - e.g. using Kruskals Algorithm', 'LastActivityDate': '2013-01-15T21:48:58.973', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'EliteTUM', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><heuristics><search-problem>', 'CreationDate': '2012-10-09T13:24:05.047', 'Id': '6208''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '313', 'Title': 'Assignment problem for multiple days', 'LastEditDate': '2012-10-21T09:32:46.587', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '2', 'Body': '<p>I have a problem that can be reduced to an assignment problem.\n(In a previous <a href="http://cstheory.stackexchange.com/questions/12850/matching-on-bipartite-graph-multiple-edges">question</a> i found out how to do that.)</p>\n\n<p>Which means we have a set $A$ of agents and a set $T$ of tasks as well as a cost function $c(i,j)$. We need to find an assignment so that the total cost is minimal.</p>\n\n<p>The <a href="http://en.wikipedia.org/wiki/Hungarian_algorithm">hungarian algorithm</a> can find an optimal solution in at least $O(n^4)$. Which sounds good to me.</p>\n\n<p>My new Problem is:\nThere is a given number of days. I have to solve the assignment problem for each day so that <strong>every task is done every day</strong> and <strong>no agent does the same task twice</strong>.</p>\n\n<p>What I have tried:\nWe could run the hungarian algorithm separately for each day and limit the number of possible combinations based on the result of the previous day. But this would get us into trouble at some of the later days, where most likely it will be impossible to find a feasibly solution.</p>\n\n<p>Another idea is to somehow integrate local search to change decisions made at a previous day. But I think we can\'t rely on this.</p>\n\n<p>The problem instances I have to face will be somewhere around $|A| = |T| = 500$. The cost matrix $C(i,j)$ will have lots of same values (E.g. mostly 1 or infinity, only some 2 or 3). So during the hungarian algorithm there is a lot of space to create different optimal solutions for a single day.</p>\n\n<p>I\'d be glad to hear some ideas or advises how to find a good solution for the problem.\nThanks in advance.</p>\n', 'Tags': '<algorithms><graph-theory><assignment-problem>', 'LastEditorUserId': '4298', 'LastActivityDate': '2012-10-21T16:52:13.963', 'CommentCount': '1', 'AcceptedAnswerId': '6216', 'CreationDate': '2012-10-21T08:44:43.650', 'Id': '6210''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Least cost travel by intermixing different airline routes having linear discount functions:</p>\n\n<p>Lowest air fare route chosen by mixing different routes provided by different airline having different discount functions (like some airline can give 25% discount if fare crosses $5k) so that total cost of travel is minimized after intermixing of different airline routes</p>\n\n<p>This is a graph problem. Let $E(k)$ be the set of edges/routes \nflown by $k$-th airline, also given cost of travel associated with \neach edge.</p>\n\n<p>For $n$ airlines we have $n$ sets of edges i.e $E(k)=\\{\\mbox{some edges}\\}$ for \nall $k=1.. n$. We need to find the route from given source $s$ to given destination $t$\nsuch that we end up paying least fare among all possible \nroutes. There is no restriction on number of edges in a route.</p>\n\n<p>This is an NP-hard problem. How can I prove it?</p>\n', 'ViewCount': '138', 'Title': 'Proving following problem NP Hard using known NP Hard partition problem', 'LastEditorUserId': '140', 'LastActivityDate': '2012-10-22T08:13:56.217', 'LastEditDate': '2012-10-22T06:45:28.780', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'abhishek', 'PostTypeId': '1', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2012-10-21T09:33:47.030', 'FavoriteCount': '1', 'Id': '6218''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a bipartite graph with $|E|=O(|V|^2)$, a super-source and a super-sink. I am looking for the min-cost max-flow (the max-flow of all possible max-flows that has the minimum cost).</p>\n\n<p>For the sake of my question, denote $n=|E|$.</p>\n\n<p>Are there algorithms that will run in $O(n^2)$, or even $O(n\\log(n))$, or for that matter anything less than $O(n^3)$? In my case, $n$ is ~100,000, so $O(n^3)$ is impractical for me.</p>\n\n<p>\'Extra\' questions (should these go under a separate question?):</p>\n\n<ol>\n<li>Do any of these supper multi-graphs (I have 2 edges from my super-source node to each of the "blue" nodes in my bipartite graph, and 2 edges from each of the "red" nodes to my super-sink node)?</li>\n<li>Are there efficient implementations of such algorithms (that run in less than $O(n^3)$, and support multi-graphs) in C++, C, or Python?</li>\n<li>If the answer is \'no\', what are popular approximation algorithms and their associated run times?</li>\n</ol>\n', 'ViewCount': '500', 'Title': 'Min cost max flow in bipartite run time', 'LastEditorUserId': '4283', 'LastActivityDate': '2014-03-18T21:51:17.517', 'LastEditDate': '2012-10-23T05:03:44.203', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4283', 'Tags': '<graph-theory><graphs><optimization>', 'CreationDate': '2012-10-22T17:25:16.093', 'Id': '6234''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '92', 'Title': 'Constructing a tree from disjoint graphs', 'LastEditDate': '2012-10-23T09:13:36.870', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'BadAtGraphs', 'PostTypeId': '1', 'OwnerUserId': '4330', 'Body': '<p>I will preface my question with the definition of a simple tree that applies to my question:</p>\n\n<blockquote>\n  <p>A simple tree is an undirected and connected graph with no cycles.</p>\n</blockquote>\n\n<p>I am having difficulty coming up with a compelling argument that a tree of the above definition can be constructed by taking a set of disjoint valid graphs and adding a vertex between each of them. The practice problem states:</p>\n\n<blockquote>\n  <p>Prove that some graph $G$ is a tree if and only if it can be constructed from a set $X_1, X_2, \\dots, X_i$ of disjoint valid graphs by adding a new node adjacent to one node from each of $X_1,\\dots, X_i$. A single node is a valid graph.</p>\n</blockquote>\n\n<p>I\'m confused whether this question is asking me to prove that two graphs, or trees ("valid"), can be made into one tree by adding a node and adding edges from one preexisting node from each of the trees. If that is how the question should be interpreted, then is it enough to prove that the new tree (or "graph," I guess) has no cycles, and is connected?</p>\n\n<p>I\'m new to graph theory and I\'m wondering if you can help me understand it.</p>\n', 'Tags': '<graph-theory><trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-23T09:13:36.870', 'CommentCount': '0', 'AcceptedAnswerId': '6252', 'CreationDate': '2012-10-22T20:36:40.003', 'Id': '6249''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know that the disjoint set datastructure is used   to keep track of the connected components of an undirected graph when the edges are added to the graph dynamically . I also know that is is used in <a href="http://en.wikipedia.org/wiki/Kruskal%27s_algorithm" rel="nofollow">Kruskal\'s  algorithm for minimum spanning trees</a> . What are the other possible applications of this datastructure ?</p>\n', 'ViewCount': '487', 'Title': 'Practical applications of disjoint set datastructure', 'LastActivityDate': '2012-10-25T21:10:04.077', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6318', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graph-theory><data-structures><graphs>', 'CreationDate': '2012-10-25T12:40:07.410', 'FavoriteCount': '3', 'Id': '6308''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We know that the clique problem is NP-complete. Is the restriction of the problem to bipartite graphs or planar graphs still NP-complete?</p>\n', 'ViewCount': '358', 'Title': 'Is the clique problem NP-complete also on bipartite or planar graphs?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T00:00:07.960', 'LastEditDate': '2012-10-29T21:57:01.987', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1402', 'Tags': '<complexity-theory><graph-theory><graphs><np-complete>', 'CreationDate': '2012-10-29T21:24:06.577', 'Id': '6375''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m writing a JavaScript library for calculating graph measurements such as degree centrality, eccentrality, closeness and betweenness.</p>\n\n<p>In order to validate my library I use two exist applications <a href="http://gephi.org" rel="nofollow">Gephi</a> and <a href="http://nodexl.codeplex.com/" rel="nofollow">NodeXL</a> to run calculation with them.\nThe problem is I got what looks like different results.</p>\n\n<p>I build simple graph:</p>\n\n<pre><code>  (A) ----- (B)\n   |         |\n   |         | \n  (C) ----- (D)\n</code></pre>\n\n<p>Gephi gave those results:</p>\n\n<pre><code>A ecc=2 close=1.333 bet=0.5\nB ecc=2 close=1.333 bet=0.5\nC ecc=2 close=1.333 bet=0.5\nD ecc=2 close=1.333 bet=0.5\n</code></pre>\n\n<p>NodeXL gave those results:</p>\n\n<pre><code>A close=0.25 bet=0.5\nB close=0.25 bet=0.5\nC close=0.25 bet=0.5\nD close=0.25 bet=0.5\n</code></pre>\n\n<p>Note that NodeXL does not calculate eccentrality.</p>\n\n<p>Which one is right?<br>\nAre the results really different?</p>\n\n<p>I didn\'t normalize (or at least not intend to normalize) any results.</p>\n', 'ViewCount': '153', 'Title': 'Graph Closeness - Different result with gephi and NodeXL', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T14:54:03.650', 'LastEditDate': '2012-10-30T14:54:03.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6384', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4395', 'Tags': '<graph-theory><terminology><graphs>', 'CreationDate': '2012-10-30T09:37:41.223', 'Id': '6382''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '199', 'Title': 'Modification of Hamilton Path', 'LastEditDate': '2012-11-03T04:47:29.347', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4436', 'FavoriteCount': '1', 'Body': '<p>Although I know that the <a href="http://en.wikipedia.org/wiki/Hamiltonian_path_problem" rel="nofollow">Hamilton Path problem</a> is ${\\sf NP}$-complete, I think the following variant can be solved in polynomial time:</p>\n\n<blockquote>\n  <p>Given a planar graph with vertex set $V$, edge set $E$, start node $S$ and target node $F$,\n  our task is to find the Hamiltonian path from $S$ to $F$ or write that the path doesn\'t exist.</p>\n  \n  <p><em>Last condition</em>: In the path, in addition to selecting the directly connected vertices, \n  we can also choose those connected to exactly one neighbor.</p>\n  \n  <p><strong>Edit</strong>: The degree of any vertex is at most four ($\\deg(v_i) \\le 4$).</p>\n</blockquote>\n\n<p>Does anyone have any ideas how to prove that this can be solved in polynomial time? </p>\n\n<p>It can be hard to understand, so I will give an example:  </p>\n\n<p><img src="http://i.stack.imgur.com/meTSp.png" alt="Examples"></p>\n\n<p>In the left example, for $S=1,F=12$, the solution is the path $1, 11, 8, 7, 5, 9, 2, 10, 4, 6, 3, 12$.  </p>\n\n<p>In the right example, for $S=1,F=15$, there is no Hamiltonian path.</p>\n', 'Tags': '<algorithms><complexity-theory><graph-theory><np-hard>', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-03T16:06:59.817', 'CommentCount': '9', 'AcceptedAnswerId': '6448', 'CreationDate': '2012-11-02T10:23:44.050', 'Id': '6446''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We are given a graph with $n$ vertices, $m$ edges, and path edge costs of $x$. For vertices without a direct path that are distant exactly one neighbor, we can add new edge with edge cost $y$. Our task is to find shortest path (i.e minimum cost) between the start vertex and all others vertices.</p>\n\n<p>I have developed an algorithm, but I would like to create something faster than adding edges to the graph (via breadth-first search) and <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a>. Here are a couple examples:</p>\n\n<p><em>Example 1 Input:</em> For $x=3$, $y=1$</p>\n\n<p><img src="http://i.stack.imgur.com/RrBPA.png" alt="Example 1 Graph"></p>\n\n<p><em>Possible $y$ paths included:</em></p>\n\n<p><img src="http://i.stack.imgur.com/1lgvX.png" alt="Example 1 Graph with y"></p>\n\n<p><em>Output</em>: cost of shortest path from start node to node $i$ (assume that from start node to start node is 0)</p>\n\n<blockquote>\n  <p>1: 0<br>\n  2: 2<br>\n  3: 2<br>\n  4: 1<br>\n  5: 1<br>\n  6: 3  </p>\n</blockquote>\n\n<p><em>Example 2 Input</em>: For $x=3, y=2$</p>\n\n<p><img src="http://i.stack.imgur.com/Bsm7F.png" alt="Example 2 Graph"> </p>\n\n<p><em>Output</em>:  </p>\n\n<blockquote>\n  <p>1: 0<br>\n  2: 3<br>\n  3: 3<br>\n  4: 2<br>\n  5: 5  </p>\n</blockquote>\n', 'ViewCount': '264', 'Title': 'Shortest path in graph - upgrade an algorithm', 'LastEditorUserId': '4304', 'LastActivityDate': '2013-01-08T15:48:50.643', 'LastEditDate': '2012-11-03T04:47:38.037', 'AnswerCount': '0', 'CommentCount': '12', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4440', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-11-02T16:25:24.033', 'Id': '6453''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How many different max-heaps can I form using a list of $n$ integers. </p>\n\n<p>Example: \nlist [1,2,3,4]</p>\n\n<p>and max-heap is <code>4 3 2 1</code>  or </p>\n\n<pre><code>    4\n   / \\\n  3   2\n /\n1\n</code></pre>\n\n<p>other possible max-heap is <code>4 2 3 1</code></p>\n\n<pre><code>    4 \n   / \\\n  2   3 \n /\n1\n</code></pre>\n', 'ViewCount': '569', 'Title': 'How many max heaps are there?', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-01-27T20:52:32.243', 'LastEditDate': '2012-11-20T08:21:15.937', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6458', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '244', 'Tags': '<graph-theory><data-structures><combinatorics><binary-trees><heaps>', 'CreationDate': '2012-11-02T18:19:35.187', 'Id': '6456''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I ran into the following problem:</p>\n\n<p>Given a directed acyclic graph with real-valued edge weights, and two vertices s and t, compute the minimum s-t cut.</p>\n\n<p>For general graphs this is NP-hard, since one can trivially reduce max-cut to it by simply reversing the edge weights (correct me if I'm wrong).</p>\n\n<p>What is the situation with DAGs? Can min-cut (or max-cut) be solved in polynomial time? Is it NP-hard and, if so, are there any known approximation algorithms?</p>\n\n<p>I tried to find work on this but wasn't able to (maybe I'm just using wrong keywords in my searches), so I was hoping somebody may know (or find) something about this.</p>\n", 'ViewCount': '521', 'Title': 'Minimum s-t cut in weighted directed acyclic graphs with possibly negative weights', 'LastActivityDate': '2012-11-05T21:05:51.660', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '6498', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '691', 'Tags': '<algorithms><complexity-theory><graph-theory><weighted-graphs>', 'CreationDate': '2012-11-04T18:19:49.463', 'Id': '6476''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it possible for a graph to have a cycle that goes through all the nodes, but it does not have a Hamiltonian cycle (i.e. the cycle goes through some nodes more than once)? If yes, can anyone prove it? If not, can anyone give a counterexample?</p>\n', 'ViewCount': '114', 'Title': 'Can a graph have a cycle containing all nodes but not Hamiltonian?', 'LastActivityDate': '2012-11-05T22:42:21.243', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6501', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<graph-theory>', 'CreationDate': '2012-11-05T21:52:22.747', 'Id': '6500''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to build a graph with $N$ vertices such that each vertex has degree at least $k$ and the graph has the smallest diameter. What algorithm can I use?</p>\n', 'ViewCount': '59', 'Title': 'Constructing a graph of min-degree k with the smallest diameter possible', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-16T11:22:13.917', 'LastEditDate': '2012-11-16T11:22:13.917', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '-2', 'OwnerDisplayName': 'capoluca', 'PostTypeId': '1', 'OwnerUserId': '7079', 'Tags': '<graph-theory>', 'CreationDate': '2012-10-25T04:24:47.190', 'Id': '6669''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We are given a labelled directed graph, where both vertices (or states) and edges (or transitions) have labels. Informally, two states are bisimilar when they have the same label and they can simulate each other\'s transitions. On the states the two states evolve to, the same again is true.</p>\n\n<p>More formally, a binary relation $R \\subseteq S \\times S$ is a <a href="http://en.wikipedia.org/wiki/Simulation_preorder" rel="nofollow">simulation</a> iff $\\forall (p,q) \\in R$</p>\n\n<ul>\n<li>$p$ and $q$ have the same label, and</li>\n<li>if $p \\overset{a}{\\longrightarrow} p\'$ then $\\exists q\', q \\overset{a}{\\longrightarrow} q\'$ and $(p\',q\') \\in R$.</li>\n</ul>\n\n<p>A relation $R$ is a <a href="http://en.wikipedia.org/wiki/Bisimulation" rel="nofollow">bisimulation</a> iff $R$ and $R^{-1}$ are simulations. The largest bisimulation on the given system is called the <em>bisimilarity relation</em>. </p>\n\n<p>There are algorithms for finding the bisimilarity relation, that run in $O(m \\log n)$ time and $O(m+n)$ space, where $n$ is the number of states and $m$ the number of transitions. An example is the Paige-Tarjan RCP algorithm from 1987.</p>\n\n<p>However, consider a simpler problem. Instead of finding all the bisimulations, I just want to find a few of them. Can it be done faster than in loglinear time? If so, how? For example, let\'s say one is given two states $p,q \\in S$ such that they have the same label and they can make the same transitions. What I find problematic is to check that the states they lead to are once again bisimulations. In other words, one could also ask if there is a quick way to decide if two given states are a bisimulation.</p>\n', 'ViewCount': '78', 'Title': 'How to quickly find a few bisimulations on a given labelled digraph?', 'LastActivityDate': '2012-11-16T00:20:57.640', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6691', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<algorithms><graph-theory><process-algebras>', 'CreationDate': '2012-11-15T22:52:59.997', 'FavoriteCount': '1', 'Id': '6690''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '569', 'Title': 'Graph Theory and computer networks', 'LastEditDate': '2012-11-17T09:25:32.120', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Body': '<p>What are the various graph theory  techniques which are used in modelling of computer networks? Secondly, Will routing algorithms like bellmanford etc also be considered to be part of modelling networks? In short , I want to know the algorithm names which are used in modelling computer networks.</p>\n', 'ClosedDate': '2012-11-19T22:16:00.363', 'Tags': '<graph-theory><computer-networks>', 'LastEditorUserId': '4624', 'LastActivityDate': '2012-11-17T15:24:18.903', 'CommentCount': '2', 'AcceptedAnswerId': '6716', 'CreationDate': '2012-11-17T07:20:05.667', 'Id': '6707''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1199', 'Title': 'Formalization of the shortest path algorithm to a linear program', 'LastEditDate': '2012-12-23T09:32:01.477', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2329', 'FavoriteCount': '2', 'Body': '<p>I\'m trying to understand a formalization of the shortest path algorithm to a linear programming problem:</p>\n\n<p>For a graph $G=(E,V)$, we defined  $F(v)=\\{e \\in E \\mid t(e)=v \\}$ and $B(v)=\\{ e \\in E \\mid h(e)=v\\}$ where $t(e)$ is a tail of a node, and  $h(e)$ is a head of a node.</p>\n\n<p>Also the solutions for the conditions for the linear problem was defined as $b_v=1$ for every node $v$ except of the root $r$ which from it we find all the shortest paths in the graph where $b_r=-(n-1)$. It is written here "We associate a flow (primal variable) $x_e$ with each arc $e \\in E$.</p>\n\n<p>The main linear program is to minimize $\\sum\\limits_{e\\in E }c_ex_e$, subject to $\\sum\\limits_{e\\in B(v)}x_e-\\sum\\limits_{e\\in F(v)}x_e=b_v$ for all $v \\in V$ and $x_e \\geq 0$ for all $e \\in E$, where $c_e$ is the length of arc $e$.</p>\n\n<p>I\'d really love your help with understanding what does $x_e$ represent. Is it the number of times I use $e$ in order to find all the shortest paths in the graph?</p>\n\n<p>I don\'t understand why does the above condition for this linear program is as at it, why does  $\\sum\\limits_{e\\in B(v)}x_e-\\sum\\limits_{e\\in F(v)}x_e=b_v$ for all $v \\in V$ should  be $1$ for every node and $-(n-1)$ for the all the root? If I think of a $3$ nodes tree for a graph,for  the middle node we get that the condition equals to $1$, which makes me think that I might be misunderstood what $x_e$ stands for.</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path><linear-programming>', 'LastEditorUserId': '3016', 'LastActivityDate': '2012-12-23T12:30:04.713', 'CommentCount': '6', 'AcceptedAnswerId': '7562', 'CreationDate': '2012-11-17T15:59:11.327', 'Id': '6717''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There may be a large number of algorithms proposed for generating graphs satisfying some common properties (e.g., clustering coefficient, average shortest path length, degree distribution, etc).</p>\n\n<p>My question concerns a specific case: I want to generate a few <em>undirected regular</em> graphs (i.e., every node in these graphs has the same number of neighbors) with different clustering coefficients and average shortest path lengths. More generally, by fixing a degree distribution, I want to generate graphs with different clustering coefficients and average shortest path lengths.</p>\n\n<p>I wonder what are the well-known algorithms for doing this (or in fact, is there any?), and what are the recommended software for the same purpose?</p>\n', 'ViewCount': '358', 'Title': 'Algorithms for graph generation using given properties', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T10:21:38.160', 'LastEditDate': '2012-11-18T18:43:46.823', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4641', 'Tags': '<algorithms><graph-theory><graphs><sampling>', 'CreationDate': '2012-11-18T17:26:39.090', 'FavoriteCount': '1', 'Id': '6744''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Assume that we are given a real life graph, DBLP network in my case, where degree distribution of nodes follows a power law (many nodes have 1, 2 neighbors, and only a few nodes have hundreds of neighbors).</p>\n\n<p>A random walk ends when it returns to the initial node or when the walk takes 3 steps.\nIf we start random walks from each node on this graph, should we start equal number of walks from each node? If so, nodes with small degrees will often return to where they started, and we will not learn big portions of the network. This is because small degree nodes are neighbors of small degree nodes more often, so there will not be many paths to walk on.</p>\n\n<p>I believe there should be a way to decide on the number of walks to minimize computational costs. </p>\n', 'ViewCount': '174', 'Title': 'How many random walks to start from each node?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T03:31:55.453', 'LastEditDate': '2012-11-22T03:31:55.453', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4649', 'Tags': '<graph-theory><graphs><probability-theory><random-walks>', 'CreationDate': '2012-11-19T06:40:05.413', 'FavoriteCount': '1', 'Id': '6758''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1322', 'Title': 'Finding negative cycles for cycle-canceling algorithm', 'LastEditDate': '2012-11-20T09:31:55.460', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '4', 'Body': '<p>I am implementing the cycle-canceling algorithm to find an optimal solution for the min-cost flow problem. By finding and removing negative cost cycles in the residual network, the total cost is lowered in each round. To find a negative cycle I am using the bellman-ford algorithm.</p>\n\n<p>My Problem is:\nBellman-ford only finds cycles that are reachable from the source, but I also need to find cycles that are not reachable.</p>\n\n<p>Example: In the following network, we already applied a maximum flow. The edge $(A, B)$ makes it very expensive. In the residual network, we have a negative cost cycle with capacity $1$. Removing it, would give us a cheaper solution using edges $(A, C)$ and $(C, T)$, but we cannot reach it from the source $S$.</p>\n\n<p>Labels: Flow/Capacity, Cost</p>\n\n<p><img src="http://i.stack.imgur.com/jKtUd.png" alt="enter image description here"></p>\n\n<p>Of course, I could run Bellman-ford repeatedly with each node as source, but that does not sound like a good solution. I\'m a little confused because all the papers I read seem to skip this step.</p>\n\n<p>Can you tell me, how to use bellman-ford to find every negative cycle (reachable or not)?\nAnd if not possible, which other algorithm do you propose?</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path><network-flow>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-20T17:17:58.753', 'CommentCount': '3', 'AcceptedAnswerId': '6789', 'CreationDate': '2012-11-19T20:56:27.043', 'Id': '6773''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If a graph with $n$ vertices has more than $\\frac{(n-1)(n-2)}{2}$ edges then it is connected.</p>\n\n<p>I am a bit confused about this question, since I can always prove that for a graph to connected you need more than $|E|&gt;n-1$  edges.</p>\n', 'ViewCount': '1750', 'LastEditorDisplayName': 'user742', 'Title': 'Every simple undirected graph with more than $(n-1)(n-2)/2$ edges is connected', 'LastActivityDate': '2013-09-21T08:08:54.893', 'LastEditDate': '2012-11-22T10:43:46.290', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '6803', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<graph-theory>', 'CreationDate': '2012-11-21T06:18:46.710', 'Id': '6801''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '83', 'Title': 'Who (and when) first defined interval graphs?', 'LastEditDate': '2012-11-21T14:59:55.280', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '26', 'FavoriteCount': '1', 'Body': '<p>I\'ve been searching google scholar for references and narrowed down the first mention to somewhere around <a href="http://books.google.com/ngrams/graph?content=interval%20graph&amp;year_start=1800&amp;year_end=2000&amp;corpus=15&amp;smoothing=0&amp;share=">1963</a> with a very weird jitter in 1949.</p>\n\n<p>So, I\'m trying to track down the original paper introducing interval graphs for citation, but it\'s been rather elusive so far.</p>\n', 'Tags': '<graph-theory><reference-request><history>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T17:36:52.917', 'CommentCount': '0', 'AcceptedAnswerId': '6816', 'CreationDate': '2012-11-21T13:26:08.517', 'Id': '6812''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In this Wikipedia article about the <a href="http://en.wikipedia.org/wiki/Clique_%28graph_theory%29">Clique problem in graph theory</a> it states in the beginning that the problem of finding a clique of size K, in a graph G is NP-complete:</p>\n\n<blockquote>\n  <p>Cliques have also been studied in computer science: finding whether there is a clique of a given size in a graph (the clique problem) is NP-complete, but despite this hardness result many algorithms for finding cliques have been studied.</p>\n</blockquote>\n\n<p>But in this other Wikipedia article about the <a href="http://en.wikipedia.org/wiki/Clique_problem">Clique problem in CS</a>\n it says it is solving the problem for a fixed size k is a problem in P, it can be brute forced in polynomial time.</p>\n\n<blockquote>\n  <p>A brute force algorithm to test whether a graph G contains a k-vertex clique, and to find any such clique that it contains, is to examine each subgraph with at least k vertices and check to see whether it forms a clique. This algorithm takes time O(n^k k^2): there are O(n^k) subgraphs to check, each of which has O(k^2) edges whose presence in G needs to be checked. Thus, the problem may be solved in polynomial time whenever k is a fixed constant. When k is part of the input to the problem, however, the time is exponential.</p>\n</blockquote>\n\n<p>Is there something I am missing here? Maybe a difference in the wording of the problem? And what does the last sentence mean, that "When k is part of the input to the problem, however, the time is exponential."? Why is there a difference when the k is part of the input to the problem?</p>\n\n<p>My idea is that to find a clique of size k in a graph G, is that we first choose a subset of size k of nodes from G, and test wether they are all related to the other k nodes, which can be done in constant time. And repeat this until we have a clique of size k. The number of sets of k nodes we can choose from G is n! / k!*(n-k)!. </p>\n', 'ViewCount': '1742', 'Title': 'Is the k-clique problem NP-complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-24T15:19:38.560', 'LastEditDate': '2012-11-24T15:19:38.560', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6848', 'Score': '8', 'OwnerDisplayName': 'Eivind', 'PostTypeId': '1', 'Tags': '<complexity-theory><graph-theory><np-complete><complexity-classes>', 'CreationDate': '2012-11-22T08:52:36.760', 'Id': '6847''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>EDITS: corrected $r$ to add edges just like $f$ does in paragraph 8 per the first comment below. Also specified the Clique problem of interest in paragraph 2.</p>\n\n<p>Having received no response to this question on math.SE, I\'m asking it here. Thanks for your help.</p>\n\n<p>In <a href="http://en.wikipedia.org/wiki/Clique_problem" rel="nofollow">the Wikipedia article on the Clique problem</a>, we are told that under the brute-force algorithm, there are potentially exponentially many subgraphs of a given graph that must be checked as possible cliques. The particular Clique problem I\'m interested in is the problem of finding a clique larger than a given size.</p>\n\n<p>Informally, the question here is whether an unknown representation of graphs will also have a possibly exponential number of subgraphs that must be checked as possible cliques under the brute-force algorithm.</p>\n\n<p>I\'ll try to make this more precise by first giving a function to build up normal graphs, and then a new, different function to build up the unknown representation with properties that the new function must satisfy. The whole discussion here is about undirected graphs.</p>\n\n<p>Let\'s start by defining an operation that will build up a normal undirected graph. Let $E$ denote the null graph: $0$ nodes, $0$ edges. Let $f$ be the following operation:</p>\n\n<p>$f(n_1, n_2, G)$</p>\n\n<p>$f$ takes a graph $G$ and returns a graph with the edge from $n_1$ to $n_2$ added to $G$. So while the null graph $E$ is definable without $f$, all other standard graphs in our discussion are built by $f$: $f(n_1, n_2, G)$ where $G$ could equal $E$.</p>\n\n<p>As an example, the expression $f(n_1, n_2, E)$ returns the graph $(\\{n_1, n_2\\}, \\{(n_1, n_2)\\})$.</p>\n\n<p>Now consider an alternate graph representation $H$, built by a function we\'ll call $r$ that adds edges like $f$ does. But $H$ is an unknown representation that must obey the properties below.</p>\n\n<p>First let\'s describe a similarity relation ($\\sim$) between $G$ and $H$:</p>\n\n<p>Case 1. $G \\sim H$ if $G = E$ and $H = E$.<br>\nCase 2. $G \\sim H$ if $G = f(n_1, n_2, G_1)$, $H = r(n_1, n_2, H_1)$, and $G_1 \\sim H_1$.</p>\n\n<p>As before, the null graph $E$ is definable without $r$, but all others in the unknown representation are built by $r$: $r(n_1, n_2, H)$ where $H$ could equal $E$.</p>\n\n<p>The representation $H$ must obey the following properties:</p>\n\n<ol>\n<li>Just as $G$ is built by successive applications of $f$ to the null graph $E$, $H$ is built by successive applications of $r$ to the null graph $E$.</li>\n<li>The order in which the edges of a graph are added doesn\'t matter:\nin ordinary graphs, $f(n_1, n_2, f(n_3, n_4, G)) = f(n_3, n_4, f(n_1, n_2, G))$; in the unknown representation, $r(n_1, n_2, r(n_3, n_4, H)) = r(n_3, n_4, r(n_1, n_2, H))$. </li>\n<li>Since we\'re talking about undirected graphs, the order in which the nodes of an edge are specified doesn\'t matter: in ordinary graphs, $f(n_1, n_2, G) = f(n_2, n_1, G)$; in the alternate representation, $r(n_1, n_2, H) = r(n_2, n_1, H)$.</li>\n<li>Just as for $G$, $H$ has an operation $hasClique(\\{n_1,...,n_k\\}, H)$ which is true exactly when there is a clique among the nodes $\\{n_1,...,n_k\\}$. </li>\n<li>Consider a graph $G$ with nodes $\\{n_1,...,n_m\\}$ and a subset $\\{n_i,...,n_j\\}$ and $G \\sim H$ for some $H$. Then we require that nodes $\\{n_i,...,n_j\\}$ form a clique in $G$ if and only if the nodes $\\{n_i,...,n_j\\}$ form a clique in $H$. What I\'m trying to capture here is that $H$ has a clique wherever $G$ does and vice versa for $G \\sim H$.</li>\n</ol>\n\n<p>Question: Can we conclude that $H$ has potentially exponentially many subgraphs that must be checked as possible cliques under the brute-force algorithm, just as in normal graphs?</p>\n', 'ViewCount': '106', 'Title': 'Cliques in an alternate graph representation', 'LastEditorUserId': '1295', 'LastActivityDate': '2012-11-30T05:58:41.677', 'LastEditDate': '2012-11-28T03:46:37.517', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '7035', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2012-11-27T05:13:30.250', 'Id': '6942''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given an undirected Graph. I want to find a hamiltonian path with no restriction to starting or ending vertices. I know there are some smart algorithms for solving that.<br>\nNow let's make things interesting: sometimes, when I arrive at a vertex, the edges connected to that vertex change. I.e. some will be removed, others appear. It is only depending on the edge I used before which egdes will change.<br>\nThat means, if I go from vertex $v_1$ to $v_x$, edges connected to $v_x$ will change in the way $b_{1,x}$. if I arrived $v_x$ via $v_2$, edges will change in the way $b_{2,x}$ and so on.  </p>\n\n<p>I am looking for a efficient algorithm telling me if there is a hamiltonian path and output that if so. Has anybody ideas on how to approach that? Or has anyone an idea if this can be transformed into another better known problem?</p>\n", 'ViewCount': '133', 'Title': 'Hamiltonian path in dynamic graph', 'LastActivityDate': '2012-11-30T11:59:23.053', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4769', 'Tags': '<algorithms><graph-theory><reductions>', 'CreationDate': '2012-11-30T11:59:23.053', 'Id': '7046''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How can you perform the clique decision algorithm fewer than $ O(n) $ times to solve clique optimization?</p>\n\n<p>I\'m not sure if my approach is right but this is my thought process: you would pick vertices in a graph and see if they form a clique, then keep picking more vertices until you have the max possible clique.</p>\n\n<p>I\'m not sure how it can be done less than $ O(n) $ times.</p>\n\n<p>I can imagine an undirected graph such as:</p>\n\n<p><img src="http://i.stack.imgur.com/GptO1.png" alt="undirected graph"></p>\n\n<p>where $ \\{A, B, C\\} $ and $ \\{B, C, D\\} $ would be cliques. The number of vertices is 4, and the number of vertices in the cliques is 3, which is $ n - 1 $. Would this count as being done in less than $ O(n) $ times, or is this the wrong approach to this problem?</p>\n', 'ViewCount': '100', 'Title': 'Using Clique decision to solve Clique optimization', 'LastEditorUserId': '4689', 'LastActivityDate': '2012-12-02T03:39:34.423', 'LastEditDate': '2012-12-02T03:39:34.423', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7053', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<algorithms><graph-theory><optimization>', 'CreationDate': '2012-11-30T20:10:46.630', 'Id': '7052''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '405', 'Title': 'Using coloring optimization or coloring decision to solve coloring search', 'LastEditDate': '2012-12-01T01:46:27.977', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4689', 'FavoriteCount': '1', 'Body': "<p>How can you show that <strong>coloring search</strong> can be solved by making a polynomial number of calls to the solution for <strong>coloring optimization</strong> or <strong>coloring decision</strong>? (<strong>Coloring search</strong> is the algorithm to color the vertices of a graph such that adjacent vertices have a different color.)</p>\n\n<p>I wasn't sure how to solve it, but here is what I attempted (I chose to use <strong>coloring optimization</strong>):</p>\n\n<blockquote>\n  <p><strong>Coloring search</strong> can be solved by calling <strong>coloring optimization</strong> and finding the value $m$, which is the amount of colors needed so\n  that no two adjacent vertices have the same color. Once $m$ is found,\n  <strong>coloring search</strong> can color the vertices of the graph by rotating through the $m$\n  different colors for each vertex.</p>\n</blockquote>\n\n<p>Am I on the right track?</p>\n", 'Tags': '<graph-theory><np>', 'LastEditorUserId': '4689', 'LastActivityDate': '2012-12-01T03:12:33.517', 'CommentCount': '1', 'AcceptedAnswerId': '7066', 'CreationDate': '2012-12-01T01:35:49.187', 'Id': '7064''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>The Clique problem takes a graph $G = (V,E)$ and an integer $k$ and asks if $G$ contains a clique of size $k$. (A clique is a set of vertices such that every pair of vertices in the set is adjacent.) The Independent-Set problem takes a graph $G\u2019 = (V\u2019,E\u2019)$ and an integer $k\u2019$ and asks if $G\u2019$ contains an independent set of size $k\u2019$. (An independent set is a set of vertices such that no pair of vertices in the set is adjacent.)</p>\n\n<ol>\n<li><p>Give a polynomial time algorithm that, given a graph $G$ and an integer $k$ produces a graph $G\u2019$ and an integer $k\u2019$ such that $G$ has a clique of size $k$ if and only if $G\u2019$ has an independent set of size $k\u2019$. Justify your answer.</p></li>\n<li><p>Use 1. to prove that the Independent-Set problem is NP-Complete given that the Clique problem is NP-Complete.</p></li>\n</ol>\n', 'ViewCount': '2074', 'Title': 'Reducing Clique to Independent Set', 'LastEditorUserId': '2826', 'LastActivityDate': '2012-12-03T19:13:11.427', 'LastEditDate': '2012-12-03T18:47:25.250', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4828', 'Tags': '<algorithms><complexity-theory><graph-theory><np-complete>', 'CreationDate': '2012-12-03T10:46:11.947', 'Id': '7120''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Provided that we have to compare it against the graph coloring problem which is NPC. So far,\nI can only think of connecting edges from a vertex in a provided graph to all the other edges it is not connected to then I separate the new graph g2, then I connect all the vertices that are not connected in the g2. And then I count the number of subsets. However it doesnt seem to work with a graph that requires four colors? </p>\n', 'ViewCount': '417', 'Title': 'Proving that the clique cover problem is in NPC by reducing from k-coloring', 'LastEditorUserId': '2826', 'LastActivityDate': '2013-01-08T12:48:32.413', 'LastEditDate': '2012-12-06T19:48:46.213', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<graph-theory><np-complete><reductions>', 'CreationDate': '2012-12-04T13:05:33.323', 'FavoriteCount': '2', 'Id': '7155''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This problem, for me, looks very interesting. It was about to find a simple cycle (i.e. cycle where are not repeat nodes) in a directed graph.</p>\n\n<p>My solution is going like this, i.e, this graph is a case problem:\n<img src="http://i.stack.imgur.com/emyPU.png" alt="enter image description here"></p>\n\n<p>I know that there is a cycle in a graph, when you can find "back edges" in a depth-first-search (dashed in my picture in DFSTree), and for a moment I can sure for a few cycles, but not for all, simple cycles. Because, the directed egdes so important to from a cycle, i.e (0123) != (0321)</p>\n\n<p>I\'m thinking in make a dfs for each node with back-edges, but I\'m not sure, and it\'s not clear. So, I ask you, if you guide me. Thanks!.\n<img src="http://i.stack.imgur.com/yEVJ8.png" alt="enter image description here"></p>\n\n<p>Here is my count of simple loops for my case problem.</p>\n\n<p><img src="http://i.stack.imgur.com/6xGof.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/BO76B.png" alt="enter image description here"><img src="http://i.stack.imgur.com/lbUNw.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/Sj9us.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/ylafw.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/Lh0aa.png" alt="enter image description here"></p>\n', 'ViewCount': '2850', 'Title': 'Find the Simple Cycles in a Directed Graph', 'LastActivityDate': '2012-12-06T21:17:26.680', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1152', 'Tags': '<graph-theory>', 'CreationDate': '2012-12-06T20:58:31.723', 'FavoriteCount': '1', 'Id': '7216''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to solve a graph problem (it's not for homework, just to practice my skills). A DAG $G(V,E)$ is given, where $V$ is the set of vertices and $E$ the edges. The graph is represented as an adjacency list, so $A_v$ is a set containing all the connections of $v$. My task is to find which vertices are reachable from each vertex $v\\in V$. The solution I use has a complexity of  $O(V^3)$, with transitive closure, but i read that in a blog it can be faster, although it didn't reveal how. Could anyone tell me another way (with better complexity) to solve the transitive closure problem in a DAG? </p>\n", 'ViewCount': '1090', 'Title': 'Efficient algorithm for retrieving the transitive closure of a directed acyclic graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-08T07:54:26.363', 'LastEditDate': '2012-12-07T17:07:54.007', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4916', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2012-12-07T16:11:31.303', 'FavoriteCount': '1', 'Id': '7231''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Technical question: is there any open source program/code/library which can compute (minimal) conductance of a given graph, probably by some simulated annealing?</p>\n\n<p>Think it is quite well-known problem, but I cannot find anything like I mentioned above, but maybe you guys know? I know that it is a NP-hard task, but anyway, probably someone has written some programs.</p>\n', 'ViewCount': '82', 'Title': 'Graph conductance - program/code/library', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-03T22:28:30.283', 'LastEditDate': '2013-06-03T22:28:30.283', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Wojtek', 'PostTypeId': '1', 'Tags': '<graph-theory><random-walks>', 'CreationDate': '2012-12-08T16:29:39.240', 'Id': '7268''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is a homework question. I do not want the solution - I'm offering the solution I've been thinking of and wish to know whether is it good or why is it flawed.</p>\n\n<p>My motivation is to find what edges of an weighted, undirected graph are not a part of any MST. This problem only makes sense when several edges have the same weight, otherwise the MST is unique.</p>\n\n<p>My idea comes from Prim's Algorithm with a slight change - instead of adding the minimum edge from S to T on every step (where S and T being the two sets of vertex) - instead look for the minimum edge and more edges of the same value going from S to the vertex the minimum edge goes to. By doing that, (so I suppose) we will receive a graph containing all the edges which appear in any MST. If this is right, I can simply XOR the edges list with the original graph edges list to find what edges are not in any MST.</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '130', 'Title': 'What edges are not in any MST', 'LastEditorUserId': '5026', 'LastActivityDate': '2012-12-11T05:49:35.473', 'LastEditDate': '2012-12-11T05:49:35.473', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5026', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-10T22:51:01.253', 'Id': '7318''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For which values $A,B$ is the problem $\\mathsf{gap\\mathord-VC}\\mathord-[A,B]$ NP-hard? VC is the <a href="http://en.wikipedia.org/wiki/Vertex_cover" rel="nofollow">vertex cover</a> problem. I am given three options: $B=\\frac{3}{4},A=\\frac{1}{2}$ or  $B=\\frac{3}{4},A=\\frac{1}{4}$ or none.</p>\n\n<p>I would to review what I think that I need to do, I\'m not sure that the way I think of it is correct. This is what I think: I need to decide if it NP-hard to approximate the VC to $\\frac{1}{2}$, i.e., can I build an NP Turing machine that would return Yes iff for a given graph, it can guarantee that it has less than $\\frac{1}{4}V$ vertices that cover the whole graph? Maybe even for $\\frac{1}{2}V$ vertices? </p>\n\n<p><sub> This is a question from a past midterm that I\'m solving now in order to prepare myself for my own midterm in a "Computational Complexity Theory" course. </sub></p>\n', 'ViewCount': '67', 'Title': 'For what values of A and B is the gap-VC-[A,B] problem NP-HARD?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-12T20:39:47.017', 'LastEditDate': '2012-12-11T21:29:00.627', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7365', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<complexity-theory><graph-theory><approximation>', 'CreationDate': '2012-12-11T19:46:56.387', 'Id': '7332''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I came across a couple of solutions to one of the problems that is in the CLRS textbook (pg. 637 23.2-5 edition 3).  I am wondering if anyone can make a clarification as to the stated running time of the solution.</p>\n\n<p>Q:  Given that we know the edge weights on a graph are between $1$ and some constant $W$, how fast can we make Prim's algorithm run?</p>\n\n<p>Solution:</p>\n\n<ul>\n<li>Uses an array of linked lists where each index corresponds to a given weight [$1\\dots W + 1$]</li>\n<li>Each link linked lists contains a series of vertices with the weight of the index as their key</li>\n</ul>\n\n<p>The run time given is $O(E)$</p>\n\n<p>They break it down as follows:</p>\n\n<p>$O(1)$ to find the vertex with smallest weight\n       - I understand this part since we scan at most $W$ array slots to find a non-empty list and $W$ is constant.</p>\n\n<p>$O(1)$ for decrease key\n     - This makes sense as far as the actual removing of a link from one list and inserting it into another</p>\n\n<p>My question is about the decrease key step.  Say for example we pull the node $A$ from the 3rd slot, that is the next node to be processed.  We look at $A$'s adjacency matrix and see that it has edges to $B, C, F$.  Since we are using linked lists we have no choice other than to look at all array slots from $4$ to $W$ and see if we can find the vertices listed in the linked list for that particular index. Then delete the vertex from its current list and add it to the correct list if we find it. Possible search time = $O(V)$ [since we store vertices in the linked lists and could search all before finding our desired vertex] not $O(1)$.</p>\n\n<p>Since each decrease key takes $O(V)$ and we process all vertices running time = $O(V^2)$.  </p>\n\n<p>If anyone could let me know where I am going astray in my analysis I would greatly appreciate it.</p>\n", 'ViewCount': '489', 'Title': 'Question about Prims algorithm where weights are between 1 and some constant W', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-14T22:17:34.860', 'LastEditDate': '2013-01-14T22:17:34.860', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'cpowel2', 'PostTypeId': '1', 'OwnerUserId': '5050', 'Tags': '<algorithms><graph-theory><runtime-analysis><spanning-trees>', 'CreationDate': '2012-12-11T18:43:12.797', 'Id': '7345''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to solve a graph problem ( it's not for homework, just to practise my skills ). </p>\n\n<p>A dag $G(V,E)$ is given, where $V$ is the set of vertices and $E$ the edges. The graph is represented as an adjacency list, so $A_i$ is a set containing all the connections of $i$. </p>\n\n<p>My task is to find which vertices are reachable from each vertex $v\\in V$. </p>\n\n<p>The solution I use has a complexity of  $O(V^3)$, with transitive closure, but i read that in a blog it can be faster, although it didn't reveal how. Could anyone tell me an other way ( with better complexity ) to solve the transitive closure problem in a dag? Thanks in advance.</p>\n", 'ViewCount': '112', 'Title': 'Finding reachable vertices', 'LastActivityDate': '2012-12-13T23:17:23.803', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '1', 'OwnerDisplayName': 'Rondogiannis Aristophanes', 'PostTypeId': '1', 'OwnerUserId': '4916', 'Tags': '<graph-theory>', 'CreationDate': '2012-12-06T17:43:17.690', 'FavoriteCount': '1', 'Id': '7369''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '8637', 'Title': 'How many edges must a graph with N vertices have in order to guarantee that it is connected?', 'LastEditDate': '2012-12-13T15:28:57.800', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/6801/every-simple-undirected-graph-with-more-than-n-1n-2-2-edges-is-connected">Every simple undirected graph with more than $(n-1)(n-2)/2$ edges is connected</a>  </p>\n</blockquote>\n\n\n\n<p>At lesson my teacher said that a graph with $n$ vertices to be certainly connected should have<br>\n$ {\\frac{n(n-1)}{2}+1 \\space }$ edges showing that (the follow is taken from the web but says the same thing):</p>\n\n<blockquote>\n  <p>The non-connected graph on n vertices with the most edges is a complete graph on \n  $n-1$ vertices and one isolated vertex. So you must have $ 1+\n{\\frac{n(n-1)}{2} \\space}$ edges to guarantee connectedness. </p>\n</blockquote>\n\n<p><strong>My idea:</strong> a complete graph $K_{n-1}$ with $n-1$ vertices has ${n-1 \\choose 2}$edges,  so ${\\frac{(n-1)*(n-2)}{2}}$ edges, added to the edge to connect the complete graph to the isolate vertex,</p>\n\n<p>so shouldn\'t be ${\\frac{(n-1)*(n-2)}{2}}+1$ edges?</p>\n\n<p>What am I doing wrong?</p>\n\n<p>Thanks.</p>\n', 'ClosedDate': '2012-12-17T00:47:19.893', 'Tags': '<graph-theory><graphs>', 'LastEditorUserId': '4765', 'LastActivityDate': '2012-12-13T15:42:26.470', 'CommentCount': '3', 'AcceptedAnswerId': '7375', 'CreationDate': '2012-12-13T10:57:30.183', 'Id': '7373''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given an undirected weighted graph $G$ with two edges of minimum weight and all other edges are distinct. Does G have a unique minimum spanning tree?</p>\n\n<p>I know the proof for if all edge weights are distinct (it does give a unique MST) and I am thinking that if two edges of minimum weight are in $G$ then I should be able to show a counter example. But so far I have not been able to produce one.</p>\n\n<p>So my question is does it give a unique MST if the graph $G$ contains two minimum weight edges?</p>\n', 'ViewCount': '1396', 'Title': 'Minimum spanning tree with two minimum edge weights', 'LastActivityDate': '2013-04-17T10:28:33.490', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-15T18:14:13.453', 'FavoriteCount': '1', 'Id': '7414''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For a random undirected graph with $n$ nodes, where each node has $k$ incident edges ($nk/2$ edges in total), the vertex set is  partitioned into two sets each having $n/2$ nodes.  </p>\n\n<blockquote>\n  <p>What is the order of the number of edges that start in one partition and end in the other?  </p>\n</blockquote>\n\n<p>My back of the napkin calculation is half of total number of edges, $nk/4$. If I place randomly an edge it has $1/4$ chance of having both ends in one partition, $1/4$ chance of having both ends in the other partition and $1/2$ chance of having the ends in both. I find it surprising that it could be half.</p>\n', 'ViewCount': '52', 'Title': 'Mean number of edges between two equal partitions', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-16T19:05:20.267', 'LastEditDate': '2012-12-16T19:05:20.267', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7435', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5081', 'Tags': '<graph-theory><graphs><random-graphs>', 'CreationDate': '2012-12-16T10:12:42.143', 'Id': '7433''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to design an efficienct algorithm to color a unicyclic graph. I know if a graph does not contain any cycles (it's a tree) then it is 2-colorable. But cycles are either 2 (is even number of vertices) or 3 (is odd number of vertices) colorable. So if there contains just one cycle then the chromatic number of this unicyclic graph should be 3 (if the cycle contains an odd number of vertices).</p>\n\n<p>So enough of that. on to the algorithm.</p>\n\n<p>I would start at a vertex and color it color1. Now I would perform a BSF from the originator. Then each vertex that is adjacent to the originator vertex i would color it color 2, and continue this process of switching from color1 to color 2 unless if one of the vertices has an adjacent vertex that is already colored the same color. That means i found the cycle and will color that vertex color 3. If it had an adajcent vertex that was a different color than what i was going to color it then its an even number cycle and it would be 2-colorable.</p>\n\n<p>So that means, each step of the BFS I would check each vertex adjacent to the vertex selected for that step of the BFS. Therefore $O(|E|)$?</p>\n\n<p>is there a more efficient algorithm to color a unicyclic graph and is my time complexity correct?</p>\n", 'ViewCount': '124', 'Title': 'Coloring a Unicyclic Graph', 'LastActivityDate': '2012-12-25T11:21:47.680', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7462', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2012-12-16T19:45:56.453', 'FavoriteCount': '0', 'Id': '7444''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Consider an undirected graph with a source and a sink vertex. We would like to remove minimum number of vertices in that graph to disconnect any path between source and sink.</p>\n\n<p>My intuition tells me that we can use max-flow, min-cut algorithm to solve this problem. I don't know whether my solution is correct or not. Please help me check it:</p>\n\n<ol>\n<li>Replace each of the undirected edges with a pair of directed edges.</li>\n<li>Replace each vertex $v$ with two vertices $v_\\text{in}$ and $v_\\text{out}$ connected by an edge. all the incoming edges of $v$ will be connected with $v_\\text{in}$, all the outgoing edges of $v$ will be connected with $v_\\text{out}$.</li>\n<li>Try to find a minimum cut $M$. The edges of $M$ refer to the vertices that we need to remove.</li>\n</ol>\n", 'ViewCount': '767', 'Title': 'Remove minimum number of vertices to disconnect the graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-17T09:25:17.337', 'LastEditDate': '2012-12-17T09:25:17.337', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5093', 'Tags': '<algorithms><graph-theory><network-flow>', 'CreationDate': '2012-12-17T07:12:38.157', 'Id': '7457''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to figure out a greedy algorithm that finds the optimum (minimum) dominating set for any tree in linear time.</p>\n\n<p>So a greedy algorithm to find a dominating set for a general graph is not optimum. It's an approximation of the optimum dominating set. But since this is a tree I am assuming that a greedy algorithm can give the optimum.</p>\n\n<p>What i have so far is:</p>\n\n<p>Select a vertex with the maximum number of adjacent vertices that are not dominated (that is, it's neighbors are either not dominated by one it its neighbors or they are not a dominated vertex themselves). We add this vertex to the dominated set.</p>\n\n<p>We repeat this proceudue until all vertices are either in the dominated set or are neighbors of one of the dominated vertices.</p>\n\n<p>But I am not sure this will give an optimum solution.</p>\n", 'ViewCount': '418', 'Title': 'Greedy Optimum Dominating Set For A Tree', 'LastActivityDate': '2012-12-23T08:11:29.983', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><greedy-algorithms>', 'CreationDate': '2012-12-17T19:13:27.847', 'Id': '7470''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a DAG representing strict partial order where each node is an assignment of variables $V$ to their values $v$. Each arc $(u,w)$ represents a change in one variable value such that $u\\succ w$. </p>\n\n<p>So if I have $n$ binary variables, I will end up with $2^n$ nodes which is exponential to the size of variables $n$. is there any method to store such DAG efficiently? </p>\n', 'ViewCount': '119', 'Title': 'Is there an efficient method to store large DAGs?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-18T18:31:40.867', 'LastEditDate': '2012-12-18T16:32:46.107', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<algorithms><graph-theory><data-structures><partial-order>', 'CreationDate': '2012-12-18T04:30:32.000', 'Id': '7484''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '804', 'Title': 'Characteristic path length', 'LastEditDate': '2012-12-21T22:40:42.830', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4624', 'FavoriteCount': '1', 'Body': '<p>I am unable to understand that what the characteristic path length (CPL) of a graph is.</p>\n\n<p>In one of its definitions, it is written that</p>\n\n<blockquote>\n  <p>it is defined as the median of the means\n  of the shortest path lengths connecting each vertex to all other vertices.</p>\n</blockquote>\n\n<p>This is what I understand. Is it right?</p>\n\n<p>Suppose we have 3 nodes A, B and C. A can reach to B and C through different paths. We consider just the two paths, AB and AC. These two are the shortest path lengths from which A can reach to B and C respectively. We will then take the mean of AB and AC. Similarly, we will calculate two more means for B and C like I calculated it for A. In the end, we will take the median of the 3 means.</p>\n\n<p>Am I right?</p>\n', 'Tags': '<graph-theory>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-21T22:40:42.830', 'CommentCount': '2', 'AcceptedAnswerId': '7538', 'CreationDate': '2012-12-21T12:30:09.707', 'Id': '7535''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '213', 'Title': 'XOR-like behavior in flow networks', 'LastEditDate': '2013-03-03T11:44:38.840', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '2', 'Body': '<p><em>XOR is not the correct name, but I am looking for some kind of exclusive behavior.</em></p>\n\n<p>I am currently solving a set of different (assignment) problems by modeling flow networks and running a min-cost-max-flow algorithm. Flow networks are quite handy because a lot of problems can be reduced to them in an easy and understandable way. In my case these are matchings with some additional constraints. As these constraints are getting more complex I\'ve been wondering if there are some existing constructions to model specific behaviors.</p>\n\n<p>In this case I want to restrict the outgoing flow of a node to a single edge.</p>\n\n<p>Given a graph $G=(V, E)$, integral capacities $c(u,v)$ and costs $k(u,v)$. An arbitrary node is called $A$. It\'s direct neighbors are called $B_1, ..B_n$. Can we replace the edges $AB_1,...AB_n$ (red) with some construction so that <strong>only one edge can receive flow</strong>? Which means that if $AB_1$ gets some flow (e.g. $5/10$) no other (red) edge can receive flow.</p>\n\n<p><img src="http://i.stack.imgur.com/1Cli7.png" alt=""></p>\n\n<p>We could add intermediate nodes/edges and play with costs and capacities. The total capacity of our new construction has to stay the same and the cost of the different alternatives have to stay somehow proportional.</p>\n\n<p>So my questions are:</p>\n\n<ol>\n<li>Are there constructions like this in general? (Any keywords, links, papers)</li>\n<li>Can you suggest a solution to my specific problem?</li>\n</ol>\n', 'Tags': '<algorithms><graph-theory><graphs><network-flow><assignment-problem>', 'LastEditorUserId': '4298', 'LastActivityDate': '2013-10-29T15:14:57.683', 'CommentCount': '9', 'AcceptedAnswerId': '7623', 'CreationDate': '2012-12-26T22:37:50.973', 'Id': '7610''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>When we say that in random graph we add an edge with a certain fixed probability, what do we actually mean?</p>\n\n<p>For example if probability is 0.5, does that mean that we can just add two edges in a graph because 0.5+0.5=1.</p>\n', 'ViewCount': '222', 'Title': 'Random graph model', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-29T01:36:11.837', 'LastEditDate': '2012-12-29T00:43:23.927', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '7633', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<graph-theory><probability-theory>', 'CreationDate': '2012-12-28T15:48:20.620', 'Id': '7629''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>3-Coloring problem can be proved NP-Complete making use of the reduction from 3SAT <a href="http://www.ic.unicamp.br/~rezende/ensino/mo417/2010s2/notas/16-nphard.pdf" rel="nofollow">Graph Coloring (from 3SAT)</a>. As a consequence, 4-Coloring problem is NP-Complete using the reduction from 3-Coloring:</p>\n\n<blockquote>\n  <p>Reduction from 3-Coloring instance: adding an extra vertex to the graph of 3-Coloring problem, and making it adjacent to all the original vertices.</p>\n</blockquote>\n\n<p>Following the same reasoning, 5-Coloring, 6-Coloring, and even general $k$-Coloring problem can be proved NP-Complete easily. However, my problem comes out with the underlying mathematical induction:</p>\n\n<blockquote>\n  <p>My Problem: What if the induction goes on to $n-1$-Coloring and $n$-Coloring problem, where $n$ is the number of vertices in the graph? I certainly know that $n$-Coloring problem can be solved trivially. So, is there something wrong with the reasoning? How to understand the reduction from 3-Coloring problem to the general $k$-Coloring one?</p>\n</blockquote>\n\n<p>Thanks for any suggestions.</p>\n', 'ViewCount': '1559', 'Title': 'How to understand the reduction from 3-Coloring problem to general $k$-Coloring problem?', 'LastActivityDate': '2013-01-01T08:24:44.500', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7672', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<complexity-theory><graph-theory><np-complete>', 'CreationDate': '2013-01-01T07:08:05.763', 'Id': '7671''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>What are the key differences between these three terms isomorphism, automorphism and homomorphism in simple layman language and  why we do isomorphism, automorphism and homomorphism ?</p>\n', 'ViewCount': '889', 'Title': 'Why we do isomorphism, automorphism and homomorphism?', 'LastActivityDate': '2013-01-02T21:37:38.257', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7693', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<graph-theory>', 'CreationDate': '2013-01-02T08:26:01.527', 'FavoriteCount': '3', 'Id': '7690''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A regular graph is one in which each vertex has the same number of neighbors, but in a star topology the central vertex is connected to more than one vertex. So, why is it referred to as a regular graph?</p>\n', 'ViewCount': '167', 'Title': 'How is a star topology a regular graph?', 'LastEditorUserId': '1541', 'LastActivityDate': '2013-01-05T20:46:36.067', 'LastEditDate': '2013-01-04T19:08:12.813', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<graph-theory>', 'CreationDate': '2013-01-03T01:26:15.037', 'Id': '7713''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m currently studying the book "Introduction to Algorithms - Cormen". Although a proof of correctness for the BFS algorithm is given, there isn\'t one any for the DFS in the book. So I was courious about how it can be shown that DFS visits all the nodes.\nI also googled for it. But it seems that every lecturer do some copy-paste work from this book in their pdf\'s, so I couldn\'t find anything useful. <br/><br/>\nBy DFS we had to show that it found the shortest path. But since DFS does not calculate something like that I have no idea how to prove it.<br/></p>\n\n<hr>\n\n<p>Off the topic, why are those proofs so important? Throughout the book there are so many lemmas and theorems which can be really boring sometimes. I understand how an algorithm works in 10 minutes, perhaps need another 5 to 10 minutes to understand how to analyse the running time, but then I\'m loosing 1 hour just for some useless lemmas. Besides, and worse even, I studied almost 50 proofs/lemmas of different algorithms till now, I never managed to solve one of them by myself. How can I gain the "proving ability"? Is there a systematical way to learn that? I don\'t mean the Hoare logic way with invariants, rather the informal way described in the book "Introduction to Algorithms". Is there any book which focuses on "how to prove algorithms" and show that in a systematical, introductory way ?</p>\n', 'ViewCount': '800', 'Title': 'DFS - Proof of Correctness', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-05T11:11:50.160', 'LastEditDate': '2013-01-05T10:16:22.507', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graph-theory><graphs><correctness-proof>', 'CreationDate': '2013-01-04T05:53:53.593', 'Id': '7749''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '91', 'Title': 'Application of Expander Codes', 'LastEditDate': '2013-02-14T18:42:46.433', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'smoes', 'PostTypeId': '1', 'OwnerUserId': '5327', 'Body': '<p>I need to give a talk about <a href="http://en.wikipedia.org/wiki/Expander_code">expander codes</a> at university (I\'m a student of computer science). Since they have been introduced to show a family of codes looking good when thinking of the <a href="http://en.wikipedia.org/wiki/Noisy-channel_coding_theorem">Shannon theorem</a>, I wonder what real world application for expander codes exist.</p>\n\n<p>As far as I know one has a real hard time when encoding but decoding is quite fast. Why aren\'t they used to encode write only media or similar? What is their big disadvantage?</p>\n', 'Tags': '<graph-theory><combinatorics><coding-theory><expanders>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-14T22:04:27.807', 'CommentCount': '0', 'AcceptedAnswerId': '9785', 'CreationDate': '2013-01-06T13:47:18.513', 'Id': '7816''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>What kind of heuristics are useful in a tree decomposition of a graph to find the k shortest paths from a given source to a vertex? </p>\n\n<p>Moreover, the local shortest paths at each node in a tree are precomputed. Here, the graph is undirected and weighted. I'm interested in finding only simple paths, i.e., no nodes are repeated in a path. </p>\n", 'ViewCount': '87', 'Title': 'Heuristics for tree decomposition into k shortest paths', 'LastEditorUserId': '88', 'LastActivityDate': '2013-01-08T08:25:46.483', 'LastEditDate': '2013-01-08T08:25:46.483', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5328', 'Tags': '<graph-theory><heuristics>', 'CreationDate': '2013-01-07T18:19:27.840', 'Id': '7819''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have 2 questions regarding Bipartiteness with corresponding examples.</p>\n\n<p>1) Can a non-connected graph be bipartite if it has an isolated vertex? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/AzAxV.png" alt="enter image description here">\n<br/>\nI would say YES with this partition:\nV<sub>1</sub> = {A, D, G}\n; V<sub>2</sub> = {B, C, E, F, H}\n<br/>But what confuses me is that A is isolated.\n<br/>Is that a contradiction to the bipartitiness of G ?</p>\n\n<p>2) Is there a rule about the uniqueness of the partitions ? Let\'s take the following graph:\n<img src="http://i.stack.imgur.com/dbQww.png" alt="enter image description here">\n<br/>choice1:\nV<sub>1</sub>= {A, C}; V<sub>2</sub> = {B, D}\n<br/>choice2:\nV<sub>1</sub>= {A, D}; V<sub>2</sub> = {B, C}</p>\n\n<p>Does it matter which one i choose?</p>\n', 'ViewCount': '82', 'Title': 'Graph Bipartiteness', 'LastActivityDate': '2013-01-08T02:45:16.330', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7824', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'CreationDate': '2013-01-08T02:10:47.957', 'Id': '7823''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I cannot imagine how cohomology is related to graph theory, actually I read solid definition from <a href="http://en.wikipedia.org/wiki/Cohomology" rel="nofollow">wiki</a>, and to be honest, I cannot understand it. \ne.g I know what is homotopy (in simple term), group of functions such that I can continuously convert each of them to another one, and I think this is useful for understanding homology, but, is there similar visualization method for cohomology? (I\'m not looking for exact definition, I want to imagine it, actually this is in graph theoretic concept). for more information see introduction of <a href="http://homepages.cwi.nl/~lex/files/fkdp.pdf" rel="nofollow">this paper</a>. I want to understand it in this paper, how is useful? how to imagine it? </p>\n\n<p><sub>P.S1: my field is not related to group theory, and as in introduction author wrote, this paper doesn\'t need deep group theoretic definition! and I don\'t want to be deep in group theory. Just looking for simple way to understand them.</sub></p>\n\n<p><sub>P.S2: I think I can imagine what is free group (which is in introduction of paper), at least by Calay graph seems to be easy to imagine it. </sub></p>\n\n<p><sub>P.S3: I also asked this in math.stackexchange but I think this is something between two field and may I get some mathematical answer there and some others here (from CS point of view) to understand it well.</sub></p>\n', 'ViewCount': '144', 'LastEditorDisplayName': 'user742', 'Title': 'Visualized definition of cohomology', 'LastActivityDate': '2013-01-23T12:32:53.133', 'LastEditDate': '2013-01-23T12:32:53.133', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '3', 'OwnerDisplayName': 'user742', 'PostTypeId': '1', 'Tags': '<graph-theory><group-theory>', 'CreationDate': '2013-01-22T10:51:45.317', 'FavoriteCount': '1', 'Id': '9088''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can someone tell me why almost in every book/website/paper authors use the following:</p>\n\n<pre><code>foreach vertex v in Adjacent(u)\n    relax(u,v)\n</code></pre>\n\n<p>when relaxing the edges, instead of:</p>\n\n<pre><code>foreach vertex v in Adjacent(u)\n    if (v is in Q)\n        relax(u,v)\n</code></pre>\n\n<p>This is extremely confusing for someone when learning the algorithm. Is there any reason why the people are omitting the IF ?</p>\n\n<p>Anyway I wrote a semi-Javascript (I changed it here to a readable syntax) implementation of Dijkstra and I wanted to be sure if it is correct because of this IF case. Here is my code excluding the initialising:</p>\n\n<pre><code>while (queue.length != 0)\n    min = queue.getMinAndRemoveItFromQ()\n    foreach v in min.adjacentVertices\n        // inspect edge from "min" to "v"\n        if ( queue.contains(v) AND min.priority + weight(min,v) &lt; v.priority )\n            v.priority = min.priority + weight(min,v)\n            v.pre = min\n</code></pre>\n\n<p>Is this implementation correct or am I missing something ?</p>\n', 'ViewCount': '204', 'Title': "Why not relax only edges in Q in Dijkstra's algorithm?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T13:23:47.117', 'LastEditDate': '2013-01-25T11:30:42.873', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '9121', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-01-23T22:07:29.570', 'Id': '9120''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given some undirected, unweighted, connected, and potentially parallel-edged graph $G$, an Euler circuit may be constructed iff every vertex in $G$ has an even degree.</p>\n\n<p>In graphs with two or more vertices of odd degree (there may only be multiples of two), one must "Eulerize" the graph, connecting the odd vertices with additional edges through other vertices if necessary.</p>\n\n<p>The optimal case for Eulerization is with the construction of only $n/2$ edges, where $n$ is the number of odd degree vertices, but this can only be the case if each odd vertex has an adjacent partner, thus allowing us to connect both vertices with one edge and making them both even.</p>\n\n<p>That being said, most graphs will require more than $n/2$ edges. As humans, we tend to Eulerize graphs by always choosing each pair of odd vertices that are adjacent to one another, and then using trial and error for the rest. However, this does not always work.</p>\n\n<p>For instance, in the following graph, choosing to add an edge between the pair of adjacent odd vertices, $1\\leftrightarrow 2$ and using $5$ edges to connect $3\\leftrightarrow 4$ results in an Eulerization that costs $6$ edges. However, choosing to instead connect $1\\leftrightarrow 4$ and $2\\leftrightarrow 3$ yields an Eulerization that costs $5$ edges, even though it did not use the adjacent odd vertices to its advantage.</p>\n\n<p><img src="http://i.stack.imgur.com/XB2O7.jpg" alt="Graph Generated by MMA"></p>\n\n<p>I know for sure that this problem is solvable, at least by brute force, because the number of pairs of odd vertices which should be connected with some number of edges is finite; specifically, there are $2^{n/2} \\Gamma(\\frac{n+1}{2})/\\sqrt{\\pi}$ (<a href="http://www.smbc-comics.com/index.php?db=comics&amp;id=2861#comic">Mathematica said so</a>) possible sets of pairs of odd vertices to connect. It\'s possible to go through each one, linking up each vertex to its partner (finding the shortest path between the two vertices in an undirected graph is probably a challenge within itself, which <a href="http://en.wikipedia.org/wiki/Shortest_path_problem#Undirected_graphs_with_unit_weights">Wikipedia fails to give a time complexity for</a>).</p>\n\n<p>In the end, the whole deal probably runs in polynomial times exponential times factorial time, which is pretty nasty. I\'ve done some basic research into whether there are algorithms which Eulerize paths, but can\'t seem to find any.</p>\n\n<p><em>Mathematica</em> code for graphic:</p>\n\n<pre><code>GraphPlot[\n  {1 -&gt; 2, 2 -&gt; 5, 5 -&gt; 3, 3 -&gt; 6, 6 -&gt; 3, 6 -&gt; 7, 7 -&gt; 6, 2 -&gt; 7, 7 -&gt; 8, 8 -&gt; 9, 9 -&gt; 10, 10 -&gt; 4, 4 -&gt; 11, 11 -&gt; 4, 11 -&gt; 12, 12 -&gt; 1, 1 -&gt; 12}, \n  VertexRenderingFunction -&gt; \n    (If[#2 &lt; 5, \n        Text[Style[#2, Large], #1, Background -&gt; Yellow], Null] &amp;)]\n</code></pre>\n', 'ViewCount': '386', 'Title': 'Is there a non-brute force algorithm for Eulerization of graphs?', 'LastActivityDate': '2013-01-25T07:14:49.743', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '9129', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6533', 'Tags': '<graph-theory>', 'CreationDate': '2013-01-24T03:32:58.287', 'FavoriteCount': '1', 'Id': '9126''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a directed acyclic graph $D = (V,A)$, a vertex $v \\in V$ is a <em>source</em> if its <em>indegree</em> is zero, meaning that it has only outgoing arcs.</p>\n\n<p>Does there exist a linear time algorithm to find a source in a given directed acyclic graph?</p>\n\n<p>Follow-up question:  Can one in linear time find all sources?</p>\n', 'ViewCount': '1940', 'Title': 'Finding a source of a directed acyclic graph in linear time', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-29T16:44:27.813', 'LastEditDate': '2013-01-26T18:01:05.863', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1108', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-01-24T17:59:04.973', 'FavoriteCount': '1', 'Id': '9133''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In the CLRS book (<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">http://en.wikipedia.org/wiki/Introduction_to_Algorithms</a>) Chapter 26 (Maximum Flow) page 744 (third edition), there is the following equation -</p>\n\n<p>$$\n\\sum_{u \\in U}e(u) \\;=\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in U}f(v, u) \\;+\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in \\bar{U}}f(v, u) \\;-\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in U}f(u, v) \\;-\\;\n\\sum_{u \\in U}\\;\\sum_{v \\in \\bar{U}}f(u, v)\n$$</p>\n\n<p>where $f(u, v)$ is the flow between vertices $u$ and $v$, $e(u)$ is the excess flow at a particular vertex, $U$ is the set of vertices which are reachable from the source, and $\\bar{U}$ is the set of remaining vertices.</p>\n\n<p>In the next line, the first and third terms disappear. I don\'t understand why that holds. I do realize that those are flow values from vertex $u$ to vertex $v$ where both of them are in the same set $U$, but I don\'t understand why they cancel out to zero.</p>\n', 'ViewCount': '102', 'Title': 'Push relabel algorithms in flow networks', 'LastEditorUserId': '2152', 'LastActivityDate': '2013-04-03T16:18:22.383', 'LastEditDate': '2013-04-03T16:18:22.383', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10993', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6558', 'Tags': '<algorithms><graph-theory><graphs><network-flow>', 'CreationDate': '2013-01-25T16:14:49.193', 'Id': '9153''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a graph with $n \\leq 50 $ vertices. Count all $k$-cliques of this graph, where $k = 1, \\ldots , n$.</p>\n\n<p>I need the most efficient algorithm.</p>\n', 'ViewCount': '170', 'Title': 'Finding all cliques of a graph', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T19:26:57.273', 'LastEditDate': '2013-02-02T19:26:57.273', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6583', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-01-27T17:52:18.483', 'FavoriteCount': '0', 'Id': '9209''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have the following problem:</p>\n\n<blockquote>\n  <p>Given an edge-colored DAG $G = (V,A)$, vertices $s$ and $t$, a set of colors $C$ and $k \\in \\mathbb{N}$,<br>\n   does there exist a path from $s$ to $t$ using exactly $k$ distinct colors?</p>\n</blockquote>\n\n<p>Can anyone provide pointers to the complexity of this problem?  More specific, is it $\\mathsf{NP}$-complete or in $\\mathsf{P}$?</p>\n', 'ViewCount': '84', 'Title': 'Path on an edge-colored DAG using exactly $k$ colors', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-05T10:28:30.163', 'LastEditDate': '2013-02-05T10:28:30.163', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'user547616', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-02-01T07:27:24.787', 'Id': '9490''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am interested if there exists a following version of the travelling salesman problem:</p>\n\n<blockquote>\n  <p>INSTANCE: A finite set $C = \\{1,2,\\dots,k\\}$ of cities, a positive integer distance $\\delta(i,j)$ for each pair of cities, and two positive integers $d$ and $B$.</p>\n  \n  <p>QUESTION: Is there a tour that visits every city in $C$, includes exactly $d$ detours, and has total length no more then $B$?  In other words, suppose $OPT$ is the optimal permutation of the cities; that is, $OPT(i)$ is the next city after city $i$ in an optimal traveling salesman tour.  Is there an ordering $x(0), \\dots, x(k-1)$ of the cities such that $$\\sum_{i=1}^{k} \\delta(x(i), x((i+1) \\bmod k)) \\leq B$$ and there are exactly $d$ indices $i$ where $x((i+1) \\bmod k) \\ne OPT(x(i))$?</p>\n</blockquote>\n\n<p>The $d$ implies that if my shortest tour is $a\\rightarrow b \\rightarrow c\\rightarrow a$ but $d=1$ then what would be the shortest path if I had to first go to $c$, $ a \\rightarrow c \\rightarrow ...$. So $d$ tells me that I have to make $d$ number of wrong choices but I can choose these choices in any way I want to to minimize the length of the path.</p>\n\n<p>Is this a problem worthwhile describing? Or if it has been described where could I see an example? </p>\n', 'ViewCount': '90', 'Title': 'Travelling salesman problem with detours', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:05:07.807', 'LastEditDate': '2013-06-06T15:05:07.807', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6697', 'Tags': '<complexity-theory><graph-theory><np-hard><decision-problem><traveling-salesman>', 'CreationDate': '2013-02-15T10:58:21.960', 'Id': '9802''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let Undir-Reachability be the following problem:\ngiven an undirected graph G and two specified vertices s and t in G, is there a path from s to t in G?</p>\n\n<p>I need to prove that the 2-Colourability is in L, by knowing that Undir-Reachability belongs to the complexity class L.</p>\n\n<p>I don't know how to start.</p>\n", 'ViewCount': '55', 'Title': 'Prove that 2-Colourability is in L from Undir-Reachability is in L', 'LastActivityDate': '2013-02-21T23:20:30.173', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10024', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6978', 'Tags': '<complexity-theory><graph-theory><space-complexity><colorings>', 'CreationDate': '2013-02-21T18:32:59.790', 'Id': '10016''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to prove that the following problem $0$-$1$ $\\mathsf{ Ineq}$ is $\\mathsf{NL}$-complete.</p>\n\n<p>Given a finite set of variables $V$, a finite set of inequalities of the form $x \\le y$ (where $x, y \\in V$) and a finite set of equalities of the form $x=a$ (where $x \\in V$ and $a \\in \\{0,1\\}$), is there an assignment of values from $\\{0, 1\\}$ to the variables satisfying all the inequalities and all the equalities?</p>\n\n<p>How can I start to resolve the proof?</p>\n', 'ViewCount': '64', 'Title': 'Prove that $0$-$1$ $\\mathsf{ Ineq}$ is $\\mathsf{NL}$-complete', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-22T10:06:31.597', 'LastEditDate': '2013-02-22T10:06:31.597', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10023', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6978', 'Tags': '<complexity-theory><graph-theory><reductions><space-complexity>', 'CreationDate': '2013-02-21T18:41:55.347', 'Id': '10017''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '852', 'Title': 'What is the complexity of this matrix transposition?', 'LastEditDate': '2013-02-26T02:44:32.997', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5391', 'FavoriteCount': '1', 'Body': "<p>I'm working on some exercises regarding graph theory and complexity. \nNow I'm asked to give an algorithm that computes a transposed graph of $G$, $G^T$ given the adjacency matrix of $G$. So basically I just have to give an algorithm to transpose an $N \\times N$ matrix.</p>\n\n<p>My first thought was to loop through all rows and columns and simply swapping values in each of the $M[i,j]$ place. Giving a complexity of $O(n^2)$ But I immediately realized there's no need to swap more than once, so I can skip a column every time e.g. when I've iterated over row i, there's no need to start iteration of the next row at column i, but rather at column i + 1.</p>\n\n<p>This is all well and good, but how do I determine the complexity of this. When I think about a concrete example, for instance a 6x6 matrix this leads to 6 + 5 + 4 + 3 + 2 + 1 swaps (disregarding the fact that position [i,i] is always in the right position if you want to transpose a $N \\times N$ matrix, so we could skip that as well).\nThis looks alot like the well-known arithmetic series which simplifies to $n^2$, which leads me to think this is also $O(n^2)$. There are actually $n^2/2$ swaps needed, but by convention the leading constants may be ignored, so this still leads to $O(n^2)$. Skipping the i,i swaps leads to $n^2/2 - n$ swaps, which still is $O(n^2)$, but with less work still..</p>\n\n<p>Some clarification would be awesome :)</p>\n", 'Tags': '<graph-theory><time-complexity><algorithm-analysis><linear-algebra><adjacency-matrix>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-07-25T22:31:32.400', 'CommentCount': '3', 'AcceptedAnswerId': '10082', 'CreationDate': '2013-02-25T13:54:53.913', 'Id': '10081''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given an undirected tree (with no specific root), how to find the longest path, i.e. 2 vertices that are the farthest apart from each other? There are no lengths associated with the edges (each edge has length 1 by default).<br>\nObviously one idea is to check the path lengths between all pairs of vertices (e.g. by doing a DFS from each vertex), but there should be a more efficient solution. Please include a short proof in your answer.</p>\n', 'ViewCount': '683', 'ClosedDate': '2013-03-04T17:16:27.133', 'Title': 'Longest path in undirected tree', 'LastEditorUserId': '7096', 'LastActivityDate': '2013-03-01T22:46:48.810', 'LastEditDate': '2013-03-01T19:35:40.383', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7096', 'Tags': '<algorithms><graph-theory><trees>', 'CreationDate': '2013-03-01T18:10:03.390', 'Id': '10181''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Given a tree $T = (V , F)$, find an algorithm which finds $u \\in V$, so in the graph $T = (V \\setminus \\{u\\} , F)$ the size of each connected component is $\\lceil |V| / 2 \\rceil$ at most. What is the complexity?</p>\n</blockquote>\n\n<p>Can I please have a hint?</p>\n', 'ViewCount': '211', 'Title': 'Find node that splits tree in half', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-07T02:37:14.300', 'LastEditDate': '2013-03-05T07:06:43.247', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'user2102697', 'PostTypeId': '1', 'Tags': '<algorithms><complexity-theory><graph-theory><trees>', 'CreationDate': '2013-03-01T15:40:43.320', 'Id': '10262''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '696', 'Title': 'How to find the maximum independent set of a directed graph?', 'LastEditDate': '2013-03-06T01:05:54.933', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5218', 'FavoriteCount': '2', 'Body': u'<p>I\'m trying to solve <a href="http://www.spoj.com/problems/DIVREL/" rel="nofollow">this problem</a>.  </p>\n\n<blockquote>\n  <p><strong>Problem</strong>: Given $n$ positive integers, your task is to select a maximum number of integers so that there are no two numbers $a, b$ in which $a$ is divisible by $b$.</p>\n</blockquote>\n\n<p>I have to find the Maximum independent set and the size of this set.   The size can be found by <a href="http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29" rel="nofollow">K\xf6nig\'s theorem</a>. But how can I find the Maximum Independent Set (i.e. which vertex are part of the set).  </p>\n\n<p>I did some search also and found something <a href="http://apps.topcoder.com/forums/?module=Thread&amp;threadID=647913&amp;start=0&amp;mc=5#1127789" rel="nofollow">here</a>:</p>\n\n<p><code>If removing a vertex does not change minimum path cover then I can get the desired  result without that vertex.</code></p>\n\n<p>But I don\'t understand the underlying theorem. Any help will be greatly helpful.</p>\n', 'Tags': '<algorithms><graph-theory><bipartite-matching>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-03-06T01:05:54.933', 'CommentCount': '3', 'AcceptedAnswerId': '10303', 'CreationDate': '2013-03-04T22:16:02.387', 'Id': '10274''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '139', 'Title': u'Number of Hamiltonian cycles on a Sierpi\u0144ski graph', 'LastEditDate': '2013-03-06T07:09:17.007', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'flonk', 'PostTypeId': '1', 'OwnerUserId': '7165', 'Body': '<p>I am new to this forum and just a physicist who does this to keep his brain in shape, so please show grace if I do not use the most elegant language. Also please leave a comment, if you think other tags would be more appropriate.</p>\n\n<p>I am trying to solve <a href="http://projecteuler.net/problem=312">this problem</a> for which I need to compute the number of Hamiltonian cycles $C(n)$ in the $n$th order Sierpinski-graph $S_n$. (Please also see the above link for the definition and pictures of Sierpinski-graphs)</p>\n\n<p>I have found $C(n)$, but I must have messed up something, because my solution does not match the given value $C(5) = 71328803586048$. My argumentation consists of very basic thoughts, and I cannot find the mistake. Any help is greatly appreciated. Even if it seems lengthy, the thoughts become trivial if you <a href="http://projecteuler.net/problem=312">look at the graphs</a> while following.</p>\n\n<p><strong>(a)</strong> In a given graph $S_n$ call the outer corners $A,B,C$. Then I define the following quantities: </p>\n\n<p>$N(n) := $ the number of Hamiltonian paths from $A$ to $C$.</p>\n\n<p>$\\bar{N}(n) := $ the number of paths from $A$ to $C$ which visit each node once except $B$.</p>\n\n<p>I will also call such paths $N$- or $\\bar{N}$-type paths in the following. </p>\n\n<p><strong>(b)</strong> It is easy to see that $N(n)=\\bar{N}(n)$. </p>\n\n<p>The reason is the following: Consider a $N$-type path. Starting at $A$ this path is of the form $(A,...,X_1,B,X_2,...,C)$. By replacing the segment $(X_1,B,X_2)$ by $(X_1,X_2)$ we obtain a $\\bar{N}$-type path. This operation uniquely maps all $N$-type paths to $\\bar{N}$-type paths.</p>\n\n<p><strong>(c)</strong> We derive the recursion $N(n+1)=2N(n)^3$.</p>\n\n<p>Consider an $N$-type path from $A$ to $B$ and denote the subtriangles at the outer corners $A,B,C$ by $T_A,T_B,T_C$, respectively. It is clear that the $N$-type path will visit each subtriangle exactly once starting from $T_A$ over $T_B$ to $T_C$. Now consider the node $Z$ at which the subtriangles $T_A$ and $T_C$ touch. There are two possibilities, when this point is visited by the path, either <strong>(i)</strong> before leaving $T_A$ or <strong>(ii)</strong> after entering $T_C$. In these cases the three subpaths inside $T_A,T_B,T_C$ are of the types <strong>(i)</strong> $N,N,\\bar{N}$ or <strong>(ii)</strong> $\\bar{N},N,N$, respectively. With this in mind we can count </p>\n\n<p>$N(n+1)=N(n)N(n)\\bar{N}(n)+\\bar{N}(n)N(n)N(n)$ and with <strong>(b)</strong> we arrive at the upper recursion.</p>\n\n<p><strong>(d)</strong> We solve the recursion <strong>(c)</strong> with $N(1)=1$ and obtain $N(n)=2^{3^0+3^1+...+3^{n-2}}$.</p>\n\n<p><strong>(e)</strong> Consider a Hamiltonian cycle in the graph $S_n$. As each of three subtriangles is connected to the others via two nodes only, it is clear that the cycle will enter each subtriangle exactly once via one connecting node, then "fill" it, an finally leave it via the other connecting node. Hence the Hamiltonian cycle in $S_n$ consists of three $N$-type subpaths in the subtriangles which all have the structure of $S_{n-1}$. We can conclude for the number of Hamiltonian cycles</p>\n\n<p>$C(n) = N(n-1)^3$.</p>\n\n<p>However it follows for $n=5$</p>\n\n<p>$C(5) = N(4)^3 = 8192^3=549755813888 \\neq 71328803586048$</p>\n\n<p>where the latter should be obtained according to the problem page (link above).</p>\n\n<p>Thanks again for any help or comments.</p>\n', 'Tags': '<graph-theory><combinatorics><check-my-proof>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-24T03:14:30.723', 'CommentCount': '0', 'AcceptedAnswerId': '10306', 'CreationDate': '2013-03-05T10:07:51.497', 'Id': '10305''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given an undirected unweighted  multigraph $G=(V,E)$ and $s,t \\in V$ find a simple $st$-path $P$ s.t. the number of edges leaving $P$ (i.e. the edges with exaclty one endpoint in $P$ ) is minimized.</p>\n\n<p>Does anybody have any idea how to solve this?\nI first thought about replacing edges by two arcs and weight them according to some node degrees but the edges staying in $P$ make life difficult.</p>\n', 'ViewCount': '45', 'Title': '$st$-path with fewest leaving edges', 'LastEditorUserId': '4259', 'LastActivityDate': '2013-03-07T01:43:30.247', 'LastEditDate': '2013-03-07T01:34:15.203', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10351', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4259', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-03-06T23:21:53.257', 'Id': '10339''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am studying MIT OCW lecture notes but they do not have solutions for the following problem. </p>\n\n<p><strong>Directed Acyclic Tournaments</strong></p>\n\n<p>In a round-robin tournament, every two distinct players play against each other\njust once. For a round-robin tournament with no tied games, a record of who beat\nwhom can be described with a tournament digraph, where the vertices correspond\nto players and there is an edge $x \\rightarrow y$ iff $x$ beat $y$ in their game.</p>\n\n<p>A <em>ranking</em> is a path that includes all the players. So in a ranking, each player won\nthe game against the next lowest ranked player, but may very well have lost their\ngames against much lower ranked players \u2014whoever does the ranking may have a\nlot of room to play favorites.</p>\n\n<ol>\n<li>Give an example of a tournament digraph with more than one ranking.</li>\n<li>Prove that if a tournament digraph is a DAG, then it has at most one ranking.</li>\n<li>Prove that every finite tournament digraph has a ranking.</li>\n<li>Prove that the greater-than relation, $&gt;$, on the rational numbers,\n$Q$, is a DAG and a tournament graph that has no ranking.</li>\n</ol>\n\n<p>I got stuck at  questions 2, 3, and 4. I have no idea how to solve it. I tried induction on b without a luck but still induction does not even help for infinite DAG cases.</p>\n', 'ViewCount': '357', 'Title': 'Acyclic Tournament Digraphs and Hamiltonian Paths', 'LastEditorUserId': '19', 'LastActivityDate': '2013-03-10T16:51:05.333', 'LastEditDate': '2013-03-10T00:07:24.233', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7208', 'Tags': '<graph-theory><proof-techniques>', 'CreationDate': '2013-03-09T21:42:28.243', 'Id': '10410''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So I\'ve been doing some reading on community detection in graphs as I\'m planning on working on my thesis for it. I\'ve been reviewing papers regarding the same and came across the <a href="http://www.pnas.org/content/99/12/7821.abstract" rel="nofollow">Girvan-Newman algorithm</a>. I\'ve read the paper and have a doubt which I couldn\'t really figure out.</p>\n\n<p>The algorithm works by removing the edge which has the highest value of "edge betweenness" in every iteration. Suppose I have a graph $G(V, E)$ such that $V = \\{ v_{1}, v_2, \\cdots , v_n\\}$. Now suppose this graph is such that it has 2 distinct communities (something we already know but that\'s what the algorithm should detect). After the first iteration, it would remove the edge which has the highest value of edge betweenness. Now my question is, after this is done (or even after a few iterations), say I have any vertex $v_i$, how do we know which community this vertex belong to? Am I missing something here?</p>\n', 'ViewCount': '65', 'Title': 'How do we know to what community a vertex belongs to in the Girvan-Newman algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-10T17:28:08.773', 'LastEditDate': '2013-03-10T11:58:27.300', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10431', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5020', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-03-09T22:55:03.733', 'Id': '10411''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Can the number of cycles in a graph (undirected/directed) be exponential in the number of edges/vertices?</p>\n\n<p>I'm looking for a polynomial algorithm for finding all cycles in a graph and was wondering if it's even possible.</p>\n", 'ViewCount': '881', 'Title': 'Number of cycles in a graph?', 'LastActivityDate': '2013-03-10T16:27:00.970', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10428', 'Score': '0', 'OwnerDisplayName': 'Shmoopy', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<graph-theory>', 'CreationDate': '2013-03-06T13:53:01.467', 'Id': '10427''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A graph $G$ is <em><a href="http://en.wikipedia.org/wiki/Chordal_graph">chordal</a></em> if it doesn\'t have induced cycles of length 4 or more. Chordal graphs are precisely the class of graphs that admit a <em>clique tree</em> representation. A clique tree $T$ of $G$ is a tree in which the vertices of the tree are the maximal cliques of $G$. An edge in $T$ corresponds to a <em><a href="http://en.wikipedia.org/wiki/Chordal_graph#Minimal_separators">minimal separator</a></em>. In general, $G$ can have more than one clique tree representing it. A graph is said to be <em>geodetic</em> if the shortest path between any pair of vertices is unique.</p>\n\n<p>Consider a chordal graph $G$ in which every minimal separator is a singleton set. I can prove such a graph is geodetic, but this property doesn\'t hold once minimal separators get larger. For example, consider a graph with a minimal separator $S = \\{2,3\\}$ of size 2 below. It already has 2 shortest paths between the vertices 1 and 4. </p>\n\n<p><img src="http://i.stack.imgur.com/QXNrB.png" alt="A chordal graph in which the minimal separator is of size 2."></p>\n\n<p>In fact, consider two adjacent vertices in a clique tree of a chordal graph. Let $S$ be the minimal separator corresponding to the edge between them. Now consider two distinct vertices $u$ and $v$ in these adjacent cliques such that $u,v \\notin S$. The number of shortest paths from $u$ to $v$ is the size of the minimal separator between them. This is because, roughly speaking, it takes one step to move from any vertex in a clique to a separator, and likewise any vertex in a clique can be reached with one step from the separator.</p>\n\n<p>Finally, consider an example like below. The graph has 3 maximal cliques, and the minimal separators are $\\{ 4,5 \\}$ and $\\{ 2,3 \\}$. Now the number of shortest paths from 1 to 6 is $2 \\times 2 = 4$.</p>\n\n<p><img src="http://i.stack.imgur.com/HcoSr.png" alt="enter image description here"></p>\n\n<blockquote>\n  <p>Given a connected chordal graph $G$ (with no loops nor parallel edges), what is the maximum number of shortest paths there can exist between any pair of vertices? How can it be bounded (in terms of $n$ and $m$)?</p>\n</blockquote>\n', 'ViewCount': '240', 'Title': 'What is the maximum number of shortest paths between any pair of vertices in a chordal graph?', 'LastActivityDate': '2013-03-10T23:20:18.047', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10439', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<graph-theory><combinatorics><shortest-path><discrete-mathematics>', 'CreationDate': '2013-03-10T22:13:48.403', 'FavoriteCount': '1', 'Id': '10438''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose that there is some graph, with $n$ vertexes. We wish to find the hamiltonian path, but we make the graph being searched a little different. There is a person A that travels each (undirected) edge that connects one vertex to the other vertex. But after the person crosses the edge, how edges connect pairs of vertexes change. (So, for example, before one crossed(traveled) one edge, there was an edge that connects vertex A to vertex B, but after some edge is crossed, there may no longer be the edge that connects vertex A to vertex B.) How the graph changes depends only on the order of the path being crossed - so, if he is on the third vertex in the path he chose, regardless of what path is, how the graph changes only depend on the fact that it is third vertex. Every change is known and inserted as input. Then we compute hamiltonian path. </p>\n\n<p>We can replace human with machine.</p>\n\n<p>So, what would be the name of finding hampath in such graph? And what complexity class would this be in?</p>\n\n<p>I tried to search this in my complexity textbook, but failed miserably - so I wonder if this even has a name.</p>\n', 'ViewCount': '44', 'Title': 'The name of "finding the path of a graph that is a variant of hamiltonian path"', 'LastActivityDate': '2013-03-12T13:46:05.437', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7243', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-03-12T13:46:05.437', 'Id': '10482''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given any graph $G$ on $V(G)=\\{1,\\dots,n\\}$ and its adjacency matrix \n$$A(G)=\\left(\\matrix{\nA_{1,1} &amp; A_{1,2} &amp; \\dots &amp; A_{1,n}\\\\\nA_{2,1} &amp; A_{2,2} &amp; \\dots &amp; A_{2,n}\\\\\n&amp;&amp;\\dots&amp;\\\\\nA_{n,1} &amp; A_{n,2} &amp; \\dots &amp; A_{n,n}\n}\\right)$$ any permutation on  $\\{1,\\dots,n\\}$ defines a new isomorphic graph $G\'$. A common approach to canonization is to take the lexicographically  minimal string $A\'_{1,2}A\'_{1,3}\\dots A\'_{n-1,n}$ (i.e. the upper/lower triangular matrix) such that $G$ is isomorphic to $G\'$ with $A\'=A(G\')$.</p>\n\n<p>If you now consider a permutation on $I=\\{(i,j)\\mid 1\\leq i&lt;j\\leq n\\}$ or equivalently  a bijective function $\\pi : \\{1,\\dots,{n \\choose 2}\\} \\rightarrow I$, we can try to minimize $A\'_{\\pi(1)},\\dots,A\'_{\\pi({n\\choose 2})}$ instead, or at least to compute the first $k$ bits of the minimal string.</p>\n\n<p>Observe that the complexity of this task heavily depends on the choice of $\\pi$:</p>\n\n<ol>\n<li>If you stick with default permutation (upper triangular matrix) you can easily compute the first $2n-1$ bits in polynomial time (adjacent vertices with maximal degrees).</li>\n<li>If you choose $\\pi(i)=(i,i+1)$ for the first $\\sqrt[c]{n}$ positions, you can reduce <strong>HamiltonPath</strong> to this in polynomial time.</li>\n</ol>\n\n<p><strong>Now my questions</strong>:</p>\n\n<ol>\n<li>Given a fixed function $k$ and input $(G,\\pi)$ how hard is it to compute the first bits $k(|V(G)|)$ of the minimal string $A\'_{\\pi(1)},\\dots,A\'_{\\pi({n\\choose 2})}$? Is there any (not necessarily strictly) monotonically increasing $k$ for which this is feasible? </li>\n<li>Is there a $\\pi$ s.t. even $\\omega(n)$ bits can be computed in polynomial time?</li>\n<li>Do you know any other reductions to a problem of this kind where $\\pi$ is "fixed" (i.e. only depends on $|V(G)|$) and the input has the form $(G,k)$ or $G$ (i.e. $k$ is "fixed" too)?</li>\n</ol>\n\n<p>Note: Answering (1) is enough to get accepted.</p>\n\n<p>Edit: In the meanwhile there appeared a somewhat connected question: <a href="http://cs.stackexchange.com/questions/10576/is-induced-subgraph-isomorphism-easy-on-an-infinite-subclass">Is induced subgraph isomorphism easy on an infinite subclass?</a></p>\n', 'ViewCount': '58', 'Title': 'Complexity of computing the first bits of a minimal permuted adjacency matrix', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-03-19T17:08:31.693', 'LastEditDate': '2013-03-19T17:08:31.693', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6716', 'Tags': '<complexity-theory><graph-theory><graph-isomorphism>', 'CreationDate': '2013-03-12T17:46:21.020', 'Id': '10493''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A full binary tree seems to be a binary tree in which every node is either a leaf or has 2 children.\nI have been trying to prove that its height is O(logn) unsuccessfully.\nHere is my work so far:</p>\n\n<p>I am considering the worst case of a full binary tree in which each right node has a subtree, and each left node is a leaf.\nIn this case:<br>\n$N = 2x - 1$<br>\n$H = x - 1$<br>\nI am going nowhere trying to prove that $H = O(\\log(N))$</p>\n\n<p>Furthermore, we know that leaves l is bounded by $h+1 &lt;l&lt;2^h$.<br>\nInternal nodes is bounded by $h&lt;i&lt;2^{h-1}$.<br>\nAll this proves is that number of nodes $n=i+e$ is $&lt;= 2^{h+1} - 1$ i.e. $\\log(n) &lt;= h$. But this does not take me anywhere closer to prove that $H = O(\\log(n))$</p>\n', 'ViewCount': '364', 'Title': 'Height of a full binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-13T14:40:59.037', 'LastEditDate': '2013-03-13T14:40:59.037', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10508', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7260', 'Tags': '<graph-theory><combinatorics><binary-trees><trees>', 'CreationDate': '2013-03-13T06:53:28.090', 'Id': '10507''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>An undirected graph is a near clique if adding an additional edge would make it a clique. Formally, a graph $G = (V,E)$ contains a near clique of size $k$ where $k$ is a positive integer in $G$ if there exists $S \\subseteq V$ where $|S| = k$ and $u,v \\in S$ where $(u,v) \\not\\in E$, and $S$ forms a clique in $(V,E \\cup \\{(u,v)\\})$. How can I show finding a near clique of size $k$ in $G$ is NP-complete? </p>\n', 'ViewCount': '173', 'Title': 'Prove finding a near clique is NP-complete', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-17T18:21:40.813', 'LastEditDate': '2013-03-17T18:21:40.813', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10583', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<complexity-theory><graph-theory><np-complete>', 'CreationDate': '2013-03-17T07:07:50.377', 'Id': '10573''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a problem that I was able to conceptualize as following:</p>\n\n<h2>Problem</h2>\n\n<p>We have a set of n people. And m subsets representing their ethnicity like White, Hispanic, Asian etc. Given any combination of these people, I want to check if it is a diverse group.</p>\n\n<p>A diverse group is a group that satisfies several requirements, each requirement is of the form "at least $k_i$ persons in the group belong to subset $S_i$". Here is the tricky part, one person can only be used to satisfy one requirement. As in, you can\'t use him/her for multiple requirements.</p>\n\n<h2>Example:</h2>\n\n<p>Given:</p>\n\n<p>At least two people from Hispanic= {a,b,c}</p>\n\n<p>At least two people from African={a,d,e}</p>\n\n<p>Is the group {a,c,d} a diverse group?</p>\n\n<p>The group {a,c,d} is not diverse because you cant count a as Hispanic and African. But, the group {a,c,d,e} is diverse because we have two Hispanics a and c and two African d and e.</p>\n\n<h2>Attempt:</h2>\n\n<p>I think this is an instance of the Assignment problem. The jobs are the ethnicity and we can put as many ethnicity as the requirement dictate. For example, if we need two Hispanic, then we put two Hispanic jobs. However there only some people are able to do a particular job. Is there a name for such a problem? any algorithms somewhere in the internet? If not how would the implementation look like? </p>\n\n<p>This is my attempt so far:</p>\n\n<p>I will construct a bipartite graph with the set of people $P$ on one hand and the set of ethnicity on the other $S$. We will put an edge between a person $p_i$ and an ethnicity $S_i$ if he/she belongs to the ethnicity.\n Now, we will modify the graph, for every ethnicity $S_i$ duplicate it $k_i$ times ($S_{i,1}, S_{i,2}, ... , S_{i,k_i}$). And add new edges accordingly. Find the maximum matching M of this graph. </p>\n\n<p>Now, merge the $S_{i,j}$s into one $S_i$ and there you have a diverse group. However, a maximum matching is only a possible solution to to the problem. And my problem is a decision problem, I want to check if a given group is a solution or not. </p>\n', 'ViewCount': '217', 'Title': 'Assignment problem with no cost', 'LastActivityDate': '2013-03-20T13:40:37.340', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7320', 'Tags': '<graph-theory><bipartite-matching><matching><assignment-problem>', 'CreationDate': '2013-03-17T23:04:11.883', 'FavoriteCount': '1', 'Id': '10591''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Suppose all costs on edges are distinct. How many minimal spanning trees are possible?</p>\n\n<p>I dont know if this question is supposed to be easy or hard, but all I can come up with is one, because Kruskal's, and any other greedy algorithm should choose all the smallest weighted edges first. Then, if all weights on all edges are distinct, then there are no two equivalently weighted minimum spanning trees if a greedy algorithm is used.</p>\n", 'ViewCount': '1057', 'Title': 'How many minimal spanning trees are there when all edge costs are distinct?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-27T16:47:34.527', 'LastEditDate': '2013-03-25T10:19:10.033', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '10731', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2013-03-24T02:05:51.303', 'Id': '10728''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a problem where I am supposed to analyze the <code>Steiner tree problem</code> by doing the following 3 steps.</p>\n\n<p>1) Look up what the Steiner tree problem is.</p>\n\n<p>2) Find a polynomial time reduction to it from one of these 8 known NP-complete problems:</p>\n\n<ul>\n<li>3-col </li>\n<li>subset-sum </li>\n<li>clique </li>\n<li>hampath </li>\n<li>Uhampath </li>\n<li>sat </li>\n<li>3-sat </li>\n<li>vertex-cover.</li>\n</ul>\n\n<p>3) Prove that it is NP-complete.</p>\n\n<hr>\n\n<p>My first problem is that I don't understand what the Steiner tree problem is. I can't find the problem anywhere. Wikipedia has  a page on it, but doesn't really describe it in simple terms.</p>\n\n<p>Can anyone help me out on this, and also give me hints for number 1, 2 and 3?</p>\n", 'ViewCount': '202', 'Title': 'How to analyze the Steiner tree problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-26T11:23:15.850', 'LastEditDate': '2013-03-26T11:23:15.850', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions><trees>', 'CreationDate': '2013-03-26T00:09:08.733', 'FavoriteCount': '2', 'Id': '10790''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need help with the following problem:</p>\n\n<blockquote>\n  <p><strong>Input:</strong>  An undirected, unweighted graph $G = (V,E)$ and a set of vertices $F \\subseteq V$.</p>\n  \n  <p><strong>Question:</strong>\n  Find a vertex $v$ of $V$ such that the distance from each vertex of $F$ to $v$ is the same and all the distances are minimized?  Return <code>None</code> if there is no such $v$.</p>\n</blockquote>\n\n<p>The runtime should be $O(|V| + |E|)$.</p>\n\n<p>My thoughts were to do a breadth-first search for each vertex in $F$, so for each vertex in $F$, you store all vertices with their distances, then find the intersection of all these.</p>\n\n<p>Is there a better way?</p>\n', 'ViewCount': '234', 'Title': 'Find a vertex that is equidistant to a set of vertices?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-03-31T10:13:00.143', 'LastEditDate': '2013-03-31T10:13:00.143', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<algorithms><graph-theory><search-algorithms><shortest-path>', 'CreationDate': '2013-03-26T05:51:11.470', 'Id': '10794''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Do you know of any kind of decomposition of graphs that involves centers, especially in the context of parametrized complexity? If so, please provide some reference. If not, do you see any reason (other than the potentially large size of centers) why such a notion isn\'t fruitful (e.g. subsumed by other notion)?</p>\n\n<p>I\'m looking for something similar to this:</p>\n\n<p>Let $G=(V,E)$ be an undirected graph. Its <em>central decomposition</em> is</p>\n\n<ul>\n<li>If $G$ is not connected: the set of central decompositions of its connected components.</li>\n<li>If $G$ is self-centered (radius equals diameter): $G$</li>\n<li>If $G$ is connected and not self-centered and its center is $C$: the pair $(I,O)$ where $I$ is the central decomposition of $G[C]$ and $O$ is the central decomposition of $G[V\\setminus C]$ (induced subgraphs of center and its complement)</li>\n</ul>\n\n<p>Its <em>central width</em> shall be the size of largest self-centered graph which appears in its central decomposition.</p>\n\n<p>The notion may also use other concepts (like complements, trees etc.), but it should use centers recursively. There is no need for uniqueness.</p>\n\n<p>I\'m <strong>not looking for</strong> e.g. <em>path distance decompositions</em> (see <a href="http://igitur-archive.library.uu.nl/math/2007-0104-200209/bodlaender_97_isomorphism.pdf" rel="nofollow">here</a>) where the root is the center, i.e. a map $d$ of a path $\\{p_0,\\dots,p_k\\}$ to $V$ where $d(p_i)=\\{v\\in V\\mid \\min_{c \\in C}\\mathrm{dist}(v,c) = i\\}$ ($C$ being the center of $G$).</p>\n', 'ViewCount': '58', 'Title': 'Decomposition of graphs that uses centers', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-03T15:31:28.617', 'LastEditDate': '2013-04-03T15:31:28.617', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6716', 'Tags': '<complexity-theory><graph-theory><reference-request><parametrized-complexity>', 'CreationDate': '2013-03-29T21:09:20.307', 'Id': '10903''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>A graph $G$ is chordal if it doesn't have induced cycles of length $4$ or more. A clique tree $T$ of $G$ is a tree in which the vertices of the tree are the maximal cliques of $G$. An edge in $T$ corresponds to a minimal separator. The number of distinct clique trees can be exponential in the number of vertices in a chordal graph. </p>\n\n<p>The <em>reduced clique graph</em> $C_r(G)$ is the union of all clique trees of $G$. That is, it has all the same vertices, and all possible edges. What is the complexity of computing $C_r(G)$ for a given $G$?</p>\n\n<p>I think I once saw a presentation claiming $C_r(G)$ can be computed in $O(m+n)$ time without proof. This would mean it is as easy as computing a clique tree of $G$. Is there a reference that confirms this, or gives a slower algorithm for computing it?</p>\n", 'ViewCount': '118', 'Title': 'Given a chordal graph $G$, what is the complexity of computing the reduced clique graph $C_r(G)$?', 'LastActivityDate': '2013-07-20T21:55:57.460', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13369', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<algorithms><graph-theory><reference-request>', 'CreationDate': '2013-04-02T21:23:52.710', 'FavoriteCount': '1', 'Id': '10979''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A simple question:</p>\n\n<p>What would be the complexity of finding whether a hampath of length $k$ exists in a graph with $n$ vertexes where $k &lt; n$?</p>\n\n<p>Would this be in NP-complete or just NP?</p>\n', 'ViewCount': '44', 'Title': 'complexity of finding the hampath of length $k$ in a graph with $n$ vertexes where $k < n$', 'LastActivityDate': '2013-04-05T03:35:16.630', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7585', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-04-05T01:05:09.547', 'Id': '11034''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I (will, at the end) have a connected, undirected graph with N nodes and 2N-3 edges. You can consider the graph as it is built onto an existing initial graph , which has 3 nodes and 3 edges, iteratively. Every node added onto the graph and has 2 connections with the existing nodes (not necessarily with the initial 3 only) in the graph. When all nodes are added to the graph (N-3 nodes added in total), the final graph is constructed.</p>\n\n<p>I\'m asked, what is the maximum number of nodes in this graph that can be visited exactly once (except for the initial node), i.e., what is the maximum number of nodes contained in the largest Hamiltonian path of the given graph. <em>(Okay, saying largest Hamiltonian path is not a valid phrase, but considering the question\'s nature, I need to find a max. number of nodes that are visited once and the trip ends at the initial node. I thought it can be considered as a sub-graph which is Hamiltonian, and consists max. number of nodes, thus largest possible Hamiltonian path).</em></p>\n\n<p>I tried to apply <a href="http://en.wikipedia.org/wiki/Ore%27s_theorem" rel="nofollow">Ore\'s Theorem</a> but even for a small example graph, the Ore\'s Theorem might not be sufficient to tell if the graph is Hamiltonian even though it strikes you directly that it is Hamiltonian.</p>\n\n<p>I thought I might use BFS since It\'s used to detect cycles in a graph: I needed to find the largest cycle which contained all the nodes in that cycle but given a large number of nodes, this approach might be slow and not desirable in my case since the timing will be crucial. For now this option is the last option if I can\'t come up with a solution.</p>\n\n<p>After some thinking, I thought whatever the number of nodes will be, the graph seems to be Hamiltonian due to node addition criteria. The problem is I can\'t be sure and I can\'t prove it. Does adding nodes in that fashion, i.e. adding new nodes with 2 edges which connect the added node to the existing nodes, alter the Hamiltonian property of the graph? If it doesn\'t alter the Hamiltonian property, how so? If it does alter, again, how so?\nThanks.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>I, again, realized that building the graph the way I described might alter the Hamiltonian property. Consider an input given as follows:</p>\n\n<pre><code>1 3\n2 3\n1 5\n1 3\n</code></pre>\n\n<p>these input says that 4th node is connected to node 1 and node 3, 5th to node 2 and node 3 . . .</p>\n\n<p>4th and 7th node are connected to the same nodes, thus lowering the maximum number of nodes that can be visited exactly once, by 1. If i detect these collisions (including an input such as 3 3) and lower the maximum number of nodes, starting from N, I believe I can get the right result.</p>\n\n<p>See, I do not choose the connections, they are given to me and I have to find the max. number of nodes.</p>\n\n<p>I think counting the same connections while building the graph and subtracting it from N will give the right result? Can you confirm this or is there a flaw with this?</p>\n', 'ViewCount': '132', 'Title': 'Is this graph a hamiltonian graph?', 'LastEditorUserId': '6998', 'LastActivityDate': '2013-04-07T14:12:52.047', 'LastEditDate': '2013-04-07T12:39:16.870', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6998', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-04-06T22:20:40.597', 'Id': '11081''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have to solve the following problem:</p>\n\n<blockquote>\n  <p>Consider the problem Connected:</p>\n  \n  <p><strong>Input:</strong> An unweighted, undirected graph $G$.</p>\n  \n  <p><strong>Output:</strong> True if and only if $G$ is connected.</p>\n  \n  <p>Show that Connected can be decided in polynomial time.</p>\n</blockquote>\n\n<p>I have been at this for hours, and I can't seem to find a way to prove this.\nAny hints?</p>\n", 'ViewCount': '384', 'Title': 'How to check whether a graph is connected in polynomial time?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-20T10:18:03.417', 'LastEditDate': '2013-04-10T08:49:17.583', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7643', 'Tags': '<algorithms><complexity-theory><graph-theory><polynomial-time>', 'CreationDate': '2013-04-10T00:08:01.310', 'Id': '11177''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If I am given a graph which forms a tree, I am interested in finding a vertex which maximizes the minimum distance to any leaf.</p>\n\n<p>I am sure this problem has been studied before.\nDoes anybody know the name of this problem or an algorithm for solving it?</p>\n', 'ViewCount': '250', 'Title': 'Given a tree, find a vertex which maximizes the minimum distance to any leaf', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T22:49:24.883', 'LastEditDate': '2013-04-10T21:35:43.710', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11212', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7675', 'Tags': '<algorithms><graph-theory><reference-request><trees>', 'CreationDate': '2013-04-10T21:05:36.970', 'Id': '11208''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>A bridge (critical edge) in an undirected graph is an edge whose removal increases the number of connected components.</p>\n\n<p>I need to determine all critical edges in an undirected graph, in $O(V+E)$ time. From what I found out, I need to use a modified DF search, but all pseudo-code algorithms I found have <code>low[v]</code> and <code>d[v]</code> which I don't understand.</p>\n\n<p>Can someone please explain to me the $O(V+E)$ bridge determination algorithm?</p>\n", 'ViewCount': '257', 'Title': 'Bridge determination in undirected graphs', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-11T14:22:16.190', 'LastEditDate': '2013-04-11T14:22:16.190', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'user7681', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal>', 'CreationDate': '2013-04-11T13:18:37.097', 'Id': '11229''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let's say we a have flow network with $m$ edges and integer capacities. </p>\n\n<p>Prove that there exists a sequence of at most $m$ augmenting paths that yield the maximum flow.</p>\n\n<p>A good way to start thinking about this is to imagine that we know the maximum flow already.  How can we figure the sequence of $m$ paths?</p>\n", 'ViewCount': '310', 'Title': 'Maximum number of augmenting paths in a network flow', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-16T02:07:47.667', 'LastEditDate': '2013-04-15T08:17:49.407', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '11351', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Tags': '<graph-theory><combinatorics><network-flow>', 'CreationDate': '2013-04-13T16:06:42.840', 'Id': '11288''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a positively weighted DAG (directed acyclic graph) $D = (V,E)$, can you create a new non-weighted DAG $D'$ by converting each edge with weight $w(e) = x$ into x non-weighted edges and vertices? I believe this would take $O(|E|+W)$ time where $|E|$ is the number of edges and $W$ is the total weight of all edges. My concern is whether I can include this weight variable and still consider this algorithm to be in polynomial time.</p>\n\n<p>(NOTE: This algorithm may apply to all positively weighted graphs, not just DAGs.)</p>\n", 'ViewCount': '37', 'Title': 'Can you convert a positively weighted DAG into a non-weighted DAG in polynomial time?', 'LastActivityDate': '2013-04-15T22:05:19.823', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11344', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7715', 'Tags': '<algorithms><graph-theory><graphs><algorithm-analysis><polynomial-time>', 'CreationDate': '2013-04-15T20:19:10.183', 'Id': '11343''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '175', 'Title': 'Transforming an arbitrary cover into a vertex cover', 'LastEditDate': '2013-04-19T19:42:54.777', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4259', 'FavoriteCount': '0', 'Body': "<p>Given is a planar graph $G=(V,E)$ and let $\\mathcal{G}$ denote its embedding in the plane s.t. each edge has length $1$. \nI have furthermore a set $C$ of points where each point $c \\in C$ is contained in $\\mathcal{G}$. Furthermore, it holds  for any point $p$ in $\\mathcal{G}$ that there exists a $c \\in C$ with  geodesic distance to $p$ at most one. (The distance is measured as the shortest distance within $\\mathcal{G}$.)</p>\n\n<p>I want to argue that given a $C$ for which the above condition holds, I can easily transform it into a vertex cover, or put differently, transform it into a $C'$ of same cardinality s.t any $c \\in C'$ is placed in $\\mathcal{G}$  at a vertex of $G$, and $C'$ still covers $G$.</p>\n\n<p>My approach was to orient the edges and move the points in $C$ at the end vertex of the arc. But so far I did not find a correct orientation which yields $C'$ from $C$.</p>\n\n<p>Does anybody have an idea?</p>\n", 'Tags': '<algorithms><graph-theory><set-cover>', 'LastEditorUserId': '4259', 'LastActivityDate': '2013-04-22T16:50:16.823', 'CommentCount': '2', 'AcceptedAnswerId': '11416', 'CreationDate': '2013-04-16T00:49:10.817', 'Id': '11347''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given an undirected graph $G = (V,E)$, what is the clique number $\\omega(G)$ given $|E|$, <em>i.e.</em>, the size of the largest clique in a graph with $|E|$ edges.</p>\n\n<p>I think this is doable after realizing that the number of edges in a clique is equal to the <em><a href="http://en.wikipedia.org/wiki/Triangular_number" rel="nofollow">triangular number</a></em>:\n$$|E(K_k)| = \\frac{1}{2}k(k-1).$$</p>\n\n<p>I am looking for a closed formula.</p>\n', 'ViewCount': '219', 'Title': 'Size of maximum clique given a fixed amount of edges?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-17T14:16:52.153', 'LastEditDate': '2013-04-17T14:16:52.153', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7715', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-04-16T19:12:03.283', 'Id': '11360''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>One topic I\'ve recently looked at is <a href="http://en.wikipedia.org/wiki/Co-occurrence_networks" rel="nofollow">co-occurence networks</a> formed from <a href="https://twitter.com/" rel="nofollow">Twitter</a> tweets.  This is how I felt after looking at the tweets of random people:</p>\n\n<p><img src="http://i.stack.imgur.com/j7uxM.png" alt="Professor Farnsworth: &quot;I don\'t want to live on this planet anymore.&quot;"></p>\n\n<p>This leads me to the question:</p>\n\n<blockquote>\n  <p><strong>Question</strong>: Is it possible to discern the quality of web data from networks derived from it?</p>\n</blockquote>\n\n<p><em>A hypothetical situation</em>: Suppose we have two networks of comparable size derived from two different web sources: Network X is from a high-quality source (perhaps government documents) and Network Y is from a low-quality source (perhaps some random blog).  <em>Which network is from a higher quality source: Network X or Network Y?</em></p>\n\n<p>I\'m intentionally leaving out specifics about the networks in this question, since I\'m intending this to be more of a proof-of-concept style question.</p>\n', 'ViewCount': '30', 'Title': 'Is it possible to discern the quality of web data from networks derived from it?', 'LastActivityDate': '2013-04-18T17:16:53.770', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2254', 'Tags': '<graph-theory><data-mining>', 'CreationDate': '2013-04-18T17:16:53.770', 'Id': '11384''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>In a directed graph, the indegree of a node is the number of incoming edges and\nthe outdegree is the number of outgoing edges. Show that the following problem\nis NP-complete. Given an undirected graph G and a designated subset C of G\u2019s\nnodes, is it possible to convert G to a directed graph by assigning directions to each\nof its edges so that every node in C has indegree 0 or outdegree 0, and every other\nnode in G has indegree at least 1?</p>\n\n<p>I need an idea how to prove it</p>\n', 'ViewCount': '339', 'Title': 'Can the edges of a graph be assigned directions such that all nodes in a given subset have in- or outdegree 0, and every other node indegree > 0?', 'LastEditorUserId': '917', 'LastActivityDate': '2013-10-08T10:57:13.280', 'LastEditDate': '2013-10-08T10:57:13.280', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7783', 'Tags': '<complexity-theory><graph-theory><np-complete><np-hard>', 'CreationDate': '2013-04-19T06:22:19.890', 'FavoriteCount': '1', 'Id': '11398''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This problem is about finding a route on a square grid.\nThe starting point is $(1,1)$ and the target point $(n,m)$.\nI can move each step from my current point $(x,y)$ either to $(x+y,y)$ or $(x,y+x)$.\nNow I need to determine if there is a path from $(1,1)$ to $(n,m)$, and if so to return the shortest one.</p>\n\n<p>Now I believe that if I trace back my steps from the input point $(n,m)$ I can always know which move I made out of the two possible ones since if $n=m$ then there is no route, this means I'm always take the smaller coordinate and subtract it from the bigger one.\nBut that means I have at most only one possible route to $(n,m)$ so why was  I asked to return the shortest one?</p>\n\n<p>Am I missing anything ?</p>\n", 'ViewCount': '188', 'Title': u'Route on a square grid with only (x,y) \u2192 (x,x+y) and (x,y) \u2192 (x+y,y) moves', 'LastEditorUserId': '39', 'LastActivityDate': '2013-04-20T23:28:40.130', 'LastEditDate': '2013-04-20T23:28:40.130', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6632', 'Tags': '<algorithms><graph-theory><shortest-path><square-grid>', 'CreationDate': '2013-04-20T13:56:24.683', 'Id': '11427''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>Pebbling is a solitaire game played on an undirected graph $G$ , where\n  each vertex has zero or more pebbles. A single pebbling move consists\n  of removing two pebbles from a vertex $v$ and adding one pebble to an\n  arbitrary neighbor of $v$ . (Obviously, the vertex v must have at\n  least two pebbles before the move.) The PebbleDestruction problem\n  asks, given a graph $G = ( V; E )$ and a pebble count $p ( v )$ for\n  each vertex $v$ , whether there is a sequence of pebbling moves that\n  removes all but one pebble. Prove that PebbleDestruction is\n  NP-complete.</p>\n</blockquote>\n\n<p>First, I show that it is in NP since I can verify the solution in polynomial time, tracing back the pebble count from just one pebble.</p>\n\n<p>Next, what are some ideas on which problems to use as the basis for a polynomial-time reduction?</p>\n\n<p>Would something like vertex cover work? Or a vertex cover of different sizes? </p>\n\n<p>If so, how can it handle the varying number of pebbles on each move?</p>\n\n<p>Thank You.</p>\n\n<p>From: <a href="http://courses.engr.illinois.edu/cs473/sp2011/hw/disc/disc_14.pdf" rel="nofollow">http://courses.engr.illinois.edu/cs473/sp2011/hw/disc/disc_14.pdf</a></p>\n', 'ViewCount': '199', 'Title': 'Pebbling Problem', 'LastEditorUserId': '903', 'LastActivityDate': '2013-07-09T16:23:27.433', 'LastEditDate': '2013-05-01T01:25:01.613', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '7812', 'Tags': '<algorithms><graph-theory><np-complete>', 'CreationDate': '2013-04-20T21:30:03.620', 'FavoriteCount': '2', 'Id': '11443''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is NOT HW, this is from Skienas book, and I just couldn't solve it at all.</p>\n\n<p>Please give me a hand here, in understanding and solving it, thanks.</p>\n\n<p>Let G = (V, E) be a binary tree. The distance between two vertices in G is the length of the path connecting these two vertices, and the diameter of G is the maximal distance over all pairs of vertices. Give a linear-time algorithm to find the diameter of a given tree. (*)</p>\n\n<p>I figured I'd do a DFS, and increment on each node in terms of the depth of the tree</p>\n", 'ViewCount': '51', 'ClosedDate': '2013-04-21T23:06:21.807', 'Title': 'LInear time algorithm to find the diameter of a tree', 'LastEditorUserId': '139', 'LastActivityDate': '2013-04-21T23:43:53.940', 'LastEditDate': '2013-04-21T19:20:21.703', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><graph-theory><graphs><algorithm-analysis><search-problem>', 'CreationDate': '2013-04-21T17:47:36.077', 'Id': '11470''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Basically, I am looking for a (well-defined) term for some "<em>borderline</em>" vertexes interconnecting other vertices <em>in</em> and <em>outside of</em> a given connected component.</p>\n\n<p>More specifically, given directed graph $G = (V_G, E_G)$ and (strongly) connected component $C = (V_C, E_C)$, how do people refer to such vertices $x$, where,</p>\n\n<ol>\n<li>$x \\in V_C$;</li>\n<li>$\\exists\\ v \\in V_G \\setminus V_C$ such that $(x, v) \\in E_G \\setminus E_C$;</li>\n</ol>\n\n<p>My friends have suggested names such as <em>gateway vertex</em> and <em>border vertex</em>. But I feel obliged to make sure we are not reinventing something well-known / well-defined.</p>\n\n<p>It would be helpful if someone can help identify an equivalent (or likewise) definition of this concept in the literature. Thanks a lot.</p>\n\n<p>EDIT:</p>\n\n<p>Please note that -- unlike the well-defined concept of <em>cut vertex</em> -- the concept of <em>borderline vertex</em> (or whatever it should be called) is with respect to a <em>specific</em> given <strong>component</strong>, <em>not</em> the entire graph.</p>\n', 'ViewCount': '67', 'Title': 'Terminology for vertices in graph connecting vertices "in" and "outside of" a given component', 'LastEditorUserId': '7644', 'LastActivityDate': '2013-04-22T14:51:24.510', 'LastEditDate': '2013-04-22T14:51:24.510', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7644', 'Tags': '<graph-theory><terminology><graphs>', 'CreationDate': '2013-04-22T11:09:18.577', 'Id': '11485''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>From Skiena's book:</p>\n\n<p>Let $G = (V,E,w)$ be a directed weighted graph such that all the weights are positive. Let $v$ and $u$ be two vertices in $G$ and $k \\leq |V|$ be an integer. Design an algorithm to find the shortest path from $v$ to $u$ that contains exactly $k$ edges. Note that the path need not be simple.</p>\n\n<p>This is <strong>not homework</strong>, its me preparing for an interview. I have no clue how to approach this.</p>\n", 'ViewCount': '614', 'Title': 'Shortest path with exactly $k$ edges', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-05-23T14:44:05.013', 'LastEditDate': '2013-05-23T14:44:05.013', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-04-22T23:22:16.367', 'FavoriteCount': '1', 'Id': '11503''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Consider this problem: </p>\n\n<blockquote>\n  <p>Given an undirected graph $G = (V, E)$, find $G' = (V', E')$ such that:</p>\n  \n  <ol>\n  <li>$G'$ is an induced subgraph of $G$</li>\n  <li>$G'$ has no 3-cliques</li>\n  <li>$|V'|$ is maximal</li>\n  </ol>\n</blockquote>\n\n<p>So the least number of vertices must be eliminated from $G$ so that 3-cliques are eliminated.</p>\n\n<p>An equivalent problem would be to find a 2-coloring for $G$ such that if $(v_1, v_2, v_3) \\in V$ and $((v_1, v_2), (v_2, v_3), (v_3, v_1)) \\in V$, </p>\n\n<ol>\n<li><p>$(v_1.color == v_2.color \\wedge v_2.color == v_3.color \\wedge v_3.color == v_1.color) = False$</p></li>\n<li><p>The (absolute) difference between the number of nodes with color 1 and the number of nodes with color 2 is maximal.</p></li>\n</ol>\n\n<p>Can anyone think of a polynomial-time algorithm to solve one of these problems?</p>\n", 'ViewCount': '155', 'Title': 'Finding the largest 3-clique-free induced subgraph', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T10:36:57.313', 'LastEditDate': '2013-04-24T06:13:48.183', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '11534', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3101', 'Tags': '<algorithms><graph-theory><graphs><optimization>', 'CreationDate': '2013-04-23T15:30:56.217', 'Id': '11518''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to construct d-regular expander graph for some small fixed d (like 3 or 4) of n vertices.</p>\n\n<p>What is the easiest method to do this in practice? \nConstructing a random d-regular graph, which is proven to be a.a.s. an expander?</p>\n\n<p>I also read about Margulis constructions and Ramanujan graphs that are expanders and a construction using a zig-zag product. Wikipedia gives a nice but very short overview: <a href="http://en.wikipedia.org/wiki/Expander_graph#cite_note-10">http://en.wikipedia.org/wiki/Expander_graph#cite_note-10</a>\nBut which method do I choose in practice?</p>\n\n<p>For me, these methods seem all very complicated to implement and in particular to understand and maybe quite specific.\nAren\'t there easier methods, maybe based on permutations or so, to practically generate a sequence of d-regular expander graphs?  </p>\n\n<p>Is it maybe easier to construct d-regular bipartite expander graphs?</p>\n\n<p>I also have another question: What about families of bad d-regular expanders? Does such a notion make sense? Can one construct a family of d-regular graphs (that are of course connected) that is as bad as possible in the sense of an expander?</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '200', 'Title': 'How to practically construct regular expander graphs?', 'LastEditorUserId': '7309', 'LastActivityDate': '2014-01-19T18:58:28.767', 'LastEditDate': '2013-04-24T16:42:32.183', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '7309', 'Tags': '<graph-theory><combinatorics><cryptography><discrete-mathematics><expanders>', 'CreationDate': '2013-04-24T13:37:26.307', 'FavoriteCount': '3', 'Id': '11538''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose you are given a polynomial-time algorithm for the following problem related to INDEPENDENT SET:</p>\n\n<p>INDEPENDENT SET VALUE</p>\n\n<p>Input: An undirected graph G.</p>\n\n<p>Output:The size of the largest independent set in G (but not the set itself).</p>\n\n<p>Show how you can use this algorithm to solve the INDEPENDENT SET problem in polynomial time: given a graph G, return an independent set which is as large as possible.</p>\n\n<p>Any help would be really appreciated. I am pretty lost in this question</p>\n', 'ViewCount': '132', 'Title': 'How to reduce INDEPENDENT SET to INDEPENDENT SET SIZE?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-26T09:48:23.050', 'LastEditDate': '2013-04-26T09:48:23.050', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7909', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions>', 'CreationDate': '2013-04-26T08:16:10.927', 'FavoriteCount': '1', 'Id': '11570''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Famous PPAD class of problems is  formally defined by specifying one of its complete problems, known as <a href="http://en.wikipedia.org/wiki/PPAD_%28complexity%29" rel="nofollow">End-Of-The-Line</a>:</p>\n\n<p><strong>End-Of-The-Line Problem:</strong>\n$G$ is a (possibly exponentially large) directed graph with no isolated vertices, and with every vertex having at most one predecessor and one successor. $G$ is specified  by giving a polynomial-time computable function $f(v)$ (polynomial in the size of $v$) that returns the predecessor and successor (if they exist) of the vertex $v$. Given a vertex $s$ in $G$ with no predecessor, find a vertex $t\u2260s$ with no predecessor or no successor. (The input to the problem is the source vertex s and the function $f(v)$). In other words, we want any source or sink of the directed graph other than $s$.</p>\n\n<p>Let\'s consider the slightly augmented version of End-Of-The-Line problem.</p>\n\n<p><strong>End-Of-The-Line Augmented Problem:</strong> The definition is same as for End-Of-The-Line expect that it\'s required to find not a vertex $t\u2260s$ with no predecessor or no successor, but the exact end of the path of the given source vertex $s$.</p>\n\n<p>Intuitively, it seems like <strong>End-Of-The-Line Augmented Problem</strong> is not more in PPAD, just because it requires something more stronger than <strong>End-Of-The-Line Problem</strong>. How to show that <strong>End-Of-The-Line Augmented Problem</strong> is NP-hard?</p>\n', 'ViewCount': '49', 'Title': 'End-Of-The-Line Augmented Problem of PPAD', 'LastEditorUserId': '4778', 'LastActivityDate': '2013-04-28T05:38:26.623', 'LastEditDate': '2013-04-28T05:38:26.623', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4778', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-04-27T15:20:01.477', 'Id': '11604''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to determine which complexity class this problem belongs to:</p>\n\n<blockquote>\n  <p>Given a graph $G(V, E)$, two vertices $u$ and $v$ and a natural number $k$, does a path of length $k$ exist between thesee two vertices?</p>\n</blockquote>\n\n<p>How can I approach this problem to solve it?</p>\n', 'ViewCount': '131', 'Title': 'k-path problem - P, NP or NPC?', 'LastEditorUserId': '903', 'LastActivityDate': '2013-05-31T17:08:03.723', 'LastEditDate': '2013-05-01T01:25:11.237', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7981', 'Tags': '<complexity-theory><graph-theory><np-complete><np>', 'CreationDate': '2013-04-30T18:55:29.343', 'Id': '11680''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Question: If $H = \\{(G,m)$ $|$ $G$ is a graph with $m$ distinct Hamiltonian cycles $\\}$ ($m$ is in binary), prove that $H \\in$ polynomial space.</p>\n\n<p>My thoughts: I thought that I could show that $H \\in NP$, by which it would automatically follow that $H \\in$ polynomial space. By the witness theorem, the $m$ distinct Hamiltonian cycles (call them the set $C$) would serve as a witness. However, what is not apparent is if $|C| \\leq |G|^k$. In fact, that is the entire problem, isn't it? What am I thinking about wrong over here?</p>\n", 'ViewCount': '50', 'Title': 'Finding Hamiltonian cycles in polynomial space', 'LastActivityDate': '2013-05-01T16:48:02.180', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8000', 'Tags': '<graph-theory><np>', 'CreationDate': '2013-05-01T16:22:53.083', 'Id': '11698''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am trying to understand an algorithm  presented in <a href="http://www.cc.gatech.edu/dimacs10/papers/%5B13%5D-dimacs_stable_community.pdf" rel="nofollow">Using Stable Communities for Maximizing Modularity</a> by S. Srinivasan and S. Bhowmick, <strong>along with its complexity results</strong>. (The complete algorithm is presented on page 7, in pseudocode.)</p>\n\n<p>As I understand it, the idea of the algorithm is to identify densely connected communities (basically, subgraphs) in a graph, such that any subset of vertices in the community has more connections (that is, edges pointing to another vertex) inside the community than to any other community in the graph.</p>\n\n<p>Below I\'ve cited the part of the algorithm I\'m having trouble with:</p>\n\n<pre><code>For all vertices v_i in network N that are not in any stable community\n    Create a subset S of v_i and its neighbors  \n        For each neighbor n_j\n            ...\n            Identify y_j, the subset of external neighbors \n            which are all within distance k of each other\n</code></pre>\n\n<p>I take "external neighbors" to mean the neighbours of $n_j$ that aren\'t in $S$, and where the distance between them is also never measured through $S$ (as otherwise, they would never be more than two hops apart\u2014through $n_j$).</p>\n\n<p>The authors state the following about the complexity of this part:</p>\n\n<blockquote>\n  <p>...the average degree of a vertex is $d$...</p>\n  \n  <p>...the complexity for computing $y_j$ for all possible values of $k$ is $O(d^3)$.</p>\n</blockquote>\n\n<p>On the next page, the authors make some more statements about the complexity of this part, including that the values of the shortest paths between external vertices <em>can be reused</em> for many neighbours and that <em>setting $k$ to small values (2\u20144) is sufficient in most cases</em>. I\'m not sure if these considerations are already factored in, however I\'m a bit stuck on "all possible values of $k$" in the above quotation.</p>\n\n<p>My question is: what assumptions are necessary for the complexity result $O(d^3)$ to hold, with $d$ being the average degree of a vertex? How is the subset found in this case?</p>\n', 'ViewCount': '72', 'Title': 'Complexity of finding a subset of vertices within distance k of each other, given a set of vertices', 'LastActivityDate': '2013-05-05T12:58:25.270', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8057', 'Tags': '<graph-theory><time-complexity>', 'CreationDate': '2013-05-05T12:58:25.270', 'Id': '11803''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Modification of vertex cover problem.<br>\nGiven a graph G,does G have a vertex cover with 10 vertices? Is this problem still in NP?<br>\nGiven a graph G and integer k, does G have a vertex cover with k vertices?<br>\nIs there any important difference between this two problems? </p>\n', 'ViewCount': '56', 'Title': 'Vertex Cover problem modification', 'LastEditorUserId': '8072', 'LastActivityDate': '2013-05-07T19:56:29.067', 'LastEditDate': '2013-05-07T19:02:16.443', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11861', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8072', 'Tags': '<graph-theory><np>', 'CreationDate': '2013-05-07T18:57:10.810', 'Id': '11860''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '285', 'Title': 'Reducing from Hamiltonian Cycle problem to the Graph Wheel problem', 'LastEditDate': '2013-05-10T18:21:49.337', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7336', 'Body': '<p>EDIT: This question is different from the other in a sense that unlike it this one goes into specifics and is intended to solve the problem. In the previous post, the only answer was a hint. In this post, the answer is a proper solution. </p>\n\n<p>Is there a way to "polynomialy" reduce the problem of finding graph wheel $W_{n}$ to the problem of detecting Hamiltonian Cycle \n(or vice versa) ? The ultimate goal is to show that finding $W_n$ is NP-complete problem. So far I can show that the problem is in NP. To show that I claim that given an input of graph it is possible in polynomial time to check every vertex and to make sure that it has three edges(except the hub): one goes to the hub, one goes to the next vertex and one to the previous vertex. By checking every vertex in this fashion one can make sure the "ticket" indeed represents $W_{n}$.</p>\n\n<p>As far as converting from the Hamiltonian Cycle problem to the problem of fining $W_n$ goes I have encountered that $W_n$ has many Hamiltonian cycles inside it.It is easy to see if one imagines a wheel with  a hub and bunch of spokes. Every triangle created by the spokes forms a Hamiltonian cycle as well as any other "closed loop" formed inside a given $W_{n}$. </p>\n\n<p>The intriguing part is the fact that only one vertex is in "the way" and that vertex is the hub. Is the hub of the wheel main culprit in figuring out the conversion ?</p>\n', 'ClosedDate': '2013-05-10T09:37:44.963', 'Tags': '<graph-theory><np-complete>', 'LastEditorUserId': '7336', 'LastActivityDate': '2013-05-10T21:34:34.490', 'CommentCount': '1', 'AcceptedAnswerId': '11917', 'CreationDate': '2013-05-09T16:52:55.897', 'Id': '11915''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>My task is to give proof, the Vertex-Cover problem is NP-complete, assuming it's already shown that the Stable-Set problem is NP-complete, too.</p>\n\n<p>My approach: i know, Stable-Set is NP-complete, and all Problems that are NP-complete can be reduced to each other. If i could solve one NP-complete problem, i might be able to solve all NP-complete problems. It should be possible to create a function with polynomial complexity to reduce Vertex-Cover to Stable-Set. At least, this was, what my Professor told.</p>\n\n<p>Now all i have to do, is to find this polynomial function, in order to Show that Vertex-Cover is NP-complete. But here is where i am stuck.. so i need some advice how to build such functions.</p>\n", 'ViewCount': '415', 'Title': 'Show that Vertex-Cover is NP-complete, using Stable-Set', 'LastActivityDate': '2013-05-11T21:05:26.027', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11955', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6828', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-05-11T20:04:02.480', 'Id': '11954''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a Bayesian Network $N$, one can build a junction/joint tree $JT$ over $N$ by applying series of steps (namely, moralisation,triangulation..etc). Then we can use $JT$ to answer queries over $N$.</p>\n\n<p>My question is: what makes BN decomposable into $JT$? The structure (along with the CPTs) must exhibit certain conditions otherwise any graphical model is decomposable.  </p>\n', 'ViewCount': '97', 'Title': 'What makes Bayesian Networks decomposable into joint trees?', 'LastActivityDate': '2013-05-15T08:38:34.180', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12035', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graph-theory><probability-theory><trees>', 'CreationDate': '2013-05-13T02:30:42.550', 'Id': '11983''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a directed graph with the following attributes: - a chain from node $a$ to node $z$ passing nodes $b$ to $y$ exists and is unidirectional. - additionally a set of nodes having bidirectional vertices to at least two of the nodes $a \\ldots z$ exists. These nodes are connected in a second unidirectional chain.</p>\n\n<p><img src="http://i.stack.imgur.com/W1NjY.png" alt="enter image description here"></p>\n\n<p>(the red route is the requested result, the squares are the first chain (unidirectional) and the circles are the second chain (unidirectional). $1$ is the start node and $5$ is the destination node.)</p>\n\n<p>Is it possible to find the shortest path from $a$ to $z$ that includes nodes $b$ to $y$ and the additional nodes once without probing all possibilities?</p>\n\n<p>I think the problem is roughly the same as the minimal traveling salesman problem since adding a vertex from $z$ to $a$ will result in the min-TSP - but this problem is slightly easier since a path from $a$ to $z$ is already known.</p>\n', 'ViewCount': '145', 'Title': u'Is \u201cFind the shortest tour from a to z passing each node once in a directed graph\u201d NP-complete?', 'LastEditorUserId': '8188', 'LastActivityDate': '2013-05-16T07:26:57.557', 'LastEditDate': '2013-05-16T06:17:36.050', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12061', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8188', 'Tags': '<algorithms><graph-theory><graphs><np-complete>', 'CreationDate': '2013-05-15T11:03:35.493', 'Id': '12036''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1087', 'Title': 'Graph Has Two / Three Different Minimal Spanning Trees?', 'LastEditDate': '2013-05-15T20:00:02.037', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8202', 'FavoriteCount': '0', 'Body': "<p>I'm trying to find an efficient method of detecting whether a given graph G has two different minimal spanning trees. I'm also trying to find a method to check whether it has 3 different minimal spanning trees. The naive solution that I've though about is running Kruskal's algorithm once and finding the total weight of the minimal spanning tree. Later , removing an edge from the graph and running Kruskal's algorithm again and checking if the weight of the new tree is the weight of the original minimal spanning tree , and so for each edge in the graph. The runtime is O(|V||E|log|V|) which is not good at all, and I think there's a better way to do it.</p>\n\n<p>Any suggestion would be helpful, thanks in advance</p>\n", 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-17T21:55:27.857', 'CommentCount': '5', 'AcceptedAnswerId': '12058', 'CreationDate': '2013-05-15T18:45:13.007', 'Id': '12048''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am having trouble trying to formulate a simple proof. I can clearly see that what I am trying to prove is correct but to prove it I am not sure what to do.</p>\n\n<p>The problem is a broadcasting problem on a graph. My graph contains two cycles. The two cycles are joined by a single vertex $v$. If the vertex $v$ contains some info that it wants to broadcast to all other vertices on the graph what is the minimum number of rounds required to achieve this.</p>\n\n<p>So a proof I am trying to formulate is that in order to achieve the minimum broadcast time I would have to first broadcast on the largest of the two cycles.</p>\n\n<p>I was thinking of a proof by contradiction. Something like assume that we first broadcast on the smaller cycle and somehow show that it could lead to a broadcast time that is larger than the time if we were to start on the larger cycle.</p>\n\n<p>To clarify, suppose we have two cycles $C_1$ and $C_2$ such that $|C_1| \\ge |C_2|$. So the minimum broadcast time from vertex $v$ denoted by $b(v)$ would require us to broadcast on the larger cycle first.</p>\n', 'ViewCount': '83', 'Title': 'Proof that fast broadcasts have to target larger cycles first', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-30T23:53:38.257', 'LastEditDate': '2013-05-30T23:53:38.257', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory>', 'CreationDate': '2013-05-16T17:02:32.177', 'Id': '12078''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $G = (V,E)$ be a directed graph  with a weight function $w$ such that there are no negative-weight cycles, and let $v \\in V$ be a vertex such that there is a path from $v$ to every other vertex. Let $f : V \\to \\mathbb R$ be a given function. Describe an algorithm that runs in $O(|V| + |E|)$ time that answers yes/no to the question: is it true that for all $u \\in V, f(u) = \\delta(v,u)$, where $\\delta(v,u)$ is the weight of the shortest path from $v$ to $u$?</p>\n\n<p>Obviously what comes to mind is Bellman-Ford algorithm, but it doesn't satisfy the time requirement. I don't really see how having the candidate $f$ function helps us in this regard.</p>\n", 'ViewCount': '194', 'Title': 'Shortest paths candidate', 'LastActivityDate': '2013-06-05T15:32:06.230', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12126', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8247', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-05-18T19:19:11.787', 'Id': '12120''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to estimate the graph in very high dimensional data, I mean with million nodes. Up to now all the papers that I have found, they are limited to few thousands.</p>\n\n<p>All of them like graphical lasso, non parnormal, they use the estimated covariance matrix and then use the gaussian likelihood function which they optimize to find the precision matrix, which actually encodes the graph structure</p>\n\n<p>In my case, I have million nodes. So if I try to estimate the covariance matrix at the beginning, that is a dense matrix of 1 million x 1 million. I will run out of memory with that</p>\n\n<p>I wanted to know if any methods have been devised that actually deal with this issue. Or this problem is unsolved?</p>\n', 'ViewCount': '58', 'Title': 'Graph estimation in high dimensional data', 'LastActivityDate': '2013-05-20T02:17:06.667', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6999', 'Tags': '<graph-theory><machine-learning>', 'CreationDate': '2013-05-20T02:17:06.667', 'Id': '12146''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '270', 'Title': 'Longest cycle contained in two cycles', 'LastEditDate': '2013-05-22T13:39:21.057', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6970', 'FavoriteCount': '4', 'Body': "<p>Is the following problem NP-complete? (I assume yes).</p>\n\n<blockquote>\n  <p><strong>Input:</strong> $k \\in \\mathbb{N},G=(V,E)$ an undirected graph where the edge set can be decomposed into two edge-disjoint simple cycles (these are <strong>not</strong> a part of the input).</p>\n  \n  <p><strong>Question:</strong> Is there a simple cycle in $G$ with length greater than $k$?</p>\n</blockquote>\n\n<p>Obviously the problem is in NP and the maximum degree in $G$ is $\\leq 4$, but that doesn't seem to help.</p>\n", 'Tags': '<graph-theory><np-complete><decision-problem>', 'LastEditorUserId': '6970', 'LastActivityDate': '2013-05-25T21:42:25.810', 'CommentCount': '6', 'AcceptedAnswerId': '12270', 'CreationDate': '2013-05-20T07:07:18.790', 'Id': '12148''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let G be a directed graph with non-negative weights. We call a path between two vertices an "odd path" if its weight is odd.</p>\n\n<p>We are looking for an algorithm for finding the weight of the shortest odd path between any two vertices in the graph.</p>\n\n<p>If possible, describe one algorithm that is reduction-based (that is, make some modification to the graph so that application of Floyd-Warshall, or any other "known" algorithm, and then deciphering the answer will give the result, see <a href="http://en.wikipedia.org/wiki/Reduction_(complexity)" rel="nofollow">http://en.wikipedia.org/wiki/Reduction_(complexity)</a>) and one that is "direct" (that is, make some modification to Floyd-Warshall in order for it to solve this problem).</p>\n', 'ViewCount': '301', 'Title': 'Shortest path with odd weight', 'LastActivityDate': '2013-05-22T07:57:41.470', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '12155', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8247', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-05-20T11:52:45.343', 'Id': '12154''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>i'm going to use the Christofides heuristic algorithm in order to solve a TSP for about 80 edges. Eventually i should have a solution, that is within the factor 1.5 of the optimum.</p>\n\n<p>But when i'm finished, i'd like to check my solution but i don't know how. So i thought about using a computer-program to find the optimal solution to see, if my solution is within the 3/2-range.</p>\n\n<p>i am not quite sure, if this is really possible or how long it might take. if it would take less than a month, i think, it would be worth a try.</p>\n", 'ViewCount': '63', 'Title': 'Is there a program to solve a metric TSP for 80 edges at optimum?', 'LastActivityDate': '2013-05-21T13:33:49.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12190', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6828', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-05-21T12:39:05.100', 'Id': '12184''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This was a question at SO, and I think it\'s very interesting, I thought about it, but I could not provide any efficient algorithm neither showing the NP-Hardness:</p>\n\n<blockquote>\n  <p>Find the length of the longest non-decreasing sequence through\n  adjacent, non-repeating cells (including diagonals). For example, in the\n  following grid, one legal path (though not the longest) that could be\n  traced is 0->3->7->9 and its length would be 4.</p>\n  \n  <p>8 2 4 </p>\n  \n  <p>0 7 1 </p>\n  \n  <p>3 7 9 </p>\n  \n  <p>The path can only connect adjacent locations (you could not connect 8 ->\n  9). The longest possible sequence for this example would be of length\n  6 by tracing the path 0->2->4->7->7->9 or 1->2->4->7->7->8.</p>\n</blockquote>\n\n<p>For first attempts and possible misinterpretations is not bad to see <a href="http://stackoverflow.com/questions/15553218/technical-interview-longest-non-decreasing-subsequence-in-mxn-matrix/15554014#15554014">this</a> answer at SO.</p>\n\n<p>My question: above problem is in $P$?</p>\n', 'ViewCount': '365', 'LastEditorDisplayName': 'user742', 'Title': 'Longest path in grid like graph', 'LastActivityDate': '2013-05-24T02:46:31.383', 'LastEditDate': '2013-05-23T23:29:03.860', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'OwnerDisplayName': 'user742', 'PostTypeId': '1', 'Tags': '<algorithms><complexity-theory><graph-theory>', 'CreationDate': '2013-05-23T23:20:39.770', 'FavoriteCount': '1', 'Id': '12239''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '185', 'Title': 'Team construction in tri-partite graph', 'LastEditDate': '2013-06-05T04:54:04.320', 'AnswerCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1342', 'FavoriteCount': '1', 'Body': '<p>The government wants to create a team with one <em>alchemist</em>, one <em>builder</em>, and one <em>computer-scientist</em>. </p>\n\n<p>In order to have good cooperation, it is important that the 3 team-members like each other. </p>\n\n<p>Therefore, the government gathers $k$ candidates of each profession, and creates their "liking" graph. This is a tri-partite graph, where there is an edge between $a$ and $b$ iff $a$ likes $b$.</p>\n\n<p>(Note that the "like" relation is symmetric but not transitive, i.e.: if $a$ likes $b$ then $b$ likes $a$, but if $a$ likes $b$ and $b$ likes $c$, then not necessarily $a$ likes $c$).</p>\n\n<p>Is this always possible to create a team? Of course not. For example, it is possible that no alchemist likes any builder.</p>\n\n<p>However, suppose the "liking" graph has the following property: <em>in each group of 3 alchemists and 3 builders, there is at least a single alchemist-builder pair that like each other; ditto for alchemists-computerists and builders-computerists</em>.</p>\n\n<p>Given this property, is this always possible to create a team where all 3 members like each other? If so, what is the minimum number of candidates of each type ($k$) that the government will have to gather?</p>\n\n<p>I would like to both find k and prove that it is the minimum.</p>\n\n<p>A possibly related sub-question is: in a group of $k$ alchemists and $k$ builders, what is the minimum number of pairs that like each other? For $k=3$, by the assumption of the question, that number is 1. What about $k&gt;3$?</p>\n\n<p>A third question is: what is the name of this kind of problems?</p>\n', 'Tags': '<graph-theory><graphs><combinatorics>', 'LastEditorUserId': '1342', 'LastActivityDate': '2013-06-27T12:54:50.907', 'CommentCount': '8', 'AcceptedAnswerId': '12926', 'CreationDate': '2013-05-25T19:02:19.567', 'Id': '12275''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Reachability is defined as follows:\na digraph $G = (V, E)$ and two vertices $v,w \\in V$. Is there a directed path from $v$ to $w$ in $G$?</p>\n\n<p>Is it possible to write a polynomial time algorithm for it?</p>\n\n<p>I asked this question on mathematics and got no answer by far.</p>\n', 'ViewCount': '109', 'Title': 'Does reachability belong to P?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T07:39:49.460', 'LastEditDate': '2013-05-28T07:11:56.720', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '21360', 'Score': '-3', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<complexity-theory><graph-theory><time-complexity>', 'CreationDate': '2013-05-26T05:57:18.243', 'Id': '12288''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Find the weight of the lightest path from u to v the goes through node a or/and b.</p>\n\n<p>Do you have a suggestion on how it can be done?</p>\n', 'ViewCount': '94', 'LastEditorDisplayName': 'user742', 'Title': 'Find the weight of the lightest path from u to v', 'LastActivityDate': '2013-09-20T09:34:09.967', 'LastEditDate': '2013-09-20T09:34:09.967', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '8361', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-05-26T07:55:17.363', 'FavoriteCount': '0', 'Id': '12291''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Here is the question:</p>\n\n<p>I have a given tree with n nodes. The task is to find the number of subtrees of the given tree with outgoing edges to its complement less than or equal to a given number K.</p>\n\n<p>for example: If <code>n=3</code> and <code>k=1</code></p>\n\n<p>and the given tree is    <code>1---2---3</code></p>\n\n<p>Then the total valid subtrees would be 6</p>\n\n<pre><code>{}, {1}, {3}, {1,2}, {2,3}, {1,2,3}\n</code></pre>\n\n<p>I know I can enumerate all <code>2^n</code> trees and chack the valid ones, but is there some approach that is faster? Can I achieve polynomial time in <code>n</code>? Something close to <code>O(n^3)</code> or even <code>O(n^4)</code> would be nice.</p>\n\n<p>for k=1 this value turns out to be <code>2*n</code></p>\n\n<p><strong>There was a solution provided for this one as:</strong></p>\n\n<p>This is a fairly typical instance of the DP-on-a-tree paradigm. Let's generalize the problem slightly by allowing the specification of a root vertex v and stratifying the counts of the small-boundary trees in two ways: whether v is included, and how many edges comprise the boundary.</p>\n\n<p>The base case is easy. There are no edges and thus two subtrees: one includes v, the other excludes v, and both have no boundary edges. Otherwise, let e = {v, w} be an edge incident to v. The instance looks like this.</p>\n\n<pre><code>|\\         /|\n| \\   e   / |\n|L v-----w R|\n| /       \\ |\n|/         \\|\n</code></pre>\n\n<p>Compute recursively the stratified counts for L rooted at v and R rooted at w.</p>\n\n<p>Subtrees that include v consist of a subtree in L that includes v, plus optionally e and a subtree in R that includes w. Subtrees that don't include v consist of either a subtree in L that doesn't include v, or a subtree in R (double counting the empty tree). This means we can obtain the stratified counts by convolving the stratified counts for L with the stratified counts for R.</p>\n\n<p>Here's how this works on your example. Let's choose root 1.</p>\n\n<pre><code>  e\n1---2---3\n</code></pre>\n\n<p>We choose e as shown and recurse.</p>\n\n<pre><code>1\n</code></pre>\n\n<p>The vector for includes-1 is [1], since the one subtree is {1}, with no boundary. The vector for excludes-1 is [1], since the one subtree is {}, also with no boundary.</p>\n\n<pre><code>2---3\n</code></pre>\n\n<p>We compute 2 and 3 as we did for 1. The vector for includes-2 is [1, 1], since {2, 3} has no boundary edges, and {2} has one. We obtained this vector by adding the includes-2 vector for 2, shifted by one because of the new boundary edge to make [0, 1], to the convolution of the includes-2 vector for 2 with the includes-3 vector for 3, which is [1, 0]. The vector for excludes-2 is [1] + [1, 1] - [1] = [1, 1], where [1, 1] is the sum of the shifted includes-3 vector and the excludes-3 vector, and the subtraction is to compensate for double-counting {}.</p>\n\n<p>Now, for the original invocation, to get the includes-1 vector, we add [0, 1], the includes-1 vector for 1 shifted by one, to the convolution of [1] with [1, 1], obtaining [1, 2]. To check: {1, 2, 3} has no boundary, and {1} and {1, 2} have one boundary edge. The excludes-1 vector is [1] + [1, 2, 1] - [1] = [1, 2, 1]. To check: {} has no boundary, {2, 3} and {3} have one boundary edge, and {2} has two boundary edges.</p>\n\n<p><strong>I am unable to understand this fully. Can anyone help?</strong></p>\n", 'ViewCount': '242', 'LastEditorDisplayName': 'user742', 'Title': 'Trouble understanding this dynamic programming solution', 'LastActivityDate': '2013-09-20T09:33:50.137', 'LastEditDate': '2013-09-20T09:33:50.137', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12449', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8505', 'Tags': '<algorithms><graph-theory><dynamic-programming><trees>', 'CreationDate': '2013-06-03T16:03:41.183', 'Id': '12445''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given a network $G=(V,E)$ , a max flow f and an edge $e \\in E$ , I need to find an efficient algorithm in order to detect whether there is some min cut which contains $e$.\nAnother question is, how do I decide whether if $e$ is the lightest edge of at least one minimal cut?</p>\n\n<p>I've thought about running Ford-Fulkerson algorithm, and then increasing / decreasing the capacity of the given edge and see what happens, but I haven't came up with something that might help me solve the problem.</p>\n\n<p>I'd be grateful if anyone could point me to the solution, thanks in advance.</p>\n", 'ViewCount': '178', 'Title': 'Max-Flow: Detect if a given edge is found in some Min-Cut', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-08T15:56:02.467', 'LastEditDate': '2013-06-07T20:49:03.987', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8202', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-06-07T13:10:00.247', 'Id': '12507''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let  consider a general version of <a href="http://en.wikipedia.org/wiki/Two_Generals%27_Problem" rel="nofollow">Two Generals\' Problem</a>, when there are $n$ generals located on the arbitrary graph and they should agree on exactly the same value whether to attack or not to attack. </p>\n\n<p>It\'s well known  that Two Generals\' Problem represents a version of the <a href="http://en.wikipedia.org/wiki/Consensus_%28computer_science%29" rel="nofollow">Consensus Problem</a> with unlimited number of the stopping failures, I think this is the only reason why Two Generals\' Problem and Generals\' Problem (with $n$ generals) don\'t have solution.</p>\n\n<p>There is a proof of lacking solution for Two Generals\' Problem (can be found in the textbook of Lynch).</p>\n\n<p>The following is the exercise from the textbook of Lynch, that I have not solved so far.</p>\n\n<p>Show that a solution to the (deterministic) coordinated attack problem (Generals\' Problem) for any nontrivial connected graph implies a solution for the simple graph consisting of two processes connected by one edge. (Therefore, this problem is unsolvable in any nontrivial graph.)</p>\n\n<p>Apparently, there is a reduction from an edge case to graph. But how to show it mathematically rigorous?</p>\n\n<p><strong>Addendum:</strong></p>\n\n<p>Can I say something like this?\nWhen we are given the primary problem of Two Generals and they initial values $a_i$ (inclination whether to attack or not), we in arbitrarily add more dummy generals with the only requirement if $a_1=a_0=a$ for primary problem set all dummy\'s general input to $a$, otherwise set arbitrary input value $b \\in \\{0,1\\}$. Find the solution on the graph, the solution on the graph is the solution for the primary problem. </p>\n', 'ViewCount': '157', 'LastEditorDisplayName': 'user742', 'Title': 'Coordinated Attack Problem On The Arbitrary Graph', 'LastActivityDate': '2013-09-20T17:48:32.680', 'LastEditDate': '2013-09-20T09:33:24.167', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4778', 'Tags': '<algorithms><complexity-theory><graph-theory><reductions><distributed-systems>', 'CreationDate': '2013-06-07T13:49:01.323', 'Id': '12508''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>A sink in a directed graph is a node with no outgoing edges. If I perform a depth first search, why is it that the node with the least post-order number (and thus the highest pre-order number) not necessarily a sink - isn't this node found last?</p>\n\n<p>Also, intuitively, the node with the greatest post-order number should be a source - a node with no incoming edges.</p>\n", 'ViewCount': '270', 'LastEditorDisplayName': 'user742', 'Title': 'Why is the node with the greatest DFS post-order number not necessarily a sink?', 'LastActivityDate': '2013-09-20T09:33:07.620', 'LastEditDate': '2013-09-20T09:33:07.620', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12570', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2013-06-09T09:55:02.757', 'Id': '12559''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have given an undirected graph $G$ with vertex $\\{1, ... n\\}$ and two star subgraphs $S_1$ and $S_2$, always consisting of ALL neighbors of a given vertex,  and the goal is to check wether the two star graphs have a vertex in common. This will be will be executed $M$ times for $M$ a large integer.</p>\n\n<p>My approach would be to store the graph in adjacency list format and for each vertex store its adjacency list in sorted order.</p>\n\n<p>We can then check in $O(M n \\log n)$ time in total if two star graphs of the sequence of $M$ star graph pairs have a vertex in common. </p>\n\n<p>But maybe this can be done more efficiently?</p>\n', 'ViewCount': '124', 'LastEditorDisplayName': 'user742', 'Title': 'Efficiently checking if two star graphs are disjoint', 'LastActivityDate': '2013-09-20T09:32:52.133', 'LastEditDate': '2013-09-20T09:32:52.133', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8613', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-06-10T19:58:39.027', 'FavoriteCount': '1', 'Id': '12603''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to prove by induction  the following theorem:\nUse Induction to prove the following fact: for every integer, $N\\ge  1$ , a BST with $N$ nodes must have at least $\\log( N + 1)$ levels.\nI've proved the base case but I am struggling to figure out how to apply induction to prove for the $K+1$ case. Any suggestions would be wonderful.</p>\n", 'ViewCount': '49', 'Title': 'Proving that a BST with N>=1 nodes will have log(N+1) levels', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-11T16:27:11.647', 'LastEditDate': '2013-06-11T16:27:11.647', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8624', 'Tags': '<graph-theory><data-structures><binary-trees><induction>', 'CreationDate': '2013-06-11T16:18:32.680', 'Id': '12622''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Well, i have a binary search tree $T$ that is equilibrated by height witch has $2^d+c$ nodes ($c&lt;2^d$). \nWhat is the number of comparisons that will occur in the worst case scenario, if we ask whether $k\\in V(T)$ and why does it arise?</p>\n', 'ViewCount': '274', 'Title': 'Worst case scenario in binary search tree retrieval', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-14T21:57:25.843', 'LastEditDate': '2013-06-14T12:13:40.983', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'Mihai Alin', 'PostTypeId': '1', 'Tags': '<graph-theory><search-trees><search-problem>', 'CreationDate': '2013-06-13T18:46:27.367', 'Id': '12667''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I need your help with an exercise on <a href="http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm" rel="nofollow">Ford-Fulkerson</a>.</p>\n\n<blockquote>\n  <p>Suppose you are given a flow network with capacities $(G,s,t)$ and you are also given the max flow $|f|$ in advance.</p>\n  \n  <p>Now suppose you are given an arc $e$ in $G$ and suppose this arc\'s capacity is increased by one.</p>\n  \n  <p>Give an efficent algorithm which returns true iff the increase of the capacity of the arc $e$ will allow an increase in the max flow.</p>\n</blockquote>\n\n<p>I suppose we shouldn\'t run Ford-Fulkerson again but somehow use the given $|f|$\u2026 Any ideas how?</p>\n', 'ViewCount': '237', 'LastEditorDisplayName': 'user742', 'Title': 'Effect of increasing the capacity of an edge in a flow network with known max flow', 'LastActivityDate': '2013-06-17T23:03:08.163', 'LastEditDate': '2013-06-17T23:03:08.163', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'SyndicatorBBB', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<algorithms><graph-theory><network-flow><weighted-graphs>', 'CreationDate': '2013-06-16T16:41:05.080', 'Id': '12703''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Find the number of topological sorts in a tree that has nodes that hold the size of their sub-tree including itself.</p>\n\n<p>I've tried thinking what would be the best for m to define it but couldn't get anything specific. </p>\n\n<p>Maybe $\\mbox{Number of sorts =}\\prod\\limits_{x\\in \\mbox{children}}\\mbox{Number of sorts}(x)$\nMeaning that starting at the root I call the the method recursively multilying each result by the previous children's result. When we reach a node with size 1 we assume that there's just 1 topological sort;</p>\n\n<p>If this is correct I'd really appreciate some help with proving correctness and if not a explanation why and a clue could be nice :)</p>\n", 'ViewCount': '50', 'Title': 'Find the number of topological sorts in a tree', 'LastEditorUserId': '8709', 'LastActivityDate': '2013-06-17T16:06:57.213', 'LastEditDate': '2013-06-17T15:42:53.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12716', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8709', 'Tags': '<graph-theory><graphs><algorithm-analysis><trees>', 'CreationDate': '2013-06-17T15:29:23.190', 'Id': '12713''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve been working on this graph and just completely botching it. I mean to say that my solution may be the worst possible other than if a monkey had thrown darts at the graph to decide the next path.  Anyhow, I\'m lost and really trying to get a grasp of where my conclusion and the proper conclusion diverged dramatically.</p>\n\n<p>I wanted to perform a DFS, show discovery/finish times, the DF forest, and edge classifications. I assumed that: 1) The vertices are listed in alphabetical order in each adjacency list. 2) The vertices are taken in the alphabetical order in the main loop of the DFS algorithm.</p>\n\n<p><img src="http://i.stack.imgur.com/fgGDu.jpg" alt=""></p>\n\n<p>Should I be treating this as a directed acyclic graph?</p>\n', 'ViewCount': '103', 'Title': 'How to perform alphabetically ordered DFS?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-18T00:02:57.537', 'LastEditDate': '2013-06-17T21:22:38.820', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12729', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<graph-theory><graphs><search-algorithms>', 'CreationDate': '2013-06-17T20:47:29.400', 'Id': '12728''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am working with sparse matrices (not particularly huge, &lt;100Mb) and I want to compute the largest independent set on the bipartite graph $(N,E)$ defined as follows: suppose the matrix is named $A$ and is of size $m \\times n$.</p>\n\n<ul>\n<li>$m+n$ nodes ($1,\\dots,m$ for the rows, $m+1,\\dots,m+n$ for the columns)</li>\n<li>the edge $(i,j) \\in E \\iff a_{ij} \\neq 0$</li>\n</ul>\n\n<p>An independent set is then a subset of rows and columns such that they "do not intersect".</p>\n\n<p>The graph is clearly bipartite (edges are from the set $\\{1,\\dots,m\\}$ to the set $\\{m+1,\\dots,m+n\\}$), and therefore the computation of the largest independent set is definitely simpler than the general case (as suggested also <a href="http://cs.stackexchange.com/questions/3027/maximum-independent-set-of-a-bipartite-graph">in this other question</a>). </p>\n\n<p>This computation is not entirely critical for my work (my thesis, actually) so I would like to use as much code from existing libraries as possible. I tried <a href="http://igraph.sourceforge.net/" rel="nofollow">igraph</a>, but they use a general algorithm for the largest independent set (which is terribly slow for even a matrix of 5MB), and I have yet to try and see if doing explicitly all the passages "Maximum Matching > Minimum vertex cover > maximum independent set" helps (it depends on their implementation).</p>\n\n<p>The fact that I have a bipartite graph definitely helps from the theoretical point of view, so bigger instances are solvable, but yet I have to find a nice library which might work well with big, sparse, bipartite graphs.</p>\n\n<p>Do you know any other existing libraries to do this kind of job?</p>\n', 'ViewCount': '43', 'Title': 'Library for Maximum independent set on a sparse bipartite graph (from sparse matrix)', 'LastActivityDate': '2013-06-18T09:16:20.910', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8729', 'Tags': '<graph-theory>', 'CreationDate': '2013-06-18T09:16:20.910', 'Id': '12736''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a problem where, there are a set of nodes and dependencies between them. I want to cluster them based on the maximum number of dependencies.  Dependencies can be thought of as number of edges connected.  I want to group those with maximum dependencies.</p>\n\n<p>For example in the set $\\{1,2,3\\}$ and $\\{3,5,7\\}$ if $\\{3,5,7\\}$ have more dependencies i need to group $\\{3,5,7\\}$. I know the dependencies beforehand. </p>\n\n<blockquote>\n  <p>Which algorithm will help to solve this problem?</p>\n</blockquote>\n', 'ViewCount': '41', 'LastEditorDisplayName': 'user742', 'Title': 'How to cluster nodes based on the number of dependencies', 'LastActivityDate': '2013-09-20T09:29:13.827', 'LastEditDate': '2013-09-20T09:29:13.827', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<graph-theory><data-mining><cluster>', 'CreationDate': '2013-06-19T12:58:01.557', 'Id': '12760''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '213', 'Title': 'Get nodes that are participating in any cycle in a graph', 'LastEditDate': '2013-06-20T12:30:34.290', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8044', 'FavoriteCount': '1', 'Body': '<p>I have a problem that states the following :</p>\n\n<blockquote>\n  <p>Given a cyclic graph , output for each node if the node removes all cycles in the graph.</p>\n</blockquote>\n\n<p>The most trivial way to do this is using a Union-find disjoint set , and for each node , try <strong>not</strong> putting it in the Union-find disjoint set , if there are no cycles , then this node should output "Yes" , otherwise "No".</p>\n\n<p>This approach would take about $\\Theta(N^2)$ time and $\\Theta(N)$ memory.</p>\n\n<p>The problem also stated that $N \\leq 1,000,000$ which would definitely get a TLE (Time Limit Exceeded) Answer on any problem.</p>\n\n<p>So, my question is, What\'s the algorithm that would take $\\Theta(N \\lg N) $ or $\\Theta(N)$ time and $\\Theta(N)$ memory?</p>\n', 'Tags': '<algorithms><graph-theory><data-structures>', 'LastEditorUserId': '8044', 'LastActivityDate': '2013-06-21T23:01:41.097', 'CommentCount': '0', 'AcceptedAnswerId': '12763', 'CreationDate': '2013-06-19T14:55:23.630', 'Id': '12762''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How is a <a href="http://en.wikipedia.org/wiki/Hypergraph" rel="nofollow">hypergraph</a> different from the bipartite graph generated from the hypergraph by introducing new vertices for each hyperedge, and connecting these vertices with the vertices connected by the original hyperedge. Alternatively, I could also start with a bipartite graph, designate one of the sets of vertices as the hyperedges, and connect these hyperedges with the vertices connected to the original vertices.</p>\n\n<p>Is there anything wrong with this construction? Are there theorems about hypergraphs that don\'t have a natural interpretation in terms of the bipartite graph just described?</p>\n\n<hr>\n\n<p>I haven\'t read in detail what <a href="http://cs.stackexchange.com/users/699/vzn">vzn</a> is proposing <a href="http://vzn1.wordpress.com/2012/12/08/outline-for-a-np-vsppoly-proof-based-on-monotone-circuits-hypergraphs-and-factoring/" rel="nofollow">here</a>, but this got me interested in the question whether hypergraphs are really non-trivial generalizations of graphs. I googled for hypergraphs (and Wikipedia indeed also described the construction given above) and searched stackexchange and mathoverflow, but somehow hypergraphs are always treated as a non-trivial generalization of graphs, and somehow considered to be much more complicated than graphs. Don\'t read too much into this question, I have neither done an excessive literature research nor thought too deeply about hypergraphs. (Perhaps I even accidentally searched for multigraph instead of hypergraph, but I don\'t think so.)</p>\n', 'ViewCount': '213', 'Title': 'How is a hypergraph different from a bipartite graph?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-21T08:15:47.907', 'LastEditDate': '2013-06-21T06:22:57.673', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1557', 'Tags': '<graph-theory><terminology>', 'CreationDate': '2013-06-19T23:01:36.713', 'FavoriteCount': '1', 'Id': '12769''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have this problem, maybe anybody could help. </p>\n\n<p>Given a graph $G = (V, E)$ and an integer $k \\geq 1$, find the minimum number $l$ of vertices to remove to make the largest connected component of $G \\setminus \\{v_1, \\dots,v_l\\}$ have at most $k$ vertices.</p>\n\n<p>I wonder it this problem can be solved quickly (in polynomial time)?</p>\n\n<p>(Related: <a href="http://cs.stackexchange.com/questions/12789/find-which-vertices-to-delete-from-graph-to-get-smallest-largest-component">finding the vertices when $k$ is small</a>)</p>\n', 'ViewCount': '126', 'LastEditorDisplayName': 'user742', 'Title': 'Minimum number of vertices to remove to bound the largest connected component of a graph', 'LastActivityDate': '2013-09-20T09:28:50.637', 'LastEditDate': '2013-09-20T09:28:50.637', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12784', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8770', 'Tags': '<graph-theory><np-complete><combinatorics>', 'CreationDate': '2013-06-20T08:47:37.500', 'Id': '12783''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '217', 'LastEditorDisplayName': 'user742', 'Title': 'Find which vertices to delete from graph to get smallest largest component', 'LastEditDate': '2013-09-20T09:28:39.900', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8770', 'FavoriteCount': '1', 'Body': '<p>Given a graph $G = (V, E)$, find $k$ vertices $\\{v^*_1,\\dots,v^*_k\\}$, which removal would result in a graph with smallest largest component.  </p>\n\n<p>I assume for large $n = |V|$ and large $k$ the problem is difficult (NP-hard), but I am interested in small values of $k$ ($k \\in \\{1, 2, 3, 4\\}$).</p>\n\n<p>For $k = 1$, I think it is possible to find best vertex $\\{v^*_1\\}$ to remove by performing single depth-first-search of the graph (i.e., checking articulation points).</p>\n\n<p>For $k = 2$, it would be possible to find best vertices $\\{v^*_1, v^*_2\\}$ by performing $n$ depth-first searches (each of them for graph $G_i = G / \\{v_i\\}$). A similar approach could be applied in the case $k &gt; 2$.</p>\n\n<p>I wonder if there is any better solution than that.</p>\n\n<p>(Related: <a href="http://cs.stackexchange.com/questions/12783/find-min-no-of-vertices-to-remove-to-make-graph-max-component-k">counting the minimum number of vertices without necessarily enumerating them</a>)</p>\n', 'Tags': '<algorithms><complexity-theory><graph-theory><parametrized-complexity>', 'LastActivityDate': '2014-03-30T17:24:55.313', 'CommentCount': '4', 'AcceptedAnswerId': '12809', 'CreationDate': '2013-06-20T14:40:37.167', 'Id': '12789''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there a name for the DAG obtained from a directed graph by collapsing together the strongly connected components?</p>\n', 'ViewCount': '44', 'Title': 'Is there a name for this kind of graph?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-21T06:24:22.760', 'LastEditDate': '2013-06-21T06:24:22.760', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12795', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8785', 'Tags': '<graph-theory><terminology>', 'CreationDate': '2013-06-20T16:26:51.737', 'Id': '12794''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $T$ be a depth-first search tree of a connected undirected graph $G$ and $h$ be the height of $T$. How do you show that $G$ has no more than $h \\times |V|$ edges where $|V|$ is the number of vertices in $G$? </p>\n', 'ViewCount': '75', 'Title': 'Upper bound on the number of edges relative to the height of a DFS tree', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-26T12:42:38.160', 'LastEditDate': '2013-06-26T12:42:38.160', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12852', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2013-06-23T22:54:36.937', 'Id': '12851''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am having some issues proving a problem I am working on. I have been sketching out examples but the proof is not jumping out at me.</p>\n\n<p>Question:\nLet $G = (V,E)$ be an undirected $r$-regular graph (that is each vertex has a degree of $r$) for some $0 &lt; r &lt; n$, where $|V| = n &gt; 1$. Prove that either $G$ or its complement $G^*$ has a hamiltonian path. </p>\n\n<p>Now the reason it's asking for $G$ or $G^*$ is because if it's not a connected undirected graph then taking the complement will make it connected.</p>\n\n<p>So lets assume that it's a connected $r$-regular graph. We start at a vertex $v$. From this vertex we can visit up to $r$ adjacent vertices. So we visit one of them, say $u$, and from there we have $r-1$ vertices to choose from because we do not want to go back to vertex $v$.</p>\n\n<p>Now I am trying to formulate a proof by going from vertex to vertex until all vertices are visited exactly once (hamiltonian path). But I do not see how to formulate the proof. Somehow each new vertex I visit will always have an uninformed neighbour until I reach the final vertex on the path.</p>\n\n<p>Am I on the right track?</p>\n", 'ViewCount': '136', 'Title': 'r-regular graph and hamiltonian path', 'LastActivityDate': '2013-06-26T20:19:10.370', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12918', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><proof-techniques>', 'CreationDate': '2013-06-26T18:24:24.753', 'Id': '12916''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Suppose that we have a directed graph $G = (V, E)$ represented as an adjacency list.  Suppose that we want to list all of the edges incident to some node $v \\in V$.  We can do this by iterating over all the elements in the adjacency list.</p>\n\n<p>My question concerns the runtime of this operation.  Is it proper to say that the runtime is $\\Theta(deg^+(v))$ (since the runtime is a linear function of the outdegree of $v$)?  Or should it be $\\Theta(1 + deg^+(v))$, since even if $deg^+(v)$ is zero, there is some amount of work that's still done?  Or are both of these terminologies incorrect because there is no underlying variable $n$ for which we could apply the formal definition of $\\Theta$?</p>\n\n<p>Thanks!</p>\n", 'ViewCount': '46', 'LastEditorDisplayName': 'user742', 'Title': 'What is the proper runtime for visiting all outgoing edges in an adjacency list?', 'LastActivityDate': '2013-09-20T09:28:16.213', 'LastEditDate': '2013-09-20T09:28:16.213', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<terminology><graph-theory><asymptotics>', 'CreationDate': '2013-06-29T00:58:31.787', 'Id': '12959''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Given an <strong>undirected</strong> graph with <strong>positive weights</strong>, there are 2 kinds of edges: locked edges and unlocked edges. \nDetermination if a given edge is either locked or unlocked edge takes O(1).</p>\n\n<p>For given two vertices s , t and a positive number k = O(1), How can I find the shortest path between s and t which contains <strong>at most</strong> k locked edges?\nHow to find that path if it must contains <strong>exactly</strong> k locked edges?  note that the second path might be contains the same locked edge <strong>more than 1 time</strong>.</p>\n\n<p>So my first solution was to define a counter that is initialized to k, and decrease its value each time I found locked edge during dijkstra algo.  but it doesn\u2019t meet the requirement, so @tmyklebu suggest me to copy the graph k times, and modify each graph to <strong>directed one</strong> so that a locked edge vw in G_i turns into an edge from u in G_i to v in G_{i+1} and from v in G_i to u in G_{i+1}.  I didn\u2019t undertand this solution, so I hope you can help (or suggest another one to solve this problem) :-)</p>\n\n<p>Thanks a lot!\n<br>\nTomer.</p>\n', 'ViewCount': '89', 'Title': 'Minimum path in an undirected graph with 2 kinds of edges', 'LastActivityDate': '2013-06-30T11:06:56.353', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12988', 'Score': '-1', 'OwnerDisplayName': 'TomerGod', 'PostTypeId': '1', 'OwnerUserId': '8930', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-06-29T22:53:22.833', 'Id': '12987''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>While I was doing\n<a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">CLRS</a> (3rd\nedition), I came across this question on page 629:</p>\n\n<p><strong>Professor Sabatier conjectures</strong> the following converse of Theorem\n23.1:</p>\n\n<blockquote>\n  <p>Let $G = (V,E)$ be a connected, undirected graph with a real-valued\n   weight function $w$ defined on $E$. Let $A \\subseteq E$ that is\n   included in some minimum spanning tree for $G$, let $(S,V -S)$ be any cut of $G$ that respects $A$, and let $(u,v)$ be a safe\n   edge for $A$ crossing $(S, V - S)$. Then, $(u,v)$ is a light\n   edge for the cut.</p>\n</blockquote>\n\n<p>Show that the professor\u2019s conjecture is incorrect by giving a\ncounterexample.</p>\n\n<p><strong>Theorem 23.1</strong>:</p>\n\n<blockquote>\n  <p>Let $G = (V,E)$ be a connected, undirected graph with a real-valued\n   weight function $w$ defined on $E$. Let $A$ be a subset of $E$ that\n   is included in some minimum spanning tree for $G$, let $(S, V\n - S)$ be any cut of $G$ that respects $A$, and let $(u,v)$\n   be a light edge crossing $(S, V - S)$.  Then, edge $(u,v)$\n   is safe for $A$.</p>\n</blockquote>\n\n<p>Can anybody please give a proof or a counterexample to the conjecture\nalso because I used to think that all safe edges added to the graph\nare light edges.  </p>\n\n<blockquote>\n  <p><strong>DEFINITIONS</strong> :<br>\n  1. <strong>Cut (S ,V-S)</strong> : of an undirected graph G = (V,E) is a partition of V(as defined in CLRS Book) .You can think it as a line that divides graph into two disjoint sets of vertices on its either side.<br>\n  2. <strong>Light edge</strong>:Any edge crossing a cut is light edge if its weight is the minimum of all the edge crossing the cut.Light edge is defined with respect to a particular Cut.<br>\n  3. A cut <strong>Respects</strong> a set A of edges if no edge in A crosses the cut.<br>\n  4. <strong>Safe edge</strong> is the edge which we can add to MST without any violation of MST\'s property.These are those edges which are the part of final MST.  </p>\n</blockquote>\n\n<p>I have written most of the definition but for more queries you can also refer to CLRS chapter 23.</p>\n', 'ViewCount': '340', 'Title': 'Sabatier conjectures', 'LastEditorUserId': '8951', 'LastActivityDate': '2014-05-03T17:00:51.560', 'LastEditDate': '2013-07-03T21:58:06.263', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '13071', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8951', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-07-01T08:06:55.030', 'Id': '13008''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G$ be a $d$-regular expander graph. What is the electrical resistance of $G$? Is it a constant independent of the number of nodes $n$ once $d$ is large enough? If not, can we give matching upper and lower bounds in terms of $n,d$?</p>\n', 'ViewCount': '63', 'Title': 'Electrical resistance of expander graphs', 'LastActivityDate': '2013-07-08T04:58:52.567', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '13155', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9070', 'Tags': '<graph-theory><random-walks><expanders>', 'CreationDate': '2013-07-07T17:14:21.943', 'FavoriteCount': '1', 'Id': '13137''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $G$ be a directed graph, and $H$ a subgraph of $G$ that contains all the vertices of $G$. (In other words, $H$ is obtained by deleting some of the edges of $G$, but not any of the vertices of $G$.)</p>\n\n<p>A subgraph isomorphism $\\varphi$ from $G$ to $H$ is a graph isomorphism from some subgraph of $G$ to $H$.  In other words, it is a bijective function $\\varphi:V\\to V$ (where $V$ is the vertex set of $G$) such that if $(\\varphi(u),\\varphi(v))$ is an edge in $H$, then $(u,v)$ is an edge in $G$.</p>\n\n<p>Let $\\Phi$ denote the set of all subgraph isomorphisms from $G$ to $H$.  For a vertex $v \\in V$, define the out-expansion of $u$ in $\\Phi$ to be $|\\{\\varphi(v) : \\varphi \\in \\Phi\\}|$ (i.e., the number of vertices that $v$ can be mapped to, under some subgraph isomorphism), and the in-expansion of $v$ to be $|\\{\\varphi^{-1}(v) : \\varphi \\in \\Phi\\}|$ (i.e., the number of vertices that can map to $v$, under some subgraph isomorphism).</p>\n\n<p>Consider the following proposition:</p>\n\n<blockquote>\n  <p>If every vertex has out-expansion $\\ge k$, then every vertex has in-expansion $\\ge k$.</p>\n</blockquote>\n\n<p>Is this proposition true for all $G,H$?</p>\n\n<p>I haven't been able to find any reason why it should be true.  (For instance, I don't think $\\Phi$ is closed under inversion: $\\varphi \\in \\Phi$ doesn't seem to imply $\\varphi^{-1} \\in \\Phi$.)  However, playing with a few small examples, I haven't found a counter-example yet.  That said, I only tried a few simple examples, so it's possible that more trial-and-error might give a better sense.  But I thought I'd check whether anyone here has any suggestions for how to answer this.</p>\n\n<p>Motivation: this problem arises in the security analysis of a proposed scheme for obfuscating/protecting circuits.  The graph represents the circuit (actually, they use a colored graph, where each vertex is given a color, and the isomorphism has to respect the color scheme; but that can probably be ignored, for simplicity), and subgraph isomorphisms represent different possible ways that the circuit might have been hidden/obfuscated.</p>\n", 'ViewCount': '36', 'Title': 'Subgraph isomorphisms: does large out-expansion imply large in-expansion?', 'LastActivityDate': '2013-07-10T16:08:36.300', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13204', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<graph-theory><graphs><discrete-mathematics><graph-isomorphism>', 'CreationDate': '2013-07-09T19:24:18.013', 'Id': '13183''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given an undirected simple graph $G$ and two nodes $s$ and $t$, the question asks for an algorithm to find the shortest simple cycle (no edge or vertex reuse) that contains the two. As far as I know, the problem is NP-complete if the two constraint were changed to arbitrary, but what if the number is given?</p>\n', 'ViewCount': '272', 'Title': 'Can the shortest simple cycle between two given nodes be found in polynomial time?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-07-22T09:45:28.230', 'LastEditDate': '2013-07-22T09:45:28.230', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9106', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-07-10T06:11:43.530', 'Id': '13194''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given two sets of vertices $U$ (size $n$) and $V$ (size $m$), how many possibilities of set of edges $E$ exist that make the bipartite graph $G = (U, V, E)$ connected?</p>\n\n<p>Obviously there are $2^{n m}$ different set of edges but many will be disconnected.</p>\n', 'ViewCount': '133', 'Title': 'Number of Combinations of Connected Bipartite Graphs', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-16T11:09:14.920', 'LastEditDate': '2013-07-12T13:42:57.077', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13297', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9133', 'Tags': '<graph-theory><combinatorics>', 'CreationDate': '2013-07-11T15:33:50.653', 'Id': '13229''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>There is a river which can be considered as an infinitely long straight line with width W.</p>\n\n<p>There are A piles on the river, and B types of wooden disks are available.\nThe location of the $i$-th pile is $(X_i, Y_i)$.</p>\n\n<p>The $i$-th type of wooden disks has radius $R_i$, and its price is $C_i$ per disk.</p>\n\n<p>Disks can be placed on the river such that for each wooden disk, its center must be one of the locations $(X_i, Y_i)$ of piles. We can only move on the wooden disks.</p>\n\n<p>How to find the minimum cost such that we can cross the river.I am unable to approach questions like these. What would be the best method to approach this one?</p>\n\n<p>I have come to realize that we can use Dijkstra's algorithm here. We treat this as a graph, with piles as the nodes. Start point can be $y=0$. and $y=W$ as the end point. But i am having implementation problems. There are multiple disks which can be used in going from on state to another. How to handle this?</p>\n", 'ViewCount': '156', 'LastEditorDisplayName': 'user742', 'Title': 'Finding path with minimum weight', 'LastActivityDate': '2013-09-20T09:27:54.150', 'LastEditDate': '2013-09-20T09:27:54.150', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9184', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-07-14T23:16:01.920', 'Id': '13273''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm currently working on my masters thesis, and it's about clustering on graphs. I'm working with an idea using ants to solve the problem. I'm currently working on the implementation and am wondering exactly how well to represent the edges of the graph. </p>\n\n<p>Each edge is augmented with certain information such as its pheromone value and the number of times an ant has visited that edge. I'll be working with undirected graphs, which can be end up being pretty huge (over a million vertices) and I was wondering what is the most efficient way for me to store the edges and look them up? I was thinking of sticking to a convention and store endpoints according to the one which has a lower vertex id for $v_1$ and the higher one for $v_2$ ($v_1$ and $v_2$ are the endpoints of the edge in the data structure). But I'm wondering how would I perform a look up in this case?</p>\n\n<p>There is a mapping I came up with from the adjacency matrix to the edge array, but that works only if the underlying graph is a complete graph. So I came here for some suggestions as to how I should proceed because I need my lookup to be efficient while at the same time I don't want to blow up the storage space for the edges as the graphs will be huge.</p>\n", 'ViewCount': '560', 'LastEditorDisplayName': 'user742', 'Title': 'Data structure for storing edges of a graph', 'LastActivityDate': '2013-09-20T09:27:38.553', 'LastEditDate': '2013-09-20T09:27:38.553', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '13367', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5020', 'Tags': '<graph-theory><data-structures><evolutionary-computing>', 'CreationDate': '2013-07-20T19:03:15.100', 'Id': '13364''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m not terribly well-versed in CS (I only just a few moments ago learned what a k-partite graph is), so forgive me if this is an obvious question.</p>\n\n<p>I\'m wondering how to determine if a given graph matches a specified pattern, where this pattern is an example graph that is a k-partite graph where all inter-set edges must be between one special "central" set and some other set.</p>\n\n<p>I hope I\'m explaining this correctly. I imagine an algorithm to take care of this (or most likely a more general case) already exists, so just a link might be the most appropriate response.</p>\n\n<p>Thanks!</p>\n\n<p>(P.S.: This isn\'t a homework problem or some made-up situation. I\'m trying to do a matching of ligand-to-amino-acid graphs for a biological search tool; in my real-life case the "central" set is the ligand, the edges are bonds or interactions, and the other sets are amino acids.)</p>\n', 'ViewCount': '60', 'LastEditorDisplayName': 'user742', 'Title': 'Matching k-partite graphs where all sets may only share edges with one of the sets', 'LastActivityDate': '2013-09-20T09:27:09.223', 'LastEditDate': '2013-09-20T09:27:09.223', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9475', 'Tags': '<graph-theory>', 'CreationDate': '2013-08-01T18:31:18.937', 'Id': '13567''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m conflicted whether to post this here or in either math.stackexchange or mathematica.stackexchange.</p>\n\n<p>Define a "<strong>simple zonotope</strong>" to be a regular $2n$-gon which is tiled by the following rule: all tiles are rhombi. They key point here is that rhombuses have equal side lengths (say equal to 1), but their shapes are allowed to vary arbitrarly. Here\'s an example of a 12-gon zonotope:</p>\n\n<p><img src="http://i.stack.imgur.com/YATPS.png" alt="Zonotope"></p>\n\n<p>There are many characterizations and properties of these objects. For example, one can encode a zonotope using $2n$ vectors (one for each outer edge) since we can just translate copies of each vector.</p>\n\n<p><strong>What I would like to do is the following:</strong> I have the adjacency matrix of a graph that I believe to be a simple zonotope. Specifically, you can assume that we are starting with a <em>planer geometric graph</em>, in that I have an adjacency matrix, in addition to having (x,y) coordinates of each point. In other words, it\'s fairly straightforward to identify which vertices go to the outer vertices of the $2n$-polygon.Here\'s an example of a geometric graph that I could have:</p>\n\n<p><img src="http://i.stack.imgur.com/TFPlL.png" alt="enter image description here"></p>\n\n<p>In the above picture, the two red vertices indicate the north/south poles of the zonotope they are mapped to (which happens to be the zonotope in the first picture). </p>\n\n<blockquote>\n  <p>Question: What is the most painless way of drawing the simple zonotope from a given adjacency matrix plus geometric graph coordinates? </p>\n</blockquote>\n\n<p>Some observations: part of the algorithm is somewhat clear to me: one should work from the outside in. Once a specific rhombus side has been identified, all sides below it must be the same until we run into the opposite side of the zonotope. However this all seems very computationally expensive. I am honestly not preferential to any specific solution. I would even accept something akin to attaching springs to vertices and then running the algorithm until the graph converges to a zonotope.</p>\n', 'ViewCount': '79', 'Title': 'Drawing Zonotopes from an Adjacency Matrix', 'LastEditorUserId': '9472', 'LastActivityDate': '2013-08-01T18:59:46.497', 'LastEditDate': '2013-08-01T18:59:46.497', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9472', 'Tags': '<graph-theory><computational-geometry><mathematical-programming>', 'CreationDate': '2013-08-01T18:52:44.327', 'Id': '13568''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I've been looking for an algorithm which divides an undirected, weighted, planar and simple graph into $k$ disjoint subgraphs. Here, the graph is sparse, $k$ is fixed, and there are no negative edge weights. After cutting, each subgraph must be connected (i.e. there must be a path between any two vertices of the subgraph which is only composed of vertices in that subgraph).</p>\n\n<p>However, unlike most existing work on graph partitioning out there, I don't intend to obtain subgraphs that contain the same approximate number of vertices. Instead, I would like these subgraphs to have similar sum of edge weights. In other words, I would like to minimize the sum of edge weights of the subgraph with maximal weight and ideally cut long (weighted) edges.</p>\n\n<p>Is there a name for this problem? I wasn't able to find anything about this on the web. Also, how can I approach this problem?</p>\n", 'ViewCount': '185', 'Title': 'Dividing a weighted planar graph into $k$ subgraphs with balanced weight', 'LastEditorUserId': '9431', 'LastActivityDate': '2013-11-06T15:14:17.837', 'LastEditDate': '2013-08-03T14:22:17.707', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9431', 'Tags': '<graph-theory><weighted-graphs><cluster><partition-problem>', 'CreationDate': '2013-08-02T04:01:20.273', 'FavoriteCount': '1', 'Id': '13571''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to detect cycles in an undirected graph such that I get a list of all edges/vertices which form each cycle. For a graph G({a,b,c,d}, {a-b, b-c, c-d, d-a, b-d}) this would be {a, b, c, d}, {a, b, d}, {b, c, d}.</p>\n\n<p>I have read <a href="http://stackoverflow.com/questions/526331/cycles-in-an-undirected-graph">this</a> and I think that when the <a href="http://en.wikipedia.org/wiki/Depth-first_search#Pseudocode" rel="nofollow">iterative pseudocode from Wikipedia</a> finds a back-edge then I can say the graph has a cycle. But I don\'t know how to find out which vertices/edges the cycle consists of.</p>\n\n<p>Can you please help with an algorithm which would take a graph as input (or the information from DFS) and output list of lists describing the cycles?</p>\n', 'ViewCount': '1834', 'Title': 'Detecting cycles in undirected graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-10T14:09:56.323', 'LastEditDate': '2013-08-10T14:09:56.323', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '13697', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7287', 'Tags': '<graph-theory>', 'CreationDate': '2013-08-09T18:46:24.393', 'Id': '13693''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The following question is related to the <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://en.wikipedia.org/wiki/Maximum_cut&amp;ei=wMQTUuXxLuny4QS55oHgAw&amp;usg=AFQjCNF7PelNFUITFjPfjyXHqig7ivCgvw&amp;sig2=JVB560isHX3-zBpX2khJTQ&amp;bvm=bv.50952593,d.bGE" rel="nofollow">max cut problem</a> in <em>cubic graphs</em>. In <a href="http://www.cs.armstrong.edu/greenlaw/research/cubic.ps" rel="nofollow">this</a> survey paper Theorem 6.5 states</p>\n\n<blockquote>\n  <p>A maximal cut of a cubic graph can be computed in polynomial time</p>\n</blockquote>\n\n<p>Browsing through some other related results (for example <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://www.cs.tau.ac.il/~zwick/papers/cubic-MAXCUT-SODA.pdf&amp;ei=ycUTUvvrH6fV4gT25IHQBA&amp;usg=AFQjCNG6njoPJo3VO7GHk9dQvdiN23WOTA&amp;sig2=z706i_jNpl-wljwko3W6QQ&amp;bvm=bv.50952593,d.bGE" rel="nofollow">this</a> SODA paper) one gets the impression that this problem is actually NP complete even for cubic instances. In particular, the last paper states that this is indeed so if the graph is subcubic.</p>\n\n<p>That makes me wonder.. What\'s going on? Is the survey paper (and the result cited therein) faulty or is there some point that I am missing?</p>\n', 'ViewCount': '49', 'Title': 'Max cut in cubic graphs', 'LastActivityDate': '2013-08-20T21:01:07.307', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13848', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<complexity-theory><graph-theory><graphs><np-complete><np>', 'CreationDate': '2013-08-20T19:42:20.570', 'Id': '13845''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Ramsey's theorem states that every graph with $n$ nodes contains either a clique or an independent set with at least $\\frac{1}{2}\\log_2 n$ nodes.</p>\n\n<p>I tried to look it up at a few places (including Sipser) but I could not make out a lot of sense from the proofs. I would appreciate it if someone can give me a proof (or clear intuition) on this.</p>\n", 'ViewCount': '259', 'Title': "Proof of Ramsey's theorem: the number of cliques or anti cliques in a graph", 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-26T15:30:54.327', 'LastEditDate': '2013-08-25T11:36:47.523', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13921', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<graph-theory><proof-techniques><combinatorics><discrete-mathematics>', 'CreationDate': '2013-08-25T08:49:06.623', 'Id': '13920''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>Given $n$ nodes in the plane, connect the nodes by a spanning tree.\nFor each node $v$ we construct a disk centered at $v$ with radius equal to the distance to $v$\u2019s furthest neighbor in the spanning tree. The <strong>interference</strong> of a node $v$ is then de\ufb01ned as the number of such disks that include the node $v$.</p>\n\n<p>The problem I'm interested is to find a spanning tree that <strong>minimizes the maximum interference</strong>.</p>\n\n<p>What is known about the problem in terms of computational complexity? Is it NP-hard? Can it be solved efficiently? What is its inapproximability threshold?</p>\n\n<p>Apparently this problem is still not understood well. I do not know the complexity of the problem (solvable optimally in polynomial time, or NP-complete), and as far as I know it is unknown whether efficient approximation algorithms exist.</p>\n", 'ViewCount': '124', 'Title': 'Complexity of finding a spanning tree that minimizes the maximum interference', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-08T11:04:52.237', 'LastEditDate': '2013-08-29T12:17:16.040', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14202', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9665', 'Tags': '<complexity-theory><graph-theory><computational-geometry>', 'CreationDate': '2013-08-28T19:48:05.097', 'Id': '13999''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>In other words, given a graph with nodes $N=\\{n_0,n_1,...,n_j\\}$, and a set of nodes in the graph $M=\\{n_a,n_b,...,n_k\\}$ with $M\\subseteq N$, I'm looking for what to call the node or nodes $n'$ which minimize:</p>\n\n<p>$\\sum_{m\\in M}d_{min}(n',m)$</p>\n\n<p>where $d_{min}(x,y)$ is the shortest distance from node $x$ to node $y$, as traditionally defined.</p>\n\n<p>When $M=N$, this would be the node with the highest closeness centrality, but I'm interested in subgraphs.</p>\n", 'ViewCount': '42', 'LastEditorDisplayName': 'user742', 'Title': 'Is there a word/name for the node(s) in a graph with the minimal cumulative path length to a set of other nodes?', 'LastActivityDate': '2013-09-20T09:26:49.253', 'LastEditDate': '2013-09-20T09:26:49.253', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9876', 'Tags': '<terminology><graph-theory>', 'CreationDate': '2013-08-28T20:48:55.503', 'Id': '14003''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to construct a complete graph where each node is connected to every other node. The link between the nodes give a distance function (does not follow triangle inequality) between them. What I require is to merge the closest nodes, (bounded by a threshold) into a single node and recompute the graph each time, recursively. This is because if two nodes are merged, then all the links connected to the new node has to be updated with the newly computed distance for the new edge. Since its a complete graph this would be an expensive operation. </p>\n\n<p>I would have a large number of nodes with $N*(N-1)/2$ links for $N$ nodes , and $N=60$ or more , \nWhat I want to do is to reduce this complete graph into clusters of  sub graphs with low intra node distance, yet with a relatively high distance between the subgraphs. So,How can I go about solving this problem?</p>\n\n<p>This is like applying the graph partitioning techniques to complete graphs.</p>\n\n<p>One of the solutions is <a href="http://www.cs.berkeley.edu/~malik/papers/SM-ncut.pdf" rel="nofollow">this paper</a> which proposes the normalized cut criterion for partitioning the graph  minimizing normalized cuts on graphs which is clearly NP-complete,Is there a practically efficient way and what are the recent developments to achieve this?</p>\n\n<p>So what I want is an efficient solution to the above problem which is not NP complete ? Since this problem is NP Complete , answers using randomization or approximation methods would be welcome</p>\n', 'ViewCount': '173', 'Title': 'Algorithm for Graph merge and recompute', 'LastEditorUserId': '9881', 'LastActivityDate': '2013-09-01T18:21:45.387', 'LastEditDate': '2013-09-01T18:21:45.387', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9881', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-08-29T07:32:27.390', 'Id': '14014''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Does anybody know whether the multiset of the determinants (possibly together with the order of the submatrix they refer to) of all the principal minors of the (symmetric) adjacency matrix of a graph is a complete invariant for graph isomorphism (i.e. that multiset uniquely identifies a graph up to isomorphism)?</p>\n', 'ViewCount': '74', 'Title': 'Complete graph invariant', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-05T16:39:07.250', 'LastEditDate': '2013-09-05T16:39:07.250', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '14151', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9991', 'Tags': '<graph-theory><graph-isomorphism>', 'CreationDate': '2013-09-05T11:45:29.447', 'Id': '14147''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there any formula for computing the number of 5-cycles and 6-cycles in a simple undirected graph?</p>\n', 'ViewCount': '88', 'Title': 'Number of 5-cycles and 6-cycles in a simple graph', 'LastActivityDate': '2013-09-09T02:39:14.203', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10020', 'Tags': '<graph-theory>', 'CreationDate': '2013-09-07T09:26:04.387', 'Id': '14185''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>As I understand it when doing a DFS run when every new node is discovered and edge is added to the DFS tree from the parent of the new node to the new node. If that's the case how are back edges are created?</p>\n", 'ViewCount': '613', 'Title': 'Where are back edges in a DFS tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T09:42:57.813', 'LastEditDate': '2013-09-09T09:40:11.037', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14231', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9851', 'Tags': '<terminology><graph-theory>', 'CreationDate': '2013-09-07T12:54:22.700', 'Id': '14191''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1799', 'LastEditorDisplayName': 'user742', 'Title': 'What is the significance of negative weight edges in a graph?', 'LastEditDate': '2013-09-20T09:26:20.050', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9987', 'FavoriteCount': '2', 'Body': "<p>I was doing dynamic programming exercises and found the Floyd-Warshall algorithm. Apparently it finds all-pairs shortest paths for a graph which can have negative weight edges, but no negative cycles.</p>\n\n<p>So, I wonder what's the real world significance of negative weight edges? A plain English explanation would be helpful.</p>\n", 'Tags': '<algorithms><graph-theory>', 'LastActivityDate': '2013-09-20T09:26:20.050', 'CommentCount': '5', 'AcceptedAnswerId': '14262', 'CreationDate': '2013-09-10T15:18:19.163', 'Id': '14248''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to modify the Floyd-Warshall algorithm to find all-pairs minimax paths in a graph. (That is, the shortest length paths such that the maximum edge weight along a path is minimized.)</p>\n\n<p>Floyd-Warshall algorithm contains the following loop to enhance the distance (<code>ds</code>) and the next vertex (<code>ns</code>) matrices at each iteration.</p>\n\n<pre><code>for (int k = 0; k &lt; n; k++)\n    for (int i = 0; i &lt; n; i++)\n        for (int j = 0; j &lt; n; j++)\n            if (ds[i][k] != inf &amp;&amp; ds[k][j] != inf) {\n                final int d = ds[i][k] + ds[k][j];\n                if (d &lt; ds[i][j]) {\n                    ds[i][j] = d;\n                    ns[i][j] = k;\n                }\n            }\n</code></pre>\n\n<p>I replaced <code>ds</code> with two new matrices: <code>ws</code> (weights) and <code>ls</code> (lengths). Further, updated the iteration step as follows:</p>\n\n<pre><code>for (int k = 0; k &lt; n; k++)\n    for (int i = 0; i &lt; n; i++)\n        for (int j = 0; j &lt; n; j++)\n            if (ws[i][k] != inf &amp;&amp; ws[k][j] != inf) {\n                final int w = Math.max(ws[i][k], ws[k][j]);\n                final int l = ls[i][k] + ls[k][j];\n                if (w &lt; ws[i][j] || (w == ws[i][j] &amp;&amp; l &lt; ls[i][j])) {\n                    ws[i][j] = w;\n                    ls[i][j] = l;\n                    ns[i][j] = k;\n                }\n            }\n</code></pre>\n\n<p>However, the modified algorithm finds paths with loops, that is, paths such as 1-<strong>3-2-3</strong>-4. While the maximum edge weight of the paths 1-3-2-3-4 and 1-3-4 are identical, the latter has a shorter path length and supposed to be returned by the enhanced Floyd-Warshall. Any ideas?</p>\n\n<p>A working Java version of both algorithms and a test case which produces a path with loop can be found <a href="https://gist.github.com/vy/6580214" rel="nofollow">here</a>.</p>\n\n<p><strong>Edit:</strong> Since no solutions were presented yet, I implemented my own shortest minimax path algorithm using incremental link removal method. Java sources to the solutions can be accessed from the <a href="https://gist.github.com/vy/6580214" rel="nofollow">above link</a>. </p>\n', 'ViewCount': '683', 'LastEditorDisplayName': 'user742', 'Title': 'Shortest Minimax Path via Floyd-Warshall', 'LastActivityDate': '2013-10-20T10:59:54.067', 'LastEditDate': '2013-09-20T09:26:04.407', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10167', 'Tags': '<algorithms><graph-theory><optimization><shortest-path>', 'CreationDate': '2013-09-16T12:50:56.260', 'Id': '14353''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m looking for an algorithm that provides a <a href="http://en.wikipedia.org/wiki/Graph_canonization" rel="nofollow">canonical string</a> for a given colored graph. Ie. an algorithm that returns a string for a graph, such that two graphs get the same string if and only if they are isomorphic. </p>\n\n<p>In particular, I\'m looking for a simple algorithm that is easy to implement with a reasonable performance on most graphs (worst case super-polynomial, of course). I\'m expecting small graphs, so performance doesn\'t have to be stellar, just good enough.</p>\n\n<p>Unfortunately, most things I\'ve found are highly complex and more interested in expressing deep mathematical connections than simply describing the algorithm. I\'m afraid I don\'t have the time to dive that deep. Can anyone give me a shortcut?</p>\n\n<p>I\'m hoping for something like the Floyd-Warshall algorithm. Not optimal, but good enough, and easy to implement.</p>\n', 'ViewCount': '174', 'LastEditorDisplayName': 'user742', 'Title': 'Simple graph canonization algorithm', 'LastActivityDate': '2013-10-20T09:59:54.030', 'LastEditDate': '2013-09-20T09:25:40.343', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1428', 'Tags': '<algorithms><graph-theory><combinatorics>', 'CreationDate': '2013-09-16T14:11:06.023', 'Id': '14354''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for some graph theory concepts and definitions around <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Embedding" rel="nofollow">embedding</a> a DAG into another DAG.  I could only find a few lines on Wikipedia around this so I wonder if someone can help me find good references for the important concepts and definitions.</p>\n\n<p>For example, assume I have a DAG $G=(E,V)$ where there are two types of edges, red and black.  $E_{red} \\subset E$, $E_{black} \\subset E$, and $E_{red} \\cap E_{black} =  \\emptyset$ .  </p>\n\n<p>I assume that the red edges represents some "core" DAG and the black edges represents "details".</p>\n\n<p>If I want to extract this "core" DAG, I might do something like this:</p>\n\n<p>Put $E_{red}$ and all related vertices into a new graph $G\' = (E\',V\')$.</p>\n\n<p>For every pair $e_p,e_c \\in E_{red}$, if $e_c$ is reachable from $e_p$ and there is no other $e \\in E_{red}$ on the path, then add the edge $(end(e_p),beginning(e_c))$ to $G\'$.</p>\n\n<p>$G\'$ might then be thought of as having removed the black edges (and thus the details) from $G$.</p>\n\n<p>My question is, what am I doing, and where can I read about embedding DAGs and extracting embeddings based on edge colors? </p>\n', 'ViewCount': '36', 'Title': 'Finding embedded DAG in another DAG based on colors', 'LastEditorUserId': '10168', 'LastActivityDate': '2013-09-17T12:17:54.980', 'LastEditDate': '2013-09-17T12:17:54.980', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10168', 'Tags': '<graph-theory><reference-request>', 'CreationDate': '2013-09-16T16:13:42.470', 'Id': '14358''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a finite automaton with these properties:</p>\n\n<ul>\n<li>Contains cycles</li>\n<li>It's a directed graph</li>\n<li>All the states/nodes are initialy reachable from the initial state</li>\n<li>It has final states but I guess it isn't relevant for my issue</li>\n<li>It's a random generated automaton, and the generation isn't meant to satisfy properties like strongly connected components or connected components </li>\n</ul>\n\n<p>Let's suppose I have to delete an edge. </p>\n\n<p>I need to know if there's a way to prove that the reached state by this edge is still reachable from the initial state without using a classical search (DFS or BFS); obviously, if there is any.</p>\n", 'ViewCount': '57', 'Title': 'What is the optimal solution to prove the reachbility of a node from the root?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T17:36:35.740', 'LastEditDate': '2013-09-17T17:36:35.740', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<graph-theory><finite-automata><graph-traversal>', 'CreationDate': '2013-09-17T15:48:06.797', 'FavoriteCount': '1', 'Id': '14381''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $G = (V, E)$ be a connected graph and let $M\\subseteq V$. We say that a vertex $v$ is <em>marked</em> if $v\\in M$.  The problem is to find a simple path in $G$ that visits the maximum possible number of marked vertices. The associated decision problem is: is there a simple path that visits every $v\\in M$?  </p>\n\n<p>The problem is obviously more general than the problem of finding a Hamiltonian path in an arbitrary graph, so it is NP-hard.  </p>\n\n<p>I see no obvious strategy; one can't simply disregard the unmarked vertices, since they (and their incident edges) may be part of the optimal path.  Indeed, omitting them may disconnect the graph completely.</p>\n\n<p>My questions:</p>\n\n<ol>\n<li>Does this problem have a well-known name?</li>\n<li>Are there any good approximation algorithms, heuristics, or simple reductions to problems I might know more about?</li>\n<li>Where can I find this problem discussed in the literature?</li>\n</ol>\n", 'ViewCount': '201', 'LastEditorDisplayName': 'user742', 'Title': 'Find a simple path visiting all marked vertices', 'LastActivityDate': '2013-09-20T09:24:48.873', 'LastEditDate': '2013-09-20T09:24:48.873', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1786', 'Tags': '<algorithms><graph-theory><reference-request><np-hard><hamiltonian-path>', 'CreationDate': '2013-09-17T21:18:50.210', 'Id': '14390''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '114', 'LastEditorDisplayName': 'user742', 'Title': 'Approximation algorithm for Feedback Arc Set', 'LastEditDate': '2013-11-17T16:03:32.293', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '10198', 'FavoriteCount': '1', 'Body': '<p>Given a directed graph $G = (V,A)$, a feedback arc set is a set of arcs whose removal leaves an acyclic graph.  The problem is to find the minimum cardinality such set.</p>\n\n<p>I want to find out about is there some approximation algorithm around this problem.</p>\n', 'Tags': '<algorithms><graph-theory><approximation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-17T16:03:32.293', 'CommentCount': '6', 'AcceptedAnswerId': '14432', 'CreationDate': '2013-09-18T09:21:04.343', 'Id': '14410''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to to prove that every undirected graph, with $n$ nodes and at least $(n^2 - 3n + 4) / 2$ edges, is connected.</p>\n\n<p>Now I came up with this, possibly unorthodox solution and wondering if it is correct.</p>\n\n<pre><code>#V = n\n#E = (n^2 - 3n + 4) / 2\n\n(V,E) connected &lt;=&gt; #E &gt;= #V - 1\nTo prove: (n^2 - 3n + 4) / 2 &gt;= n - 1\nn^2 - 3n + 4 &gt;= 2n - 2\nn^2 + 6 &gt;= 5n\nn^2 - 5n + 6 &gt;= 0\n(n - 6)(n + 1) &gt;= 0\n\nSolutions: n &lt;= -1 or n &gt;= 6\n\nSo first conclusion: n &gt;= 6 for (V,E) to be connected.\n\nBy doing case distinction on 0 &lt;= n &lt; 6 you can also prove that it holds for those.\n#V = 5, #E = 7: 7 &gt;= 5 - 1\n#V = 4, #E = 4: 4 &gt;= 4 - 1\n#V = 3, #E = 2: 2 &gt;= 3 - 1\n#V = 2, #E = 1: 1 &gt;= 2 - 1\n#V = 1, #E = 0: Trivially.\n#V = 0, #E = 0: Trivially.\n</code></pre>\n\n<p>Would this be correct? And why does the first thing I try to prove not cover all possible solutions?</p>\n', 'ViewCount': '27', 'ClosedDate': '2013-09-20T11:38:31.750', 'Title': 'Prove that an undirected graph with at least (n^2 - 3n + 4) / 2 edges is connected', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-20T11:38:25.203', 'LastEditDate': '2013-09-20T11:38:25.203', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10245', 'Tags': '<graph-theory>', 'CreationDate': '2013-09-20T09:40:12.603', 'Id': '14464''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a bipartite graph with vertex set partitioned into $X=\\{u_1,u_2,u_3\\}$ and $Y=\\{v_1,v_2,v_3\\}$. Consider the graph has the following edges: $\\{u_1,v_1\\}$, $\\{u_2,v_2\\}$, $\\{u_2,v_3\\}$, $\\{u_3,v_2\\}$ and $\\{u_3,v_3\\}$. The perfect matchings are $\\{\\{u_1,v_1\\}$, $\\{u_2,v_2\\}$, $\\{u_3,v_3\\}\\}$ and $\\{\\{u_1,v_1\\}$, $\\{u_2,v_3\\}$, $\\{u_3,v_2\\}\\}$. The total number of such matchings is $2$.</p>\n\n<p>However I do not want the same edge to occur in two different sets. Here edge $\\{u_1,v_1\\}$ occurs in both the sets. So I can pick one of the two possible matchings for a total of $1$.</p>\n\n<p>Is there any counting strategy for the new matching problem? Note that permanent counts perfect matchings in the base case. </p>\n\n<p>Is there an approximation algorithm?</p>\n', 'ViewCount': '52', 'Title': 'Counting modified perfect matchings', 'LastEditorUserId': '9753', 'LastActivityDate': '2013-09-25T20:33:54.460', 'LastEditDate': '2013-09-25T20:33:54.460', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-09-23T04:08:20.910', 'Id': '14544''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>From CLRS (3rd edition), I came have this question on page 626:</p>\n\n<p>Given these definitions from the text,</p>\n\n<p>DEFINITIONS:\nGiven an undirected graph G = (V,E),\n<p>1. A CUT (S ,V-S) of G is a partition of V, \n<p>2. A LIGHT EDGE over a cut is any edge crossing the cut with a weight smaller than or equal to any other edge crossing that cut,\n<p>3. A cut RESPECTS a set A of edges if no edge in A crosses the cut.</p>\n\n<p>In every example in the text, the set A is coincident with one of the partitions of the cut but I cannot see why this must be. Given an arbitrary new vertex v', it could be added to the partition that contains A and no edge from v' to A would cross the cut. The definition of respects says that a cut cannot divide A, not that A must define the partition.</p>\n\n<p>There is clearly something here I missed since that does not seem consistent with the theorems. Can anyone point out my error?</p>\n\n<p>+++++++++++++++</p>\n\n<p>Amendment.\nThanks for the help. I also now realize that Theorem 23.1 only says that a light-edge is a safe edge but not that such a cut is guaranteed to find every safe edge since some edges may have both vertices in the same partition as A. I see in GENERIC-MST(G) that line 3 only says to find an edge. It is not until Kruskal or Prim algorithms that the method by which we find this edge is explained and neither depend upon the partition being coincident with the set of vertices defined by the set of edges A.</p>\n\n<p>I find it interesting that in Kleinberg Tardos that they take a different approach and define a cut property (4.17, pg 145) that avoids this (what I find awkward) development of the ideas. </p>\n", 'ViewCount': '94', 'Title': 'Clarification sought for definition of a cut that respects a set A of edges in Graph Theory', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T08:18:30.237', 'LastEditDate': '2014-03-26T08:18:30.237', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10333', 'Tags': '<graph-theory><terminology>', 'CreationDate': '2013-09-25T21:45:14.510', 'Id': '14607''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Suppose I have a set of small subgraphs $A=\\{G_i\\}$ of an original directed acyclic graph $G$, typically $|G_i| \\ll |G|$, which together span the original graph</p>\n\n<p>$$\nG= \\bigcup_i G_i\n$$\nMy question is if I take a arbitrary subset of these graphs $A\u2032 \\subset A$, and a single subgraph from this graph, $ a \\in A\u2032$, is there a simple way (or known algorithm) of reassembling the subgraph $G\u2032 \\subset G$ given by that portion of the union of $A\u2032$ connected to $a$?</p>\n\n<p>In words, this is rather like a jigsaw problem where $A$ is the total collection of pieces that originally came in the box, $A\u2032$ is the subset left after half of them got lost and $a \\in A\u2032$ the random selected piece you put down the start the puzzle off. The question is then what is the largest connected graph (connected subset of pieces $x \\in A\'$) that you can lay down all on the board.</p>\n\n<p>The actual application arises where each subgraph $G_i$ of A represents a rule and (e.g. $x \\wedge y \\Rightarrow z$) and the objective is to find the largest rule implied transitively from an initial seed rule $a \\in A\u2032$ and the remaining rules contained in thinned out subset $A\u2032 \\subset A$.</p>\n\n<p>I suspect I maybe able to do something by brute force here but would be most interested in knowing if there is any area or known application of this problem elsewhere.\n I think similar things are possible in declarative language such as Prolog but I suspect that Prolog can actually do any more. Any good up-to-date reference on declarative programming languages would also be very useful.</p>\n\n<p>I originally posted a version of this question on the <a href="http://scicomp.stackexchange.com/questions/8637/a-jigsaw-problem-recreating-a-subgraph-from-a-limited-number-of-fragments-on-an">Computational Science</a> site but was advised that this forum could be better.</p>\n', 'ViewCount': '46', 'Title': 'a jigsaw problem: recreating a subgraph from a limited number of fragments on an original graph', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-09-30T23:47:50.627', 'LastEditDate': '2013-09-30T22:14:53.810', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '14716', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10416', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-09-30T19:20:47.333', 'Id': '14712''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Suppose we are given an M\xd7N matrix, with some elements are zero, some non-zero. We know the co-ordinates of non-zero elements. Now, if I am allowed to multiply a whole row or a whole column by zero one at a time what will be minimum number of operations (i.e multiplications) I will need. For example, for the matrix</p>\n\n<p>$\\begin{pmatrix}\n    0 &amp; 1 &amp; 0 \\\\\n    0 &amp; 0 &amp; 0 \\\\\n    1 &amp; 0 &amp; 1\n  \\end{pmatrix}$</p>\n\n<p>the answer is two. For this example</p>\n\n<p>$\\begin{pmatrix}\n    1 &amp; 1 &amp; 1 \\\\\n    0 &amp; 0 &amp; 1 \\\\\n    0 &amp; 0 &amp; 1\n  \\end{pmatrix}$</p>\n\n<p>the answer is two not three.</p>\n\n<p>Any help to go for head start is appreciated.</p>\n', 'ViewCount': '65', 'Title': 'What will be minimum no of operation to make whole matrix zero if one is allowed to multiply a row or column by zero?', 'LastEditorUserId': '6665', 'LastActivityDate': '2013-10-06T16:53:54.620', 'LastEditDate': '2013-10-06T16:53:54.620', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10516', 'Tags': '<algorithms><complexity-theory><graph-theory><data-structures><discrete-mathematics>', 'CreationDate': '2013-10-05T18:23:42.310', 'FavoriteCount': '1', 'Id': '14831''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know that Stable set cannot be approximated to constant factor. I saw a simple proof using OR product sometime back. I am unable to recall it. If anyone here knows what I am talking about could help fill my memory, that will be helpful.</p>\n\n<p>Is there a graph product $\\cdot$ such that $\\alpha(G\\cdot G)=\\alpha(G)^2$ for all  graphs $G$ and $G\\cdot G$ the product of $G$ with itself?</p>\n\n<p>I only need an answer to inapproximability to constant factor and I believe there is a one step proof for this.</p>\n\n<p>If we had such a product, then we have $\\alpha(G\\cdot G\\cdot\\cdots \\cdot G\\cdot G)=\\alpha(G)^k$. If $\\alpha(G\\cdot G\\cdot\\cdots \\cdot G\\cdot G)$ can be approximated to constant factor $\\sigma&gt;0$, then $\\alpha(G\\cdot G\\cdot\\cdots \\cdot G\\cdot G)=\\sigma\\hat\\alpha(G\\cdot G\\cdot\\cdots \\cdot G\\cdot G)=\\alpha(G)^k$ and since $0&lt;\\sqrt[k]{\\sigma}&lt;\\sigma$, we can get an approximation of $\\alpha(G)$ that is better than $\\sigma$ by $\\sqrt[k]{\\sigma\\hat\\alpha(G\\cdot G\\cdot\\cdots \\cdot G\\cdot G)}=\\alpha(G)$.</p>\n', 'ViewCount': '53', 'Title': 'Is there a graph product that is multiplicative in independence number?', 'LastEditorUserId': '9753', 'LastActivityDate': '2013-12-07T10:56:41.340', 'LastEditDate': '2013-10-06T13:53:35.667', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14860', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-10-05T19:42:26.987', 'Id': '14833''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '621', 'Title': 'Running Floyd-Warshall algorithm on graph with negative cost cycle', 'LastEditDate': '2013-10-06T13:05:25.863', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10519', 'FavoriteCount': '1', 'Body': u"<p>I am trying to find the answer to the following question for the Floyd-Warshall algorithm. Suppose Floyd-Warshall algorithm is run on a directed graph G in which every edge's length is either -1, 0, or 1. Suppose that G is strongly connected, with at least one u-v path for every pair u,v of vertices, and that G may have a negative-cost cycle. How large can the final entries A[i,j,n] be, in absolute value (n denotes number of vertices). Choose the smallest number that is guaranteed to be a valid upper bound?\nThere is the following answers:</p>\n\n<ol>\n<li>+\u221e</li>\n<li>n^2</li>\n<li>n - 1</li>\n<li>2^n</li>\n</ol>\n\n<p>I have ruled out 3. (n-1) and 1. (+\u221e) since if a graph has a negative cost cycle, the absolute final value of a path including a negative cycle can be increased further than n-1. The answer also cannot be +\u221e since the algorithm stops after a finite number of steps. But I am having trouble between answers 2. and 4. I am more inclined to 4. since I have run some test cases, and final values seemed to comply to an exponential growth. But I cannot find a proof for it. </p>\n", 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '10519', 'LastActivityDate': '2013-10-06T20:41:36.453', 'CommentCount': '7', 'AcceptedAnswerId': '14861', 'CreationDate': '2013-10-05T22:22:47.837', 'Id': '14839''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am working on a diagram editor.\nDiagrams display 2D shapes (<em>nodes</em>) connected with connectors (<em>edges</em>).</p>\n\n<p>I\'d like to add an operation that, given a selection of nodes, <em>"disentangles"</em> them: it repositions them to reduce the number of crossing edges, if possible\n(and it\'s OK if the edges will have to be drawn with bend points).</p>\n\n<p>So I want a graph algorithm that, given a (<em>topological</em>) graph embedding and a subset of its nodes, modifies the embedding (its <em>topology</em>) on only those nodes so as to minimize the number of crossing edges.</p>\n\n<p>From reading <a href="https://en.wikipedia.org/wiki/Apex_graph#Characterization_and_recognition" rel="nofollow">about apex graphs</a> and browsing <a href="http://epubs.siam.org/doi/abs/10.1137/120872310" rel="nofollow">Cabello and Mohar (2013)</a>, I suppose this problem is NP-hard.\nSo I\'ll be happy with a parametrized algorithm (e.g. on the number of crossing edges) that has a known, polynomial, time complexity for any given parameter value. This seems feasible, but I don\'t find it easy to come up with such an algorithm on my own.</p>\n\n<p>Questions:</p>\n\n<ul>\n<li>Where do I look for such an algorithm?</li>\n<li>Does it exist?</li>\n<li>In existing software?</li>\n<li>Is there any significant practical experience with such an operation? (What looks good in theory may not be so good in practice, or vice versa.)</li>\n</ul>\n\n<p><em>(I am not sure where best to ask this question: here, on StackOverflow, or MathOverflow?)</em></p>\n', 'ViewCount': '236', 'Title': 'How to reduce the number of crossing edges in a diagram?', 'LastEditorUserId': '917', 'LastActivityDate': '2013-10-08T18:57:07.263', 'LastEditDate': '2013-10-08T10:00:56.180', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '917', 'Tags': '<graph-theory><graph-algorithms><crossing-number>', 'CreationDate': '2013-10-08T09:45:18.533', 'FavoriteCount': '1', 'Id': '14901''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am reading a paper on <a href="http://talukdar.net/papers/adsorption_ecml09.pdf" rel="nofollow">Semi Supervised Learning</a> and I am confused about a term. The paper talks about graphs that are invariant to permutations of the vertices. Can somebody explain or perhaps give an example? Is it same a regular graphs?</p>\n', 'ViewCount': '43', 'Title': 'Graphs invariant to permutations of vertices', 'LastActivityDate': '2013-10-08T11:42:31.550', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1972', 'Tags': '<graph-theory><graphs><machine-learning>', 'CreationDate': '2013-10-08T11:42:31.550', 'Id': '14906''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to find an efficient solution to my problem. Let's assume that I have positive weighted graph <code>G</code> containing 100 nodes(each node is numbered) and it is an acyclic graph. So there cannot be any edge like 2,2 or 2,1. I have got a list of nodes let's say 10 from graph <code>G</code>. Let's say each of these nodes are also in an array. I am looking for a way to find the shortest path's total weight from node 1 to 100 that passes through at least some particular(let's say 5) of those nodes from that list.</p>\n\n<p>To simplify it, consider graph with 6 nodes, 0...5, now node 1 and 4 are marked as points where we could specify to pass. Let's say existing paths are 0-1-2-5, 0-3-4-5, and 1-4. Now let's say all edges are weighted as 5 except 3 to 4 is weighted as 1. If we run a shortest path algorithm this would basically find the path 0-3-4-5 as it is weighted 11. However if we run an algorithm specifying minimum amount of specified points and try the amount 2. Then the algorithm should be running on 0-1-4-5 which is weighted as 15.</p>\n\n<p>I have written this way</p>\n\n<pre><code>    shortestPath(destinationNode, minAmount) \n\n        if(destinationNode == srcNode &amp;&amp; minAmount &lt; 1) \n            return 0\n\n        else if(destinationNode == srcNode &amp;&amp; minAmount &gt; 1) \n            return INFINITY\n\n        int destNo = destinationNode get number\n        int cost = INFINITY\n        for (int i = 0; i &lt; destNo; i++)\n            if (d[i][destNo] != null) \n                int minimumAmountCount = minAmount;\n                for (int j = 0; j &lt; marked.length(); j++) \n                    if (marked[j] == i) \n                        minimumAmountCount = minimumAmountCount - 1;\n\n                cost = MIN(cost, shortestPath(Node(i), minimumAmountCount);\n\n        return cost;\n</code></pre>\n\n<p>Basically we call this algorithm by using the our destination node and minimum amount of nodes from that list. Firstly we want to make sure that this is a recursive function and it should have a stopping point, which would be when passed destination is equal to source node(which is essentially node #0). The second case we need to check is whether we visited enough amount, so if it is less than 1(0 or negative number) then we visited enough points and return 0 as distance from node #0 to node #0 would be 0. If we did not visit enough amount then we return infinity so that algorithm would consider other paths.</p>\n\n<p>So in order for the returning part to work, we have to define the destination node's number(if we consider that we have 100 nodes it would be node #99 at the initial start) and initialise cost as infinity.</p>\n\n<p>Then we run a for loop that starts from 0(essentially node #0) till our current node number, this is because there are no backwards edges on the graph. By using node number we check from the matrix whether there is an existing weight for those nodes. If it exist then we initialise a variable for our current minimum amount and then run a loop and check if source to the current destination is in the list of marked nodes. If it is marked then we simply decrement the minimum amount.</p>\n\n<p>For the final step we run the function again by changing destination as the current source and with the current minimum amount.</p>\n\n<p>But it seems very expensive, considering the fact that the worst case complexity of  nested loop takes O(|Node|^2) and total recurrence would take O(|Node|^2 * |Edges|). So is there any other efficient solution for this problem?</p>\n", 'ViewCount': '799', 'Title': 'Shortest path that passes through specific node(s)', 'LastEditorUserId': '8849', 'LastActivityDate': '2013-10-11T03:40:33.580', 'LastEditDate': '2013-10-10T23:46:31.867', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8849', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T06:29:19.223', 'FavoriteCount': '0', 'Id': '14977''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have written an A* algorithm to find the shortest path through a directed cyclic graph.  I am trying to modify it to find the longest path through the same graph.</p>\n\n<p>My attempt was to write it so that all I change is [1] the weights per edge (making them negative instead of positive) and [2] the heuristic function.</p>\n\n<p>I seem to be having trouble getting it to do this. It is pretty good at finding the longest path sometimes, but it is not guaranteed.  </p>\n\n<p>It seems that the problem lies with [2] the heuristic -- for shortest path an L2 norm is a good optimistic way to get it to head towards the goal, but for longest path I want the heuristic to point it at paths that are further from the goal to continue to increase total length. </p>\n\n<p>If I set the heuristic to return 0 so that it's a Dijkstra's search, it's less predictable as there's no incentive to search from nodes further away (using [1] negative weights per edge).</p>\n\n<p>I think if I keep the weights positive and try to maximize the score instead of minimize it may work, but I was attempting to do this without changing the algorithm, only the edge weights and the heurstic.</p>\n\n<p>I have found similar posts on stackExchange but they don't answer my specific questions:</p>\n\n<p>Q1) Can this be done with A*</p>\n\n<p>Q2) Is setting the weights negative the right thing to do</p>\n\n<p>Q3) Is the only way to do this is to set the heuristic to zero and keep the weights positive and try to maximize the score instead of minimize it?</p>\n", 'ViewCount': '1136', 'Title': 'A* to find the longest path in a directed cyclic graph', 'LastActivityDate': '2013-10-10T22:54:53.123', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14996', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10643', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T18:39:05.643', 'Id': '14991''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>So I have some graph, and I know what it's max flow is based of the Ford-Fulkerson Algorithm.</p>\n\n<p>With this information, I need to know how to find a new max flow when I remove an edge of this graph with flow capacity 1. The algorithm must run in O(v+e) time where v is the number of vertices in the graph, and e the number of edges.</p>\n\n<p>I have an idea, but I don't think it will run in O(v+e). \nI might just be confused about big O notation, but my algorithm would run in O(v+e+v)=O(2v+e) time. Would that just be considered O(v+e) time? If not, what part of my proposed algorithm should be reconsidered? Should I make a completely different approach (maybe considering if the deleted edge is in the min-cut or not?).</p>\n\n<p>Thanks in advance!</p>\n", 'ViewCount': '85', 'ClosedDate': '2013-10-14T07:48:03.477', 'Title': 'Recalculate max-flow after removing edge with 1 capacity', 'LastEditorUserId': '10680', 'LastActivityDate': '2013-10-13T21:45:05.603', 'LastEditDate': '2013-10-13T21:44:47.073', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10680', 'Tags': '<algorithms><graph-theory><algorithm-analysis><dynamic-programming>', 'CreationDate': '2013-10-12T20:18:55.893', 'Id': '15023''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>It seems to me that taken over the entire graph, the norm of the error vector must be monotonically decreasing, otherwise we couldn't guarantee that PageRank would ever converge.</p>\n\n<p>However, is the same true on a per-vertex basis? I.e., from iteration t to iteration t+1, is the squared error of a vertex guaranteed to always decrease as it moves closer to its PageRank value? Or is it possible that the vertex squared error would ever increase?</p>\n\n<p>This also seems to me to have some broader relationship with power iterations in general? Some explanation or proof with the answer would be appreciated.</p>\n", 'ViewCount': '48', 'Title': 'Is the per-vertex error over a PageRank iteration monotonically decreasing?', 'LastActivityDate': '2013-10-15T02:00:25.790', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16094', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '10683', 'Tags': '<graph-theory><algorithm-analysis><error-estimation>', 'CreationDate': '2013-10-12T20:56:11.653', 'Id': '15024''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'ve been struggling with this problem for days now, making no progress:</p>\n\n<blockquote>\n  <p>There are N points on an XY plane. In one turn, you can select a set of collinear points on the plane and remove them. Your goal is to remove all the points in the least number of turns. Given the coordinates of the points, calculate two things:</p>\n  \n  <ul>\n  <li>The minimum number of turns (T) needed to remove all the points.</li>\n  <li>The number of ways to to remove them in T turns. Two ways are considered different if any point is removed in a different turn.</li>\n  </ul>\n</blockquote>\n\n<p>-- <a href="https://www.hackerrank.com/challenges/points-in-a-plane" rel="nofollow">https://www.hackerrank.com/challenges/points-in-a-plane</a></p>\n\n<p>I\'ve tried a greedy exhaustive solution, where I draw a line between each pair of points, then start to eliminate the lines in descending order based on the number of points they cross. Unfortunately, there is at least one case where this approach produces suboptimal results:</p>\n\n<p>For ease of discussion, I will call lines "longer" or "shorter", based on how many points they include. The greedy algorithm is simply to eliminate lines in order of descending length.</p>\n\n<p>Suppose we have a set of N longer lines, and another set of M shorter lines. Our greedy algorithm will eliminate the long lines first. But what if every single point of the long lines is also included in a short line?  In that case,our initial elimination of the N longer line was a waste, since we would have gotten those lines "for free" had we just eliminated the shorter lines. Specifically, our greedy approach will require N + M eliminations, where we could have cleared all points in just M steps.</p>\n\n<p>The simplest example input demonstrating this is:</p>\n\n<pre><code>(0, 1), (1, 2), (2, 4), (3, 3)\n(0, 0), (1, 0), (2, 0), (3, 0)\n(0,-1), (1,-2), (2,-4), (3,-3)\n</code></pre>\n\n<p>As you can see, we have a line of length 4 running along the X axis, and 4 shorter vertial lines of length 3 perpendicular to it. Our greedy algorithm will first eliminate the longest line, after which there will be 8 sets of points remaining, with no more than 2 of them collinear. Eliminating those will thus take 4 steps, for a total 5, where we could have eliminated all points in just 4 steps, had we simply eliminated the 4 vertical lines first.</p>\n\n<p>Could someone provide at least a hint at the general body of knowledge required to approach this? I solved many other HackerRank questions, but can\'t make any headway with this one.</p>\n', 'ViewCount': '293', 'Title': 'Points-in-a-plane from HackerRank', 'LastEditorUserId': '10768', 'LastActivityDate': '2013-10-18T20:31:51.190', 'LastEditDate': '2013-10-18T20:31:51.190', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '16150', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10768', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2013-10-15T20:20:51.557', 'Id': '16111''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In the chapter, <em>Approximation Algorithms</em> of <em>Introduction to Algorithm, 3rd Edition</em>, for the approximation problem <strong>Travelling Salesman Problem</strong>, the author proposes a approximation method that first constructs a minimum spanning tree.</p>\n\n<p><img src="http://i.stack.imgur.com/G9Bvx.png" alt="enter image description here"></p>\n\n<p>In order to prove this algorithm is a 2-approximation algorithm, the author claims that:</p>\n\n<p>The weight of the minimum spanning tree $T$ is less than the cost of the optimal tour.</p>\n\n<p>I am wondering if the minimum spanning tree(which is <strong>acyclic</strong>) of $G$ ensures that its weight is <strong>necessarily</strong> smaller than any tour(which is <strong>cyclic</strong>) of the same graph $G$</p>\n\n<p>PS: </p>\n\n<p>The original claim is:</p>\n\n<p><img src="http://i.stack.imgur.com/MGgcu.png" alt="enter image description here"></p>\n', 'ViewCount': '134', 'Title': 'Approximated TSP: weight of minimum spanning tree less than cost of the optimal tour?', 'LastActivityDate': '2013-10-16T17:49:55.960', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><graph-theory><traveling-salesman><approximation-algorithms>', 'CreationDate': '2013-10-16T17:45:18.160', 'FavoriteCount': '1', 'Id': '16144''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>To find the maximum flow in a graph, why doesn't it suffice to only saturate all augmenting paths with the minimum edge capacity in that path without considering the back-edges? I mean, what is the point calling it a back-edge if we assume flow from it?</p>\n", 'ViewCount': '52', 'Title': 'Saturating all augmenting paths with the minimum edge capacity in max flow', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T21:07:48.467', 'LastEditDate': '2013-10-18T21:07:48.467', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10525', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs><network-flow>', 'CreationDate': '2013-10-18T17:15:17.717', 'Id': '16202''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '92', 'Title': "Courcelle's Theorem: Looking for papers", 'LastEditDate': '2013-10-22T09:51:25.143', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1382', 'FavoriteCount': '1', 'Body': '<p>I am looking for an easy and introductory paper on the proof of <a href="http://en.wikipedia.org/wiki/Courcelle%27s_theorem">Courcelle\'s Theorem</a>. I am also interested in its connection to <a href="http://en.wikipedia.org/wiki/Parameterized_complexity">parameterized complexity</a> regarding the <a href="http://en.wikipedia.org/wiki/Treewidth">treewidth</a>.</p>\n\n<p>I am only a beginner in this field.</p>\n\n<p>Any suggestions?</p>\n', 'Tags': '<complexity-theory><graph-theory><reference-request><discrete-mathematics><parametrized-complexity>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-12T21:25:05.823', 'CommentCount': '0', 'AcceptedAnswerId': '16326', 'CreationDate': '2013-10-22T09:20:33.627', 'Id': '16324''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '102', 'Title': 'Direct reduction from Near-Clique to Clique', 'LastEditDate': '2013-10-22T13:16:24.780', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10913', 'FavoriteCount': '2', 'Body': '<p>An undirected graph is a Near-Clique if adding one more edge would make it a clique. Formally, a graph $G=(V,E)$ contains a near-clique of size&nbsp;$k$ if there exists $S\\subseteq V$ and $u,v\\in S$ where $|S|=k$, $(u,v)\\notin E$, and $S$&nbsp;forms a clique in $(V,E\\cup\\{(u,v)\\})$. How can I show a direct reduction from Near-Clique to Clique?</p>\n', 'Tags': '<complexity-theory><graph-theory><reductions><np>', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-10-23T03:08:34.873', 'CommentCount': '1', 'AcceptedAnswerId': '16349', 'CreationDate': '2013-10-22T09:31:12.100', 'Id': '16325''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have graphs $G_k$ and $H_k$ with $|\\mathcal{V}(G_k)|=|\\mathcal{V}(H_k)|^{2k}=n^{2k}$ with $k\\in\\Bbb N$ that pass sanity checks such as no-homomorphism lemma. Are there free and easy to use tools to test graph homomorphism from $G$ to $H$?</p>\n', 'ViewCount': '167', 'Title': 'Software for testing graph homomorphism', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-25T19:08:17.933', 'LastEditDate': '2013-10-24T13:29:06.540', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-10-23T21:36:20.043', 'FavoriteCount': '0', 'Id': '16375''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G$ be a graph on $|\\mathcal{V}(G)|$ vertices. If $H$ is another graph that contains a clique of size $|\\mathcal{V}(G)|$, then does it mean $G$ is subgraph isomorphic to $H$? Does this mean that all graphs with vertices less than $|\\mathcal{V}(G)|$ are subgraph isomorphic to $H$?</p>\n\n<p>If the above is not the case, is there another term for the exact presence of $G$ in $H$ as a structure preserved subgraph (when I say structure preserved, that means, edges are mapped to edges and non-edges are mapped to non-edges in the subgraph of $H$)?</p>\n', 'ViewCount': '41', 'Title': 'A technical clarification on subgraph isomorhism', 'LastActivityDate': '2013-10-25T07:42:32.967', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16423', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<graph-theory>', 'CreationDate': '2013-10-25T07:23:54.277', 'Id': '16421''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>A ranking algorithm determines the position (or rank) of a combinatorial object among all the objects (with respect to a given order); an unranking algorithm finds the object having a specified rank. Thus, ranking and unranking can be considered as inverse operations.</p>\n</blockquote>\n\n<p>The following lattice has 9 unique max length paths from {} to {1,2,3,4,5}, which can be obtained by a depth first search.</p>\n\n<p><img src="http://i.stack.imgur.com/wGYHo.png" alt="lattice">(The graph is directed, with arrows pointing down)</p>\n\n<p>Is it possible to write a function that generates the N\'th path without enumerating paths 1..N-1.</p>\n\n<p>see: <a href="http://math.stackexchange.com/questions/510911/computing-all-simple-paths-in-a-distributive-lattice-in-parallel">http://math.stackexchange.com/questions/510911/computing-all-simple-paths-in-a-distributive-lattice-in-parallel</a> for more problem details.</p>\n', 'ViewCount': '53', 'Title': 'Unranking paths in a graph/lattice', 'LastActivityDate': '2013-10-26T02:10:56.440', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16437', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10979', 'Tags': '<graph-theory><combinatorics><lattices>', 'CreationDate': '2013-10-25T21:37:10.387', 'Id': '16433''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm having trouble understanding why it's easy to detect negative-weight cycles (Bellman Ford) but hard to find the maximum weight cycle in an undirected graph. </p>\n\n<p>If we negate the weight of each edge, we can easily find if there are any cycles with total weight > 0. However it must not be easy to find if there are any cycles with weight > 1 or else we could repeat with 2, 3, 4 etc until the answer is no.</p>\n\n<p>Is this correct? Why is it so much harder to detect if there exists a cycle with weight > 1 then to find if there is a cycle with weight > 0?</p>\n", 'ViewCount': '97', 'Title': 'Negative weight cycle vs maximum weight cycle', 'LastActivityDate': '2013-11-07T21:20:02.610', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '10987', 'Tags': '<complexity-theory><graph-theory>', 'CreationDate': '2013-10-26T13:13:26.430', 'Id': '16442''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am well aware of the DP solution to the traveling salesman problem; also known as the Held and Karp algorithm for TSP.</p>\n\n<p>I have implemented it with bitmask, and it's something like this:</p>\n\n<pre><code>int TSP(int pos, int bitmask) {\n    if (bitmask == (1&lt;&lt;(K+1))-1)\n        return dist[pos][0];              // Completing the round trip\n\n    if (memo[pos][bitmask] != -1)\n        return memo[pos][bitmask];\n\n    int answer = INF;\n    for (int i = 0; i &lt;= K; i++) {\n        if (i != pos &amp;&amp; (bitmask &amp; (1 &lt;&lt; i)) == 0)\n               answer = Math.min(answer, dist[pos][i] + TSP(i, bitmask | (1 &lt;&lt; i)));\n    }\n\n    return memo[pos][bitmask] = answer;     // Storing the best dist for the set of traveled cities and untraveled ones.\n</code></pre>\n\n<p>This algorithm is quite fast; computation of 15 cities is relatively fast enough. However, I notice that it could be further improved to accommodate around 20 cities.</p>\n\n<p>1) If the dist matrix is symmetrical, perhaps we can make use of this property to prevent repeated calculations. (e.g a->b->c->d->a == a->d->c->b->a)</p>\n\n<p>2) Using both a upper and lower bound to prune. The above algorithm is able to get its first possible optimal solution in a very short time, might be able to use that.</p>\n\n<p>I have tried to improve the algorithm based on the aforementioned two principles. However, I don't get a better algorithm.</p>\n\n<p>Am I making a futile attempt at improving something impossible? What do you think?</p>\n", 'ViewCount': '89', 'Title': 'Traveling Salesman with Held and Karp Algorithm', 'LastActivityDate': '2013-10-27T15:00:58.337', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10999', 'Tags': '<graph-theory><np-complete><dynamic-programming><traveling-salesman>', 'CreationDate': '2013-10-27T15:00:58.337', 'Id': '16474''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I asked this question on stackoverflow, but was suggested to post to same here. So here goes.</p>\n\n<p>The following problem was asked in the recent <a href="https://www.hackerrank.com/contests/oct13/challenges/missile-defend" rel="nofollow">October 20-20 Hack on Hackerrank</a> :</p>\n\n<blockquote>\n  <p>Evil Nation A is angry and plans to launch N guided-missiles at the\n  peaceful Nation B in an attempt to wipe out all of Nation B\u2019s people.\n  Nation A\u2019s missile i will arrive in nation B at the time ti. Missile i\n  communicates with its headquarters by unique radio signals with a\n  frequency equal to fi. Can you help the peaceful Nation B survive by\n  building a defensive system that will stop the missiles dead in the\n  sky?</p>\n  \n  <p><strong>Defensive system:</strong></p>\n  \n  <p>The only way to defend Nation B from the attacking missile is by\n  counter attacking them with a hackerX missile. You have a lot of\n  hackerX missiles and each one of them has its own radio frequency. An\n  individual hackerX missile can destroy Evil Nation A\u2019s attacking\n  missile if the radio frequency of both of the missiles match. Each\n  hackerX missile can be used an indefinite number of times. Its\n  invincible and doesn\u2019t get destroyed in the collision.</p>\n  \n  <p>The good news is you can adjust the frequency of the hackerX missile\n  to match the evil missiles\u2019 frequency. When changing the hackerX\n  missile\u2019s initial frequency fA to the new defending frequency fB, you\n  will need |fB - fA| units of time to do.</p>\n  \n  <p>If two evil missles with same\n  frequency arrive at the same time, we can destroy them both with one\n  hackerX missile. You can set the frequency of a hackerX missile to any\n  value when its fired.</p>\n  \n  <p>What is the minimum number of hackerX missiles you must launch to keep\n  Nation B safe?</p>\n  \n  <p><strong>Input Format:</strong> The first line contains a single integer N denoting the\n  number of missiles.  This is followed by N lines each containing two\n  integers ti and fi denoting the time &amp; frequency of the ith missile.</p>\n  \n  <p><strong>Output Format:</strong> A single integer denoting the minimum number of\n  hackerX\u2019s you need to defend the nation.</p>\n  \n  <p><strong>Constraints:</strong> \n  1 &lt;= N &lt;= 100000</p>\n  \n  <p>0 &lt;= ti &lt;= 100000</p>\n  \n  <p>0 &lt;= fi &lt;= 100000</p>\n  \n  <p>t1 &lt;= t2 &lt;= \u2026 &lt;= tN</p>\n</blockquote>\n\n<p>The problem gets reduced to a Minimum Path Cover Problem which is to be solved in <code>O(nlogn)</code> time based on the constrainsts.\nHowever the best solution to a Minimum Path Cover Problem is using the Hopcroft\u2013Karp algorithm, that leads to the Maximal Matching Problem. The solution to which is <code>O(n^2.5)</code>.\nBut the following solution by <code>icyrhyme9733</code> solves the problem in <code>O(nlogn)</code> :</p>\n\n<pre><code>#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n\nint main() {\n    /* Enter your code here. Read input from STDIN. Print output to STDOUT */\n    int n;\n    cin &gt;&gt; n;\n    vector&lt;pair&lt;int, int&gt; &gt; vp;\n    for(int i = 0; i &lt; n; ++i) {\n        int t, f;\n        cin &gt;&gt; t &gt;&gt; f;\n        vp.push_back(make_pair(t + f, t - f));\n    }\n    sort(vp.begin(), vp.end());\n    reverse(vp.begin(), vp.end());\n    vector&lt;int&gt; last(vp.size(), numeric_limits&lt;int&gt;::max());\n    for(int i = 0; i &lt; vp.size(); ++i) {\n        *lower_bound(last.begin(), last.end(), vp[i].second) = vp[i].second;\n    }\n    cout &lt;&lt; lower_bound(last.begin(), last.end(), numeric_limits&lt;int&gt;::max()) - last.begin() &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n\n<p>Is it solving a <code>Minimum Path Cover Problem in O(nlogn)</code> time ?  Or is there an optimization that I am missing ?</p>\n\n<p>I found a similar problem on <a href="http://stackoverflow.com/a/10508198/1016784">this thread</a>. They have taken advantage of the fact that the graph is an Interval Graph. Even though being very similar, the same solution cannot be implemented, as the intervals are inverted.</p>\n', 'ViewCount': '121', 'Title': 'DAG Minimum Path Cover in O(nlogn)?', 'LastActivityDate': '2013-10-28T17:37:21.440', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><intervals>', 'CreationDate': '2013-10-28T17:37:21.440', 'Id': '16510''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Although this seems rather obvious, I couldn't prove it rigorously. Any ideas how to prove it? The graph is assumed to be simple and connected.</p>\n\n<p>Explanation of the terms:</p>\n\n<ul>\n<li>$k$-regular means that all vertices have degree $k$;</li>\n<li>bipartite means that there are 2 sets of vertices $X, Y$, where vertices from $X$ only have edges with vertices $Y$ and vertices from $Y$ only have edges with vertices from $X$;</li>\n<li>cut-edge is an edge which removal disconnects the graph;</li>\n</ul>\n\n<p>This is b) part of the exercise, maybe a) part can help:</p>\n\n<p>a) If all vertices $v \\in G$ have an even degree, $G$ does not have cut-edge</p>\n\n<p>From a) it actually follows that for even $k$, b) is true, thus only case with odd $k$ left to prove.</p>\n", 'ViewCount': '250', 'Title': 'Prove that a $k$-regular bipartite graph with $k \\geq 2$ has no cut-edge', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-30T10:11:29.557', 'LastEditDate': '2013-10-30T10:10:21.863', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8770', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-10-29T10:44:19.740', 'Id': '16537''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>An <em>independent set</em> is a set of vertices in a graph, no two of which are adjacent.</p>\n\n<p>A maximum independent set is a largest independent set for a given graph G.</p>\n\n<p>Is there a standard term for the size of the largest independent set in a given graph?</p>\n\n<p>If not, what short term can you suggest for this size? Maybe "independence number"? </p>\n', 'ViewCount': '37', 'Title': 'Term for size of maximum independent set', 'LastActivityDate': '2013-10-30T09:04:54.070', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16571', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<graph-theory><terminology>', 'CreationDate': '2013-10-30T07:41:00.953', 'Id': '16569''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a nice idea to optimize TSP by removing nodes, its going to be hard for me to explain my self, so please be patient with me and try to understand what I am saying.</p>\n\n<p>I have a symmetric(the weight of $AB$ is equal to $BA$), undirected graph where all the weights are 1 or 2.</p>\n\n<p>I am trying to find TSP optimal tour for this graph. Also I know that the optimal tour is only contains edges with the weight of 1.</p>\n\n<p>I been looking in to my data and I found that there is a node that only have two edges of 1 connected to it - lets call this node $B$ and those edges that connected to him $AB$ and $BC$. I know that $AB,BC$ must be part of the optimal tour because in any other way we will have an edge with the weight of 2, and by definition this can't be . So I am removing the node $B$ and adding extra edge $AC$ between the endpoints of the removed node, and I am giving him the weight of 1. Now when I will solve the TSP I can replace it by the two edges that I removed.</p>\n\n<p>Now I want to try something bigger and I am not sure that it will work, so this is what the question is about. Lets assume that we have not 2 but 3 edges connected to one node with the weight of 1, can we remove this node and add extra two edges using the same idea as before?</p>\n", 'ViewCount': '86', 'Title': 'Symmetric TSP optimization by removing nodes', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-11-04T12:30:04.023', 'LastEditDate': '2013-11-04T10:43:43.307', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graph-theory><traveling-salesman>', 'CreationDate': '2013-11-04T08:32:03.913', 'Id': '16696''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am learning about CS Theory and specifically Nondeterministic Finite Automata (NFA) right now. In my book I came across a section of text that discussed a way to determine the length of a walk stating specifically that :</p>\n\n<blockquote>\n  <p>If a transition graph has a walk labeled $w$, then there is a walk <em>w</em> of length no more than $\\Lambda + (1 + \\Lambda)|w|$ where $\\Lambda$ is the number of $\\lambda$ transitions in the graph.</p>\n</blockquote>\n\n<p>The book does not define $|w|$ which is causing part of my confusion. I\'m assuming $|w|$ is the length of the label of the walk. So in this case it would be 1 when going from $q_1 \\to q_0 \\to q1$ because $a$ is the only labeled edge.\nI am trying to understand this concept and how it works because when I have tested out this claim it has not held true.</p>\n\n<p>Here is the test I did with this NFA</p>\n\n<p><img src="http://i.stack.imgur.com/9tV6X.png" alt="enter image description here"></p>\n\n<p>$q_1$ is the final state. So assuming you were trying to find the length of the walk $a$, the label would indicate that the length is 1 (e.g. $\\delta^* (q_1, a)$) . However due to the lambdas you actually have $\\lambda \\lambda a$ to go from $q_1 \\to q_0 \\to q_1$.</p>\n\n<p>This theorem doesn\'t hold with my math though because it is defined as \u039b + (1 + \u039b)|w| where \u039b is the number of \u03bb-edges in the graph.</p>\n\n<p>Since there are two \u03bb-edges (and it doesn\'t state whether it means \u03bb-edges in the walk itself or in the graph in total...) this would then be 2 + (1 + 2)|w|. So thats 2 + 3|w|. This clearly is more than 3, which is the length of q1 -> q1 of \u03bb\u03bba.</p>\n\n<p>What am I missing here? Any help is greatly appreciated.</p>\n\n<p>This comes from Peter Linz "An Introduction to Formal Languages and Automata" 5th edition.</p>\n\n<p>Some more information about the argument for this claim:</p>\n\n<blockquote>\n  <p>While \u03bb-edges may be repeated, there is always a walk in which every repeated \u03bb-edge is separated by an edge labeled with a nonempty symbol. Otherwise, the walk contains a cycle labeled \u03bb, which can be replaced by a simple path without changing the label of the walk.</p>\n</blockquote>\n\n<p>Also the book never names this as a theorem or lemma or anything of the sort so it has been very difficult to find online resources about this topic.</p>\n', 'ViewCount': '90', 'Title': 'Determining Length of a walk in Nondeterministic Finite Automata with Lambda Transitions', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:40:46.183', 'LastEditDate': '2013-11-28T21:40:46.183', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11178', 'Tags': '<graph-theory><finite-automata><nondeterminism>', 'CreationDate': '2013-11-04T17:36:38.040', 'FavoriteCount': '0', 'Id': '16716''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have found an interesting exercise in my introduction to graphs workbook:</p>\n\n<p>Let $ad(G) = \\frac{2\\vert E(G)\\vert}{\\vert V(G) \\vert}$ and $mad(G) = max\\{ad(H): H\\ is\\ an\\ induced\\ subgraph\\ of\\ G\\}$.</p>\n\n<p>Given a graph $G$ and a number $k \\geq 3$, prove that if $\\chi(G) &gt; k \\wedge mad(G) \\leq k \\Rightarrow \\exists A \\subseteq V(G)$ such that $[A]_{G}$ is $k - regular$.</p>\n\n<p>I believe this can proved by contradiction:</p>\n\n<p>Given a $G$ and $k$ for which the properties hold, we assume that $G$ has no induced subgraph $H$ that is $k - regular$. We then prove that if $\\nexists H$ then at least one of the property is false and thus we contradict ourselves however I can't quite figure out the connection between $H$ and the mentioned properties.</p>\n\n<p>How would you go about solving this?</p>\n", 'ViewCount': '74', 'Title': 'How can I prove that if $\\chi(G) > k \\wedge \\vert\\{ad(H): H\\ is\\ an\\ induced\\ subgraph\\ of\\ G\\}\\vert$ then $G$ has a $k-regular$ induced subgraph?', 'LastActivityDate': '2013-11-05T07:16:43.693', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11183', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-11-04T19:35:20.957', 'Id': '16720''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am aware of a logarithmic-time algorithm to maintain the connected components of graphs in the Euclidean plane <a href="http://web.cs.swarthmore.edu/~adanner/cs97/s08/pdf/eppstein92maintenance.pdf" rel="nofollow">(D. Eppstein, GF Italiano, R. Tamassia, RE Tarjan, J. Westbrook, and M. Yung. Maintenance of a minimum spanning forest in a dynamic plane graph. <em>J. Algorithms</em>, 13 (1): 33 {54, 1992.).</a></p>\n\n<p>Does anyone know if there is an implementation of this work or if there are other results that are easier to implement?</p>\n', 'ViewCount': '50', 'Title': 'Help for implementing the maintenance of the connected components in the Euclidean plane in logarithmic time', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-06T16:03:25.510', 'LastEditDate': '2013-11-06T16:03:25.510', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11227', 'Tags': '<graph-theory><graphs><computational-geometry>', 'CreationDate': '2013-11-06T14:54:30.473', 'FavoriteCount': '1', 'Id': '16773''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '281', 'Title': 'CNF Generator for Factoring Problems', 'LastEditDate': '2013-11-07T21:03:05.140', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10572', 'FavoriteCount': '1', 'Body': '<p>I\'ve been reading these:</p>\n\n<ul>\n<li><a href="http://cstheory.stackexchange.com/questions/6755/fast-reduction-from-rsa-to-sat">Fast Reduction from RSA to SAT</a></li>\n<li><a href="http://cgi.cs.indiana.edu/~sabry/cnf.html" rel="nofollow">CNF Generator for Factoring Problems</a> (Also have C code implementation)</li>\n</ul>\n\n<p>I don\'t understand how the reduction from <a href="https://en.wikipedia.org/wiki/Integer_factorization" rel="nofollow">FACT</a> to <a href="https://en.wikipedia.org/wiki/Clausal_normal_form" rel="nofollow">$3\\text{-SAT}$</a> works. Are there any simple articles in which I can read about it?</p>\n\n<p>My final goal is to eventually implement a reduction from $3\\text{-SAT}$ to the <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem" rel="nofollow">undirected Hamiltonian circuit problem</a>.</p>\n', 'Tags': '<algorithms><graph-theory><reductions><factoring><hamiltonian-path>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-13T22:15:26.360', 'CommentCount': '7', 'AcceptedAnswerId': '16805', 'CreationDate': '2013-11-07T06:57:01.380', 'Id': '16789''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A book I read states "Since $G$ is planar, $G$ has a vertex $v$ of degree at most 5".</p>\n\n<ol>\n<li>Is this true?</li>\n<li>Why?</li>\n<li>Does this theorem have a name?</li>\n</ol>\n', 'ViewCount': '61', 'Title': 'Is there a low degree vertex in planar graphs?', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-11-08T00:37:30.570', 'LastEditDate': '2013-11-08T00:37:30.570', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16802', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9407', 'Tags': '<graph-theory>', 'CreationDate': '2013-11-07T18:37:01.617', 'Id': '16800''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For a given acyclic graph $G$, a topological sort is an ordering $v_1, \\dots, v_n$ of the vertices such that the arrows in the graph are all directed forward under that ordering.</p>\n\n<p>Question: can all topological orders of a graph $G$ be obtained from a single ordering by iteratively swapping two vertices that are not connected by an edge?</p>\n\n<p>Motivation. In a certain context I am trying to prove that all topological sorts of an acyclic graph are in fact "equivalent". I want to do this by comparing $v_1, \\dots, v, v\', \\dots v_n$ and $v_1, \\dots, v\', v, \\dots v_n$ where there is no edge between $v,v\'$.</p>\n', 'ViewCount': '104', 'Title': 'topological sort equivalence', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-19T11:41:08.957', 'LastEditDate': '2013-11-09T15:23:59.883', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<graph-theory><graphs><sorting>', 'CreationDate': '2013-11-09T14:47:39.720', 'FavoriteCount': '1', 'Id': '16848''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let $G$ be a graph, and let $s$ and $t$ be two vertices of $G$. Can we efficiently sample a shortest $s$-$t$ path uniformly and independently at random from the set of all shortest paths between $s$ and $t$? For simplicity, we can assume $G$ is simple, undirected and unweighted.</p>\n\n<p>Even in many restricted graphs, the number of shortest paths between $s$ and $t$ can be exponential in the size of $G$. Therefore, we would naturally like avoid actually computing all the shortest $s$-$t$ paths. I don't know about the general case, but it seems to me that we can achieve this for some special graph classes.</p>\n\n<p>This feels like something someone must have considered before. Is there any existing research into this, or is this in fact simple to do even for general graphs?</p>\n", 'ViewCount': '187', 'Title': 'Efficiently sampling shortest $s$-$t$ paths uniformly and independently at random', 'LastActivityDate': '2013-11-12T15:18:07.457', 'AnswerCount': '2', 'CommentCount': '14', 'AcceptedAnswerId': '17929', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<graph-theory><reference-request><shortest-path><sampling>', 'CreationDate': '2013-11-11T14:36:27.297', 'FavoriteCount': '4', 'Id': '17917''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So say we have a bipartite graph G=(X,Y,E). Let\'s make a game out of it.</p>\n\n<p>I go first. I pick a node in X. You go next. You pick a node in Y that is connected by an edge to the node I picked. Next it\'s my turn. I pick another node in X (must be a new one that hasn\'t been used before) that is also connected to the node in Y you just picked. We continue playing in this manner, until someone cannot pick a node (i.e. all edges out of the current node have already been used). When that happens, the person who cannot pick a next node loses.</p>\n\n<p>I\'m supposed to find a polynomial time algorithm to decide which of the two players (you or me) can force a "win" for a given bipartite graph.</p>\n\n<p>I\'m stumped. I\'ve approached this in many different ways, including the following two:</p>\n\n<p>1) 1) each node in the xy "path" played will use two edges, except for the first and last nodes which will only use one edge. Idea: add one new node on each side of the bipartite graph, and connect to all opposite nodes. Then check for a perfect (or maximal) matching twice, removing the edges used in the first perfect (maximal) matching when finding the second one. I don\'t think this really helps us with the problem, though, as there are many different nodes you could visit next given a current node.</p>\n\n<p>2) A second idea was to work with alternating/augmenting paths (as we "zig-zag" between the two sides). I again got stuck since at any given node there are many possible nodes to visit next.</p>\n\n<p>Does anyone have any suggestions for this problem? I\'m thinking it has to do with matching, but I could be wrong.</p>\n\n<p>Thanks in advance!</p>\n', 'ViewCount': '120', 'Title': 'Bipartite Graph Game', 'LastActivityDate': '2013-11-13T08:27:30.500', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '17976', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10680', 'Tags': '<graph-theory><graphs><combinatorics><computer-networks><bipartite-matching>', 'CreationDate': '2013-11-12T22:58:47.500', 'Id': '17974''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Is it possible to modify Dijkstra\xb4s algorithm in order to get the longest path from $s$ to $t$ ?.</p>\n\n<blockquote>\n  <p>My intuition says that I\xb4ll need a different algorithm entirely. Finding the longest path is the same as finding the shortest path on a graph with negative weights. However, Dijkstra\u2019s algorithm requires that the weights are positive, so it cannot be modified to calculate the longest path. A better algorithm to use could be: <a href="http://en.wikipedia.org/wiki/Longest_path_problem" rel="nofollow">http://en.wikipedia.org/wiki/Longest_path_problem</a></p>\n</blockquote>\n\n<p>Any idea of how to modify it?</p>\n', 'ViewCount': '1734', 'ClosedDate': '2013-11-17T01:20:19.727', 'Title': 'Is it possible to modify dijkstra algorithm in order to get the longest path?', 'LastActivityDate': '2013-11-14T03:25:44.443', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10610', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs>', 'CreationDate': '2013-11-13T07:40:20.250', 'Id': '17980''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My Problem is like this:</p>\n\n<ol>\n<li><p>I have a physical layout represented as a graph. The Nodes represents hooks/ducts where a wire can anchor and Edges are the possible connection between 2 nodes from where wire can go.</p></li>\n<li><p>There are some special Nodes, called splitters, from where a single wire can be splitted to  2 or more up to k. The k can be taken constant for now but it varies from node to node. Not all nodes are splitters. </p></li>\n<li><p>There is one source of power from where a wire will emerge. It is the source. The wire has to be taken to n sinks. </p></li>\n<li><p>An edge can take any number of wires traversing through it in either direction.</p></li>\n<li><p>The the total wire length has to be minimized. </p></li>\n<li><p>The nature of graph, planar or euclidean is not known. </p></li>\n</ol>\n\n<p><strong>Example</strong>: Below is a sample network. Nodes are named as numbers and edges are provided with equal weights of 1. Source is Node1 and Sinks are Node5, Node9 and Node13. In case 1 Node6 is Splitter node. In case 2 Node6 and Node4 are splitter nodes. The splitter node\'s k=3, i.e., it can take in one wire and split it out to 3 wires.</p>\n\n<p><strong>Case 1</strong>. Only one splitter Node. It makes sense to split at Node6.\n<img src="http://i.stack.imgur.com/IVvkw.jpg" alt="enter image description here"></p>\n\n<p><strong>Case 2</strong>. Two splitter Node. It makes sense to split at Node4 instead of Node6.\n<img src="http://i.stack.imgur.com/6ZKJD.jpg" alt="enter image description here"></p>\n\n<p>I am looking for different strategies to find out a generic solution for this problem. The graph presented here is of a smaller scale as compared to the problem in hand. The graph is static and can not be changed (i mean the solution should not suggest any new edge or propose new splitter location ). \nAny reference to research paper published on this kind of problem is also welcomed.</p>\n\n<p><strong>Case 3</strong>. Two splitter Node. It makes sense to split at Node4 and Node14. Note that this case has edge weights changed for Edge 8-12, 6-10 and 10-11. The important thing in this case is retracing of a wire after getting splitted from Node14.</p>\n\n<p><img src="http://i.stack.imgur.com/aYuPN.jpg" alt="enter image description here"></p>\n', 'ViewCount': '128', 'Title': 'Wiring Length Minimization', 'LastEditorUserId': '7976', 'LastActivityDate': '2014-01-20T06:19:48.023', 'LastEditDate': '2013-11-15T09:44:52.997', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '7976', 'Tags': '<algorithms><graph-theory><optimization>', 'CreationDate': '2013-11-15T08:43:01.883', 'FavoriteCount': '3', 'Id': '18041''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I will be given some kind of this graph as in the picture below. I\'ve searched some algorithms but it seams as if it is something impossible for me to figure them out. In fact using <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">Floyd\u2013Warshall algorithm</a> it is kinda of possible, but unfortunately I\'m only allowed to use stacks (instead of matrices). I also looked for <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a> but I could not get the relationship with my problem.<img src="http://i.stack.imgur.com/z6bfG.png" alt="picture"></p>\n\n<p>Clearly my aim is to get all <strong>shortest paths</strong> from one point to another one. As I mentioned I will just output the solution from my <strong>stack</strong> in a vector string. I guess I have to visit each node and what I am most afraid is of getting stacked in a loop or even loosing the track during the search.\nAlso note that this is <strong>not a directed graph</strong>. If  Dijkstra\'s algorithm is applicable here I would be very grateful if anyone of you would guide me and I would really appreciate any help, suggestion, idea or even a vision for not getting stacked in a loop or loosing the track while searching.</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '81', 'Title': 'Finding Shortest Paths of weighted graph using stacks', 'LastActivityDate': '2013-11-16T11:28:27.430', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11406', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-11-16T11:28:27.430', 'Id': '18071''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Motivated by <a href="http://cs.stackexchange.com/q/17917/2755">Efficiently sampling shortest s-t paths uniformly and independently at random</a>,</p>\n\n<p>The answers give methods of randomly sampling shortest $s\\text{-}t$ paths. However, they use a lot of seemingly unnecessary random bits.</p>\n\n<p>My question is:</p>\n\n<blockquote>\n  <p>Can the solution be improved to use a single random number in interval $[0,w(t))$, where $w(t)$ is the total number of shortest paths from $s\\text{-}t$.</p>\n  \n  <p>Alternatively, can the solution be improved to use $\\left\\lceil \\log_2 w(t)\\right\\rceil $ random bits?</p>\n</blockquote>\n', 'ViewCount': '74', 'Title': 'Uniformly random efficient sampling of shortest s-t paths, with optimal random bits', 'LastActivityDate': '2013-11-17T19:21:56.460', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18091', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<graph-theory><shortest-path><sampling><random>', 'CreationDate': '2013-11-17T01:51:40.173', 'FavoriteCount': '1', 'Id': '18089''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to prove that if P = NP, then there is a polynomial time algorithm for finding the largest clique in an undirected graph.</p>\n\n<p>I understand how to use a verifier to find this but my issue is since P = NP it doesn't want me to use a verifier. I'm not sure how to approach this.</p>\n", 'ViewCount': '167', 'Title': 'If P = NP, how do I prove I can find the maximum clique in polynomial time?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-20T12:02:06.427', 'LastEditDate': '2013-11-20T12:02:06.427', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<graph-theory><time-complexity>', 'CreationDate': '2013-11-20T02:37:23.993', 'Id': '18183''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '128', 'Title': 'Can Euclidean TSP be exactly solved in time better than (sym)metric TSP?', 'LastEditDate': '2013-11-20T22:51:30.667', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '1', 'Body': u'<p>Symmetric/Metric TSP can be solved via the Held-Karp algorithm in $\\mathcal O(n^2 2^n)$.</p>\n\n<p>See <a href="http://epubs.siam.org/doi/abs/10.1137/0110015">A dynamic programming approach to sequencing problems</a> by Michael Held and Richard M. Karp, 1962.</p>\n\n<p>In <a href="http://faculty.cs.tamu.edu/chen/courses/689/2006/reading/w1.pdf">Exact Algorithms for NP-Hard Problems: A Survey (PDF)</a> Woeginger writes:</p>\n\n<blockquote>\n  <p>This result was published in 1962, and from nowadays point of view almost looks trivial. Still, it yields the best time complexity that is known today.</p>\n</blockquote>\n\n<p>Thus, this is the best known upper-bound.</p>\n\n<p><b>Question:</b></p>\n\n<blockquote>\n  <p>Are there any better results for Euclidean TSP? Or does that best-known bound apply to Euclidean TSP as well.</p>\n</blockquote>\n\n<p>How is Euclidean TSP different? Well,</p>\n\n<ul>\n<li>Euclidean TSP can be encoded into $\\mathcal O(n \\log m)$ space, where $n$ is the number of cities, and $m$ is the bound on the integer coordinates of the city locations. As opposed to (sym)metric TSP variants, which essentially require a distance matrix of size $\\mathcal O(n^2 \\log m)$. Thus, it might be easier to solve; for example, perhaps Euclidean TSP can be more easily encoded into k-SAT, because the distance function is implicit.</li>\n<li><p>Contrary to popular notion, Euclidean TSP\'s reduction from k-SAT is quite different from (sym)metric TSP. UHC (undirected Hamiltonian cycle), symmetric TSP, and metric TSP are pretty directly related to each-other. But formulations of reductions from (sym)metric TSP to Euclidean TSP are not easy to come by. Paragraph, from interesting article, <a href="http://rjlipton.wordpress.com/2012/04/22/the-travelling-salesmans-power/">The Travelling Salesman\u2019s Power</a> by K. W. Regan (bold mine):</p>\n\n<blockquote>\n  <p>Now the reductions from 3SAT to TSP, especially Euclidean TSP, are less familiar, and we ascribe this to their being far more \u201cexpansive.\u201d <b>Texts usually reduce 3SAT to Hamiltonian Cycle, then present the latter as a special case of TSP, but this does not apply to Euclidean TSP</b>. The ${\\mathsf{NP}}$-completeness of Euclidean TSP took a few years until being shown by Christos Papadimitriou, and a 1981 <a href="http://www.cs.technion.ac.il/~itai/publications/Algorithms/Hamilton-paths.pdf">paper</a> by him with Alon Itai and Jayme Luiz Szwarcfiter advertised a \u201cnew, relatively simple, proof.\u201d This proof uses vertex-induced subgraphs of the grid graph in the plane, for which the shortest possible TSP tour and any Hamiltonian cycle have the same length. Despite this simplification, the gadgets involved are large\u2014a diagram of one occupies most of one journal page.</p>\n</blockquote>\n\n<p>Hunting down k-SAT $\\rightarrow$ Euclidean TSP reductions is quite an adventure; so far I\'ve found two of them. One $\\rm k\\text{-}SAT \\rightarrow CircuitSAT \\rightarrow PlanarCircuitSAT \\rightarrow EuclideanTSP$, and another, even tougher one to find, $\\rm k\\text{-}SAT \\rightarrow DHC \\rightarrow UHC \\rightarrow PlanarUHC \\rightarrow EuclideanTSP$. The latter reduction can perhaps be seen to make Euclidean TSP parallel (sym)metric TSP.</p></li>\n</ul>\n', 'Tags': '<graph-theory><reference-request><time-complexity><np-hard><traveling-salesman>', 'LastEditorUserId': '2755', 'LastActivityDate': '2014-02-05T14:16:06.677', 'CommentCount': '0', 'AcceptedAnswerId': '18218', 'CreationDate': '2013-11-20T22:46:01.723', 'Id': '18209''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given N finite subsets of the finite universe set E, it is necessary to find the intersection which contains maxumum number of subsets. Let call this problem MSI (Maximum Subset Intersetion).</p>\n\n<p>Firstly I had thought that it is variation of well-known Maximum Clique Problem where vertices are subsets and edges are relations of intersection, so the classic Bron-Kerbosch algorithm or Tomita et al. algorithm can be easily used. But the k-size clique is certainly not the same that the mutual intesection of k subsets (cause subset A can intersect B, B can intersect C, A can intersect C, but at the same time A, B and C may not have common points of intersection).</p>\n\n<p>Actually the multiple intersections form edges in <strong>hypergraph</strong>, so the main task is to find edge of maximal cardinality.</p>\n\n<p>I found an article by Eduardo C. Xavier <a href="http://www.ic.unicamp.br/~eduardo/publications/ipl12.pdf" rel="nofollow">A Note on a Maximum k-Subset Intersection Problem\n</a> where he proves that the MSI-problem is a variation of Maximum Edge Biclique (MEB) problem which is in turn NP-hard.</p>\n\n<p>My naive solution is to implement branch and bound greedy algorithm (in other words, to adopt Bron-Kerbosch algorithm to this domain).</p>\n\n<p>May be there are already any implementations or acadimic paper on that problem?</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>Actually the exact problem I met in my work is the following:</p>\n\n<p>Suppose that I can run some function which returns the cardinality of one subset or N subsets intersection. The function is time-consuming. I am interested in finding optimal or approximately optimal argorithm to find the intersection of maximum number of subsets (next thing is to find the whole set of such intersections in cardinality decreasing order).\nWorking on element-level is even more costly from the time consumption point of view.</p>\n\n<p>I thought firstly to take cardinalities of all subsets (N operations) and then run Bron-Kerbosh kind of search for subsets sorted by cardinality decreasing order. So I will start with the largest subset, check if it intersects with the 2nd largest subset and so on.</p>\n', 'ViewCount': '134', 'Title': 'Maximum subset intersection problem', 'LastEditorUserId': '10736', 'LastActivityDate': '2013-11-21T23:49:34.870', 'LastEditDate': '2013-11-21T23:49:34.870', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10736', 'Tags': '<graph-theory><graphs><optimization>', 'CreationDate': '2013-11-21T13:58:09.430', 'Id': '18221''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose we have a graph $H$, where each vertex represents a spanning tree of another graph $G$.</p>\n\n<p>We create an edge between 2 vertices in $H$ if $ST_1$ (spanning tree) contains exactly one edge not in $ST_2$ (and vice versa).</p>\n\n<p>How do we show that $H$ is connected?</p>\n', 'ViewCount': '60', 'Title': 'Showing that graph of spanning trees are connected', 'LastEditorUserId': '9863', 'LastActivityDate': '2013-11-25T14:57:33.637', 'LastEditDate': '2013-11-25T14:36:00.353', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11608', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-11-25T13:29:31.623', 'Id': '18325''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This is one of the special cases for Chinese Postman Problem.\nI know the answer is (Cost of all Edges + Cost of shortest path between the odd degree vertices). How do I prove this?</p>\n\n<p>I am trying to prove the solution to <a href="http://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=53" rel="nofollow">this</a> UVA problem.</p>\n', 'ViewCount': '38', 'Title': 'Minimum cost tour for a simple connected graph having exactly two odd degree vertices', 'LastActivityDate': '2013-11-25T14:04:02.283', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11609', 'Tags': '<graph-theory>', 'CreationDate': '2013-11-25T14:04:02.283', 'Id': '18326''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '188', 'Title': '$O(n^{k-1}$) algorithm for K-clique problem', 'LastEditDate': '2013-11-25T15:38:33.530', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '96', 'FavoriteCount': '1', 'Body': "<p>Clique problem is a well known $NP$-complete problem where the size of the required clique is part of the input. However, k-clique problem has a trivial polynomial time algorithm ($O(n^k)$ when $k$ is constant). I'm interested in the best known upper bounds when k is constant. </p>\n\n<blockquote>\n  <p>Is there an algorithm with run time $O(n^{k-1})$? A $o(n^k)$-time algorithm is also acceptable. Also, Is there any complexity-theoretic consequence for the existence of such algorithms?</p>\n</blockquote>\n", 'Tags': '<complexity-theory><graph-theory>', 'LastEditorUserId': '96', 'LastActivityDate': '2014-01-20T16:12:20.110', 'CommentCount': '0', 'AcceptedAnswerId': '18331', 'CreationDate': '2013-11-25T15:32:53.833', 'Id': '18330''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I tried to solve the above NP-completeness exercise by making a bipartite graph from a general one (undirected) by inserting a vertice in the middle of every edge of the first (general) graph. This generates problems as suggested here: <a href="http://cs.stackexchange.com/questions/1527/finding-the-flaw-in-a-reduction-from-hamiltonian-cycle-to-hamiltonian-cycle-on-b">Finding the flaw in a reduction from Hamiltonian cycle to Hamiltonian cycle on bipartitie graphs</a> \nAnyone can give a hint on how to make a bipartite graph from a general one without using the above method and how the hamiltonian property can be passed to it?</p>\n', 'ViewCount': '877', 'Title': 'Proof that the existence of a Hamilton Path in a bipartite graph is NP-complete', 'LastActivityDate': '2013-11-30T00:12:54.147', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '18482', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11617', 'Tags': '<graph-theory><graphs><np-complete>', 'CreationDate': '2013-11-25T21:13:27.677', 'Id': '18335''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I Know that determining Hamiltonian cycle in a graph is NP complete. For the sake of my clarification, I just want to know that whether the problem remains NP complete with following restrictions ? </p>\n\n<p>1) Graph is undirected , and  every node has degree two.</p>\n\n<p>Any help will be appreciated. Thanks.</p>\n', 'ViewCount': '27', 'Title': 'Complexity class of Determining Hamiltonian cycle', 'LastActivityDate': '2013-11-26T04:54:16.490', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11629', 'Tags': '<complexity-theory><graph-theory><p-vs-np>', 'CreationDate': '2013-11-26T04:17:18.607', 'Id': '18352''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '75', 'Title': 'For how large graphs can we still check for isomorphism?', 'LastEditDate': '2013-11-26T14:45:57.957', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11147', 'FavoriteCount': '1', 'Body': u'<p>Let $G_1,$ $G_2$  be two arbitrary graphs with $n$ vertices and we want to check if they are isomorphic.</p>\n\n<p><strong>Question 1.</strong>  For what maximal value of $n$ we \u200b\u200bcan actually perform such verification? </p>\n\n<p><strong>Question 2.</strong>\nIs there any result like as  a list of all non-isomorphic graphs up to $n$, and what is the value of $n$ \u2014 10, 20?</p>\n', 'Tags': '<graph-theory><graph-algorithms>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-27T04:19:37.950', 'CommentCount': '3', 'AcceptedAnswerId': '18373', 'CreationDate': '2013-11-26T08:44:24.090', 'Id': '18358''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given is the following graph which is logically divided into layers (with Dijkstra's shortest paths algorithm):</p>\n\n<pre><code> Vertices   Layer\n\n    Root      0\n   /   \\\n  A     B     1\n / \\    |\nC   D   E     2\n \\  |  /\n  \\ | /\n    F         3\n</code></pre>\n\n<p>Now I'm looking for an algorithm which groups vertices when they have a (single) common ancestor in the previous layer, e.g. for the graph in the example the groups would be:</p>\n\n<pre><code>0: A, B\n1: C, D\n2: E\n3: F\n</code></pre>\n\n<p>I know that this is doable by visiting vertices and comparing ancestors but I was wondering whether there is a well known algorithm for it.</p>\n\n<p><strong>Update:</strong> My question is really only related to find groups. I'm aware of the fact, that I can traverse vertices and test for incoming edges and group those vertices. Furthermore, the graph is fully constructed.</p>\n\n<p>One (now deleted) answer mentioned DFS, which creates a search forest (as BFS creates a search tree which I basically used for levels, though I mentioned Dijkstra). So, I assume that combining BFS and DFS could give me the desired result.</p>\n", 'ViewCount': '140', 'Title': 'Algorithm to Group Vertices of Graph', 'LastEditorUserId': '11734', 'LastActivityDate': '2014-03-07T23:10:15.287', 'LastEditDate': '2013-12-07T20:39:47.837', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11734', 'Tags': '<algorithms><graph-theory><graph-traversal>', 'CreationDate': '2013-12-01T16:02:07.553', 'Id': '18504''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I need to modify the Dijkstra's algorithm to get the shortest path in a directed graph and get the one with the least amount of edges if there are equal paths. </p>\n\n<p>I am thinking to add another data field to count the number of edges from start and compare them in same way as weights. Would that work?</p>\n", 'ViewCount': '143', 'Title': u'Modifying Dijkstra\u2019s algorithm to favor the path with least amount of edges', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-02T04:28:20.353', 'LastEditDate': '2013-12-02T04:28:20.353', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18516', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '11747', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-12-02T00:29:23.490', 'Id': '18515''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Where $A(k;s)$ be the family of digraphs such that $D\\in A(k;s)$ iff for any $u,l:V(D)\\to R^+$ with $u\\ge l,$ and for any $S\\subset V(D)$ with $|S|\\le s$ and with $u(S)\\ge k \\ge l(S), D $ has $k$ edge-disjoint spanning arborescences whose roots are in $S$ in such a way that every $r\\in S$ is the root of at least $l(r)$ and at most $u(r)$ of such spanning arborescences.</p>\n', 'ViewCount': '31', 'Title': 'prove or disprove that a digraph $D \\in A(k;s)$ iff $D$ is $k-$strong?', 'LastActivityDate': '2013-12-02T02:38:56.950', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11751', 'Tags': '<graph-theory>', 'CreationDate': '2013-12-02T02:38:56.950', 'Id': '18520''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '137', 'Title': 'Widest path algorithm steps', 'LastEditDate': '2013-12-02T06:02:56.707', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11747', 'FavoriteCount': '1', 'Body': u'<p>I need to compute the bottleneck shortest paths from s to all vertices of a graph by modifying the Dijkstra\u2019s algorithm. I found this explanation on Wikipedia(<a href="http://en.wikipedia.org/wiki/Widest_path_problem" rel="nofollow" title="Link">Link to Wikipedia</a>) but I would appreciate if you can elaborate it a bit for me.</p>\n\n<blockquote>\n  <p>If the edges are sorted by their weights, then a modified version of\n  Dijkstra\'s algorithm can compute the bottlenecks between a designated\n  start vertex and every other vertex in the graph, in linear time. The\n  key idea behind the speedup over a conventional version of Dijkstra\'s\n  algorithm is that the sequence of bottleneck distances to each vertex,\n  in the order that the vertices are considered by this algorithm, is a\n  monotonic subsequence of the sorted sequence of edge weights;\n  therefore, the priority queue of Dijkstra\'s algorithm can be replaced\n  by an array indexed by the numbers from 1 to m (the number of edges in\n  the graph), where array cell i contains the vertices whose bottleneck\n  distance is the weight of the edge with position i in the sorted\n  order. This method allows the widest path problem to be solved as\n  quickly as sorting; for instance, if the edge weights are represented\n  as integers, then the time bounds for integer sorting a list of m\n  integers would apply also to this problem</p>\n</blockquote>\n\n<p>So I need to sort my vertex by weight starting from A? I would appreciate if you can explain me the steps in this algorithm. </p>\n\n<p>Thanks</p>\n', 'ClosedDate': '2014-01-19T02:13:52.897', 'Tags': '<algorithms><graph-theory><graphs>', 'LastEditorUserId': '11747', 'LastActivityDate': '2013-12-02T06:09:22.450', 'CommentCount': '4', 'AcceptedAnswerId': '18527', 'CreationDate': '2013-12-02T03:04:42.707', 'Id': '18522''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I can see from <a href="http://math.stackexchange.com/questions/421233/turans-theorem-clique-free-graph-and-minimum-independent-set-size">this</a> question that a $K_{r + 1}$-free graph with $n$ vertices and $e$ edges contains an independent set of order at least\n$$\\frac{n}{2e/n + 1} \\tag{1} $$\nSince for a $C_{n}$/$P_{n}$ we know how many edges it contains it is easy to determine (1).</p>\n\n<p>However, are there any particularities of cycle graphs and path graphs that would allow me, for such a graph $G$, to determine exactly $\\min\\{\\mathopen|A\\mathclose| : A\\text{ is a maximal independent set of } G\\}$, i.e. the minimum number of vertices that a <a href="http://en.wikipedia.org/wiki/Maximal_independent_set" rel="nofollow">maximal independent set</a> of $G$ must contain.</p>\n', 'ViewCount': '56', 'Title': 'On the minimum order of a maximal independent set in cycle graphs and path graphs', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-02T18:43:48.307', 'LastEditDate': '2013-12-02T17:41:33.393', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18544', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11184', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-12-02T14:26:28.537', 'Id': '18535''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>the question is: Prove or disprove the following ( let  $k &gt; 0 $ be an integer, and $D$ be a digraph s.t. every vertex has indegree at most $k$. If $D$ does not have a subdigraph in $A_r(g+1)$, then $D$ can be covered by $k+g$ branchings).<br>\nWhere for any $g &gt; 0 $ be an integer, $A_r(g)$ be the family of digraphs such that $h \\in A_r(g)$ iff $H$ has a distinguished vertex $r$ s.t. $H$ has $g-$edge-disjoint spanning r-arborescences.<br>\nI know it is disprove but i'm still confuse to find a good example. Any suggestion please. </p>\n", 'ViewCount': '26', 'Title': 'Prove or disprove D can be covered by $k+g$ branching?', 'LastActivityDate': '2013-12-02T20:06:18.283', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11751', 'Tags': '<graph-theory>', 'CreationDate': '2013-12-02T20:06:18.283', 'Id': '18547''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was given a graph problem with 3 different questions and 1 set of answers. The problem is described below. The problem that I'm having is that it seems to me that the answer to all the questions is the same. I keep trying to find a caveat but I don't see one. What am I missing?</p>\n\n<p>Here is the problem</p>\n\n<p>Undirected graph $G$. $n$ - number of vertices. $m$ - number of edges. $d$ - maximum degree of a graph. </p>\n\n<ol>\n<li>The maximum clique size of $G$ is no larger than </li>\n<li>The minimum vertex cover size of $G$ is no larger than</li>\n<li>The maximum independent set size of $\\overline{G}$, the complement of $G$, is no larger than</li>\n</ol>\n\n<p>Set of answers</p>\n\n<ul>\n<li>(a) $d+1$ </li>\n<li>(b) $n$</li>\n<li>(c) $n-1$</li>\n<li>(d) $n/2$</li>\n<li>(e) $d$</li>\n<li>(f) $n-d$</li>\n</ul>\n\n<p>It looks to me that the answer to every problem is (b) $n$, because</p>\n\n<ol>\n<li>Clique cannot have more vertices than there are in a graph</li>\n<li>Vertex cover cannot be larger than the number of vertices in a graph</li>\n<li>Maximum independent set cannot be larger than the number of vertices in a graph. </li>\n</ol>\n\n<p>I feel like I'm missing something, because the answers seem too obvious. </p>\n\n<p>Any help is appreciated</p>\n", 'ViewCount': '122', 'Title': 'clique, independent set, and minimum vertex cover', 'LastEditorUserId': '10511', 'LastActivityDate': '2013-12-06T22:55:56.513', 'LastEditDate': '2013-12-06T22:55:56.513', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2013-12-06T17:57:56.600', 'FavoriteCount': '0', 'Id': '18689''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '123', 'Title': 'Hard computational problem on special class of bipartite graphs', 'LastEditDate': '2013-12-09T18:52:36.190', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '96', 'FavoriteCount': '1', 'Body': '<p>I am interested in the properties of a class of bipartite graphs $G(X \\cup Y, E)$ where all nodes in $X$ are 3-regular, all nodes in $Y$ are 2-regular, and $|X|=|2Y/3|$. First, Is this a well known class of graphs? Secondly,</p>\n\n<blockquote>\n  <p>Is there an example of intractable computational problem restricted to this class of bipartite graphs?</p>\n</blockquote>\n', 'Tags': '<complexity-theory><graph-theory>', 'LastEditorUserId': '96', 'LastActivityDate': '2013-12-09T20:22:37.543', 'CommentCount': '0', 'AcceptedAnswerId': '18787', 'CreationDate': '2013-12-08T17:59:53.053', 'Id': '18754''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '16', 'Title': 'Why generally to find a Euler cycle is easier than Hamilton cycle for the same set of nodes?', 'LastEditDate': '2013-12-09T19:57:24.237', 'AnswerCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11964', 'FavoriteCount': '1', 'Body': "<p>To find a Hamilton cycle is a NPC problem, but Euler is not. Considering one can always transform the vertex as edge or vice versa conceptually. Then the vertex can be used to describe the information which originally edge does.</p>\n\n<p>What properties make the Euler graph more easily to be resolved?</p>\n\n<p>For example, in genome assembly problem, one can either consider a Kmer as vertex or edge(de bruijn graph), it's just two perspectives to look at the same thing. I think their should be additional or missing information between two kind of explanation.</p>\n", 'ClosedDate': '2013-12-10T07:16:43.247', 'Tags': '<algorithms><graph-theory><eulerian-paths><hamiltonian-path>', 'LastEditorUserId': '11964', 'LastActivityDate': '2013-12-09T19:57:24.237', 'CommentCount': '2', 'CreationDate': '2013-12-09T19:48:17.363', 'Id': '18785''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>While reading a passage in an older textbook I came upon this problem which I am having difficulty in justifying whether its true or false. Is this possible? </p>\n\n<p>If some problem $A$ is NP-hard, and if that problem $A$ can be reduced to problem $B$, and there exists some polynomial-time algorithm which solves $B$, then P=NP?</p>\n\n<p>While I understand that the view is $P\u2260NP$, if the above case were true would $P=NP$?</p>\n', 'ViewCount': '50', 'Title': 'NP-hardness given some reducible language', 'LastActivityDate': '2013-12-11T01:25:13.597', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<graph-theory><np-hard>', 'CreationDate': '2013-12-11T01:07:43.380', 'Id': '18854''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This problem is from the book <a href="http://cseweb.ucsd.edu/users/dasgupta/book/index.html" rel="nofollow">Algorithms, Chapter 5: Greedy algorithms</a>. In case of being closed as a duplication to that in <a href="http://stackoverflow.com/questions/13127446/minimum-spanning-tree-subgraph">Minimum Spanning tree subgraph</a>, I will first make a defense:</p>\n\n<ul>\n<li>The accepted solution at <a href="http://stackoverflow.com/questions/13127446/minimum-spanning-tree-subgraph">Minimum Spanning tree subgraph</a> <strong>is</strong> still in dispute.</li>\n<li>The solution given by <code>eh9</code> seems to be related with the Kruskal MST algorithm.</li>\n<li>I am seeking for a general (and easy) solution.</li>\n</ul>\n\n<p>The problem is as follows:</p>\n\n<blockquote>\n  <p>Let $T$ be an MST of graph $G$. Given a connected subgraph $H$ of $G$, show that $T \\cap H$ is contained in some MST of $H$.</p>\n</blockquote>\n\n<p>My partial trial is <em>by contradiction</em>:</p>\n\n<blockquote>\n  <p>Suppose that $T \\cap H$ is not contained in any MST of $H$. That is to say, for any MST of $H$ (denoted $MST_{H}$), there exists an edge $e$ such that $e \\in T \\cap H$, and however, $e \\notin MST_{H}$.<br>\n  Now we can add $e$ to $MST_{H}$ to get $MST_{H} + {e}$ which contains a cycle (denoted $C$). </p>\n  \n  <ul>\n  <li>Because $MST_{H}$ is a minimum spanning tree of $H$ and $e$ is not in $MST_{H}$, we have that every other edge $e\'$ than $e$ in the cycle $C$ has weight no greater than that of $e$ (i.e., $\\forall e\' \\in C, e\' \\neq e. w(e\') \\le w(e)$).</li>\n  <li>There exists at lease one edge (denoted $e\'\'$) in $C$ other than $e$ which is not in $T$. Otherwise, $T$ contains the cycle $C$. </li>\n  </ul>\n  \n  <p>Now we have $w(e\'\') \\le w(e)$ and $e \\in T \\land e\'\' \\notin T$, $\\ldots$</p>\n</blockquote>\n\n<p>As you see, I failed to continue with the above argument. Therefore, my problem here is:</p>\n\n<blockquote>\n  <ul>\n  <li>Is my argument by contradiction feasible so far? </li>\n  <li>And, how to draw the contradiction to complete the argument?</li>\n  </ul>\n</blockquote>\n', 'ViewCount': '178', 'Title': 'Minimum spanning tree and its connected subgraph', 'LastEditorUserId': '4911', 'LastActivityDate': '2013-12-12T23:34:15.087', 'LastEditDate': '2013-12-11T15:25:56.723', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2013-12-11T08:02:14.180', 'Id': '18867''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am reading <a href="http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem" rel="nofollow">Subgraph isomorphism problem</a> </p>\n\n<p>I am having trouble understanding how they prove that the subgraph isomorphism problem is NP-Complete using the Hamiltonian cycles problem in the article.  </p>\n\n<p>Can someone help me explain what is happening in more laymen terms?  </p>\n', 'ViewCount': '187', 'Title': 'Reducing from Hamiltonian Cycle to Subgraph Isomorphism', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-12-12T09:18:51.053', 'LastEditDate': '2013-12-12T09:18:51.053', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18907', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12045', 'Tags': '<algorithms><graph-theory><np-complete>', 'CreationDate': '2013-12-12T00:15:59.803', 'Id': '18906''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '142', 'Title': 'Problems that are NP but polynomial on graphs of bounded treewidth', 'LastEditDate': '2013-12-16T12:50:01.927', 'AnswerCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4598', 'FavoriteCount': '1', 'Body': '<p>I <em>heard</em> <a href="http://www.youtube.com/watch?v=cQwhYtTfZCs&amp;list=PLawkBQ15NDElkyLbJBKwZCgA5jxsKRlK-&amp;index=22" rel="nofollow">here</a> that the Hamiltonian cycle problem is polynomial on graphs of bounded treewidth.</p>\n\n<p>I am interested in examples/references to different problems which is essentially hard but having polynomial complexity on graphs of bounded treewidth. </p>\n', 'Tags': '<complexity-theory><graph-theory><reference-request><np><polynomial-time>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T14:13:58.150', 'CommentCount': '0', 'AcceptedAnswerId': '19036', 'CreationDate': '2013-12-15T20:00:48.920', 'Id': '19019''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '48', 'Title': 'Given the same set of nodes, why is it (generally) easier to find a Euler cycle than a Hamilton cycle?', 'AnswerCount': '2', 'Score': '4', 'OwnerDisplayName': 'user11964', 'PostTypeId': '1', 'OwnerUserId': '11964', 'FavoriteCount': '1', 'Body': "<p>To find a Hamilton cycle is a NPC problem, but Euler is not. \nConsidering one can always transform the vertex as edge or vice versa conceptually. Then the vertex can be used to describe the information which originally edge does.</p>\n\n<p>What properties make the Euler graph more easily to be resolved? </p>\n\n<p>For example, in genome assembly problem, one can either consider a Kmer as vertex or edge(de bruijn graph), it's just two perspectives to look at the same thing. I think their should be additional or missing information between two kind of explanation.</p>\n", 'ClosedDate': '2013-12-16T11:45:00.277', 'Tags': '<graph-theory>', 'LastActivityDate': '2013-12-16T03:47:06.900', 'CommentCount': '0', 'AcceptedAnswerId': '19028', 'CreationDate': '2013-12-09T19:40:05.087', 'Id': '19026''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to understand how IDDFS works by reading a <a href="http://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search" rel="nofollow">wikipedia article</a> on it.\n(If someone has a better literature on the subject, don\'t hesitate to post).\nPseudocode is as follows:</p>\n\n<pre><code>IDDFS(root, goal)\n{\n  depth = 0\n  for(i=1, i&lt;10, i++)\n  {\n    DFS(limit=i)\n  }\n}\n</code></pre>\n\n<p>First of all, what is 10 here? Is it an arbitray number we choose?\nWhat is the connection between depth and "10"?</p>\n\n<p>In the graph given as an example in that wikipedia article, in step 2 vistied nodes are:<br>\n2: A, B, D, F, C, G, E, F</p>\n\n<p>Why is node F visited twice? Doesn\'t a DFS keep track of already visited nodes?</p>\n\n<p>I am totally confused on this issue and any help is greatly appreciated.</p>\n', 'ViewCount': '89', 'Title': 'IDDFS explained', 'LastActivityDate': '2013-12-16T09:55:09.557', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19033', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12153', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2013-12-16T09:06:14.077', 'Id': '19032''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>For my homework I have a problem that I can't solve and it makes me wonder about 2 different MST:</p>\n\n<blockquote>\n  <p>Let $G=(V,E)$ be a graph that has a minimum spanning tree $T$.</p>\n  \n  <p>I want to find another minimum spanning tree $T'$ that has at least 1 different edge $e'$\n  such that the weight of $e'$ is differ from any weight of edges in $T$.</p>\n</blockquote>\n\n<p>If $T'$ doesn't exist I can claim that every 2 different MST must have the same weight for each edge. </p>\n\n<p>My intuition says that this claim is wrong but on the other hand I can't find example of $T'$ to contradict this claim.</p>\n", 'ViewCount': '72', 'Title': 'Find a diffrent minimal spanning tree for a graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-19T10:57:54.237', 'LastEditDate': '2013-12-19T10:57:54.237', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19116', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9292', 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-12-16T17:31:17.433', 'Id': '19049''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am curious whether the following problems has been studied before, but wasn't able to find any papers about it:</p>\n\n<p>Given a planar graph G, and two vertices s and t, find an st-path $P$ which minimizes the number of distinct faces of G which contain vertices of $P$ on their boundary.</p>\n\n<p>Does anybody know any references?  </p>\n", 'ViewCount': '70', 'Title': 'Finding an st-path in a planar graph which is adjacent to the fewest number of faces', 'LastActivityDate': '2013-12-20T00:57:12.100', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '12250', 'Tags': '<algorithms><graph-theory><reference-request>', 'CreationDate': '2013-12-20T00:57:12.100', 'Id': '19137''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>there are many classes of graphs proved <a href="http://en.wikipedia.org/wiki/Graph_isomorphism_problem#GI-complete_and_GI-hard_problems" rel="nofollow">GI complete</a> &amp; many questions related to GI on tcs.se eg [1] &amp; many others.</p>\n\n<blockquote>\n  <p>suppose a class both $X$ and not-$X$ of graphs are proven GI complete. what are the implications of that?</p>\n</blockquote>\n\n<p>[1] <a href="http://cstheory.stackexchange.com/questions/20267/open-problems-related-to-graph-isomorphism">open problems related to GI</a></p>\n', 'ViewCount': '57', 'Title': 'graph isomorphism completeness of class X and not-X', 'LastActivityDate': '2013-12-25T17:17:40.840', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19282', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '699', 'Tags': '<graph-theory><graph-isomorphism>', 'CreationDate': '2013-12-20T16:26:59.623', 'FavoriteCount': '1', 'Id': '19160''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there an efficient way to cluster nodes in a graph using Jaccard similarity such that each cluster has at least k nodes? </p>\n\n<p>Jaccard similarity between nodes i and j: Let S be the set of neighbours of i and T be the set of neighbours of j. Then, the similarity between i and j is given by  $\\frac{|(S \\cap T)|}{|(S \\cup T)|}$.</p>\n', 'ViewCount': '49', 'Title': 'Is there an efficient way to cluster a graph according to Jaccard similarity?', 'LastActivityDate': '2014-02-18T23:36:13.597', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4868', 'Tags': '<graph-theory><data-mining><cluster>', 'CreationDate': '2013-12-20T21:54:54.990', 'Id': '19167''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This question was originally posted here: <a href="http://stackoverflow.com/q/20735339/2305618">http://stackoverflow.com/q/20735339/2305618</a></p>\n\n<p>I am surely not the first to have implemented code to perform the following graph transformation. But try as I might, I can\'t find a previous reference to it. </p>\n\n<p>The transformation arises when creating a single graph that simultaneously models hierarchical inclusion relationships and other pairwise relationships between nodes.</p>\n\n<p>The algorithm transforms a rooted directed tree DAG into an equivalent hierarchical network DAG. Equivalence in this sense - if the meaning of the tree structure is that parents \'consist of\' or \'contain\' their children the equivalent network structure would carry the same \'consisting of\' or \'containment\' information.</p>\n\n<p>The tree hierarchy is represented in the network as sub-networks and sub-sub-networks. The tree\'s exterior nodes are copied across and each interior node X is represented by the pair: X\' and X\'\'</p>\n\n<p>Does anyone know the name/reference of this transformation/ algorithm? :-)</p>\n\n<p>Illustration image of this transformation:\n<img src="http://davidpratten.com/wp-content/uploads/2013/12/example-algorithm.png" alt="Illustration image of this transformation"></p>\n\n<p>Thanks</p>\n\n<p>David</p>\n', 'ViewCount': '56', 'Title': "What is this algorithm? Create a tree's equivalent hierarchical network", 'LastEditorUserId': '12306', 'LastActivityDate': '2013-12-23T05:21:06.803', 'LastEditDate': '2013-12-23T05:21:06.803', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12306', 'Tags': '<algorithms><graph-theory><trees>', 'CreationDate': '2013-12-23T00:45:35.480', 'Id': '19200''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given an undirected weighted graph $G(V,E)$, where the number of edges is $|V|+10$, how can I find the minimum spanning tree of $G$ in $O(|V|)$?</p>\n\n<p>Kruskal's algorithm is out of the question, since sorting alone is $O(|V|\\log |V|)$, so I thought maybe using Prim's algorithm with minimum binary heap, but still - every iteration will cost $\\log |V|$ for updating vertices keys in the heap, so altogether it's $|V|\\log |V|$.<br>\nI know that the key here is to use the fact that $|E|=|V|+10$, so I start thinking maybe removing the 11 edges with the biggest weights, as long as the graph stays connected, but that's obviously a bad idea since it'll - again - require sorting.<br>\nI just can't figure it out. Any help would be greatly appreciated.</p>\n", 'ViewCount': '88', 'Title': 'Finding minimum spanning tree with O(|V|)', 'LastActivityDate': '2013-12-24T16:27:10.887', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19255', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<graph-theory>', 'CreationDate': '2013-12-23T20:11:05.373', 'Id': '19221''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Given simple, udirected and connected graph with $n$ verticies. Every edge in this graph has some weight. I have to find (in polynomial time) a set of edges such that :  </p>\n\n<p>1.every simple cycle in graph contains at least one edge from this set<br>\n2.sum of weights of these edges is the least possible  </p>\n\n<p>I have derived the following algorithm to solve this problem.  </p>\n\n<p>First, apply DFS algorithm, starting from 1. vertex, to get all back edges. It is known that every simple cycle in this graph will contain at least one back edge, so 1. condition will be satisfied. To satisfy the 2. condition, we must apply DFS algorithm starting from 2. vertex, 3. vertex .... n. vertex, to get different sets of back edges, that all satisfy 1. condition, and choose set with the least sum of weights.  </p>\n\n<p>My question is will this algorithm give the right answer ? And if it won't, then why?  </p>\n\n<p>I have some doubdts about it, for example, is the set of back edges, given by DFS algorithm, is least possible to satisfy the condition that every simple cycle in the graph contain at least one edge from this set? For example, DFS has given me that $BE =  \\left\\{ e_1, e_2, e_3, e_4 \\right\\}$ are the back edges of graph. So every simple cycyle will contain at least one edge from $BE$. But, is it possible that we can throw out, say, $e_3$ and still every simple cycle in graph will contain at least one edge from $\\left\\{ e_1, e_2, e_4 \\right\\}$ ?</p>\n", 'ViewCount': '86', 'Title': 'Finding edges with minimal weight sum, such that every simple cycle contain at least one edge', 'LastActivityDate': '2013-12-24T15:46:23.037', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19251', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11315', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2013-12-24T10:19:44.943', 'Id': '19237''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let G be a weighted undirected graph and e be an edge with maximum weight in G.Suppose there is a minimum weight spanning tree in G containing the edge e.Which of the following statements is always TRUE?</p>\n\n<p>1.There exists a cut in g having all edges if maximum weight</p>\n\n<p>2.There exists a cycle in G having all edges of maximum weight</p>\n\n<p>3.Edge e can not be contained in a cycle </p>\n\n<p>4.All edges in G have the same weight </p>\n\n<p>i think Option 4 and 1 is correct but which is always true .and what is the meaning of option 3.Can any body remove my confusion ??</p>\n', 'ViewCount': '46', 'Title': 'Satisfying condition to be in minimum spanning tree of an edge (maximum weight)', 'LastActivityDate': '2013-12-24T10:44:53.143', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19241', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12340', 'Tags': '<algorithms><graph-theory><trees><spanning-trees>', 'CreationDate': '2013-12-24T10:26:51.827', 'Id': '19239''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>Algorithms for the finding of an MST in a graph can be applied for both maximum and minimum spanning trees.</p>\n\n<p>It is well known, however, that the finding of a max-cut in a graph is an NP-hard problem while the min-cut problem can be easily solved in polynomial time.</p>\n\n<p>Why aren't the two equivalent? </p>\n\n<p>What is the restriction that I\u2019m missing here? </p>\n\n<p>Thanks!</p>\n", 'ViewCount': '49', 'Title': 'Reduction from max-cut to min-cut', 'LastActivityDate': '2013-12-25T00:43:05.643', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19265', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12356', 'Tags': '<complexity-theory><graph-theory><np-complete>', 'CreationDate': '2013-12-24T22:17:23.767', 'Id': '19263''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for a reference for the following theorem:</p>\n\n<p>Let $G$ be a bipartite graph with partitions $X$ and $Y$, each with the same number of vertices ($n$).</p>\n\n<p>There is a nonempty subset $Y_1 \\subseteq Y$, and a partition of $X$ to disjoint subsets $X_1$ and $X_2$, such that:</p>\n\n<ul>\n<li>There is a complete matching between $X_1$ and a subset of $Y_1$;</li>\n<li>There are no edges between $X_2$ and $Y_1$.</li>\n</ul>\n\n<p>Intuitively, $X$ can be seen as a set of men and $Y$ can be seen as a set of women. An edge between $x \\in X$ and $y \\in Y$ means that "$x$ and $y$ like each other" ("like" is considered a symmetric relation). </p>\n\n<p>The goal is to find a subset of the women ($Y_1$) and a subset of the men ($X_1$), such that each man can marry a woman he likes without upsetting any of the other men ($X_2$), because no unmarried man likes any married woman.</p>\n\n<p>This sounds similar to <a href="https://en.wikipedia.org/wiki/Hall%27s_marriage_theorem" rel="nofollow">Hall\'s marriage theorem</a>, but the premise is simpler. And, I am mainly looking for a reference that I can cite.</p>\n\n<p>EDIT: Some special cases:</p>\n\n<ul>\n<li>If the graph is full (i.e. any man likes any woman), then we can take $Y_1=Y$, $X_1=X$, $X_2=\\phi$.</li>\n<li>If the graph is empty (i.e. no man likes no woman), then we can take $Y_1=Y$, $X_1=\\phi$, $X_2=X$.</li>\n<li>If there is $y \\in Y$ with no neighbours (i.e. a woman that doesn\'t like any man), then we can take $Y_1={y}$, $X_1=\\phi$, $X_2=X$.</li>\n<li>If there is $y \\in Y$ with a single neighbour $x \\in X$  (i.e. a woman that likes a single man), then we can take $Y_1={y}$, $X_1={x}$, $X_2=X-{x}$.</li>\n</ul>\n\n<p>The question becomes more problematic when all $y \\in Y$ have at least two neighbours.</p>\n', 'ViewCount': '63', 'Title': 'Partition a bipartite graph to a complete matching and an independent set', 'LastEditorUserId': '1342', 'LastActivityDate': '2013-12-26T06:38:00.980', 'LastEditDate': '2013-12-26T06:38:00.980', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<graph-theory><reference-request>', 'CreationDate': '2013-12-25T16:31:05.593', 'Id': '19281''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This question was asked in the onsite regionals for ACM ICPC 2013 at Amritapuri.\nIn short, the question asked to find the number of ways to fill a $ 2\\times N$ grid with $M$ colors such that no two cells with the same row or same column have the same color.</p>\n\n<p>The limits given are $1 \\leq N$, and $M \\leq 1000$ with 1000 test cases per input. </p>\n\n<p>Based on the constraints the approach that comes to my mind after a long struggle includes having a precomputed DP table which can be used for every test case. I tried to apply the inclusion-exclusion principle but could not come up with any solution. I also tried to solve it using bipartite perfect matchings, but no success. How should I approach this question?</p>\n', 'ViewCount': '276', 'Title': 'Number of ways to fill a 2xN grid with M colors', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-27T17:23:20.610', 'LastEditDate': '2013-12-27T17:23:20.610', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19291', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><combinatorics><permutations><bipartite-matching>', 'CreationDate': '2013-12-25T20:33:19.390', 'Id': '19288''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am reading a unpublished paper describing an algorithm. In one step of the algorithm, there is a bipartite graph $G(X,Y,E)$, where $X=\\{1,...,n\\}$.</p>\n\n<p>For every subset $X' \\subseteq X$, they define</p>\n\n<p>$$f(X')=\\bigcup_{i \\in X'} \\{j \\in Y| (i,j)\\in E\\}.$$</p>\n\n<p>In other words, $f(X')$ is the set of neighbors of vertices in $X'$.</p>\n\n<p>Then they define:</p>\n\n<p>$$ X^+ = \\arg \\max_{X' \\subseteq \\{2,3,...,n\\}\\ s.t.\\ |X'|\\geq|f(X')|}\\{|X'|\\}$$</p>\n\n<p>i.e., $X^+$ is a largest subset of $\\{2,3,...,n\\}$ such that $X^+$ is at least as large as the set of its neighbors in $Y$ (i.e., the largest subset such that $|X^+| \\ge |f(X^+)|$).</p>\n\n<p>And then they do some stuff with this $X^+$.</p>\n\n<p>MY QUESTION IS: Can this $X^+$ be found in polynomial time? </p>\n\n<p>The authors do not prove that it can, but this is implied by the paper (otherwise the algorithm itself cannot be polynomial). Maybe it is so obvious that only I haven't seen this?</p>\n\n<p>EDIT: The following similar problem can be solved easily:</p>\n\n<pre><code>Find the largest set of vertices in X with less than |Y| neighbours.\n</code></pre>\n\n<p>Solution: find a $y \\in Y$ with a minimal number of neighbours in $X$. Return the set that includes all vertices in $X$ except $y$'s neighbours.</p>\n\n<p>What about the following similar problem?</p>\n\n<pre><code>Find the largest set of vertices in X with less than |Y|/2 neighbours.\n</code></pre>\n", 'ViewCount': '126', 'Title': 'Largest set of vertices that is larger than its set of neighbors', 'LastEditorUserId': '1342', 'LastActivityDate': '2014-01-01T15:40:34.427', 'LastEditDate': '2014-01-01T15:40:34.427', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<algorithms><graph-theory><time-complexity><runtime-analysis>', 'CreationDate': '2013-12-30T14:31:23.103', 'Id': '19377''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>what is the reason for the correctness proof of Prim's Algorithm for the undirected case cannot carry over to the directed case?</p>\n\n<p>Is it because of after any number of steps, $S$ might not be in a sub tree of an MST since it depends upon the direction of the edge of the directed graph, unlike the undirected one?</p>\n", 'ViewCount': '111', 'ClosedDate': '2014-01-05T17:29:58.513', 'Title': "Proof of Correctness of Prim's algorithm", 'LastEditorUserId': '7269', 'LastActivityDate': '2013-12-31T16:22:53.543', 'LastEditDate': '2013-12-31T13:52:39.337', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<graph-theory><correctness-proof><greedy-algorithms><spanning-trees>', 'CreationDate': '2013-12-31T12:55:44.063', 'Id': '19405''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to come up with a good algorithm for the following decision problem:</p>\n\n<p>Let $G=(V,A)$ be a directed graph and let $s,t \\in V$. Are there at-least 2 non-intersecting paths from $s$ to $t$?</p>\n\n<p>By non-intersecting I mean that if $P_1$ and $P_2$ are non-intersecting paths from $s$ to $t$ then $\\forall e\\in P_1\\in A, e\\notin P_2$ (can share vertices but not edges).</p>\n\n<p>I thought of the following algorithm:</p>\n\n<ol>\n<li>Find the shortest path $P\\in A$ in $G$ from $s$ to $t$. if no such path exist, return false;</li>\n<li>Find the shortest path $P'\\in A-P$ in $G$ from $s$ to $t$. if no such path exists, return false; else return true.</li>\n</ol>\n\n<p>I didn't find a contradicting example but so far I was unable to prove its correctness.</p>\n\n<p>Ideas about proof approaches for this algorithm or suggesting other algorithms is welcome.</p>\n", 'ViewCount': '69', 'Title': 'Non intersecting paths in a graph', 'LastEditorUserId': '10438', 'LastActivityDate': '2014-01-01T16:49:59.463', 'LastEditDate': '2013-12-31T16:24:44.257', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19418', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-12-31T16:06:10.790', 'Id': '19413''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m trying to apply <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a> to the <a href="http://projecteuler.net/problem=83" rel="nofollow">Problem 83</a> on projecteuler.net. The problem reads:</p>\n\n<blockquote>\n  <p>In the 5 by 5 matrix below, the minimal path sum from the top left to\n  the bottom right, by moving left, right, up, and down, is indicated in\n  bold red and is equal to 2297.</p>\n\n<pre><code>131   673   234   103    18\n201    96   342   965   150\n630   803   746   422   111\n537   699   497   121   956\n805   732   524    37   331\n</code></pre>\n  \n  <p>Find the minimal path sum, in matrix.txt (right click and \'Save\n  Link/Target As...\'), a 31K text file containing a 80 by 80 matrix,\n  from the top left to the bottom right by moving left, right, up, and\n  down.</p>\n</blockquote>\n\n<p>I wonder if the original algorithm can be simplified due to the fact that the graph is represented as a matrix?</p>\n\n<p>In particular, I\'ve noticed that every edge in the graph is only relaxed once (i.e. the node\'s distance is changed only once from infinity to some value). Can I rely on this fact in my code?</p>\n', 'ViewCount': '247', 'Title': "How to optimize Dijkstra's algorithm for a grid graph?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-06T11:39:11.420', 'LastEditDate': '2014-01-06T11:39:11.420', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'OwnerDisplayName': 'user12525', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2014-01-02T02:19:25.053', 'Id': '19446''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>In the last 2 paragraphs of the paper about Hopcroft\u2013Karp algorithm to find the maximum cardinality matching in bipartite graph:</p>\n\n<blockquote>\n  <p><a href="https://dl.dropboxusercontent.com/u/64823035/04569670.pdf" rel="nofollow">https://dl.dropboxusercontent.com/u/64823035/04569670.pdf</a></p>\n  \n  <p>The execution time of a phase is O(m+n), where m is the number of\n  edges in G, and n is the number of vertices. Hence the execution time\n  of the entire algorithm is O((m+n)s), where s is the cardinality of a\n  maximum matching.</p>\n  \n  <p>If G has n vertices then m &lt;= n^2 / 4 and s &lt; n / 2 so that the\n  execution time is bounded by O(n^(5/2)).</p>\n</blockquote>\n\n<p>I don\'t understand given:</p>\n\n<pre><code>m &lt;= n^2 / 4\ns &lt;= n / 2\n</code></pre>\n\n<p>why they concluded:</p>\n\n<pre><code>O((m+n)s) = O(n^(5/2))\n</code></pre>\n\n<p>Shouldn\'t it be:</p>\n\n<pre><code>O((m+n)s) = O(n^3)\n</code></pre>\n\n<p>Any idea?</p>\n', 'ViewCount': '78', 'Title': u'Hopcroft\u2013Karp algorithm time complexity', 'LastEditorUserId': '12572', 'LastActivityDate': '2014-01-03T14:30:49.710', 'LastEditDate': '2014-01-03T14:30:49.710', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12572', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal><bipartite-matching>', 'CreationDate': '2014-01-03T13:58:38.513', 'Id': '19486''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>How do I iterate over all the $k$-element subsets of $\\{1,2,\\dots, n\\}$ by switching one element at a time?</p>\n\n<pre><code>123\n134\n234\n124\n145\n245\n345\n135\n235\n125\n</code></pre>\n\n<p>This comes from Ch2 of  <a href="http://www.math.upenn.edu/~wilf/website/CombinatorialAlgorithms.pdf" rel="nofollow">Combinatorial Algorithms</a> by Nienhuis and Wilf.</p>\n\n<p>Equivalently I am asking for a Hamiltonian circuit on the <a href="http://en.wikipedia.org/wiki/Johnson_graph" rel="nofollow">Johnson graph</a> of $k$ element subsets of a set of $n$ elements connected if their intersection has $k-1$ elements. </p>\n\n<hr>\n\n<p>I am trying to understand how the equation $$A(n,k) = A(n-1,k), \\overline{ A(n-1,k-1)}\\otimes \\{n\\}$$ from Nienhuis-Wilf leads to a type of "gray code" for subsets.  In fact, it is the gray code when you restruct to $k$-element sets. </p>\n\n<p>Here, $A(n,k)$ is an ordering, looping over the $k$-element subsets of $\\{1,2,\\dots, n\\}$.   The notation $\\overline{ A(n-1,k-1)}\\otimes \\{n\\}$ means we should list the $k-1$-element substs of $\\{1,2,\\dots, n-1\\}$ and append the element $n$ to each element of that list.</p>\n\n<p>This equation can also be thought of a set theoretic version of the binomial coefficient identity</p>\n\n<p>$$ \\binom{n}{k} = \\binom{n-1}{k-1} + \\binom{n-1}{k}$$</p>\n\n<p>Using this formation I came up a means of listing all the subsets in order. </p>\n\n<p>Here <code>gc(n,k)</code> is returning an array of $k$-element arrays, enumerating the $k$-element subsets of $\\{1,2,\\dots, n\\}$.</p>\n\n\n\n<pre><code>def gc(n,k):\n    if(k==1):\n        return [[i+1] for i in range(n)]\n    elif(n == 0):\n        return []\n    else:\n        L = [ x+ [n] for x in gc(n-1,k-1)]\n        return gc(n-1,k)+ L[::-1]\n</code></pre>\n\n<p>How do I find the predecessor or successor of a given subset without generating all the subsets?  I wrote some python code for this, which is different from what is in the textbook.  It still doesn\'t return the correct answer.</p>\n\n<pre><code>def S(n,k,a):\n    if k == 1:\n        return [(a[0] + 1)%n]\n    elif(a[-1] == n-1):\n        return P(n-1,k-1, a[:-1]) + [n-1]\n    else:\n        return S(n-1,k,a)\n\ndef P(n,k,a):\n    if k == 1:\n        return [(a[0] - 1)%n]\n    elif(a[-1] == n-1):\n        return S(n-1,k-1, a[:-1]) + [n-1]\n    else:\n        return P(n-1,k,a)\n</code></pre>\n\n<p>This looks pretty close to the recursion in Nienhuis-Wilf but I would like to understand where I am going wrong in my implementation.</p>\n', 'ViewCount': '99', 'Title': 'iterating over subsets by switching one element at a time', 'LastEditorUserId': '3131', 'LastActivityDate': '2014-01-08T21:29:35.157', 'LastEditDate': '2014-01-05T18:08:51.710', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><graph-theory><finite-automata>', 'CreationDate': '2014-01-05T03:35:26.093', 'Id': '19504''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '88', 'Title': 'What is the order of the Pancake graph in Given example & what are the properties of Pancake graph?', 'LastEditDate': '2014-05-03T21:04:17.810', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9665', 'FavoriteCount': '2', 'Body': '<p>Pancake graph have least diameter &amp; degree (log n/ log log n)</p>\n\n<p>pancake Graph with order-2 will be one single line with two nodes, labeled with permutation of node {12, 21}.</p>\n\n<p>pancake Graph with order-3 will be one single line with one hexagonal, labeled with permutation of node {123, 132, 213, 231, 312, 321}.</p>\n\n<p>Similarly for order-4 graph will be with 4-hexagonal.\n<img src="http://i.stack.imgur.com/RFsZY.png" alt="enter image description here"></p>\n\n<p><strong>This graph is in three dimension or four dimension?\nif this graph is in four dimension, then how graph will look like in three dimension?</strong></p>\n', 'ClosedDate': '2014-01-09T23:26:42.547', 'Tags': '<graph-theory><graphs><graph-traversal>', 'LastEditorUserId': '9665', 'LastActivityDate': '2014-05-03T21:04:17.810', 'CommentCount': '1', 'AcceptedAnswerId': '19579', 'CreationDate': '2014-01-08T11:26:51.350', 'Id': '19578''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>Assume having a graph $G_{variables}=(V,U)$ where $V=\\{v_1,v_2,\u2026,v_n\\}$ is a set of variables; each variable $v_i\\in V$ is associated with a set of possible values (it's domain) $dom(v_i)$. </p>\n\n<p>Let $P$ be a search problem (i.e reachability problem) over graph $G=(O,E)$ where $O$ is the cartesian product of the variables domains. Let $T$ be a junction tree resulted from $G_{variables}$. $P$ can be also solved through searching every clique in $T$. I am looking for keywords/examples of such problems. $G_{variables}$ preferably to be DAG.  </p>\n", 'ViewCount': '30', 'Title': 'Search problems that can also be solved by junction trees and searching cliques', 'LastEditorUserId': '4598', 'LastActivityDate': '2014-01-10T04:15:00.893', 'LastEditDate': '2014-01-10T04:15:00.893', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graph-theory><reference-request><search-algorithms><search-problem>', 'CreationDate': '2014-01-09T17:48:23.083', 'Id': '19602''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '65', 'Title': 'Is there a mathematical way to deduce that my directed graph is disconnected?', 'LastEditDate': '2014-01-10T03:25:10.223', 'AnswerCount': '3', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '12721', 'FavoriteCount': '2', 'Body': '<p>I have a graph G with 13814 nodes and 25190 edges. I am interested in finding a mathematical proposition that proves that my graph is disconnected. I know it is, because the visualization shows lonely clusters where they have no way of reaching the other nodes in the graph. This simply is a signature of disconnected graphs. But, is there a mathematical way to prove whether my graph is disconnected?</p>\n', 'ClosedDate': '2014-01-11T11:02:20.933', 'Tags': '<graph-theory>', 'LastEditorUserId': '12721', 'LastActivityDate': '2014-01-10T15:45:12.927', 'CommentCount': '5', 'CreationDate': '2014-01-10T03:09:59.143', 'Id': '19612''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a simple directed graph $G(V,E)$ that has a source $s$ and sink $t$. Each edge $e$ of $G$ has positive integer capacity $c(e)$ and positive integer cost $a(e)$. I am trying to find the minimum cost maximum flow from $s$ to $t$ using the <a href="http://wwwhome.math.utwente.nl/~uetzm/do/DO_Lecture4.pdf" rel="nofollow">well-known Dijkstra potential method for finding augmenting paths</a>. It goes something like this:</p>\n\n<pre><code>Initialize all edge flows to 0.\nInitialize all potentials pi[v] to 0.\nWhile there exists an augmenting path in G_f (the residual network):\n    Set the costs of all edges e = uv to be:\n        b(e) = a(e) + pi[u] - pi[v], if e exists in G or\n        b(e) = -a(e_reverse) + pi[u] - pi[v], where e_reverse = vu otherwise\n    # We are now assured all edges have nonnegative costs\n    Using Dijkstra method with costs b(e) in G_f:\n        Find the cheapest augmenting path from s to t\n        Calculate dist(v), the cost of cheapest path from s to v\n    Augment the cheapest path to t to current flow\n    Set pi[v] = pi[v] + dist(v) for all vertices v\nThe current flow gives the minimum cost maximum flow.\n</code></pre>\n\n<p>Obviously, if all costs $a(e) \\le a_{max}$ and all capacities $c(e) \\le c_{max}$, then there is a loose bound $|E|c_{max}a_{max}$ for cost of minimum cost maximum flow. However, the bound on the potentials $\\pi(v)$ and Dijkstra distances $dist(v)$ is not so obvious. In fact, judging by how it adds $dist(v)$ to $\\pi(v)$ each iteration, $\\pi(v)$ can possibly be multiplied by $|V|$ each iteration!</p>\n\n<p><strong>My question is</strong>, is there a way to calculate a non-exponential bound for $\\pi(v)$? If not, say all capacities and costs are at most $10^4$, $|V| = 200$, $|E| = 5000$. The minimum cost of the maximum flow is at most $5000 \\times 10^4 \\times 10^4 = 5 \\times 10^{11}$. But is it possible that $\\pi(v)$ and $dist(v)$ exceeds 64-bit integers? How do so many implementations not use Big Integers?</p>\n', 'ViewCount': '104', 'Title': 'Potential values of minimum cost maximum flow algorithm', 'LastEditorUserId': '7137', 'LastActivityDate': '2014-01-15T14:37:32.410', 'LastEditDate': '2014-01-15T14:37:32.410', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7137', 'Tags': '<algorithms><graph-theory><algorithm-analysis><asymptotics><network-flow>', 'CreationDate': '2014-01-11T04:25:09.883', 'Id': '19645''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The first chapter of the book "Graphs and their uses" by Oystein Ore says that interval graphs can be used to resolve authorship disputes, but I couldn\'t find any details.  How does this work?  What is the algorithm?</p>\n\n<p><strong>From the text (Chapter 1.7):</strong></p>\n\n<blockquote>\n  <p>Interval graphs have also been used to investigate the likely authorship of disputed pieces of writing, such as certain works of Plato. Various features of an authors prose style are studied for their appearance in several literary works. By drawing a graph in which the vertices correspond to these literary features and the edges correspond to pairs of them which occur together in the same work, we obtain a situation very similar to our archaeological example. As before, we can then investigate whether the resulting graph can be represented as an interval graph, and we can thereby attempt to arrange the works in chronological order. By doing this, it has sometimes been possible to relate the style of the disputed piece of writing to that of the author in question, and thereby to determine the likely authorship.</p>\n</blockquote>\n', 'ViewCount': '64', 'Title': 'Using interval graphs to find authorship disputes', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-13T13:14:32.097', 'LastEditDate': '2014-01-13T12:58:54.237', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<graph-theory><graphs><natural-lang-processing>', 'CreationDate': '2014-01-13T01:54:11.963', 'Id': '19680''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In a directed graph i want to call bfs on some of the vertices so that all of the vertices will be met.</p>\n\n<p>(in other words all of the other vertices are reachable from these chosen vertices.)</p>\n\n<p>I want to find the minimum number of such vertices.</p>\n\n<p>Actually this problem arises in social networks when we want to find the minimum number of people to which if we send a message then all of the network members will get that.(suppose that we know when someone gets the message he/she will send that to all of his/her followers.)</p>\n\n<p>Can anyone help?</p>\n', 'ViewCount': '158', 'Title': 'find the minimum number of vertices in a directed graph from which the other vertices are reachable', 'LastEditorUserId': '12820', 'LastActivityDate': '2014-04-05T15:47:19.383', 'LastEditDate': '2014-01-14T00:00:43.170', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12820', 'Tags': '<algorithms><graph-theory><social-networks>', 'CreationDate': '2014-01-13T23:54:48.383', 'Id': '19707''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for an algorithm to convert a digraph (directed graph) to an undirected graph in a reversible way, ie the digraph should be reconstructable if we are given the undirected graph. I understand that this will come in expense of the undirected graph having more vertices but I do not mind.</p>\n\n<p>Does one know how to do this or can suggest any references? Thanks in advance.</p>\n\n<hr>\n\n<p>Update: Regarding the answer of AdrianN below. It might be a good starting point but I don\'t think it works in its current form. Here is an image of why I think it doesn\'t:\n<img src="http://i.stack.imgur.com/Kh4eq.png" alt="enter image description here"></p>\n\n<hr>\n\n<p>Update after D.W.\'s comment: I consider the vertices of the graphs to be unlabeled. If a solution involves labeling the vertices (like AdrianN\'s does), then it should give the same (isomorphic) undirected graph no matter how the labeling is done. My definition of "isomorphic" for graphs with labeled vertices is that there is a permutation of the labeling that relates the two graphs, but I am not sure of the exact definition for unlabeled graphs...</p>\n', 'ViewCount': '127', 'Title': 'Converting a digraph to an undirected graph in a reversible way', 'LastEditorUserId': '12348', 'LastActivityDate': '2014-01-16T18:45:39.390', 'LastEditDate': '2014-01-15T19:07:50.007', 'AnswerCount': '4', 'CommentCount': '4', 'AcceptedAnswerId': '19758', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12348', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2014-01-15T10:30:23.683', 'Id': '19744''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for papers/methods (or at least problem examples) where the original search problem $P$ can be solved by either:</p>\n\n<ol>\n<li>Searching through the original graph. or</li>\n<li>By decomposing it into several subset of problems $P_1,P_2, \\dots,P_n$.</li>\n</ol>\n\n<p>Ideally $sol(P )=sol(P_1)\\cup sol(P_2)\\cup \\ldots \\cup(P_n)$ with no preprocessing (i.e the union of the subproblems correspond directly to the solution of the problem).  </p>\n\n<p>I have no constraint; though prefer the underlying graph to be a DAG and the problem to be a reachability problem. Google seems to fail on finding such papers. </p>\n', 'ViewCount': '74', 'Title': 'Decomposing the search problem into several small problems', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T12:32:29.493', 'LastEditDate': '2014-01-17T21:36:52.663', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '19804', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<graph-theory><reference-request><search-algorithms><search-problem>', 'CreationDate': '2014-01-17T18:59:51.023', 'Id': '19792''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a two-dimensional grid with wrap-around edges (a doughnut-shaped graph). I need to calculate the second-largest eigenvalue of the adjacency matrix. Is there a faster way of computing it for such a special graph than a general method such as the "eigs" function in MATLAB?</p>\n', 'ViewCount': '35', 'Title': 'Calculating eigenvalue gap of a torus graph', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:39:46.200', 'LastEditDate': '2014-02-02T13:39:46.200', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19801', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9802', 'Tags': '<graph-theory><linear-algebra>', 'CreationDate': '2014-01-17T23:06:50.043', 'Id': '19800''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>This was asked in a recent contest.\nThe question asked to count the number of ways to color an $M \\times N$ matrix with $K$ colours such that no two adjacent cells (sharing an edge) have the same color.\nIn other words, I want to count the number of different graph colorings of a grid graph: the graph of a $N \\times M$ grid. The limits were $1 \\le N,M \\le 8$ and $1 \\le K \\le 1000000000$.</p>\n\n<p>Is it possible to count the number of colors using the inclusion-exclusion principle, and if so, how? I saw <a href="http://cs.stackexchange.com/q/19288/98">another question</a> that solves the special case (where $M=2$) using inclusion-exclusion, so I\'m wondering if that kind of approach can be generalized here.</p>\n', 'ViewCount': '89', 'Title': 'Calculate number of ways to color matrix using inclusion-exclusion principle', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-21T08:14:00.150', 'LastEditDate': '2014-03-21T08:04:40.733', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><combinatorics><counting><colorings>', 'CreationDate': '2014-01-19T07:03:15.513', 'Id': '19822''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am working on the following problem:</p>\n\n<blockquote>\n  <p>Suppose that $T$ is a spanning tree of a graph $G$, with an edge cost function $c$.  Let $T$ have the <em>cycle property</em> if for any edge $e\' \\not \\in T, c(e\') \\geq c(e)$ for all $e$ in the cycle generated by adding $e\'$ to $T$.  Let  $T$ have the <em>cut property</em> if for any edge $e \\in T$, $c(e) \\leq c(e\')$ for all $e\'$ in the cut defined by $e$.</p>\n  \n  <p>Show that the following three properties are equivalent </p>\n  \n  <ol>\n  <li>T has the cycle property, </li>\n  <li>T has the cut property, and </li>\n  <li>T is a minimum cost spanning tree.</li>\n  </ol>\n</blockquote>\n\n<p>I believe that to show that 3. implies 1., we suppose otherwise, and then show that this would give a cycle with an edge that can replace another edge in T and that is cheaper, whence we have a contradiction.  Similarly, I believe to show that 3. implies 2., we similarly suppose otherwise, and then show that this would give a cut with an edge that can replace another edge in T and that is cheaper, whence a contradiction.</p>\n\n<p>However, I am not sure how to prove the other implications needed for this problem.  My feeling is to somehow use a similar argument to what I listed, but "in reverse".</p>\n\n<p>Any help with this problem would be greatly appreciated.</p>\n', 'ViewCount': '96', 'Title': 'Spanning Tree - Equivalent Properties', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T11:47:57.600', 'LastEditDate': '2014-01-21T08:21:15.430', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12985', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2014-01-20T22:19:12.643', 'Id': '19855''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Recently i\'ve been dealing with a problem that led me to the following questions:</p>\n\n<ul>\n<li>Is there a good algorithm to enumerate all maximum/perfect matchings in a general graph?</li>\n<li>Is there a good algorithm for finding all maximum/perfect matchings in a general graph?</li>\n<li>Are these two problems equivalent in their complexity?</li>\n</ul>\n\n<p>I\'ve stumbled upon the following references:</p>\n\n<ul>\n<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.107.8179&amp;rep=rep1&amp;type=pdf" rel="nofollow">Algorithms for Enumerating All Perfect Maximum and Maximal Matchings In Bipartite Graphs</a>- Suggesting an algorithm for enumerating all maximum matchings in a bipartite graph.</li>\n<li><a href="http://www.sciencedirect.com/science/article/pii/0893965994900450" rel="nofollow">Finding All the Perfect Matchings\nin Bipartite Graphs</a>- Suggesting an algorithm for finding all perfect matchings in bipartite graphs</li>\n</ul>\n\n<p>Both algorithms\' complexity depend on the number of perfect matchings in the graph (meaning exponential running time in the worst case).</p>\n\n<p>Moreover, both articles deal with bipartite graphs, I couldn\'t find similar articles dealing with the same problem in general graphs.</p>\n\n<p>I\'d appreciate information and references about the above problems.</p>\n', 'ViewCount': '131', 'Title': 'Counting and finding all perfect/maximum matchings in general graphs', 'LastEditorUserId': '10438', 'LastActivityDate': '2014-01-24T19:06:05.883', 'LastEditDate': '2014-01-24T16:12:01.350', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19926', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<algorithms><complexity-theory><graph-theory><reference-request><matching>', 'CreationDate': '2014-01-23T21:28:38.760', 'Id': '19924''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a social network in the form of an undirected graph $G = (V,E)$ with distinct non-negative integer keys. For each node $u \\in V$, let the set $\\Gamma(u) = \\{ v \\in V : (u,v) \\in E \\}$ be the <strong><em>neighbourhood</em></strong> of $u$. Clearly, I got that $d(u) = \\left | \\Gamma(u) \\right |$, where $d(u)$ is the <strong><em>degree</em></strong> of $u$.</p>\n\n<p>I now want to split $\\Gamma(u)$ into two sets of nodes</p>\n\n<p>$$\\Gamma_{\\text{low}}(u)  = \\{ v \\in V : v \\in \\Gamma(u) \\text{ and } v &lt; u \\}$$\n$$\\Gamma_{\\text{high}}(u) = \\{ v \\in V : v \\in \\Gamma(u) \\text{ and } v &gt; u \\}$$</p>\n\n<p>i.e. $\\Gamma_{\\text{low}}(u)$ and $\\Gamma_{\\text{high}}(u)$ contain neighbours of $u$ whose key is less than or greater than $u$'s, respectively.</p>\n\n<p>Assuming that the graph has got $m$ edges, is there a way to obtain an upper bound for $d_{\\text{low}}(u) = \\left | \\Gamma_{\\text{low}}(u) \\right |$ and $d_{\\text{high}}(u) = \\left | \\Gamma_{\\text{high}}(u) \\right |$ for varying $m$? I just can obtain the following relationship</p>\n\n<p>$$\\sum_{u \\in V} d_{\\text{low}}(u) + \\sum_{u \\in V} d_{\\text{high}}(u) = 2m,$$</p>\n\n<p>because the graph is undirected. I read somewhere that $d(u) = O\\left ( \\sqrt{m} \\right )$ is a good bound for social networks, but how do I prove it?</p>\n", 'ViewCount': '45', 'Title': 'Need an upper bound for node degree', 'LastActivityDate': '2014-01-30T14:19:42.420', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13243', 'Tags': '<algorithms><graph-theory><space-complexity><social-networks>', 'CreationDate': '2014-01-30T14:19:42.420', 'Id': '20108''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am trying to show that every 2-terminal SP-graph is $O(\\log(n))$-outer-planar for a challenge question on my assignment. In particular, I am trying to prove this by induction on the number of combinations (either a series or a parallel combination). This is what I have so far.</p>\n\n<p>The base case on $0$ combinations is that we just have some edge $(s, t)$. Clearly this is outer-planar and so $O(\\log(n))$-outer-planar as well (in this case, $\\log(2) = 1$, so this does hold).</p>\n\n<p>Now we do the inductive step. Given some 2-terminal outer-planar graph $G = (V, E)$, we will show that it is $O(\\log(n))$-outer-planar, where $|V| = n$. Since $G$ is a 2-terminal outer-planar graph, it was either the result of combining two graphs $G_1$ on $n_1$ vertices and $G_2$ on $n_2$ vertices by series or by parallel. So we have two cases two consider.</p>\n\n<p>The first case is when $G_1$ and $G_2$ were combined by series. By induction, $G_1$ is $O(\\log(n_1))$-outer-planar and $G_2$ is $O(\\log(n_2))$-outer-planar. Since $G$ was combined by series, it has $n = n_1 + n_2 - 1$ vertices, where $n_1, n_2 \\ge 2$. Let $n_0 = \\max(n_1, n_2)$. Then $G$ is $O(\\log(n_0))$-outer-planar since we have not added any layers to $G_1$ or $G_2$ by combining them. It follows that $G$ is $O(\\log(n))$-outer-planar since $n_0 \\le n$.</p>\n\n<p>In the second case, $G_1$ and $G_2$ are combined in parallel, meaning that $G$ has $n = n_1 + n_2 - 2$ vertices. Again by induction, $G_1$ is $O(\\log(n_1))$-outer-planar and $G_2$ is $O(\\log(n_2))$-outer-planar. However, this time we cannot conclude that the number of layers around $G$ is the same.</p>\n\n<p>This is where I am stuck. I understand that we are at-most doubling the amount of vertices in $G$ by combining them in parallel, but I don\'t know how to use that to argue that the number of layers in $G$ is $O(\\log(n))$. Any help would be appreciated since I\'ve been stuck on this for several days now.</p>\n\n<p><strong>EDIT</strong>: Now that the deadline has passed for my assignment, I would love to have a solution so that I can prepare for my midterm exam (solutions to bonus/challenge problems are never posted).</p>\n\n<h2>Terminology</h2>\n\n<p><strong><a href="http://en.wikipedia.org/wiki/Series-parallel_graph" rel="nofollow">Series-parallel graphs (SP-graphs)</a></strong> are constructed in the following way. A <em>two-terminal</em> graph is a graph with two distinguished nodes $s,t$. A single edge connecting $s$ and $t$ is an SP-graph. If $(G_1,s_1,t_1)$ and $(G_2,s_2,t_2)$ are two SP-graphs, then their <em>serial</em> composition is an SP-graph, and their <em>parallel</em> composition is an SP-graph. The serial composition is obtained by identifying $t_1$ with $s_2$; the new terminals are $s_1$ and $t_2$. The parallel composition is obtained by identifying $s_1$ and $s_2$, and $t_1$ and $t_2$; the new terminals are $s_1=s_2$ and $t_1=t_2$. SP-graphs are the minimal class of graphs generated by these operations. See Wikipedia for more on this class.</p>\n\n<p><strong>$k$-outerplanar graphs:</strong> A planar embedding (i.e. an embedding without crossings) is <a href="http://en.wikipedia.org/wiki/Outerplanar_graph" rel="nofollow">$1$-outerplanar</a> if all of the vertices belong to the unbounded face. For $k \\gt 1$, a planar embedding is said to be $k$-outerplanar if removing the vertices on the outer face results in a $(k \u2212 1)$-outerplanar embedding. A graph is $k$-outerplanar if it has a $k$-outerplanar embedding.</p>\n', 'ViewCount': '115', 'Title': 'How to show that all 2-terminal SP-graphs are O(log n)-outer-planar', 'LastEditorUserId': '4734', 'LastActivityDate': '2014-02-05T02:55:43.710', 'LastEditDate': '2014-02-04T22:57:45.620', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '20174', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<graph-theory>', 'CreationDate': '2014-01-31T18:33:30.630', 'Id': '20167''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><a href="http://en.wikipedia.org/wiki/Petersen%27s_theorem" rel="nofollow">Petersen\'s Theorem</a> states that every cubic, bridgeless graph $G(V, E)$ contains a 2-factor $F$ (and therefore a perfect matching $E-F$). Alternatively, 2-factor is a set of vertex disjoint cycles that cover $V$. I\'m interested in the computational properties of 2-factors in connected bridgeless cubic graphs. I conjecture that every non-trivial property of two-factors in connected bridgeless cubic graphs is intractable.</p>\n\n<p>There are two parameters of two-factor: the number of disjoint cycles and the size of each cycle. So, it seems that restricting cycles sizes and/or the number of cycles in the 2-factor would make the decision problem of deciding the existence of restricted 2-factor is $NP$-complete. For instance, I conjecture the following decision problem is NP-complete: Given connected bridgeless cubic graph, decide whether it contains 2-factor such that sizes of each cycle are between two integers $n$ and $m$.</p>\n\n<p><strong>Non-trivial property</strong> in this context means a restriction on the parameters of  2-factor (in connected bridgeless cubic graph ) which partitions the class of connected bridgeless cubic graphs into two infinite sets. Therefore, there is infinite set of connected bridgeless cubic graphs with their 2-factor satisfying the property and infinite set not satisfying the property. I am aware of several $NP$-complete properties of 2-factors in connected bridgeless cubic graphs. For instance, Deciding the existence of connected 2-factor, even 2-factor, and odd 2-factor are all $NP$-complete problems.</p>\n\n<blockquote>\n  <p>When does such non-trivial property of 2-factor become $NP-complete? When does it become polynomial-time decidable?</p>\n</blockquote>\n\n<p>This is an improved version of a post originally posted on TCS SE.</p>\n', 'ViewCount': '97', 'Title': 'Intractable properties of Two-factor in connected bridgeless cubic graphs', 'LastEditorUserId': '96', 'LastActivityDate': '2014-02-06T21:01:54.387', 'LastEditDate': '2014-02-02T03:11:02.460', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><graph-theory><np-complete>', 'CreationDate': '2014-02-02T02:08:18.210', 'FavoriteCount': '0', 'Id': '20203''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '54', 'Title': 'Simple path in a graph, within a given range of lengths', 'LastEditDate': '2014-02-03T08:54:42.827', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13327', 'FavoriteCount': '1', 'Body': '<p>Given an undirected graph $G(V,E)$ and two nodes $s$ and $t$, $s,t\\in V$, find a path whose length $L$ is bounded by a lower bound $N$ and an upper bound $M$, $N\\leq L\\leq M$.</p>\n\n<p>So, for example, $N=4, M=7$, I want to confirm that there is at least one simple path of 4,5,6 and 7 between two nodes in a graph? Nodes of the graph may appear in more than one path.</p>\n\n<p>Typical problem size:  </p>\n\n<ul>\n<li>10,000 nodes   </li>\n<li>Mean of 20 edges per node   </li>\n<li>Cycles in graph  </li>\n<li>Unweighted edges</li>\n</ul>\n', 'ClosedDate': '2014-02-03T09:54:06.393', 'Tags': '<graph-theory><graphs><graph-traversal>', 'LastEditorUserId': '1337', 'LastActivityDate': '2014-02-03T08:54:42.827', 'CommentCount': '2', 'CreationDate': '2014-02-02T14:17:32.063', 'Id': '20217''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '54', 'Title': 'Why is the PageRank vector also the eigenvector of the web adjacency matrix?', 'LastEditDate': '2014-02-04T23:08:39.537', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7706', 'FavoriteCount': '1', 'Body': '<p>From <a href="http://en.wikipedia.org/wiki/PageRank#Damping_factor" rel="nofollow">wikipedia</a>:</p>\n\n<blockquote>\n  <p>The PageRank values are the entries of the dominant eigenvector of the\n  modified adjacency matrix. This makes PageRank a particularly elegant\n  metric</p>\n</blockquote>\n\n<p>Can anyone please elaborate on the connection between the eigenvector and the PR vector? Why are they related?</p>\n', 'Tags': '<graph-theory><search-algorithms>', 'LastEditorUserId': '11946', 'LastActivityDate': '2014-02-04T23:08:39.537', 'CommentCount': '0', 'AcceptedAnswerId': '21291', 'CreationDate': '2014-02-04T11:09:29.440', 'Id': '21283''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am learning Probabilistic Graphical Models with the help of the videos on Coursera. I am in week 4 and I see cliques being mentioned often. But the graphs being discussed are cluster graphs. So are the cliques and clusters the same?</p>\n', 'ViewCount': '47', 'Title': 'In Probabilistic Graphical Models, are Cliques and Clusters the same?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-09T08:02:50.520', 'LastEditDate': '2014-02-07T07:39:57.253', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12813', 'Tags': '<graph-theory><terminology><probability-theory><graphical-models>', 'CreationDate': '2014-02-06T22:07:25.603', 'Id': '21406''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a set of colors $M$ and a graph $G=(V,E)$. Allocate the colors to minimize the number edges with same color on the two vertices of the edge (i.e. minimize pairs of adjoining vertices with same color.).</p>\n\n<p>This problem is different from standard <a href="http://en.wikipedia.org/wiki/Graph_coloring" rel="nofollow">coloring problem</a>. Could someone please provide some literature where this problem is studied?</p>\n', 'ViewCount': '134', 'Title': 'A variation of the graph coloring problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T23:19:01.293', 'LastEditDate': '2014-02-07T22:28:30.997', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<graph-theory><reference-request><colorings>', 'CreationDate': '2014-02-07T17:30:35.593', 'FavoriteCount': '1', 'Id': '21431''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am reading <a href="http://arxiv.org/pdf/1309.7440v2.pdf" rel="nofollow">Decompositions of Triangle-Dense Graphs</a> by Gupta et al. </p>\n\n<p>On page 2, in Definition 1 what is a wedge in a graph? </p>\n\n<p>I know what triangle is but I don\'t know what wedge is and google isn\'t helping!</p>\n', 'ViewCount': '56', 'Title': 'What does a wedge in a graph look like?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T22:44:08.660', 'LastEditDate': '2014-02-09T22:44:08.660', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21470', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '244', 'Tags': '<graph-theory><terminology>', 'CreationDate': '2014-02-09T17:21:04.373', 'Id': '21469''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The Triangle Cover Graph problem is this:</p>\n\n<blockquote>\n  <p>Given a graph $G = (V,E)$ and an integer $k$, does there exist a set of at most $k$ vertices of $G$ such that every triangle contained in $G$ also contains a vertex of the set?</p>\n</blockquote>\n\n<p>This problem is obviously in $NP$ as its verifier is just the set which you can easily check.  However, what's the reduction to be able to show that this is NP Complete?</p>\n\n<p>I recognize the fact that a good reduction for this problem would be for 3-SAT as you could easily take a 3-sat instance and make a 3-vertex triangle in the graph corresponding to the variables which are in each clause.  However, I wasn't able to come up with a way to connect the different triangles together to ensure that the assignment of vertices would be a satisfiable truth assignment.</p>\n", 'ViewCount': '58', 'Title': 'Reducing 3SAT to Triangle Cover Graph', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-19T14:58:51.107', 'LastEditDate': '2014-02-19T14:58:51.107', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14824', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions>', 'CreationDate': '2014-02-19T00:19:18.737', 'FavoriteCount': '1', 'Id': '21792''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G=(L,R,E)$ be a bipartite graph, are there conditions on the degree of the vertices under which the condition of Hall\'s theorem is surely satisfied? (meaning a perfect matching exists in the graph).</p>\n\n<p><a href="http://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29" rel="nofollow">Konig\'s theorem</a> proves that every $k$-regular bipratite graph has exactly $k$ edge disjoint perfect matchings, so the answer is obviously yes for any $k$-regular bipartite graph with $k&gt;0$ (it\'s not hard to see why hall\'s condition is satisfied in this case).</p>\n\n<p>Is there a wider rule? </p>\n\n<p>For example: Let $|L|=|R|=n$, What is the minimal degree as a function of $n$ of every vertex in the graph such that the graph must admit a perfect matching?</p>\n\n<p>I\'m also wondering if these conditions will hold in general graphs (satisfying Tutte\'s theorem), and if not, then are there similar conditions for general graphs.</p>\n', 'ViewCount': '92', 'Title': "Degree conditions sufficient for Hall's theorem", 'LastEditorUserId': '10438', 'LastActivityDate': '2014-02-21T12:42:04.250', 'LastEditDate': '2014-02-21T12:42:04.250', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<graph-theory><graphs><matching>', 'CreationDate': '2014-02-19T07:49:04.013', 'Id': '21803''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G=(V,E)$ be a directed graph. The <strong>connectivity</strong> of a graph is the defined as the cardinality of a smallest separator of $G$. A <strong>separator</strong> of $G$ is a subset $U$ of $V$, such that $G-U$ is not strongly connected.</p>\n\n<p>Why does the following algorithm compute the connectivity of a graph correctly?</p>\n\n<p>\\begin{equation}\n\\begin{split}\n&amp;\\text{Connectivity}(\\text{graph }G=(V,E)) \\\\\n&amp;\\;\\;\\;\\;01\\text{:}\\;\\;k=\\infty \\\\\n&amp;\\;\\;\\;\\;02\\text{:}\\;\\;\\text{for }i=1,\\ldots,|V| \\\\\n&amp;\\;\\;\\;\\;03\\text{:}\\;\\;\\{\\\\\n&amp;\\;\\;\\;\\;04\\text{:}\\;\\;\\;\\;\\;\\;\\text{for each }v\\in V\\\\\n&amp;\\;\\;\\;\\;05\\text{:}\\;\\;\\;\\;\\;\\;\\{\\\\\n&amp;\\;\\;\\;\\;06\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{compute a minimum }v_i,v\\text{-seperator }U_{v_i,v}\\\\\n&amp;\\;\\;\\;\\;07\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;k=\\min\\left\\{k,\\left|U_{v_i,v}\\right|\\right\\}\\\\\n&amp;\\;\\;\\;\\;08\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if }(i&gt;k+1) \\text{ return }k\\\\\n&amp;\\;\\;\\;\\;09\\text{:}\\;\\;\\\\\n&amp;\\;\\;\\;\\;10\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{compute a minimum }v,v_i\\text{-seperator }U_{v,v_i}\\\\\n&amp;\\;\\;\\;\\;11\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;k=\\min\\left\\{k,\\left|U_{v,v_i}\\right|\\right\\}\\\\\n&amp;\\;\\;\\;\\;12\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if }(i&gt;k+1) \\text{ return }k\\\\\n&amp;\\;\\;\\;\\;13\\text{:}\\;\\;\\;\\;\\;\\;\\}\\\\\n&amp;\\;\\;\\;\\;14\\text{:}\\;\\;\\}\n\\end{split}\n\\end{equation}</p>\n\n<p>More precisely, why can we return $k$ in line 08 (resp. 12) without concerning the other $u,v$-seperators?</p>\n', 'ViewCount': '41', 'Title': 'Proving the correctness of an algorithm, which computes the connectivity of a directed graph', 'LastActivityDate': '2014-02-19T23:39:35.870', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21828', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12502', 'Tags': '<algorithms><graph-theory><graphs><correctness-proof>', 'CreationDate': '2014-02-19T15:58:02.890', 'FavoriteCount': '1', 'Id': '21819''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have an undirected graph where each node is labelled with an integer key and I\'m asked to detect every <em>simple</em> 4-cycle, which can be seen as an empty square (i.e. the two opposite nodes of the cycle have not to be connected).</p>\n\n<p>I know the labels of a generic square in the graph can be permuted in $4! = 24$ ways, but on his <a href="http://www.adjoint-functors.net/su/web/354/references/graph-processing-w-mapreduce.pdf" rel="nofollow">paper</a> (pages 33-36) Cohen states that the symmetric group $S_4$ has $S_4 = 8$ elements, and this should allow me to focus only on $24/8 = 3$ distinct cases.</p>\n\n<p>I don\'t understand this last point. Well, I know he probably means that the suqare has $8$ isometries (four reflections and four rotations), but I don\'t understand why this leads to the three cases in Figure 7 of the paper.</p>\n\n<p>Thank you.</p>\n', 'ViewCount': '27', 'Title': 'How many times an empty 4-cycle can be counted in an undirected graph?', 'LastEditorUserId': '13243', 'LastActivityDate': '2014-02-20T14:55:43.497', 'LastEditDate': '2014-02-20T14:27:28.440', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13243', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2014-02-20T13:09:38.950', 'Id': '21844''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A forest is a collection of trees. </p>\n\n<p>Is there a similar notion for paths? e.g., a <strong><em>_</em>__<em>_</em>__<em>_</em></strong> is a collection of paths.</p>\n', 'ViewCount': '283', 'Title': 'Tree : Forest :: Path :?', 'LastActivityDate': '2014-02-25T01:23:02.913', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '22010', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8877', 'Tags': '<graph-theory><terminology>', 'CreationDate': '2014-02-25T00:28:58.843', 'Id': '22009''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I read that determining the size of the maximum independent set (and also a clique of maximum size) is in P. The versions that find the actual solution are known to be NP-hard. </p>\n\n<p>With respect to finding clique size, you can sort the node degrees, decrement $i$ from $|V|$ to $0$, and each time check if you have $i$ elements of node degree $i$, pick the power set of those $\\geq i$ elements and verify the clique. However, picking the power set is exponential, and this algorithm would give you the solution itself. I have a hard time figuring out how you can construct an algorithm that decides the presence of a clique (or independent set) of a certain size in polytime, but doesn't give you the solution.</p>\n", 'ViewCount': '101', 'Title': 'Why is determining the size of a maximum independent set or a clique in P?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-27T07:22:20.957', 'LastEditDate': '2014-02-27T07:22:20.957', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22083', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<algorithms><complexity-theory><graph-theory><graphs><time-complexity>', 'CreationDate': '2014-02-27T05:41:09.613', 'Id': '22080''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm looking for find the min-cut of a fully-connected directed graph (with cycles), or an undirected graph.</p>\n\n<p>Karger's works but is not guaranteed to produce the correct solution. Is there a guaranteed algorithm?</p>\n\n<p>I came across max-flow algorithms. Do these only work if the graph is acyclic?</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '28', 'Title': 'Is there a guaranteed min-cut algorithm for weighted graph or weighted cyclical digraph?', 'LastActivityDate': '2014-02-28T20:47:08.847', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15135', 'Tags': '<graph-theory>', 'CreationDate': '2014-02-28T17:14:22.537', 'Id': '22134''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Given a graph $G=(V,E)$ and a set of colors $k&lt;V$. Find a assignment of colors to vertices that minimizes the number of adjacent vertices in conflict. (Two adjacent vertices are in conflict if they have the same color.)</p>\n\n<p>I want to prove the above problem is NP-complete. Call the above problem P1.</p>\n\n<p>Answer: I am trying to reduce the k-coloring problem.</p>\n\n<p>P2: Given a graph $G=(V,E)$ and set of colors $k&lt;V$ is the graph k-colorable (zero conflicts)?</p>\n\n<p>P2 is feasible iff P1 has optimal value is exactly $0$. Therefore if P1 is solved we know solution to P2.</p>\n\n<p>Is this solution correct? Is it what is suggested by the first comment of user G.Bach in <a href="http://cs.stackexchange.com/questions/21431/a-variation-of-the-graph-coloring-problem">A variation of the graph coloring problem</a> ?</p>\n', 'ViewCount': '99', 'Title': 'Proving NP-completeness of a graph coloring problem', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-04T09:15:10.200', 'LastEditDate': '2014-03-04T09:15:10.200', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '22259', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions>', 'CreationDate': '2014-03-03T23:56:50.917', 'Id': '22246''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>There is a shop which consists of N items and there are M buyers. Each buyer wants to buy a specific set of items. However, the cost of all transactions is same irrespective of the number of items sold. So, the shopkeeper needs to maximize the number of buyers. The buyers will buy only if all the items are being sold. Items are unique. All items need not be sold.</p>\n\n<p>So, basically, we have a bipartite graph. We need to find a set of edges which maximize the number of nodes on Buyer vertex set such that each node on item set has only one edge. Any suggestions?</p>\n', 'ViewCount': '28', 'Title': 'How to maximize the number of buyers in a shop?', 'LastActivityDate': '2014-03-08T15:42:28.667', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15420', 'Tags': '<graph-theory><greedy-algorithms><bipartite-matching>', 'CreationDate': '2014-03-08T15:42:28.667', 'Id': '22399''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to find a minimal vertex in a tree from which we can traverse some edges exactly twice then come back to that vertex then do it with the rest of edges. By minimal, I mean that the difference of numbers of two subsets of edges have to be minimum.</p>\n', 'ViewCount': '84', 'ClosedDate': '2014-03-12T13:16:04.857', 'Title': 'Edge traversals of trees', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-14T00:52:01.190', 'LastEditDate': '2014-03-10T07:13:30.620', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12820', 'Tags': '<graph-theory><trees><graph-traversal>', 'CreationDate': '2014-03-09T09:43:04.420', 'Id': '22421''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Let\'s say we have a directed graph $G = (V, E)$ for which $(v, w) \\in E$ and/or $(w,v) \\in E$ holds true for all $v, w \\in V$. My feeling is that this graph most definitely is Hamiltonian, and I want to find a Hamiltonian path in it (from any vertex to any other vertex, I don\'t care where to start or stop).</p>\n\n<p>I wanted to refer to <a href="http://en.wikipedia.org/wiki/Hamiltonian_path#Bondy.E2.80.93Chv.C3.A1tal_theorem" rel="nofollow">Meylien\'s theorem</a> for this:</p>\n\n<blockquote>\n  <p>A strongly connected simple directed graph with $n$ vertices is Hamiltonian if the sum of full degrees of every pair of distinct non-adjacent vertices is greater than or equal to $2n \u2212 1.$</p>\n</blockquote>\n\n<p>There are two subtleties that I\'m not sure about with this theorem:</p>\n\n<ul>\n<li>What is meant by "adjcent vertices". Does the order matter here? Is the pair $(v,w)$ adjacent even if $(w,v) \\in E$ but not $(v,w)$ itself? If that is the case and the graph is strongly connected, than it must obviously be Hamiltonian, since there are no non-adjacent pairs of vertices at all.</li>\n<li>A graph with the above property is not necessarily strongly connected. I think this is easy to solve: We can just decompose the graph into SCCs. We will still have no non-adjacent pairs of vertices in the components and all of them are Hamiltonian. We can then construct a Hamiltonian path of the whole graph by connecting them in topological order.</li>\n</ul>\n\n<p>Is the above reasoning correct and the theorem applicable? Or is there some other argument we can use to show that there is a Hamiltonian path in the graph?</p>\n\n<p>In the end I want to actually <em>find</em> the Hamiltonian cycles in the SCCs, but haven\'t had much luck finding a constructive proof of the theorem, let alone an algorithm that solves this. Can it be done in a straightforward way? I feel like some kind of greedy approach could work, where we take the nodes in decreasing order of outdegree or something similar.</p>\n', 'ViewCount': '27', 'Title': "Meyniel's theorem + finding a Hamiltonian path for a specific graph family", 'LastEditorUserId': '13167', 'LastActivityDate': '2014-03-12T03:08:19.193', 'LastEditDate': '2014-03-12T03:02:15.303', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22527', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13167', 'Tags': '<algorithms><graph-theory><graphs><hamiltonian-path>', 'CreationDate': '2014-03-12T02:51:07.913', 'Id': '22525''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a variant of bidding problem at hand.\nThere are N bidders(~20) who bid for items from a pool of many items(~10K). Each bidder can bid many items. I want to maximize the number of bidders who are satisfied. A bidder is satisfied if he gets all the items that he bid for in the first place. For eg-</p>\n\n<pre><code>Bidders = A,B,C\nItems = 1,2,3,4\n\nBidder    Bids\nA         1,2\nB         2,3\nC         3,4\n</code></pre>\n\n<p><img src="http://i.stack.imgur.com/Xcxlu.png" alt="enter image description here">\nIn this case its only possible to satisfy 2 bidders at max.</p>\n\n<p>I\'ve tried to model the problem to a maxflow problem and have taken several approaches but to no avail\nMy approaches so far-</p>\n\n<ol>\n<li><p>Tried to model this problem as a bipartite matching problem. The only problem being that instead of a one-one mapping I have a one-many mapping with an AND condition. </p></li>\n<li><p>A maxflow problem with edges going from source to each vertex with a capacity of number of bids. Problem here being ensuring that all edges from a bidder are selcted.</p></li>\n<li><p>A maxflow problem with both upper bounded and lower bounded edge capacities.</p></li>\n</ol>\n', 'ViewCount': '155', 'Title': 'Maximum number of matched vertexes in a one-to-many bipartite graph', 'LastActivityDate': '2014-03-12T17:58:04.897', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '22548', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15606', 'Tags': '<algorithms><graph-theory><network-flow><bipartite-matching><max-cut>', 'CreationDate': '2014-03-12T16:10:00.057', 'Id': '22542''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to solve a given problem: Find an algorithm to determine if a graph has a clique of size 3 in $O(n^{2.81})$ steps. The hint given is that $2.81 &gt; \\log 7$. In order to solve this I came up with a conjecture: if $m &gt; n^{\\log 7}$ then the graph has $K_3$ as a subgraph. This will easily solve the problem if the conjecture is true. </p>\n\n<p>I am trying to argue by contradiction: Let $m &gt; n^{\\log 7}$ and assume there does not exist a $K_3$ subgraph. Then for any set of three vertices there are exactly 7 choices for how to connect them. However, I am stuck as to how to progress from here.</p>\n\n<p>Does anyone see a way to prove this, or if the conjecture is even true. I'm also interested to see if the conjecture can be extended, i.e. if $m &gt; n^{\\log 2^k -1})$ does there exist a $K_k$ subgraph?</p>\n", 'ViewCount': '66', 'Title': 'Number of edges required to guarantee $K_3$ as subgraph', 'LastActivityDate': '2014-03-13T02:10:21.040', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '22569', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '15615', 'Tags': '<graph-theory>', 'CreationDate': '2014-03-12T21:22:52.710', 'Id': '22554''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to work out centrality in a network using Freeman's network centrality. I have an in degree of 83 and an out degree of 110. I want to work out the network centrality using my out degree using the following formula: \n$$\n\\frac{\\sum_{i=1}^{g}[{C}^d ({n*})-C^{d}]}\n {[(N-1)(N-2)]}\n$$</p>\n\n<p>This is where \n$$\n{n}\n$$\nis node in my graph and presuming the out- degree. Any suggestions on how to apply this formula?</p>\n\n<p>Thanks in advance!</p>\n", 'ViewCount': '28', 'Title': 'Minimizing the following objective function with matrices', 'LastActivityDate': '2014-04-12T14:10:01.060', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<graph-theory><graphs>', 'CreationDate': '2014-03-13T09:35:48.593', 'Id': '22578''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Can there be any relations regarding the number of nodes available in a digraph so that to qualify it as NP-Complete problem. \nIf we consider this problem for instance:<br/>\nInput: A digraph $G=(V,E)$ and two nodes $u,v \\in V$ <br/>\nQuestion: Is there a path in $G$ from $u$ to $v$? <br/>\nCan we say this problem is NP-Complete problem since the digraph have only two nodes that they have a path from one another and this makes it be a Hamiltonian Path.<br/> Hints are appreciated! </p>\n', 'ViewCount': '46', 'Title': 'Relation between digraph and NP-Complete problem', 'LastEditorUserId': '7269', 'LastActivityDate': '2014-03-13T14:55:06.787', 'LastEditDate': '2014-03-13T14:28:48.627', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '22588', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<complexity-theory><graph-theory><np-complete><hamiltonian-path>', 'CreationDate': '2014-03-13T13:45:05.770', 'Id': '22586''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am reading the paper: "Maximum Weight Independent Set Of Circular-Arc Graphs and It\'s Applications" (<a href="http://link.springer.com/article/10.1007%2FBF02832044" rel="nofollow">http://link.springer.com/article/10.1007%2FBF02832044</a>). And I had a question regarding the proof of Lemma 3 in the paper. It is stated as follows.</p>\n\n<p>If $X$ is the maximum weight independent set of the circular-arc graph $A$, then for any clique $Z$ of $A$, we have that $\\| X \\cap Z\\| = 1$.</p>\n\n<p>The paper then proves this by contradiction in two cases, the first when $\\| X \\cap Z\\| \\geq 2$ and the second when $\\| X \\cap Z\\| = 0$. I buy the argument for the first case, but I am concerned about the argument they make for the case equal to 0. Their argument goes as follows: If $\\| X \\cap Z\\| = 0$, then including any vertex in $Z$ into $X$ will remain independent and the weight will be greater than the previous set, contradicting the fact that $X$ was a maximum weight independent set. To me, this statement does not seem true. </p>\n\n<p><img src="http://i.stack.imgur.com/aqVfQ.jpg" alt="Circular Graph Example"></p>\n\n<p>If we pick vertices 8, 6, and 3 to have weight 1000, and all other vertices to have weight 1, then clearly {8, 6, 3} is a maximum weight independent set. However, their exists cliques of size two (edges) that have an empty intersection with {8, 6, 3}... such as the edge {1, 2}. You can also extend this to cliques of size 3 by adding an arc that intersects with arcs {8, 2, 1} then the clique formed by this new arc and arcs 1 and 2 will have an empty intersection as well.</p>\n\n<p>So where have I gone wrong in my understanding? I feel like I must be missing something really obvious. Clarifications would be greatly appreciated!</p>\n', 'ViewCount': '34', 'Title': 'Maximum Weight Independent Set in Circular-Arc Graphs (Proof of A Lemma)', 'LastActivityDate': '2014-03-14T04:31:41.060', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<algorithms><graph-theory><correctness-proof>', 'CreationDate': '2014-03-14T04:31:41.060', 'FavoriteCount': '0', 'Id': '22608''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My teacher pointed out to us during lectures that we could use <strong>Graph Search</strong> to help us solve Sudoku puzzles which has left me puzzled . </p>\n\n<p>I dont see how this is possible as <strong>Graph Search</strong> is mostly about getting from Node A to Node B. He mentioned about how its a directed graph where the nodes correspond to partially completed puzzle</p>\n\n<p>What is the general idea behind using <strong>Graph Search</strong> to solve Sudoku Puzzle</p>\n', 'ViewCount': '108', 'Title': 'How to implement graph search to solve Sudoku puzzle', 'LastEditorUserId': '12448', 'LastActivityDate': '2014-03-17T12:30:24.120', 'LastEditDate': '2014-03-17T07:52:15.367', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12448', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs>', 'CreationDate': '2014-03-17T07:45:30.290', 'FavoriteCount': '1', 'Id': '22695''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I\u2019m trying to find an algorithm that can give me an approximate solution for a wiring problem that I have been asked to look at. I believe this is closely related to finding a node weighted Steiner tree \u2013 e.g. <a href="http://www.cs.umd.edu/~samir/grant/gk98b.ps" rel="nofollow">http://www.cs.umd.edu/~samir/grant/gk98b.ps</a>. </p>\n\n<p>I have a number of connectors which have a fixed location in space and are connected together by wires. This can be represented as a graph where the connectors are nodes and the wires are edges:</p>\n\n<p><img src="http://i.stack.imgur.com/yQwNf.png" alt="Original layout"></p>\n\n<p>Each wire needs to be surrounded by a tube to protect it and a tube can contain many wires. Two or more tubes can be joined together at a junction. In the sketch below, the black lines show the outside of the tubes and the grey circles show junctions, but with each connector still connected by the same wires as before:</p>\n\n<p><img src="http://i.stack.imgur.com/7U9jO.png" alt="Layout showing junctions and tubes"></p>\n\n<p>Both the tubes and the junctions have a cost associated with them \u2013 for the tubes this is proportional to the length of the tube, for the junctions this is a fixed cost per junction. For example, if the tubes cost \\$10 per metre and the junctions cost \\$5 each, 1 metre of tubes with two junctions would be 10 + 5 + 5 = \\$20.</p>\n\n<p>I would like to find a layout that minimises the cost of the total length of tube + the cost of the junctions. I don\u2019t think it\u2019s quite the same problem as the reference above \u2013 I need to ensure that that the wires connecting between the connectors do not change, only the intermediate junctions between them. My real application has approximately 300 nodes and 1500 edges.</p>\n\n<p>Thanks,</p>\n\n<p>Rich</p>\n', 'ViewCount': '31', 'Title': 'Steiner tree wiring problem', 'LastActivityDate': '2014-03-17T18:14:12.507', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15786', 'Tags': '<algorithms><graph-theory>', 'CreationDate': '2014-03-17T18:14:12.507', 'Id': '22717''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am reading the paper Color Coding by Alon, Yuster, and Zwick. They state a theorem (6.3) that says if $H$ is a graph on $k$ vertices with treewidth $t$ and $G = (V, E)$, then a subgraph of $G$ isomorphic to $H$ can be found in $2^{O(k)}V^{t+1}$ expected time. They do not include a proof, but do state that the proof is similar to the case where $H$ is a forest (namely theorem 6.1, which they do provide a proof of).</p>\n\n<p>As I am trying to understand how they algorithm would work for graphs of bounded treewidth, I was wondering if anyone could provide a proof sketch of the algorithm, as I don\'t see how it would be similar to the proof of 6.1 - Any help would really be appreciated, as this is for a course project, and I am having difficulties figuring out the algorithm.</p>\n\n<p>A copy of the paper can be found here: <a href="http://www.tau.ac.il/~nogaa/PDFS/col5.pdf" rel="nofollow">http://www.tau.ac.il/~nogaa/PDFS/col5.pdf</a></p>\n', 'ViewCount': '47', 'Title': 'Subgraph Isomophism Problem - Color Coding Technique - Proof Sketch', 'LastActivityDate': '2014-03-18T04:53:05.377', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22746', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<graph-theory><graph-isomorphism>', 'CreationDate': '2014-03-18T01:14:16.027', 'Id': '22739''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '216', 'Title': 'Characterisation of graphs that are not 3-colorable', 'LastEditDate': '2014-03-18T14:13:21.130', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14957', 'FavoriteCount': '1', 'Body': '<p>We know that <em>all</em> graphs with odd cycles (odd number of vertices) are not 2-colorable. Is there a similar characterisation for 3-colorability? I am looking for undirected graphs that are not 3-colorable depending on a single graph property e.g. vertices/edges parity or anything else that can be generalised.</p>\n', 'Tags': '<graph-theory><colorings>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T17:51:39.087', 'CommentCount': '0', 'AcceptedAnswerId': '22757', 'CreationDate': '2014-03-18T13:59:40.307', 'Id': '22754''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G$ be a graph whose Shannon Capacity is $\\Theta(G)$. Is there any graph product for which the Shannon Capacity is $\\Theta(G)^k$ where $k$ is the number of times the product is taken?</p>\n', 'ViewCount': '19', 'Title': 'On Shannon Capacity', 'LastActivityDate': '2014-03-18T20:08:37.647', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22768', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<graph-theory><information-theory>', 'CreationDate': '2014-03-18T18:28:33.060', 'Id': '22764''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have to solve this problem: We have weighted $n$-node undirected graph $G = (V,E)$ and a positive integer $k$. We can reach all vertices from vertex 1 (the root). We need to find the weight of minimal spanning tree in which the degree of vertex 1 is at most $k$ (we don\'t care about other vertices\' degrees). We can assume that such a tree exists.</p>\n\n<p>Can someone give an idea how to approach the solution?</p>\n\n<p>What I\'ve already tried:</p>\n\n<p>1) I know how to find essential edges from vertex 1. We can use dfs and start from a random edge of vertex 1. When we return to vertex 1 we can check if this edge (another vertex 1 edge) has lower weight than the previous one. If yes, than the previous one is not essential.</p>\n\n<p>2) After that I wanted to use Kruskal\'s algorithm (adding in the beginning of the algorithm all essential edges). But the problem is that sometimes we should not take an edge with minimal weight to construct the required tree. </p>\n\n<p>For example: 9-node undirected graph, $k = 3$</p>\n\n<pre><code>(vertex1 vertex2 weight)\n1 2 1\n2 3 5\n3 4 6\n4 5 7\n5 1 1\n1 6 1\n6 7 8\n7 8 9\n8 9 10\n9 1 2\n</code></pre>\n\n<p>So essentials will be (1,2) and (1, 6) (or (1, 5) and (1,6)). Kruskal will take (1,5) (or (1,2)) anyway. And the weight will be 41, but the correct answer is 39.\nSo I don\'t know how to use Kruskal\'s algorithm here. </p>\n\n<p>(The same example visualized, vertex 1 = vertex A)</p>\n\n<p><img src="http://i.stack.imgur.com/ud2Xc.png" alt="The same example visualized"></p>\n\n<p>I thought that we may construct a minimal spanning tree without constraints and after that try to transform it to the required one, but I don\'t know how to do this (how to transform without brute force).</p>\n', 'ViewCount': '146', 'Title': 'Minimal spanning tree with degree constraint', 'LastEditorUserId': '15839', 'LastActivityDate': '2014-03-19T20:17:49.750', 'LastEditDate': '2014-03-19T11:20:15.890', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15839', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2014-03-18T21:45:52.923', 'FavoriteCount': '2', 'Id': '22775''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have two shapes in a 2D space, not necessarily convex, and I\'d like to compare how similar they are. How can I define a robust distance metric to measure their similarity, and how can I compute it?</p>\n\n<p><img src="http://i.stack.imgur.com/COt2d.png" alt="Distance between two shapes"></p>\n\n<p>I am looking for a method which provides a short distance in case of:</p>\n\n<ol>\n<li>scaling;</li>\n<li>rotation;</li>\n<li>perhaps local scaling or rotation.</li>\n</ol>\n\n<hr>\n\n<p>I see two possible solutions:</p>\n\n<ol>\n<li>transform the shapes into <strong>pixel-based matrices</strong> (bitmap) and compute a Levenshtein distance (but without enough robustness in the distance, in case of rotation for instance);</li>\n<li>transform the shapes into <strong>graphs</strong> and try to define a distance between them.</li>\n</ol>\n', 'ViewCount': '58', 'Title': 'Similarity between two geometric shapes', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-19T00:40:49.737', 'LastEditDate': '2014-03-19T00:40:49.737', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15843', 'Tags': '<algorithms><graph-theory><computational-geometry><computer-vision>', 'CreationDate': '2014-03-18T23:43:32.437', 'FavoriteCount': '2', 'Id': '22781''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to solve this problem:</p>\n\n<blockquote>\n  <p>Given a collection of cities and the number of commuters between cities, design a network of roads for minimal cost where cost includes the cost of building the roads, and traveling of commuters. (So if more commuters use one edge, that edge will have a modified cost since the commuters want to get to their destination quickly)</p>\n</blockquote>\n\n<p>I've been treating the cities as nodes in a graph and the roads as edges. I want the weight of the edges to be dependent on the length of the edge (longer edges cost more) and somehow dependent on how many commuters are using that edge.</p>\n\n<p>My thought was to try doing something like a Minimum Steiner Tree, which if cost didn't depend on the commuters would minimize the cost of building the roads, but I'm not convinced that the solution to this should be a tree. And if I try to find a Minimal Spanning Tree or Minimum Steiner Tree I'm not sure how to deal with the fact that I don't know the edge cost until I know the full tree/graph. That is if people want to travel from A to B and we remove the edge from A to B, those people will now have to travel from A to C then from C to B which will modify the edge cost between A and C and C and B.</p>\n\n<p>Does anyone have any ideas on how to deal with the changing edge costs or know of a better way to solve this problem?</p>\n\n<p><strong>edit:</strong> You can make any sort of network you want, the roads can go straight from one city to another, or to any intermediate node(s) which can be placed anywhere in the plane. I'm planning on making the cost of building a road just a constant times the length of the road. For the cost of commuters I think another fractional constant times the distance they have to travel along the roads times the number of commuters traveling along that section of road.</p>\n", 'ViewCount': '87', 'ClosedDate': '2014-03-27T07:59:50.773', 'Title': 'Algorithm to determine a minimal cost graph', 'LastEditorUserId': '15844', 'LastActivityDate': '2014-03-19T16:50:47.457', 'LastEditDate': '2014-03-19T16:50:47.457', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15844', 'Tags': '<algorithms><graph-theory><graphs><weighted-graphs>', 'CreationDate': '2014-03-18T23:49:12.033', 'Id': '22782''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>I am reading Prim's MST for the first time and wanted to implement the fast version of it . </p>\n\n<p>$m$ - The number of edges in the graph </p>\n\n<p>$n$ - The number of vertices in the graph </p>\n\n<p>Here's the algorithm :</p>\n\n<p>1) Create a Min Heap of size $V$ where $V$ is the number of vertices in the given graph. Every node of min heap contains vertex number and key value of the vertex.</p>\n\n<p>2) Initialize Min Heap with first vertex as root (the key value assigned to first vertex is $0$ ). The key value assigned to all other vertices is $\\infty$ .</p>\n\n<p>3) While Min Heap is not empty, do following</p>\n\n<p>\u2026..a) Extract the min value node from Min Heap. Let the extracted vertex be u.</p>\n\n<p>\u2026..b) For every adjacent vertex $v$ of $u$, check if $v$ is in Min Heap (not yet included in MST). If $v$ is in Min Heap and its key value is more than weight of $u-v$, then update the key value of $v$ as weight of $u-v$.</p>\n\n<p>Now my point is during implementation ( I am doing in C++) in step 3(b) I have to check whether the vertex is there in the heap or not . As we know , searching in a heap is done in $O(n)$ time . So in the main while loop which will run ( $n$ number of times ) although extract-min is $O(\\log n)$ but the search ( whether $v$ is min heap or not takes time proportional to size of the heap ( although it is decreasing in each step ) . </p>\n\n<p>So is it correct to say that the above algorithm is $O(m+n\\log n)$</p>\n", 'ViewCount': '86', 'Title': "Prim's Minimum Spanning Tree implementation $O(mn)$ or $O(m+n \\log n)$?", 'LastEditorUserId': '15879', 'LastActivityDate': '2014-03-19T19:06:06.820', 'LastEditDate': '2014-03-19T18:56:58.260', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15879', 'Tags': '<algorithms><graph-theory><algorithm-analysis><graphs><runtime-analysis>', 'CreationDate': '2014-03-19T18:20:22.067', 'Id': '22817''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was reading up on <a href="http://en.wikipedia.org/wiki/Four_color_theorem" rel="nofollow">Four color theorem</a> and am wondering if there is any practical application of it .( I dont think seperating the map into four different colors can be considered an application)</p>\n\n<p>I tried Googling for applications of Four colour theorem but could not find any uses of it . </p>\n', 'ViewCount': '71', 'Title': 'Application of Four color theorem', 'LastActivityDate': '2014-03-21T15:24:07.493', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12448', 'Tags': '<graph-theory><colorings>', 'CreationDate': '2014-03-21T04:17:25.910', 'FavoriteCount': '1', 'Id': '22892''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider the "Generalized Geography" game: on directed graph G with selected start node, players take turns moving along edges, without ever going back to previously visited nodes.  Last player to move wins.</p>\n\n<blockquote>\n  <p>GG = {  : G is a directed graph, b is a node in G, and the next\n                     player to play has a winning strategy for generalized\n                     geography from start node b, i.e., there are moves for\n                     the next player to win no matter how opponent plays }</p>\n</blockquote>\n\n<p>This problem is well-known to be in PSPACE and EXPTIME-hard. My question is:\nIf we allow repetitions in GG, it still belongs to EXPTIME-hard?</p>\n', 'ViewCount': '59', 'Title': 'Generalized Geography with repetitions', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-22T20:01:27.593', 'LastEditDate': '2014-03-22T20:01:27.593', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15966', 'Tags': '<graph-theory><time-complexity><space-complexity>', 'CreationDate': '2014-03-21T11:50:18.843', 'FavoriteCount': '0', 'Id': '22901''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>This is a Discrete Math/Combinatorics Question from my hw\u2026but I don't really understand the question.</p>\n\n<blockquote>\n  <p>Find largest chromatic number of a full binary tree given the following depths: (Check all that apply)</p>\n  \n  <p>T2 T3 T7 T12 T200</p>\n</blockquote>\n\n<p>I understand that the chromatic number refers to the minimum color that you can color a graph or tree with the adjacent nodes or vertices being different colors.</p>\n\n<p>So knowing this fact... I'm sure that the chromatic number for all full binary trees should be 2 since you can use two different color nodes to completely color the tree? But they want me to find the largest chromatic number. I'm just confused.</p>\n", 'ViewCount': '94', 'ClosedDate': '2014-04-01T22:00:40.957', 'Title': 'Find largest chromatic number of a full binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T05:10:33.807', 'LastEditDate': '2014-03-21T21:11:42.240', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'Ace', 'PostTypeId': '1', 'Tags': '<graph-theory><binary-trees><trees><discrete-mathematics><colorings>', 'CreationDate': '2014-03-21T03:15:36.973', 'Id': '22906''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '11', 'Title': 'Generalized Geography with repetitions', 'LastEditDate': '2014-03-22T20:01:21.090', 'AnswerCount': '0', 'Score': '2', 'OwnerDisplayName': 'user3195997', 'PostTypeId': '1', 'OwnerUserId': '15966', 'FavoriteCount': '0', 'Body': '<p>Consider the "Generalized Geography" game: on directed graph G with selected start node, players take turns moving along edges, without ever going back to previously visited nodes. Last player to move wins.</p>\n\n<blockquote>\n  <p>GG = { : G is a directed graph, b is a node in G, and the next player to play has a winning strategy for generalized geography from start node b, i.e., there are moves for the next player to win no matter how opponent plays }</p>\n</blockquote>\n\n<p>This problem is well-known to be in PSPACE and EXPTIME-hard. My question is: If we allow repetitions in GG, it still belongs to EXPTIME-hard?</p>\n', 'ClosedDate': '2014-03-22T20:01:36.047', 'Tags': '<graph-theory><time-complexity><space-complexity>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-22T20:01:21.090', 'CommentCount': '0', 'CreationDate': '2014-03-21T11:53:26.130', 'Id': '22945''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '159', 'Title': 'Undirected graph with 12 edges and 6 vertices', 'LastEditDate': '2014-03-25T11:49:03.893', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16029', 'FavoriteCount': '0', 'Body': '<p>For school we have to make an assignment, and part of the assignment is this question:</p>\n\n<blockquote>\n  <p>Describe an unidrected graph that has 12 edges and at least 6\n  vertices. 6 of the vertices have to have degree exactly 3, all other\n  vertices have to have degree less than 2. Use as few vertices as\n  possible.</p>\n</blockquote>\n\n<p>The best solution I came up with is the following one. Here the number in the circles is the degree of that vertex, now I was wondering if there is a better solution, if so, can somebody explain this to me?</p>\n\n<p><img src="http://i.stack.imgur.com/eHNNo.png" alt="Solution exercise 1"></p>\n\n<p><em>I do not need a better answer, just a push in the right direction - if needed.</em></p>\n', 'ClosedDate': '2014-03-27T07:58:38.133', 'Tags': '<graph-theory><discrete-mathematics>', 'LastEditorUserId': '16029', 'LastActivityDate': '2014-03-25T11:49:03.893', 'CommentCount': '13', 'AcceptedAnswerId': '22980', 'CreationDate': '2014-03-23T16:09:19.720', 'Id': '22972''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '52', 'Title': 'Complexity of calculating independence number of a hypergraph', 'LastEditDate': '2014-03-25T21:38:30.027', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16119', 'FavoriteCount': '1', 'Body': '<p>Let $G$ be a "hypergraph", a collection of vertices $V=\\{v_1,v_2,\\ldots,v_n\\}$ and a collection of "hyperedges" $E=\\{e_1,e_2,\\ldots,e_m\\}$, where $e_i\\subseteq V$ and unlike normal edges, an edge may contain more than two vertices.</p>\n\n<p>An "independent set" (<a href="http://en.wikipedia.org/wiki/Independent_set_(graph_theory)" rel="nofollow">http://en.wikipedia.org/wiki/Independent_set_(graph_theory)</a>) is a collection of vertices, $U$, that does not fully contain any of the hyperedges:  $e_i\\not\\subseteq U$.  The "independence number" or "maximum independent set size" is the size of the largest independent set in the graph $G$.</p>\n\n<p>I know that finding if there is an independent set of size $k\\in\\mathbb{N}$ in some normal graph $G$ is NP-Complete.  If I am not mistaken, this holds for hypergraphs as well.  However calculating the independence number is not proven to be NP.  Even approximating it is not proven in NP.</p>\n\n<p>First, is there a more specific complexity class for calculating the independence number than NP-Hard?</p>\n\n<p>Second, how much harder is it for a hypergraph?  Again, is there a complexity class more specific?</p>\n\n<p>For related questions, a recent dissertation has been helpful to me: <a href="https://escholarship.org/uc/item/79t9b162" rel="nofollow">https://escholarship.org/uc/item/79t9b162</a>.</p>\n\n<p>Thanks!</p>\n', 'Tags': '<complexity-theory><graph-theory>', 'LastEditorUserId': '16119', 'LastActivityDate': '2014-03-26T01:07:40.823', 'CommentCount': '15', 'AcceptedAnswerId': '23051', 'CreationDate': '2014-03-25T20:15:07.680', 'Id': '23044''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The question is as follows:\nTrue or False: For every non-directed connected non-weighted graph and for every spanning tree T of the graph there exists a vertex v such that T is a DFS tree with the root v.</p>\n\n<p>What about if instead of DFS I used BFS?</p>\n\n<p>I have no clue where to begin with this one. I feel like I'm overlooking some basic characteristic of the algorithm or the tree that it produces. Any help would be appreciated!</p>\n", 'ViewCount': '28', 'Title': 'Question about spanning trees and creating them through BFS and/or DFS algorithms', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-26T23:45:56.843', 'LastEditDate': '2014-03-26T23:45:56.843', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15977', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2014-03-26T22:08:28.540', 'FavoriteCount': '2', 'Id': '23101''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><strong>Context</strong></p>\n\n<p>Consider this algorithm. If the set $\\{\\angle p_ip_{i+1}p_{i+2} : i=0,...,n-1\\}$  does not contain left and right turns, output "yes the polygon is convex"; otherwise, "no".</p>\n\n<p><strong>My answer</strong>  </p>\n\n<p>Consider this nonsimple polygon having 4 vertices; the algorithm above will output "yes" as the set of points does not contain both left and right turns, yet the polygon is not convex. Is this a good counterexample rendering the above algorithm incorrect? </p>\n\n<p><img src="http://i.stack.imgur.com/hHEck.png" alt="enter image description here"></p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '37', 'Title': 'Show that this algorithm does not work for determining convex polygons', 'LastEditorUserId': '15072', 'LastActivityDate': '2014-03-29T11:42:03.130', 'LastEditDate': '2014-03-29T11:42:03.130', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23202', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<algorithms><graph-theory><computational-geometry>', 'CreationDate': '2014-03-28T21:33:44.823', 'Id': '23193''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Say that for a particular problem, e.g., the independent set problem, it has been shown that no polynomial-time algorithm exists to solve it.</p>\n\n<p>Could we get around this by finding an algorithm which approximates the solution to a certain accuracy?</p>\n\n<p>That is, would the result above bar the existence of an algorithm which finds a maximum independent set to an accuracy of 0.5? I.e., it is guaranteed to be less than 0.5 away from the size of a maximum set? (And hence implying that it actually <em>is</em> a maximum independent set.)</p>\n\n<p>It seems to me that the latter wouldn't violate our proofs of non-tractability, which are discrete in nature, while still giving an answer that satisfies the problem from a practical perspective.</p>\n", 'ViewCount': '252', 'Title': 'Approximating NP-complete problems', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-30T16:47:19.050', 'LastEditDate': '2014-03-30T16:47:19.050', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '23239', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<algorithms><graph-theory><algorithm-analysis><time-complexity>', 'CreationDate': '2014-03-30T01:43:13.067', 'Id': '23236''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '85', 'Title': 'Difference between diameter of a graph vs longest path of the graph', 'LastEditDate': '2014-03-31T08:22:09.740', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9536', 'FavoriteCount': '1', 'Body': '<p>I am curious what is the difference between diameter of a graph vs longest path of a graph. I just read diameter of a graph can be solved using Floyd warshall in O(V^3) while longest path can be calculated in O(V + E) using topological sort. </p>\n', 'Tags': '<graph-theory><terminology>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-31T09:19:55.540', 'CommentCount': '0', 'AcceptedAnswerId': '23285', 'CreationDate': '2014-03-31T05:37:49.697', 'Id': '23284''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>What is average number of cycles in an undirected ordered graph of size $n$? \nI've tried finding out sum of number of cycles in all sorts of a graph of size n but I couldn't find that out.</p>\n", 'ViewCount': '108', 'Title': 'What is average number of cycles in an undirected ordered graph of size n?', 'LastEditorUserId': '16351', 'LastActivityDate': '2014-04-01T20:03:42.260', 'LastEditDate': '2014-04-01T11:48:30.700', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16351', 'Tags': '<graph-theory><combinatorics>', 'CreationDate': '2014-04-01T10:18:30.250', 'Id': '23315''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Suppose that $G$ and $H$ are both expander graphs on the same node set with a second largest eigenvalue of $\\lambda_G$ resp. $\\lambda_H$.</p>\n\n<ul>\n<li>What can be said about the expansion of graph $G \\cup H$? In particular, is the spectral gap of $G \\cup H$ at least as large as the minimum of the spectral gaps of $G$ and $H$? </li>\n<li>Does it make a difference whether $G$ and $H$ both have constant node degree?</li>\n</ul>\n\n<p>This is certainly true for the <em>edge expansion</em> of $G \\cup H$, since it can only increase by adding edges. \nI know that spectral expansion and edge expansion are related by the <a href="http://en.wikipedia.org/wiki/Cheeger_constant_%28graph_theory%29#Cheeger_Inequalities">Cheeger inequality</a>, but using this route we only get a bound on the <em>spectral expansion</em> of $G \\cup H$ that is <strong>worse</strong> than $\\lambda_G$ and $\\lambda_H$. </p>\n', 'ViewCount': '36', 'ClosedDate': '2014-04-04T01:17:03.140', 'Title': 'Union of 2 expander graphs', 'LastActivityDate': '2014-04-03T01:04:20.107', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '16400', 'Tags': '<graph-theory><combinatorics><expanders>', 'CreationDate': '2014-04-03T01:04:20.107', 'Id': '23379''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a problem that I encountered that boils down to the following:</p>\n\n<p>Considered this directed graph I found on Google: <img src="http://i.stack.imgur.com/BTt0Z.png" alt="enter image description here"></p>\n\n<p>I have the following information available to me</p>\n\n<pre><code>Node: Ancestors\n\n1 : 3\n2 : 1 3 5 7\n3 : Null\n4 : 3 5\n5 : 3\n6 : 1 2 3 4 5 7 \n7 : 1 3\n8 : 1 2 3 4 5 6 7\n</code></pre>\n\n<p>How can I re-construct the original graph in a reasonably efficient manner? I basically have large sets of data that I would like to have visualized as branches and merges(similar to a code repository, but not quite).</p>\n\n<p>Note: While I believe my data shouldn\'t be disjoint, I\'m somewhat certain my data is incomplete and will produce disjoint graphs, or at the very least have many separate "roots". There is no ordering to the data, everything must be considered random, the lists can also be thought of as sets. </p>\n', 'ViewCount': '39', 'Title': 'Reconstruct directed graph from list of ancestors for each node', 'LastEditorUserId': '16433', 'LastActivityDate': '2014-04-04T13:27:17.890', 'LastEditDate': '2014-04-04T02:55:04.440', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16433', 'Tags': '<algorithms><graph-theory><graphs><sets>', 'CreationDate': '2014-04-04T02:30:23.000', 'Id': '23408''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We know that if an edge is a part of a cycle in an undirected connected graph $G$, then if we remove that edge the graph is still connected.</p>\n\n<p>Is the opposite true? If an edge is <strong>not</strong> a part of a cycle in a connected graph $G$, and we remove that edge, then the graph we get is disconnected?</p>\n\n<p>P.S.: I think that it is true, and the direction for a proof is to look at one vertex it connects, and the edges that connect the vertices with it as on component, and the other end as another component, and showing that if we cut out that edge, we get two components, such that the graph is not connected. What do you think?</p>\n', 'ViewCount': '38', 'Title': 'Edges in and out of cycles and their relation to connectivity of the graph', 'LastEditorUserId': '11424', 'LastActivityDate': '2014-04-05T18:48:54.910', 'LastEditDate': '2014-04-05T15:33:58.793', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<graph-theory>', 'CreationDate': '2014-04-05T15:25:33.420', 'Id': '23451''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>1) Is there a better algorithm than the naive O(|E|.|V|) to compute the number of descendants of each vertex in a DAG?</p>\n\n<p>2) Is there an online algorithm to do so, assuming that nodes are added one by one and connect to a non empty subset of the existing nodes?</p>\n\n<p>Context: I\'m interested in the case where m = O(n), millions of vertices, tens of millions of edges typically.\nAlternatively, counting the number of descendants which are also sinks would be useful.</p>\n\n<hr>\n\n<p>A probabilistic approach would be min-hashing, as a way to represent the set of descendants of every node. The union of the min-hash structure is trivial, and the cardinality of the union can be estimated from the number of coincidences in the min-hashes.</p>\n\n<p>However, I\'m not sure how well behaved that would be when propagating up the DAG, intuitively it looks like errors would compound pretty fast.</p>\n\n<hr>\n\n<p>Very related: <a href="http://cstheory.stackexchange.com/questions/553/what-bounds-can-be-put-on-counting-reachable-nodes-in-a-dag">http://cstheory.stackexchange.com/questions/553/what-bounds-can-be-put-on-counting-reachable-nodes-in-a-dag</a>\nAnd actually a duplicate of: <a href="http://cstheory.stackexchange.com/questions/18787/what-is-the-fastest-deterministic-algorithm-for-incremental-dag-reachability">http://cstheory.stackexchange.com/questions/18787/what-is-the-fastest-deterministic-algorithm-for-incremental-dag-reachability</a></p>\n', 'ViewCount': '61', 'Title': 'Number of descendants of each node in a DAG', 'LastEditorUserId': '9476', 'LastActivityDate': '2014-04-07T02:30:58.040', 'LastEditDate': '2014-04-07T02:30:58.040', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '5', 'OwnerDisplayName': 'Arthur B', 'PostTypeId': '1', 'OwnerUserId': '16450', 'Tags': '<graph-theory>', 'CreationDate': '2014-04-04T17:36:46.840', 'Id': '23455''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '38', 'Title': 'What is the common terminology to refer to the nth ancestor of a tree root?', 'LastEditDate': '2014-04-07T23:34:03.630', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'xtian', 'PostTypeId': '1', 'OwnerUserId': '16569', 'Body': '<p>Reading the Wikipedia article for common terminology for tree <a href="http://en.wikipedia.org/wiki/Tree_%28data_structure%29" rel="nofollow">(data structure)</a> there are several near references, but I don\'t read a formal declaration for how to refer to a specific generation of a tree\'s subtrees. </p>\n\n<p>For example, </p>\n\n<blockquote>\n  <h3>Definition</h3>\n  \n  <p>As a data type, a tree has a value and children, and <strong>the children are \n  themselves trees</strong>;  [...] Due to the use of references to\n  trees in the linked tree data structure, trees are often discussed\n  implicitly assuming that they are being represented <strong>by references to\n  the root node</strong>, as this is often how they are actually implemented.</p>\n</blockquote>\n\n<p>And also,</p>\n\n<blockquote>\n  <h3>Terminology.</h3>\n  \n  <p>"The <strong>height of a node is the length of the longest downward path to a\n  leaf from that node.</strong> The height of the root is the height of the\n  tree. [...] <strong>The root node has depth zero</strong>..."</p>\n</blockquote>\n\n<p>The former implies subtree n could be refered to as the nth decendant of root or the nth tree. Can I be sure subtree only refers to decendants and not other branches at the same distance from root?</p>\n\n<p>The latter refers to the height counting from the root (0). Again, height sounds uncommon to me. As in, <em>"Please refer to the nodes at height 4 to see..."</em> Since a tree is commonly displayed from the root branching downward, I\'m predisposed to bias against the term <em>height</em> versus my preferred notion of <em>depth</em>. </p>\n', 'Tags': '<graph-theory><terminology><trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T23:34:03.630', 'CommentCount': '4', 'AcceptedAnswerId': '23523', 'CreationDate': '2014-04-06T16:18:17.753', 'Id': '23519''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I got a problem related to graph theory - </p>\n\n<p>Consider an undirected graph \u0729 where self-loops are not allowed. The vertex set of G is\n{(i,j):1&lt;=i,j &lt;=12}. There is an edge between (a, b) and (c, d) if |a-c|&lt;=1 and |b-d|&lt;=1\nThe number of edges in this graph is </p>\n\n<p>Answer is given as 506\nbut I am calculating it as 600, please see attachment.</p>\n\n<p>I am unable to get why it is coming as 506 instead of 600.</p>\n\n<p>Thanks<img src="http://i.stack.imgur.com/IKmgx.png" alt="enter image description here"></p>\n', 'ViewCount': '53', 'Title': 'number of edges in a graph', 'LastEditorUserId': '16546', 'LastActivityDate': '2014-04-08T14:01:25.283', 'LastEditDate': '2014-04-08T07:50:57.403', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23533', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11750', 'Tags': '<graph-theory><graphs><combinatorics><counting>', 'CreationDate': '2014-04-08T06:39:12.977', 'Id': '23532''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Im looking online for a good definition of sparse graphs, but i'm confused. Is a sparse graph effectively a big one, with millions/billions of nodes. An example, is a real world one - like Facebook. Or can they be in small networks as well?</p>\n\n<p>Thanks in advance!</p>\n", 'ViewCount': '41', 'Title': 'Understanding sparse graphs', 'LastActivityDate': '2014-04-08T13:33:43.637', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<graph-theory><network>', 'CreationDate': '2014-04-08T11:40:29.187', 'Id': '23546''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m taking a class on graph theory that uses "Graph Theory (Graduate Texts in Mathematics)" by Bondy and Murty. One of the questions is about Cayley graphs and the n-cube, and I don\'t understand how to interpret it. It runs as follows:</p>\n\n<blockquote>\n  <p>Let $\\Gamma$ be a group and $S$ be a subset of $\\Gamma$ not including the\n  identity element. Suppose that the inverse of every element in $S$ also\n  belongs to $S$. The Cayley graph of $\\Gamma$ with respect to $S$ is the graph\n  $CG(\\Gamma, S)$ with vertex set $\\Gamma$ in which two vertices $x$ and $y$ are\n  adjacent iff $xy^{-1}\\in S$.</p>\n</blockquote>\n\n<p>Okay. I follow so far.</p>\n\n<blockquote>\n  <p>Recall that the n-cube is the graph whose vertex set is the set of all\n  n-tuples of 0s and 1s, where two n-tuples are adjacent if they differ\n  in precisely one coordinate.</p>\n</blockquote>\n\n<p>Makes sense.</p>\n\n<blockquote>\n  <p>Show that the n-cube is a Cayley graph.</p>\n</blockquote>\n\n<p>What does it mean to talk about "$xy$" when $x$ and $y$ are n-tuples? What is the inverse of an n-tuple?</p>\n\n<p>Someone I asked about the problem suggested that I treat $\\Gamma$ here as the additive group $({\\mathbb Z}/2{\\mathbb Z})^n$, and so take $xy^{-1}$ to mean elementwise subtraction of $y$ from $x$, mod 2. But then it seems like $(0, 0, ..., 0)\\in\\Gamma$ and, since it\'s the identity element, every vertex will have an edge connecting to it, and that isn\'t what the n-cube looks like. Googling, I also see that there is an <a href="http://en.wikipedia.org/wiki/Tuple#Tuples_as_nested_sets" rel="nofollow">interpretation of tuples as nested sets</a>, but then I don\'t see how the product of two nested sets would ever be in S, since it will have a different cardinality from either of the original tuples. Interpreting the tuples as vectors can\'t work either since then $xy^{-1}$ will have different dimensions than either of the original tuples.</p>\n\n<p>What is this question asking?</p>\n', 'ViewCount': '48', 'Title': 'n-Cube as a Cayley Graph', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-13T10:06:40.313', 'LastEditDate': '2014-04-13T10:03:00.093', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23733', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16612', 'Tags': '<graph-theory><terminology><group-theory>', 'CreationDate': '2014-04-13T03:07:11.680', 'Id': '23724''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>What is the difference between maximal flow and maximum flow. I am reading these terms while working on Ford Fulkerson algorithms and they are quite confusing. I tried on internet, but couldn't get a reasonable answer. I believe maximum flow is quite clear as it means maximum amount of flow that can be transferred from source to sink in a network, but what exactly is maximal flow.</p>\n\n<p>Please answer in layman terms if possible.</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '100', 'Title': 'What is the difference between maximal flow and maximum flow?', 'LastActivityDate': '2014-04-14T01:38:17.857', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16750', 'Tags': '<algorithms><graph-theory><graphs><network-flow>', 'CreationDate': '2014-04-14T00:31:01.150', 'Id': '23763''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '57', 'Title': 'Shortest directed path connecting given subset of vertices', 'LastEditDate': '2014-04-14T18:27:40.627', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6615', 'FavoriteCount': '1', 'Body': '<p>Given</p>\n\n<ul>\n<li>weighted directed graph $G = (V,E,w)$, where $w : E \\to \\mathbb R^+$</li>\n<li>source vertex $v \\in V$</li>\n<li>vertex subset $U \\subset V$</li>\n</ul>\n\n<p>how to find a shortest directed path from $v$ containing all vertices from $U$? Note that such path may contain vertices that are not in $U$.</p>\n\n<ol>\n<li>Does such problem have a name?</li>\n<li>How to find a solution?</li>\n</ol>\n', 'Tags': '<graph-theory><terminology><shortest-path><weighted-graphs>', 'LastEditorUserId': '6615', 'LastActivityDate': '2014-04-14T18:27:40.627', 'CommentCount': '2', 'AcceptedAnswerId': '23789', 'CreationDate': '2014-04-14T14:52:04.890', 'Id': '23784''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Thanks to Yuval Filmus, I got to read <a href="http://theory.stanford.edu/~trevisan/cs261/lecture14.pdf" rel="nofollow">these lecture notes by Trevisan</a>. At the bottom half of Page 5, </p>\n\n<blockquote>\n  <p>The capacity of cut $S$ is the number of edges that go from $S$ to $\\overline{S}$, that is $\\text{Capacity}(S) = |L_2|+|R_1|+\\text{edges}(L_1, R_2)$.</p>\n</blockquote>\n\n<p>Here, $L_1 = S \\cap L$, $L_2 = L \\setminus S$, $R_1 = S \\cap R$ and $R_2 = R \\setminus S$. Furthermore, $L$ are the left edges and $R$ are the right edges.</p>\n\n<p>I don\'t understand how he arrived at the conclusion that</p>\n\n<blockquote>\n  <p>number of edges that go from $S$ to $\\overline{S} = |L_2|+|R_1|+\\text{edges}(L_1, R_2)$</p>\n</blockquote>\n\n<p>I don\'t understand the meaning of this expression. I drew it out on paper (highlighting all graph elements of the expression) and I still don\'t get it. Could somebody please explain to me how this expression is generated in simple and detailed terms?</p>\n', 'ViewCount': '15', 'Title': "The min cut capacity in a network based on a bipartite graph (Hall's Theorem)", 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-16T11:50:35.420', 'LastEditDate': '2014-04-16T08:33:57.210', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23855', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4748', 'Tags': '<graph-theory><bipartite-matching>', 'CreationDate': '2014-04-16T05:18:01.800', 'Id': '23843''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Could most categories , or a finite part of them be represented on a subset of a complete graph of N vertices (Kn) which is connected. and partly directed? Could all the axioms of category theory be written for such graphs?</p>\n', 'ViewCount': '41', 'Title': 'Category theory and graphs', 'LastActivityDate': '2014-04-17T02:12:37.420', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16843', 'Tags': '<graph-theory><category-theory>', 'CreationDate': '2014-04-17T01:52:59.513', 'Id': '23875''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I was reading a paper for recognizing interval graphs. Here is an excerpt from the paper:</p>\n\n<blockquote>\n  <p>Each interval graph has a corresponding interval model in which two intervals overlap if\n      and only if their corresponding vertices are adjacent. Such a representation is usually far\n      from unique. To eliminate uninteresting variations of the endpoint orderings, we shall\n      consider the following block structure of endpoints: Denote the right (resp. left) endpoint of\n      an interval $u$ by $R(u)$ (resp. $L(u)$). In an interval model, define a maximal contiguous set of\n      right (resp. left) endpoints as an R-block (resp. L-block). Thus, the endpoints can be grouped\n      as a left-right block sequence. Since an endpoint block is a set, the endpoint orderings within\n      a block are ignored. It is easy to see that the overlapping relationship does not change if one\n      permute the endpoint order within each block. Define two interval models for $G$ to be\n      equivalent if either their left-right block sequences are identical or one is the reversal of the\n      other. </p>\n</blockquote>\n\n<p>I am unable to understand the notion of equivalent intervals. Can someone help me?</p>\n', 'ViewCount': '37', 'Title': 'Recognizing interval graphs--"equivalent intervals"', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-18T06:40:51.167', 'LastEditDate': '2014-04-18T06:40:51.167', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23890', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11703', 'Tags': '<algorithms><graph-theory><graphs><intervals>', 'CreationDate': '2014-04-17T11:39:56.467', 'Id': '23885''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a problem in which I need to find an optimal graph cut that maximizes an objective over vertices (versus edge weights). I have looked at the literature but have not been able to find any similar problems to which I can map to. Perhaps someone can give some insight or point me to a similar problem from the graph theory literature.</p>\n\n<p>The problem is as follows, given a graph $G=(V,E)$, where there exists a path from any vertex $x_i$ to any other vertex $x_j$ (1 connected component) and each vertex has an associated weight $w_j$. Find a partition which removes $E_p$ edges $(E_p \\subset E)$ to create exactly $k$ connected components. The partition seeks to maximize a function over the $k$ subgraphs $\\sum\\limits_{i=1}^k f(W_i)$ where $W_i$ is the set of all weights on vertices in subgraph $i$. The $f$ I am specifically interested in is $f(W_i)=|W_i|\\,\\mathrm{mean}(W_i)^2 $, but I think any resources for a similar problem with a different $f$ would be helpful. </p>\n', 'ViewCount': '41', 'Title': 'Edge cuts with vertex weights', 'LastEditorUserId': '16985', 'LastActivityDate': '2014-04-23T08:03:23.563', 'LastEditDate': '2014-04-23T08:03:23.563', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16985', 'Tags': '<graph-theory><cluster><partition-problem>', 'CreationDate': '2014-04-22T12:27:06.003', 'FavoriteCount': '1', 'Id': '24026''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '39', 'Title': 'Concrete and simple applications for bipartite graphs', 'LastEditDate': '2014-04-23T19:27:43.003', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16536', 'Body': '<p>I am looking for concrete and simple problems that may be solved using bipartite graphs or bipartite graph properties. Any idea along with explanations are welcome.</p>\n', 'ClosedDate': '2014-04-24T17:37:00.217', 'Tags': '<graph-theory><graphs><bipartite-matching>', 'LastEditorUserId': '16536', 'LastActivityDate': '2014-04-24T17:03:52.407', 'CommentCount': '3', 'AcceptedAnswerId': '24083', 'CreationDate': '2014-04-23T19:20:35.893', 'Id': '24057''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I just read "Boole\'s Algebra Isn\'t Boolean Algebra" by Theodore Halperin (behind a paywall <a href="http://link.springer.com/chapter/10.1007/978-94-015-9385-4_4#page-1" rel="nofollow">here</a>). I don\'t have a strong background in abstract algebra, so, frankly, the paper is a bit over my head but the gist of it is as follows: the algebra developed by Boole in the 19th century has some strange properties. Boole interprets every term in an expression as representing a set and restricts the domain of valid expressions on the basis of relationships between the underlying sets. In particular, he asserts that the expression $x + y$ is valid iff $x$ and $y$ represent disjoint sets, and $x - y$ is valid iff the intersection of $x$ and $y$ is nonempty. He also defines an operation $w = \\frac x y$ such that $w$ has many solutions. Halperin goes to great lengths to construct a commutative ring that satisfies Boole\'s constraints. </p>\n\n<p>I think that there might be a nice, intuitive, graph-theoretic interpretation of Boole\'s algebra where we can say something like "Given a complex expression in Boole\'s algebra, $\\Phi = \\{\\phi_1, \\phi_2\\, \\dots, \\phi_n\\}$, we can construct a (di)graph $G$ such that $\\Phi$ is valid if and only if $G$ has some property $P$." </p>\n\n<p>For example, to test if $X + Y$ is valid, we could do something like the following:</p>\n\n<p>Let $G$ be a graph. Let $V(G) = X \\cup Y \\cup \\{v_X, v_Y\\}$, i.e. make a vertex for every element of the underlying set, plus a vertex for each term in the expression. Then define </p>\n\n<p>$$E(G) = \\{uv_X \\mid u \\in X \\} \\cup \\{uv_Y \\mid u \\in Y \\}$$</p>\n\n<p>and let $\\partial(G)$ be the set of all valid bonds formed by subsets of $V(G)$. It follows that $X + Y$ is valid if and only if $|\\partial(G)| = 2$. </p>\n\n<p>From there, I\'m not sure how to go about forming graphs for complex expressions like $\\frac {y(x + z)} {z^2 + 1}$ by composing simpler graphs. I imagine that there is literature about representing Boolean algebra on graphs, but I haven\'t been able to find it. </p>\n\n<p>Does anyone have an elegant interpretation? Or a pointer to relevant literature that might get me started?</p>\n\n<p>EDIT: I can\'t find the article for free anywhere, but <a href="http://en.wikipedia.org/wiki/The_Laws_of_Thought" rel="nofollow">wikipedia</a> touches on the issues: </p>\n\n<blockquote>\n  <p>In places, Boole talks of terms being interpreted by sets, but he also\n  recognises terms that cannot always be so interpreted, such as the\n  term 2AB...Such terms he classes uninterpretable\n  terms...uninterpretable terms cannot be the ultimate result of\n  equational manipulations from meaningful starting formulae.</p>\n</blockquote>\n\n<p>Halperin\'s paper shows that his algebra is isomorphic to "a commutative ring with unit having no additive or multiplicative nilpotents." I think, for that reason, that it will require heavier machinery to represent than normal Boolean logic operations.</p>\n', 'ViewCount': '42', 'Title': "Finding a graph-theoretic representation of expressions in Boole's algebra", 'LastEditorUserId': '16612', 'LastActivityDate': '2014-04-25T19:14:45.803', 'LastEditDate': '2014-04-25T19:14:45.803', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16612', 'Tags': '<graph-theory><logic><boolean-algebra>', 'CreationDate': '2014-04-24T20:14:30.220', 'FavoriteCount': '1', 'Id': '24088''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a set of nodes S where all the nodes of an arbitrary integer value.  I Also have a set of pairs of nodes from S, indicating that those node cannot be in the same subset.  Given a subset of S, how can I determine the largest possible Sum of that subset taking into account the exclusion pairs.</p>\n\n<p>Example:</p>\n\n<p>S = (x1:50, x2:20, x3:30, x4:15, x5:70)</p>\n\n<p>Exclusion = {(x1,x2), (x4,x5), (x2,x4)}</p>\n\n<p>Starting set = (x1,x2,x4,x5)</p>\n\n<p>Best Possible Sum = (x1,x5)</p>\n', 'ViewCount': '38', 'Title': 'Maximizing the Sum of a Subset with Excluding pairs', 'LastActivityDate': '2014-04-25T14:23:58.780', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24105', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17076', 'Tags': '<graph-theory><sets>', 'CreationDate': '2014-04-25T14:05:57.740', 'Id': '24103''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to find a graph that does not get optimally colored by the Briggs coloring algoritm. Any suggestions on a type of graph to look for?</p>\n', 'ViewCount': '18', 'ClosedDate': '2014-04-29T22:38:59.250', 'Title': 'Briggs algorithm non optimal situation', 'LastActivityDate': '2014-04-25T16:11:04.377', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17080', 'Tags': '<algorithms><graph-theory><graphs><colorings>', 'CreationDate': '2014-04-25T16:11:04.377', 'Id': '24110''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am working on a solving a graph partitioning problem and have found a way to formulate it as a trace minimization. I am hoping this will allow me to relax the problem to a continuous one. I am wondering if someone is familiar with any similar trace minimization problem or can help reformulate my constraints such that they fit a trace minimization problem.</p>\n\n<p>The initial problem is as follows. Given an undirected connected graph $G=(V,E)$ partition the nodes in the graph into 2 connected components denoted $S$ and $\\bar S$ to maximize $\\frac{(\\sum\\limits_{i \\in S} w_i)^2}{|S|}+\\frac{(\\sum\\limits_{i \\in \\bar S} w_i)^2}{ |\\bar S|}$</p>\n\n<p>I have mapped this problem into the following trace optimization problem.</p>\n\n<p>Let $x,y \\in\\{0,1\\}^n$,$x=\\mathbf{1}-y$. Here the set $S=\\{i:x_i=1\\}$ . We define  $X=[\\alpha x \\ \\beta y]$ for $\\alpha=\\frac{1}{\\sqrt{x'x}}$ and $\\beta=\\frac{1}{\\sqrt{y'y}}$ . $A$ is the adjacency matrix of the undirected graph $G$. Finally $W=ww'$ where $w_i$ is the weight of vertex $i$. We seek</p>\n\n<p>$\\max \\limits_{X'X=I, (A-I)X \\geq 0} trace(X'WX)$</p>\n\n<p>For the case of a complete graph I have been able to show that this maps to an NP-hard problem, but for sparse graphs I am not sure if it is NP-hard, although I suspect that it is and hope a continuous relaxation might give an approximation. Is anyone familiar with any similar optimization problems? Given the 2 constraints if I can rewrite them in the form of $X'BX=I$ then this would be a well known trace minimization. Any ideas would be helpful.</p>\n", 'ViewCount': '76', 'Title': 'Graph partitioning problem', 'LastEditorUserId': '16985', 'LastActivityDate': '2014-04-28T16:00:54.943', 'LastEditDate': '2014-04-28T16:00:54.943', 'AnswerCount': '0', 'CommentCount': '13', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16985', 'Tags': '<graph-theory><optimization><adjacency-matrix>', 'CreationDate': '2014-04-26T12:01:33.800', 'Id': '24127''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Let $G$ be a graph of diameter 2 ($\\forall u,v\\in V: d(u,v)\\leq2$).</p>\n\n<blockquote>\n  <p><strong>Can we decide if $G$ has Hamiltonian path in poly time? What about digraphs?</strong></p>\n</blockquote>\n\n<hr>\n\n<p>Perhaps some motivation is in place:</p>\n\n<p>the question arises from Dirac\'s theorem which states that if $\\forall v\\in V:d(v)\\geq \\frac{n}{2}$ then the graph is Hamiltonian, as well as it\'s generalizations (the Ghouila-Houri theorem and the result from Bang-Jensen and Gutin\'s book).</p>\n\n<p><a href="http://cstheory.stackexchange.com/questions/22247/does-deltag-delta-g-geq-n-imply-strong-connectivity/22299#22299">I\'ve shown here</a> that these degree requirements imply that the graph has diameter 2, and was wondering if such graphs can be decided without the degree requirements (strong gut feeling: No).</p>\n', 'ViewCount': '72', 'Title': 'Is Hamiltonian path NP-hard on graphs of diameter 2?', 'LastEditorUserId': '12969', 'LastActivityDate': '2014-04-28T11:16:29.733', 'LastEditDate': '2014-04-28T11:16:29.733', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12969', 'Tags': '<graph-theory><graphs><np-complete><hamiltonian-path>', 'CreationDate': '2014-04-27T22:41:46.630', 'Id': '24159''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am working on acyclic orientations of undirected graphs and have the following questions: </p>\n\n<ol>\n<li>Given connected undirected simple graph $G$, how to find all possible acyclic orientations of $G$ ? </li>\n<li>What is the number of acyclic orientations? \nIt is known (from <a href="http://math.mit.edu/~rstan/pubs/pubfiles/18.pdf">here</a>) to be $(-1)^p\\ \\chi(G,-\\lambda)$ for a graph $G$ with $p$ vertices where $\\chi$ is the chromatic polynomial evaluated at $-\\lambda$; but I wasn\'t successful in understanding how to evaluate $\\chi$ at a negative value ($-\\lambda$).  </li>\n</ol>\n', 'ViewCount': '62', 'Title': 'Algorithm to find all acyclic orientations of a graph', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-28T17:24:29.400', 'LastEditDate': '2014-04-28T03:02:59.220', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<algorithms><graph-theory><counting>', 'CreationDate': '2014-04-28T02:49:32.510', 'Id': '24171''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '26', 'Title': 'Given a complete, weighted and undirected graph $G$, complexity of finding a path with a specific cost', 'LastEditDate': '2014-04-29T18:42:14.217', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17185', 'FavoriteCount': '1', 'Body': '<p>Given a fully connected graph $G$, suppose that we are searching for a simple path $P$ with a specific cost $c$. </p>\n\n<p>Is answering to that problem <em>yes</em> or <em>no</em> equivalent to subset-sum problem?\nWhat would be the complexity of finding such path?</p>\n\n<p>I have made a reduction from subset-sum problem:</p>\n\n<p>If each number in a set $S$ is a vertex of $G$ and weight of $&lt;i,j&gt;$ is $|i-j|$, then answering the question above <em>yes</em> or <em>no</em> is the same as solving the sumbet-sum problem.</p>\n\n<p>P.S. The initial vertex I have visited is added to the cost.</p>\n\n<p><strong>Edit: Edge weights</strong></p>\n', 'Tags': '<algorithms><graph-theory><graphs><decision-problem>', 'LastEditorUserId': '17185', 'LastActivityDate': '2014-04-29T20:37:29.247', 'CommentCount': '4', 'AcceptedAnswerId': '24233', 'CreationDate': '2014-04-29T17:40:06.137', 'Id': '24231''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Can anyone provide an example of an ordered graph for which the following algorithm produces the the incorrect longest path?</p>\n\n<pre><code>let A = V[1]\nlongestPath = 0\n\nwhile there is an edge out of A do\n     choose edge (A,V[i]) for which i is as small as possible\n     set A = V[i]\n     LongestPath = LongestPath + 1\nend while\nreturn longestPath\n</code></pre>\n\n<p>Thanks for the comments. I've tried several examples but I dont see why this algorithm would not work</p>\n\n<p>If we start with a small 3 node graph with nodes A,B,C. If node A has an edge that goes to B and and edge that goes to C, And B has one edge that goes to C. Then starting with node A we would take the shortest path per the algorithm and go to node b. From node b we would go to node c and the algorithm works.</p>\n", 'ViewCount': '28', 'ClosedDate': '2014-05-01T02:46:10.497', 'Title': 'Longest path of a directed ordered graph', 'LastEditorUserId': '15850', 'LastActivityDate': '2014-05-01T03:14:35.177', 'LastEditDate': '2014-05-01T03:14:35.177', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15850', 'Tags': '<algorithms><graph-theory><graphs>', 'CreationDate': '2014-05-01T00:36:13.987', 'Id': '24278''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm studying for my finals in algorithms and reading the part about flow networks. There's a certain section that has me completely stumped and it is as follows:</p>\n\n<blockquote>\n  <p>Given a graph $G= \\langle V_G, E_G \\rangle$, we can construct the $H(G)=\\langle V_H, E_H\\rangle$ as follows:\n  $$V_H = V_G\\times\\{0,1\\}E_H = \\{((v,0),(v,1))|v\\in V_G\\}\\cup\\{((x,1),(y,0))|(x,y)\\in E_G\\}.$$\n  Say that we have a graph $\\langle G,u,v\\rangle$ where $G$ is some directed graph, which contains vertices $u$ and $v$ then $H(G)$ can be used to find the smallest number of nodes that must be removed from $G$ to separate $u$ to $v$, meaning there will be no simple path from $u$ to $v$.</p>\n</blockquote>\n\n<p>I really don't understand what's going on here, partly because I can't visualise $H(G)$. I assume we'd get some bipartite graph and maybe apply Edmonds-Karp only because the flow networks sections is succinct and there's not much else in this chapter. Could someone tell/show me what $H(G)$ is doing exactly and why this result is true. Much appreciated.</p>\n", 'ViewCount': '65', 'Title': "Don't understand this graph definition", 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T21:53:50.963', 'LastEditDate': '2014-05-02T21:53:50.963', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15826', 'Tags': '<graph-theory><terminology><network-flow>', 'CreationDate': '2014-05-01T14:30:30.687', 'Id': '24295''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u"<p>A phone company provides service on 7 frequencies. They want to establish their business in your area and and have fixed locations for 100 towers. The company has to ensure that two towers broadcasting on the same frequency are atleast 100km apart, so that there is no interference of signals.</p>\n\n<ol>\n<li><p>Model this using graphs.</p></li>\n<li><p>Describe an algorithm which will answer the question \u201cIs it feasible to set up\ntowers at the given locations and provide service on 7 different frequencies?\u201d. Your algorithm should say \u201cfeasible\u201d if it is feasible, otherwise output the minimum number of frequencies needed to utilise all 100 towers.</p></li>\n</ol>\n\n<p><strong>My Solution</strong></p>\n\n<ol>\n<li><p>I think this can be modeled as a graph coloring problem. If the locations of 100 towers are given, then draw a graph such that each tower is represented as a vertex and draw an edge between two vertices if the distance between the respective towers is less than 100km. Coloring this graph using 7 colors would be equivalent to alloting the 7 frequencies.</p></li>\n<li><p>This can be an algorithm to find the max-clique in the graph and if the order of the max-clique is greater than 7, print that, else say it's feasible.</p></li>\n</ol>\n\n<p>Are there better/more intutive ways of modeling this problem?</p>\n", 'ViewCount': '28', 'ClosedDate': '2014-05-03T02:01:59.983', 'Title': 'Model this problem using graphs', 'LastActivityDate': '2014-05-01T19:32:44.073', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17260', 'Tags': '<graph-theory>', 'CreationDate': '2014-05-01T19:32:44.073', 'Id': '24301''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am faced with this question.</p>\n\n<blockquote>\n  <p>Let $G$ be a graph in which each vertex has degree at least $k$. Show\n  that there is a path of length $k$ in $G$ - that is, a sequence of $k+1$ distinct vertices $v_0, v_1, ..., v_k$ such that for $0 \u2264 i &lt; k$, $v_i$ is connected to $v_{i+1}$ in $G$.</p>\n</blockquote>\n\n<p>I started attacking it this way:</p>\n\n<p>If $G$ has a vertex of degree atleast $k$, it has atleast $k+1$ vertices. That is, $G$ can have $|v| \\geq k+1$</p>\n\n<p>In the case where $|v| = k+1$, the graph is a fully connected graph of $k+1$ vertices, which trivially has a path of length $k+1$.</p>\n\n<p>I am not able to prove the cases where $|v| \\geq k+2$</p>\n\n<p>Note: This is not a homework question, but something I am trying to sovle from an old examination paper (<a href="http://www.cmi.ac.in/admissions/sample-qp/pgcs2010.pdf" rel="nofollow">here</a>) as a practice. I don\'t have the solutions to it.</p>\n', 'ViewCount': '21', 'Title': 'Prove that there is a path of lenght k+1 in a graph with minimum degree k', 'LastEditorUserId': '17260', 'LastActivityDate': '2014-05-01T20:55:22.980', 'LastEditDate': '2014-05-01T20:55:22.980', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17260', 'Tags': '<graph-theory>', 'CreationDate': '2014-05-01T20:05:17.577', 'FavoriteCount': '1', 'Id': '24303''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am looking for a way to enumerate all the possible paths between a source and one or more sinks in a directed graph, with loops.  Also, some edges must enforce a maximum number of traversals (n), so that if an entity passing through the graph has already traversed the edge n times it cannot traverse it again.</p>\n\n<p>Also, entities are able to split into multiple sub-entities, and merge again later, though each sub-entity is also able to traverse loops.</p>\n\n<p>My current approach is to just simulate the flow of an entity through the graph, since each edge at a split does have an assigned probability.  With a large enough sample I know I can trace the most likely paths for traversing the graph by finding all unique paths taken by simulated entities.</p>\n\n<p>I do not know if there is already a theoretical solution to this problem, or where I might start looking for such an answer.</p>\n\n<p>Is this a well-known, solved problem?  What technical terms would I use to research this problem?</p>\n', 'ViewCount': '11', 'Title': 'Enumerating all paths through directed graph with loops and splits', 'LastActivityDate': '2014-05-02T23:46:27.130', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17285', 'Tags': '<graph-theory>', 'CreationDate': '2014-05-02T23:46:27.130', 'Id': '24330''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I want to develop one algorithm which can predict shortest time to be taken to go to a destination from a source in a road network based on traffic congestion data. \nConsider that I have a server which gives me real time traffic congestion data for all the path segments in a road network. Now I want to develop such an algorithm which can predict time to be taken based on these data. So in short: </p>\n\n<p>time_to_be_taken_from_source_to_destination = function ( traffic_congestion_data ). And 'time_to_be_taken_from_source_to_destination' is proportional to 'traffic_congestion_data' as time increases when traffic_congestion increases.</p>\n\n<p>Are there any such algorithm alraedy developed? Any idea? reference to any algorithm or theory will be appreciated. </p>\n", 'ViewCount': '10', 'Title': 'shortest time based on traffic congestion data', 'LastActivityDate': '2014-05-03T22:11:25.087', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16563', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2014-05-03T05:47:16.070', 'Id': '24341''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I know Distributed Graph Coloring algorithm in O(log* n)\nwhich is given at P11: <a href="http://dcg.ethz.ch/lectures/podc_allstars/lecture/chapter1.pdf" rel="nofollow">Vertex Coloring</a></p>\n\n<p>same for Maximal Independent Set [MIS] they gave remark like algorithms exist in O(log* n) time at P70: <a href="http://dcg.ethz.ch/lectures/podc_allstars/lecture/chapter7.pdf" rel="nofollow">Maximal Independetn Set</a></p>\n\n<p>How we can reduce Graph coloring problem to MIS in O(log* n) time?</p>\n\n<p>If you feel difficulty in understanding algorithm then please comment. </p>\n', 'ViewCount': '11', 'Title': 'MIS algorithm for Tree in O(log* n) time', 'LastActivityDate': '2014-05-04T02:29:39.507', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9665', 'Tags': '<algorithms><graph-theory><data-structures><distributed-systems>', 'CreationDate': '2014-05-03T22:14:11.747', 'Id': '24369''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}