{'Body': "<p>I'd like to start by stating this isn't homework! I'm studying for a job interview and would appreciate a second opinion. (Well, I guess it is homework, but not for school!).</p>\n\n<p>I've written an algorithm (see pseudocode below) to merge two <em>sorted</em> lists into one sorted list. The problem requires that I implement it as a recursive divide-and-conquer algorithm. My algorithm is recursive and works <em>but does it count as divide-and-conquer</em>?</p>\n\n<p>The reason I'm asking is that the other people working on the same problem insist D&amp;C must divide the lists in half every time and have $O(n \\log n)$ complexity, like quicksort and mergesort. My algorithm doesn't divide the lists in the middle and has a complexity of $O(n+m)$ (where $n$ and $m$ are the lengths of the lists).</p>\n\n<p>To summarize my question: <strong>Does a D&amp;C algorithm have to have $O(n \\log n)$ complexity and divide the problem in half every time? Or does this algorithm count as D&amp;C?</strong></p>\n\n<pre><code>merge_sorted_lists(list1, list2)\n    if(list1 and list2 are empty)\n        return empty list\n\n    if(list1 is empty)\n        return list2\n\n    else if(list2 is empty)\n        return list1\n\n    else if(head of list1 &lt; head of list2)\n        smaller = pop head of list1\n\n    else if(head of list2 &lt; head of list1)\n        smaller = pop head of list2\n\n    return smaller + merge_sorted_lists(list1, list2)\n</code></pre>\n\n<p>P.S. I've implemented the algorithm in Java and it works.</p>\n", 'ViewCount': '239', 'Title': 'Is this a divide-and-conquer algorithm?', 'LastEditorUserId': '7007', 'LastActivityDate': '2013-03-17T03:43:34.093', 'LastEditDate': '2013-03-14T15:12:38.100', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '10520', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7007', 'Tags': '<algorithms><terminology><divide-and-conquer>', 'CreationDate': '2013-03-14T06:33:28.713', 'Id': '10518'}{'Body': u'<p>You\u2019re doing some stress-testing on various models of glass jars to determine the height from which they can be dropped and still not break. The setup for this experiment, on a particular type of jar, is as follows. You have a ladder with $n$ rungs, and you want to find the highest rung from which you can drop a copy of the jar and not have it break. We call this the highest safe rung.\nIt might be natural to try binary search: drop a jar from the middle rung, see if it breaks, and then recursively try from rung $n/4$ or $3n/4$ depending on the outcome. But this has the drawback that you could break a lot of jars in finding the answer.</p>\n\n<p>If your primary goal were to conserve jars, on the other hand, you could try the following strategy. Start by dropping a jar from the first rung, then the second rung, and so forth, climbing one higher each time until the jar breaks. In this way, you only need a single jar\u2014at the moment it breaks, you have the correct answer\u2014but you may have to drop it $n$ times (rather than $\\log n$ as in the binary search solution).</p>\n\n<p>So here is the trade-off: it seems you can perform fewer drops if you\u2019re willing to break more jars. To understand better how this trade- off works at a quantitative level, let\u2019s consider how to run this experiment given a fixed \u201cbudget\u201d of $k \\ge 1$ jars. In other words, you have to determine the correct answer\u2014the highest safe rung\u2014and can use at most $k$ jars in doing so.</p>\n\n<p>Suppose you are given a budget of $k = 2$ jars. Describe a strategy for finding the highest safe rung that requires you to drop a jar at most $f (n)$ times, for some function $f (n)$ that grows slower than linearly. (In other words, it should be the case that $\\lim_{n\\to\\infty} f (n)/n = 0$.)</p>\n\n<p>Anyone any insights how to solve this problem?</p>\n\n<p>I know that the answer is $h = \\sqrt n$. I know  that it solves the problem. But I want to know how you got that answer, there must be a general way to do it?</p>\n', 'ViewCount': '672', 'Title': 'Balancing subproblems in resilience testing', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-11T01:48:19.290', 'LastEditDate': '2013-08-01T07:17:26.863', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'user75300', 'PostTypeId': '1', 'OwnerUserId': '8086', 'Tags': '<algorithms><binary-trees><decision-problem><divide-and-conquer>', 'CreationDate': '2013-05-07T21:28:25.053', 'Id': '11981'}{'Body': '<p><img src="http://i.stack.imgur.com/oAsDp.jpg" alt="enter image description here"></p>\n\n<p>I\'m thinking of using something similar to the Merge Sort algorithm. So the recurrence running time of Merge Sort is T(n) = 2T(n/2) + n. What should I do about if n/2 is less than or equal to m, OR if n/2 is greater than or equal to m?</p>\n\n<p>I believe the given function should be location inside the "Merge" function of the Merge Sort.(Since we\'re merging a sorted array) Thank you for your time.</p>\n\n<p>Edited: \nI\'m thinking if n/2 is less than or equal to m, use the "Given" function . Otherwise use the original "Merge" function (The usual Merge for Merge Sort) </p>\n', 'ViewCount': '41', 'Title': 'Constructing a Divide and Conquer Algorithm', 'LastEditorUserId': '4884', 'LastActivityDate': '2013-06-10T03:39:17.973', 'LastEditDate': '2013-06-09T06:05:06.720', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4884', 'Tags': '<sorting><arrays><divide-and-conquer>', 'CreationDate': '2013-06-09T05:57:31.027', 'Id': '12555'}{'Body': "<p>I met the problem </p>\n\n<blockquote>\n  <p>Show that the solution to $T(n) = 2T(\\lfloor n/2\\rfloor + 17) + n$ is $O(n \\log n)$</p>\n</blockquote>\n\n<p>while reading Introduction to Algorithm. It's a question about the substitution method for solving recurrences.</p>\n\n<p>Should I just assume $T(n/2 + 17) \\leq O((n/2 + 17) \\log(n/2 + 17))$ and then prove $T(n) \\leq O(n \\log n)$? Is this inductive assumption enough to solve it?</p>\n", 'ViewCount': '122', 'ClosedDate': '2013-09-16T08:55:38.767', 'Title': 'How to prove the asymptotic upper bound for $T(n) = 2T(\\lfloor n/2\\rfloor + 17) + n$ is $O(n \\log n)$?', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-06-27T18:45:56.293', 'LastEditDate': '2013-06-27T18:45:56.293', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8838', 'Tags': '<asymptotics><recurrence-relation><induction><divide-and-conquer>', 'CreationDate': '2013-06-24T14:43:28.910', 'Id': '12865'}{'Body': "<p>How to find the smallest difference between two numbers in a sorted list using divide-and-conquer approach? For example,</p>\n\n<pre><code>   (smallest-dif '(5 500 510 670 750 10000)) =&gt; 10\n</code></pre>\n", 'ViewCount': '135', 'Title': 'Finding the difference between two number in a sorted list using divide-and-conquer', 'LastActivityDate': '2013-07-03T07:59:38.970', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '8983', 'Tags': '<encoding-scheme><divide-and-conquer>', 'CreationDate': '2013-07-03T05:53:57.913', 'Id': '13045'}{'Body': '<p>When it comes to the design of algorithms, one often employs the following techniques:</p>\n\n<ul>\n<li>Dynamic Programming</li>\n<li>The Greedy-Strategy</li>\n<li>Divide-and-Conquer</li>\n</ul>\n\n<p>While for the first two methods, there are well-known theoretical foundations, namely the Bellman Optimality Principle and matroid (resp. greedoid) theory, I could not find such a general framework for algorithms based on D&amp;C. </p>\n\n<p>Firstly, I am aware of something that we (or rather, the prof) introduced  in a functional programming class,  called an "algorithmic skeleton", that arose in the context of combinators. As an example hereof, we gave such a skeleton for D&amp;C algorithms as follows: </p>\n\n<p><strong>Definition</strong>: Let $A,S$ be non-empty sets. We call the elements of $S$ <em>solutions</em>, and the elements of $P:=\\mathfrak{P}(A)$ (that is, the subsets of $A$) are referred to as <em>problems</em>.\nThen, a <em>D&amp;C-skeleton</em> is a 4-tuple $(P_\\beta, \\beta, \\mathcal{D}, \\mathcal{C})$, where: </p>\n\n<ul>\n<li>$P_\\beta$ is a predicate over the set of problems and we say that a problem $p$ is <em>basic</em> iff $P_\\beta(p)$ holds.</li>\n<li>$\\beta$ is a mapping $P_\\beta \\rightarrow S$ that assigns a solution to each basic problem. </li>\n<li>$\\mathcal{D}$ is a mapping  $P \\rightarrow \\mathfrak{P}(P)$ that divides each problem into a set of subproblems.</li>\n<li>$\\mathcal{C}$ is a mapping $P\\times \\mathfrak{P}(S) \\rightarrow S$ that joins the solutions (depending on kind of a "pivot problem") of the subproblems to produce a solution. </li>\n</ul>\n\n<p>Then, for a given skeleton $s=(P_\\beta, \\beta, \\mathcal{D}, \\mathcal{C})$ and a problem $p$, the following generic function $f_s: P\\rightarrow S$ computes a solution (in the formal sense) for $p$:</p>\n\n<p>$f_s(p)= \\left\\{\n  \\begin{array}{l l}\n    \\beta(p) &amp; \\quad \\text{if $p$ is basic}\\\\\n    \\mathcal{C}(p,f(\\mathcal{D}(p))) &amp; \\quad \\text{otherwise}\n  \\end{array} \\right.$</p>\n\n<p>where in the second line we use the notation $f(X) := \\{f(x)  : x\\in X\\}$ for subsets $X$ of the codomain of a mapping $f$.</p>\n\n<p>However, we did not further examine the underlying, "structural" properties of problems that can be formulated this way (as I said, it was a functional programming class and this was only a small example). Unfortunately, I could not find further reference on this very approach. Hence I don\'t think the above definitions are quite standard. If someone recognizes what I have stated above, I would be glad about related articles.</p>\n\n<p>Secondly, for the greedy strategy we have the famous result that a problem is correctly solved by the general greedy algorithm if and only if its solutions constitute a weighted matroid. Are there similar results for D&amp;C-algorithms (not necessarily based on the method outlined above)?</p>\n', 'ViewCount': '355', 'Title': 'Theoretical foundations of Divide and Conquer', 'LastActivityDate': '2014-01-27T13:03:11.173', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '20011', 'Score': '17', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<algorithms><reference-request><divide-and-conquer>', 'CreationDate': '2013-08-29T16:27:18.153', 'FavoriteCount': '4', 'Id': '14022'}{'Body': '<p>I have to create an algorithm for homework, but cant figure out where to start. </p>\n\n<p>The divide and conquer algorithm muse be O(nlgn) and returns a pair of numbers <em>p</em> and <em>q</em> in an array <em>A</em>. <em>p</em> must appear before <em>q</em> in the array, and <em>q-p</em> must be the highest possible value</p>\n\n<p>heres and example I made up:</p>\n\n<p>A=[1,4,12,5,9,1,3,8]</p>\n\n<p>the return values would be <em>p=1</em> &amp; <em>q=12</em></p>\n', 'ViewCount': '100', 'Title': 'create divide and conquer algorithm', 'LastEditorUserId': '6665', 'LastActivityDate': '2013-09-29T15:10:53.533', 'LastEditDate': '2013-09-29T15:10:53.533', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '14668', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10387', 'Tags': '<algorithms><divide-and-conquer>', 'CreationDate': '2013-09-28T23:21:10.377', 'Id': '14665'}{'Body': "<p>Say you have two polynomials: $3 + x$ and $2x^2 + 2$.</p>\n\n<p>I'm trying to understand how FFT helps us multiply these two polynomials. However, I can't find any worked out examples. Can someone show me how FFT algorithm would multiply these two polynomials. (Note: there is nothing special about these polynomials, but I wanted to keep it simple to make it easier to follow.) </p>\n\n<p>I've looked at the algorithms in pseudocode, but all of them seem to be have problems (don't specify what the input should be, undefined variables). And surprisingly, I can't find where anyone has actually walked through (by hand) an example of multiplying polynomials using FFT.</p>\n", 'ViewCount': '464', 'Title': 'Show how to do FFT by hand', 'LastActivityDate': '2013-10-21T01:34:40.843', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16272', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '10599', 'Tags': '<algorithms><fourier-transform><divide-and-conquer>', 'CreationDate': '2013-10-20T19:59:33.633', 'Id': '16266'}{'Body': "<p>I need to evaluate a polynomial of degree n at the n cube roots of unity. Simple evaluation would take $O(n^2)$ time. I know that polynomial evaluation can be done in $O(n\\log n)$ time using FFT.</p>\n\n<p>But the problem that I am facing is this. FFT only works when $n$ is a power of 2. If I extend my polynomial by appending zeroes at the end, that would not solve my problem because then I would be evaluating my polynomial at cube roots of $m$ (where $m$ is a power of $2$ greater than $n$) which I don't want.</p>\n\n<p>Any ideas on this?</p>\n", 'ViewCount': '40', 'Title': 'Discrete fourier transform of a polynomial whose degree is not a power of 2', 'LastEditorUserId': '683', 'LastActivityDate': '2013-12-11T07:55:55.970', 'LastEditDate': '2013-12-11T07:55:55.970', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11899', 'Tags': '<algorithms><divide-and-conquer><polynomials>', 'CreationDate': '2013-12-07T09:42:01.607', 'Id': '18710'}{'Body': '<p>I am trying to wrap my head around recursion and divide and conquer algorithms. Can someone provide a proof and explanation of how many times a list of n elements can be divided in 1/2 on both sides.. In other words the total number of half divisions in a recursive divide procedure on a list of size n. </p>\n', 'ViewCount': '59', 'ClosedDate': '2014-03-27T08:00:03.037', 'Title': 'How many times can you divide a list of n elements in 1/2', 'LastActivityDate': '2014-03-15T22:31:08.997', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '22660', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14847', 'Tags': '<recurrence-relation><recursion><divide-and-conquer>', 'CreationDate': '2014-03-15T19:25:02.470', 'Id': '22656'}{'Body': u'<p>Please consider the following Divide-And-Conquer Problem:</p>\n\n<blockquote>\n  <p>You\u2019re consulting for a small computation-intensive investment\n  company, and they have the following type of problem that they want to\n  solve over and over. A typical instance of the problem is the\n  following. They\u2019re doing a simulation in which they look at n\n  consecutive days of a given stock, at some point in the past. Let\u2019s\n  number the days i=1,2,...,n; for each day i, they have a price p(i)\n  per share for the stock on that day. (We\u2019ll assume for simplicity that\n  the price was fixed during each day.) Suppose during this time period,\n  they wanted to buy 1,000 shares on some day and sell all these shares\n  on some (later) day. They want to know: When should they have bought\n  and when should they have sold in order to have made as much money as\n  possible? (If there was no way to make money during the n days, you\n  should report this instead.)</p>\n</blockquote>\n\n<p>There already is a <a href="http://cs.stackexchange.com/questions/10050/confusion-related-to-a-divide-and-conquer-problem">discussion about the same problem</a>, but I don\'t understand why they try to make it that complicated. I think the following Algorithm will yield the result they ask for:</p>\n\n<pre><code>DivideAndConquer(1,..,n)\n(i1,j1) := DivideAndConquer(1,..,n/2)\n(i2,j2) := DivideAndConquer(n/2 + 1,..,n)\nreturn (min(p(i1),pi2),max(p(j1),p(j2)))\n</code></pre>\n\n<p>Even if they ask for the range, we can get it from <code>(i,j) := DivideAndConquer(1,..,n)</code> by <code>j-i</code>. So, what am I missing?</p>\n\n<p>PS: I don\'t see the point of using a DivideAndConquer approch at all. Why not sorting the input twice. Once in ascending and once in descending order induced by <code>p(i)</code>.</p>\n\n<p>EDIT: According to the explanation of Yuval Filmus, the algorithm should look like the following:</p>\n\n<pre><code>DivideAndConquer(1,..,n)\n(i1,j1) := DivideAndConquer(1,..,n/2)\n(i2,j2) := DivideAndConquer(n/2 + 1,..,n)\nLet p(i) be minimal in 1,..,n/2\nLet p(j) be maximal in n/2 + 1,..,n\nreturn (i,j)\n</code></pre>\n', 'ViewCount': '31', 'Title': 'Just another Divide-And-Conquer question - but somehow different', 'LastEditorUserId': '12502', 'LastActivityDate': '2014-04-28T19:03:31.463', 'LastEditDate': '2014-04-28T19:03:31.463', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12502', 'Tags': '<algorithms><algorithm-analysis><divide-and-conquer>', 'CreationDate': '2014-04-28T18:15:22.217', 'Id': '24195'}