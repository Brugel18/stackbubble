{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '319', 'Title': "Does the 'difference' operation add expressiveness to a query language that already includes 'join'?", 'LastEditDate': '2012-04-02T15:35:05.827', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '5', 'FavoriteCount': '1', 'Body': '<p>The set difference operator (e.g., <code>EXCEPT</code> in some SQL variants) is one of the many fundamental operators of relational algebra. However, there are some databases that do not support the set difference operator directly, but which support <code>LEFT JOIN</code> (a kind of outer join), and in practice this can be used instead of a set difference operation to achieve the same effect.</p>\n\n<p>Does this mean that the expressive power of a query language is the same even without the set difference operator, so long as the <code>LEFT JOIN</code> operator is maintained? How would one prove this fact?</p>\n', 'Tags': '<database-theory><relational-algebra><finite-model-theory>', 'LastEditorUserId': '69', 'LastActivityDate': '2013-05-29T00:50:34.590', 'CommentCount': '1', 'AcceptedAnswerId': '28', 'CreationDate': '2012-03-06T19:06:05.667', 'Id': '2'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>According to <a href="http://books.google.ca/books?id=kWSZ0OWnupkC&amp;pg=PA224#v=onepage&amp;q&amp;f=false">Immerman</a>, the complexity class associated with <a href="http://en.wikipedia.org/wiki/SQL">SQL</a> queries is exactly the class of <em>safe queries</em> in $\\mathsf{Q(FO(COUNT))}$ (first-order queries plus counting operator): SQL captures safe queries. (In other words, all SQL queries have a complexity in $\\mathsf{Q(FO(COUNT))}$, and all problems in $\\mathsf{Q(FO(COUNT))}$ can be expressed as an SQL query.)</p>\n\n<p>Based on this result, from theoretical point of view, there are many interesting problems that can be solved efficiently but are not expressible in SQL. Therefore an extension of SQL which is still efficient seems interesting. So here is my question:</p>\n\n<blockquote>\n  <p>Is there an <strong>extension of SQL</strong> (implemented and <strong>used in the industry</strong>) which <strong>captures $\\mathsf{P}$</strong> (i.e. can express all polynomial-time computable queries and no others)?</p>\n</blockquote>\n\n<p>I want a database query language which stisfies all three conditions. It is easy to define an extension which would extend SQL and will capture $\\mathsf{P}$. But my questions is if such a language makes sense from the practical perspective, so I want a language that is being used in practice. If this is not the case and there is no such language, then I would like to know if there is a reason that makes such a language uninteresting from the practical viewpoint? For example, are the queries that rise in practice usually simple enough that there is no need for such a language?</p>\n', 'ViewCount': '234', 'Title': 'Extension of SQL capturing $\\mathsf{P}$', 'LastEditorUserId': '41', 'LastActivityDate': '2013-04-27T15:07:01.660', 'LastEditDate': '2012-03-12T21:56:17.563', 'AnswerCount': '3', 'CommentCount': '17', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<database-theory><complexity-theory><finite-model-theory><descriptive-complexity>', 'CreationDate': '2012-03-08T16:08:50.840', 'Id': '135'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose $\\sigma$ is a vocabulary of First Order logic consisting of one binary relation $E$ and let $\\phi$ be a $\\sigma$ sentence (FO formula with no free variables). Is it decidable whether there is a finite directed graph $G$, with all in- and out-degrees $0$ or $1$, such that $G\\models \\phi$ ?</p>\n', 'ViewCount': '114', 'Title': 'Decidability over finite graphs of small degree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-14T15:24:32.167', 'LastEditDate': '2013-03-14T15:24:32.167', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<graphs><logic><undecidability><first-order-logic><finite-model-theory>', 'CreationDate': '2013-03-13T10:55:07.910', 'Id': '10509'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the proof of Trakhtenbrot\'s theorem (as given in "Elements of Finite Model Theory" by Leonid Libkin), for every Turing machine $M$, author constructs a FO sentence $\\Phi_M$ of vocabulary $\\sigma$ such that $\\Phi_M$ is finitely satisfiable iff $M$ halts on the empty input. Then he says that as the latter is known to be undecidable so the theorem holds.</p>\n\n<p>My doubt is, the vocabulary $\\sigma$ that was constructed depends on the Turing Machine $M$. But the theorem holds for any relational vocabulary with at least one binary relation symbol and also it should not depend on the machine $M$. Perhaps the claim of author is enough to imply the theorem for arbitrary vocabulary, but I am unable to see how.</p>\n', 'ViewCount': '161', 'Title': "Proof of Trakhtenbrot's theorem", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T09:57:57.300', 'LastEditDate': '2013-04-15T09:54:06.163', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<turing-machines><logic><reductions><undecidability><finite-model-theory>', 'CreationDate': '2013-04-15T08:38:12.270', 'Id': '11327'}