317_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am revising for a computer security course and I am stuck on one of the past questions. Here is it:</p>\n\n<blockquote>\n  <p>Alice ($A$) wants to send a short message $M$ to Bob ($B$) using a shared secret $S_{ab}$ to authenticate that the message has come from her. She proposes to send a single message with two pieces:\n  $$ A \\to B: \\quad M, h(M \\mathbin\\parallel S_{ab})$$\n  where $h$ is a hash function and $\\parallel$ denotes concatenation.</p>\n  \n  <ol>\n  <li>Explain carefully what Bob does to check that the message has come from Alice, and why (apart from properties of $h$) he may believe this.</li>\n  <li>Suppose that $h$ does not satisfy the one-way property and it is possible to generate pre-images. Explain what an attacker can do and how.</li>\n  <li>If generating pre-images is comparatively time-consuming, suggest a simple countermeasure to improve the protocol without changing $h$.</li>\n  </ol>\n</blockquote>\n\n<p>I think I know the first one. Bob needs to take a hash of the received message along with his shared key and compare that hash with the hash received from Alice, if they match then this should prove Alice sent it.</p>\n\n<p>I am not sure about the second two questions though. For the second one, would the answer be that an attacker can simply obtain the original message given a hash? I'm not sure how that would be done though.</p>\n", 'ViewCount': '170', 'Title': 'Attack on hash functions that do not satisfy the one-way property', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:44:58.717', 'LastEditDate': '2013-03-10T00:44:58.717', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1227', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '995', 'Tags': '<cryptography><hash><one-way-functions>', 'CreationDate': '2012-04-11T16:25:33.290', 'Id': '1225'},317_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was wondering how should I proceed in order to show that the composition of (say) two one-way functions (either weak or strong or both together) is not a one-way function?</p>\n\n<p>Specifically: Say $f$ and $g$ are one-way functions (either weak or strong).\nHow do I prove that their composition $g(f(x))$ is not necessarily a one-way function?</p>\n', 'ViewCount': '403', 'Title': 'How to show composition of one way function is not such?', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:44:40.480', 'LastEditDate': '2013-03-10T00:44:40.480', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9232', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4488', 'Tags': '<proof-techniques><cryptography><one-way-functions>', 'CreationDate': '2012-12-01T10:21:02.673', 'Id': '7076'},317_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that a <a href="http://en.wikipedia.org/wiki/One-way_function" rel="nofollow">one-way function</a> is informally a function that it\'s easy to compute but hard to invert.<br/>\nIf f(x) is a one way function the function  $g(x) = x\\oplus f(x)$ is a one-way function?\nMy intuition is that it\'s but i not really sure.</p>\n', 'ViewCount': '206', 'Title': "What will i obtain if i apply a xor-ing a one way function and it's input?", 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-10T00:43:38.110', 'LastEditDate': '2013-03-10T00:43:38.110', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7163', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3048', 'Tags': '<cryptography><one-way-functions>', 'CreationDate': '2012-12-04T18:24:57.147', 'Id': '7160'},317_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose $f(x)$ is a one way function. What about $h(x)=f(x_1) \\, \\oplus \\,f(x_2)$, where $x=x_1 || x_2$ and $\\lvert x_1 \\rvert = \\lvert x_2\\rvert$?</p>\n\n<ul>\n<li>$\\oplus$ is exclusive disjunction (xor)</li>\n<li>$||$ is concatenation</li>\n<li>$|u|$ is the length of $u$</li>\n</ul>\n', 'ViewCount': '263', 'Title': 'If xor-ing a one way function with different input, is it still a one way function?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-03-17T19:53:50.897', 'LastEditDate': '2013-03-13T20:16:34.320', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7209', 'Tags': '<cryptography><one-way-functions>', 'CreationDate': '2013-03-10T00:39:41.690', 'Id': '10415'},317_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Unfortunately my background in computational complexity is still weak, but I am working on it.</p>\n\n<p>As I understand, the question of existence of one-way functions is very important in the field.</p>\n\n<p>Assume there are one way-functions, how it can be shown that there exist one-way functions which are length preserving?</p>\n', 'ViewCount': '200', 'Title': 'Length-preserving one-way functions', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-21T10:21:10.180', 'LastEditDate': '2013-03-20T16:22:22.640', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<complexity-theory><cryptography><one-way-functions>', 'CreationDate': '2013-03-20T08:46:30.130', 'Id': '10639'},317_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I try to get the intuition behind the notion of <em>strong one way function</em> and <em>weak one way function</em> by reading the scribe <a href="http://www.cs.cornell.edu/courses/cs6830/2011fa/scribes/lecture3.pdf" rel="nofollow">One-Way Functions</a>. Particularly, I am interested in examples and definitions of the weak and strong one way function. I known it\'s very broad notion, therefore I will be as specific as possible in my questions.</p>\n\n<p><strong>Strong one way function</strong>. $\\forall$ nonuniform PPT $A$, $\\exists \\epsilon s.t. \\forall n \\in N, Pr_{x\\in\\{0,1\\}^n}[A(1^n, f(x)) \\in f^{-1}(f(x))] \\leq \\epsilon(n)$</p>\n\n<blockquote>\n  <p>Q:$1^n$ as the first parameter of the PPT $A$ represent the length of the initial input, the usage of it is justified as <em>"this ensures that the output of A doesn\'t shrink the size if its too must as in the f(x)=|x| example".</em> Unfortunately I didn\'t get the previous explanation (may be because the lost the sign, which takes an additional bit). In my opinion putting in A the size of $x$ might help $A$ get the right output $x$.</p>\n  \n  <p>Q: in the lecture it mentioned that $f(x)=|x|$ is hard, <em>"because it will take $2^c$ time to write a valid inverse of something such that $f(x)=c$"</em>. It happens because we cannot find $x$ with probability with negligible more than 0.5,  but it\'s due to another problem not a computational but rather information theory problem, by running the function we lost the information about the sign of the input $x$, if it\'s a correct reasoning, why actually it would take $2^c$ time?  In addition for  me it looks like the great discover to find the strong one way function, however do have more assumption of hard function like $f(x)=|x|$?</p>\n</blockquote>\n\n<p><strong>Definition of weak one way function</strong>.$\\exists$ $q(x)$, $\\forall$ nonunoform PPT A, $\\forall$ n $\\in$ N,\n$Pr_{x \\in \\{0,1\\}^n}[A(1^n,f(x)) \\in f^{-1}(f(x))] \\leq 1-\\frac{1}{q(n)}$</p>\n\n<blockquote>\n  <p>Q: in the lecture there was an assumption that the multiplication is weak one function, how we can actually show that the multiplication is weak one way function, and do we have more assumptions of examples of weak one way functions?</p>\n</blockquote>\n\n<p>I am very sorry for being naive, even though I will appreciate any help.</p>\n', 'ViewCount': '87', 'Title': 'Assumptions of One Way Functions', 'LastEditorUserId': '157', 'LastActivityDate': '2013-05-18T07:11:24.310', 'LastEditDate': '2013-04-18T06:04:27.470', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<complexity-theory><cryptography><one-way-functions>', 'CreationDate': '2013-04-17T19:40:32.080', 'Id': '11369'},317_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m curious about two things.</p>\n\n<ol>\n<li><p>When we define the class called "probabilistic polynomial-time algorithm" in computer science, does it include polynomial-time algorithm with exponential space? \nFor example, when algorithm is considered to be given a input from domain $\\{0,1\\}^n$, \nwhat if the algorithm internally queries its exponential sized table (ex. $0^n\\to0,0^{n-1}1\\to1$ and so on..) and outputs the result? Does it still polynomial-time algorithm?</p></li>\n<li><p>In theoretical cryptography, one-way function $f:\\{0,1\\}^*\\to\\{0,1\\}^*$ has a requirement, which is related with <em>hard-to-invert</em> property, as following block.\nIf the answer to above question is yes, is it possible to construct algorithm $A\'$ to simulate exactly same as $f$ for every value in $\\{0,1\\}^n$ using exponential table as described in above question? If then, it implies that it\'s impossible to design one-way function which is definitely not true. So what have i missed?</p>\n\n<blockquote>\n  <p>For every probabilistic polynomial-time algorithm $A\'$, every positive polynomial $p(\\cdot)$, and all sufficiently large $n$\'s, </p>\n  \n  <p>$Pr[A\'(f(U_n),1^n)\\in f^{-1}(f(U_n))]&lt;\\frac{1}{p(n)}$</p>\n  \n  <p>where $U_n$ is random variable uniformly distributed over $\\{0,1\\}^n$ </p>\n</blockquote></li>\n</ol>\n', 'ViewCount': '195', 'Title': 'Polynomial-time algorithm with exponential space is eligible?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-08T10:42:59.150', 'LastEditDate': '2013-08-08T10:42:59.150', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '13668', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9565', 'Tags': '<complexity-theory><terminology><polynomial-time><one-way-functions>', 'CreationDate': '2013-08-07T10:09:41.700', 'Id': '13655'},317_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '105', 'Title': 'Using a proof-of-work system to discourage piracy or encourage donations', 'LastEditDate': '2013-10-21T04:12:46.827', 'AnswerCount': '3', 'Score': '4', 'OwnerDisplayName': 'LateralFractal', 'PostTypeId': '1', 'OwnerUserId': '10539', 'FavoriteCount': '2', 'Body': '<p><strong>Background</strong></p>\n\n<p>A <a href="http://en.wikipedia.org/wiki/Proof-of-work_system" rel="nofollow">proof-of-work system</a> allows one peer to prove to another peer that a certain amount of computational effort was performed.\nIn a network setting this can be used to throttle peer requests without needing to keep a precise track on the identity of the peers or prior events. \nThe most well known use of proof-of-work is to throttle spam throughput in an email network*.</p>\n\n<p>Some proof-of-work systems allow certain roles on the network (say, a mailing list) to calculate the proof of work much faster by using a secret <em>"short-cut"</em> - typically a pre-calculated trapdoor or a private key depending on the proof-of-work system.</p>\n\n<p><strong>Hypothesis</strong></p>\n\n<ol>\n<li>Any algorithm or a certain class of algorithms can be converted into a proof-of-work version of that algorithm. That is: A deliberately inefficient and incompressible algorithm.</li>\n<li>Such converted proof-of-work algorithms can support proof-of-work shortcuts.</li>\n<li>Such converted proof-of-work algorithms can not be converted back to the original algorithm without considerable computational power; if at all.</li>\n</ol>\n\n<p><strong>Extrapolation</strong></p>\n\n<p>If the hypothesis holds, then selected business logic of an application - specifically that which is unique or value-added by that application vs existing applications - could be converted to proof-of-work equivalents.</p>\n\n<p>End-users could then be provided such an application; which will run slowly either generally or for certain premium features. The development team however, possesses a secret PoW shortcut and set up a subscription, donation or advertising(<a href="http://www.aef.com/on_campus/classroom/book_excerpts/data/1504" rel="nofollow">!</a>)-based service - an <a href="http://en.wikipedia.org/wiki/Software_as_a_service" rel="nofollow">SaaS</a> - for solving the proof-of-work bottleneck for the end-user. The end-user can now choose to run the application slower without the SaaS or faster with the SaaS. </p>\n\n<p>This SaaS needs to process considerably less client-side business logic than a general cloud solution (e.g. Diablo 3 style SaaS); as the goal is the speed of execution rather than no execution - and the SaaS proof-of-work speed ratio is tailored accordingly. </p>\n\n<p>This is especially relevant for software projects supported by charity as the developers <em>do</em> want the software available to anyone but can encourage donations without needing a separate fairly easy to pirate <a href="http://en.wikipedia.org/wiki/Freemium" rel="nofollow">Freemium</a> edition. The Tragedy of the Commons (freeloading) could be discouraged to a fair extent without guilt-tripping or <a href="http://www.theregister.co.uk/2003/01/17/i_poisoned_p2p_networks/" rel="nofollow">rat poisoning</a>, by adjusting the proof-of-work cost relative the value of the application or service.</p>\n\n<blockquote>\n  <p><em>Example 1:</em> A commercial stock market estimation tool licensed per\n  month. If the user forgoes paying for a subscription, the estimation\n  occurs at 1% the normal rate.</p>\n  \n  <p><em>Example 2:</em> A free <a href="http://gamedevtycoon.wikia.com/wiki/AAA" rel="nofollow">Triple A</a> co-op video game runs twice fast if the\n  user donates some money once a year.</p>\n</blockquote>\n\n<p>In either example the user must decide between accepting the default speed; spending money on a faster computer/cloud services; or contributing to the upkeep of the product.</p>\n\n<p><strong>Question</strong></p>\n\n<p><em>Does the hypothesis hold and has anyone attempted to explore or implement this hypothesis?</em></p>\n\n<p>Any example of an open source library or application that attempts to implement the hypothesis qualifies as a sufficient answer (from my perspective); as I could dissect the code.</p>\n\n<p><sub> * Which has a variety of issues for the Digital Divide, but that\'s another story</sub></p>\n', 'Tags': '<time-complexity><one-way-functions><proof-of-work>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-21T13:56:59.407', 'CommentCount': '3', 'CreationDate': '2013-10-03T03:52:24.797', 'Id': '16188'},317_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I believe this question should be extremely easy but I am having a (embarrassing) hard time figuring out why its true if there exist OWF (computable in polynomial time) then there exits a OWF that is computed in $O(n^2)$.</p>\n\n<p>This is what I have/tried.</p>\n\n<p>Let $ \\ f(x)$ be a OWF that can be computed in $k^c$. Then we can construct a OWF:</p>\n\n<p>$$\nf\'(x\'||\\ x\'\') = f(x\') || \\ x\'\'\n$$\nwhere:\n$$\n|x\'| = k \\\\\n|x\'\'| = k^c\n$$</p>\n\n<p>Notice the size of the input for $f\'$ is $n = k^c + k$.</p>\n\n<p>Its intuitively "obvious" f\' is a OWF since f is OWF (or you can go ahead and prove it by contradiction if you want to be pedantic). But how come it takes $O(n^2)$ to compute the OWF f\'? Does this depend on the Turing Machine model being used to compute f\'?</p>\n\n<p>It seems to me you can just parse the input $x\'||x\'\'$ (separate it so that you can feed the appropriate thing to the original f) in O(n) and then compute $f(x\')$ in $k^c = O(n)$\nand then concatenate it to $x\'\'$ and print f(x\')|x\'\' (printing takes at most $O(n)$). It seems to me it takes $O(n)$ and that the bound $O(n^2)$ is unnecessarily un-tight (I know $cn + d = O(n) = O(n^2)$). Or maybe the parsing algorithm is "harder" than I expect it... even if you just append the lengths at the beginning just for parsing purposes , isn\'t the time to compute $f\'$ just $O(n)$?</p>\n\n<p>Does someone understands why my O(n) argument is wrong?</p>\n', 'ViewCount': '44', 'Title': 'If a one-way functions (OWF) exist, then there exits a OWF that is computable in quadratic running time by a padding argument', 'LastEditorUserId': '12623', 'LastActivityDate': '2014-01-08T06:44:06.893', 'LastEditDate': '2014-01-07T00:25:10.693', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19532', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12623', 'Tags': '<asymptotics><cryptography><one-way-functions>', 'CreationDate': '2014-01-06T04:48:25.020', 'Id': '19527'}