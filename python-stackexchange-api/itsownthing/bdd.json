{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am trying to figure out difference between fully- and quasi-reduced BDDs. I have read a lot of material but still it is not very clear. As I am trying to figure out the quasi reduced version for union between two BDDs.\nThe algorithm for union between two fully-reduced BDDs is </p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n   //fully-reduced version\n   local bdd r;\n1  if p=0 or q=1 then return q;\n2  if q=0 or p=1 then return p;\n3  if p=q then return p;\n4  if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n5  if p.lvl = q.lvl then\n6    r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n7  else if p.lvl &gt; q.lvl then\n8    r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q), Union(p[1], q));\n9  else since p.lvl &lt; q.lvl then\n10   r \u2190 UniqueTableInsert(q.lvl, Union(p, q[0]), Union(p, q[1]));\n11 enter\u27e8UnionCODE,{p,q}:r\u27e9inCache;\n12 return r;\n</code></pre>\n\n<p>I have read the paper <em>Binary decision diagrams in theory and practice</em> by Rolf Drechsler, Detlef Sieling for basics of BDD, and <em>Data Representation and Efficient Solution: A Decision Diagram Approach</em> by Gianfranco Ciardo for quasi-reduced and fully reduced definitions. Then I read more papers with more or less same description of quasi- and fully-reduced BDDs. In the former paper I mentioned the authors talk about reduced BDDs, I am not clear whether these BDDs are fully reduced. Quasi-reduced BDDs has no variable skipping so how come they are reduced when they have redundant nodes. I am pretty confused between BDD, quasi-reduced BDD and fully-reduced BDD. Yes, I am trying to find the difference between union algorithm for quasi-reduced and fully-reduced, for this I need to look at the quasi-reduced version of union algorithm.</p>\n\n<p>I figured out an algorithm for union of two quasi reduced BDDs <code>p</code> and <code>q</code> resulting in <code>r</code>.</p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n  local bdd r;\n1 if p=0 or q=1 then return q;\n2 if q=0 or p=1 then return p;\n3 if p=q then return p;\n4 if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n  //p.lvl = q.lvl in case of quasi reduced BDDs\n5 r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n6 enter\u27e8UnionCODE,{p,q}:r\u27e9 in Cache;\n7 return r;\n</code></pre>\n\n<p>Since there is no variable skipping, <code>p.lvl</code> is always equal to <code>q.lvl</code>. I have a question about this algorithm.</p>\n\n<p>If I want to implement Xor or Xnor for quasi-reduced BDDs, can it be done the same way as union or should I implement the expression <code>pq' + p'q</code> where <code>q' = !q</code>.</p>\n", 'ViewCount': '86', 'Title': 'Difference between fully-reduced BDD and quasi-reduced BDD', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:56:46.307', 'LastEditDate': '2013-08-13T08:56:46.307', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9556', 'Tags': '<algorithms><terminology><logic><binary-trees><bdd>', 'CreationDate': '2013-08-06T23:35:14.983', 'Id': '13637'}