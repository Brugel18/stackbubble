193_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>Originally on <a href="http://math.stackexchange.com/questions/74453/how-is-the-loop-invarient-obtained-in-this-square-root-bound-finding-algorithm">math.SE</a> but unanswered there.</em></p>\n\n<p>Consider the following algorithm.</p>\n\n<pre><code>u := 0\nv := n+1;\nwhile ( (u + 1) is not equal to v) do\n   x :=  (u + v) / 2;\n   if ( x * x &lt;= n) \n     u := x;\n   else\n     v := x;\n   end_if\nend_while \n</code></pre>\n\n<p>where u, v, and n are integers and the division operation is integer division. </p>\n\n<ul>\n<li>Explain what is computed by the algorithm. </li>\n<li>Using your answer to part I as the post-condition for the algorithm, establish a loop invariant and show that \nthe algorithm terminates and is correct.</li>\n</ul>\n\n<p>In class, the post-condition was found to be $0 \\leq u^2 \\leq n &lt; (u + 1)^2$ and the \nInvariant is $0 \\leq u^2 \\leq n &lt; v^2, u + 1 \\leq v$.  I don\'t really understand on how the post-condition and invariants were obtained.  I figure the post condition was $u + 1 = v$... which is clearly not the case.  So I am wondering on how the post-condition and invariant was obtained.  I\'m also wondering on how the pre-condition can be obtained by using the post-condition.</p>\n', 'ViewCount': '271', 'Title': 'How is the loop invariant obtained in this square root bound finding algorithm?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-10T03:28:29.270', 'LastEditDate': '2012-05-10T03:28:29.270', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<algorithms><loop-invariants><correctness-proof>', 'CreationDate': '2012-03-13T06:06:53.057', 'FavoriteCount': '1', 'Id': '288'},193_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm making a graduate thesis about proving correctness of program for multiplying 2 matrices using Hoare logic. For doing this, I need to generate the invariant for nested loop for this program:</p>\n\n<pre><code>for i = 1:n\n    for j = 1:n\n        for k = 1:n\n            C(i,j) = A(i,k)*B(k,j) + C(i,j);\n        end\n    end\nend\n</code></pre>\n\n<p>I've tried to find the invariant for inner loop first, but I can't find the true one until now. Is there someone can help me for finding the invariant for above program?</p>\n", 'ViewCount': '514', 'Title': 'Invariant For Nested Loop in Matrix Multiplication Program', 'LastEditorUserId': '472', 'LastActivityDate': '2012-05-06T15:19:40.093', 'LastEditDate': '2012-05-02T10:33:52.290', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '7', 'OwnerDisplayName': 'Anggha Nugraha', 'PostTypeId': '1', 'OwnerUserId': '1352', 'Tags': '<algorithms><loop-invariants><correctness-proof>', 'CreationDate': '2012-05-01T20:55:52.537', 'Id': '1625'},193_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On <a href="https://en.wikipedia.org/wiki/Levenshtein_distance#Computing_Levenshtein_distance">Wikipedia</a>, an implementation for the bottom-up dynamic programming scheme for the edit distance is given. It does not follow the definition completely; inner cells are computed thus:</p>\n\n<pre><code>if s[i] = t[j] then  \n  d[i, j] := d[i-1, j-1]       // no operation required\nelse\n  d[i, j] := minimum\n             (\n               d[i-1, j] + 1,  // a deletion\n               d[i, j-1] + 1,  // an insertion\n               d[i-1, j-1] + 1 // a substitution\n             )\n}\n</code></pre>\n\n<p>As you can see, the algorithm <em>always</em> chooses the value from the upper-left neighbour if there is a match, saving some memory accesses, ALU operations and comparisons. </p>\n\n<p>However, deletion (or insertion) may result in a <em>smaller</em> value, thus the algorithm is locally incorrect, i.e. it breaks with the optimality criterion. But maybe the mistake does not change the end result -- it might be cancelled out.</p>\n\n<p>Is this micro-optimisation valid, and why (not)?</p>\n', 'ViewCount': '306', 'Title': 'Micro-optimisation for edit distance computation: is it valid?', 'LastActivityDate': '2012-08-02T07:32:35.867', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2997', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<algorithms><dynamic-programming><string-metrics><correctness-proof><program-optimization>', 'CreationDate': '2012-08-01T15:41:33.670', 'Id': '2985'},193_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>Suppose that we redefine the residual network to disallow edges into $s$. Argue that the procedure FORD-FULKERSON still correctly computes a maximum flow.  </p>\n</blockquote>\n\n<p>I was thinking that when we augment a path the residual capacity of reverse edge increases and can be used to decrease the flow in that edge (but overall increase the network flow) if needed. So if we disallow the edges into $s$ that means we are not allowing decrease in flow in edges $s\\to x$ ($x$ is the adjacent node to $s$). So in the case when we allow edges into $s$ we can have a cycle like </p>\n\n<p>$\\qquad \\displaystyle s \\to x_1 \\leadsto y \\leadsto x_2 \\to s \\to x_3 \\leadsto t$.  </p>\n\n<p>But if we disallow edges into $s$ again we can find the same path with out the cycle. All the above are intuitive ideas but I want a formal proof.  </p>\n\n<p>The question is from <em>Introduction to Algorithms</em> by Cormen et al.</p>\n', 'ViewCount': '356', 'Title': 'A variation in Ford-Fulkerson algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-02T13:17:51.197', 'LastEditDate': '2012-09-02T13:17:51.197', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2589', 'Tags': '<algorithms><graph-theory><network-flow><correctness-proof>', 'CreationDate': '2012-09-02T12:01:27.050', 'Id': '3400'},193_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have created the algorithm below...</p>\n\n<pre><code>        String A = v[0];\n        int val = 1;\n\n        for (int i = 1; i &lt; v.length; i++) {\n            if (val == 0) {\n                A = v[i];\n                val++;\n            } else if (v[i].equals(A))\n                val++;\n            else\n                val--;\n        }\n</code></pre>\n\n<p>The goal of the algorithm is to find the item that occurs in more than half the array.</p>\n\n<p>Let v = {"one", "two", "one", "three", "one", "two", "two", "one", "one"}</p>\n\n<p>The string "one" occurs 5 out of 9 times.  So, at the end of the loop, the String A will be equal to "one". </p>\n\n<p>I\'m lost as to how to derive a loop invariant from this.  Could someone provide me with some direction?</p>\n', 'ViewCount': '218', 'Title': 'Help Finding Loop Invariant From For Loop', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-15T09:39:40.800', 'LastEditDate': '2012-09-13T21:53:54.173', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2816', 'Tags': '<algorithms><loop-invariants><correctness-proof>', 'CreationDate': '2012-09-13T19:06:30.303', 'FavoriteCount': '2', 'Id': '3532'},193_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I see <strong>structural induction</strong> the usual way for proving an algorithm's <strong>termination</strong> property, but it's not that easy to prove by means of induction on a <strong>tree</strong> algorithm. Now I am struggling on proving that the pre-order tree traversal algorithm is terminable:</p>\n\n<pre><code>preorder(node)\n  if node == null then return\n  visit(node)\n  preorder(node.left) \n  preorder(node.right)\n</code></pre>\n\n<p>How should I prove?</p>\n", 'ViewCount': '220', 'Title': 'How to prove that the pre-order tree traversal algorithm terminates?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-26T20:14:24.327', 'LastEditDate': '2012-09-26T20:14:24.327', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4726', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2954', 'Tags': '<algorithms><data-structures><algorithm-analysis><correctness-proof><induction>', 'CreationDate': '2012-09-24T15:52:44.860', 'Id': '4719'},193_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '326', 'Title': 'How to prove that BFS directed-graph traversal algorithm terminates?', 'LastEditDate': '2012-09-27T00:17:49.203', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2954', 'FavoriteCount': '0', 'Body': u'<p>How to prove that BFS directed-graph traversal algorithm terminates?\n(I copy the pseudocode from <a href="http://en.wikipedia.org/wiki/Breadth-first_search" rel="nofollow">here</a>) Input: A graph G and a root v of G.</p>\n\n<pre><code>  procedure BFS(G,v):\n      create a queue Q\n      enqueue v onto Q\n      mark v\n      while Q is not empty:\n          t \u2190 Q.dequeue()\n          if t is what we are looking for:\n              return t\n          for all edges e in G.incidentEdges(t) do\n             o \u2190 G.opposite(t,e)\n             if o is not marked:\n                  mark o\n                  enqueue o onto Q\n</code></pre>\n', 'Tags': '<algorithms><algorithm-analysis><correctness-proof>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-09-27T00:17:49.203', 'CommentCount': '1', 'AcceptedAnswerId': '4749', 'CreationDate': '2012-09-26T18:21:07.543', 'Id': '4746'},193_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am trying to teach myself the principles of cryptograhpy, and want to solve the following question:</p>\n\n<blockquote>\n  <p>Let G be the algorithm that takes an input x = (x1, . . . , xn) from\n  {0, 1} n (so each xi \u2208 {0, 1}) and outputs the string G(x1, . . . ,\n  xn) = (x1, . . . , xn, x1 \u2295 x2) in {0, 1} n+1. Rigorously prove that G\n  is not a pseudorandom generator.</p>\n</blockquote>\n\n<p>So, we would want to prove that either <strong>expansion</strong> doesn't hold (for all n, l(n) > n), which, in this case, would mean that for each x, the corresponding G > x, or <strong>pseudorandomness</strong> doesn't hold ( For efficient algorithm D, there is a negligible function 'n' such that: </p>\n\n<blockquote>\n  <p>Pr[D(r) = 1]-Pr[D(G(s)) = 1] $\\leq$ $\\epsilon$(n), </p>\n  \n  <p>where 'r' is uniform on {0,1}$^{l(n)}$ and 's' is uniform on {0,1}$^n$</p>\n</blockquote>\n\n<p>), which, in this case, means that we need to prove that there does not exist a function n such that the difference of the probabilities of the function D(r) and D(G(s)) is very small.</p>\n\n<p>Now, I understand these concepts, but I am  having trouble approaching this problem practically... what would be the best way to start?</p>\n", 'ViewCount': '78', 'Title': 'Rigorous proof against pseudorandom generator', 'LastActivityDate': '2012-09-27T06:54:15.687', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '4757', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<correctness-proof><pseudo-random-generators>', 'CreationDate': '2012-09-26T22:28:27.563', 'Id': '4754'},193_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm in a first year discrete math course and we started algorithms. I created a recursive algorithm to multiply two numbers together:</p>\n\n<pre><code>function multiply($n, $r) {\n    if($n == 1)\n return $r;\n    else if($r == 1)\n return $n;\n    else\n        return $r + multiply($n - 1, $r);\n}\n</code></pre>\n\n<p>How do I prove my algorithm is correct?</p>\n\n<p>A quick google search tells me I have to prove that it works for $n + 1$ and I have to prove that it terminates. Unfortunately I'm still incredibly new to this and haven't the faintest clue as to where to start for proving my algorithm correct, so I would really appreciate some help here. I think maybe I have to do some sort of proof by induction but as this is an algorithm, I wouldn't know where to start.</p>\n", 'ViewCount': '643', 'Title': 'Prove correctness of recursive multiplication algorithm', 'LastEditorUserId': '755', 'LastActivityDate': '2013-08-31T05:56:55.600', 'LastEditDate': '2013-08-31T05:56:55.600', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4359', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><induction>', 'CreationDate': '2012-10-25T15:37:15.703', 'Id': '6311'},193_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>One can compress data with straight-line grammars. An algorithm that employs this technique is called <em>Sequitur</em>. If I understood correctly, Sequitur basically starts with one rule representing the input and then does these three steps till the grammar does not change anymore:</p>\n\n<ol>\n<li>For each rule, try to find any sequences of symbols in any other rule that match the rule's right hand side and replace these sequences by the rules left hand side.</li>\n<li>For each pair of adjacent symbols in any right hand side, find all non-overlapping other pairs of adjacent symbols that are equal to the original pair. If there are any other pairs, add a new nonterminal, replace all occurrences of these pairs by the new nonterminal and add a new rule that defines the nonterminal.</li>\n<li>For each nonterminal that appears exactly once on all right-hand sides of all rules, replace its occurrence by its definition, remove the nonterminal and the rule that defines it.</li>\n</ol>\n\n<p>For each (non-empty) input, can one guarantee that the above algorithm terminates?</p>\n", 'ViewCount': '251', 'Title': 'Will this algorithm terminate on any input?', 'LastEditorUserId': '2280', 'LastActivityDate': '2013-01-28T22:04:37.830', 'LastEditDate': '2012-10-29T06:14:04.147', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<algorithms><algorithm-analysis><formal-grammars><data-compression><correctness-proof>', 'CreationDate': '2012-10-28T21:15:53.433', 'FavoriteCount': '1', 'Id': '6360'},193_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<pre><code>Insertion-Sort (A) [where A is an array of numbers to be sorted]\n\n(1) for j = 2 to A.length\n(2)       key = A[j]\n(3)       i = j -1\n(4)       while i &gt; 0 and A[i] &gt; key\n(5)              A[i+1] = A[i]\n(6)              i = i - 1\n(7)       A[i + 1] = key\n</code></pre>\n\n<p>CLRS proves the correction of the above algorithm by using a loop invariant:</p>\n\n<blockquote>\n  <p><strong>Loop Invariant:</strong> At the start of each iteration of the for loop of lines 1\u20138, the subarray A[1... j - 1] consists of the elements originally in A[1... j - 1]  but in sorted order.</p>\n  \n  <p>We use loop invariants to help us understand why an algorithm is correct. We must show three things about a loop invariant:</p>\n  \n  <p>Initialization: It is true prior to the first iteration of the loop.</p>\n  \n  <p>Maintenance: If it is true before an iteration of the loop, it remains true before the</p>\n  \n  <p>Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.</p>\n</blockquote>\n\n<p>In the explanation of the maintenance aspect of the loop invariant, the following is mentioned:</p>\n\n<blockquote>\n  <p>Maintenance: A more formal treatment of the this property would require us to state and show a loop invariant for the while loop of lines 5\u20137. At this point, however, we prefer not to get bogged down in such formalism, and so we rely on our informal analysis to show that the second property holds for the outer loop.</p>\n</blockquote>\n\n<p>Why would a "formal treatment" require a loop invariant for the while loop? Having one invariant for the outer for loop is sufficient to prove the correctness of the algorithm- why would a "formal treatment" require a loop invariant?</p>\n', 'ViewCount': '153', 'Title': 'Loop invariants?', 'LastActivityDate': '2012-11-09T07:23:45.327', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4519', 'Tags': '<algorithms><algorithm-analysis><correctness-proof>', 'CreationDate': '2012-11-09T03:03:51.197', 'Id': '6567'},193_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>From <a href="http://rads.stackoverflow.com/amzn/click/0262033844" rel="nofollow">CLRS</a> (third edition, page 19), there is a footnote:</p>\n\n<blockquote>\n  <p>When the loop is a for loop, the moment at which we check the loop invariant just prior to the first iteration is immediately after the initial assignment to the loop-counter variable and just before the first test in the loop header.</p>\n</blockquote>\n\n<p>Why is the checking moment specifically chosen to be after the initial assignment but before the first test? Note the excerpt is talking about proving correctness of algorithms using loop invariants.</p>\n', 'ViewCount': '162', 'Title': 'Invariant Proof of For Loops?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-11T15:25:00.483', 'LastEditDate': '2012-11-10T12:28:54.603', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4533', 'Tags': '<proof-techniques><correctness-proof><loop-invariants>', 'CreationDate': '2012-11-10T03:23:45.817', 'Id': '6595'},193_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the searching problem:</p>\n\n<blockquote>\n  <p>Input: A sequence of $n$ numbers $A=(a_1, a_2, \\ldots , a_n)$ and a value $v$.</p>\n  \n  <p>Output: An index $i$ such that $v = a_i$ or the special value NIL if $v$ does not appear in $A$</p>\n</blockquote>\n\n<p>Write pseudocode for linear search, which scans through the sequence, looking for $v$. Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.</p>\n\n<p>The algorithm is clearly very simple to prove. However could someone prove the correctness of the algorithm using a loop invariant? Note the "three necessary properties" are:</p>\n\n<ul>\n<li><p>Initialization: It is true prior to the first iteration of the loop.</p></li>\n<li><p>Maintenance: If it is true before an iteration of the loop, it remains true before the</p></li>\n<li><p>Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.</p></li>\n</ul>\n', 'ViewCount': '436', 'Title': 'Proof of linear search?', 'LastEditorUserId': '4528', 'LastActivityDate': '2012-11-10T18:12:56.610', 'LastEditDate': '2012-11-10T07:03:19.407', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4533', 'Tags': '<proof-techniques><correctness-proof><loop-invariants>', 'CreationDate': '2012-11-10T04:23:18.037', 'Id': '6597'},193_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/6597/proof-of-linear-search">Proof of linear search?</a>  </p>\n</blockquote>\n\n\n\n<p>I\'m reading the MIT Press, Introduction to Algorithms textbook 3rd edition, and I am a bit confused by an exercise. </p>\n\n<p>2.1-3\nConsider the searching problem:\nInput: A sequence of n numbers A =  and a value v.\nOutput: An index i such that v = A[i] or the special value NIL if v does not appear in A.</p>\n\n<p>Write pseudocode for linear search, which scans through the sequence looking for v. Using a loop invariant, prove that your algorithm is correct. Make sure your loop invariant fulfills the three necessary properties.</p>\n\n<p>Earlier in the book I read that "We must show three things about a loop invariant:</p>\n\n<p>Initialization: It is true prior to the first iteration of the loop.</p>\n\n<p>Maintenance: If it is true before an iteration of the loop, it remains true before the\nnext iteration.</p>\n\n<p>Termination: When the loop terminates, the invariant gives us a useful property that helps show that the algorithm is correct.\n"</p>\n\n<p>I wrote this as my pseudocode</p>\n\n<pre><code>index = nil\nj = 1 \nwhile j &lt;= A.length and index == nil\n  if A[j] == v\n    index = j\n  j = j + 1\n</code></pre>\n\n<p>But when it comes to proving using a loop invariant I have no idea what to do. What do I even use as a loop invariant? To be honest I\'m not really clear about the entire loop invariant concept. Can someone please help me understand this? </p>\n\n<p>Thanks.</p>\n', 'ViewCount': '38', 'ClosedDate': '2012-12-04T17:03:05.747', 'Title': 'loop invariant proof', 'LastEditorUserId': '4648', 'LastActivityDate': '2012-12-04T03:56:29.240', 'LastEditDate': '2012-12-04T03:56:29.240', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'OwnerDisplayName': 'the.alch3m1st', 'PostTypeId': '1', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><loop-invariants>', 'CreationDate': '2012-12-03T20:11:11.017', 'Id': '7138'},193_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m currently studying the book "Introduction to Algorithms - Cormen". Although a proof of correctness for the BFS algorithm is given, there isn\'t one any for the DFS in the book. So I was courious about how it can be shown that DFS visits all the nodes.\nI also googled for it. But it seems that every lecturer do some copy-paste work from this book in their pdf\'s, so I couldn\'t find anything useful. <br/><br/>\nBy DFS we had to show that it found the shortest path. But since DFS does not calculate something like that I have no idea how to prove it.<br/></p>\n\n<hr>\n\n<p>Off the topic, why are those proofs so important? Throughout the book there are so many lemmas and theorems which can be really boring sometimes. I understand how an algorithm works in 10 minutes, perhaps need another 5 to 10 minutes to understand how to analyse the running time, but then I\'m loosing 1 hour just for some useless lemmas. Besides, and worse even, I studied almost 50 proofs/lemmas of different algorithms till now, I never managed to solve one of them by myself. How can I gain the "proving ability"? Is there a systematical way to learn that? I don\'t mean the Hoare logic way with invariants, rather the informal way described in the book "Introduction to Algorithms". Is there any book which focuses on "how to prove algorithms" and show that in a systematical, introductory way ?</p>\n', 'ViewCount': '800', 'Title': 'DFS - Proof of Correctness', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-05T11:11:50.160', 'LastEditDate': '2013-01-05T10:16:22.507', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graph-theory><graphs><correctness-proof>', 'CreationDate': '2013-01-04T05:53:53.593', 'Id': '7749'},193_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Based on the definition of a <a href="http://mathworld.wolfram.com/Multiset.html" rel="nofollow">multiset</a> and the information in this <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.145.8728" rel="nofollow">paper</a>, why do we use multisets in proving the termination of a program?\nIs not the well-founded order enough?</p>\n', 'ViewCount': '126', 'Title': 'The use of multiset ordering in proving termination', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T10:55:18.597', 'LastEditDate': '2013-01-21T10:55:18.597', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1584', 'Tags': '<algorithm-analysis><proof-techniques><correctness-proof><sets>', 'CreationDate': '2013-01-19T23:46:45.707', 'Id': '9046'},193_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can GDB be run on itself? How or why not?\nI see something about it <a href="http://www.math.utah.edu/docs/info/gdbint_3.html" rel="nofollow">http://www.math.utah.edu/docs/info/gdbint_3.html</a>\nBut GDB might not be written in a language that it can debug?</p>\n', 'ViewCount': '107', 'Title': 'Can GDB debug itself?', 'LastActivityDate': '2013-01-30T15:23:59.747', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '9310', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2529', 'Tags': '<correctness-proof><program-correctness>', 'CreationDate': '2013-01-30T14:47:04.433', 'Id': '9308'},193_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose I have a admissible and consistent heuristic.</p>\n\n<p>Is it true, that when I expand a node, I have guaranteed that the path I found to this node is optimal?</p>\n\n<p>Look at this pseudocode from wikipedia:</p>\n\n<pre><code>function A*(start,goal)\n closedset := the empty set    // The set of nodes already evaluated.\n openset := {start}    // The set of tentative nodes to be evaluated, initially containing the start node\n came_from := the empty map    // The map of navigated nodes.\n\n g_score[start] := 0    // Cost from start along best known path.\n // Estimated total cost from start to goal through y.\n f_score[start] := g_score[start] + heuristic_cost_estimate(start, goal)\n\n while openset is not empty\n     current := the node in openset having the lowest f_score[] value\n     if current = goal\n         return reconstruct_path(came_from, goal)\n\n     remove current from openset\n     add current to closedset\n     for each neighbor in neighbor_nodes(current)\n         tentative_g_score := g_score[current] + dist_between(current,neighbor)\n         if neighbor in closedset\n             if tentative_g_score &gt;= g_score[neighbor]\n                 continue\n\n         if neighbor not in openset or tentative_g_score &lt; g_score[neighbor] \n             came_from[neighbor] := current\n             g_score[neighbor] := tentative_g_score\n             f_score[neighbor] := g_score[neighbor] + heuristic_cost_estimate(neighbor, goal)\n             if neighbor not in openset\n                 add neighbor to openset\n\n return failure\n</code></pre>\n\n<p>I suppose it should be true. Because of this:</p>\n\n<pre><code>if current = goal\n     return reconstruct_path(came_from, goal)\n</code></pre>\n\n<p>If it wasn't true then this test would not guarantee me that the solution is optimal right?</p>\n\n<p>What I don't get and the reason I am asking this question is this:</p>\n\n<pre><code>if neighbor in closedset\n         if tentative_g_score &gt;= g_score[neighbor]\n             continue\n</code></pre>\n\n<p>If the neighbor is in closed list, it means that it has already been expanded. Why are they testing the scores then? Why would not the next condition work?</p>\n\n<pre><code>if neighbor in closedset\n         continue\n</code></pre>\n", 'ViewCount': '97', 'Title': 'A* optimality of the expanded node', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-29T23:28:22.880', 'LastEditDate': '2013-04-02T07:37:43.930', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '16559', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7075', 'Tags': '<algorithms><algorithm-analysis><search-algorithms><correctness-proof>', 'CreationDate': '2013-02-28T15:36:33.660', 'Id': '10152'},193_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Would it be correct to characterize loop invariants as a type of tautology?  I ask since the invariant must basically always be true, before the loop starts, before each iteration and after the loop terminates.  I realize that there is the possibility that the invariant could become false during the body of the loop.  But since inside the loop "doesn\'t count" is it fair to characterize the invariant as a tautology?</p>\n', 'ViewCount': '92', 'Title': 'Loop Invariants as Tautologies', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T21:25:07.547', 'LastEditDate': '2013-03-12T14:08:56.163', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '10471', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<algorithm-analysis><logic><correctness-proof><loop-invariants><program-correctness>', 'CreationDate': '2013-03-12T07:57:56.437', 'Id': '10469'},193_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p><strong>Definition:</strong> A preserved invariant of a state machine is a predicate, $P$, on\nstates, such that whenever $P(q)$ is true of a state, $q$, and $q  \\rightarrow r$ for some state, $r$,\nthen $P(r)$ holds.</p>\n\n<p><strong>Definition:</strong> A line graph is a graph whose edges are all on one path.</p>\n\n<p><strong>Definition:</strong> Formally, a state machine is nothing more than a binary relation on a set, except\nthat the elements of the set are called \u201cstates,\u201d the relation is called the transition\nrelation, and an arrow in the graph of the transition relation is called a transition.\nA transition from state $q$ to state $r$ will be written $q \\rightarrow r$.</p>\n\n<p><strong>DAG</strong>: Directed Acylic Graph</p>\n\n<blockquote>\n  <p>The following procedure can be applied to any directed graph, $G$:</p>\n  \n  <ol>\n  <li>Delete an edge that is in a cycle.</li>\n  <li>Delete edge $&lt;u \\rightarrow v&gt;$ if there is a path from vertex $u$ to vertex $v$ that does not\n  include $&lt;u \\rightarrow v&gt;$.</li>\n  <li>Add edge $&lt;u \\rightarrow v&gt;$ if there is no path in either direction between vertex $u$ and\n  vertex $v$.</li>\n  </ol>\n  \n  <p>Repeat these operations until none of them are applicable.</p>\n</blockquote>\n\n<p>This procedure can be modeled as a state machine. The start state is $G$, and the\nstates are all possible digraphs with the same vertices as $G$.</p>\n\n<p><strong>(b)</strong> Prove that if the procedure terminates with a digraph, $H$, then $H$ is a line\ngraph with the same vertices as $G$.</p>\n\n<p>Hint: Show that if $H$ is not a line graph, then some operation must be applicable.</p>\n\n<p><strong>(c)</strong> Prove that being a DAG is a preserved invariant of the procedure.</p>\n\n<p><strong>(d)</strong> Prove that if $G$ is a DAG and the procedure terminates, then the walk relation\nof the final line graph is a topological sort of $G$.</p>\n\n<p>Hint: Verify that the predicate\n$P(u,v)$:: there is a directed path from $u$ to $v$\nis a preserved invariant of the procedure, for any two vertices $u, \\ v$ of a DAG.</p>\n\n<p><strong>(e)</strong> Prove that if $G$ is finite, then the procedure terminates.</p>\n\n<p>Hint: Let $s$ be the number of cycles, $e$ be the number of edges, and $p$ be the number\nof pairs of vertices with a directed path (in either direction) between them. Note\nthat $p \\leq n^2$ where $n$ is the number of vertices of $G$. Find coefficients $a,b,c$ such\nthat as+bp+e+c is nonnegative integer valued and decreases at each transition.</p>\n\n<blockquote>\n  <p><em><strong>My Problems:</em></strong></p>\n  \n  <p>I got stuck with problems $d$ and $e$ but solutions to other problems are welcome too.</p>\n  \n  <p>At problem  $d$, <strong>I could not understand the hint and why it is given, how it helps</strong>. </p>\n</blockquote>\n\n<p>In my way for proving $d$, I am trying to show that given procedure always preserves the order of vertices, which are associated with edges, on the start graph $G$. So a line graph is automatically a topological sort since the "precedence order" of the vertices are preserved. </p>\n\n<blockquote>\n  <p>But procedure number $3$ is problematic, <strong>how to show it preserves precedence ?</strong></p>\n</blockquote>\n', 'ViewCount': '486', 'Title': 'A procedure for Topological sort, proof for its correctness', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-18T19:45:06.263', 'LastEditDate': '2013-09-20T15:21:45.287', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7337', 'Tags': '<algorithms><algorithm-analysis><sorting><correctness-proof>', 'CreationDate': '2013-03-23T20:42:41.853', 'Id': '10720'},193_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the original paper of A* algorithm, <a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=a%20formal%20basis%20for%20the%20heuristic%20determination%20of%20minimum%20cost%20paths&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CDYQFjAA&amp;url=http://fai.cs.uni-saarland.de/teaching/winter12-13/heuristic-search-material/Astar.pdf&amp;ei=m-NRUeOUMYa0kAXpgIHIDw&amp;usg=AFQjCNFp9yfCwE0_B_epYI4kPmEmZjOGww&amp;bvm=bv.44342787,d.dGI" rel="nofollow"><em>A Formal Basis for the Heuristic Determination of Minimum Cost Paths</em></a>, the author proved the optimality of A* in <em>Theorem 2</em>, page 105.</p>\n\n<p>However, I cannot understand the proof. The assumption is that we have a node in $G_s$ which is not expanded by algorithm A, but in the proof we change the graph to $G_{n,\\theta}$, isn\'t it a problem?</p>\n', 'ViewCount': '96', 'Title': 'While proving optimality of the A* algorithm, why can we change graphs?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-27T13:07:35.247', 'LastEditDate': '2013-03-27T12:03:09.513', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7432', 'Tags': '<algorithms><algorithm-analysis><search-algorithms><correctness-proof>', 'CreationDate': '2013-03-27T00:57:43.747', 'Id': '10817'},193_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '210', 'Title': 'Proving correctness of the algorithm for convex polygon minimum cost triangulation', 'LastEditDate': '2013-04-07T12:38:35.643', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7336', 'FavoriteCount': '1', 'Body': '<p>I have read many solutions for the minimum cost of triangulation problem and intuitively get the idea , however I am struggling to figure out how to prove it formally. I kind of feel that it has to be proven by induction but I struggle at choosing the right quantity to look at and also at the inductive step portion of the proof.</p>\n\n<p>For example, can you provide a formal proof for the algorithm described <a href="http://users.eecs.northwestern.edu/~dda902/336/hw6-sol.pdf" rel="nofollow">here</a> (page 5 problem 6.12).</p>\n', 'Tags': '<algorithms><algorithm-analysis><dynamic-programming><recursion><correctness-proof>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:53:48.043', 'CommentCount': '2', 'AcceptedAnswerId': '11098', 'CreationDate': '2013-04-07T01:15:34.200', 'Id': '11085'},193_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '44', 'Title': 'how to prove this unsolvable problem about halting problem (turing machine)', 'LastEditDate': '2013-05-19T06:11:29.767', 'AnswerCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8244', 'FavoriteCount': '1', 'Body': u'<p>Show that the problem of deciding, for a given TM M, whether M halts for all inputs within n^2(namely n square ) steps(n is the length of the input) is unsolvable. You can use the fact without proof that the \u03b5-halting problem(that asks if a given TM halts for input \u03b5,namely, for the empty string) is unsolvable. (Hint: Use the input just to count the number of steps and basically simulate the behavior against the \u03b5 input for m steps. m may be any (easy to realize) number if it is at most n^2 and grows unlimitedly as n.).                             My answer is: Assume TM M decides whether halt or not within n^2 steps. TM S decides that when \u03b5 is a input halting or not.        use as a input of S, M1 is a TM. make a TM S:1.Use   on TM M.        2. If reject,then S rejects.        3.if accept, execute \u03b5 on M until halting. Who can tell me is this right or wrong? If it is wrong, then how to correct?</p>\n', 'ClosedDate': '2013-05-18T21:58:12.343', 'Tags': '<algorithms><complexity-classes><correctness-proof>', 'LastEditorUserId': '8244', 'LastActivityDate': '2013-05-19T06:11:29.767', 'CommentCount': '3', 'CreationDate': '2013-05-18T15:19:56.223', 'Id': '12116'},193_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am reading Algorithm design manual by Skiena. It gives proof of Insertion sort by Induction. I am giving the proof described in the below.</p>\n\n<blockquote>\n  <p>Consider the correctness of insertion sort, which we introduced at the beginning of this chapter. The reason it is correct can be shown inductively:</p>\n  \n  <ol>\n  <li>The basis case consists of a single element, and by definition a\n  one-element array is completely sorted.</li>\n  <li>In general, we can assume that the first n \u2212 1 elements of array A\n  are completely sorted after n \u2212 1 iterations of insertion sort.</li>\n  <li>To insert one last element x to A, we find where it goes, namely the\n  unique spot between the biggest element less than or equal to x and\n  the smallest element greater than x. This is done by moving all the\n  greater elements back by one position, creating room for x in the\n  desired location.</li>\n  </ol>\n</blockquote>\n\n<p>I do not understand paragraph #3. Could someone please explain it to me with an example?</p>\n', 'ViewCount': '368', 'Title': 'Insertion sort Proof by Induction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-02T22:48:42.980', 'LastEditDate': '2013-06-02T22:48:42.980', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8496', 'Tags': '<algorithms><algorithm-analysis><sorting><correctness-proof><induction>', 'CreationDate': '2013-06-02T16:03:58.043', 'Id': '12434'},193_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Apparently, if we use Djikstra's algorithm to find the shortest path between the root node and all other nodes in a weighted graph with no negative cycles, we are done after updating the distance of each node $|V| - 1$ times.</p>\n\n<p>This puzzles me because I think that a single round of breadth first search is enough. Why must we do $|V| - 1$ of these searches?</p>\n", 'ViewCount': '59', 'Title': "For Djikstra's algorithm, why are we surely done if we update all edges $|V|-1$ times?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:44:37.167', 'LastEditDate': '2013-06-10T09:44:37.167', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12572', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<algorithms><graphs><shortest-path><correctness-proof>', 'CreationDate': '2013-06-09T09:20:18.353', 'Id': '12558'},193_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to prove a bisimulation relation on $CA_{\\tau}(N)$ (communication algebra with tau-steps) and names $N$.</p>\n\n<p>It need to prove that $p!d.x||p?d.y$ is bisimular with $p!d.(x||p?d.y)+p?d.(p!d.x||y)$ by finding a suitable bisimulation relation $R$.</p>\n\n<p>I was thinking of $R=\\{(x,x) \\mid x \\text{ is a reachable state} \\} \\cup \\{(p!d.(x||p?d.y)+p?d.(p!d.x||y) \\mid x\\text{ and }y \\text{ are reachable states} \\}$.</p>\n\n<p>Is this a suitable relation? How do I prove that.</p>\n\n<p>Note: the definition of bisimularity in this book is:\n$x$ is bisimilar with $y$ when there exists and relation $R$ on automata $M$ and $M'$ with sets of states $S$, $S'$ such that:</p>\n\n<ol>\n<li>$R$ relates the reachable states</li>\n<li>$R$ relates the initial states</li>\n<li>Whenever $sRs'$ and $s$ has an $a$ step to $t$ for some $a$ in the alphabet, then there are states $s''$ and $t'$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and $s''$ has an $a$ step to $t'$ and both $sRs''$ and $tRt'$.</li>\n<li>Whenever $sRs'$ and $s'$ has an $a$ step to $t'$, then there are states $s''$ and $t$ in $S$ such that $s$ has an $\\epsilon$ path to $s''$ and $s''$ has an $a$ step to $t$ and both $s''Rs'$ and $tRt'$.</li>\n<li>Whenever $sRs'$ and $s$ has an $\\tau$ step to $t$, then there are states $s''$ and $t'$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and either:\n<ol>\n<li>$s''=t'$ or</li>\n<li>$s''$ has an $\\tau$ step to $t'$ and both $sRs'$ and $tRt'$</li>\n</ol></li>\n<li>Same as $5$, but then from $M'$ to $M$.</li>\n<li>Whenever $sRs'$ and $s'$ terminates, then there is a state $s''$ in $S'$ such that $s'$ has an $\\epsilon$ path to $s''$ and $s''$ terminates and $sRs''$.</li>\n<li>Same as 7, but then from $M'$ to $M$.</li>\n</ol>\n\n<p>How can I prove such relation?</p>\n", 'ViewCount': '56', 'Title': 'Prove a bisimulation relation', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-11T12:55:25.187', 'LastEditDate': '2013-06-11T12:55:25.187', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8588', 'Tags': '<automata><proof-techniques><correctness-proof>', 'CreationDate': '2013-06-10T08:50:59.530', 'Id': '12591'},193_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In Don Knuth\'s famous series of books, <em>The Art of Computer Programming</em>, section 2.3.1, he describes an algorithm to traverse binary tree in inorder, making use of an auxiliary stack:</p>\n\n<blockquote>\n  <p><strong>T1</strong> [Initialize.] Set stack $\\rm A$ empty and set the link variable $\\rm P\\gets T$</p>\n  \n  <p><strong>T2</strong> [$\\rm P=\\Lambda$?] If $\\rm P=\\Lambda$, go to step T4.</p>\n  \n  <p><strong>T3</strong> [Stack$\\rm \\;\\Leftarrow P$] (Now $\\rm P$ points to a nonempty binary tree that is to be traversed.) push the value of $\\rm P$ onto stack $\\rm A$, then set $\\rm P\\gets LLINK(P)$</p>\n  \n  <p><strong>T4</strong> [$\\rm P\\Leftarrow Stack$] If stack $\\rm A$ is empty, the algorithm terminates; otherwise pop the top of $\\rm A$ to $\\rm P$.</p>\n  \n  <p><strong>T5</strong> [Visit $\\rm P$] Visit $\\rm NODE(P)$. Then set $\\rm P\\gets RLINK(P)$ and return to step T2.</p>\n</blockquote>\n\n<p>We can plot a flow chart of the algorithm. In the succeeding paragraph, he gives a <em>formal proof</em> of the algorithm:</p>\n\n<blockquote>\n  <p>Starting at step T2 with $\\rm P$ a pointer to a binary tree of $n$ nodes and with the stack $\\rm A$ containing $\\rm A[1]\\dotsc A[m]$ for some $m\\ge 0$, the procedure of steps T2-T5 will traverse the binary tree in question, in inorder, and will then arrive at step T4 with stack $\\rm A$ returned to its original value $\\rm A[1]\\dotsc A[m]$.</p>\n</blockquote>\n\n<p>However, as far as I know, such a formal proof is quite different from the general method described in section 1.2.1:</p>\n\n<blockquote>\n  <p>for each box in the flow chart, that if an assertion attached to any arrow leading into the box is true before the operation in that box is performed, then all of the assertions on relevant arrows leading away from the box are true after the operation.</p>\n</blockquote>\n\n<p>In fact, such a method is somewhat equivalent to <a href="http://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>, which is used to formally check the validity of algorithms.</p>\n\n<p>Can we turn the statement mentioned to prove the traversing algorithm into a schema of Hoare logic, or the assertion-attachment of a flow chart?</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '122', 'Title': 'Question about the formal proof of the inorder traversing', 'LastActivityDate': '2013-06-11T20:17:23.337', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1715', 'Tags': '<algorithms><correctness-proof><graph-traversal><hoare-logic>', 'CreationDate': '2013-06-11T08:47:50.447', 'Id': '12610'},193_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>A typical way of proving the greedy choice property of the fractional knapsack problem is as follows:</p>\n\n<hr>\n\n<p>From Slide 5 of <a href="http://www.cs.kzoo.edu/cs215/lectures/f4-knapsack.pdf" rel="nofollow">this link</a>:</p>\n\n<p>Given: A set of items $I = \\{I_1,I_2..I_n\\}$ with weights $\\{w_1,w_2 ... w_n\\}$ and values $\\{v_1,v_2 ...v_n\\}$. Let $P$ be the problem of selecting items from $I$, with the weight limit $K$ such that the resulting value is maximum.</p>\n\n<p>Let $O = \\{o_1,o_2 ... o_j\\} \\subseteq I$ be the <strong>optimum</strong> solution of problem $P$. </p>\n\n<p>Let\xa0$G = \\{g_1,g_2 ... g_k\\} \\subseteq I$ be\xa0the\xa0greedy\xa0solution,\xa0where\xa0the\xa0 items\xa0are\xa0ordered\xa0according\xa0to the\xa0greedy\xa0choices.\xa0</p>\n\n<p>We\xa0need to\xa0show\xa0that\xa0there\xa0exists\xa0some\xa0optimal\xa0solution\xa0$O\'$\xa0that\xa0includes\xa0the\xa0choice $g_1$\n.</p>\n\n<p>CASE\xa01:\xa0$g_1$\xa0is\xa0non-\xadfractional.</p>\n\n<ol>\n<li>If\xa0$g_1$\xa0is\xa0included\xa0in $O$,\xa0then\xa0we\xa0are\xa0done.</li>\n<li>If\xa0$g_1$\xa0is\xa0not\xa0included\xa0in\xa0$O$,\xa0then\xa0we\xa0arbitrarily\xa0remove\xa0$w_{g_1}$\xa0worth\xa0of\xa0stuff from\xa0$O$\xa0and\xa0replace\xa0it\xa0with\xa0$g_1$\xa0to\xa0produce\xa0$O\'$.</li>\n<li>$O\'$ is\xa0a\xa0solution, and\xa0it\xa0is at\xa0least\xa0as\xa0good as\xa0$O$.</li>\n</ol>\n\n<hr>\n\n<p>In the above proof, step $3$ for CASE 1 merely shows that weight criteria is satisfied. How does it show that $O\'$ is also an optimal solution(i.e. in terms of value achieved), more so when we are "arbitrarily removing $w_{g_1}$ worth of stuff" without paying attention to corresponding change in value ?</p>\n\n<p><strong>UPDATE</strong>: I found the answer in terms of change in value <a href="http://oucsace.cs.ohiou.edu/~razvan/courses/cs4040/lecture15.pdf" rel="nofollow">here</a>. I am not sure if this should go into the answer part. Mods, please suggest.</p>\n', 'ViewCount': '1236', 'Title': 'Proving greedy choice property of fractional knapsack', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-05T20:37:19.433', 'LastEditDate': '2013-08-05T20:37:19.433', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'curryage', 'PostTypeId': '1', 'OwnerUserId': '8660', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><greedy-algorithms>', 'CreationDate': '2013-07-03T00:09:45.020', 'Id': '13575'},193_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm studying for the computer science GRE, and as an exercise I need to provide a recursive algorithm to compute Fibonacci numbers and show its correctness by mathematical induction.</p>\n\n<p>Here is my recursive version of an algorithm to compute Fibonacci numbers:</p>\n\n<pre><code>Fibonacci(n):\n    if n = 0 then     // base case\n        return 0\n    elseif n = 1 then // base case\n        return 1\n    else\n        return Fibonacci(n - 1) + Fibonacci(n - 2)\n    endif\n</code></pre>\n\n<p>How can I prove the correctness of this algorithm by induction?</p>\n", 'ViewCount': '1036', 'Title': 'Prove correctness of recursive Fibonacci algorithm, using proof by induction', 'LastEditorUserId': '755', 'LastActivityDate': '2013-08-31T10:28:41.523', 'LastEditDate': '2013-08-31T05:55:13.280', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9744', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><induction>', 'CreationDate': '2013-08-29T18:27:55.383', 'FavoriteCount': '1', 'Id': '14025'},193_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="https://en.wikipedia.org/wiki/Multi-label_classification" rel="nofollow">Multi-label classification</a> is a machine-learning problem where each sample can have zero or more labels from a closed set of possible labels. This task has applications in several fields. For example, in dialog systems, each sentence that the human says may have several intents, and the classifier should detect all of them. For example, the sentence "I want a cake and a drink" contains the two intents "WANTCAKE" and "WANTDRINK".</p>\n\n<p>Theoretically, I expect a classifier to classify multi-label samples, even if the training data contained only single-label samples. For example, consider the following training set (where each word is considered a feature):</p>\n\n<ul>\n<li>"I want a cake" -> WANTCAKE</li>\n<li>"I want a drink" -> WANTDRINK</li>\n<li>"I want a solution" -> WANTSOLUTION</li>\n</ul>\n\n<p>I would expect a classifier to realize, that the words "I want a" are not relevant for classification, and the words cake/drink/solution are indicative of the classes WANTCAKE/WANTDRINK/WANTSOLUTION respectively, and classify the sentence "I want a cake and a drink" correctly as {WANTCAKE,WANTDRINK}.</p>\n\n<p>This seems trivial to humans. Therefore. I was very surprised to find out, that many state-of-the-art multi-label classifiers fail miserably on this simple task!</p>\n\n<p>For example, consider a multi-label classifier in the "Binary Relevance" method. In this method, there is a single binary classifier for each label. For example, there is a binary classifier for the "WANTCAKE" label, trained with I want a cake" as a positive sample, and the other two sentences as negative samples. When this classifier sees the sentence "I want a cake and a drink and a solution", it sees a <em>single</em> feature "cake" that is a positive signal of WANTCAKE, and <em>two</em> features, "drink" and "solution", that are negative signals of WANTCAKE, because they appeared in the training set with sentences that did not have the WANTCAKE label. Therefore, this classifier returns \'negative\'. The same happens for the other two binary classifiers, and thus the multi-label classifier returns an empty set!</p>\n\n<p>I also tried other approaches to multi-label classification, such as RF-PCT (Random Forest Prediction Clustering Trees), with a slightly larger example (7 labels instead of 3) and got similar results. </p>\n\n<p>I sent this problem to machine learning experts, and they told me that I need more training data. They said that a classifier cannot tag multi-label instances, if the training data contains only single-label instances. In practice, they are right - adding more training data usually improves the accuracy of the classifier. </p>\n\n<p>But I am still bothered with the theoretical issue - how can it be, that there is no state-of-the-art classifier that can solve this trivial, 3-instance problem?</p>\n\n<p>I am looking for a classifier that provably solves such problems. I.e., a classifier for which there is a proof, that if it is given correct single-label samples, it can correctly solve multi-label cases.</p>\n\n<p>Is there such a classifier?</p>\n', 'ViewCount': '89', 'Title': 'Theory of multi-label classification', 'LastActivityDate': '2013-09-08T00:07:55.913', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14205', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<machine-learning><correctness-proof><classification>', 'CreationDate': '2013-09-03T17:41:10.823', 'Id': '14107'},193_30:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a program consisting of variables and instructions which modify these variables, and a synchronization primitive (a monitor, mutex, java's synchronized or C#'s lock), is it possible to prove that such a program is thread safe? </p>\n\n<p>Is there even a formal model for describing things like thread safety or racing conditions? </p>\n", 'ViewCount': '110', 'Title': 'Is it possible to prove thread safety?', 'LastActivityDate': '2013-09-17T14:26:49.070', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '14365', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10169', 'Tags': '<proof-techniques><correctness-proof><concurrency><threads>', 'CreationDate': '2013-09-16T15:57:39.443', 'FavoriteCount': '2', 'Id': '14356'},193_31:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a bijection problem that I cannot get my head around. It goes like this: </p>\n\n<p>let f: A -> B and g: B -> C be functions such that g o f is a bijection. Prove that f must be one-to-one and that g must be onto. And also an example showing that it is possible for neither f nor g to be a bijection. </p>\n\n<p>This is the problem. I do not even know where to begin. Any help is appreciated. </p>\n', 'ViewCount': '64', 'ClosedDate': '2013-11-01T12:55:21.657', 'Title': 'trouble with bijection definition', 'LastEditorUserId': '10282', 'LastActivityDate': '2013-10-01T04:38:49.983', 'LastEditDate': '2013-10-01T04:16:58.313', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10282', 'Tags': '<proof-techniques><discrete-mathematics><correctness-proof><partial-order>', 'CreationDate': '2013-10-01T04:01:25.823', 'Id': '14724'},193_32:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I stumbled upon this <a href="http://www.proofwiki.org/wiki/User%3aJoe" rel="nofollow">wikipage</a> that has got this proof :</p>\n\n<p><img src="http://i.stack.imgur.com/ouR52.png" alt="enter image description here"></p>\n\n<p>I rechecked <a href="http://en.wikipedia.org/wiki/Sum_rule_in_differentiation" rel="nofollow">sum rule of differentiation</a>.</p>\n\n<p>And i can not understand where is this wrong.</p>\n\n<p>Any Tips ?</p>\n\n<p>I think that the second line </p>\n\n<p>x^2 = x + x +... x times... </p>\n\n<p>being used for differentiation is wrong. but i am not sure .</p>\n', 'ViewCount': '67', 'ClosedDate': '2013-11-01T10:08:34.853', 'Title': 'What is wrong in this proof?', 'LastActivityDate': '2013-11-01T07:53:47.073', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '16614', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11032', 'Tags': '<proof-techniques><correctness-proof>', 'CreationDate': '2013-11-01T06:09:41.560', 'Id': '16613'},193_33:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For clarity, I attach below a concise implementation of the algorithm in Python. I understand that it checks all possible element swaps, but I don't see how that necessarily means that all possible orderings of the elements will be reached, and/or that no ordering will be duplicated.</p>\n\n<p>For example, what if the elements at index 0 and 1 are swapped, then 1 and 2 are swapped?  How does the algorithm guarantee this won't result in a duplicate ordering?</p>\n\n\n\n<pre><code>P = []\ndef permute(l, n=0):\n    if n == len(l):\n        return P.append(list(l))\n    for i in xrange(n, len(l)):\n        l[i], l[n] = l[n], l[i]\n        permute(l, n+1)\n        l[i], l[n] = l[n], l[i]\n</code></pre>\n", 'ViewCount': '53', 'Title': 'Is there a proof of the recursive algorithm for generating all permutations of a sequence?', 'LastActivityDate': '2013-11-28T02:19:16.190', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10768', 'Tags': '<algorithms><combinatorics><correctness-proof>', 'CreationDate': '2013-11-27T21:26:26.657', 'Id': '18423'},193_34:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a question regarding recursion in <a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" rel="nofollow">Viterbi algorithm</a>.</p>\n\n<p>Define $\\pi(k; u; v)$  which is the maximum probability for any sequence of length $k$, ending in the tag bigram $(u; v)$.</p>\n\n<p>The base case if obvious $\\pi(0,*,*)=1$</p>\n\n<p>The general case.</p>\n\n<p>$\\pi(k,u,v) = max_{w \\in K_{k-2} } \\pi(k-1,w,u) \\cdot q(v|w,u) \\cdot e(x_k|v)$</p>\n\n<p>The author justifies the recursion as folllows: </p>\n\n<blockquote>\n  <p>How can we justify this recurrence? Recall that $\\pi(k, u, v)$ is the highest probability for any sequence $y_{\u22121}...y_k$ ending in the bigram $(u, v)$. Any such sequence must have $y_{k\u22122} = w$ for some state $w$. The highest probability for any sequence of length $k \u2212 1$ ending in the bigram $(w, u)$ is $\\pi(k \u2212 1, w, u)$, hence the highest probability for any sequence of length $k$ ending in the trigram $(w, u, v)$ must be $\\pi(k \u2212 1,w, u) \\cdot q(v|w, u) \\cdot e(x_k |v)$</p>\n</blockquote>\n\n<p>I do not understand why it\'s actually true, I think it\'s possible to reach $\\pi(n,u, v)$ from any $(n-1,w, u)$ not actually the maximum one $\\pi(n-1,w, u)$ just because $q(v|w, u) \\cdot e(x_k |v)$ might have a higher influence on the resulting $(n,u, v)$ than any $\\pi(n-1,w, u)$.</p>\n\n<p>I would appreciate if anyone could explain me why it\'s true.</p>\n', 'ViewCount': '94', 'Title': 'Viterbi algorithm recursive justification', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-04T18:05:36.053', 'LastEditDate': '2014-02-04T18:05:36.053', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19109', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8473', 'Tags': '<algorithms><dynamic-programming><recursion><correctness-proof><hidden-markov-models>', 'CreationDate': '2013-12-18T13:44:43.103', 'Id': '19093'},193_35:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>what is the reason for the correctness proof of Prim's Algorithm for the undirected case cannot carry over to the directed case?</p>\n\n<p>Is it because of after any number of steps, $S$ might not be in a sub tree of an MST since it depends upon the direction of the edge of the directed graph, unlike the undirected one?</p>\n", 'ViewCount': '111', 'ClosedDate': '2014-01-05T17:29:58.513', 'Title': "Proof of Correctness of Prim's algorithm", 'LastEditorUserId': '7269', 'LastActivityDate': '2013-12-31T16:22:53.543', 'LastEditDate': '2013-12-31T13:52:39.337', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<graph-theory><correctness-proof><greedy-algorithms><spanning-trees>', 'CreationDate': '2013-12-31T12:55:44.063', 'Id': '19405'},193_36:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose we had 2 arrays of the same size with positive numbers and we wanted to pair up the elements of each array such that the total difference between the pairs is minimized.</p>\n\n<p>The first thought would be to choose pairs with the minimum difference and so on. But it turns out the correct algorithm is to sort them and them pair accordingly.</p>\n\n<p>Any ideas on how to prove that the latter algorithm correctly minimizes the sum of differences?</p>\n', 'ViewCount': '85', 'Title': 'How can we minimize the total distance of cross pairs in an array', 'LastEditorUserId': '755', 'LastActivityDate': '2014-02-21T16:31:05.690', 'LastEditDate': '2014-02-21T16:31:05.690', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21815', 'Score': '2', 'OwnerDisplayName': 'user14805', 'PostTypeId': '1', 'Tags': '<algorithms><algorithm-analysis><optimization><correctness-proof><permutations>', 'CreationDate': '2014-02-18T14:51:18.950', 'Id': '21767'},193_37:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G=(V,E)$ be a directed graph. The <strong>connectivity</strong> of a graph is the defined as the cardinality of a smallest separator of $G$. A <strong>separator</strong> of $G$ is a subset $U$ of $V$, such that $G-U$ is not strongly connected.</p>\n\n<p>Why does the following algorithm compute the connectivity of a graph correctly?</p>\n\n<p>\\begin{equation}\n\\begin{split}\n&amp;\\text{Connectivity}(\\text{graph }G=(V,E)) \\\\\n&amp;\\;\\;\\;\\;01\\text{:}\\;\\;k=\\infty \\\\\n&amp;\\;\\;\\;\\;02\\text{:}\\;\\;\\text{for }i=1,\\ldots,|V| \\\\\n&amp;\\;\\;\\;\\;03\\text{:}\\;\\;\\{\\\\\n&amp;\\;\\;\\;\\;04\\text{:}\\;\\;\\;\\;\\;\\;\\text{for each }v\\in V\\\\\n&amp;\\;\\;\\;\\;05\\text{:}\\;\\;\\;\\;\\;\\;\\{\\\\\n&amp;\\;\\;\\;\\;06\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{compute a minimum }v_i,v\\text{-seperator }U_{v_i,v}\\\\\n&amp;\\;\\;\\;\\;07\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;k=\\min\\left\\{k,\\left|U_{v_i,v}\\right|\\right\\}\\\\\n&amp;\\;\\;\\;\\;08\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if }(i&gt;k+1) \\text{ return }k\\\\\n&amp;\\;\\;\\;\\;09\\text{:}\\;\\;\\\\\n&amp;\\;\\;\\;\\;10\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{compute a minimum }v,v_i\\text{-seperator }U_{v,v_i}\\\\\n&amp;\\;\\;\\;\\;11\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;k=\\min\\left\\{k,\\left|U_{v,v_i}\\right|\\right\\}\\\\\n&amp;\\;\\;\\;\\;12\\text{:}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if }(i&gt;k+1) \\text{ return }k\\\\\n&amp;\\;\\;\\;\\;13\\text{:}\\;\\;\\;\\;\\;\\;\\}\\\\\n&amp;\\;\\;\\;\\;14\\text{:}\\;\\;\\}\n\\end{split}\n\\end{equation}</p>\n\n<p>More precisely, why can we return $k$ in line 08 (resp. 12) without concerning the other $u,v$-seperators?</p>\n', 'ViewCount': '41', 'Title': 'Proving the correctness of an algorithm, which computes the connectivity of a directed graph', 'LastActivityDate': '2014-02-19T23:39:35.870', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21828', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12502', 'Tags': '<algorithms><graph-theory><graphs><correctness-proof>', 'CreationDate': '2014-02-19T15:58:02.890', 'FavoriteCount': '1', 'Id': '21819'},193_38:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading the paper: "Maximum Weight Independent Set Of Circular-Arc Graphs and It\'s Applications" (<a href="http://link.springer.com/article/10.1007%2FBF02832044" rel="nofollow">http://link.springer.com/article/10.1007%2FBF02832044</a>). And I had a question regarding the proof of Lemma 3 in the paper. It is stated as follows.</p>\n\n<p>If $X$ is the maximum weight independent set of the circular-arc graph $A$, then for any clique $Z$ of $A$, we have that $\\| X \\cap Z\\| = 1$.</p>\n\n<p>The paper then proves this by contradiction in two cases, the first when $\\| X \\cap Z\\| \\geq 2$ and the second when $\\| X \\cap Z\\| = 0$. I buy the argument for the first case, but I am concerned about the argument they make for the case equal to 0. Their argument goes as follows: If $\\| X \\cap Z\\| = 0$, then including any vertex in $Z$ into $X$ will remain independent and the weight will be greater than the previous set, contradicting the fact that $X$ was a maximum weight independent set. To me, this statement does not seem true. </p>\n\n<p><img src="http://i.stack.imgur.com/aqVfQ.jpg" alt="Circular Graph Example"></p>\n\n<p>If we pick vertices 8, 6, and 3 to have weight 1000, and all other vertices to have weight 1, then clearly {8, 6, 3} is a maximum weight independent set. However, their exists cliques of size two (edges) that have an empty intersection with {8, 6, 3}... such as the edge {1, 2}. You can also extend this to cliques of size 3 by adding an arc that intersects with arcs {8, 2, 1} then the clique formed by this new arc and arcs 1 and 2 will have an empty intersection as well.</p>\n\n<p>So where have I gone wrong in my understanding? I feel like I must be missing something really obvious. Clarifications would be greatly appreciated!</p>\n', 'ViewCount': '34', 'Title': 'Maximum Weight Independent Set in Circular-Arc Graphs (Proof of A Lemma)', 'LastActivityDate': '2014-03-14T04:31:41.060', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<algorithms><graph-theory><correctness-proof>', 'CreationDate': '2014-03-14T04:31:41.060', 'FavoriteCount': '0', 'Id': '22608'},193_39:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We have a 0-1 knapsack in which the increasing order of items by weight is the same as the decreasing order of items by value. Design a greedy algorithm and prove that the greedy choice guarantees an optimal solution.</p>\n\n<p>Given the two orders I imagined that we could just choose the first k elements from either sequence and use them to fill knapsack until it was full. This would be similar to choosing the items with the greatest ratio of value to weight. But I don't think that is an optimal solution. </p>\n\n<p>So what I need help with is whether or not this solution is optimal. And how would I prove the correctness of a greedy algorithm. </p>\n", 'ViewCount': '63', 'Title': 'Correctness proof of greedy algorithm for 0-1 knapsack problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T16:45:47.887', 'LastEditDate': '2014-03-26T08:38:55.053', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '23060', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15512', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><greedy-algorithms><knapsack-problems>', 'CreationDate': '2014-03-26T03:23:03.477', 'Id': '23058'},193_40:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '150', 'Title': 'Could program verification techniques prevent bugs of the genre of Heartbleed from occurring?', 'LastEditDate': '2014-04-16T12:41:34.870', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'Mok-Kong Shen', 'PostTypeId': '1', 'OwnerUserId': '6437', 'FavoriteCount': '1', 'Body': '<p>On the matter of the Heartbleed bug, Bruce Schneier wrote in his Crypto-Gram of 15th April:\n\'"Catastrophic" is the right word. On the scale of 1 to 10, this is an 11.\' I read several years ago that a kernel of a certain operating system has been rigorously verified with a modern program verification system. Could hence bugs of the genre of Heartbleed be prevented from occurring via application of program verification techniques today or is this yet unrealistic or even principally impossible?</p>\n', 'Tags': '<cryptography><correctness-proof><security><software-verification><program-correctness>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-23T20:21:04.283', 'CommentCount': '1', 'CreationDate': '2014-04-15T14:30:22.640', 'Id': '23856'},193_41:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So here is the challenge problem statement: <a href="https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1512" rel="nofollow">https://icpcarchive.ecs.baylor.edu/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=1512</a> </p>\n\n<p>Basically, given a 0/1 matrix, you need to permute the columns so that the first column is fixed and after the permutation of columns, then for each row the 1\'s in the row occur contiguously (without counting wrap-around). I thought about this problem and came up with a conjecture that would make it easy to solve, but I\'m not sure if it\'s true.</p>\n\n<p>Conjecture: After the first $k$ columns have been chosen, let $S$ be the set of rows that end with a $1$ in the $k$th column, such that there exists an unchosen column that has a $1$ in that row. Then the $k+1$th column can be chosen to be the column that has (i) 1\'s for all positions in $S$, and (ii) which has a minimum total number of $1$\'s.</p>\n\n<p>Is this true? If so an optimal solution could be constructed very quickly. I know that the $k+1$th column has to satisfy condition (i), which reduces the possibilities, but I\'m really hoping we can ensure condition (ii) also holds so that the choice of $k+1$th column is essentially unique.</p>\n', 'ViewCount': '26', 'Title': 'Conjecture about a matrix column swapping challenge problem', 'LastEditorUserId': '9584', 'LastActivityDate': '2014-04-21T18:53:34.960', 'LastEditDate': '2014-04-21T18:53:34.960', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9584', 'Tags': '<algorithms><correctness-proof><greedy-algorithms><permutations>', 'CreationDate': '2014-04-21T17:15:13.210', 'Id': '23997'}