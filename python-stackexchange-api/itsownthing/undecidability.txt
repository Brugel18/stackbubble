{'ViewCount': '463', 'Title': "Rice's theorem for non-semantic properties", 'LastEditDate': '2014-02-06T20:32:46.053', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '41', 'FavoriteCount': '1', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Rice%27s_theorem" rel="nofollow">Rice\'s theorem</a> tell us that the only <em>semantic</em> properties of <a href="http://en.wikipedia.org/wiki/Turing_machines" rel="nofollow">Turing Machines</a> (i.e. the properties of the function computed by the machine) that we can decide are the two trivial properties (i.e. always true and always false).</p>\n\n<p>But there are other properties of Turing Machines that are not decidable. For example, the property that there is an unreachable state in a given Turing machine is undecidable$^{\\dagger}$.</p>\n\n<p>Is there a similar theorem to Rice\'s theorem that categorizes the decidability of similar properties? I don\'t have a precise definition. Any known theorem that covers the example I have given would be interesting for me.</p>\n\n<p>$^\\dagger$ it is easy to prove that this set is undecidable using <a href="http://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem" rel="nofollow">Kleene\'s Recursion/Fixed Point theorems</a>.</p>\n', 'Tags': '<computability><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-06T20:32:46.053', 'CommentCount': '4', 'AcceptedAnswerId': '37', 'CreationDate': '2012-03-06T22:46:52.293', 'Id': '33'}{'Body': '<p>I want to know if the following problem is decidable and how to find out. Every problem I see I can say "yes" or "no" to it, so are most problems and algorithms decidable except a few (which is provided <a href="http://en.wikipedia.org/wiki/List_of_undecidable_problems" rel="nofollow">here</a>)?</p>\n\n<blockquote>\n  <p>Input: A directed and finite graph $G$, with $v$ and $u$ as vertices<br>\n  Question: Does a path in $G$ with $u$ as initial vertex and $v$ as final vertex exist?</p>\n</blockquote>\n', 'ViewCount': '327', 'Title': 'Is this finite graph problem decidable? What factors make a problem decidable?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-30T21:37:25.987', 'LastEditDate': '2012-04-30T21:37:25.987', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '153', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<algorithms><computability><graph-theory><undecidability>', 'CreationDate': '2012-03-09T00:47:22.190', 'Id': '143'}{'Body': u'<p>Consider decision problems stated in some \u201creasonable\u201d formal language. Let\'s say formulae in higher-order Peano arithmetic with one free variable as a frame of reference, but I\'m equally interested in other models of computation: Diophantine equations, word problems from rewriting rules using Turing machines, etc. An answer expressed in any classical formalization would be fine, though if you know how much the choice of formalization influences the answer, that would also be interesting.</p>\n\n<p>Given the length $N$ of the statement of a decision problem, we can define the number $D(N)$ of decidable statements of length $N$ and the number $U(N)$ of undecidable statements of length $N$.</p>\n\n<p>What is known about the relative growth of $U(N)$ and $D(N)$? In other words, if I take a well-formed decision problem at random, what is the probability of its being decidable for a given statement length?</p>\n\n<p><sub> Inspired by <a href="http://cs.stackexchange.com/questions/143/what-factors-make-a-problem-decidable">this question</a> which asks whether \u201cmost problems and algorithms [are] decidable\u201d. Well, if you don\'t filter by interest, are they? </sub>  </p>\n', 'ViewCount': '318', 'Title': 'Ratio of decidable problems', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-22T13:05:21.823', 'LastEditDate': '2012-03-10T15:12:03.217', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-03-09T12:54:25.553', 'FavoriteCount': '5', 'Id': '155'}{'ViewCount': '274', 'Title': 'Is there a "natural" undecidable language?', 'LastEditDate': '2012-12-13T02:16:00.593', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '2', 'Body': '<p>Is there any "natural" language which is undecidable?</p>\n\n<p>by "natural" I mean a language defined directly by properties of strings, and not via machines and their equivalent. In other words, if the language looks like\n$$ L = \\{ \\langle M \\rangle \\mid \\ldots \\}$$\nwhere $M$ is a TM, DFA (or regular-exp), PDA (or grammar), etc.., then $L$ <strong>is not</strong> natural. However $L = \\{xy \\ldots \\mid x \\text{ is a prefix of y} \\ldots \\}$ is natural.</p>\n', 'Tags': '<formal-languages><automata><computability><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:16:00.593', 'CommentCount': '0', 'AcceptedAnswerId': '179', 'CreationDate': '2012-03-10T05:08:27.597', 'Id': '178'}{'Body': "<p>The halting problem cannot be solved in the general case. It is possible to come up with defined rules that restrict allowed inputs and can the halting problem be solved for that special case?</p>\n\n<p>For example, it seems likely that a language that does not allow loops for instance, would be very easy to tell if the program would halt or not.</p>\n\n<p>The problem I'm trying to solve right now is that I'm trying to make a script checker that checks for the validity of the program. Can halting problem be solved if I know exactly what to expect from script writers, meaning very predictable inputs. If this cannot be solved exactly, what are some good approximation techniques to solve this?</p>\n", 'ViewCount': '242', 'Title': 'Is it possible to solve the halting problem if you have a constrained or a predictable input?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-13T00:49:09.953', 'LastEditDate': '2012-03-13T00:20:34.387', 'AnswerCount': '5', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<computability><undecidability><software-engineering><formal-methods>', 'CreationDate': '2012-03-12T23:00:03.130', 'Id': '258'}{'Body': '<p>At the midterm there was a variant of the following question:</p>\n\n<blockquote>\n  <p>For a decidable $L$ define  $$\\text{Pref}(L) = \\{ x \\mid \\exists y \\text{ s.t. } xy \\in L\\}$$\n  Show that $\\text{Pref}(L)$ is not necessarily decidable.</p>\n</blockquote>\n\n<p>But if I choose $L=\\Sigma^*$ then I think $\\text{Pref}(L)$ is also $\\Sigma^*$, thus decidable. Also $L=\\emptyset$ gives the same result. And since $L$ must be decidable I cannot pick the halting problem or such..</p>\n\n<ol>\n<li>How can I find $L$ such the $\\text{Pref}(L)$ is not decidable?</li>\n<li>Which conditions on $L$ will make $\\text{Pref}(L)$ decidable, and which will make it undecidable?</li>\n</ol>\n', 'ViewCount': '630', 'Title': 'Decidability of prefix language', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-19T22:18:32.557', 'LastEditDate': '2013-03-19T20:27:27.193', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '287', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '157', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-03-13T03:54:05.710', 'Id': '285'}{'ViewCount': '4546', 'Title': 'How can it be decidable whether $\\pi$ has some sequence of digits?', 'LastEditDate': '2012-03-14T16:40:56.483', 'AnswerCount': '2', 'Score': '54', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '11', 'Body': '<p>We were given the following exercise.</p>\n\n<blockquote>\n  <p>Let</p>\n  \n  <p>$\\qquad \\displaystyle f(n) = \\begin{cases} 1 &amp; 0^n \\text{ occurs in the decimal representation of } \\pi \\\\ 0 &amp; \\text{else}\\end{cases}$</p>\n  \n  <p>Prove that $f$ is computable.</p>\n</blockquote>\n\n<p>How is this possible? As far as I know, we do not know wether $\\pi$ contains every sequence of digits (or which) and an algorithm can certainly not decide that some sequence is <em>not</em> occurring. Therefore I think $f$ is not computable, because the underlying problem is only semi-decidable.</p>\n', 'Tags': '<computability><undecidability>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-08-13T10:53:55.560', 'CommentCount': '2', 'AcceptedAnswerId': '369', 'CreationDate': '2012-03-14T13:19:52.857', 'Id': '367'}{'Body': "<p>OK, so here is a question from a past test in my Theory of Computation class:</p>\n\n<blockquote>\n  <p>A useless state in a TM is one that is never entered on any input string.  Let $$\\mathrm{USELESS}_{\\mathrm{TM}} = \\{\\langle M, q \\rangle \\mid  q \\text{ is a useless state in }M\\}.$$\n  Prove that $\\mathrm{USELESS}_{\\mathrm{TM}}$ is undecidable. </p>\n</blockquote>\n\n<p>I think I have an answer, but I'm not sure if it is correct.   Will include it in the answer section.</p>\n", 'ViewCount': '765', 'Title': 'A Question relating to a Turing Machine with a useless state', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T20:56:08.023', 'LastEditDate': '2012-03-25T20:56:08.023', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '637', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<computability><undecidability><formal-methods><turing-machines>', 'CreationDate': '2012-03-22T00:21:58.210', 'Id': '636'}{'Body': '<p>Do there exist undecidable languages such that their union/intersection/concatenated language is decidable? What is the physical interpretation of such example because in general, undecidable languages are not closed under these operations?</p>\n\n<p>What can we say about the kleene closure? Do we have examples for it too?  I.e. can the closure of an undecidable language be decidable?</p>\n\n<p>Also, can we generalize such undecidable classes?</p>\n', 'ViewCount': '834', 'LastEditorDisplayName': 'user1291', 'Title': "operations that aren't closed for undecidable languages", 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T08:52:26.420', 'LastEditDate': '2012-05-09T08:52:26.420', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'OwnerDisplayName': 'user1284', 'PostTypeId': '1', 'Tags': '<formal-languages><undecidability><closure-properties>', 'CreationDate': '2012-04-28T11:50:33.113', 'Id': '1549'}{'Body': '<p>One of the definitions of a computably enumerable (c.e., equivalent to recursively enumerable, equivalent to semidecidable) set is the following:</p>\n\n<blockquote>\n  <p>$A \\subseteq \\Sigma^*$ is c.e. iff there is a decidable language $V\\subseteq \\Sigma^*$ (called verifier) s.t. \n  for all $x\\in \\Sigma^*$, </p>\n  \n  <p>$x\\in A$ iff there exists a $y\\in\\Sigma^*$ s.t. $\\langle x, y \\rangle \\in V$.</p>\n</blockquote>\n\n<p>So one way to show that a language is not c.e. is to show that there is no decidable verifier $V$ for it. Is this method useful to show that languages are not c.e. in practice?</p>\n', 'ViewCount': '256', 'Title': 'Can we show a language is not computably enumerable by showing there is no verifier for it?', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-03T11:46:38.007', 'LastEditDate': '2012-04-30T08:01:59.740', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1314', 'Tags': '<computability><proof-techniques><undecidability>', 'CreationDate': '2012-04-30T05:32:15.673', 'Id': '1586'}{'Body': '<p>Are there undecidable properties of linear bounded automata (avoiding the empty set language trick)? What about for a deterministic finite automaton? (put aside intractability). </p>\n\n<p>I would like to get an example (if possible) of an undecidable problem that is defined <em>without using Turing machines</em> explicitly.</p>\n\n<p>Is Turing completeness of a model necessary to support uncomputable problems?</p>\n', 'ViewCount': '506', 'Title': 'Are there undecidable properties of non-turing-complete automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-23T18:22:59.677', 'LastEditDate': '2012-05-10T14:18:02.203', 'AnswerCount': '5', 'CommentCount': '5', 'AcceptedAnswerId': '1699', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<computability><automata><undecidability>', 'CreationDate': '2012-05-06T21:35:14.827', 'Id': '1697'}{'ViewCount': '1059', 'Title': "Why isn't this undecidable problem in NP?", 'LastEditDate': '2013-10-05T23:00:15.917', 'AnswerCount': '3', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1528', 'FavoriteCount': '2', 'Body': '<p>Clearly there aren\'t any undecidable problems in NP.  However, according to <a href="http://en.wikipedia.org/wiki/NP_%28complexity%29" rel="nofollow">Wikipedia</a>:</p>\n\n<blockquote>\n  <p>NP is the set of all decision problems for which the instances where the answer is "yes" have [.. proofs that are] verifiable in polynomial time by a deterministic Turing machine.</p>\n  \n  <p>[...]</p>\n  \n  <p>A problem is said to be in NP if and only if there exists a verifier for the problem that executes in polynomial time.</p>\n</blockquote>\n\n<p>Now consider the following problem:</p>\n\n<blockquote>\n  <p>Given a <a href="http://en.wikipedia.org/wiki/Diophantine_equation" rel="nofollow">Diophantine equation</a>, does it have any integer solutions?</p>\n</blockquote>\n\n<p>Given a solution, it\'s easy to verify in polynomial time that it really <em>is</em> a solution:  just plug the numbers into the equation.  Thus, the problem is in NP.  However, <em>solving</em> this problem is famously <a href="http://en.wikipedia.org/wiki/Hilbert%27s_tenth_problem" rel="nofollow">known to be undecidable</a>!</p>\n\n<p><em>(Similarly, it seems the halting problem should be in NP, since the "yes"-solution of "this program halts at the N-th step" can be verified in N steps.)</em></p>\n\n<p>Obviously there\'s something wrong with my understanding, but what is it?</p>\n', 'Tags': '<complexity-theory><computability><undecidability><decision-problem>', 'LastEditorUserId': '1528', 'LastActivityDate': '2013-10-05T23:00:15.917', 'CommentCount': '4', 'AcceptedAnswerId': '1902', 'CreationDate': '2012-05-17T16:50:51.853', 'Id': '1887'}{'ViewCount': '1041', 'Title': 'Is there an undecidable finite language of finite words?', 'LastEditDate': '2012-05-24T13:02:04.297', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1396', 'FavoriteCount': '2', 'Body': '<p>Is there <em>a need</em> for $L\\subseteq \\Sigma^*$ to be <em>infinite</em> to be undecidable?</p>\n\n<p>I mean what if we choose a language $L\'$ be a <em>bounded finite version of</em> $L\\subseteq \\Sigma^*$, that is $|L\'|\\leq N$, ($N \\in \\mathbb{N}$), with $L\' \\subset L$.  Is it possible for $L\'$ to be an undecidable language?  </p>\n\n<p>I see that there is a problem of "How to choose the $N$ words that $\\in$ $L\' "$ for which we have to establish a rule for choosing which would be the first $N$ elements of $L\'$, a kind of "finite" Kleene star operation. The aim is to find undecidability language without needing an infinite set, but I can\'t see it.</p>\n\n<p><strong>EDIT Note:</strong> </p>\n\n<p>Although I chose an answer, many answers <strong>and all comments</strong> are important.</p>\n', 'Tags': '<formal-languages><computability><undecidability>', 'LastEditorUserId': '1396', 'LastActivityDate': '2013-01-02T01:05:19.163', 'CommentCount': '11', 'AcceptedAnswerId': '2014', 'CreationDate': '2012-05-22T13:11:23.497', 'Id': '1990'}{'Body': '<p>From this statement </p>\n\n<blockquote>\n  <p>As there is no surjection from $\\mathbb{N}$ onto $\\mathcal{P}(\\mathbb{N})$, thus there must exist an undecidable language.</p>\n</blockquote>\n\n<p>I would like to understand why similar reasoning does not work with a <em>finite</em> set $B$ which also has no surjection onto $\\mathcal{P}(B)$!  (with $|B|=K$ and $K \\in \\mathbb{N}$)</p>\n\n<p>Why is there a minimum need for the infinite set? </p>\n\n<p><strong>EDIT Note:</strong> </p>\n\n<p>Although I chose an answer, many answers <strong>and all comments</strong> are important.</p>\n', 'ViewCount': '161', 'Title': 'Why absence of surjection with the power set is not enough to prove the existence of an undecidable language?', 'LastEditorUserId': '1396', 'LastActivityDate': '2012-05-24T13:02:44.670', 'LastEditDate': '2012-05-24T13:02:44.670', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1997', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2012-05-22T14:23:03.890', 'Id': '1993'}{'ViewCount': '138', 'Title': 'Semi-decidable problems with linear bound', 'LastEditDate': '2012-06-21T20:32:07.537', 'AnswerCount': '2', 'Score': '5', 'OwnerDisplayName': 'Joachim Breitner', 'PostTypeId': '1', 'OwnerUserId': '1913', 'Body': u'<p>Take a semi-decidable problem and an algorithm that finds the positive answer in finite time. The run-time of the algorithm, restricted to inputs with a positive answer, cannot be bounded by a computable function. (Otherwise we\u2019d know how long to wait for a positive answer. If the algorithm runs longer than that we know that the answer is no and the problem would be solvable.)</p>\n\n<p>My question is now: Can such an algorithm still have a, say, a run-time bound linear (polynomial, constant,...) in the input size, but with an uncomputable constant? Or would that still allow me to decide the problem? Are there example?</p>\n', 'Tags': '<computability><time-complexity><undecidability>', 'LastEditorUserId': '1728', 'LastActivityDate': '2012-06-21T20:32:07.537', 'CommentCount': '2', 'AcceptedAnswerId': '2426', 'CreationDate': '2012-06-20T07:52:13.637', 'Id': '2425'}{'ViewCount': '1439', 'Title': "Perplexed by Rice's theorem", 'LastEditDate': '2012-11-26T12:04:48.433', 'AnswerCount': '2', 'Score': '21', 'PostTypeId': '1', 'OwnerUserId': '1951', 'FavoriteCount': '5', 'Body': '<p><strong>Summary:</strong> According to Rice\'s theorem, everything is impossible. And yet, I <em>do</em> this supposedly impossible stuff <em>all the time!</em></p>\n\n<hr>\n\n<p>Of course, Rice\'s theorem doesn\'t simply say "everything is impossible". It says something rather more specific: "Every property of a computer program is non-computable."</p>\n\n<p>(If you want to split hairs, every "non-trivial" property. That is, properties which <em>all</em> programs posses or <em>no</em> programs posses are trivially computable. But any other property is non-computable.)</p>\n\n<p>That\'s what the theorem says, or appears to say. And presumably a great number of very smart people have carefully verified the correctness of this theorem. But it seems to completely defy logic! There are <em>numerous</em> properties of programs which are <em>trivial</em> to compute!! For example:</p>\n\n<ul>\n<li><p>How many steps does a program execute before halting? To decide whether this number is finite or infinite is precisely the Halting Problem, which is non-computable. To decide whether this number is greater or less than some finite $n$ is <em>trivial!</em> Just run the program for up to $n$ steps and see if it halts or not. Easy!</p></li>\n<li><p>Similarly, does the program use more or less than $n$ units of memory in its first $m$ execution steps? Trivially computable.</p></li>\n<li><p>Does the program text mention a variable named $k$? A trivial textual analysis will reveal the answer.</p></li>\n<li><p>Does the program invoke command $\\sigma$? Again, scan the program text looking for that command name.</p></li>\n</ul>\n\n<p>I can see plenty of properties that <em>do</em> look non-computable as well; e.g., how many additions does a complete run of the program perform? Well, that\'s nearly the same as asking how many <em>steps</em> the program performs, which is virtually the Halting Problem. But it looks like there are boat-loads of program properties which a really, really <em>easy</em> to compute. And yet, Rice\'s theorem insists that none of them are computable.</p>\n\n<p>What am I missing here?</p>\n', 'Tags': '<computability><terminology><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-26T18:26:22.353', 'CommentCount': '1', 'AcceptedAnswerId': '6928', 'CreationDate': '2012-07-18T09:23:10.527', 'Id': '2811'}{'Body': "<p>I'm trying to prove that </p>\n\n<p>$L_1=\\{\\langle M\\rangle \\mid M \\text{ is a Turing machine and visits } q_0 \\text{ at least twice on } \\varepsilon\\} \\notin R$.</p>\n\n<p>I'm not sure whether to reduce the halting problem to it or not. I tried to construct a new machine $M'$ for $(\\langle M \\rangle,w)$, such that $M'$ visits $q_0$ twice, iff $M$ halts on $w$. This is specific $q_0$ given to me, but I didn't come to any smart construction, which would yield the requested. Maybe it's easier to show that it's $RE$ and not $coRE$? It is obvious that it's in $RE$, and I need to show that $L_2^{c}$ is not in $RE$.</p>\n\n<p>What should I do?</p>\n", 'ViewCount': '134', 'Title': 'Showing that the set of TMs which visit the starting state twice on the empty input is undecidable', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-02T05:53:06.110', 'LastEditDate': '2012-08-01T15:00:46.580', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2984', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-08-01T12:41:06.703', 'Id': '2981'}{'Body': '<p>I know that given two problems are undecidable it does not follow that their intersection must be undecidable. For example, take a property of languages $P$ such that it is undecidable whether the language accepted by a given pushdown automaton $M$ has that property. Clearly $P$ and $\\lnot P$ are undecidable (for a given $M$) but $P \\cap \\lnot P$ is trivially decidable (it is always false).</p>\n\n<p>I wonder if there are any "real life" examples which do not make use of the "trick" above? When I say "real life" I do not necessarily mean problems which people come across in their day to day life, I mean examples where we do not take a problem and it\'s complement. It would be interesting (to me) if there are examples where the intersection is not trivially decidable.</p>\n', 'ViewCount': '485', 'Title': 'Examples of undecidable problems whose intersection is decidable', 'LastEditorUserId': '769', 'LastActivityDate': '2012-08-02T11:57:36.140', 'LastEditDate': '2012-08-02T09:20:43.607', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '3002', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '769', 'Tags': '<reference-request><undecidability><decision-problem>', 'CreationDate': '2012-08-01T13:04:25.613', 'Id': '2982'}{'Body': '<p>I wonder how come that the following language is in $\\mathrm R$.</p>\n\n<p>$L_{M_1}=\\Bigl\\{\\langle M_2\\rangle \\;\\Big|\\;\\; M_2 \\text{ is a TM, and } L(M_1)=L(M_2), \\text{ and } |\\langle M_1\\rangle| &gt; | \\langle M_2 \\rangle| \\Bigr\\} $</p>\n\n<p>(I know that it\'s in $\\mathrm R$ since there\'s an answer for this multi-choice question, but without explanation).</p>\n\n<p>I immediately thought that the $L_{M_1} \\notin \\textrm{co-RE} \\cup \\textrm{RE}$  since we know that checking if two machines accept the same language is really not decidable, I came to think: is it immediate "False", but it can\'t be since there\'s a lot of Turing machines who accepts the same answer and have different codings.</p>\n\n<p>Thanks! </p>\n', 'ViewCount': '127', 'Title': 'For a Turing Machine $M_1$, how is the set of machines $M_2$ which are "shorter" than $M_1$ and which accept the same language decidable?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-13T05:44:48.050', 'LastEditDate': '2012-08-13T05:44:48.050', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3091', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-08-08T12:01:12.723', 'Id': '3090'}{'Body': '<p><em>F</em>&nbsp;=&nbsp;{&nbsp;&lang;<em>M</em>&rang;&nbsp;: <em>M</em> is a turing machine which stops on every input in no more than 50 steps&nbsp;}. </p>\n\n<p>I need to decide whether <em>F</em> is decidable or recursive enumerable.</p>\n\n<p>This "50 steps" part immediate turns the <strong>R</strong> sign for me, I know that if it was for specific input it was decidable for sure, but here it\'s for every input, so I need to check it for all inputs in some way. checking it for infinite inputs makes me think that the problem is <strong>co-RE</strong>, <em>i.e.</em>&nbsp;its complement is acceptable, but still I\'m not sure.</p>\n\n<p>I have a feeling it\'s decidable, but I don\'t know to prove it, Any help?</p>\n\n<p>Or maybe I can check the configurations and see that all configurations after 50 steps don\'t lead to accept state- how do I do that?</p>\n', 'ViewCount': '930', 'Title': 'Is the set of Turing machines which stop in at most 50 steps on all inputs, decideable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-09T21:03:55.937', 'LastEditDate': '2012-08-09T21:03:55.937', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '3105', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-08-09T10:27:53.680', 'Id': '3101'}{'Body': "<p>I'd like your help with proving that the language\n$$L=\\{\\langle M \\rangle \\mathrel| L(M) \\in \\mathrm{NP}\\smallsetminus \\mathrm{P} \\}$$\nis decidable iff $\\mathrm{P}=\\mathrm{NP}$.</p>\n\n<p>If $\\mathrm{P}=\\mathrm{NP}$, I get that it's the language of empty Turing machines. So $L$ is a $\\text{co-RE}$ problem &mdash; but that's not what's being asked, so I got confused.</p>\n\n<p>I know that in order to show $\\mathrm{P}=\\mathrm{NP}$, I need to show problem which it's $\\mathrm{NPC}$ and $\\mathrm{P}$ as well.</p>\n\n<p>Any help? \nThanks!</p>\n", 'ViewCount': '126', 'Title': 'How to show that the set of machines which accept languages in $\\mathrm{NP}\\smallsetminus\\mathrm P$, is decidable only if $\\mathrm P=\\mathrm{NP}$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-09T21:03:07.123', 'LastEditDate': '2012-08-09T21:03:07.123', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<computability><undecidability><p-vs-np>', 'CreationDate': '2012-08-09T11:56:04.413', 'Id': '3103'}{'ViewCount': '572', 'Title': 'Is it decidable whether a TM reaches some position on the tape?', 'LastEditDate': '2012-08-11T12:12:07.167', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1183', 'FavoriteCount': '1', 'Body': "<p>I have these questions from an old exam I'm trying to solve. For each problem, the input is an encoding of some Turing machine $M$.</p>\n\n<blockquote>\n  <p>For an integer $c&gt;1$, and the following three problems:</p>\n  \n  <ol>\n  <li><p>Is it true that for every input $x$, M does not pass the $|x|+c$ position when running on $x$?</p></li>\n  <li><p>Is it true that for every input $x$, M does not pass the $\\max \\{|x|-c,1 \\}$ position when running on $x$?</p></li>\n  <li><p>Is it true that for every input $x$, M does not pass the $(|x|+1)/c$ position when running on $x$?</p></li>\n  </ol>\n  \n  <p>How many problems are decidable? </p>\n</blockquote>\n\n<p>Problem number (1), in my opinion,  is in $\\text {coRE} \\smallsetminus \\text R$ if I understand correct since, I can run all inputs in parallel, and stop if some input reached this position and for showing that it's not in $\\text R$ I can reduce the complement of <strong>Atm</strong> to it. I construct a Turing machine $M'$ as follows: for an input $y$ I check if $y$ is a history of computation, if it is, then $M'$ running right and doesn't stop, if it's not, then it stops.</p>\n\n<p>For (3), I believe that it is decidable since for $c \\geqslant 2$ it is all the Turing machines that always stay on the first cell of the stripe, since for a string of one char it can pass the first cell, so I need to simulate all the strings of length 1 for $|Q|+1$ steps (Is this correct?), and see if I'm using only the first cell in all of them.</p>\n\n<p>I don't really know what to do with (2).</p>\n", 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '1183', 'LastActivityDate': '2012-08-12T03:39:42.523', 'CommentCount': '2', 'AcceptedAnswerId': '3127', 'CreationDate': '2012-08-10T19:10:45.963', 'Id': '3119'}{'Body': "<p>Does accepting mean that the TM will read and recognize a char from the cell it's currently reading from? And is it the case that a TM halts iff the input is decidable?</p>\n", 'ViewCount': '548', 'Title': 'What is the difference between halting, accepting, and deciding in the context of Turing machines?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T13:08:49.083', 'LastEditDate': '2012-09-15T13:08:49.083', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '3556', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2835', 'Tags': '<terminology><turing-machines><undecidability>', 'CreationDate': '2012-09-15T01:49:13.377', 'Id': '3554'}{'Body': '<p>I\'d like to understand what approaches should one adopt when deciding/proving that a given function <em>F</em> is uncomputable, by any Turing Machine (TM). The ones I\'ve tried so far are as follows:</p>\n\n<ul>\n<li>Reduction, from a known uncomputable function (such as $UC(\\alpha)$, the uncomputable function as proved by Cantor\'s diagonalization argument in Chapter 1 of the book "Computational Complexity" by Sanjeev Arora and Boaz Barak, or $HALT(\\alpha, x)$, which is nothing but the function in the <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="nofollow">Halting problem</a>), to <em>F</em>. If such a reduction is possible, it can be argued that <em>F</em> is uncomputable as otherwise, the problems that are proved to be uncomputable would become be computable as well.</li>\n<li>Proof by contradiction, in which one shows that if there is a TM <em>M</em> that computes <em>F</em>, it would lead to some sort of inconsistency in either the <em>M</em>\'s output, or the functions evaluated value.</li>\n</ul>\n\n<p>I\'ve applied (or rather, tried to apply) both the above techniques to some reductions, two of which I now state here (for illustrating the limitations of my approach):</p>\n\n<blockquote>\n  <ol>\n  <li><p>If whenever a TM <em>M</em> accepts a string <em>w</em> $\\in$ ${\\{0,1\\}}^*$, it also accepts $w^R$, the TM <em>M</em> is said to possess property <em>R</em>. ($w^R$ is the string obtained by reversing $w$ i.e. $(110)^R$ is $011$). Let $R: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: $R(\\alpha) = 1$ if $M_\\alpha$ possesses property $R$, and $R(\\alpha) = 0$ otherwise. Prove that $R$ is uncomputable.</p></li>\n  <li><p>Let $B: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: \n  $B(\\alpha,x) = 1$ if $M_\\alpha$ writes a non-blank symbol on its output tape while computing input $x$, $B(\\alpha,x) = 0$ otherwise. Prove that function $B$ is uncomputable.</p></li>\n  </ol>\n</blockquote>\n\n<p>For problem 1, I tried reducing the uncomputable function $UC$ to $R$, but the reason I couldn\'t quite complete the reduction is because $R$ is a property of the Turing Machine, not dependent on any input instance, where $UC$ depends on the output of a specific instance $M_\\alpha(\\alpha)$. Also, for both $R(\\alpha)$ = 0 and $R(\\alpha)$ = 1, it is possible that $M_\\alpha$ can go on indefinitely for some inputs! </p>\n\n<p>For problem 2, I tried reducing the function $HALT$ to $B$ (thus attempting to make a TM that computes $HALT(\\alpha,x)$ by using the output of a TM $M_\\beta$ that computes $B$). But here as in problem 1, <em>it is possible</em> that for both outputs of $M_\\beta(\\alpha,x)$, the TM $M_\\alpha$ may not halt at all on input $x$! </p>\n\n<p>So, I\'m stumped here - I understand intuitively why these functions should be uncomputable (No TM should be able to predict whether another TM would halt/output anything on any possible input), I\'m not quite able to derive a concrete proof! So, I really want to understand what approaches am I missing here, or are there holes in the current approaches that I\'ve tried so far!</p>\n\n<p>Note: For self-containment, I\'m stating what are the functions UC and HALT here as well:</p>\n\n<p>$UC: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$UC(\\alpha) = 0$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ = 1</p>\n\n<p>$UC(\\alpha) = 1$, otherwise.</p>\n\n<p>$HALT: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$HALT(\\alpha, x) = 1$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ halts on input $x$.</p>\n\n<p>$HALT(\\alpha, x) = 0$, otherwise.</p>\n', 'ViewCount': '338', 'Title': 'What approaches are most useful when proving uncomputability of a given function?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-20T12:16:37.440', 'LastEditDate': '2012-09-16T21:19:35.027', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '476', 'Tags': '<computability><turing-machines><proof-techniques><undecidability>', 'CreationDate': '2012-09-16T20:40:29.383', 'FavoriteCount': '1', 'Id': '4577'}{'Body': '<p>There are two context-sensitive languages, $L_1$ and $L_2$. Which of the following statements about them are decidable respectively undecidable?</p>\n\n<ol>\n<li>$L_1 = \\emptyset$</li>\n<li>$L_1 = \\Sigma^*$</li>\n<li>$L_1 \\cap L_2 = \\emptyset$</li>\n<li>$\\overline{L_1}$ is also a context-sensitive language.</li>\n<li>$L_1 = L_2$</li>\n</ol>\n', 'ViewCount': '238', 'Title': 'Which properties of context sensitive languages are decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-10T14:20:05.680', 'LastEditDate': '2012-10-10T14:17:55.793', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4997', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3138', 'Tags': '<formal-languages><undecidability><context-sensitive>', 'CreationDate': '2012-10-10T09:17:09.567', 'Id': '4992'}{'Body': '<p>I have come across the following interesting problem: let $p,q$ be polynomials over the field of real numbers, and let us suppose that their coefficients are all integer (that is, there is a finite exact representation of these polynomials). If needed, we may suppose that the degree of both polynomials is equal. Let us denote by $x_p$ (resp. $x_q$) the greatest absolute value of some (real or complex) root of the polynomial $p$ (resp. $q$). Is the property $x_p = x_q$ decidable?</p>\n\n<p>If not, does this property hold for some restricted families of polynomials? In the context from which this problem arises, the polynomials are characteristic polynomials of matrices, and their roots are eigenvalues.  </p>\n\n<p>I am aware of some numerical algorithms for computing roots of polynomials / eigenvalues, however these seem to be of no use here, since the output of these algorithms is only approximate. It seems to me that computer algebra might be useful here, however, unfortunately, I do not have almost any knowledge in that field.</p>\n\n<p>I am not searching for a detailed solution to this problem, however any intuition and ideas where to search for the solution would be helpful. </p>\n\n<p>Thank you in advance.</p>\n', 'ViewCount': '109', 'Title': 'Decidability of a problem concerning polynomials', 'LastActivityDate': '2012-10-16T19:19:49.487', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6091', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2091', 'Tags': '<computability><undecidability><computer-algebra>', 'CreationDate': '2012-10-15T07:37:19.173', 'Id': '6088'}{'ViewCount': '257', 'Title': 'Are all context-sensitive languages decidable?', 'LastEditDate': '2012-10-16T12:12:02.693', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '2', 'Body': '<p>I was going through the <a href="http://en.wikipedia.org/wiki/Context-sensitive_language">Wikipedia definition of <em>context-sensitive language</em></a> and I found this:</p>\n\n<blockquote>\n  <p>Each category of languages is a proper subset of the category directly above it. Any automaton and any grammar in each category has an equivalent automaton or grammar in the category directly above it.</p>\n</blockquote>\n\n<p>I could see that linear-bounded automaton is directly below decider in the article\'s ordering. If this is the case, then that means every computation on a LBA will halt at some point (since every LBA would be a decider). But I feel that there may be some computation which can run on a LBA at the same time never to halt. For example we can write a computation on LBA which would</p>\n\n<ol>\n<li>read the first symbol on the tape and move right;</li>\n<li>read the next symbol and move back left.</li>\n</ol>\n\n<p>This (useless) computation (which is obviously a LB computation) would run indefinitely oscillating left and right and never halt and hence cannot be a decider. Where am I thinking wrong?</p>\n', 'Tags': '<formal-grammars><turing-machines><undecidability><context-sensitive>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-17T06:19:22.953', 'CommentCount': '1', 'AcceptedAnswerId': '6109', 'CreationDate': '2012-10-16T11:57:26.330', 'Id': '6108'}{'Body': '<p>I know that we can visualize a Non deterministic TM as a TM which splits into multiple copies of itself whenever it sees a non deterministic path (Yes, I also know that this is just a visualization and is usually used by beginners like me for understanding non determistisism). </p>\n\n<p>Further, I also know that a Decider is a TM that halts on all possible inputs.</p>\n\n<p>Now, my question is how can I visualize a Non determistic Decider? Does a non-determistic decider mean a TM where</p>\n\n<ol>\n<li>All the copies must halt, (OR)</li>\n<li>At-least one copy halts.</li>\n</ol>\n\n<p>Kindly explain in detail why so. Thanks.</p>\n', 'ViewCount': '181', 'Title': 'Visualizing a Non Deterministic Decider', 'LastActivityDate': '2013-06-30T16:13:23.483', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '6257', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2137', 'Tags': '<turing-machines><undecidability><nondeterminism>', 'CreationDate': '2012-10-23T06:42:09.307', 'FavoriteCount': '1', 'Id': '6253'}{'Body': "<blockquote>\n  <p>$L_0 = \\{ \\langle M, w, 0 \\rangle \\mid \\text{$M$ halts on $w$}\\}$ <br>\n  $L_1 = \\{ \\langle M, w, 1 \\rangle \\mid \\text{$M$ does not halt on  $w$}\\}$</p>\n  \n  <p>$L = L_0 \\cup L_1$</p>\n</blockquote>\n\n<p>I need to determine where in the hierarchy of languages (recursive, recursively enumerable, not recursively enumerable) $L$ and its complement $\\overline L$ belong. I reasoned as follows</p>\n\n<p>$L = \\{ \\langle M, w, x\\rangle  \\mid \\text{$M$ halts on $w$ when $x=0$, $M$ doesn't halt on $w$ when $x = 1$, $x \\in \\{0, 1\\}$}\\}$</p>\n\n<p>$L$ is clearly not recursively enumerable as a Turing machine wouldn't be able accept in all cases.  It can accept only in case the input refers to $L_0$, but can't in case the input refers to $L_1$.</p>\n\n<p>$\\overline L = \\overline L_0 \\cap \\overline L_1 = \\emptyset$<br>\nThus $\\overline L$ is recursive.</p>\n\n<p>Is my reasoning ok? This is a question from a previous exam paper.</p>\n", 'ViewCount': '121', 'Title': 'Determining the classification of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-26T14:27:29.443', 'LastEditDate': '2012-10-26T14:27:29.443', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6310', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><turing-machines><undecidability><halting-problem>', 'CreationDate': '2012-10-25T13:39:53.527', 'Id': '6309'}{'Body': '<p>Does anybody know a good definition of 2 decision / optimization problems being equivalent? </p>\n\n<p>I am asking since for example allowing polynomial time computations any 2 problems in NP could be considered equivalent.</p>\n', 'ViewCount': '165', 'Title': 'When are 2 decision/optimization problems equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-31T09:52:13.867', 'LastEditDate': '2012-10-31T09:52:13.867', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6394', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4404', 'Tags': '<complexity-theory><terminology><undecidability>', 'CreationDate': '2012-10-30T18:42:29.597', 'Id': '6393'}{'Body': "<p>I am trying to teach myself computability theory with a textbook. According to my book, a function $f$ over an alphabet $A=\\{a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\\}$ is only computable iff the language</p>\n\n<p>$$\nL = \\{s\\#^j\\sigma : s\\in A^*, \\sigma \\in A, \\text{ the }j\\text{'th symbol of } f(s)\\text{ is } \\sigma\\}$$</p>\n\n<p>is decidable. Why is that? Couldn't a function $f$ be not computable even if $L$ is decidable?</p>\n", 'ViewCount': '102', 'Title': 'Can $f$ be not computable even if $L$ is decidable?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-31T21:55:23.710', 'LastEditDate': '2012-10-31T21:55:23.710', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6407', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4414', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2012-10-31T21:31:58.657', 'Id': '6406'}{'Body': '<p>A <a href="http://en.wikipedia.org/wiki/Formal_grammar" rel="nofollow">grammar</a> is <em><a href="http://en.wikipedia.org/wiki/Ambiguous_grammar" rel="nofollow">ambiguous</a></em> if at least one of the words in the\nlanguage it defines can be parsed in more than one way. A simple example of an ambiguous grammar\n$$\n   E \\rightarrow E+E \\ |\\ E*E \\ |\\ 0 \\ |\\ 1 \\ |\\ ...\n$$\nbecause the string 1+2*3 can be parsed as (1+2)*3 and 1+(2*3).  For\ncontext free grammars (CFGs) ambiguity is not decidable [1, 2]. This implies that non-ambiguity is also not decidable. Moreover, at least one of ambiguity and\nnon-ambiguity cannot even be recursively enumerable, for otherwise\nambiguity of a given CFG $G$ could be decided by running the\nenumeration of ambiguity and non-ambiguity together and seeing which\none contains $G$ (and one of them must).</p>\n\n<p>So which problem is harder in this sense? Ambiguity or non-ambiguity?</p>\n\n<ol>\n<li><p>D. G. Cantor, On The Ambiguity Problem of Backus Systems.</p></li>\n<li><p>R. W. Floyd, On ambiguity in phrase structure languages.</p></li>\n</ol>\n', 'ViewCount': '127', 'Title': 'Hardness of ambiguity/non-ambiguity for context-free grammars', 'LastEditorUserId': '2887', 'LastActivityDate': '2012-11-03T16:47:16.880', 'LastEditDate': '2012-11-03T16:47:16.880', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6464', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<computability><formal-grammars><context-free><undecidability><ambiguity>', 'CreationDate': '2012-11-03T14:29:51.043', 'Id': '6463'}{'Body': "<p>I've read first-order logic is in general undecidable, and that could be decidable only when working with unary operators. (I think that's propositional logic, correct me if I am wrong)</p>\n\n<p>The question is <strong>why arity leads to undecidable problems?</strong></p>\n\n<p>I would like to see some reference material, or at least some simple <em>example</em> of it, as a way to think in this passage from unary to n-ary and why it leads to undecidable problems. </p>\n", 'ViewCount': '157', 'Title': 'First-order logic arity defines decidability?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T10:58:10.357', 'LastEditDate': '2012-11-05T17:16:52.103', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6489', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<reference-request><logic><undecidability><satisfiability><first-order-logic>', 'CreationDate': '2012-11-05T15:10:08.337', 'Id': '6488'}{'ViewCount': '101', 'Title': 'Reduction of A_LBA to E_LBA', 'LastEditDate': '2012-11-06T20:48:13.643', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Kevin Stadler', 'PostTypeId': '1', 'OwnerUserId': '4479', 'Body': "<p>I have a rather interesting one to ponder and would love if I could get an answer for it. We were discussing the topic of mapping reduction today in my Computing theory course and I was wondering why this reduction can't exist, $A_{LBA} \\leq_{m} E_{LBA}$, since both of them are linear bound automata (LBAs). I do realize that $E_{LBA}$ is undecidable, $A_{LBA}$ is decidable, and the normal proof uses $A_{TM}$, or $E_{TM}$, to prove the undecidibility of $E_{LBA}$. I am just curious why the proof is using a TM to prove an LBA. But, my Professor could not come up with a solution to my confusion. I was wondering is this possible, if so, why or why not.</p>\n\n<p><strong>Definitions:</strong></p>\n\n<p>$A_{LBA} = \\{\\langle M, w\\rangle \\mid \\text{$M$ is a linear bound automaton that accepts the string $w$}\\}$</p>\n\n<p>$E_{LBA} = \\{\\langle M \\rangle \\mid \\text{$M$ is a linear bound automaton with $L(M)=\\emptyset$}\\}$</p>\n\n<p>$A_{TM}$ and $E_{TM}$ are the equivalent problems for Turing Machines.</p>\n", 'Tags': '<computability><turing-machines><reductions><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T20:48:13.643', 'CommentCount': '0', 'AcceptedAnswerId': '6516', 'CreationDate': '2012-11-06T05:19:27.213', 'Id': '6515'}{'Body': '<p>I have a book that proves the halting problem with this simple statement:</p>\n\n<p>$$\nA_\\text{TM} \\le_m  \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon\n$$</p>\n\n<p>It states that halting problem reduces to the language consisting of $\\langle M, \\omega \\rangle$ for which a Turing machine $M$ accepts $\\omega$ is undecidable.</p>\n\n<p>What does this mean? What does the notation $\\le_m$ indicate?</p>\n', 'ViewCount': '88', 'Title': 'Why does $A_\\text{TM} \\le_m \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon$?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-12T09:28:48.157', 'LastEditDate': '2012-11-07T20:47:20.573', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '7902', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-11-07T19:55:12.923', 'Id': '6541'}{'ViewCount': '533', 'Title': 'How do I show that whether a PDA accepts some string $\\{ w!w \\mid w \\in \\{ 0, 1 \\}^*\\}$ is undecidable?', 'LastEditDate': '2012-11-12T11:36:31.860', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2860', 'FavoriteCount': '1', 'Body': "<p>How do I show that the problem of deciding whether a PDA accepts some string of the form $\\{ w!w \\mid w \\in \\{ 0, 1 \\}^*\\}$ is undecidable?</p>\n\n<p>I have tried to reduce this problem to another undecidable one such as whether two context-free grammars accept the same language. However, I'm not sure how to use it as a subroutine.</p>\n", 'Tags': '<formal-languages><automata><context-free><undecidability><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-23T22:02:29.330', 'CommentCount': '0', 'AcceptedAnswerId': '6630', 'CreationDate': '2012-11-12T05:00:51.627', 'Id': '6626'}{'Body': u'<p>Here\'s a lab from a first-year computer science course, taught in Scheme: <a href="https://www.student.cs.uwaterloo.ca/~cs135/assns/a07/a07.pdf">https://www.student.cs.uwaterloo.ca/~cs135/assns/a07/a07.pdf</a></p>\n\n<p>At the end of the lab, it basically presents the halting problem, and shows that it is impossible to solve by introducing the function <code>diagonal</code>, which is defined as:</p>\n\n<pre><code>(de\ufb01ne (diagonal x)\n  (cond\n     [(halting? x x) (eternity 1)]\n     [else true]))\n</code></pre>\n\n<p>Where <code>eternity</code> is a non-terminating program defined as <code>(define (eternity x) (eternity x))</code>. What happens when you feed <code>diagonal</code> its own definition as input ... ?</p>\n\n<p>This is all fairly standard stuff. Then, the lab says: </p>\n\n<blockquote>\n  <p>For a real challenge, de\ufb01nitively answer the question posed at the end of Exercise 20.1.3 of the\n  text, with the interpretation that function=? consumes two lists representing the code for the two\n  functions. This is the situation Church considered in his proof.</p>\n</blockquote>\n\n<p>So the gist of it is that <code>function=?</code> takes two inputs. Each is a list, which represents the definition of a function, i.e. it is a list of the form <code>(define (id args ...) body ...)</code>. We can assume that both functions are syntactically valid and will terminate for all inputs (without runtime errors). <code>function=?</code> returns true if and only if the two functions will always return the same result when given the same inputs. For example,</p>\n\n<pre><code>(function=? \'(define (foo x) (* 2 x)) \n            \'(define (bar x) (+ x x))) ; should return #t\n\n(function=? \'(define (foo x) (+ x 1)) \n            \'(define (bar x) (+ x 2))) ; should return #f\n</code></pre>\n\n<p>Now, <code>function=?</code> is obviously impossible to write - the challenge is to <em>prove</em> it is impossible. I thought about this for a while, and the best solution I could come up with is the following:</p>\n\n<pre><code>(define (disprove-function=? x)\n  ((lambda (snip)\n     (let ((self (list \'define \'(disprove-function=? x)\n                       (list snip (list \'quote snip)))))\n       (if (function=? self \'(define (id x) x))\n           (list x)\n           x)))\n   \'(lambda (snip) \n      (let ((self (list \'define \'(disprove-function=? x)\n                        (list snip (list \'quote snip)))))\n        (if (function=? self \'(define (id x) x))\n            (list x)\n            x)))))\n</code></pre>\n\n<p>Basically, <code>disprove-function=?</code> uses standard quining techniques to generate its own source code (the variable <code>self</code>), and then asks <code>function=?</code> if it is equivalent to the identity function. If <code>function=?</code> says #f, then <code>disprove-function=?</code> will always behave like the identity function. Contradiction! If <code>function=?</code> says #t, then <code>disprove-function=?</code> will always behave differently from identity; in particular, it will behave like the <code>list</code> function. Contradiction! Thus, <code>function=?</code> can\'t exist. QED.</p>\n\n<p>My question is: is there a more elegant way to approach this problem? My solution seems ... long and ugly. Not nearly as nice as the <code>diagonal</code> function for proving that the halting problem is unsolvable.</p>\n\n<p>NB: Please give me answers and not hints! Even though this is a homework question, it is not <em>my</em> homework question: I don\'t go to this university! Further, as you can see from the lab, this question is under the <code>Enhancements</code> category and isn\'t worth marks, so even if you don\'t believe me, there is still no problem with just giving me an answer. Finally, I already <em>have</em> a solution, which I am pretty sure is right; I was just wondering if there was a <em>better</em> solution.</p>\n', 'ViewCount': '115', 'Title': 'Showing the function=? is impossible', 'LastEditorUserId': '4720', 'LastActivityDate': '2012-11-27T01:00:44.990', 'LastEditDate': '2012-11-25T02:06:41.870', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6936', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4720', 'Tags': '<undecidability><lambda-calculus><halting-problem>', 'CreationDate': '2012-11-25T01:41:33.743', 'Id': '6879'}{'Body': "<p>Given $n \\in \\mathbb{N}$ and  $p,q \\in \\mathbb{N}[x_1,\\ldots,x_n]$  one can define the following formula in the language of formal arithmetics</p>\n\n<p>$$\\varphi(n,p,q) = \\forall x_1 \\cdots \\forall x_n : \\neg (p(x_1,\\ldots,x_n) = q(x_1,\\ldots,x_n))$$</p>\n\n<p>I would like to show that there are infinitely many triples $(n,p,q)$ such that neither $\\varphi(n,p,q)$ nor $\\neg \\varphi(n,p,q)$ is a theorem of formal arithmetic. </p>\n\n<p>In showing this I can use the fact that the problem of deciding if a polynomial $r \\in \\mathbb{Z}[x_1,\\ldots,x_n]$ has a natural zero is undecidable.</p>\n\n<p>Knowing the above fact we know that there is a polynomial $r \\in \\mathbb{Z}[x_1,\\ldots,x_n]$ such that neither $$\\varphi' = \\forall x_1 \\cdots \\forall x_n : \\neg (r(x) = 0)$$ nor $\\neg \\varphi'$ is a theorem. (Here the quantifiers are over the naturals which I am not sure if I can use deliberately?)</p>\n\n<p>Once we have such $r$ we can write it as $$r(x_1,\\ldots,x_n) = p(x_1,\\ldots,x_r) - q(x_1,\\ldots,x_n)$$ for $p,q \\in \\mathbb{N}[x_1,\\ldots,x_n]$ and hence $\\varphi(n,p,q)$ and $\\neg \\varphi(n,p,q)$ are also not theorems since $\\varphi$ is logically equivalent to $\\varphi'$ and we have shown that this is not a theorem.</p>\n\n<p>Once we have one such triple $(n,p,q)$ we have infinitely many of them since we can just take $(n,p+k,q+k)$ for $k \\in \\mathbb{N}.$</p>\n\n<p>Since I never did such things before I am wondering if the above reasoning is correct?</p>\n", 'ViewCount': '105', 'Title': "Question related to Hilbert's 10th problem", 'LastEditorUserId': '3092', 'LastActivityDate': '2012-12-23T05:46:13.213', 'LastEditDate': '2012-11-28T14:42:50.287', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<computability><logic><undecidability>', 'CreationDate': '2012-11-28T14:33:42.353', 'Id': '6993'}{'Body': "<p>I'm preparing for an exam, and on a sample one provided (without solutions), we have this question: Is the following solvable or non-solvable: Given a turing machine $T$, does it accept a word of even length? - Given a deterministic 1-tape turing machine $T$, does $T$ ever read the contents of the 10th cell?</p>\n\n<p>Thanks! - </p>\n", 'ViewCount': '152', 'Title': 'Solvability of Turing Machines', 'LastActivityDate': '2012-12-07T22:24:42.607', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '7242', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2012-12-07T21:57:26.213', 'Id': '7241'}{'ViewCount': '311', 'Title': 'Undecidability of the following language', 'LastEditDate': '2012-12-11T04:09:25.933', 'AnswerCount': '3', 'Score': '2', 'OwnerDisplayName': 'muddy', 'PostTypeId': '1', 'OwnerUserId': '5020', 'Body': "<p>So we can prove that the language say $A = \\{ \\langle M,w \\rangle \\mid \\text{M is TM that accepts } w^R \\text{ whenever it accepts } w \\}$ is undecidable by assuming it is decidable and use that to construct a $TM$ deciding $A_{TM}$. So by contradiction $A$ is undecidable. But what if the language was $\\{ \\langle M,w \\rangle \\mid \\text{M accepts } w \\text{ but on input } w^R \\text{halts and rejects} \\}$? </p>\n\n<p>I was thinking to prove that it's r.e, we can construct a Turing recognizer, say $K$, which recognizes this language by simulating $M$ on $w$ and do whatever $M$ does. But how does the machine know what's $w$ and $w^R$? Non determinism maybe? Or am I looking at it the wrong way?</p>\n\n<p>And to prove that it's undecidable would we use the same approach as that for $A$? </p>\n", 'Tags': '<turing-machines><undecidability>', 'LastEditorUserId': '5020', 'LastActivityDate': '2012-12-11T12:26:59.320', 'CommentCount': '2', 'AcceptedAnswerId': '7324', 'CreationDate': '2012-12-09T23:48:05.950', 'Id': '7285'}{'Body': '<p>Trivially decidable problem is one in which the problem is a known property of the language/grammar. So  <strong>intersection of two regular languages is regular should be trivially decidable</strong>? But it is given as not trivially decidable.</p>\n', 'ViewCount': '249', 'Title': 'Is the intersection of two regular languages regular?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-25T21:16:11.313', 'LastEditDate': '2012-12-25T21:16:11.313', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '7534', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4763', 'Tags': '<regular-languages><undecidability><decision-problem>', 'CreationDate': '2012-12-18T14:08:00.077', 'Id': '7488'}{'Body': '<p>Is there an undecidable problem which is not NP-hard?</p>\n', 'ViewCount': '162', 'Title': 'Is undecidable(complement of R) a subset of NP-hard?', 'LastActivityDate': '2013-01-01T14:28:59.920', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'cineel', 'PostTypeId': '1', 'Tags': '<complexity-theory><undecidability>', 'CreationDate': '2013-01-01T06:43:12.347', 'Id': '7676'}{'Body': '<p>I am new to Computability Theory and find it is both amazing and confusing. Specifically, it is difficult for me to get through the undecidability of the well-known Halting Problem. </p>\n\n<blockquote>\n  <p><strong>Halting function:</strong> The Halt function takes an input a pair $&lt;\\alpha, x&gt;$ and outputs 1 if and only if the TM $M_{\\alpha}$ represented by $\\alpha$ halts on input $x$ within a finite number of steps.</p>\n</blockquote>\n\n<p>The undecidability of Halting function is proved by reduction from another undecidable function $UC$, which is defined as follows <a href="http://www.cs.duke.edu/~reif/courses/complectures/books/AB/ABbook.pdf" rel="nofollow">Book by Arora and Barak</a>.</p>\n\n<blockquote>\n  <p><strong>$UC$:</strong> For every $\\alpha \\in \\lbrace 0,1 \\rbrace^{\\ast}$, if $M_{\\alpha}(\\alpha) = 1$, then $UC(\\alpha) = 0$; otherwise (if $M_{\\alpha}(\\alpha)$ outputs a different value or enters an infinite loop), $UC(\\alpha) = 1$.</p>\n</blockquote>\n\n<p>The undecidability of $UC$ is proved by the also well-known <em>"diagonalization"</em> technique. I can understand the technique. However, I am puzzling over a more basic problem involving the definition of $UC$.</p>\n\n<blockquote>\n  <p><strong>My Problem:</strong> The definition of $UC$ is based on the value of $M_{\\alpha}(\\alpha)$. Especially, it seem to be based on <em>whether a Turing Machine halts on an input</em>. However, the latter is undecidable (Worse still, it is undecidable due to the undecidability of $UC$!). In this sense, is the $UC$ function well-defined?</p>\n</blockquote>\n\n<p>What is wrong with my opinion? How should I understand the definition of $UC$ and the relation between $UC$ and Halting Problem?</p>\n\n<p>Thank for your help.</p>\n', 'ViewCount': '126', 'Title': 'Is the undecidable function $UC$ well-defined for proving the undecidability of Halting Problem?', 'LastActivityDate': '2013-01-07T19:26:06.113', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7788', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<computability><proof-techniques><undecidability><halting-problem>', 'CreationDate': '2013-01-05T11:29:41.143', 'Id': '7785'}{'ViewCount': '140', 'Title': 'Decision problem and algorithm', 'LastEditDate': '2013-01-05T12:41:30.573', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was reading about decision problem. I understand that decision problem tell yes/no answer for an input. The decision is based on a decision procedure also called an algorithm. </p>\n\n<p>The wikipedia says that </p>\n\n<blockquote>\n  <p>It is traditional to define the decision problem equivalently as: the set of inputs for which the problem returns yes.</p>\n  \n  <p>These inputs can be natural numbers, but may also be values of some other kind, such as strings over the binary alphabet $\\{0,1\\}$ or over some other finite set of symbols. The subset of strings for which the problem returns "yes" is a formal language, and often decision problems are defined in this way as formal languages.</p>\n</blockquote>\n\n<p>Whether I can take it like algorithm written in a programming language defines the set of all possibilities and gives the output based on the input?</p>\n\n<p>So in computability theory, the problem should be encoded to some form? Is this same thing as the input tape and configuration of a Turing machine (set of 0\'s and 1\'s )?</p>\n', 'Tags': '<computability><turing-machines><undecidability><decision-problem>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-05T14:46:26.633', 'CommentCount': '0', 'AcceptedAnswerId': '7790', 'CreationDate': '2013-01-05T12:27:42.627', 'Id': '7786'}{'Body': '<p>Let $A$ be the language $\\{\\langle M\\rangle\\mid M\\text{ is a Turing machine that accepts only one string}\\}$</p>\n\n<p>According to my understanding, if a Turing machine is able to decide if another Turing machine will accept only one string, then the halting problem could also be solved. Therefore, $A$ is non-recursively enumerable in my understanding.\nIs it correct ? </p>\n', 'ViewCount': '123', 'Title': 'Language comprising of Turing machine encodings', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-10T08:58:45.577', 'LastEditDate': '2013-01-10T06:55:38.930', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-01-10T01:54:48.163', 'Id': '7858'}{'Body': '<p>Let $L_{1}$ and $L_{2}$ be two languages defined as follows :<br>\n   $L_1 = \\{ \\langle M\\rangle \\mid L(M) \\neq \\emptyset \\}$<br>\n   $L_2 = \\{ \\langle M\\rangle \\mid L(M) = \\emptyset \\}$<br>\n   where $\\langle M\\rangle$ denotes the encoding of a Turing Machine $M$. \n$L_{1}$ is the set of encodings of TMs that accept at least one string (i.e. the with non-empty languages), and $L_{2}$ is the set of encodings of TMs that do not accept any string (i.e. with empty lanugages). By making a language out of such encodings, I am essentially asking a Turing Machine to decide on another Turing machine as to whether the second TM has an empty language or not. This is essentially the halting problem, and so both languages are undecidable.             </p>\n\n<p>Now, I am not able to characterize $L_{1}$ and $L_{2}$ from among   </p>\n\n<ul>\n<li>not recursively enumerable  </li>\n<li>recursively enumerable but not recursive </li>\n<li>recursive </li>\n</ul>\n', 'ViewCount': '203', 'Title': 'Deciding Recursive/Recursively Enumerable when given Turning machine encoding as a language', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-01-10T03:58:22.040', 'LastEditDate': '2013-01-10T03:58:22.040', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-01-10T01:29:39.413', 'Id': '7860'}{'ViewCount': '258', 'Title': 'Is it possible to decide if a given algorithm is asymptotically optimal?', 'LastEditDate': '2013-02-02T12:51:15.650', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6642', 'FavoriteCount': '0', 'Body': '<p>Is there an algorithm for the following problem:</p>\n\n<blockquote>\n  <p>Given a Turing machine $M_1$ that decides a language $L$,<br>\n  Is there a Turing machine $M_2$ deciding $L$ such that\n  $t_2(n) = o(t_1(n))$?</p>\n</blockquote>\n\n<p>The functions $t_1$ and $t_2$ are the worst-case running times of Turing machines $M_1$ and $M_2$ respectively.</p>\n\n<p>What about space complexity?</p>\n', 'Tags': '<complexity-theory><computability><undecidability><decision-problem>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-02T12:51:15.650', 'CommentCount': '1', 'AcceptedAnswerId': '9399', 'CreationDate': '2013-01-31T10:58:26.190', 'Id': '9349'}{'Body': "<p>Given a language, how do you go about deciding if it's decidable or not? For example:</p>\n\n<p>Given a DFA $A_0$ and a TM $M_0$</p>\n\n<p>$L_1 = \\{ \\langle M \\rangle \\, | \\, M \\mbox{ is a TM and }L(M) = L(A_0) \\}$</p>\n\n<p>$L_2 = \\{ \\langle A \\rangle \\, | \\, A \\mbox{ is a DFA and }L(A) = L(M_0) \\}$</p>\n\n<p>What's the intuition/process of figuring out if $L_1$, $L_2$ are decidable or not?</p>\n\n<p>This is not homework, $L_1$ is not decidable and $L_2$ is decidable, but I have not idea why, and how to solve this problem and problems similar to it. If you could explain to me the process of doing that you will help a lot.</p>\n", 'ViewCount': '120', 'Title': 'Intuition about decidability', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-18T21:58:40.490', 'LastEditDate': '2013-02-18T21:58:40.490', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '9705', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6836', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-02-12T12:24:34.953', 'Id': '9703'}{'Body': '<p>We are given the following language </p>\n\n<p>B = {$&lt;M,i&gt;$ : M is a turing machine and $i \\in \\mathcal{N}$ and M accepts some string in atmost $i$ steps }</p>\n\n<p>Is language B decidable ?</p>\n\n<p>As per a hint from another fellow user, I decided to construct the following decider for B. Call it D.</p>\n\n<p>D = On input </p>\n\n<ol>\n<li>Enumerate all the strings in $\\Sigma^*$ in lexicographical order (shortlex). Let the generated sequence be $s_1,s_2,...$ where each $s_k$ denotes all strings of lenght $k$</li>\n<li>Simulate each string in $s_k$ on M for atmost i steps. </li>\n<li>If any of them is accepted, ACCEPT. </li>\n<li>When we have finished evaluating strings for length $s_i$, output REJECT. </li>\n</ol>\n\n<p>Is this the correct decider for B ? </p>\n', 'ViewCount': '102', 'Title': 'Is this a correct decider?', 'LastActivityDate': '2013-02-18T03:15:38.150', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6919', 'Tags': '<undecidability>', 'CreationDate': '2013-02-17T15:03:44.600', 'FavoriteCount': '0', 'Id': '9862'}{'Body': "<p>For any language $L$ over $\\{0,1\\}^*$, a language $L'$ can be defined as $\\{ a | ab \\in L \\text{ for some } b \\in \\{0,1\\}^* \\}$.</p>\n\n<p>If $L$ is decidable, is $L'$ decidable?</p>\n\n<p>I think that $L'$ should be decidable because we can create a Turing machine for $L'$ that will run the decider for $L$ on the input $w$ for $L'$, accept if it accepts, and otherwise will enumerate all the possible strings $b$ and run $wb$ on $L$. Does that make sense?</p>\n", 'ViewCount': '60', 'Title': 'computability - decidability of a prefix language', 'LastEditorUserId': '683', 'LastActivityDate': '2013-02-20T19:24:39.137', 'LastEditDate': '2013-02-20T19:24:39.137', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6965', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-02-20T18:21:41.973', 'Id': '9976'}{'Body': u'<p>I have to reduce $L_\\text{empty}$ to $L_\\text{inf}$</p>\n\n<p>where </p>\n\n<p>$\\qquad L_\\text{empty} = \\{e \\mid |L(P_e)| = 0 \\}$ and<br>\n$\\qquad L_\\text{inf}= \\{e \\mid |L(P_e)| = \\infty \\}$.</p>\n\n<p>where $P_e$ is the program with G\xf6del number $e$, and $L(P_e)$ the language it accepts.</p>\n\n<p>So can I define a program $P$ like this</p>\n\n<pre><code>input n\nRun Pe on 1...n for n steps\nif Pe accepts any number then \n  enter an infinite loop and start accepting infinite number\nif Pe does not accept any number then \n  accept 1\n</code></pre>\n\n<p>Now if I can define program P like above then asking the question whether the index of $P$ is in $L_\\text{inf}$ will tell me whether the language accepted by $P_e$ is empty or not.</p>\n', 'ViewCount': '75', 'Title': 'Can I use infinite numbers in a reduction?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-11T07:31:15.733', 'LastEditDate': '2013-03-11T07:31:15.733', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7222', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-03-11T00:40:18.537', 'Id': '10442'}{'Body': '<p>Suppose $\\sigma$ is a vocabulary of First Order logic consisting of one binary relation $E$ and let $\\phi$ be a $\\sigma$ sentence (FO formula with no free variables). Is it decidable whether there is a finite directed graph $G$, with all in- and out-degrees $0$ or $1$, such that $G\\models \\phi$ ?</p>\n', 'ViewCount': '114', 'Title': 'Decidability over finite graphs of small degree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-14T15:24:32.167', 'LastEditDate': '2013-03-14T15:24:32.167', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<graphs><logic><undecidability><first-order-logic><finite-model-theory>', 'CreationDate': '2013-03-13T10:55:07.910', 'Id': '10509'}{'Body': "<p>Let $$L_\\emptyset = \\{\\langle M\\rangle \\mid M \\text{ is a Turing Machine and }L(M)=\\emptyset\\}.$$<br>\nIs there a Turing machine R that decides (I don't mean recognizes) the language $L_\\emptyset$?</p>\n\n<p>It seems that the same technique used to show that $\\{A \\mid A \\text{ is a DFA and } L(A)=\\emptyset\\}$ should work here as well.</p>\n", 'ViewCount': '1129', 'Title': 'Can a Turing machine decide the language $L_\\emptyset$ of machines with empty language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-22T10:30:47.150', 'LastEditDate': '2013-04-03T07:03:14.517', 'AnswerCount': '4', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-03-29T16:28:54.423', 'FavoriteCount': '1', 'Id': '10897'}{'Body': "<p>As it is explained in Sipser's book, the following language is undecidable and he proves this using the computation history method.</p>\n\n<p>$\\qquad E = \\{\\langle M \\rangle \\mid M\\ \\mathrm{LBA}, L(M)=\\emptyset\\}$</p>\n\n<p>I wanted to see if we could use the same method used for proving undecidability of the following language in the case of LBAs too (instead of using computation history method).</p>\n\n<p>$\\qquad E' = \\{\\langle M \\rangle \\mid M\\ \\mathrm{TM}, L(M)=\\emptyset\\}$</p>\n\n<p>Is it possible?</p>\n", 'ViewCount': '47', 'Title': 'Proving undecidability of the language composed of LBAs where their language is empty', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:45:43.797', 'LastEditDate': '2013-04-02T07:45:43.797', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10935', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-03-31T11:41:10.983', 'Id': '10934'}{'ViewCount': '142', 'Title': 'Program synthesis, decidability and the halting problem', 'LastEditDate': '2013-04-05T15:19:36.143', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '1', 'Body': '<p>I was reading an answer to a recent question, and sort of a strange, ephemeral thought came to mind. My asking this might betray either that my theory chops are seriously lacking (mostly true) or that it\'s just too early for me to read this site. Now, with the disclaimer out of the way...</p>\n\n<p>It is a well-known result it computability theory that the halting problem cannot be decided for TMs. However, this doesn\'t exclude the possibility that there exist machines that can solve the halting problem for certain classes of machines (just not all of them).</p>\n\n<p>Consider the set of all decidable problems. For each problem, there exist infinitely many TMs which decide that language. Could the following be possible </p>\n\n<ul>\n<li>There is a TM that decides the halting problem for a subset $S$ of Turing machines; and</li>\n<li>All decidable problems are decided by at least one Turing machine in $S$?</li>\n</ul>\n\n<p>Of course, finding the Turing machine in $S$ may not be computable itself; but we ignore that problem.</p>\n\n<p>EDIT: Based on Shaull\'s answer below, it seems that either (a) this idea is too ill-specified to be meaningful or (b) my previous attempt wasn\'t quite on the mark. As I try to elaborate in the comments to Shaull\'s answer, my intent isn\'t that we\'re guaranteed that the input TM is in $S$. What I really meant by my question is whether there could exist such an $S$, <em>such that membership in $S$ is a decidable problem</em>. The program to solve the halting problem for $S$ would, presumably, write "invalid input" on the tape or something when given an input that it recognizes as not being in $S$. When I formulate it like that, I\'m not sure whether this allows us to solve the halting problem or not, or whether Rice\'s theorem applies (is decidability a semantic property of a language w.r.t. Rice\'s theorem?)</p>\n', 'Tags': '<turing-machines><undecidability><halting-problem>', 'LastEditorUserId': '69', 'LastActivityDate': '2013-04-05T15:20:46.887', 'CommentCount': '2', 'AcceptedAnswerId': '11059', 'CreationDate': '2013-04-05T13:19:48.110', 'Id': '11056'}{'Body': "<p>I'm studying Turing Machines and I've already showed how Turing-Decidable is closed for the operations of Union, Intersection, Concatenation, Complement and Kleene Star. Next I did some demonstrations to show how T-Recognizable languages are closed for Union, Intersection, Concatenation and Kleene Star.</p>\n\n<p>Now I'm trying to answer a question to show why the classe of T-Recognizable languages are not closed for the operation of Complementation, but I cannot understand it. Could someone please explain this?</p>\n", 'ViewCount': '1166', 'Title': "Why isn't the class of Turing-Recognizable languages closed under Complement?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T19:56:48.270', 'LastEditDate': '2013-04-07T19:01:23.620', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7632', 'Tags': '<computability><undecidability><closure-properties>', 'CreationDate': '2013-04-07T17:52:07.083', 'Id': '11104'}{'Body': '<p>I have an exam coming up soon and I need help with this.  Consider the problem:</p>\n\n<blockquote>\n  <p>Given a Turing machine $M$, determine if $M$ halts in at most ten steps on every input.</p>\n</blockquote>\n\n<p>Is this decidable?  Prove your answer.</p>\n', 'ViewCount': '83', 'Title': 'Decidability of a Turing machine which always halts in at most ten steps', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-04-08T09:10:17.170', 'LastEditDate': '2013-04-08T09:10:17.170', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7639', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-04-08T07:26:53.610', 'Id': '11135'}{'Body': '<p>I have an exam coming up and I need help with the following homework:</p>\n\n<blockquote>\n  <p>Given an NFA $A$ and a regular expression $B$, consider the problem of determining if $L(A) = L(B)$. Is this decidable? Prove your answer.</p>\n</blockquote>\n', 'ViewCount': '135', 'Title': 'Given an NFA A and a regular expression B, is the problem of determining L(A) = L(B) decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:55:24.693', 'LastEditDate': '2013-04-08T14:55:24.693', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7639', 'Tags': '<automata><finite-automata><undecidability><regular-expressions>', 'CreationDate': '2013-04-08T10:13:25.680', 'Id': '11138'}{'ViewCount': '1040', 'Title': 'How to show that a function is not computable?', 'LastEditDate': '2013-06-06T16:06:21.617', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '5', 'Body': "<p>I know that there exist a Turing Machine, if a function is computable. Then how to show that the function is <em>not</em> computable or there aren't any Turing Machine for that. Is there anything like a Pumping lemma?</p>\n", 'Tags': '<computability><proof-techniques><undecidability><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-08-07T07:04:22.880', 'CommentCount': '4', 'AcceptedAnswerId': '11289', 'CreationDate': '2013-04-10T02:38:54.367', 'Id': '11181'}{'Body': '<p>If there is a Turing Machine $M_e$ (computing some partially computable function $f$), is there an algorithm to decide if $f$ diverges for all possible inputs?</p>\n', 'ViewCount': '109', 'Title': 'Does Turing Machine divergence depend on the input?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T04:44:34.687', 'LastEditDate': '2013-04-10T18:34:48.943', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'Gauk', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><undecidability><halting-problem>', 'CreationDate': '2013-04-10T10:36:06.323', 'Id': '11196'}{'Body': '<blockquote>\n  <p>A TM for a recursive language corresponds to our informal notion of an algorithm.</p>\n</blockquote>\n\n<p>as per Automata Theory, Languages and Computation by Ullman et al. Then there are languages called RE and $L_d$, where there exist TM that halts for accepting strings in the case of RE languages.</p>\n\n<p>This means that we cannot construct a algorithm for RE languages that are not recursive? Then what is the significance of these RE languages from an algorithm point of view.</p>\n\n<p>What confuses me is that for RE language you can construct a TM. So you can construct an algorithm?</p>\n', 'ViewCount': '97', 'Title': "What does it mean to say that there doesn't exist an algorithm from a TM point of view?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T11:20:42.773', 'LastEditDate': '2013-04-14T11:13:02.347', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '11310', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-04-13T13:34:34.777', 'Id': '11285'}{'Body': '<p>In the proof of Trakhtenbrot\'s theorem (as given in "Elements of Finite Model Theory" by Leonid Libkin), for every Turing machine $M$, author constructs a FO sentence $\\Phi_M$ of vocabulary $\\sigma$ such that $\\Phi_M$ is finitely satisfiable iff $M$ halts on the empty input. Then he says that as the latter is known to be undecidable so the theorem holds.</p>\n\n<p>My doubt is, the vocabulary $\\sigma$ that was constructed depends on the Turing Machine $M$. But the theorem holds for any relational vocabulary with at least one binary relation symbol and also it should not depend on the machine $M$. Perhaps the claim of author is enough to imply the theorem for arbitrary vocabulary, but I am unable to see how.</p>\n', 'ViewCount': '161', 'Title': "Proof of Trakhtenbrot's theorem", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T09:57:57.300', 'LastEditDate': '2013-04-15T09:54:06.163', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<turing-machines><logic><reductions><undecidability><finite-model-theory>', 'CreationDate': '2013-04-15T08:38:12.270', 'Id': '11327'}{'Body': "<p>A few definitions..</p>\n\n<p>$$\n\\begin{align*}\n\\mathrm{ALL}_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle  \\,\\Big|\\, \\text{$M$ a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; L(M) = \\{0,1\\}^{*} \\Bigr\\}\n\\\\[2ex]\n\\overline{\\mathrm{ALL}}_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle  \\,\\Big|\\, \\text{$M$ a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; L(M) \\ne \\{0,1\\}^{*} \\Bigr\\}\n\\\\[2ex]\nB_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle \\,\\Big|\\, \\text{$M$ is a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; \\varepsilon \\in L(M) \\Bigr\\}\n\\end{align*}\n$$</p>\n\n<p>We are showing a reduction from $B_{\\mathrm{TM}}$ to $\\overline{\\mathrm{ALL}}_{\\mathrm{TM}}$. In my notes I have the following solution to this problem which I'm trying to understand.</p>\n\n<ol>\n<li><p>Let $\\alpha \\in \\{0,1\\}^*$. Check that $\\alpha$ is of form $\\langle M \\rangle$, where $M$ is a TM over $\\{0,1\\}$. Else, let $f(\\alpha)$ be anything not in $\\overline{\\mathrm{ALL}}_{\\mathrm{TM}}$.</p></li>\n<li><p>Let $f(\\alpha)$ be $\\langle M' \\rangle$, where $M'$ on $x$ runs $M$ on $\\varepsilon$ (blank string) for up to $|x|$ steps. If $M$ accepts (in that time), then $M'$ rejects. Otherwise, $M'$ accepts.</p></li>\n</ol>\n\n<p>What I'm trying to understand is why must we run the TM $M'$ for $|x|$ steps for this to work? If we change the part #2 of the transformation to the following, why wouldn't this work?</p>\n\n<ul>\n<li>Let $f(\\alpha)$ be $\\langle M' \\rangle$, where $M'$ on $x$ runs $M$ on $\\varepsilon$ (blank string). If $M$ accepts, reject. Otherwise accept.</li>\n</ul>\n\n<p>Which then it follows that $\\varepsilon \\in L(M) \\!\\iff\\! L(M) = \\varnothing$,  that is $L(M) \\neq \\{0,1\\}^*$.</p>\n", 'ViewCount': '257', 'Title': 'Proving ALLTM complement not recognizable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:06:43.400', 'LastEditDate': '2013-04-21T14:06:43.400', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7776', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-04-19T16:41:41.893', 'Id': '11411'}{'Body': '<p>I am attempting to prove the following problem is undecidable. Given a Turing machine $M$ and input $x$, does $M$ visit infinitely many tape cells on input $x$? </p>\n\n<p>I am considering a reduction from the halting problem. Is this the right approach? </p>\n', 'ViewCount': '109', 'Title': 'Show the problem of a machine visiting infinitely many tape cells on some input is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-04T15:47:41.333', 'LastEditDate': '2013-04-21T23:15:04.180', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<computability><turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2013-04-21T22:25:41.810', 'Id': '11479'}{'Body': "<p>If you have a language L, without doing any proofs, is there a way to tell if it's recognizable or co-recognizable or decidable?</p>\n\n<p>Basically any hints or tricks that can be used to tell. Or maybe the common patterns to search for to tell which kind it is?</p>\n", 'ViewCount': '452', 'Title': 'How to tell if a language is recognizable, co-recognizable or decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T18:02:58.057', 'LastEditDate': '2013-04-23T09:12:19.267', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<computability><undecidability><intuition>', 'CreationDate': '2013-04-22T21:00:40.460', 'Id': '11500'}{'ViewCount': '115', 'Title': 'Is there a name for complement of recursively enumerable set?', 'LastEditDate': '2013-04-27T04:51:56.517', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Juris', 'PostTypeId': '1', 'OwnerUserId': '7911', 'Body': '<p>If there is a recursive function\n$$\nf(x) = \n\\begin{cases}\n1 &amp; \\text{if $x \\notin A$}\\\\\n\\text{undefined} &amp; \\text{if $x \\in A$}\\\\\n\\end{cases}\n$$</p>\n\n<p>Is there a special name for the class of sets like $A$?</p>\n', 'Tags': '<terminology><computability><undecidability>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-27T04:51:56.517', 'CommentCount': '3', 'AcceptedAnswerId': '11584', 'CreationDate': '2013-04-25T15:45:02.357', 'Id': '11564'}{'Body': '<p>Were being asked to determine the whether this Turing Machine is decidable or not</p>\n\n<p>"Given a two way, one-tape DTM $M$ whose tape set is $\\Gamma=${$a,b,B$} and a string $x\\in${$a,b$}*, determine whether $M$ will ever overwrite a symbol $a$ by a symbol $b$ in its computation on <em>input</em> $x$"</p>\n\n<p>I\'m not looking for answers, just hints on how to even approach this problem. Like, would we declare a <em>language</em> which is a subset of that <em>language</em>, and then apply reducibility?</p>\n', 'ViewCount': '53', 'Title': 'Determining if a TM decidable or not, with limited information', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-04-26T18:31:57.527', 'LastEditDate': '2013-04-26T18:31:57.527', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11580', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-04-26T15:17:43.000', 'Id': '11579'}{'Body': "<p>Got a final coming up, so I gotta get this concept down.</p>\n\n<p>Given $A= \\{(G_1,G_2 \\mid G_1$ and $G_2$ are two CFG's and $L(G_1)=L(G_2) \\}$.\nIs $A$ decidable?</p>\n\n<p>Would it be sufficient to take an undecidable language such as $B= \\{x \\mid L(M_x)$ is a CFG $  \\}$. Then reduce it to A with function $f(x) = G'_{M_x}$?</p>\n", 'ViewCount': '54', 'Title': 'Determining grammar decidability', 'LastActivityDate': '2013-05-02T11:47:58.577', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11731', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<undecidability>', 'CreationDate': '2013-05-02T11:39:22.217', 'Id': '11729'}{'Body': "<p>I was asked this question at an interview, and couldn't answer it, and would like to know how it is 'shown' that two Turing machines which accept the same language is undecidable. This is not a homework question!</p>\n", 'ViewCount': '482', 'Title': 'Show that it is undecidable if two Turing Machines accept the same language', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-05-14T03:12:53.943', 'LastEditDate': '2013-05-09T20:06:15.133', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8104', 'Tags': '<algorithms><computability><finite-automata><undecidability>', 'CreationDate': '2013-05-09T17:18:46.500', 'Id': '11916'}{'Body': "<p>suppose <strong>we don't know that Halting problem is not recursive</strong>.</p>\n\n<p>I want to prove that <strong>complement of halting set is not r.e.</strong> then we can find <strong>halting problem is not recursive</strong>.</p>\n\n<p><strong>Can you direct prove that complement of halting set is not r.e.??</strong></p>\n", 'ViewCount': '129', 'Title': 'Complement of halting set is not r.e', 'LastEditorUserId': '8133', 'LastActivityDate': '2013-05-13T21:37:04.930', 'LastEditDate': '2013-05-13T21:37:04.930', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8133', 'Tags': '<undecidability><halting-problem>', 'CreationDate': '2013-05-13T20:54:26.763', 'Id': '11997'}{'Body': "<p>This might be a bit of an abstruse question, but it's something I've been trying to prove.</p>\n\n<p>I'm trying to show that it is undecidable whether a given Turing Machine is a member of the set of all Turing Machines that either always halt, or have non-halting loops where all of which can be detected (a positive decision made on it's existence) by some Turing Mahcine.</p>\n\n<p>I'm trying to do a reduction from the Entscheidungsproblem, and my proof looks something like this:</p>\n\n<p>Create a Turing machine $D$ on input $&lt;M,w&gt;$ that does the following:</p>\n\n<ol>\n<li><p>Mechanically create TM $M_2$ which does the following on $x$:</p>\n\n<ol>\n<li>if $M$ accepts $w$ (via simulation from UTM): accept $x$.</li>\n<li>if $M$ rejects $w$: loop in a manner such that $M_2$ would not be a member of the aforementioned set.</li>\n</ol></li>\n<li><p>Run decider for above problem on $M_2$:</p>\n\n<ul>\n<li>if decider accepts, it should accept because if $M$ accepts $w$, $M_2$ must always halt and must be a member of the set in question.</li>\n<li>if decider rejects, it should reject because if $M$ does not accept $w$, $M_2$ must have a non mechanically detectable loop and is not in the set.</li>\n</ul></li>\n</ol>\n\n<p>The above Turing Machine $D$ should therefore decide Entscheidungsproblem and shows the reduction. However, I'm not sure how to show that it possible to mechanically create a loop which cannot be mechanically detected, or whether an alternate method of proof would be adequate.</p>\n\n<p>Any insight in this proof would be appreciated.</p>\n", 'ViewCount': '111', 'Title': 'Undecidability of whether a given TM halts or only has loops which can be detected by some TM', 'LastEditorUserId': '8262', 'LastActivityDate': '2013-06-19T01:38:13.963', 'LastEditDate': '2013-05-20T01:15:44.853', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '1', 'OwnerDisplayName': 'Phillip Huff', 'PostTypeId': '1', 'OwnerUserId': '8262', 'Tags': '<turing-machines><reductions><halting-problem><undecidability>', 'CreationDate': '2013-05-19T01:12:03.770', 'Id': '12141'}{'Body': '<p>Consider the following <em>universe problem</em>.</p>\n\n<blockquote>\n  <p><strong>The universe problem.</strong> Given a finite set $\\Sigma$ for a class of languages, and an automaton accepting the language $L$, decide if $L=\\Sigma^*$.</p>\n</blockquote>\n\n<p>In [1], it is stated and proved that the universe problem is undecidable for a particular class of one-counter automata. This result then follows for the class of all non-deterministic one-counter automata. I\'m wondering if it is known whether this problem is still undecidable when we restrict the size of the input alphabet of the automaton. </p>\n\n<p>I think that with alphabet size 1 the problem becomes decidable, but what about size 2? And if that turns out to be decidable what is the smallest value of $n \\in \\mathbb{N}$ such that the problem is undecidable.</p>\n\n<p>I think it\'s probable that the answer to this question is known but I\'m having trouble finding an answer. If it is already known then I would appreciate a reference.</p>\n\n<hr>\n\n<p>[1] <a href="http://link.springer.com/article/10.1007%2FBF01744294">Ibarra, O. H. (1979). Restricted one-counter machines with undecidable universe problems. Mathematical systems theory, 13(1), 181-186</a></p>\n', 'ViewCount': '126', 'Title': 'Is the universe problem for one-counter automata with restricted alphabet size undecidable?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T15:29:14.707', 'LastEditDate': '2013-05-23T17:42:41.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12235', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '769', 'Tags': '<formal-languages><reference-request><automata><undecidability><decision-problem>', 'CreationDate': '2013-05-23T16:56:50.530', 'Id': '12233'}{'Body': "<p>I'm trying to find two languages, $L_1, L_2 \\in RE \\setminus R$, such that $L_1 \\cup L_2 \\in R$.</p>\n\n<p>I have already proved that if $L_1\\cap L_2 \\in R$ <strong>and</strong> $L_1 \\cup L_2 \\in R$, such $L_1, L_2$ don't exist (because otherwise we'll be able to construct a Turing Machine $M_1$ which will decide $L_1$, for instance).</p>\n\n<p>However, I cannot prove that it's impossible in the case $L_1\\cap L_2 \\in RE \\setminus R$, and I can't find such languages.</p>\n", 'ViewCount': '290', 'Title': 'Is it possible that the union of two undecidable languages is decidable?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-26T05:45:47.917', 'LastEditDate': '2013-05-26T05:45:47.917', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '12253', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7611', 'Tags': '<formal-languages><turing-machines><undecidability>', 'CreationDate': '2013-05-24T18:46:22.450', 'Id': '12252'}{'Body': "<p>I'm having a problem with proving the following statement:</p>\n\n<p>For every infinite language $L$, does there exists an infinite language $L'  \\subseteq L$ such that $L'$ is not decidable?</p>\n", 'ViewCount': '187', 'Title': 'Infinite languages and undecidable languages', 'LastEditorUserId': '31', 'LastActivityDate': '2013-05-30T23:48:17.517', 'LastEditDate': '2013-05-27T21:12:04.643', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7935', 'Tags': '<undecidability>', 'CreationDate': '2013-05-27T19:50:14.607', 'Id': '12309'}{'Body': '<p>I would like to show that \n$$EQ_{DTM} = \\{ (\\langle M_1\\rangle,\\langle M_2\\rangle) \\mid M_1\\text{ and } M_2 \\text{ are  DTMs  and } L(M_1)=L(M_2)\\}$$\n and \n$$\\overline{EQ_{DTM}}$$\n are not semi-decidable. I think there must be a reduction from the complement of the halting problem.</p>\n', 'ViewCount': '140', 'Title': 'Show that the equivalence problem for deterministic Turing machines and its complement is not semi-decidable', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-02T19:23:57.457', 'LastEditDate': '2013-06-02T00:57:25.937', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8480', 'Tags': '<turing-machines><reductions><undecidability>', 'CreationDate': '2013-06-01T19:58:49.277', 'Id': '12417'}{'Body': '<p>Constructivist logic is a system which removes the Law of the Excluded Middle, as well as \nDouble Negation, as axioms. It\'s described on Wikipedia <a href="http://en.wikipedia.org/wiki/Constructivist_logic">here</a> and <a href="http://en.wikipedia.org/wiki/Mathematical_constructivism">here</a>. In particular, the system doesn\'t allow for proof by contradiction.</p>\n\n<p>I\'m wondering, is anyone familiar with how this affects results regarding Turing Machines and formal languages? I notice that almost every proof that a language is undecidable relies on proof by contradiction. Both the Diagonalization argument and the concept of a reduction work this way. Can there ever be a "constructive" proof of the existence of an undecidable language, and if so, what would it look like?</p>\n', 'ViewCount': '504', 'Title': 'Do undecidable languages exist in constructivist logic?', 'LastActivityDate': '2013-07-11T06:23:13.290', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '12502', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><turing-machines><logic><proof-techniques><undecidability>', 'CreationDate': '2013-06-06T16:25:28.620', 'FavoriteCount': '2', 'Id': '12492'}{'Body': '<p>I\'m working on old MC-Questions about decidability und don\'t have the answers to the following ones:</p>\n\n<p>1.) $L_1$ and $L_2$ are not decidable $\\Rightarrow$ No superset of $L_1 \\cup L_2$ is decidable</p>\n\n<p>2.) For Turing-acceptable languages L is "L = $\\emptyset$" a non-trivial property.</p>\n\n<p>3.) There are context-free languages $L_1$ and $L_2$ so that $L_1 \\cap L_2$ is not decidable.</p>\n\n<p>4.) $L$ is decidable $\\Leftrightarrow$ $L \\le \\{0\\}^* \\cdot \\{1\\}^*$</p>\n\n<p>I think 1.) is false, because $\\Sigma^*$ as a superset of many undecidable languages for example is decidable and 2.) is true, because there are Turing-acceptable languages with (exactly one) and without the property. I have no idea at 3.) and 4.). </p>\n', 'ViewCount': '233', 'Title': 'Multiple-Choice Questions about decidability', 'LastActivityDate': '2013-06-08T12:44:09.483', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8480', 'Tags': '<turing-machines><context-free><reductions><undecidability>', 'CreationDate': '2013-06-08T12:30:17.683', 'Id': '12527'}{'ViewCount': '360', 'Title': 'What makes type inference for dependent types undecidable?', 'LastEditDate': '2013-10-09T18:44:37.213', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '8685', 'FavoriteCount': '1', 'Body': '<p>I have seen it mentioned that dependent type systems are not inferable, but are checkable. I was wondering if there is a simple explanation of why that is so, and whether or not there is there a limit of "dependency" where types can be indexed by values, below which type inference is possible and above which it is not?</p>\n', 'Tags': '<undecidability><type-theory><type-inference><dependent-types>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:37.213', 'CommentCount': '2', 'AcceptedAnswerId': '12957', 'CreationDate': '2013-06-15T15:35:18.983', 'Id': '12691'}{'Body': '<p>It is known that the language of words containing equal number of 0 and 1 is not regular, while the language of words containing equal number of 001 and 100 is regular (<a href="http://cs.stackexchange.com/questions/12139/is-the-language-of-words-containing-equal-number-of-001-and-100-regular">see here</a>).</p>\n\n<p>Given two words $w_1,w_2$, is it decidable if the language of words containing equal number of $w_1$ and $w_2$ is regular?</p>\n', 'ViewCount': '255', 'Title': 'Is it decidable if a language described by number of occurences is regular?', 'LastActivityDate': '2013-06-21T05:51:58.577', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '667', 'Tags': '<regular-languages><undecidability>', 'CreationDate': '2013-06-17T16:24:02.703', 'FavoriteCount': '1', 'Id': '12718'}{'ViewCount': '426', 'Title': 'Relationship between Undecidable Problems and Recursively Enumerable languages', 'LastEditDate': '2013-06-18T20:28:01.030', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7363', 'FavoriteCount': '0', 'Body': '<p>I have read the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Recursively_enumerable_language#Example" rel="nofollow">Recursively Enumerable languages</a>. The article suggests that the halting problem is recursively enumerable but undecidable. My idea till today was that the halting problem belongs to a class of languages which are not even recursively enumerable. But the article suggests that the halting problem is recursively enumerable. My doubt is about the relationship between undecidable problems and recursively enumerable languages. Are all undecidable problems recursively enumerable languages?</p>\n\n<p>If there is a problem which belongs to the class of non recursively enumerable languages, will it be always undecidable? </p>\n\n<p>Also could any one suggest a problem which is not even recursively enumerable?</p>\n', 'Tags': '<undecidability><halting-problem>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-18T20:28:01.030', 'CommentCount': '0', 'AcceptedAnswerId': '12749', 'CreationDate': '2013-06-18T18:33:24.070', 'Id': '12747'}{'Body': "<p>Let us define two languages of Turing machines.\n$$\nEQ_{TM} = \\{&lt;M_1,M_2&gt; : L(M_1) = L(M_2)\\}\n$$\n$$\nALL_{TM} = \\{&lt;M&gt; : L(M) = \\Sigma^*\\}\n$$\nIt is easy to show that neither of the languages are in $RE \\cup coRE$, and also it is easy to construct a reduction $ALL_{TM} \\leq EQ_{TM}$.</p>\n\n<p>I suspect that there is no reduction in the other direction, but I don't know how to prove it. Is there some sort of hierarchy of undecidable/non-recognizable languages that proves it?</p>\n", 'ViewCount': '75', 'Title': 'Hierarchy of undecidable languages', 'LastActivityDate': '2013-06-28T05:28:29.740', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'Igor Shinkar', 'PostTypeId': '1', 'OwnerUserId': '9622', 'Tags': '<undecidability>', 'CreationDate': '2013-06-27T08:29:52.580', 'Id': '12939'}{'Body': '<p>I have an assignment to do and I\'m quite stuck with the following question :</p>\n\n<blockquote>\n  <p>Use Rice\'s theorem to show that </p>\n  \n  <p>$ \\qquad L\' = \\{ \\langle M \\rangle \\mid \\; (\\exists \\text{ TM } M\') \\; [ L(M\') = L(M) \\text{ and } M\' \\text{ has less than 29 states} ] \\}$ </p>\n  \n  <p>is undecidable.</p>\n</blockquote>\n\n<p>I have absolutely no idea how to proceed.</p>\n\n<p>Would someone be kind enough to, at least, give me some clues?</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>First, I wrote the question wrong. It is now \'$M\'$ has less than 29 states\' (not \'steps\')."</p>\n\n<p>Here\'s what I\'m thinking after more reading and consulting other students at school.</p>\n\n<p>Rice\'s theorem :</p>\n\n<blockquote>\n  <p>$L = \\{ \\langle M \\rangle \\mid L(M) \\text{ has some property } P \\}$ where :</p>\n  \n  <ol>\n  <li><p>$P$ is non-trivial, i.e. there exists at least one machine $M_1$ such that $\\langle M_1 \\rangle \\in L$, and at least one machine $M_2$ such that $\\langle M_2 \\rangle \\not \\in L$.</p></li>\n  <li><p>$P$ is indeed a property of the language of TMs, i.e. whenever $L(M_a) = L(M_b)$, we have $\\langle M_a \\rangle \\in L$ if and only if $\\langle M_b \\rangle \\in L$.</p></li>\n  </ol>\n  \n  <p>Then, $L$ is undecidable.</p>\n</blockquote>\n\n<p>So here, the property is "$M\'$ has less than 29 states".</p>\n\n<p>We can show that this property is non-trivial.</p>\n\n<p>Let\'s take the language "abcdefghijklmnopqrstuvwxyz0123456789" (only one string is accepted). We can build a TM $M$ this way :</p>\n\n<p>-> Enter in state $q_0$</p>\n\n<p>-> In $q_0$ : if you read "a", proceed to $q_a$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>-> In $q_a$ : if you read "b", proceed to $q_{ab}$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>$\\vdots$</p>\n\n<p>-> In $q_{abcdefghijklmnopqrstuvwxyz012345678}$ : if you read "9" go to $q_{accept}$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>So here we got 3 "basic states" : $q_0$, $q_{reject}$ and $q_{accept}$ and we have $|abcdefghijklmnopqrstuvwxyz0123456789| - 1$ states (there is no $q_{abcdefghijklmnopqrstuvwxyz0123456789}$ because when we read "9" at the end, we go to $q_{accept}$). So that\'s 26 + 10 - 1 = 35 states. We have a total of 35 + 3 = 38 states.</p>\n\n<p>Unless I am wrong, there can\'t be a TM $M\'$ that can test wether a string $w$ belongs to that language without having <em>at least</em> 38 states !</p>\n\n<p>So the property "$M\'$ has less than 29 steps" is non-trivial as there is at least one TM that respects it, and at least one that does not.</p>\n\n<p>Now, $P$ is indeed a property of the language of TMs, because any two machines $M_1$ and $M_2$ such that $L(M_1) = L(M_2)$ implies :</p>\n\n<p>$\\langle M_1 \\rangle  \\in L\' \\Leftrightarrow L(M_1) = L(M_2) \\Leftrightarrow \\langle M_2 \\rangle \\in L\'$.</p>\n\n<p>(I know there is at least one missing clause in there, but I can\'t figure how to write it, it\'s got something to do with that "$M\'$ has less than 29 steps")</p>\n\n<p>So, according to Rice\'s theorem, $L\'$ is undecidable.</p>\n', 'ViewCount': '352', 'Title': "Use Rice's theorem to show that the language of optimisable Turing machines is undecidable", 'LastEditorUserId': '8737', 'LastActivityDate': '2013-07-30T22:50:11.450', 'LastEditDate': '2013-07-30T22:50:11.450', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8737', 'Tags': '<computability><proof-techniques><undecidability>', 'CreationDate': '2013-07-29T06:12:15.467', 'Id': '13485'}{'Body': '<p>Im sorry if this question has some trivial answer which I am missing. Whenever I study some problem which has been proven undecidable, I observe that the proof relies on a reduction to another problem which has been proven to be undecidable. I understand that it creates some kind of an order on the degree of difficulty of a problem. But my question is - has it been proven that all problems which are undecidable can be reduced to another problem which is undecidable. Is it not possible that there exists a undecidable problem which can proved to have no reduction to any other undecidable problem (Hence to prove the undecidability of such a problem, one cannot use reductions). If we use reductions to create an order on the degree of computability then this problem cannot be assigned such a degree. </p>\n', 'ViewCount': '174', 'Title': 'Reductions among Undecidable Problems', 'LastActivityDate': '2013-08-01T13:30:51.810', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13564', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '8912', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-08-01T07:07:54.960', 'Id': '13559'}{'Body': '<p>It\'s known that the following language, the so-called acceptance problem is undecidable:</p>\n\n<p>$A_{TM} = \\{\\langle M,w\\rangle\\,\\vert\\,M\\text{ is a TM which accepts }w\\}$</p>\n\n<p>The proof is by contradiction: Assume there is a TM $H$ which decides $A_{TM}$. Let $D$ be another TM. Given the code of a TM $M$, $\\langle M\\rangle$ as input, $D$ simulates $H$ on $\\langle M,\\langle M\\rangle\\rangle$, and accepts, if $H$ rejects this input and rejects, if $H$ accepts it. That is, $D$ accepts $\\langle M\\rangle$ if $M$ rejects its own code, and vice versa. Running $D$ on its own code, $\\langle D\\rangle$, leads to contradiction.</p>\n\n<hr>\n\n<p>Let\'s restrict $A_{TM}$ by excluding all input strings which encode a TM:</p>\n\n<p>$E = \\{w\\,\\vert\\,w\\text{ is a structurally valid encoding of a TM}\\}$\n $A\'_{TM} = \\{\\langle M,w\\rangle\\,\\vert\\,M\\text{ is a TM which accepts }w\\text{ and }w\\not\\in E\\}$</p>\n\n<p>I\'d like to know whether $A\'_{TM}$ is also undecidable. </p>\n\n<p>I tried to prove it the above way: Assume there is a TM $H\'$ which decides $A\'_{TM}$. Let $D\'$ be another TM. Given the code of a TM $M$, $\\langle M\\rangle$ as input, $D\'$ simulates $H\'$ on $\\langle M,\\langle M\\rangle\\rangle$, and accepts, if $H\'$ rejects this input and rejects, if $H\'$ accepts it. The problem is that running $D\'$ on its own code, $\\langle D\'\\rangle$, doesn\'t necessarily lead to contradiction. I mean since $\\langle D\',\\langle D\'\\rangle\\rangle$ is not a member of $A\'_{TM}$, we don\'t know what $H\'$ will do with it.</p>\n\n<hr>\n\n<p><strong>Note: An encoding of TMs, and TMs along with an input string</strong></p>\n\n<p>Let $M = (Q, \\Sigma, \\Gamma, \\delta, q_{i}, q_{a}, q_{r})$ be a TM, where </p>\n\n<ul>\n<li>$Q$ is the set of states, </li>\n<li>$\\Sigma = \\{0, 1\\}$ is the input alphabet, </li>\n<li>$\\Gamma$ is the tape alphabet ($\\Sigma\\subset\\Gamma$), </li>\n<li>$\\delta: (Q-\\{q_a, q_r\\})\\times\\Gamma\\rightarrow Q\\times\\Gamma\\times\\{L,R,S\\}$ is the transition function,</li>\n<li>$L$, $R$ and $S$ denote the respective head movements, "left", "right" and "stay", and</li>\n<li>$q_i$, $q_a$ and $q_r$ are the initial, accepting and rejecting state, respectively. </li>\n</ul>\n\n<p>Let\'s assign a unique positive integer to each element of $Q$, and do the same in case of $\\Sigma$, $\\Gamma$ and $\\{L,R,S\\}$. Now every transition rule $\\delta(p, a) = (q, b, m)$ can be encoded as $\\langle p\\rangle 1\\langle a\\rangle 1\\langle q\\rangle 1\\langle b\\rangle 1 \\langle m\\rangle$, where $\\langle x\\rangle$ denotes a sequence of $0$\'s, with length being equal to the positive integer assigned to $x$. The encoding of $M$, denoted by $\\langle M\\rangle$, can be created by concatenating its transition rules, separated by $11$\'s. The combined encoding of $M$, and an input string, $w\\in\\Sigma^*$, denoted by $\\langle M,w\\rangle$ is $\\langle M\\rangle111w$.</p>\n', 'ViewCount': '111', 'Title': 'Undecidability of a restricted version of the acceptance problem', 'LastEditorUserId': '9571', 'LastActivityDate': '2013-08-16T16:02:40.407', 'LastEditDate': '2013-08-16T14:04:03.693', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13776', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-08-16T08:47:47.587', 'Id': '13771'}{'ViewCount': '551', 'Title': 'Undecidable among these for turing machine', 'LastEditDate': '2013-09-21T17:23:03.633', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10264', 'FavoriteCount': '2', 'Body': "<p>Below are two questions I found in Theory of Computation book but couldn't find its correct answers, can anyone please give correct answers with explanation?</p>\n\n<ol>\n<li>It is undecidable, whether\n<ol>\n<li>an arbitrary Turing machine(TM) has 15 states</li>\n<li>an arbitrary TM halts after 10 steps</li>\n<li>an arbitrary TM ever prints a specific letter</li>\n<li>an arbitrary TM accepts a string w in 5 steps</li>\n</ol></li>\n<li>Which one of the following is not decidable?\n<ol>\n<li>given a TM M, a string s and an integer k, M accepts s with k steps</li>\n<li>equivalence of two given TMs</li>\n<li>language accepted by a given DFSA(Deterministic finite state automata) is nonempty</li>\n<li>language accepted by a CFG(Context free grammar) is nonempty  </li>\n</ol></li>\n</ol>\n\n<p>Update: In first question I think 1.2 is right because halting is undecidable for Turing machine but not sure whether remaining options are decidable or not.<br>\nIn second question I think 2 is right, but not sure about the decidability of non emptiness of CFG and DFSA.</p>\n", 'Tags': '<formal-languages><turing-machines><undecidability>', 'LastEditorUserId': '10264', 'LastActivityDate': '2013-09-27T20:19:53.660', 'CommentCount': '16', 'AcceptedAnswerId': '14644', 'CreationDate': '2013-09-21T16:00:54.280', 'Id': '14498'}{'Body': '<p>If a language is decidable, we can write a method that always halts and returns <code>true</code> for each string that is an element of the language and <code>false</code> otherwise.</p>\n\n<p>If a language is undecidable, what does that mean? Does it mean:</p>\n\n<p>a.) We cannot write a method; we cannot even conceive of a method.</p>\n\n<p>b.) We can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely.</p>\n\n<p>c.) Other (what?)</p>\n', 'ViewCount': '111', 'Title': 'Can a method be written if the language is undecidable?', 'LastActivityDate': '2013-09-21T17:08:19.787', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '14501', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<formal-grammars><undecidability><decision-problem><halting-problem><turing-completeness>', 'CreationDate': '2013-09-21T16:43:09.593', 'Id': '14499'}{'Body': "<p>A type-0 grammar generates a recursively enumerable (RE) language. </p>\n\n<p>A RE language is also known as a semi-decidable language. </p>\n\n<p>A semi-decidable language is a particular kind of undecidable language: If a language is semi-decidable, we can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely. </p>\n\n<p>Problem: Provide an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>Answer (I think): The following grammar generates this language: </p>\n\n<pre><code>(a+b+) union (infinite a's)\n</code></pre>\n\n<p>Here is the grammar:</p>\n\n<pre>\nS &rarr; aA | bE\nA &rarr; aA | bB\nB &rarr; bB | &epsilon; | aE\nbE &rarr; aE \nE &rarr; aE\n</pre>\n\n<p>A method for recognizing strings in the language generated by this grammar would return true for strings that are an element of a+b+ and would run indefinitely for strings that are not an element of a+b+</p>\n\n<p>I think that this is an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>If I am incorrect, would you provide an example please?</p>\n", 'ViewCount': '73', 'Title': 'Is this an example of a type-0 grammar that is not context-sensitive?', 'LastActivityDate': '2013-09-21T20:01:25.747', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><formal-grammars><undecidability><linear-bounded-automata>', 'CreationDate': '2013-09-21T20:01:25.747', 'FavoriteCount': '1', 'Id': '14503'}{'ViewCount': '68', 'Title': 'Reference for an undecidability proof', 'LastEditDate': '2013-10-04T06:49:58.733', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9625', 'FavoriteCount': '1', 'Body': '<p>I\'m searching for a reference of an undecidability proof that is as simple as possible and starts "from scratch".</p>\n\n<p>With "from scratch" I mean that it does not use some other undecidable problem to prove some undecidability (which is the usual case), I cannot wrap my mind about how proving undecidability that way (without a previous proof) could be possible.</p>\n\n<p>This question may be inspiring: <a href="http://math.stackexchange.com/questions/80745/an-example-of-an-easy-to-understand-undecidable-problem">An example of an easy to understand undecidable problem</a></p>\n\n<p>Also, I know this is probably not very objective, but it is important to me, it should be something as simple as possible, hopefully enough so that even I can understand it.</p>\n', 'ClosedDate': '2013-10-04T06:52:47.623', 'Tags': '<reference-request><proof-techniques><undecidability><decision-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T06:49:58.733', 'CommentCount': '4', 'CreationDate': '2013-10-03T14:44:58.153', 'Id': '14788'}{'Body': '<p>Given two ordered sets of words $a_1, a_2, ..., a_k$, $b_1, b_2, ..., b_k$ taking values in some discrete alphabet $A$, a solution to the PCP problem is a sequence $i_1, ..., i_n$ taking values in $1, 2,..., k$ such that $a_{i_1}|a_{i_2}|...|a_{i_n}=b_{i_1}|b_{i_2}|...|b_{i_n}$ where $|$ means concatenation. $k$ can be called the length of the problem, $n$ the length of the solution and if we let $w$ be the length of the largest word in $a_1, a_2, ..., a_k, b_1, b_2, ..., b_k$, $w$ is called the width of the problem.</p>\n\n<p>I know that the PCP problem becomes decidable in several scenarios, for instance: for bounded $n$, or if $A$ is unary, etc. On the other hand for $k\\geq7$ PCP is still undecidable. My question is, is there any result known for bounded values of $w$? </p>\n', 'ViewCount': '43', 'Title': 'Undecidability of the PCP problem with bounded width', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:09:30.400', 'LastEditDate': '2013-11-13T22:09:30.400', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16358', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10931', 'Tags': '<computability><reference-request><undecidability><decision-problem>', 'CreationDate': '2013-10-23T09:27:07.050', 'Id': '16357'}{'Body': "<p>I have a professor who is really poor at explaining the material, which is what makes answering his questions very hard. Here is the question:</p>\n\n<blockquote>\n  <p>Recursive language with non-recursive subsets. Does one exist?</p>\n</blockquote>\n\n<p>I'm sure it is a very simple and easy answer but I can't figure it out. Don't give me the answer just point me in the right direction and I'm sure I'll figure it out.</p>\n", 'ViewCount': '77', 'Title': 'Recursive language with non-recursive subsets', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T10:14:36.530', 'LastEditDate': '2013-11-10T10:14:36.530', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2013-11-10T00:38:17.997', 'Id': '17860'}{'Body': '<p>Consider these 2 languages:</p>\n\n<ul>\n<li><blockquote>\n  <p>$L_{\\ge5} = \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts at least 5 strings} \\right\\} $</p>\n</blockquote></li>\n<li><blockquote>\n  <p>$L_{&lt;5} =  \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts fewer than 5 strings} \\right\\}$</p>\n</blockquote></li>\n</ul>\n\n<p>Are these recursive, R.E., or not R.E. sets (languages)?</p>\n\n<p>I would say that they are not recursive, based on applications of Rice\'s Theorem.</p>\n\n<ul>\n<li><p>For the first case $L_{e}= \\left \\{ \\left&lt; M \\right&gt; :L(M)= \\emptyset \\right \\} \\notin L_{\\ge5} $ and $L_{\\ge5}$ are not empty. For example, I define $L= \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts all palindromes} \\right \\}$, which is not finite set and accepts an infinite number of strings.</p></li>\n<li><p>For the second case I would do the same thing. I have $L_{e}=\\left\\{ \\left&lt; M \\right&gt;: L(M)= \\emptyset \\right\\} \\in L_{&lt;5}$ and $L=\\left\\{ \\left&lt; M \\right&gt;:M \\text{ accepts all palindromes} \\right\\} \\notin L_{&lt;5} $</p></li>\n</ul>\n\n<p>So I would say that both are not recursive. Is my reasoning correct?</p>\n\n<p>Now about the R.E. of the languages I don\'t have an idea of how I can prove it, this should be the beginning (if L is not RE it can\'t be recursive), how can I check if they are RE or not?</p>\n\n<p>From the definition: "$L$ is RE $\\iff$ there exists a TM $M$ that accepts $L$", so I just have to define a TM that accepts each language?</p>\n', 'ViewCount': '224', 'Title': 'Show that a language is RE or recursive', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:21:03.943', 'LastEditDate': '2014-01-18T20:21:03.943', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17891', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<computability><undecidability><semi-decidability>', 'CreationDate': '2013-11-10T22:17:09.953', 'Id': '17889'}{'Body': "<p>I understand how a the language of turing machines which do not accept themselves is not recognizable but I'm not sure if the same proof could be used to describe a DFA... i.e a proof by contradiction in which a recognizer M recognizes a TM which does not accept itself on input ...creates a contradiction in which if M accepts then M does not accept itself. </p>\n", 'ViewCount': '113', 'Title': 'Is the language of DFAs which do not accept themselves recognizable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:46.427', 'LastEditDate': '2013-11-13T22:08:46.427', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11306', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-11-11T20:08:51.590', 'FavoriteCount': '1', 'Id': '17925'}{'Body': "<p>I'm trying to figure out how to prove or disprove the following statement:</p>\n\n<blockquote>\n  <p>Infinite union of recursive languages is recursively enumerable. </p>\n</blockquote>\n\n<p>I know how to prove that infinite union of regular languages is not recursive, but I can't figure out how to prove the statement above. Intuition is telling me that the statement is true, but I'm not sure. Does anybody know how would I go about it?</p>\n\n<p>Any help is greatly appreciated.</p>\n", 'ViewCount': '165', 'Title': 'Infinite union of recursive languages', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:38.003', 'LastEditDate': '2013-11-13T22:08:38.003', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-11-12T00:21:03.943', 'Id': '17938'}{'Body': "<p>Is it true that if A is a subset of B, and B is decidable, than A is guaranteed to be decidable?</p>\n\n<p>I believe it would be true because all the subsets of B should also be decidable making A decidable. I'm not sure if my thought process is right or if there's a easier more intuitive way to explain this.</p>\n", 'ViewCount': '362', 'Title': 'Is every subset of a decidable set, also decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:31.597', 'LastEditDate': '2013-11-13T22:08:31.597', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<computability><undecidability><closure-properties><sets>', 'CreationDate': '2013-11-12T18:05:15.880', 'Id': '17966'}{'Body': '<p>Can I think this way:</p>\n\n<p>We can convert a NFA to a RE using GFA.</p>\n\n<p>We build a series of GFAs. At each step, one state (other than start or accept) is removed and replaced by transitions that have the same effect.</p>\n\n<p>So, if we can convert k REs which have different forms but accept same language, then there must exists a string that the NFA accepts along k paths.</p>\n\n<p>Does that sound right?</p>\n\n<p>How to prove it properly?</p>\n', 'ViewCount': '131', 'Title': 'Can it be decided whether there exists a string accepted by a given NFA at least k ways?', 'LastEditorUserId': '10617', 'LastActivityDate': '2013-11-18T21:45:16.193', 'LastEditDate': '2013-11-18T21:45:16.193', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10617', 'Tags': '<turing-machines><finite-automata><undecidability>', 'CreationDate': '2013-11-18T02:51:27.257', 'Id': '18109'}{'Body': "<p>Is the language $L_{universal} = \\{ \\left \\langle M \\right \\rangle | M \\textrm{is a universal turing machine} \\}$ decidable? </p>\n\n<p>I'm guessing it is decidable according to the definition of a UTM, that a UTM must be able to calculate every recursive function. Since the set of recursive languages and the set of all input words are both enumerable, we are theoretically able to determine if the given $\\left \\langle M \\right \\rangle$ is a UTM. Is my logic somewhat correct?</p>\n", 'ViewCount': '81', 'Title': 'Decidability of the language that accepts a universal turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-02T12:19:54.130', 'LastEditDate': '2013-12-02T12:19:54.130', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '18508', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11738', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-12-01T18:21:44.070', 'Id': '18506'}{'Body': '<p>I\'m currently learning about Rice\'s Theorem, and I\'m having a bit of trouble understanding when I can and cannot use it. It\'s my understanding that Rice\'s Theorem can only be applied to something if it is a property of the language (i.e. $L(M)$) and not if it is a property of the machine (i.e $M$). Is this correct, or am I missing some detail?</p>\n\n<p>If the above is the case, then am I correct in thinking that I can apply Rice\'s Theorem to, say "$L(M)$ is infinite" or "$L(M)$ is not context-free", but not something like "$M$ is the only machine accepting $L(M)$"?</p>\n', 'ViewCount': '44', 'ClosedDate': '2013-12-02T16:55:33.870', 'Title': "Using Rice's Theorem Correctly", 'LastActivityDate': '2013-12-02T05:09:35.690', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11597', 'Tags': '<formal-languages><turing-machines><undecidability>', 'CreationDate': '2013-12-02T05:09:35.690', 'Id': '18526'}{'Body': u"<p>I am currently working on the following task:</p>\n\n<p>A language L = {&lt; M> | M(x) = x^2} is given. Now I need to show, that this language is not decidable.\n<br> By the way, &lt; M> is the G\xf6del number</p>\n\n<p>But right now, I don't know how to deal with that task. Honestly, this is the first time that I am working with this kind of task.</p>\n\n<p>I would appreciate if you could give me some hints, because I don't know how to proceed with the task.</p>\n", 'ViewCount': '29', 'ClosedDate': '2013-12-08T23:35:00.803', 'Title': 'Recursive set - How to show a language is undecidable', 'LastActivityDate': '2013-12-08T23:29:39.940', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11941', 'Tags': '<turing-machines><undecidability><computation-models><proof-assistants>', 'CreationDate': '2013-12-08T23:29:39.940', 'Id': '18764'}{'Body': u"<p>I'm trying to understand reduction, this is from my textbook and is not a homework problem or even any exercise, just trying to understand an example they present.</p>\n\n<p>This is the reduction they give: </p>\n\n<p>PROOF We let R be a TM that decides REGULARTM and construct TM S to\ndecide ATM . Then S works in the following manner.</p>\n\n<p>S = \u201cOn input $M$, $w$ , where M is a TM and w is a string:</p>\n\n<ol>\n<li><p>Construct the following TM $M_{2}$ .</p>\n\n<p>$M_{2}$ = \u201cOn input x:</p>\n\n<ol>\n<li><p>If x has the form $0^{n} 1^{n}$ , accept .</p></li>\n<li><p>If x does not have this form, run M on input w and\naccept if M accepts w.\u201d</p></li>\n</ol></li>\n<li><p>Run R on input $M_{2}$ .</p></li>\n<li><p>If R accepts, accept ; if R rejects, reject .\u201d</p></li>\n</ol>\n\n<p>So, we start with a machine that decides whether a language of a TM is regular. And we want to use that to decide if a TM halts on a given input.</p>\n\n<p>My question: What if $w$ does have the form $0^{n} 1^{n}$? Well, $M_{2}$ accepts that string just cause of the form. But we never actually run $M$ on $w$. So how can we say that it will accept or reject it? We have no idea what it does because we never ran it on $w$.</p>\n", 'ViewCount': '61', 'Title': 'Reducing from a Turing machine that recognizes is regular to the halting problem', 'LastActivityDate': '2013-12-11T21:54:13.870', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '18898', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12039', 'Tags': '<turing-machines><reductions><undecidability>', 'CreationDate': '2013-12-11T20:13:17.863', 'Id': '18894'}{'Body': "<p>I've got a problem where I need to check the <em>validity</em> (i.e to say whether it's true or false) of the following statement:</p>\n\n<blockquote>\n  <p><strong>Complement of a non-recursive language can NEVER be recognized by any turing machine.</strong></p>\n</blockquote>\n\n<p>How I've thought of this is that, if a language $\\mathcal{L}$ is non-recursive, there is no turing machine that accepts the language. That is, there's no TM that halts for every string in $\\mathcal{L}$. But there could be a TM $M_1$ that halts for some of the strings in $\\mathcal{L}$.</p>\n\n<p>Now suppose, the proposition is $\\ false$. So there could be a TM ${M_2}$ that recognizes the complement of $\\mathcal{L}$. So ${M_2}$ halts and accepts every string that is <strong>NOT</strong> in $\\mathcal{L}$ and may or may not halt for strings in $\\mathcal{L}$.</p>\n\n<p>Intuitively, It appears that ${M_1}$ and ${M_2}$ could be same, which makes my assumption $\\ true$. That is the the proposition is $\\ false$.</p>\n\n<p>But I'm not certain about the arguments I've made (as the equivalence of $M_1$ and $M_2$ is based on intuition). Can someone verify whether I'm correct or correct me otherwise.</p>\n", 'ViewCount': '65', 'Title': 'Can the complement of a non-recursive language be RE', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-13T13:25:20.253', 'LastEditDate': '2013-12-13T13:25:20.253', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11949', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-12-13T10:53:33.213', 'Id': '18948'}{'ViewCount': '184', 'Title': 'Decidability of Turing Machines with input of fixed length', 'LastEditDate': '2013-12-16T13:54:56.020', 'AnswerCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12094', 'Body': "<p>I'm learning about undecidability, and found this question:</p>\n\n<pre><code>Is this language decidable, make a proof:\n    L = { M : machine M halts for every input of length not exceeding 100 }\n</code></pre>\n\n<p>Update: This is translated from an exam paper some years ago, and I'm quite sure it means that machine M should halt for every input with length from 0 to 100, and that it is no constraints on the tape size.</p>\n\n<p>Update2: The solution given below, and hence the origin of this post, is for an variant of this question with fixed number of steps and input. Sorry for the confusion.</p>\n\n<p>I came to the conclusion that this is an undecidable language. </p>\n\n<p>My logic is as follows: Lets say for the sake of contradiction that it is possible to construct a machine $M_R$, that takes as input an arbitrary input $(M,x)$, and reduces this to $M'$. $M'$ has the property so that $(M,x) \\in M_{HALT}$ iff $M' \\in L$, this means that $M$ halts on all $x$ of input with maximum length of 100. </p>\n\n<p>Then run $M$ on $x$, if it halts then accept. </p>\n\n<p>And shows that $M_R$ decides the halting problem, and in hence a contradiction and proves that his is not decidable.</p>\n\n<p>But in the solution it is written that this question is decidable:</p>\n\n<blockquote>\n  <p>You can simulate $M$ on all inputs of length 100 or less (you can\n  generate such input in a loop and use the universal Turing machine to\n  simulate M on x), it is only $|\\Sigma|^{100}$ possible inputs of\n  length 100, that is finite.</p>\n</blockquote>\n", 'ClosedDate': '2013-12-16T20:32:42.270', 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '12094', 'LastActivityDate': '2013-12-16T20:33:05.603', 'CommentCount': '9', 'AcceptedAnswerId': '18971', 'CreationDate': '2013-12-13T18:19:55.973', 'Id': '18959'}{'Body': u"<p>$\\mathrm{Halt} = \\{ (f,x) | f(x)\\downarrow \\}$ is r.e. (semi-decidable) but undecidable.</p>\n\n<p>$\\mathrm{Total} = \\{ f | \\forall x f(x)\\downarrow \\}$ is not r.e. (not even semi-decidable).</p>\n\n<p>I need some help in proving that $\\mathrm{Total}$ is not recursive (decidable). </p>\n\n<p>I know the diagonalization proof for the halting problem, I just need the same kind of proof for $\\mathrm{Total}$. I'm posting the proof for the halting problem for reference:</p>\n\n<h2>Undecidability of the halting problem</h2>\n\n<p>Assume we can decide the halting problem. Then there exists some total function $\\mathrm{Halt}$ such \nthat \n$$\n\\mathrm{Halt}(x,y) = \\begin{cases} 1 &amp; \\text{if $\\phi_x(y)$ is defined}, \\\\ 0 &amp; \\text{if $\\phi_x(y)$ is not defined}.\\end{cases}\n$$</p>\n\n<p>Here, we have numbered all programs and $\\phi_x$ refers to the $x$'th program in this ordering. We can view $\\mathrm{Halt}$ as a mapping from $\\mathbb{N}$ into $\\mathbb{N}$ by treating its input as a single number representing the pairing of two numbers via the one-one onto function \n$$ \\mathrm{pair}(x,y) = \\langle x,y \\rangle = 2^x (2y + 1) \u2013 1 , $$\nwith inverses \n$$\n\\begin{align*}\n \\langle z \\rangle_1 &amp;= \\exp(z+1,1), \\\\\n \\langle z \\rangle_2 &amp;= ((( z + 1 ) // 2^{\\langle z \\rangle_1}) \u2013 1 ) // 2 \n\\end{align*}\n$$\nNow if $\\mathrm{Halt}$ exists, then so does $\\mathrm{Disagree}$, where \n$$\n\\mathrm{Disagree}(x) = \\begin{cases} 0 &amp; \\text{if $\\mathrm{Halt}(x,x)=0$, i.e., if $\\phi_x(x)$ is not defined}, \\\\ \\operatorname*{\\mu}_y (y=y+1) &amp; \\text{if $\\mathrm{Halt}(x,x)=1$, i.e., if $\\phi_x(x)$ is defined}. \\end{cases}\n$$</p>\n\n<p>Since $\\mathrm{Disagree}$ is a program from $\\mathbb{N}$ into $\\mathbb{N}$, $\\mathrm{Disagree}$ can be reasoned about by $\\mathrm{Halt}$. Let $d$ \nbe such that $\\mathrm{Disagree} = \\phi_d$, then </p>\n\n<p>$$\\mathrm{Disagree}(d)\\text{ is defined} \\Leftrightarrow \\mathrm{Halt}(d,d) = 0 \\Leftrightarrow \u03a6_d(d)\\text{ is undefined} \u21d4 \\mathrm{Disagree}(d)\\text{ is undefined}.$$ </p>\n\n<p>But this means that $\\mathrm{Disagree}$ contradicts its own existence. Since every step we took was constructive, except for the original assumption, we must presume that the original assumption was in error. Thus, the halting problem is not decidable. </p>\n", 'ViewCount': '63', 'Title': 'How to prove that "Total" is not recursive (decidable)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T05:56:05.760', 'LastEditDate': '2014-04-07T05:56:05.760', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Michael Anthony Leber', 'PostTypeId': '1', 'Tags': '<computability><undecidability><halting-problem>', 'CreationDate': '2013-12-03T03:53:04.973', 'Id': '18980'}{'Body': '<p>I need help with showing that \n$$NeverHalt_{TM} = \\{\\langle M\\rangle \\mid \\text{$M$ is a TM which runs forever on every input $w$}\\}$$\nis undecidable by giving an explicit mapping reduction.</p>\n\n<p>To show that a language reduces to any other language we must show that yes-instances are mapped to yes-instances and no-instances are mapped to no instances. We need to find a TM whose language will "help" us solve $NeverHalt_{TM}$, given $\\langle M\\rangle$.</p>\n\n<p>I am not really sure where to go from here or in general how to proceed with undecidability problems.</p>\n', 'ViewCount': '66', 'Title': 'Mapping reduction to show NeverHalt is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T22:15:30.900', 'LastEditDate': '2014-02-02T22:15:30.900', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-12-17T00:13:34.353', 'Id': '19055'}{'Body': "<p>You probably know this one (or at least a version of it).<br>\nLet $P$ be a program code, and $w$ be an input string.<br>\nDefine $A_{TM}=\\left\\{(P,w)| P(w)=1\\right\\}$.<br>\nMeaning: $A_{TM}$ is the set of all ordered pairs $(P,w)$ s.t. $P$ accepts $w$.<br>\n$A_{TM}$ is undecidable.</p>\n\n<p>I just read the proof for it, that made me wonder about something.<br>\nThe brief of the proof (by contradiction) looks something like this:<br>\nSuppose there exist $D_{A_{TM}}$ - a computer program that answers 'yes' if $(P,w)\\in A_{TM}$, and 'no' if $(P,w)\\notin A_{TM}$.<br>\nLet us consider the following program:</p>\n\n<p>$Q(w):$<br>\n1. run $D_{A_{TM}}$ on $(w,w)$<br>\n2. if $D_{A_{TM}}$ returned 'yes', then return 'no'.\nif $D_{A_{TM}}$ returned 'no', return 'yes'.</p>\n\n<p>Now running $Q(w);$ with the input $Q$, contradicts the existence of such $D_{A_{TM}}$</p>\n\n<p>This is a brief, since I assume most of you already know this problem (and its proof).  </p>\n\n<p>Now what makes me wonder is this: when I looked at $A_{TM}$, and needed to determine if it's decidable or not, the first thing that came to my mind when I tried to imagine a machine that accepts $A_{TM}$, is how can machine like that handle inputs $(P,w)$ s.t. $P$ doesn't halt on $w$?  How can it 'predicts', beforehand, that $P(w)$ goes to an infinite loop, without actually running $P$ on $w$?<br>\nThat intuition, as it turns out, wasn't wrong.<br>\nThe thing is: How come the proof, as clever as it is, has nothing to do with that fact?<br>\nYou'd expect it to lean - and even in the slightest way - on that leverage, but instead, the proof looks like something that was taken from the realm of paradoxes.</p>\n\n<p>Basically, what I'm asking is: why does this proof work?</p>\n", 'ViewCount': '41', 'Title': 'Question about the undecidability of $A_{TM}$', 'LastActivityDate': '2013-12-19T15:25:33.670', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-12-19T14:24:23.117', 'Id': '19120'}{'Body': "<p>I'm trying to find a formal proof of the following fact:</p>\n\n<blockquote>\n  <p>Given a context-free language $L_1$ and a context-sensitive language $L_2$, it is NOT decidable if their intersection is empty ($L_1 \\cap L_2 = \\varnothing$).</p>\n</blockquote>\n\n<p>I want to be able to prove it by contradiction, knowing the fact that it's undecidable to say if a given context sensitive grammar is empty.</p>\n\n<p>I know that the intersection of two context-free languages is undecidable, but I have to make a formal proof by contradiction. Taking $L_1$ as $\\Sigma^*$ ends up with a CS intersection, ok that's fine but I would like to make a better and more formal proof, without recurring to take specific languages, in a more general way... </p>\n", 'ViewCount': '76', 'Title': 'Intersection between context-free and context-sensitive language decidability', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-28T16:25:05.513', 'LastEditDate': '2013-12-28T16:25:05.513', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12405', 'Tags': '<computability><context-free><automata><undecidability><context-sensitive>', 'CreationDate': '2013-12-27T14:51:43.293', 'Id': '19326'}{'Body': '<p>An exercise that was in a past session is the following:</p>\n\n<blockquote>\n  <p>Prove that there exists an undecidable subset of $\\{1\\}^*$</p>\n</blockquote>\n\n<p>This exercise looks very strange to me, because I think that all subsets are decidable.</p>\n\n<p>Is there a topic that I should read to find a possible answer?</p>\n', 'ViewCount': '545', 'Title': 'Undecidable unary languages (also known as Tally languages)', 'LastEditorUserId': '851', 'LastActivityDate': '2013-12-28T13:47:57.850', 'LastEditDate': '2013-12-28T13:47:57.850', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '19331', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<reference-request><turing-machines><undecidability>', 'CreationDate': '2013-12-27T18:20:42.287', 'Id': '19329'}{'Body': u'<p>As I have studied, deciding regularity of context-free languages is undecidable.</p>\n\n<p>However, we can test for regularity using the Myhill\u2013Nerode theorem which provides a necessary and sufficient condition. So the problem should be decidable.</p>\n\n<p>Where is my mistake?</p>\n', 'ViewCount': '151', 'Title': 'Why is deciding regularity of a context-free language undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-05T17:18:35.267', 'LastEditDate': '2014-01-04T18:39:42.627', 'AnswerCount': '1', 'CommentCount': '14', 'AcceptedAnswerId': '19500', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12569', 'Tags': '<formal-languages><computability><regular-languages><undecidability>', 'CreationDate': '2014-01-03T12:37:01.957', 'Id': '19482'}{'Body': "<p>Given a turing machine $T$ that receives an encoding of another turing machine and a word $&lt;M&gt;&lt;w&gt;$, can $T$ 'run' through the encoding and 'mark' specific transitions/states?</p>\n\n<p>For example, if I want to show that the language $L = \\{&lt;M&gt;&lt;w&gt;\\}$ such that when we run $w$ in $M$ we will visit at least two unique states different than the starting state.</p>\n\n<p>Now for this, I suggested this algorithm, but I am not sure it is even compuatable:</p>\n\n<blockquote>\n  <p>Given the encoding $&lt;M&gt;&lt;w&gt;$, we will run through the encoding and 'mark' all states that can be reached from the starting state of $M$, if two or more states have been marked after finishing, accept, else, reject. </p>\n</blockquote>\n\n<p>I know that since this an encoding of a turing machine and a word, we indeed -can- run through the encoding. But can we really do the 'marking' operation? if so, how?</p>\n", 'ViewCount': '34', 'Title': "Turing Machine 'marking' specific portion of encoding", 'LastActivityDate': '2014-01-07T19:09:03.653', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19565', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<computability><undecidability>', 'CreationDate': '2014-01-07T18:33:38.510', 'Id': '19562'}{'Body': '<p>As far as I understand, a <code>semi-decidable (recursively enumerable)</code> problem could be: </p>\n\n<blockquote>\n  <ol>\n  <li>decidable (recursive) or </li>\n  <li>undecidable (nonrecursively enumerable)</li>\n  </ol>\n</blockquote>\n\n<p>This <a href="http://stackoverflow.com/questions/9453916/why-arent-recursively-enumerable-languages-undecidable">post</a> made me wonder if this is not conventionally followed. <a href="http://stackoverflow.com/questions/9453916/why-arent-recursively-enumerable-languages-undecidable/21056763#21056763">This</a> is my answer to it and as far as I understand it is correct:</p>\n\n<blockquote>\n  <p>A semidecidable problem (or equivalently a recursively enumerable\n  problem) could be:</p>\n  \n  <p>Decidable: If the problem and its complement are both semidecidable\n  (or recursively enumerable), then the problem is decidable\n  (recursive).</p>\n  \n  <p>Undecidable: If the problem is semidecidable and its complement is not\n  semidecidable (that is, is not recursively enumerable).</p>\n  \n  <p>Important note: Remember that a decidable (recursive) problem is also\n  semidecidable (recursively enumerable). Conversely, if a problem is\n  not recursively enumerable (semidecidable), then is not recursive\n  (decidable).</p>\n  \n  <p>What the Wikipedia entry says is that:</p>\n  \n  <p>Partially decidable problems THAT ARE NOT DECIDABLE are called\n  undecidable.</p>\n  \n  <p>In general, a semidecidable problem (recursively enumerable) could be\n  decidable (recursive) or undecidable (nonrecursively enumerable).</p>\n  \n  <p>Also note that a problem and its complement could both (or just one of\n  them) be not even semi-decidable (nonrecursively enumerable). Also\n  note that, if a problem is recursive, its complement is also\n  recursive.</p>\n</blockquote>\n\n<p>Is it conventionally (always) understood this way? Is there some literature that presents semi-decidability (partially decidable, recursively enumerable) problem as an equivalent of undecidability?</p>\n', 'ViewCount': '104', 'Title': 'Can a semi-decidable problem be also decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:44.787', 'LastEditDate': '2014-01-18T20:20:44.787', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19642', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<terminology><computability><undecidability><semi-decidability>', 'CreationDate': '2014-01-11T00:45:42.170', 'Id': '19641'}{'Body': "<p>This is an exercise I've been struggling with for a while: </p>\n\n<blockquote>\n  <p>Let $g : \\mathbb{N} \\to \\mathbb{N}$ be a total, non-decreasing function, i.e. $\\forall x &gt; y.\\ g(x) \\geq g(y)$. Is the image $I_g$ of $g$ a recursive set?</p>\n</blockquote>\n\n<p>Intuitively, I know that the image $I_{g}$ is not recursive, as $g$ is not strictly monotonic. In fact, it's because that $g$ is not strictly monotonic that $g$ could be a constant function so testing if $y \\in I_{g}$  may not finish as it could be that $\\forall x, g(x) = c$, $c$ being a constant s.t. $c &lt; y$. Then, testing if there is an $x$ s.t. $g(x) = y$ incrementing $x$ as the $g(x) &lt; y$ may go forever.  On the other hand, it could be that after a while, (for a sufficiently greater $x$) it happens that $g(x) &gt; c$ and $g(x) = y$. If it were stricly monotonic, though, then it would be recursive as I would be able to test if $y = g(x)$ incrementing $x$ until the equality is satisfied or $g(x) &gt; y$ (then $g(x)$ wouldn't get stuck in the same value because $x_1 &gt; x_2$ implies $g(x_1) &gt; g(x_2)$).</p>\n\n<p>However, I haven't been able to prove this formally. Can this intuition become part of a formal proof? Or at least could you give me some help in proving it in some other way? A hint or some outline of a proof would be great.</p>\n", 'ViewCount': '133', 'Title': 'Is the image of a total, non-decreasing function decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T07:35:02.383', 'LastEditDate': '2014-01-15T18:19:25.850', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '19752', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2014-01-15T01:15:56.527', 'Id': '19732'}{'ViewCount': '70', 'Title': 'Understanding a proof for the existance of a non-computable function', 'LastEditDate': '2014-01-18T10:06:25.117', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12924', 'FavoriteCount': '1', 'Body': "<p>For school, we have a proof that some functions are not Turing computable.\nThe example is:\n$$ G(k) = \\begin{cases} f_k(k) + 1 &amp; \\text{ if $f_k(k)$ is defined}, \\\\ 1 &amp; \\text{ otherwise}.\\end{cases} $$</p>\n\n<p>Claim: $G$ is non computable.</p>\n\n<p>Proof: In view of obtaining a contradiction, let's say $G$ is computable, say by the $k$th Turing machine.\nGive the encoding of this $k$th Turing machine as an argument for $G$.\nThis leads to a contradiction: if $f_k(k)$ is defined, then $f_k(k)$ is not equal to $g(k) = f_k(k) + 1$. Else $f_k(k)$ is undefined and not equal to $g(k) = 1$.</p>\n\n<p>I don't understand the contradiction, help please...</p>\n", 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-18T10:06:25.117', 'CommentCount': '4', 'AcceptedAnswerId': '19793', 'CreationDate': '2014-01-17T18:17:02.093', 'Id': '19788'}{'Body': '<p>Given the problem $EQ_{TM} = \\{ \\langle M_1,  M_2\\rangle \\mid M_1 \\text{ and } M_2 \\text{ are } TM, L_{M_1} = L_{M_2}\\}$, is it possible to prove that this is undecidable by using (a variant of) Rice theorem?</p>\n\n<p>I have proven this problem by reduction to $E_{TM}$, but was wondering if it was easier to do with Rice.</p>\n', 'ViewCount': '65', 'Title': 'Is it possible to prove EQTM is undecidable by the Rice theorem?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-21T22:47:38.397', 'LastEditDate': '2014-01-21T22:47:38.397', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19877', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2014-01-21T19:17:43.390', 'Id': '19876'}{'Body': u'<p>I have this question about if the decidability of an regular expression and would appreciate if someone can check my answer and see if it makes sense, and if not, what is missing.</p>\n\n<blockquote>\n  <p>Be A = {(R)|R it is a regular expression that describes a language containing at least a w string that has 111 as a substring (that it is, w=x111y to some x and some y)}. Show that A it is decidible</p>\n</blockquote>\n\n<p>Answer: Create a turing machine P, this machine receives a pair where R is the regular expression in question and W is the set of all the strings of the form x111y. P converts R into a NFA called NFAR. It sends the pair to a TM N that acts as a subrotine of it. N will convert NFAR into a DFA called DFAR. Then inside this machine N, there is a turing machine M inside it, also acting as a subrotine. It sends the pair to M. When M receives its input, it will first determines whether it properly represents a DFA DFAR an a set of strings W. If not, it will reject, and as a result, so will N and then P. Otherwise, It will start to simulate DFAR over the first string w(i) of W (where i=0,1,2... n\xb0 last input string). If DFAR accepts, M halts in the accept state, and so will N and then P. Otherwise M will continue to loop through all the strings of W. If it reaches the last w(i) and it is not accepted, M will halt in the refect state and so will N and then P.</p>\n\n<p>My fear is that the number of strings to be tested is infinite, so M could enter in a loop?</p>\n', 'ViewCount': '52', 'Title': 'Decidability of an regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:29:41.253', 'LastEditDate': '2014-01-25T16:29:41.253', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13113', 'Tags': '<computability><regular-languages><undecidability>', 'CreationDate': '2014-01-24T23:42:36.657', 'Id': '19952'}{'ViewCount': '18', 'Title': 'Decidability of fullness of intersection of a CSL with a regular language', 'LastEditDate': '2014-02-06T16:30:23.490', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'vzn', 'PostTypeId': '1', 'OwnerUserId': '699', 'Body': '<p>Let $L_r$ be a regular language with alphabet $\\Sigma$ and $L_{\\text{csl}}$ be a context sensitive language. Are any of the following questions decidable?</p>\n\n<ol>\n<li>$L_r \\cap L_\\text{csl} \\stackrel{?}{=} L_r$</li>\n<li>$\\Sigma^* \\cap L_\\text{csl} \\stackrel{?}{=} L_r$</li>\n<li>$L_r \\cap L_\\text{csl} \\stackrel{?}{=} \\Sigma^*$</li>\n<li>$\\Sigma^* \\cap L_\\text{csl} \\stackrel{?}{=} \\Sigma^*$</li>\n</ol>\n\n<p>I understand that (1) implies the others. I am also looking for any "near variants" that might be decidable.</p>\n', 'Tags': '<formal-languages><computability><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T16:30:23.490', 'CommentCount': '0', 'AcceptedAnswerId': '21384', 'CreationDate': '2014-01-18T17:05:04.703', 'Id': '21383'}{'ViewCount': '107', 'Title': 'Determining if a context-free grammar produces even-length strings', 'LastEditDate': '2014-02-06T21:11:48.003', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14447', 'Body': '<p>Given a context-free grammar, is there an algorithm to determine if the CFG will ever produce an even length string? Or is this undecidable?</p>\n', 'ClosedDate': '2014-02-15T04:33:24.287', 'Tags': '<computability><context-free><formal-grammars><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T21:11:48.003', 'CommentCount': '1', 'AcceptedAnswerId': '21396', 'CreationDate': '2014-02-06T17:46:33.243', 'Id': '21390'}{'Body': '<p>I am reducing a given Turing Machine to the complement of the known undecidable problem, \n$$ Complement(A_{TM}) = \\{ \\langle M,w \\rangle \\mid M  \\text{ is TM}, w \\not\\in L(M) \\}$$</p>\n\n<p>To this Turing Machine, known as SPARSE TM:\n$$\nSPARSE_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is 1-tape TM}, |L(M)| \\leq 1000\\} \n$$</p>\n\n<p>Here is what I have so far, but I think I need help because one of the statements I make seems fishy.</p>\n\n<p>Assume there is a TM <code>S</code> that decides the complement of the accept TM and a TM <code>R</code> that decides SPARSE. Then <code>S</code> looks like:</p>\n\n<pre><code>S = "On input `&lt;M,w&gt;`:\n    Construct M\':\n        M\' = "On input x:\n            if x in L(M):  #Fishy statement\n                accept\n            else: reject\n     Run R on &lt;M\'&gt;\n     if R accepts: accept; if R rejects: reject\n</code></pre>\n\n<p>This (if right) would then reduce the SPARSE TM and prove that it is undeciable, right? Any help would be appreciated.</p>\n', 'ViewCount': '89', 'Title': 'Reduction to complement of Accept Problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T00:25:49.743', 'LastEditDate': '2014-02-06T21:17:23.187', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21410', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<computability><turing-machines><reductions><undecidability>', 'CreationDate': '2014-02-06T20:30:09.477', 'Id': '21400'}{'Body': "<p>Is there a way to show that for all <em>finite</em> sets $S$ of context free grammars, there exists a Turing Machine $M$ such that for all grammars $G_1, G_2 \\in S$, we have that $M(G1,G2)$ terminates and answer yes if and only if $L(G_1)=L(G_2)$? Is that even true?</p>\n\n<p>I know that this problem is in general undecidable, but I also know that a finite set is in general decidable. I just can't figure out how to determine the answer for this problem.</p>\n", 'ViewCount': '85', 'Title': 'Is equivalence of CFGs decidable for finite sets of grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T17:25:01.883', 'LastEditDate': '2014-02-12T08:32:58.760', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '21542', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14581', 'Tags': '<computability><undecidability>', 'CreationDate': '2014-02-11T20:07:00.393', 'Id': '21537'}{'Body': '<p>This question is prompted by <a href="http://cs.stackexchange.com/questions/19329/undecidable-unary-languages-also-known-as-tally-languages">Undecidable unary languages (also known as Tally languages)</a></p>\n\n<p>How does the countability of a language imply (un)decidability?</p>\n', 'ViewCount': '52', 'Title': 'Undecidability and Countability', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-13T21:45:51.177', 'LastEditDate': '2014-02-13T21:45:51.177', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14650', 'Tags': '<undecidability><uncountability>', 'CreationDate': '2014-02-13T21:20:47.597', 'Id': '21609'}{'Body': '<p>Given a linear grammar G, is it possible to determine if L(G) contains a palindrome?</p>\n', 'ViewCount': '44', 'Title': 'Palindromes and linear grammars', 'LastActivityDate': '2014-02-20T16:01:25.377', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14447', 'Tags': '<formal-languages><undecidability>', 'CreationDate': '2014-02-20T15:12:23.643', 'Id': '21848'}{'Body': '<p>Nobody yet knows if ${\\sf P}={\\sf NP}$. Let us consider the following language</p>\n\n<p>$$L = \\begin{cases} (0+1)^* &amp; \\text{ if ${\\sf P}$ = ${\\sf NP}$} \\\\ \\emptyset &amp;\\text{ otherwise}. \\end{cases}$$</p>\n\n<p>A language is said to be recursive if there exists any rule to determine whether a string belong to language or not. We have a rule here, but the rule itself depends upon an unknown equation. So can we say $L$ is recursive?</p>\n', 'ViewCount': '121', 'Title': 'Is this language depending on P = NP recursive?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-26T05:55:59.580', 'LastEditDate': '2014-02-25T20:21:10.610', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12234', 'Tags': '<computability><undecidability><p-vs-np>', 'CreationDate': '2014-02-25T08:55:19.393', 'Id': '22017'}{'Body': "<p>I am studying for my algorithms final and came across the following problem:</p>\n\n<p>Find three languages $L_1 \\subset L_2 \\subset L_3$ over the same alphabet such that $L_2 \\in P$ and $L_1,L_3$ are undecidable.</p>\n\n<p>I am having trouble coming up with an example of three such languages. My first thought was to use a form of the halting problem for both $L_1$ and $L_3$ since that is pretty much the only undecidable language I know and am familiar with. I was thinking of perhaps coming up with something of the form \n\\begin{align*}\nL_1 &amp;= \\{M \\mid \\text{$M$ is a Turing machine that starts with 00 and halts}\\}\\\\\nL_2 &amp;= \\{M \\mid \\text{$M$ is a Turing machine that starts with a 00}\\}\\\\\nL_3 &amp;= ?\n\\end{align*}\nbut this doesn't seem to be working.  Any ideas are appreciated!</p>\n", 'ViewCount': '468', 'Title': 'Sandwiching Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T07:51:13.653', 'LastEditDate': '2014-03-18T07:51:13.653', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22737', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '15615', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2014-03-18T00:29:05.380', 'Id': '22735'}{'Body': "<p>does there exist two undecidable languages such that their union is decidable? \nwhat about a decidable intersection? </p>\n\n<p>One thing that I've been trying to figure out is if J and K are both undecidable but finite set, then the union would be finite and decidable. However, I have not thought of such a set yet. </p>\n", 'ViewCount': '9', 'ClosedDate': '2014-03-20T08:59:23.967', 'Title': 'two undecidable languages with a decidable union/intersection?', 'LastActivityDate': '2014-03-20T01:34:04.573', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15045', 'Tags': '<undecidability><decision-problem>', 'CreationDate': '2014-03-20T01:34:04.573', 'Id': '22838'}{'Body': '<p>Given that Let S = {a | |a| is odd}. I know that since S is decidable, but does there exist a subset within S that is undecidable?</p>\n', 'ViewCount': '74', 'ClosedDate': '2014-03-21T00:04:46.543', 'Title': "how do I find a undecidable subset of a set that's decidable?", 'LastActivityDate': '2014-03-20T01:59:19.380', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22841', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15045', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2014-03-20T01:41:32.803', 'Id': '22839'}{'Body': '<p>I have read in <a href="https://en.wikipedia.org/wiki/Halting_problem#Common_pitfalls" rel="nofollow">Wikipedia</a> and some other texts that</p>\n\n<blockquote>\n  <p>The halting problem is [...] decidable for <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" rel="nofollow">linear bounded\n  automata</a> (LBAs) [and] deterministic machines with finite memory.</p>\n</blockquote>\n\n<p>But earlier it is written that the halting problem is an undecidable problem and thus TM can\'t solve it! Since LBA are defined as a type of TM, should the same not hold for them?</p>\n', 'ViewCount': '192', 'Title': 'Why is the halting problem decidable for LBA?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-22T13:15:09.093', 'LastEditDate': '2014-03-22T13:15:09.093', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<turing-machines><automata><undecidability><halting-problem><linear-bounded-automata>', 'CreationDate': '2014-03-22T02:06:19.990', 'Id': '22925'}{'Body': '<p>It seems like the proof that $A_{DFA}$ is decidable in <a href="http://rads.stackoverflow.com/amzn/click/0534950973" rel="nofollow">Sipser (2nd ed.)</a> assumes the computation will halt... and hence only really proves that $A_{DFA}$ is recognizable. </p>\n\n<p>The language $A_{DFA}$ is defined by $A_{DFA} = \\{\\langle B, w \\rangle \\mid B \\text{ is a } \\mathsf{DFA} \\text{ that accepts input string } w \\}$.</p>\n\n<p>Here is the passage (I\'ve bolded the most relevant sentence):</p>\n\n<blockquote>\n  <p>First, let\'s examine the input $\\langle B, w \\rangle$. It is a representation of a $\\mathsf{DFA}$ $B$ together with a string $w$. One reasonable representation of $B$ is simply a list of its five components, $Q$, $\\Sigma$, $\\delta$, $q_0$, and $F$. When $M$ receives its input, $M$ first determines whether it properly represents a $\\mathsf{DFA}$ $B$ and a string $w$. If not, $M$ rejects.</p>\n  \n  <p>Then $M$ carries out the simulation directly. It keeps track of $B$\'s current state and $B$\'s current position in the input $w$ by writing this information down on its tape. Initially, $B$\'s current state is $q_0$ and $B$\'s current input position is the leftmost symbol of $w$. The states and position are updated according to the specified transition function $\\delta$. <strong>When $M$ finishes processing the last symbol of $w$, $M$ accepts the input if $B$ is in an accepting state; $M$ rejects the input if $B$ is in a nonaccepting state.</strong></p>\n</blockquote>\n\n<p>Am I missing something or is this proof bogus?</p>\n\n<p><strong>EDIT</strong>: Never mind, I think I see my problem. A Turing machine may move back and forth, never halting, but an automaton like $B$ given finite input $w$ finishes after $|w|$ steps, correct? So $M$ does halt. Feel free to post an answer explaining this yourself - I don\'t want anyone to miss out on a chance to answer by me deleting the question. If no one responds within a day, I\'ll post an answer myself.</p>\n', 'ViewCount': '35', 'Title': 'Proof that $A_{DFA}$ is decidable in Sipser', 'LastEditorUserId': '12588', 'LastActivityDate': '2014-03-29T18:56:59.760', 'LastEditDate': '2014-03-29T18:56:59.760', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23226', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<formal-languages><finite-automata><undecidability>', 'CreationDate': '2014-03-29T18:04:51.747', 'Id': '23225'}{'Body': "<p>In Sipser's Introduction to the Theory of Computation, there is an exercise that asks to prove $T$ decides $A_{TM}$, which is the language </p>\n\n<p>$$A_{TM} = \\{ \\langle M,w \\rangle | M \\text{ is a TM and $w \\in L(M)$}\\}.$$</p>\n\n<p>$T$ is a TM defined as follows. On input $\\langle M,w \\rangle$,</p>\n\n<ol>\n<li>Write the description of a TM $R$ that works as follows. On input $x$,\n<ul>\n<li>Run $T_A$ on $x$.</li>\n<li>If $T_A$ accepts $x$ then accept.</li>\n<li>If $T_A$ rejects $x$ then run $M$ on input $w$ and accept if $M$ does.</li>\n</ul></li>\n<li>Run $P$ on input $\\langle R \\rangle$, accept if $P$ rejects and reject if $P$ accepts.</li>\n</ol>\n\n<p>Here:</p>\n\n<ul>\n<li>$T_A$ is a TM that decides the language $A$.</li>\n<li>$P$ is a TM that can decide the language\n$$  Z = \\{\\langle M\\rangle | M\\text{ is a TM and } L(M) = A\\}. $$   </li>\n<li>$ A = \\{(0 \\cup 1)^a(1 \\cup 2)^b(2 \\cup 3)^c | a \\geq b\\} $.</li>\n</ul>\n\n<p>How can you prove that $T$ decides $A_{TM}$ ?</p>\n", 'ViewCount': '23', 'ClosedDate': '2014-04-14T07:50:11.927', 'Title': 'How do you prove that this TM decides a language that is undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-14T07:49:33.580', 'LastEditDate': '2014-04-14T07:49:33.580', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2014-04-14T02:08:14.150', 'Id': '23770'}{'Body': "<p>Let $L = \\{ &lt;M&gt; | M$ halts on every input $x$ in at most $200 * |x|$ steps $\\}$. </p>\n\n<p>Is $L$ decidable? Recognizable?</p>\n\n<p>Given that membership in $L$ asserts something about $M$'s behavior on an infinite set of strings, it seems extremely unlikely to me that $L$ could be either. I have shown that co-$L$ is Turing-recognizable (I think): you can make an enumerator that tests each $M_1, M_2, \\dots, $ for each $s_1, s_2, \\dots$ and emits $M$ if it does not accept some $s$ in at most $200|x|$ steps.</p>\n\n<p>Since co-$L$ is recognizable, either $L$ is not recognizable, or it is decidable. I can't imagine that $L$ is decidable. However, it definitely cannot be reduced to the halting problem, nor can Rice's theorem be applied to it (since the quality in question is the quality of halting in a particular number of steps, being able to decide it doesn't let us decide other arbitrary properties).</p>\n\n<p>It seems to me that the best way to go will be to show that $L$ lets me recognize something that is unrecognizable, since the only problems it solves are ones which require me to run over infinite sets of strings. But I can't think of what this could be. I thought that maybe co-HALT would work, but I can't ever prove that a TM will never halt on some input.</p>\n\n<p>I'm stuck. What direction should I go in?</p>\n", 'ViewCount': '38', 'Title': 'Deciding the set of all Turing machines that halt in at most $k|x|$ steps $\\forall x \\in \\Sigma^*$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-16T12:31:22.373', 'LastEditDate': '2014-04-16T12:31:22.373', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16612', 'Tags': '<computability><turing-machines><undecidability><decision-problem>', 'CreationDate': '2014-04-16T09:25:10.423', 'Id': '23849'}{'Body': '<p>So suppose we have a functional inequality with polynomial arguments in $2$ variables, $\\sum_i c_i f(p_i(x,y)) \\geq 0$, where $c_i$ are say given integer constants and $p_i$ are given polynomials, say with integer coefficients. We want the inequality to hold for all $x,y \\in \\mathbb{R}$.</p>\n\n<p>Is it a decidable problem to determine whether there are non-constant real-valued functional solutions for $f:{\\mathbb R} \\to {\\mathbb R}$?</p>\n\n<p>A recent problem of this flavor came up on math.stackexchange, which was to determine any non-constant solutions to $f(x) + f(y) \\geq f(x + y) + f(xy)$. I wondered whether it was possible to determine the existence question with an algorithm rather than ad hoc analysis.</p>\n', 'ViewCount': '16', 'Title': 'Is deciding whether there is a non-constant solution to a functional inequality with polynomial arguments decidable, with 2 variables?', 'LastEditorUserId': '755', 'LastActivityDate': '2014-05-01T22:13:34.133', 'LastEditDate': '2014-05-01T22:13:34.133', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9584', 'Tags': '<algorithms><undecidability>', 'CreationDate': '2014-05-01T21:07:09.223', 'Id': '24309'}