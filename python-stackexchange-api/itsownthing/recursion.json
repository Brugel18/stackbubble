{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider an inductive type which has some recursive occurrences in a nested, but strictly positive location. For example, trees with finite branching with nodes using a generic list data structure to store the children.</p>\n\n<pre><code>Inductive LTree : Set := Node : list LTree -&gt; LTree.\n</code></pre>\n\n<p>The naive way of defining a recursive function over these trees by recursing over trees and lists of trees does not work. Here\'s an example with the <code>size</code> function that computes the number of nodes.</p>\n\n<pre><code>Fixpoint size (t : LTree) : nat := match t with Node l =&gt; 1 + (size_l l) end\nwith size_l (l : list LTree) : nat := match l with\n    | nil =&gt; 0\n    | cons h r =&gt; size h + size_l r\n  end.\n</code></pre>\n\n<p>This definition is ill-formed (error message excerpted):</p>\n\n<pre><code>Error:\nRecursive definition of size_l is ill-formed.\nRecursive call to size has principal argument equal to\n"h" instead of "r".\n</code></pre>\n\n<p>Why is the definition ill-formed, even though <code>r</code> is clearly a subterm of <code>l</code>? Is there a way to define recursive functions on such a data structure?</p>\n\n<hr>\n\n<p>If you aren\'t fluent in Coq syntax: <code>LTree</code> is an inductive type corresponding to the following grammar.</p>\n\n<p>$$\\begin{align}\r\n  \\mathtt{LTree} ::= &amp; \\\\\r\n  \\vert &amp; \\mathtt{list}(\\mathtt{LTree}) \\\\\r\n\\end{align}$$</p>\n\n<p>We attempt to define the <code>size</code> function by induction over trees and lists. In OCaml, that would be:</p>\n\n<pre><code>type t = Node of t list\nlet rec size = function Node l -&gt; 1 + size_l l\nand size_l = function [] -&gt; 0\n                    | h::r -&gt; size h + size_l r\n</code></pre>\n', 'ViewCount': '481', 'Title': 'Recursive definitions over an inductive type with nested components', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-29T18:24:01.597', 'LastEditDate': '2012-03-29T18:24:01.597', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<logic><coq><type-theory><recursion><proof-assistants>', 'CreationDate': '2012-03-07T17:38:37.210', 'Id': '104'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to create a recursive algorithm to see if a binary tree is a binary search tree as well as count how many complete branches are there (a parent node with both left and right children nodes) with an assumed global counting variable. This is an assignment for my data structures class. </p>\n\n<p>So far I have</p>\n\n<pre><code>void BST(tree T) {\n   if (T == null) return\n   if ( T.left and T.right) {\n      if (T.left.data &lt; T.data or T.right.data &gt; T.data) {\n        count = count + 1\n        BST(T.left)\n        BST(T.right)\n      }\n   }\n}\n</code></pre>\n\n<p>But I can't really figure this one out. I know that this algorithm won't solve the problem because the count will be zero if the second if statement isn't true.</p>\n\n<p>Could anyone help me out on this one? </p>\n", 'ViewCount': '1727', 'Title': 'Algorithm to test whether a binary tree is a search tree and count complete branches', 'LastEditorUserId': '79', 'LastActivityDate': '2012-03-07T22:25:59.700', 'LastEditDate': '2012-03-07T22:25:59.700', 'AnswerCount': '3', 'CommentCount': '14', 'AcceptedAnswerId': '113', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '79', 'Tags': '<algorithms><recursion><trees>', 'CreationDate': '2012-03-07T19:47:33.067', 'Id': '105'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1181', 'Title': 'Examples of sophisticated recursive algorithms', 'LastEditDate': '2012-03-31T22:18:18.110', 'AnswerCount': '6', 'Score': '10', 'OwnerDisplayName': 'elektronaj', 'PostTypeId': '1', 'OwnerUserId': '859', 'FavoriteCount': '1', 'Body': '<p>I was explaining the famous deterministic <a href="http://en.wikipedia.org/wiki/Selection_algorithm#Linear_general_selection_algorithm_-_Median_of_Medians_algorithm">linear-time selection algorithm</a> (median of medians algorithm) to a friend.</p>\n\n<p>The recursion in this algorithm (while being very simple) is quite sophisticated. There are two recursive calls, each with different parameters.</p>\n\n<p>I was trying to find other examples of such interesting recursive algorithms, but could not find any. All of the recursive algorithms I could come up with are either simple tail-recursions or simple divide and conquer (where the two calls are "the same").</p>\n\n<p>Can you give some examples of sophisticated recursion?</p>\n', 'Tags': '<algorithms><recursion>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-02T09:17:34.660', 'CommentCount': '10', 'CreationDate': '2012-03-31T19:31:29.977', 'Id': '923'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3834', 'Title': 'When to use recursion?', 'LastEditDate': '2014-01-13T09:05:58.140', 'AnswerCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '1157', 'FavoriteCount': '5', 'Body': '<p>When are some (relatively) basic (think first year college level CS student) instances when one would use recursion instead of just a loop? </p>\n', 'Tags': '<algorithms><recursion>', 'LastEditorUserId': '1157', 'LastActivityDate': '2014-01-13T09:05:58.140', 'CommentCount': '1', 'AcceptedAnswerId': '1435', 'CreationDate': '2012-04-21T20:57:29.993', 'Id': '1418'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '234', 'Title': 'Recursion for runtime of divide and conquer algorithms', 'LastEditDate': '2012-05-10T16:31:21.383', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'user1422', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': "<p>A divide and conquer algorithm's work at a specific level can be simplified into the equation:</p>\n\n<p>$\\qquad \\displaystyle O\\left(n^d\\right) \\cdot \\left(\\frac{a}{b^d}\\right)^k$</p>\n\n<p>where $n$ is the size of the problem, $a$ is the number of sub problems, $b$ is the factor the size of the problem is broken down by at each recursion, $k$ is the level, and $d$ is the exponent for Big O notation (linear, exponential etc.).</p>\n\n<p>The book claims  if the ratio is greater than one the sum of work is given by the last term on the last level, but if it is less than one the sum of work is given by the first term of the first level. Could someone explain why this is true?</p>\n", 'Tags': '<algorithm-analysis><asymptotics><runtime-analysis><recursion><mathematical-analysis>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T16:31:21.383', 'CommentCount': '0', 'AcceptedAnswerId': '1746', 'CreationDate': '2012-05-09T03:13:56.910', 'Id': '1745'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3538', 'Title': 'Left recursion and left factoring -- which one goes first?', 'LastEditDate': '2014-01-23T17:17:37.047', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '2', 'Body': '<p>if I have a grammar having a production that contains both left recursion and left factoring like </p>\n\n<p>$\\qquad \\displaystyle F \\to FBa \\mid cDS \\mid c$ </p>\n\n<p>which one has priority, left recursion or left factoring?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:37.047', 'CommentCount': '3', 'AcceptedAnswerId': '2720', 'CreationDate': '2012-07-11T16:32:10.717', 'Id': '2696'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1273', 'Title': 'Removing Left Recursion from Context-Free Grammars - Ordering of nonterminals', 'LastEditDate': '2014-01-23T17:17:28.390', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'clebert', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': u'<p>I have recently implemented the Paull\'s algorithm for removing left-recursion from context-free grammars:</p>\n\n<blockquote>\n  <p>Assign an ordering $A_1, \\dots, A_n$ to the nonterminals of the grammar.</p>\n  \n  <p>for $i := 1$ to $n$ do begin<br>\n  $\\quad$ for $j:=1$ to $i-1$ do begin<br>\n  $\\quad\\quad$ for each production of the form $A_i \\to A_j\\alpha$ do begin<br>\n  $\\quad\\quad\\quad$ remove $A_i \\to A_j\\alpha$ from the grammar<br>\n  $\\quad\\quad\\quad$ for each production of the form $A_j \\to \\beta$ do begin<br>\n  $\\quad\\quad\\quad\\quad$ add $A_i \\to \\beta\\alpha$ to the grammar<br>\n  $\\quad\\quad\\quad$ end<br>\n  $\\quad\\quad$ end<br>\n  $\\quad$ end<br>\n  $\\quad$ transform the $A_i$-productions to eliminate direct left recursion<br>\n  end</p>\n</blockquote>\n\n<p>According to <a href="http://research.microsoft.com/pubs/68869/naacl2k-proc-rev.pdf" rel="nofollow" title="Removing Left Recursion from Context-Free Grammars">this document</a>, the efficiency of the algorithm crucially depends on the ordering of the nonterminals chosen in the beginning; the paper discusses this issue in detail and suggest optimisations.</p>\n\n<p>Some notation:</p>\n\n<blockquote>\n  <p>We will say that a symbol $X$ is a <em>direct left corner</em> of\n  a nonterminal $A$, if there is an $A$-production with $X$ as the left-most symbol on the right-hand side. We define the <em>left-corner relation</em> to be the reflexive transitive closure of the direct-left-corner relation, and we define the <em>proper-left-corner relation</em> to be the transitive closure of\n  the direct-left-corner relation. A nonterminal is <em>left recursive</em> if it is a proper left corner of itself; a nonterminal is <em>directly left recursive</em> if it is a direct left corner of itself; and a nonterminal is <em>indirectly left recursive</em> if it is left recursive, but not directly left recursive.</p>\n</blockquote>\n\n<p>Here is what the authors propose:</p>\n\n<blockquote>\n  <p>In the inner loop of Paull\u2019s algorithm, for nonterminals $A_i$ and $A_j$, such that $i &gt; j$ and $A_j$ is a direct left corner of $A_i$, we replace all occurrences of $A_j$ as a direct left corner of $A_i$ with all possible expansions of $A_j$.</p>\n  \n  <p>This only contributes to elimination of left recursion from the grammar if $A_i$ is a left-recursive nonterminal, and $A_j$ lies on a path that makes $A_i$ left recursive; that is, if $A_i$ is a left corner of $A_j$ (in addition to $A_j$ being a left corner of $A_i$).</p>\n  \n  <p>We could eliminate replacements that are useless in removing left recursion if we could order the nonterminals of the grammar so that, if $i &gt; j$ and $A_j$ is a direct left corner of $A_i$, then $A_i$ is also a left corner of $A_j$.</p>\n  \n  <p>We can achieve this by ordering the nonterminals in decreasing order of the number of distinct left corners they have.</p>\n  \n  <p>Since the left-corner relation is transitive, if C is a direct left corner of B, every left corner of C is also a left corner of B.</p>\n  \n  <p>In addition, since we defined the left-corner relation to be reflexive, B is a left corner of itself.</p>\n  \n  <p>Hence, if C is a direct left corner of B, it must follow B in decreasing order of number of distinct left corners, unless B is a left corner of C.</p>\n</blockquote>\n\n<p>All I want is to know how to order the nonterminals in the beginning, but I don\'t get it from the paper. Can someone explain it in a simpler way? Pseudocode would help me to understand it better.</p>\n', 'Tags': '<algorithms><context-free><formal-grammars><efficiency><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:28.390', 'CommentCount': '0', 'AcceptedAnswerId': '2793', 'CreationDate': '2012-05-23T12:50:45.647', 'Id': '2792'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the article <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm" rel="nofollow">Parsing Expressions by Recursive Descent by Theodore Norvell (1999)</a> the author starts with the following grammar for arithmetic expressions:</p>\n\n<pre><code>E --&gt; E "+" E | E "-" E | "-" E | E "*" E | E "/" E | E "^" E | "(" E ")" | v\n</code></pre>\n\n<p>which is quite bad, because it\'s ambiguous and left-recursive. So he starts from removing the left recursion from it, and his result is as such:</p>\n\n<pre><code>E --&gt; P {B P}\nP --&gt; v | "(" E ")" | U P\nB --&gt; "+" | "-" | "*" | "/" | "^"\nU --&gt; "-"\n</code></pre>\n\n<p>But I can\'t figure out how did he get to this result. When I try to remove the left recursion myself, I\'m doing it the following way:</p>\n\n<ol>\n<li><p>Firs, I group together the productions which doesn\'t have left recursion in one group, and other (left-recursive) in another group:</p>\n\n<pre><code>E --> E "+" E | E "-" E | E "*" E | E "/" E | E "^" E     // L-recursive\nE --> v | "(" E ")" | "-" E</code></pre></li>\n<li><p>Next, I name them and factor for easier manipulations:</p>\n\n<pre><code>E --> E B E  // L-recursive; B stands for "Binary operator"\nE --> P  // not L-recursive; P stands for "Primary Expression"\nP --> v | "(" E ")" | U E   // U stands for "Unary operator"\nB --> "+" | "-" | "*" | "/" | "^"\nP --> "-"</code></pre>\n\n<p>Now I need to deal only with the first two productions, which are now easier to deal with.</p></li>\n<li><p>I rewrite those first two productions by starting from the non-L-recursive production (which is simply <code>P</code>, the Primary expression) and following it by the optional Tail <code>T</code>, which I define as the rest of the original production less the first left-recursive nonterminal (that is, just <code>B E</code>) followed by the Tail <code>T</code>, <strong>or</strong> which could be empty:</p>\n\n<pre><code>E --> P T\nT --> B E T |</code></pre>\n\n<p>(note the empty alternative for the tail).</p></li>\n<li><p>These two productions I can now rewrite in EBNF like this:</p>\n\n<pre><code>E --> P {B E}</code></pre>\n\n<p>which is nearly what the author get, but I have <code>E</code> instead of <code>P</code> there inside the zero-or-more repetition pattern (the Tail). The other productions I get quite the same as he have got:</p>\n\n<p><pre><code>P --> v | "(" E ")" | U E\nB -> "+" | "-" | "*" | "/" | "^"\nU -> "-"</pre></code></p>\n\n<p>but here too I have <code>E</code> instead of <code>P</code> in the first production for <code>P</code>.</p></li>\n</ol>\n\n<p>So, my question is: What am I missing? What algebraic transformation on the syntax I need to proceed now to get the same exact form as the autor gets? I tried substitutions for <code>E</code>, but it only leads me into loops. I suspect that I need somehow to substitute <code>P</code> for <code>E</code>, but I don\'t know any legal transformation to justify it. Maybe you know what\'s the last missing step?</p>\n', 'ViewCount': '343', 'Title': 'Arithmetic expressions grammar transformation', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:22:47.697', 'LastEditDate': '2014-01-23T17:22:47.697', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'SasQ', 'PostTypeId': '1', 'OwnerUserId': '2381', 'Tags': '<formal-languages><context-free><formal-grammars><left-recursion>', 'CreationDate': '2012-08-05T20:59:01.593', 'Id': '3053'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have been taking a compiler course of Stanford on coursera. I have a slight misunderstanding on the parsing table of the following grammar:</p>\n\n<p>S -> Sa | b</p>\n\n<p>According to the professor parsing table looks like this:</p>\n\n<ul>\n<li><p>If the leftmost nonterminal is S and the input is 'a', the production is nothing.</p></li>\n<li><p>If the leftmost nonterminal is S and the input is 'b', the production is both <code>Sa</code> and <code>b</code>.</p></li>\n</ul>\n\n<p>So if input is just <code>b</code>, then it is correct, it will go directly to production <code>b</code>.\nBut how will it go to production <code>Sa</code> for input <code>b</code>?</p>\n", 'ViewCount': '321', 'Title': 'LL(1) parsing table of left-recursive grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:11.390', 'LastEditDate': '2014-01-23T17:17:11.390', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Batman', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing><left-recursion>', 'CreationDate': '2012-08-14T07:11:18.640', 'Id': '3173'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm now doing exam revision, and from some past year exam papers, I noticed some questions that ask to write a recursive method with signature like</p>\n\n<pre><code>public void run(int n)\n</code></pre>\n\n<p>that must have a time complexity of like : $O(n^2), O(n^3), O(n^7), O(n^2!), O(2^n), O(9^n)$.</p>\n\n<p>Can anyone give some idea on how to solve this kind of recursion questions.</p>\n", 'ViewCount': '600', 'Title': 'How to write a recursive function that with certain time complexity', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-27T10:01:42.290', 'LastEditDate': '2012-08-23T09:12:36.930', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1895', 'Tags': '<algorithms><time-complexity><recursion>', 'CreationDate': '2012-08-23T06:21:25.700', 'Id': '3297'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I have a homework assignment where I need to convert a grammar into LL(1). I've already removed the left recursion, but I'm having trouble doing left-factoring. All of the examples I've found are simple, and look something like this:</p>\n\n<p><code>A -&gt; aX | aY</code><br>\nbecomes:<br>\n<code>A -&gt; aZ</code><br>\n<code>Z -&gt; X | Y</code></p>\n\n<p>I understand that. However, my grammar looks more like this:</p>\n\n<pre><code>X -&gt; aE | IXE | (X)E\nE -&gt; IE | BXE | \u03f5\nI -&gt; ++ | --\nB -&gt; + | - | \u03f5\n</code></pre>\n\n<p>I'm not sure how to apply the simpler example to this. I've been trying for at least a couple of hours and I've lost track of all of the things I've tried. Generally, my attempts have looked something like this:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nE  -&gt; IE | BIX'E | BX'E | \u03f5\n</code></pre>\n\n<p>And I then try to convert the E rules into ones having only one production starting with + or -:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; IE | B'IX'E | IX'E | B'X'E | X'E | \u03f5\n</code></pre>\n\n<p>And then...</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; +P | -M | \u03f5\nP  -&gt; +E | IX'E | +X'E | X'E\nM  -&gt; -E | IX'E | -X'E | X'E\n</code></pre>\n\n<p>And so on. But I continually end up with a lot of extra nonterminals, and some very long productions / chains of productions, without actually having left-factored it. I'm not sure how to approach this - I can't seem to eliminate <i>some</i> nonterminal having multiple productions starting with a + and with a -.</p>\n", 'ViewCount': '2109', 'Title': 'Left-Factoring a grammar into LL(1)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:21:31.690', 'LastEditDate': '2014-01-23T17:21:31.690', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '4873', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3049', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-10-03T19:44:14.687', 'Id': '4862'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$$\\begin{align*}\n  T[1] &amp;= 1 \\\\\n  T[2] &amp;= 2 \\\\\n  T[i] &amp;= T[i-1] + T[i-3] + T[i-4] &amp; \\text{for \\(i \\gt 2\\)} \\\\\n\\end{align*}$$</p>\n\n<p>I have to calculate $T[N]$, but $N$ is too big ($\\approx 10^9$), how can I optimize it?</p>\n', 'ViewCount': '142', 'Title': 'Optimize a linear recurrence', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-11T09:35:56.713', 'LastEditDate': '2013-03-11T09:35:56.713', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3154', 'Tags': '<algorithms><dynamic-programming><recursion>', 'CreationDate': '2012-10-11T10:19:54.720', 'Id': '5018'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '190', 'Title': 'How to show that f(x) is primitive recursive?', 'LastEditDate': '2012-10-17T13:30:56.957', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': "<blockquote>\n  <p>Let </p>\n  \n  <p>$$f(x)=\\begin{cases} x \\quad \\text{if Goldbach's conjecture is true\n }\\\\ 0 \\quad \\text{otherwise}\\end{cases}$$</p>\n  \n  <p>Show that f(x) is primitive recursive.</p>\n</blockquote>\n\n<p>I know a primitive recursive function is obtained by composition or recursion, but I don't know what should I do about this problem. </p>\n", 'Tags': '<computability><recursion>', 'LastEditorUserId': '51', 'LastActivityDate': '2012-10-17T13:37:37.383', 'CommentCount': '1', 'AcceptedAnswerId': '6123', 'CreationDate': '2012-10-17T13:15:23.120', 'Id': '6122'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1566', 'Title': 'What is tail recursion?', 'LastEditDate': '2013-05-24T03:17:30.907', 'AnswerCount': '4', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2223', 'FavoriteCount': '3', 'Body': '<p>I know the general concept of recursion.  I came across the concept of <strong>tail recursion</strong> while studying the quicksort algorithm.  In this <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-4-quicksort-randomized-algorithms/" rel="nofollow">video of quick sort algorithm from MIT</a> at 18:30 seconds the professor says that this is a tail recursive algorithm.  It is not clear to me what tail recursion really means.</p>\n\n<p>Can someone explain the concept with a proper example?</p>\n\n<p><em>Some answers provided by the SO community <a href="http://stackoverflow.com/questions/11864006/why-is-quick-sort-called-a-tail-recursive-algorithm">here</a>.</em></p>\n', 'Tags': '<algorithms><reference-request><recursion>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:17:30.907', 'CommentCount': '6', 'AcceptedAnswerId': '7814', 'CreationDate': '2012-10-22T08:58:53.803', 'Id': '6230'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '335', 'Title': 'Do "inductively" and "recursively" have very similar meanings?', 'LastEditDate': '2012-10-23T12:39:08.900', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '336', 'FavoriteCount': '1', 'Body': '<p>Do "inductively" and "recursively" mean very similar?</p>\n\n<p>For example, if there is an algorithm that determines a n-dim vector by determine its first k+1 components based on its first k components having been determined, and is initialized with the first component, would you call it works recursively or inductively? I have been using "recursively", but today someone said it "inductively".</p>\n', 'Tags': '<algorithms><terminology><recursion><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T15:56:33.453', 'CommentCount': '7', 'AcceptedAnswerId': '6551', 'CreationDate': '2012-10-23T02:13:50.443', 'Id': '6247'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there any algorithm that tells us how to modify semantic actions associated with a left-recursive grammar? For example, we have the following grammar, and its associated semantic actions:</p>\n\n<p>$ S \\rightarrow id = expr $  { S.s = expr.size }</p>\n\n<p>S $\\rightarrow$ if expr then $S_1$ else $S_2$ { $S_1.t = S.t + 2; $\n$S_2.t = S.t + 2;$ $S.s = expr.size + S_1.size + S_2.size + 2;$ }</p>\n\n<p>S $\\rightarrow$ while expr do $S_1$ { $S_1.t = S.t + 4;$ $S.s = expr.size + S_1.s + 1;$ }</p>\n\n<p>S $\\rightarrow$ $S_1$ ; $S_2$  {$S_1.t = S_2.t = S.t;$ $S.s = S_1.s + S_2.s; $ }</p>\n\n<p>Clearly the non-recursive version of the grammer is:</p>\n\n<p>S $\\rightarrow$ id = expr T </p>\n\n<p>S $\\rightarrow$ if expr then $S_1$ else $S_2$ T</p>\n\n<p>S $\\rightarrow$ while expr do $S_1$ T</p>\n\n<p>T $\\rightarrow$ ; $S_2$ T</p>\n\n<p>T $\\rightarrow$ $\\epsilon$</p>\n\n<p>But we also need to change the semantic actions accordingly. Any ideas how this can be done?</p>\n', 'ViewCount': '78', 'Title': 'How to modify semantic actions when removing left-recursion from a grammer', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:48.393', 'LastEditDate': '2014-01-23T17:17:48.393', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7739', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2596', 'Tags': '<formal-grammars><compilers><semantics><left-recursion>', 'CreationDate': '2012-11-10T16:11:44.337', 'Id': '6604'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have asked this exact question on <a href="http://stackoverflow.com/questions/13229722/need-a-practical-solution-for-creating-pattern-database5-5-5-for-15-puzzle">StackOverflow</a>. I did not get the answer that I was looking for. Please read this question fully before answering. Thank You.<br><br>\nFor static pattern database(5-5-5), see <a href="http://reference.kfupm.edu.sa/content/d/i/disjoint_pattern_database_heuristics_56916.pdf" rel="nofollow">this</a>(page 290 and 283) OR there is an explanation below. For <a href="http://en.wikipedia.org/wiki/Fifteen_puzzle" rel="nofollow">What is 15-puzzle?</a><br>\nI am creating a static patter database(5-5-5). This code to to fill entries into the first table. I am doing it via the recursive function <code>insertInDB()</code>. The first input to the recursive function is this (actually the input puzzle contains it in 1-D array. For better understanding I have represented it as 2-D below)<br></p>\n\n<hr>\n\n<p>1 &nbsp;2 &nbsp;3 &nbsp;4<br>\n0 &nbsp;6 &nbsp;0 &nbsp;0<br>\n0 &nbsp;0 &nbsp;0 &nbsp;0<br>\n0 &nbsp;0 &nbsp;0 &nbsp;0<br></p>\n\n<hr>\n\n<p>This is my code : <br></p>\n\n<pre><code>class DBClass\n{\n    public Connection connection;\n     public ResultSet rs;\n      public PreparedStatement ps1;\n    public PreparedStatement ps2;\n    public int k;\n      String read_statement,insert_statement;\n\n    public DBClass()\n    {\n        try {\n            Class.forName("com.mysql.jdbc.Driver");\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n            try {\n                connection = DriverManager\n                    .getConnection("jdbc:mysql://localhost/feedback?"\n                        + "user=ashwin&amp;password=ashwin&amp;autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;validationQuery=Select 1");\n                insert_statement="insert into staticpdb1(hash,permutation,cost) values(?,?,?)";\n                read_statement="select SQL_NO_CACHE * from staticpdb1 where hash=? and permutation= ? LIMIT 1";\n                 ps1=connection.prepareStatement(read_statement, ResultSet.TYPE_SCROLL_SENSITIVE, \n                            ResultSet.CONCUR_UPDATABLE);\n                ps2=connection.prepareStatement(insert_statement);\n                k=0;\n            } catch (SQLException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n    }\n    public int updateIfNecessary(FifteenPuzzle sub) \n       {\n           String str=sub.toDBString();\n           try\n           {\n\n               ps1.setInt(1, sub.hashcode());\n               ps1.setString(2,str);\n               rs=ps1.executeQuery();\n           if(rs.next())\n              {\n                  //if a row exists, check if the cost is greater than sub\'s\n                  int cost=rs.getInt(3);\n                  if(sub.g_n&lt;cost)  //if the cost of sub is less than db row\'s cost\n                  {\n                      //replace the cost\n                      rs.updateInt(3, sub.g_n);\n                      rs.updateRow();\n                      return 1;   //only examine - do not insert\n                  }\n                  else\n                      return 0;   //dont examine - return\n\n              }\n           else\n               return 2;      //insert and examine\n           }\n           catch(SQLException e)\n           {\n\n               System.out.println("here1"+e);\n               System.err.println("reported recursion level was "+e.getStackTrace().length);\n               return 0;\n           }\n           finally{\n\n               try{\n                   rs.close();}\n               catch(final Exception e1)\n               {\n                   System.out.println("here2"+e1);\n               }\n\n           }\n\n\n       }\n    public void insert(FifteenPuzzle sub)\n    {\n\n        try{\n        String str=sub.toDBString();\n\n\n         ps2.setInt(1,sub.hashcode());\n         ps2.setString(2, str);\n         ps2.setInt(3,sub.g_n);\n         ps2.executeUpdate();\n         ps2.clearParameters();\n        }catch(SQLException e)\n        {\n            System.out.println("here3"+e);\n        }\n    }\n\n    public void InsertInDB(FifteenPuzzle sub) throws SQLException\n       {\n\n           System.out.println(k++);\n\n           int i;\n\n           int p=updateIfNecessary(sub);\n          if(p==0)\n          {\n              System.out.println("returning");\n           return;\n          }\n          if(p==2)\n          {\n          insert(sub);\n          System.out.println("inserted");\n          }\n\n\n           //FifteenPuzzle temp=new FifteenPuzzle(sub.puzzle.clone(),2,sub.g_n);\n           for(i=0;i&lt;sub.puzzle.length;i++)\n           {\n               if(sub.puzzle[i]!=0)\n               {\n\n                   //check the positions it can be moved to\n                   if(i%4!=0 &amp;&amp; sub.puzzle[i-1]==0)  //left\n                   {\n                       //create another clone and increment the moves\n                       FifteenPuzzle temp_inner=new FifteenPuzzle(sub.puzzle.clone(),2,sub.g_n+1);\n                       //exchange positions\n                        int t=temp_inner.puzzle[i];\n                        temp_inner.puzzle[i]=temp_inner.puzzle[i-1];\n                        temp_inner.puzzle[i-1]=t;\n                        InsertInDB(temp_inner);\n                   }\n                   if(i%4!=3 &amp;&amp; sub.puzzle[i+1]==0)  //right\n                   {\n                       //create another clone and increment the moves\n                       FifteenPuzzle temp_inner=new FifteenPuzzle(sub.puzzle.clone(),2,sub.g_n+1);\n                       //exchange positions\n                        int t=temp_inner.puzzle[i];\n                        temp_inner.puzzle[i]=temp_inner.puzzle[i+1];\n                        temp_inner.puzzle[i+1]=t;\n                        InsertInDB(temp_inner);\n                   }\n                   if(i/4!=0 &amp;&amp; sub.puzzle[i-4]==0)  //up\n                   {\n                       //create another clone and increment the moves\n                       FifteenPuzzle temp_inner=new FifteenPuzzle(sub.puzzle.clone(),2,sub.g_n+1);\n                       //exchange positions\n                        int t=temp_inner.puzzle[i];\n                        temp_inner.puzzle[i]=temp_inner.puzzle[i-4];\n                        temp_inner.puzzle[i-4]=t;\n                        InsertInDB(temp_inner);\n                   }\n                   if(i/4!=3 &amp;&amp; sub.puzzle[i+4]==0)  //down\n                   {\n                       //create another clone and increment the moves\n                       FifteenPuzzle temp_inner=new FifteenPuzzle(sub.puzzle.clone(),2,sub.g_n+1);\n                       //exchange positions\n                        int t=temp_inner.puzzle[i];\n                        temp_inner.puzzle[i]=temp_inner.puzzle[i+4];\n                        temp_inner.puzzle[i+4]=t;\n                        InsertInDB(temp_inner);\n\n                  }\n             }   \n       }\n</code></pre>\n\n<p><br><br>\nThe function <strong>insertInDB(FifteenPuzzle fp)</strong> in the class is the recursive function and is called first from the main function with the array for the fifteen puzzle argument(<code>puzzle</code> is an integer array field of the Class <code>FifteenPuzzle</code>) being - <code>1,2,3,4,0,6,0,0,0,0,0,0,0,0,0,0</code>(same as the matrix shown above). Before explaining the other functions I will explain what static pattern database is; briefly(Because of the comments below)<br></p>\n\n<h2>What is a (5-5-5) static pattern database for 15-Puzzle?</h2>\n\n<p>Pattern databases are heuristics used to solve a fifteen puzzle(can be any puzzle. But here I will talk about only 15-Puzzle). A heuristic is a number used to determine which state to be expanded next. I is like cost of each state. Here state is a <em>permutation</em> of the 15-Puzzle. For simple puzzles like 8-Puzzle, the heuristic can be <strong>manhattan distance</strong>. It gives the minimum number of moves, for each misplaced tile, to reach <strong>it\'s</strong> goal position. Then manhattan distances for all the tiles are added up to give the cost for that tile. Manhattan distance gives the lower bound to the estimate of the number of moves required to reach the goal state i.e you cannot reach the goal state with moves, less than the manhattan distance. <strong>BUT</strong> manhattan distance is not a very good heuristic, though admissible,  because it does not consider other tiles near by it. If a tile has to be moved to it\'s goal position, the near by tiles also have to be moved and the number of moves increase. So, clearly for these puzzles, the actual cost is mostly much greater that\nthe manhattan distance.<br>\nTo <strong>overcome</strong> this(manhattan distance) and take into account the other tiles, pattern databases were introduced.\nA static patter database holds the heuristics for sub-problems or for a group of tiles to reach for their goal state. Since, you are calculating the number of moves to make these group of tiles reach their goal state, the other tiles in that group will be taken into account when a tiles is being moved. So, this is a better heuristic and mostly will always is greater than manhattan distance.<br>\n5-5-5 static pattern is just a form of static pattern database where the number of groups are 3, two of them containing 5 tiles each and the third one contains 6(6th isthe blank tile).</p>\n\n<h2>One of the groups is this matrix :<br></h2>\n\n<p>1 &nbsp;2 &nbsp;3 &nbsp;4<br>\n0 &nbsp;6 &nbsp;0 &nbsp;0<br>\n0 &nbsp;0 &nbsp;0 &nbsp;0<br>\n0 &nbsp;0 &nbsp;0 &nbsp;0<br></p>\n\n<hr>\n\n<p>I calculating the heuristics/number_of_moves for all permutations of this group to reach the above configuration and <strong>inserting them into my database</strong>. <br> The total number of combinations(also the no of rows in db) possible is \n<br></p>\n\n<pre><code>16!/(16-5)! = 524160\n</code></pre>\n\n<p><br>  Now, the other functions  - <code>updateIfNecessary(FifteenPuzzle)</code> - this function checks if the array of the passed FifteenPuzzle object is already present in the database. If already present in the database, it checks if the current object\'s cost is less than the cost in DB. If yes, it replaces it with the current cost else does nothing. The function -<code>insert(FifteenPuzzle)</code> inserts a new permutaion with the cost.<br><br>\n<strong>NOTE :</strong> <code>fifteenuzzle.g_n</code> is the cost for the puzzle. For the initial puzzle that represents the matrix above, the cost is <code>0</code> and for each move the cost is <code>incremented by1</code>.<br><br></p>\n\n<p>I have set the stack size to -<code>Xss128m</code>(1024, 512 and 256 were giving a fatal error) for stack size in run configurations. <br>\nCurrently the recursion number or the depth is <strong><code>7,500,000</code> and counting</strong>(value of <code>System.out.println(k++);</code>).\n<br> The total number of combinations possible is \n<br></p>\n\n<pre><code>16!/(16-5)! = 524160\n</code></pre>\n\n<p><br>\nBut the depth has already reached 7,500,000. This is because of generation of duplicate states. Currently the number of entries in the database is <strong>513423</strong>. You might think that there only 10,000 entries to fill up now. But now the rate at which entries are made has decreased drastically about <strong>1 entry every 30 min</strong>. This will never get over then. <br><br>\nI need a solution that is practical - <strong>with or without recursion</strong>. Is it possible?</p>\n', 'ViewCount': '314', 'Title': 'Need a practical solution for creating pattern database(5-5-5) for 15-Puzzle', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-24T13:56:58.500', 'LastEditDate': '2014-03-24T13:56:58.500', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '6675', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4341', 'Tags': '<algorithms><artificial-intelligence><recursion>', 'CreationDate': '2012-11-11T16:34:04.977', 'Id': '6616'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm just curious about the pseudocode (or real source code, doesn't matter) of the recursive version of this algorithm. In almost every book chapter/paper when describing this topic, they mention that the recursive version takes exponential time and then they give the code for the dynamic programming approach. I understand how the iterative version (dynamic programming ie. memoization) works. But i just wonder about the recursive version.\nFor the info, the key part in the iterative code is: <br/></p>\n\n<blockquote>\n  <p>$\\ell$ ... left <br/>\n  $r$ ... right <br/>\n  $a$ ... apex <br/>\n  $T$ ... triangulation </p>\n  \n  <p>$T_{\\ell,r}= \\min\\{T_{\\ell,a} + \\text{perimeter}_{\\ell,a,r} + T_{a,r}\\}$</p>\n</blockquote>\n\n<p>So how does the recursive function <code>findOT()</code> seem in <br/>\npseudocode or one of these languages (C#, Java, C/C++, PHP, Javascript, SML)?</p>\n", 'ViewCount': '240', 'Title': 'Minimum weight triangulation', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-18T16:49:03.613', 'LastEditDate': '2012-11-18T08:27:23.633', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '6743', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4610', 'Tags': '<algorithms><computational-geometry><recursion>', 'CreationDate': '2012-11-17T19:29:10.790', 'Id': '6720'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Why LL(k) and LL(\u221e) are incompatible with left-recursion? I understand that a LL(k) language can support left-recursivity provided that with k-overahead tokens can be resolved any ambiguity. But, with a LL(\u221e) grammar, which type of ambiguities can't be solved?</p>\n", 'ViewCount': '101', 'Title': 'LL grammars and left-recursiviity', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:19:48.497', 'LastEditDate': '2014-01-23T17:19:48.497', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6824', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4675', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-11-21T11:41:00.150', 'Id': '6809'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We covered this in class today. I understand the mechanics of it, but aside from being a nice example of recursion does it serve any purpose? </p>\n\n<p><img src="http://i.stack.imgur.com/DOcD0.png" alt="enter image description here"></p>\n\n<p>Searching the web reveals lots of pages with the formula and it\'s implementation in code, some talk about the author, but nothing about it\'s purpose.</p>\n', 'ViewCount': '171', 'Title': 'What is the TAK function for?', 'LastActivityDate': '2012-11-23T12:42:32.547', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6822', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1548', 'Tags': '<algorithms><recursion>', 'CreationDate': '2012-11-21T14:20:48.557', 'FavoriteCount': '1', 'Id': '6815'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider a set of functions:</p>\n\n<ul>\n<li><p><code>head(l)</code> returns first bit from list <code>l</code>, e.g.</p>\n\n<pre><code>head([0,1,0]) = 0, \nhead([1]) = 1\n</code></pre></li>\n<li><p><code>tail(l)</code> returns a list by removing first element from <code>l</code>, e.g. </p>\n\n<pre><code>tail([0,1,0]) = [1,0],\ntail([1]) = []\n</code></pre></li>\n<li><p><code>a:l</code> appends bit <code>a</code> to beginning of list <code>l</code>, e.g.</p>\n\n<pre><code>1:[0,1,0] = [1,0,1,0].\n</code></pre></li>\n<li><p><code>xor</code> takes takes as input two bits and returns a bit.</p>\n\n<pre><code>xor(a,b)\nif (a == b) \n  return(0)\nelse \n  return(1)\nendif\n</code></pre></li>\n<li><p><code>f1</code> takes as input a list and returns another list.</p>\n\n<pre><code>f1(s)\nif (s == []) then \n  return([1])\nelse if (head(s) == 0) then  \n  return(1:tail(s))\nelse if (head(s) == 1) then \n  return(0:f1(tail(s)))\nendif\n</code></pre>\n\n<ul>\n<li><p><code>f2</code> takes as input a bit and a list and returns a bit.</p>\n\n<p>f2(b,s)\nif (s == []) then \n  return(b)\nelse if (head(s) == 0) then \n  return(f2(xor(b,1),tail(s)))\nelse if (head(s) == 1) then \n  return(xor(b,1))\nendif</p></li>\n</ul></li>\n<li><p><code>g1</code> takes as input a nonnegative number and returns a list.</p>\n\n<pre><code>g1(n)\nif (n == 0) then \n  return([0])\nelse \n  return f1(g1(n-1))\nendif\n</code></pre></li>\n<li><p><code>g2</code> takes as input a nonnegative number and returns a bit.</p>\n\n<pre><code>g2(n)\nif (n == 0) then \n  return(0)\nelse \n  return f2(g2(n-1),g1(n))\nendif\n</code></pre></li>\n</ul>\n\n<p>Can anyone explain what the function <code>g2()</code> returns?</p>\n\n<p>I am able to find out g1() returns a list in binary\nfor example </p>\n\n<pre><code>g1(1) = [1]\ng1(2) = [01]\ng1(3) = [11]\ng1(4) = [001]\n</code></pre>\n', 'ViewCount': '212', 'Title': 'Recursion problem involving head, tail and xor', 'LastEditorUserId': '139', 'LastActivityDate': '2012-12-31T07:07:40.340', 'LastEditDate': '2012-12-31T07:07:40.340', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4752', 'Tags': '<recursion><functional-programming>', 'CreationDate': '2012-11-27T10:45:00.843', 'Id': '6951'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Josephus_problem" rel="nofollow">Josephus Problem</a> asks where to start taking out every kth person in the circle consisted of n people, such that you are the last "survivor".</p>\n\n<p>The following recursive formula is given:\n$$\\begin{align}\nf(1,k)&amp;=1, \\\\\nf(n,k)&amp;=((f(n-1,k)+k-1) \\bmod n )+1.\n\\end{align}$$</p>\n\n<p>But this is not enough explanation, so I don\'t get where does it come from.</p>\n\n<p>Can anyone help? </p>\n', 'ViewCount': '264', 'Title': 'A Recursive Formula For Generalized Josephus problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-01T13:59:08.837', 'LastEditDate': '2012-12-01T13:59:08.837', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3046', 'Tags': '<combinatorics><recursion>', 'CreationDate': '2012-11-30T13:48:14.960', 'Id': '7048'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Using python need to code a recursive function with one input and no global integers that calculates the number of options to get $x$ using $a*1+b*2+c*3$.</p>\n\n<p>Say $x=3$, there are four options: $\\lbrace (1,1,1),(1,2),(2,1),(3)\\rbrace$.</p>\n', 'ViewCount': '147', 'Title': 'Recursive function calculating number of ways to sum $a + 2 b + 3 c = x$', 'LastEditorUserId': '1329', 'LastActivityDate': '2012-12-18T23:52:18.237', 'LastEditDate': '2012-12-18T18:41:05.697', 'AnswerCount': '3', 'CommentCount': '6', 'AcceptedAnswerId': '7493', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5115', 'Tags': '<combinatorics><recursion>', 'CreationDate': '2012-12-18T16:24:18.243', 'Id': '7490'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am studying primitive recursive functions and there's something that I don't quite understand: let's take the function that computes $x+y$, then, in order to show that $f(x,y)=x+y$ is primitive recursive, my lecture notes give the following equations:</p>\n\n<p>\\begin{cases}\n   f(x,0)=x \\\\\n   f(x,y+1) = f(x,y)+1\n  \\end{cases}\nthis first bunch makes perfect sense to me, on the other hand, looking at the equations down below, I don't get why a new function $g$ is used and also why does it have three parameters, when the sum clearly has only two? Is that $y$ the variable that supposedly holds (partial) results from computation?</p>\n\n<p>\\begin{cases}\n   f(x,0)=u^1_1(x) \\\\\n   f(x,y+1) = g(y, f(x,y),x)\n  \\end{cases}</p>\n\n<p>where $g(x_1, x_2, x_3) = s(u^3_2(x_1, x_2, x_3))$.</p>\n", 'ViewCount': '64', 'Title': 'Clarifications on primitive recursive function definition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-16T12:05:02.913', 'LastEditDate': '2013-01-16T10:06:59.627', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '8966', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><terminology><recursion>', 'CreationDate': '2013-01-16T09:41:09.907', 'Id': '8963'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As this thread title gives away I need to prove $x^y$ to be a primitive recursive function. </p>\n\n<p>So mathematically speaking, I think the following are the recursion equations, well aware that I am assigning to $0^0$ the value $1$, which shouldn\'t be, since it is an "indeterminate" form.</p>\n\n<p>\\begin{cases}\n  x^0=1 \\\\\n  x^{n+1} = x^n\\cdot x\n\\end{cases}</p>\n\n<p>More formally I would write:\n\\begin{cases}\n  h(0) = 1 \\\\\n  h(x,y+1) = g(y,h(x,x),x)\n\\end{cases}</p>\n\n<p>as $g(x_1, x_2, x_3) = h\\left(u^3_2(x_1, x_2, x_3),u^3_3(x_1, x_2, x_3)\\right)$ and provided $h(x,y) = x \\cdot y$ is primitive recursive.</p>\n\n<p>Is my proof acceptable? Am I correct, am I missing something or am I doing anything wrong?</p>\n', 'ViewCount': '524', 'Title': 'Show $x^y$ is a primitive recursive function', 'LastActivityDate': '2013-02-02T21:20:18.577', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><recursion><check-my-proof>', 'CreationDate': '2013-01-16T12:35:30.310', 'Id': '8967'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm not sure if this statement is correct, but my friend said so.</p>\n\n<p>The problem arose from this T/F question:\nLet $F=\\{f: f$ be a primitive recursive function from $\\mathbb{N}$ to $\\mathbb{N}\\}$, then $2^F$ (Power set of $F$) is uncountable.</p>\n\n<p>And its answer is True. The set of primitive recursive functions is countable, and I would like to know the proof to the statement above...I believe I've seen it somewhere in the book but can't find it now.</p>\n\n<p>Thank you for your time.</p>\n", 'ViewCount': '95', 'Title': 'How to prove "The power set of a countable set must be uncountable"?', 'LastActivityDate': '2013-01-17T12:28:11.867', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '8987', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<turing-machines><recursion><uncountability>', 'CreationDate': '2013-01-17T12:17:47.200', 'Id': '8986'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $\\varphi(x)=2x$ if $x$ is a perfect square, $\\varphi(x) = 2x+1$ otherwise. Show $\\varphi$ is primitive recursive.</p>\n\n<p>In proving $\\varphi$ to be a p.r. function I think it could come in handy the following theorem:</p>\n\n<p>Let $\\mathcal C$ be a PRC class. Let the functions $g$, $h$ and the predicate $P$ belong to $\\mathcal C$, let</p>\n\n<p>\\begin{equation}\n f(x_1,\\ldots, x_n) =\n \\begin{cases}\n  g(x_1, \\ldots, x_n) \\;\\;\\;\\;\\;\\text{ if } P(x_1, \\ldots, x_n)\\\\\n  h(x_1,\\ldots,x_n) \\;\\;\\;\\;\\;\\text{ otherwise}\n \\end{cases}\n\\end{equation}\nThen $f$ belongs to $\\mathcal C$ because $$f(x_1, \\ldots, x_n) = g(x_1, \\ldots, x_n) \\cdot  P(x_1, \\ldots, x_n) + g(x_1, \\ldots, x_n) \\cdot \\alpha(P(x_1, \\ldots, x_n))$$ where </p>\n\n<p>\\begin{equation}\n \\alpha(x) =\n \\begin{cases}\n  1 \\;\\;\\;\\;\\;\\text{ if } x = 0\\\\\n  0 \\;\\;\\;\\;\\;\\text{ if } x \\neq 0\n \\end{cases}\n\\end{equation}</p>\n\n<p>and $\\alpha(x)$ is p.r.</p>\n\n<p>So similarly I would say that $\\varphi(x)$ is p.r. as</p>\n\n<p>\\begin{equation}\n \\varphi(x) =\n \\begin{cases}\n  2x \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{ if } x = t \\cdot t \\\\\n  2x+1 \\;\\;\\;\\;\\;\\text{ otherwise}\n \\end{cases}\n\\end{equation}\nhence $$\\varphi(x) = 2x \\cdot  P(x_1, \\ldots, x_n) + (2x+1) \\cdot \\alpha(P(x_1, \\ldots, x_n))$$ and $P$ is a primitive recursive predicate as $x \\cdot y$ is p.r. and also $x = y$.</p>\n\n<p>Does everything hold? Is there anything wrong? If so, since I am tackling this kind of exercise for the fist time, will you please tell me what's the proper way to solve this?</p>\n", 'ViewCount': '103', 'Title': 'Prove $\\varphi(x)$ to be primitive recursive', 'LastActivityDate': '2013-02-17T04:22:42.263', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><recursion><check-my-proof>', 'CreationDate': '2013-01-17T18:30:40.390', 'Id': '8999'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There is a formula in wikipedia for the general case of josepus problem</p>\n\n<p><a href="http://en.wikipedia.org/wiki/Josephus_problem" rel="nofollow">Josephus Problem</a></p>\n\n<p>But there is no reference for it, I don\'t know where it came from and I need too find out...\nMaybe Donald Knuth\'s Art of Programming?</p>\n', 'ViewCount': '65', 'Title': 'A Formula For Generalized Josephus problem', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T08:41:27.180', 'LastEditDate': '2013-01-25T08:31:48.273', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6524', 'Tags': '<reference-request><recursion>', 'CreationDate': '2013-01-23T18:46:18.270', 'Id': '9118'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I just recently started learning in a CS context (as opposed to a programming context) about simple recursive functions, along with the combinatorial applications, and techniques such as Backtracking and Divide et Impera.</p>\n\n<p>The example problem that I chose for my questions is the n queens problem (given n queens and a n*n chessboard, how do you position the queens such that they can't attack each other?).\nI understood that the basic idea is to generate all possible placements (by generating a cartesian product) and then simply discarding them as they come along if they are invalid (through the validation function).</p>\n\n<p>Here is my sample implementation:</p>\n\n<pre><code>    int valid (int k)\n    {\n    for (int i = 1; i &lt; k; i++)\n    {\n        if (sol[i] == sol[k]) return 0;\n        if (abs(sol[i] - sol[k]) == abs(i - k)) return 0;\n    }\n    return 1;\n}\n\nvoid print ()\n{\n    for (int i = 1; i &lt;= n; i++)\n    {\n        cout &lt;&lt; sol[i];\n    }\n    cout &lt;&lt; endl;\n    how++;\n}\n\nvoid backtrack (int k)\n{\n    if (k == n+1) print();\n    else\n    {\n        sol[k] = 0;\n        while (sol[k] &lt; n)\n        {\n            sol[k]++;\n            if (valid(k)) backtrack(k+1);\n        }\n    }\n}\n</code></pre>\n\n<ol>\n<li>Why is it that in the validation function, the checking of the solution is done progressively by checking 1 with k, 2 with k and so on. I think that the solution can be correct in pairs of (i, k) but wrong overall (for example 1 and 2 relative to 3 are placed correctly, but 1 relative to 2 is placed incorrectly)?</li>\n</ol>\n", 'ViewCount': '232', 'Title': 'Why does backtracking work the way it does?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T11:55:37.743', 'LastEditDate': '2013-02-08T08:27:23.527', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9599', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2530', 'Tags': '<algorithms><recursion><backtracking>', 'CreationDate': '2013-02-08T06:03:24.863', 'Id': '9590'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In compiler design, why should left recursion be eliminated in grammars? I am reading that it is because it can cause an infinite recursion, but is it not true for a right recursive grammar as well?</p>\n', 'ViewCount': '1414', 'Title': 'Why is left recursion bad?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T02:23:37.270', 'LastEditDate': '2014-01-23T17:17:55.627', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'OwnerDisplayName': 'user56833', 'PostTypeId': '1', 'Tags': '<formal-grammars><compilers><left-recursion>', 'CreationDate': '2013-02-20T10:06:01.963', 'Id': '9963'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've just finished studying recursion at university. One thing that stood out for me however was that in both the lectures and in the practical we completed, all the tasks we were asked to do could be performed faster, and in less code, using iterative means.<br>\nThis was something the lecturer confirmed.</p>\n\n<p>Could somebody please give me some examples of situations when recursion is a better solution than iterative techniques? Additionally, are there any situations in which recursion is the <em>only</em> way to sole a problem?</p>\n", 'ViewCount': '270', 'ClosedDate': '2013-02-23T07:30:39.423', 'Title': 'Tasks in which recursion is either the fastest or only way to produce a result', 'LastActivityDate': '2013-02-21T00:04:53.237', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9988', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6967', 'Tags': '<recursion>', 'CreationDate': '2013-02-20T20:32:01.857', 'Id': '9987'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a recurrence relation which is like the following:<p></p>\n\n<p>$T(n) = 2T(\\frac{n}{2}) + \\log_{2}n$</p>\n\n<p>I am using recursion tree method to solve this. And at the end, i came up with the following equation:<p></p>\n\n<p>$T(n)=(2\\log_{2}n)(n-1)-(1\\times 2 + 2\\times 2^{2} + \\ldots + k\\times2^{k})$ where $k=\\log_{2}n$</p>\n\n<p>I am trying to find a theta notation for this equation. But i cannot find a closed formula for the sum $(1\\times 2 + 2\\times 2^{2} + \\ldots + k\\times2^{k})$. How can I find a big theta notation for $T(n)$? </p>\n', 'ViewCount': '250', 'Title': 'Need help about solving a recurrence relation', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-07T20:27:23.937', 'LastEditDate': '2013-03-07T00:27:04.883', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7175', 'Tags': '<algorithms><algorithm-analysis><recurrence-relation><recursion>', 'CreationDate': '2013-03-07T00:10:55.800', 'FavoriteCount': '2', 'Id': '10346'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a recurrence relation and trying to use master theorem to solve it. The recurrence relation is:</p>\n\n<p>$T(n) = 3T(n/5) + n^{0.5}$</p>\n\n<p>Can I use the master theorem in that relation? If so, can I say that $T(n)$ is $\u0398(n^{0.5})$?</p>\n', 'ViewCount': '24', 'ClosedDate': '2013-03-07T11:23:42.837', 'Title': 'The use of master theorem appriopriately', 'LastEditorUserId': '8246', 'LastActivityDate': '2013-09-28T12:35:50.493', 'LastEditDate': '2013-09-28T12:35:50.493', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7175', 'Tags': '<algorithms><time-complexity><recurrence-relation><recursion><master-theorem>', 'CreationDate': '2013-03-07T09:48:45.607', 'Id': '10356'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Perhaps this is a question for stackoverflow because its practical nature, but I am not aware of any general method to relate recurrence relations and recursive functions.</p>\n\n<p>Having as an example this recurrence relation:</p>\n\n<p>$\\qquad \\begin{align}a_0 &amp;= a_1 = 1 \\\\ 2a_n &amp;= 3a_{n-1}-2a_{n-2}\\end{align}$</p>\n\n<p>I would like to transform it into a recursive <em>function</em> $f$, able to be called to itself a number of times (composite), i.e.  $f \\circ f \\circ f \\circ \\dots \\circ f$  ($n$ times), getting the same result as with the $a_n$ relation.</p>\n\n<p>Any ideas about it?</p>\n', 'ViewCount': '98', 'Title': 'Can a recurrence relation be translated to a composite function of itself?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-21T17:38:28.180', 'LastEditDate': '2013-03-23T16:05:37.757', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10707', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<recurrence-relation><recursion>', 'CreationDate': '2013-03-23T14:46:41.773', 'Id': '10706'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '210', 'Title': 'Proving correctness of the algorithm for convex polygon minimum cost triangulation', 'LastEditDate': '2013-04-07T12:38:35.643', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7336', 'FavoriteCount': '1', 'Body': '<p>I have read many solutions for the minimum cost of triangulation problem and intuitively get the idea , however I am struggling to figure out how to prove it formally. I kind of feel that it has to be proven by induction but I struggle at choosing the right quantity to look at and also at the inductive step portion of the proof.</p>\n\n<p>For example, can you provide a formal proof for the algorithm described <a href="http://users.eecs.northwestern.edu/~dda902/336/hw6-sol.pdf" rel="nofollow">here</a> (page 5 problem 6.12).</p>\n', 'Tags': '<algorithms><algorithm-analysis><dynamic-programming><recursion><correctness-proof>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:53:48.043', 'CommentCount': '2', 'AcceptedAnswerId': '11098', 'CreationDate': '2013-04-07T01:15:34.200', 'Id': '11085'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Recently, I came across <a href="http://www.spoj.com/problems/HANOI/">this problem</a>, a variation of <a href="https://en.wikipedia.org/wiki/Towers_of_hanoi">towers of hanoi</a>.</p>\n\n<p>Problem statement:</p>\n\n<blockquote>\n  <p>Consider the folowing variation of the well know problem Towers of\n  Hanoi:</p>\n  \n  <p>We are given $n$ towers and m disks of sizes $1,2,3,\\dots,m$ stacked on some\n  towers. Your objective is to transfer all the disks to the $k^{\\text{th}}$ tower\n  in as few moves as you can manage, but taking into account the\n  following rules:</p>\n  \n  <ul>\n  <li>moving only one disk at a time, </li>\n  <li>never moving a larger disk one onto a\n  smaller one, </li>\n  <li>moving only between towers at distance at most $d$. </li>\n  </ul>\n  \n  <p>(Limits in the original problem:\n  $3 \\le n \\le 1000$ and $m \\le 100$. Number of test cases $\\le 1000$.\n  You can assume that all the problems can be solved in not more than\n  $20000$ moves.)</p>\n</blockquote>\n\n<p>It\'s an interesting one. The classic towers of hanoi problem has one source, destination and temporary tower that is used to move the disks from source to destination. The problem pitched on that site basically has an initial and final configuration. </p>\n\n<p>How does one approach this problem? </p>\n', 'ViewCount': '496', 'Title': 'Towers of Hanoi but with arbitrary initial and final configuration', 'LastEditorUserId': '139', 'LastActivityDate': '2013-10-26T23:48:26.990', 'LastEditDate': '2013-04-26T15:39:15.363', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7905', 'Tags': '<algorithms><combinatorics><recursion>', 'CreationDate': '2013-04-26T06:26:18.847', 'FavoriteCount': '1', 'Id': '11562'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Master\'s theorem is shown below,</p>\n\n<p><img src="http://i.stack.imgur.com/OtLdE.png" alt="enter image description here"></p>\n\n<p>The recursive function to be solved is shown below,</p>\n\n<p><img src="http://i.stack.imgur.com/qu9VR.png" alt="enter image description here"></p>\n\n<p>I understand that <code>a</code> refers to the number of recursive calls in this function (<strong>3</strong> in this case). <code>b</code> refers to what the input size is being divided by in each recursive call. Which I believe should be <strong>4</strong>.\n<code>d</code> refers to the overhead of each recursive call, which should be 1.</p>\n\n<p>So we have:</p>\n\n<pre><code>a = 3\nb = 4...?\nd = 1\n</code></pre>\n\n<p>The problem is, b apparently doesn\'t equal 4.</p>\n\n<p>Now the actual answer shows that the answer is:</p>\n\n<p><img src="http://i.stack.imgur.com/VwDtw.png" alt="enter image description here"></p>\n\n<p>Which seems incorrect, since given the Master\'s Theorem, I don\'t see how <code>n</code> is being subtracted by a constant.</p>\n\n<p>Thank you for your help.</p>\n', 'ViewCount': '119', 'Title': "Particularly Tricky Recurrence Relation (Master's Theorem)", 'LastActivityDate': '2013-04-28T19:13:47.367', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11636', 'Score': '0', 'OwnerDisplayName': 'Kyra Westwood', 'PostTypeId': '1', 'OwnerUserId': '7958', 'Tags': '<recursion>', 'CreationDate': '2013-04-28T09:29:29.853', 'Id': '11635'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '77', 'Title': 'Resolving this recurrence equation', 'LastEditDate': '2013-04-29T12:38:07.347', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Federico Ponzi', 'PostTypeId': '1', 'OwnerUserId': '17193', 'Body': "<p>I have this recurrence equation:</p>\n\n<p>$T(n) = T(n/4) + T(3n/4) + \\mathcal{O}(n)$</p>\n\n<p>$T(1) = 1$</p>\n\n<p>I know that the result is $\\mathcal{O}(n \\log n)$ but i don't know how to proceed.</p>\n", 'ClosedDate': '2013-04-29T18:28:35.180', 'Tags': '<asymptotics><runtime-analysis><recurrence-relation><recursion>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-04-29T12:38:07.347', 'CommentCount': '6', 'AcceptedAnswerId': '11657', 'CreationDate': '2013-04-14T19:02:46.790', 'Id': '11656'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am not sure whether this is the right place to ask this question.</p>\n\n<p>I would like to write a register machine code which when given an input of n in register\n1, returns (also in register 1) the nth Fibonacci number. The Fibonacci numbers are\n0 (the 0th), 1 (the 1st), 1 = 0 + 1 (the 2nd), etc. </p>\n\n<p>I tried to write few lines of the codes, but unable to do the recursive property of Fibonacci sequence. Here is my code:</p>\n\n<p>Let A, B, C be registers.</p>\n\n<ol>\n<li>(-A; 2,-)</li>\n<li>(+C; 1)</li>\n<li>(-C; 4,-)</li>\n<li>(+B; 5)</li>\n<li>(+A; 3)</li>\n</ol>\n\n<p>I know that the fifth line is wrong but have no idea how to fix it. And I want to code to be as simple as possible (i.e. with fewest instructions). Thanks in advance.</p>\n', 'ViewCount': '224', 'Title': 'Register Machine code for Fibonacci Numbers', 'LastActivityDate': '2013-06-12T14:36:21.393', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8141', 'Tags': '<programming-languages><recurrence-relation><recursion>', 'CreationDate': '2013-05-13T05:48:28.760', 'Id': '11984'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The wikipedia article about <a href="http://en.wikipedia.org/wiki/Primitive_recursive_function" rel="nofollow">primitive recursion</a> states that </p>\n\n<blockquote>\n  <p>An equivalent definition states that a partial recursive function is one that can be computed by a Turing machine.</p>\n</blockquote>\n\n<p>My question is how one can write down formally this definition?</p>\n', 'ViewCount': '122', 'Title': 'Partial recursive function and Turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-16T06:02:08.843', 'LastEditDate': '2013-05-16T06:02:08.843', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Montaigne', 'PostTypeId': '1', 'Tags': '<terminology><turing-machines><recursion>', 'CreationDate': '2013-05-15T23:26:36.777', 'Id': '12055'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '51', 'Title': 'Time complexity of mutually recursive functions', 'LastEditDate': '2013-06-18T19:19:00.467', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4490', 'FavoriteCount': '1', 'Body': '<p>Suppose I have two mutually recursive functions like this:</p>\n\n<pre><code>f1(x)\n{\n   .//some code\n   .\n   .\n   f1(x-1)+g1(x-1); \n\n}\n\ng1(y)\n{\n   .\n   .//some code\n   g1(y-1)+f1(y-1);\n  ..\n\n\n}\n</code></pre>\n\n<p>How can I calculate time complexities in such cases?</p>\n', 'Tags': '<time-complexity><recursion>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-18T19:19:00.467', 'CommentCount': '0', 'AcceptedAnswerId': '12743', 'CreationDate': '2013-06-18T15:43:18.620', 'Id': '12742'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to show whether a program containing only <em>if-else</em> statements but no loops is able to calculate the following type of functions: $f^n(x)$. The function $f$ is applied $n$ times to $x$, so I guess this is a recursive function.</p>\n\n<p>How can I prove that formally?</p>\n', 'ViewCount': '231', 'Title': 'Can we create recursive functions only by using if-else statements?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-21T00:07:05.620', 'LastEditDate': '2013-06-20T23:54:27.990', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'Nicolas', 'PostTypeId': '1', 'OwnerUserId': '8933', 'Tags': '<recursion><semantics>', 'CreationDate': '2013-06-18T17:34:36.170', 'Id': '12772'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do you go about analysing coin change recursive solution. i.e,\n<code>T(N,K) = T(N,K-1) + T(N-1,K)</code> for K denominations that add up to amount N.</p>\n\n<p>You can find the problem description and pseudo code here - <a href="http://www.algorithmist.com/index.php/Coin_Change#Recursive_Formulation" rel="nofollow">http://www.algorithmist.com/index.php/Coin_Change#Recursive_Formulation</a></p>\n', 'ViewCount': '177', 'Title': 'Complexity of recursive solution to coin change', 'LastActivityDate': '2013-07-02T01:56:38.320', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'Raghu', 'PostTypeId': '1', 'OwnerUserId': '8298', 'Tags': '<time-complexity><recursion><asymptotics>', 'CreationDate': '2013-06-30T21:17:49.447', 'Id': '13017'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I recently learned how to implement merge-sort, using a standard recursive algorithm. Can the algorithm be implemented in a way that allows for a tail-recursive implementation? Can it be implemented in an iterative style?</p>\n\n<p>In general how can a recursive algorithm converted into an iterative and tail-recursive algorithm? What are the possible pros and cons of this conversion?</p>\n', 'ViewCount': '889', 'Title': 'Iterative and/or tail-recursive implementations of merge sort?', 'LastEditorUserId': '755', 'LastActivityDate': '2013-07-08T18:34:56.770', 'LastEditDate': '2013-07-08T01:12:53.063', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '13145', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9051', 'Tags': '<algorithms><sorting><recursion>', 'CreationDate': '2013-07-07T17:20:43.893', 'Id': '13139'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When should I call a definition recursive and when should I call it inductive?</p>\n\n<p>I have read Carl Mummert\'s <a href="http://math.stackexchange.com/a/228870/468">nice answer</a> on MSE. So if I understand correctly we refer to definitions of objects like natural numbers, lists, trees, etc. as inductive whereas we refer to definitions of operations over objects like $+$ or $head$ or $leftchild$ as recursive.</p>\n\n<p>Is this the correct way to distinguish these in programming languages theory?</p>\n\n<p>Are there examples where using either would make sense?</p>\n', 'ViewCount': '187', 'Title': 'Inductive vs. recursive definition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-17T13:01:02.477', 'LastEditDate': '2013-07-12T10:59:05.280', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<terminology><programming-languages><logic><recursion><inductive-datatypes>', 'CreationDate': '2013-07-11T09:02:21.290', 'FavoriteCount': '1', 'Id': '13225'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a question from the book <code>Data structures using C and C++ by Tenenbaum</code>. Not a homework problem but self-study.</p>\n\n<blockquote>\n  <p>Recursive definition of a+b, where a and b are non-negative integers, in terms of successor function <code>succ</code> defined as</p>\n  \n  <p>succ(int x)\n      {\n          return(x++);\n      }</p>\n</blockquote>\n\n<p>I have been thinking how is it possible? Can I change the function? I am not sure from the problem definition in the book. So how can this be done?</p>\n', 'ViewCount': '282', 'Title': 'Recursive definition of sum of two numbers in terms of the successor function', 'LastEditorUserId': '683', 'LastActivityDate': '2013-09-02T11:13:25.650', 'LastEditDate': '2013-08-07T15:23:59.207', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13660', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9051', 'Tags': '<algorithms><recursion><number-theory>', 'CreationDate': '2013-08-07T14:26:48.393', 'Id': '13659'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have encountered a surprisingly challenging problem arranging a matrix-like (List of Lists) of values subject to the following constraints (or deciding it is not possible):</p>\n\n<p>A matrix of m randomly generated rows with up to n distinct values (no repeats within the row) arrange the matrix such that the following holds (if possible):</p>\n\n<p>1) The matrix must be "lower triangular"; the rows must be ordered in ascending lengths so the only "gaps" are in the top right corner</p>\n\n<p>2) If a value appears in more than one row it must be in the same column (i.e. rearranging the order of values in a row is allowed).</p>\n\n<p>Example 1 - which has a solution</p>\n\n<p>A B<br>\nC E D<br>\nC A B</p>\n\n<p>becomes (as one solution)</p>\n\n<p>A B<br>\nE D C<br>\nA B C  </p>\n\n<p>since A, B and C all appear in columns 1, 2 and 3, respectively.</p>\n\n<p>Example 2 - which has no solution</p>\n\n<p>A B C<br>\nA B D<br>\nC B D  </p>\n\n<p>has no solution since the constraints require the third row to have the C and D in the third column which is not possible.</p>\n\n<p>In my attempts to solve this naively (e.g. by sorting shortest rows to longest and then trying to order the rows from "most in common" to least and then simple reordering within the row) there are always scenarios that it thinks aren\'t solvable but are.  In other words backtracking/exhaustive search appears to be required, which is OK but I haven\'t yet struck onto a nice concise (ideally functional) algorithm for this.</p>\n', 'ViewCount': '84', 'Title': 'Ordering a list of lists subject to constraints', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-29T00:53:53.787', 'LastEditDate': '2013-09-04T04:50:23.237', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9967', 'Tags': '<algorithms><np-complete><recursion>', 'CreationDate': '2013-09-03T21:03:11.640', 'Id': '14113'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '70', 'Title': 'Tight asymptotic bound for recursive algorithm', 'LastEditDate': '2013-09-11T11:39:35.377', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5066', 'FavoriteCount': '1', 'Body': "<p>I have this algorithm where:</p>\n\n<p>$$\nT(n) =\n\\begin{cases}\n  1 &amp; \\text{if}\\; n \\le 1 \\\\\n  T(n/2) + 1 &amp; \\text{otherwise} \\\\\n\\end{cases}\n$$</p>\n\n<p>So, evaluating for $T(0), T(1), T(2), T(3), \\ldots, T(n)$, I'm getting values like:\n$$ 1, 1, 2, 2, 3, 3, \\ldots, n, n $$</p>\n\n<p>I assume this is twice the sum of $1$ to $n$, that would be the same as $n (n+1)$ or $n^2+2$.</p>\n\n<p>Is my assumption ok?</p>\n", 'Tags': '<algorithm-analysis><asymptotics><recursion>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-11T13:19:20.067', 'CommentCount': '3', 'AcceptedAnswerId': '14269', 'CreationDate': '2013-09-11T05:05:47.037', 'Id': '14264'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We have started learning about analysis of recursive algorithms and I got the gist of it. However there are some questions, like the one I'm going to post, that confuse me a little.</p>\n\n<h3>The exercise</h3>\n\n<blockquote>\n  <p>Consider the problem of multiplying two big integers, i.e. integers represented by a large number of bits that cannot be handled directly by the ALU of a single CPU. This type of multiplication has applications in data security where big integers are used in encryption schemes. The elementary-school algorithm for multiplying two n-bit integers has a complexity of . To improve this complexity, let x and y be the two n-bit integers, and use the following algorithm</p>\n\n<pre><code>Recursive-Multiply(x,y)\n  Write  x = x1 * 2^(n/2)+x0  //x1 and x0 are high order and low order n/2 bits\n       y = y1 * 2^(n/2)+y0//y1 and y0  are high order and low order n/2 bits\n  Compute x1+x0  and y1+y0\n  p = Recursive-Multiply (x1+x0,y1+y0)\n  x1y1 = Recursive-Multiply (x1,y1)\n  x0y0 = Recursive-Multiply (x0,y0)\n  Return  x1y1*2^n + (p-x1y1-x0y0)*2^(n/2)+x0y0\n</code></pre>\n  \n  <p>(a) Explain how the above algorithm works and provides the correct answer.</p>\n  \n  <p>(b) Write a recurrence relation for the number of basic operations for the above algorithm.</p>\n  \n  <p>(c) Solve the recurrence relation and show that its complexity is $O(n^{\\lg 3})$</p>\n</blockquote>\n\n<h3>My conjecture</h3>\n\n<ol>\n<li>Since the method is being called three times, the complexity is going to be $3C(n/2) + n/2$.</li>\n</ol>\n\n<h3>My questions</h3>\n\n<ol>\n<li><p>What do they mean by hi-lo order bits?</p></li>\n<li><p>How can I use a recurrence relation on this if I don't know how each recursion works?</p></li>\n</ol>\n", 'ViewCount': '228', 'Title': 'Complexity of a recursive bignum multiplication algorithm', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-30T00:24:45.967', 'LastEditDate': '2013-09-29T23:25:48.427', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14690', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<algorithms><time-complexity><recursion>', 'CreationDate': '2013-09-29T23:02:57.907', 'Id': '14685'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am stumped as to how to print the longest path from the root of a binary tree to a leaf, essentially traversing the height of the tree. I've got the following for finding the height of a binary tree:</p>\n\n<pre><code>if (root == null) {\n    return -1;\n}\n\nreturn 1 + (Math.max(heightOfTree(root.leftNode), heightOfTree(root.rightNode)));\n</code></pre>\n\n<p>This easily finds the height of the tree but doesn't lend itself to actually figuring out which nodes should be printed out. I could go about finding the nodes's value that is at the leaf, and then do a find for that particular node, but that seems inefficient. </p>\n\n<pre><code>        A\n      B   C\n    D  E F  G\n             H\n</code></pre>\n\n<p>For example, the height of this binary tree is 3, and I would ideally like to know the path to take, in this case it would be A, C, G, H. I know that I most likely need to keep an array for the path, but I just can't seem to find a solution that isn't terribly inefficient. </p>\n", 'ViewCount': '955', 'ClosedDate': '2013-10-28T20:58:32.103', 'Title': 'Printing The Longest Path from Root to Leaf in Binary Tree', 'LastActivityDate': '2013-10-02T20:46:24.137', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10399', 'Tags': '<binary-trees><recursion>', 'CreationDate': '2013-09-29T23:35:34.197', 'Id': '14687'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For analyzing the running time of an algorithm , I'm stuck with this recursive equation :\n$$\nT(n) = \\log(n) \\cdot T(\\log n) + n\n$$\nObviously this can't be handled with the use of the Master Theorem, so I was wondering if anybody has any ideas for solving this recursive equation.</p>\n\n<p>I'm pretty sure that it should be solved with a change in the parameters, like considering $n$ to be $2^m$, but I couldn't manage to find any good fix.</p>\n", 'ViewCount': '371', 'Title': 'Recursive equation for complexity: T(n) = log(n) * T(log(n)) + n', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-10-03T11:25:54.990', 'LastEditDate': '2013-10-03T11:25:54.990', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14777', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10478', 'Tags': '<asymptotics><runtime-analysis><recursion><master-theorem>', 'CreationDate': '2013-10-03T09:53:19.790', 'Id': '14775'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I really need help with this task here. Im stuck at it and I really would appreciate your help </p>\n\n<p>Here is the task:</p>\n\n<blockquote>\n  <p>Give a recursive function $r$ on $A$ that reverses a string. For instance,\n  $r(logikk) = kkigol$ and $r(moro) = orom$. (given that $A$ the amount of\n  letters in the Norwegian alphabet which has 29 letters.). Define the\n  function in such a way that it is correctly regardless of what $A$ are.</p>\n</blockquote>\n\n<p>Also $logikk$ means $logic$ in norwegian, and $moro$ means $fun$ in norwegian in case you're wondering. </p>\n\n<p><strong>Edit:</strong></p>\n\n<p>I tried to solve one of the recursive functions, $r(logikk)$, but i'm not sure if all of it is correct:</p>\n\n<blockquote>\n  <p>$\\Lambda =$ The empty string</p>\n  \n  <p>$r(\\Lambda) =$ $\\Lambda$, $r(k) = k$, $r(k) = k$, $r(i) = i$, $r(g) = g$, $r(o) = o$, $r(l) = l$</p>\n  \n  <p>For any word $w$ and letter $a$, $r(wa) = wa$</p>\n</blockquote>\n\n<p>Can someone please check if this is correct for $r(logikk)$ I feel like i'm missing something but i'm not sure what.</p>\n", 'ViewCount': '63', 'Title': 'Give a recursive function $r$ on $A$ that reverses a string', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-14T16:01:13.883', 'LastEditDate': '2013-10-14T07:57:31.167', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10709', 'Tags': '<recursion><functional-programming>', 'CreationDate': '2013-10-13T16:07:15.447', 'Id': '16041'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a tree $T$ and a sequence of nodes $S$, with the only constraint on $S$ being that it's done through some type of recursion - that is, a node can only appear in $S$ if all of its ancestors have already appeared, what's a good algorithm to determine if $S$ is a breadth first visit, a depth first visit, or neither?</p>\n\n<p>A brute force approach is to compute every breadth first and depth first sequences and see if any is identical to $S$.  Is there a better approach?</p>\n\n<p>What if we don't want a yes or no answer, but a measure of distance.  E.g. $breadth &lt; S &lt; R &lt; U &lt; depth$; what's a good algorithm to determine distance? (A brute force approach for this is just $max(length(longest{\\_}common{\\_}subsequence(S, breadth))/length(breadth))$ over every BFS - again, is there a better way to do this?)</p>\n", 'ViewCount': '167', 'Title': 'Algorithm to determine if recursion was breadth first or depth first', 'LastEditorUserId': '10925', 'LastActivityDate': '2014-02-24T22:45:29.007', 'LastEditDate': '2013-10-27T11:20:32.830', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<algorithms><trees><recursion><discrete-mathematics>', 'CreationDate': '2013-10-27T00:54:38.727', 'FavoriteCount': '1', 'Id': '16459'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Half a decade ago I was sitting in a data structures class where the professor offered extra credit if anyone could traverse a tree without using recursion, a stack, queue, etc. (or any other similar data structures) and just a few pointers.  I came up with what I thought was an obvious answer to that question which was ultimately accepted by the professor.  I was sitting in a discrete math class with another professor in the same department--and he asserted that it was impossible to traverse a tree without recursion, a stack, queue, etc., and that my solution was invalid.</p>\n\n<p>So, is it possible, or impossible?  Why or why not?</p>\n\n<p>Edit:  To add some clarification, I implemented this on a binary tree which had three elements-- the data stored at each node and pointers to two children.  My solution could be extended to n-ary trees with only a few changes.</p>\n\n<p>My data structures teacher did not put any constraints against mutating the tree, and indeed I found out later that his own solution was to use the child pointers to point back up the tree on his way down.  My discrete math professor said any mutation of a tree means that it is no longer a tree according to the mathematical definition of a tree, his definition would also preclude any pointers to parents--which would match the case where I solved it above.</p>\n', 'ViewCount': '726', 'Title': 'Can a tree be traversed without recursion, stack, or queue, and just a handful of pointers?', 'LastEditorUserId': '11262', 'LastActivityDate': '2013-11-14T13:15:47.923', 'LastEditDate': '2013-11-09T16:24:18.440', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11262', 'Tags': '<algorithms><trees><recursion>', 'CreationDate': '2013-11-08T22:19:23.803', 'FavoriteCount': '1', 'Id': '16833'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '62', 'Title': 'Converting a recursive algorithm to a runtime function', 'LastEditDate': '2013-11-12T16:48:25.630', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10875', 'Body': "<pre><code>void Sort(int A[], int left, int right)\n{\n    int p;\n\n    if (left &lt; right)\n    {\n        p = (right + left + 2)/3;\n\n        Sort(A, left, left+p-1);\n        Sort(A, left+p, left+2*p-1);\n\n        MergeSort(A, left+2*p, right);\n\n        Merge3(A, left, left+p, left+2*p, right);\n    }\n}\n</code></pre>\n\n<p>I need to convert this function into a mathematical expression in order to solve it's run-time complexity.</p>\n\n<p>I know  that <code>MergeSort()</code>'s complexity is of $\\Theta(n \\log n)$ and that <code>Merge3()</code>'s complexity is of $\\Theta(n)$.</p>\n\n<p>I can't figure how to transform this into a recursive mathematical expression.</p>\n", 'ClosedDate': '2013-11-15T15:38:52.877', 'Tags': '<algorithm-analysis><runtime-analysis><recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T18:03:24.563', 'CommentCount': '11', 'AcceptedAnswerId': '17964', 'CreationDate': '2013-11-12T12:37:24.567', 'Id': '17956'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>consider following code</p>\n\n<pre><code>int f(int x)\n{\n  if(x&lt;1) return 1;\n  else return f(x-1)+g(x);\n}\nint g(int x)\n{\n  if(x&lt;2) return 1;\n  else return f(x-1)+g(x/2);\n}\n</code></pre>\n\n<p><b>Questions:</b></p>\n\n<blockquote>\n  <p>How do I find the growth of <code>f(x)</code>, being that it contains a recursion to another function?</p>\n  \n  <p>Are growth and time complexity of a a function same thing? Are they the same for <code>f(x)</code>?</p>\n</blockquote>\n', 'ViewCount': '147', 'Title': 'Finding growth of "inter-recursive" functions', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-27T07:04:48.907', 'LastEditDate': '2013-11-24T01:34:40.410', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10380', 'Tags': '<algorithm-analysis><recurrence-relation><recursion>', 'CreationDate': '2013-11-23T19:07:15.820', 'FavoriteCount': '1', 'Id': '18283'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been trying to implement an algorithm to detect cycles (probably how many of them) in a <code>directed and undirected graph</code>. That is the code should apply for both directed and undirected graphs.</p>\n\n<p>Using <code>DFS or topological sort</code> is mostly recommended in various posts. But largely, everything is addressed for undirected graph. </p>\n\n<p><a href="http://pages.cs.wisc.edu/~vernon/cs367/notes/13.GRAPH.html" rel="nofollow">This link</a> describes one approach for cycle detection. To my understanding this works for directed graphs.</p>\n\n<p><a href="http://algs4.cs.princeton.edu/41undirected/CC.java.html" rel="nofollow">This link</a> has the code for cycle detection in undirected graphs. but I fail to understand how it ignores the back edge. That is it must ignore any cycles with two nodes, say D to C and C to D.\nwhich means it must remember it parent as the DFS recurses. But the code does not seem take care of that.</p>\n\n<p>Any suggestions welcome..</p>\n\n<p><img src="http://i.stack.imgur.com/YA7NX.png" alt="enter image description here"></p>\n', 'ViewCount': '120', 'Title': 'single algorithm to work on both directed and undirected graph to detect cycles?', 'LastActivityDate': '2013-11-27T16:11:53.180', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11469', 'Tags': '<algorithms><graphs><recursion>', 'CreationDate': '2013-11-26T00:35:32.907', 'Id': '18342'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a question regarding recursion in <a href="http://en.wikipedia.org/wiki/Viterbi_algorithm" rel="nofollow">Viterbi algorithm</a>.</p>\n\n<p>Define $\\pi(k; u; v)$  which is the maximum probability for any sequence of length $k$, ending in the tag bigram $(u; v)$.</p>\n\n<p>The base case if obvious $\\pi(0,*,*)=1$</p>\n\n<p>The general case.</p>\n\n<p>$\\pi(k,u,v) = max_{w \\in K_{k-2} } \\pi(k-1,w,u) \\cdot q(v|w,u) \\cdot e(x_k|v)$</p>\n\n<p>The author justifies the recursion as folllows: </p>\n\n<blockquote>\n  <p>How can we justify this recurrence? Recall that $\\pi(k, u, v)$ is the highest probability for any sequence $y_{\u22121}...y_k$ ending in the bigram $(u, v)$. Any such sequence must have $y_{k\u22122} = w$ for some state $w$. The highest probability for any sequence of length $k \u2212 1$ ending in the bigram $(w, u)$ is $\\pi(k \u2212 1, w, u)$, hence the highest probability for any sequence of length $k$ ending in the trigram $(w, u, v)$ must be $\\pi(k \u2212 1,w, u) \\cdot q(v|w, u) \\cdot e(x_k |v)$</p>\n</blockquote>\n\n<p>I do not understand why it\'s actually true, I think it\'s possible to reach $\\pi(n,u, v)$ from any $(n-1,w, u)$ not actually the maximum one $\\pi(n-1,w, u)$ just because $q(v|w, u) \\cdot e(x_k |v)$ might have a higher influence on the resulting $(n,u, v)$ than any $\\pi(n-1,w, u)$.</p>\n\n<p>I would appreciate if anyone could explain me why it\'s true.</p>\n', 'ViewCount': '94', 'Title': 'Viterbi algorithm recursive justification', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-04T18:05:36.053', 'LastEditDate': '2014-02-04T18:05:36.053', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19109', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8473', 'Tags': '<algorithms><dynamic-programming><recursion><correctness-proof><hidden-markov-models>', 'CreationDate': '2013-12-18T13:44:43.103', 'Id': '19093'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Say I have Simply typed lambda calculus, and add an assignment rule:</p>\n\n<pre><code>&lt;identifier&gt; : &lt;type&gt; = &lt;abstraction&gt;\n</code></pre>\n\n<p>Where <code>&lt;identifier&gt;</code> is the name of the function, <code>&lt;type&gt;</code> is the function type and <code>&lt;abstraction&gt;</code> is the abstraction to be assigned to the identifier. </p>\n\n<p>Then I add a typing rule that says that when you see an assignment such as the above, you use a temporary type context, in which the declared type (the one in <code>&lt;identifier&gt; : &lt;type&gt;</code>) is associated with the identifier, to type check <code>&lt;abstraction&gt;</code> and then make sure the declared type equals the abstraction\'s type.</p>\n\n<p>And finally I add another rule that would let me have a list of assignments on top of a lambda term which is the one I\'d evaluate, such that all these assignments would be added to the global scope before the term is evaluated.</p>\n\n<p>Seems to me that this alone would make it Turing complete since I\'d be able to do stuff like:</p>\n\n<pre><code>stackoverflow: NUM -&gt; NUM = \u03bbn:NUM.(stackoverflow n)\n(stackoverflow 0)\n</code></pre>\n\n<p>And at the same time, everything I can define in this language would be "well typed" in the sense that it wouldn\'t be able to define infinite types (I wouldn\'t be able to define the Y combinator).</p>\n\n<p>So my questions are, is this really Turing complete? And, am I missing something when I say everything would be "well typed" (like for instance, I could define the Y combinator in a way I haven\'t yet realized or is there any gotcha in this type system)?</p>\n', 'ViewCount': '63', 'Title': 'Would adding recursive named functions to Simply typed lambda calculus make it Turing complete?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-22T17:08:16.207', 'LastEditDate': '2013-12-22T17:08:16.207', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19193', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><recursion><type-theory><turing-completeness><typing>', 'CreationDate': '2013-12-22T05:19:44.457', 'Id': '19187'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am getting confused with the solution to this recurrence - \n$T(n) = T(n/2) + n^2$</p>\n\n<p>Recursion tree - </p>\n\n<pre><code>T(n)                      Height lg n + 1\n |\nT(n/2)\n |\nT(n/4)\n</code></pre>\n\n<p>So it turns out to be -</p>\n\n<p>$T(n) = n^2(1 + 1/4 + (1/4)^2) + \\ldots (1/4)^{\\log_2 n - 1})$</p>\n\n<p>$T(n) = 4*n^2(1- (1/4)^{\\log_2 n})/3 + n^2 $</p>\n\n<p>$T(n) = 4*n^2(1 - 1^{\\log_2 n} + 4^{\\log_2 n})/3 + n^2 $</p>\n\n<p>$ T(n) = 4*n^2(1 - 1 + n^{\\log_2 4})/3 + n^2$</p>\n\n<p>$ T(n) = 4*n^2(n^2)/3 + n^2$</p>\n\n<p>$ T(n) = 4/3 * (n^4) + n^2 $</p>\n\n<p>$ T(n) = \\Theta(n^4) $</p>\n\n<p>But according to the Master theorem, $a = 1, b = 2, f(n) = n^2 $, then $n^{\\log_2 1} = 1 $ which is polynomial times less than $ n^2 $ so the solution should be $ \\Theta (n^2) $?</p>\n', 'ViewCount': '113', 'Title': 'Solution to recurrence $T(n) = T(n/2) + n^2$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-29T04:07:39.913', 'LastEditDate': '2013-12-27T15:57:15.230', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '19319', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11750', 'Tags': '<recurrence-relation><recursion><master-theorem>', 'CreationDate': '2013-12-27T01:22:05.733', 'Id': '19318'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having a hard time with the following question:</p>\n\n<p>Use a recursion tree to determine a good asymptotic upper bound on the recurrence $T(n) = 4T(n/2 + 2) + n$. Use the substitution method to verify your answer.</p>\n\n<p>This is not homework, I'm just practicing myself for an upcoming exam.</p>\n\n<p>The thing I'm having a hard time with is the $n/2 + 2$, what will the height be of this recursion tree?</p>\n\n<p>I came up with the following formula to calculate the cost of each level after a lot of labor:\n$2^i n + 2^{i+2}(2^i -1)$ not 100% sure this is correct either.</p>\n\n<p>Any help appreciated, really looking forward to the answer :D<br>\nI often make stupid mistakes and I just started doing algo's for my first time.</p>\n", 'ViewCount': '636', 'Title': 'CLRS 4.4-3 Height of recursion tree for T(N) = 4T(n/2 +2) + n', 'LastActivityDate': '2013-12-28T21:03:49.723', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19350', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12422', 'Tags': '<algorithm-analysis><recursion>', 'CreationDate': '2013-12-28T17:42:51.827', 'Id': '19343'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>i am new to compiler design, currently studying Ullmans book on this.He says:</p>\n\n<p>Problem with predictive parsing (both recursive and non recursive) is that Left recursive productions can go infinite loop.Thus, to make grammar suitable for predictive parsing we need to eliminate the left recursion by immediately or indirectly.</p>\n\n<pre><code> E -&gt; E+T|t\n</code></pre>\n\n<p>My problem is, same can happen with right recursion also.What is the solution for it?</p>\n\n<pre><code> T -&gt; E+T|t\n</code></pre>\n\n<p>Please correct me if i am wrong! thanks.</p>\n', 'ViewCount': '52', 'Title': 'Need solution for infinite right recursive grammar in Predictive parsing?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T19:25:29.983', 'LastEditDate': '2014-04-12T17:48:36.483', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10564', 'Tags': '<formal-grammars><parsing><left-recursion>', 'CreationDate': '2014-01-11T12:16:06.933', 'Id': '19654'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm following the algorithm for left recursion elimination from a grammar. It says remove the epsilon production if there is any.</p>\n\n<p>I have the grammar</p>\n\n<p>$\\qquad S \\to Aa \\mid b$<br>\n$\\qquad A \\to Ac \\mid Sd \\mid \\varepsilon$</p>\n\n<p>I can see after removing the epsilon productions the grammer becomes</p>\n\n<p>$\\qquad S \\to Aa \\mid a \\mid b$<br>\n$\\qquad A \\to Ac \\mid Sd \\mid c \\mid d$ </p>\n\n<p>I'm confused where the $a \\mid b$ for $S$ and $c \\mid d$ for $A$ come from.\nCan someone explain this?</p>\n", 'ViewCount': '38', 'Title': 'Eliminating $\\varepsilon$-productions during elimination of left recursion', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T20:51:58.290', 'LastEditDate': '2014-01-23T17:14:14.097', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<context-free><formal-grammars><compilers><left-recursion>', 'CreationDate': '2014-01-23T15:28:15.480', 'Id': '19913'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider the following function definitions:</p>\n\n<pre><code>(define (lol xs)\n  (if ((equal? xs '()) #t)\n      (wat cdr xs)))\n\n(define (wat xs)\n  (if ((equal? xs '()) #f)\n      (lol cdr xs)))\n</code></pre>\n\n<p><code>lol</code> and <code>wat</code> are both indirect recursions, right? Since the last action is always the recursive function call, they should also be tail recursions. \nBut can an interpreter optimize this to a simple and efficient iteration (Which IMO is the whole point of using tail recursion)?</p>\n", 'ViewCount': '33', 'ClosedDate': '2014-02-25T23:15:19.813', 'Title': 'Can indirect recursion also be tail recursive?', 'LastActivityDate': '2014-02-25T20:49:52.630', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'raffomania', 'PostTypeId': '1', 'OwnerUserId': '13357', 'Tags': '<functional-programming><recursion>', 'CreationDate': '2014-02-03T14:44:35.663', 'Id': '21350'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this grammar and I have to remove direct left recursion and common prefixes. This is the grammar:</p>\n\n<p>$\\qquad\\displaystyle S \\to SSA  \\mid SSB   \\mid SSC   \\mid AS   \\mid A$</p>\n\n<p>this is what I did:</p>\n\n<p>Removing common prefixes: (I think that in English you call this left factoring, right?)</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to SSS' \\mid AS'' \\\\\n  S' &amp;\\to A \\mid B \\mid C  \\\\  \n  S'' &amp;\\to S \\mid E \n\\end{align*}$</p>\n\n<p>Removing direct left recursion:</p>\n\n<p>$\\qquad\\begin{align*}\n S &amp;\\to AS''S'''   \\\\\n S''' &amp;\\to S'''S'S''' \\mid E  \\\\\n S''' &amp;\\to S'''' \\\\\n S'''' &amp;\\to E \\mid S'S'''S''''\n\\end{align*}$</p>\n\n<p>Is this correct?</p>\n\n<p>My doubts are specifically about the removing of the direct left recursion. If I have for example:</p>\n\n<p>$\\qquad\\displaystyle S \\to SSa \\mid b$</p>\n\n<p>and I apply the formula to remove direct left recursion, which of the two solutions is the correct one?</p>\n\n<p>This:</p>\n\n<p>$\\qquad\\begin{align*} \n S &amp;\\to bS' \\\\\n S' &amp;\\to S'aS'\n\\end{align*}$</p>\n\n<p>or this:</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to bS' \\\\\n  S' &amp;\\to SaS'\n\\end{align*} \\qquad$?</p>\n", 'ViewCount': '65', 'Title': 'Remove direct left recursion and common prefixes', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T09:21:14.103', 'LastEditDate': '2014-02-07T09:21:14.103', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14463', 'Tags': '<formal-grammars><left-recursion>', 'CreationDate': '2014-02-07T05:17:35.727', 'Id': '21421'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '117', 'Title': 'The minimization operator is an effective operator', 'LastEditDate': '2014-02-12T18:58:57.467', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Student', 'PostTypeId': '1', 'OwnerUserId': '11762', 'Body': u'<p>Assume $\\{f_i^{(n)}\\}_{i=0}^\\infty$ is a G\xf6del enumeration of the $\\mu$-recursive functions of $n$ arguments, such that the $S^m_n$ theorem and the universal function theorem hold. Denote the set of (total and partial) functions $\\{f:\\mathbb N^k\\to\\mathbb N\\\n\\}$ by $\\mathfrak F^k$</p>\n\n<p><strong>Definition:</strong> We call an operator $G:\\mathfrak F^n\\to\\mathfrak F^k$ effective, if $(\\forall j\\in\\mathbb N)(G(f^{(n)}_j)=f^{(k)}_{g(j)})$ for some total recursive function $g$.</p>\n\n<p><strong>Claim:</strong> The minimization operator $\\mu:\\mathfrak F^{k+1}\\to\\mathfrak F^k$ defined by $$\\mu(f)(\\overline x)=\\mu y[f(y,\\overline x)=0]=y\\iff (f(y,\\overline x)=0\\land(\\forall i&lt;y) (f(i,\\overline x)&gt;0))$$ is an effective operator.</p>\n\n<p><strong>Question:</strong> How can I go about proving the statement? Hints are welcome.</p>\n\n<p><strong>Thought:</strong> By definition the $\\mu$-recursive functions are closed with respect to the $\\mu$-operator. Therefore, $\\mu(f^{(k+1)}_j)=f^{(k)}_{h(j)}$, for some unique total function $h$. But why is $h$ a computable function?</p>\n\n<p>Note that I would really like to stay within the Partial Recursive Functions Formalism. Pseudo code means nothing to me. I cannot read it. I am not familiar with most of the notation from the programming world. I would also prefer not go into Register Machine Formalisms.</p>\n', 'Tags': '<computability><recursion><mu-calculus>', 'LastEditorUserId': '11762', 'LastActivityDate': '2014-02-12T18:58:57.467', 'CommentCount': '6', 'AcceptedAnswerId': '21529', 'CreationDate': '2014-02-10T10:04:12.157', 'Id': '21509'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was trying to rule out whether this was LL(1) by checking for left-recursion in the following grammar:</p>\n\n<p>$\\qquad  A \\to 0 A 1 \\mid 0 1$</p>\n\n<p>Which produces:</p>\n\n<p>$\\qquad 0 A 1 \\Rightarrow 0 0 A 1 1 \\Rightarrow \\dots$</p>\n\n<p>But I am unsure what type of recursion this is called, since it sorta stays in the middle.</p>\n\n<p>If this is not left-recursive, would you agree that this is not LL(1) because non-terminal A has 0 appear twice in FIRST(A)?</p>\n', 'ViewCount': '51', 'Title': 'What type of recursion is this?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T00:04:23.193', 'LastEditDate': '2014-02-18T08:18:31.617', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21756', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2014-02-18T06:31:22.527', 'Id': '21753'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Taking <a href="http://www.geeksforgeeks.org/backtracking-set-7-suduku/" rel="nofollow">this</a> as an example:</p>\n\n<pre><code>bool SolveSudoku(int grid[N][N])\n{\n    int row, col;\n\n    // If there is no unassigned location, we are done\n    if (!FindUnassignedLocation(grid, row, col))\n       return true; // success!\n\n    // consider digits 1 to 9\n    for (int num = 1; num &lt;= 9; num++)\n    {\n        // if looks promising\n        if (isSafe(grid, row, col, num))\n        {\n            // make tentative assignment\n            grid[row][col] = num;\n\n            //RUN ARC CONSISTENCY HERE ......?\n\n            // return, if success, yay!\n            if (SolveSudoku(grid))\n                return true;\n\n            // failure, unmake &amp; try again\n            grid[row][col] = UNASSIGNED;\n\n            ////REMOVE ARC CONSISTENCY HERE ......?\n        }\n    }\n    return false; // this triggers backtracking\n}\n</code></pre>\n\n<p>Given the backtracking algorithm with CSP\'s, I would like to add ARC consistency to make it smarter.</p>\n\n<p><a href="http://www.codeproject.com/Articles/34403/Sudoku-as-a-CSP" rel="nofollow">For example</a>:</p>\n\n<blockquote>\n  <p>"When we want to assign the digit \'d\' to cell s1, we use assign(cells,\n  s, d).  ...but I also want to eliminate this possibility from its\n  peers  (like Forward Checking does, tell me something new!). If the\n  elimination causes one (or some) of the peers going down to only one \n  possibility, which we call d2, we want to assign d2 to it, and by\n  doing that,  eliminate d2 from all of its peer\'s peers, and that could\n  make another chain  reaction. This chain reaction is simply called\n  constraint propagation:  placing a constraint on one cell can cause\n  further constraints to be placed on  other cells."</p>\n</blockquote>\n\n<ul>\n<li>Can the process of arc propagation end up leading to a solution by\nitself or even a false solution? What is done in those cases?</li>\n<li>In the likely event the next recursive call on the next variable returns false (no values worked out for that variable), <strong>how do I\nundo all the changes the arc consistency did?</strong></li>\n</ul>\n', 'ViewCount': '21', 'Title': 'How is ARC consistency un-done after a recursive failure condition?', 'LastActivityDate': '2014-02-28T02:44:32.343', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22119', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15116', 'Tags': '<algorithms><artificial-intelligence><recursion><constraint-programming><backtracking>', 'CreationDate': '2014-02-28T00:42:17.027', 'FavoriteCount': '3', 'Id': '22116'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '34', 'Title': 'Barnes-Hut algorithm and recursion limit', 'LastEditDate': '2014-03-02T09:38:00.273', 'AnswerCount': '0', 'Score': '1', 'OwnerDisplayName': 'user3058846', 'PostTypeId': '1', 'OwnerUserId': '15188', 'Body': '<p>I\'m running the <a href="http://en.wikipedia.org/wiki/Barnes%E2%80%93Hut_simulation" rel="nofollow">Barnes-Hut simulation algorithm</a> for an $n$-body simulation.</p>\n\n<p>If while distributing each particles to their corresponding nodes, two particles comes closer to a level smaller than the machine precision (or $\\Delta d \\to 0$), how is the situation to be treated? Should the recursive distribution stop and add both of them to a single node?\nThis happens because of treating particles as point objects rather than 2D objects, yet imagine a machine having a precision level of 3 decimal points (millimeters in the SI system) and the bodies came closer to $10^{-6}$ (micro) level.</p>\n', 'ClosedDate': '2014-03-02T19:03:05.587', 'Tags': '<algorithms><recursion>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-02T09:38:00.273', 'CommentCount': '2', 'CreationDate': '2014-03-01T18:44:27.993', 'Id': '22184'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '32', 'Title': 'Left recursion for LL(1)', 'LastEditDate': '2014-03-28T01:43:23.957', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15655', 'Body': u'<p>Hi I am trying to solve a LL(1) form question for first n follow rule The question is</p>\n\n<pre><code>A::=BC|C\nB::=Bd|ef\nC::=gh|j\n</code></pre>\n\n<p>What I have done to eliminate left recursion </p>\n\n<pre><code>A::=CA\u2019\nA\u2019::=CB\u2019\nA\u2019::=\u03f5\nB::=efB\u2019\nB::=dB\u2019\nB\u2019::=\u03f5\nC::=gh\nC::= j\n</code></pre>\n\n<p>Is it correct?</p>\n\n<p>Thanks guys, it has been solved.</p>\n', 'ClosedDate': '2014-03-27T07:54:49.217', 'Tags': '<formal-languages><parsing><left-recursion>', 'LastEditorUserId': '15655', 'LastActivityDate': '2014-03-28T01:43:23.957', 'CommentCount': '1', 'AcceptedAnswerId': '22595', 'CreationDate': '2014-03-13T18:07:01.433', 'Id': '22594'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to wrap my head around recursion and divide and conquer algorithms. Can someone provide a proof and explanation of how many times a list of n elements can be divided in 1/2 on both sides.. In other words the total number of half divisions in a recursive divide procedure on a list of size n. </p>\n', 'ViewCount': '59', 'ClosedDate': '2014-03-27T08:00:03.037', 'Title': 'How many times can you divide a list of n elements in 1/2', 'LastActivityDate': '2014-03-15T22:31:08.997', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '22660', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14847', 'Tags': '<recurrence-relation><recursion><divide-and-conquer>', 'CreationDate': '2014-03-15T19:25:02.470', 'Id': '22656'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '89', 'Title': 'What are efficient ways to compute the derivatives of iterated functions?', 'LastEditDate': '2014-03-26T18:45:29.407', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16143', 'FavoriteCount': '1', 'Body': u'<p>The derivatives of iterated functions at a fixed point $z_0$ are useful in constructing a Taylors series of iterated analytic functions - in other words, the Taylors series of a dynamical system $f^t(z_0)$. </p>\n\n<p>A simpler version of the problem casts light on possible approaches. Instead of iterated functions, consider composite functions and <a href="http://en.wikipedia.org/wiki/Fa%C3%A0_di_Bruno%27s_formula" rel="nofollow">Fa\xe0 di Bruno\'s formula</a> The combinatorial structure <a href="http://en.wikipedia.org/wiki/Integer_partition" rel="nofollow">integer partitions</a> serves as the index to the summations in Fa\xe0 di Bruno\'s formula. So the first step of evaluation is to enumerate all integer partitions of a given order.  </p>\n\n<p>While combinatorial structure <a href="http://oeis.org/A000041" rel="nofollow">integer partitions</a> are associated with the derivatives of composite functions, <a href="http://oeis.org/A000669" rel="nofollow">the unlabeled version of the labeled combinatorial structure total partitions</a> are associated with iterated functions. See <a href="http://tetration.org/Combinatorics/PartitionDiagrams.htm" rel="nofollow">Partition Diagrams</a> for more information on the different relevant combinatorial structures. The following Mathematica code does what I need, but the cost of simplicity is that it first enumerates the labeled total partitions to compute the unlabeled total partitions. So for $n=10$, $D^{10}f^t(z_0)$, there are 282,137,824 labeled total partitions, while there are only 2,312 unlabeled partitions. </p>\n\n<h2>Combinatorial Examples</h2>\n\n<p>a(4)=5 unlabeled total partitions: (oooo),(oo(oo)),(o(ooo)),(o(o(oo))),((oo)(oo)).</p>\n\n<p>b(4)=26 labeled total partitions: ((1,4),2,3), (1,(2,4),3), (1,2,(3,4)), (((1,4),2),3), ((1,(2,4)),3), ((1,2),(3,4)), (((1,4),3),2), ((1,(3,4)),2), ((1,3),(2,4)), ((1,4),(2,3)), (1,((2,4),3)), (1,(2,(3,4))), (1,2,3,4), ((1,2,4),3), ((1,2),3,4), ((1,3,4),2), ((1,3),2,4), (1,(2,3,4)), (1,(2,3),4), ((1,2,3),4), (((1,2),4),3), (((1,2),3),4), (((1,3),4),2), (((1,3),2),4), (1,((2,3),4)), ((1,(2,3)),4)</p>\n\n<p>b(4) = 12 (o(o(oo))) + 3 ((oo)(oo)) + 6 ((oo(oo)) + 4 (o(ooo)) + (oooo) = 26</p>\n\n<p>I would like to have an efficient way to reproduce the preceding results.</p>\n\n<h2>Mathematica code</h2>\n\n<pre><code>TotalPartitions[0] = {{}};\nTotalPartitions[1] = {{1}};\nTotalPartitions[2] = {{1, 2}};\nMatch[l_List, pattern_] := Extract[l, Position[l, pattern]];\nTP1[l_List, next_Integer] := \n  Map[( l /. # -&gt; {#, next}) &amp;, Match[l, _Integer] ];\nTP2[l_List, next_Integer] := \n  Map[( l /. # -&gt; Append[#, next]) &amp;, Match[l, _List] ];\nTP3[l_List, next_Integer] := \n  Map[( l /. # -&gt; {#, next}) &amp;, Match[l, _List] ];\nTotalPartitions[n_Integer] := \n  TotalPartitions[n] = \n   Flatten[ {Map[(TP1[#, n] ) &amp;, TotalPartitions[n - 1]], \n     Map[(TP2[#, n] ) &amp;, TotalPartitions[n - 1]], \n     Map[(TP3[#, n] ) &amp;, TotalPartitions[n - 1]]}, 2];\n\nu = TotalPartitions[4] /. _Integer -&gt; 1\n&gt; {{{{1, 1}, 1}, 1}, {{1, {1, 1}}, 1}, \n&gt;  {{1, 1}, {1, 1}}, {{1, 1}, {1, 1}}, \n&gt;  {1, {{1, 1}, 1}}, {1, {1, {1, 1}}}, \n&gt;  {{1, 1}, 1, 1}, {1, {1, 1}, 1}, \n&gt;  {1, 1, {1, 1}}, {{{1, 1}, 1}, 1}, \n&gt;  {{1, {1, 1}}, 1}, {{1, 1}, {1, 1}}, \n&gt;  {{1, 1, 1}, 1}, {{1, 1}, 1, 1}, \n&gt;  {1, {1, 1, 1}}, {1, {1, 1}, 1}, \n&gt;  {1, 1, 1, 1}, {{1, 1, 1}, 1}, \n&gt;  {{1, 1}, 1, 1}, {{{1, 1}, 1}, 1}, \n&gt;  {{{1, 1}, 1}, 1}, {1, {{1, 1}, 1}}, \n&gt;  {{1, {1, 1}}, 1}, {{1, 1, 1}, 1}, \n&gt;  {{{1, 1}, 1}, 1}, {{{1, 1}, 1}, 1}}\n\nSetAttributes[Z, Orderless];\nTally[Apply[List, Apply[Z, u, Infinity], Infinity]]\n&gt;  {{{1, {1, {1, 1}}}, 12}, {{{1, 1}, {1, 1}}, 3}, {{1, 1, {1, 1}}, 6}, \n&gt;   {{1, {1, 1, 1}}, 4}, {{1, 1, 1, 1}, 1}}\n</code></pre>\n\n<p>Note that the Tally function displays the number of occurrences of labeled total partitions for each unlabeled total partition, so that $12+3+6+4+1=26$ shows how the 5 unlabeled total partitions of order 4 map to the 26 labeled total partitions. I\'ve tried pure analytic approaches, combinatorial approaches and a hybrid of the two in my Mathematica programs <a href="http://tetration.org/Resources/Files/Mathematica/SchroederSummations.nb" rel="nofollow">Schroeder Summations and Iterate.</a> I believe this is a useful problem in dynamics and combinatorics and merits an efficient answer.</p>\n', 'Tags': '<algorithms><combinatorics><recursion>', 'LastEditorUserId': '16143', 'LastActivityDate': '2014-03-30T07:36:14.487', 'CommentCount': '5', 'AcceptedAnswerId': '23108', 'CreationDate': '2014-03-26T14:00:31.227', 'Id': '23076'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For example,</p>\n\n<p>Let the Grammar be:</p>\n\n<pre><code>S-&gt;Sa|B\n</code></pre>\n\n<p>Thus, <code>S-&gt;Sa-&gt;Saa-&gt;...-&gt;Saa...aaa-&gt;Baa...aaa</code></p>\n\n<p>What's wrong with this?</p>\n\n<p>Why is right recursion a solution to the problem?</p>\n\n<pre><code>S-&gt;BS'\nS-&gt;aS'|e\n</code></pre>\n", 'ViewCount': '35', 'ClosedDate': '2014-03-29T11:54:23.990', 'Title': 'Why does left recursion have to be eliminated?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T11:54:13.160', 'LastEditDate': '2014-03-29T11:54:13.160', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11684', 'Tags': '<context-free><formal-grammars><compilers><parsing><left-recursion>', 'CreationDate': '2014-03-29T05:06:57.450', 'Id': '23210'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m taking a graduate course on the theory of functional programming, based on Paul Taylor\'s "Practical Foundations of  Mathematics." I understand the statement of Tarski\'s theorem about how for any $\\omega$-compelte poset $X$, and any $\\omega$-continuous function $T:X\\rightarrow X$, that $T$ has a fixed point which is the join of (The statement and proof can be found <a href="http://www.paultaylor.eu/~pt/prafm/html/s33.html" rel="nofollow">here</a>).</p>\n\n<p>What I want to know is, how is this applicable, other than being a proof that the Y-combinator exists? It just seems to me that it says "we can use recursion to build a function that is defined for all natural numbers", where we could use some other recursive type for numbers. Doesn\'t the existence of the Y-combinator show the same thing?</p>\n', 'ViewCount': '73', 'Title': "What does Tarski's Fixed-Point theorem give us that that Y-Combinator does't", 'LastActivityDate': '2014-04-04T19:32:29.183', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<lambda-calculus><recursion><type-theory><partial-order><lattices>', 'CreationDate': '2014-04-04T19:16:13.043', 'Id': '23431'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to show the following 2 statements:</p>\n\n<ol>\n<li>Set of distinct partial recursive functions are countable.</li>\n<li>Each partial recursive function has an infinite number of indices.</li>\n</ol>\n\n<p>Completely no clue. I think for 1, we just show since we can number them, so they are countable?</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-04-27T11:42:56.097', 'Title': 'Partial recursive functions and indices', 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-27T08:38:48.450', 'LastEditDate': '2014-04-27T08:38:48.450', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17100', 'Tags': '<computability><recursion>', 'CreationDate': '2014-04-26T19:59:34.180', 'Id': '24139'}