2430:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>At my current project I had a network problem come up for which I could not find a solution. In a peer-to-peer network I needed to send an action to all peers, and each peer was to act on it only if it could verify that all other peers would also act on it.</p>\n\n<p>That is, given a network of peers $P = { P_1, ..., P_n }$. We wish to send, from some source peer $P_s$ a message to all other peers. This message contains an action which must be performed. The peer should perform this action if and only if every other peer will perform the action. That is, it performs the action if it can verify that all other peers will also have receipt of the action and can perform the same verification.</p>\n\n<p>The problem is subject to these conditions:</p>\n\n<ol>\n<li>There is no implicit message delivery guarantee: if $P_x$ sends a message to $P_y$ there is no way for $P_x$ to know if $P_y$ gets the message. (Of course $P_y$ can send a receipt, but that receipt is subject to the same constraint)</li>\n<li>Additional messages with any payload may be created.</li>\n<li>There is no total ordering on the messages received by peers. Messages can arrive in a different time-order than which they were sent. This time-order may be unique per peer. <em>Two messages sent in order from $P_x$ to $P_y$ are very unlikely to arrive out of order.</em></li>\n<li>Messages can arrive at any point in the future (so not only are they not ordered, they can be indefintely delayed). A message cannot inherently be detected as lost. <em>Most messages will be delivered quickly, or truly lost.</em></li>\n<li>Each peer has a synchronized clock. It is accurate enough in the domain of scheduling an action and to approximately measure transmission delays. It is however not accurate enough to establish a total ordering on messages using timestamps.</li>\n</ol>\n\n<p>I was not able to find a solution. I'm interested in a <em>guarantee</em> and not simply a high probability of being correct (which can be done simply be repeatedly sending confirmations from peer to peer and rejections upon any likely loss.) My stumbling block is the inability to verify that any particular message actually arrived. So even if $P_x$ determines there is an erorr, there is no guaranteed way to tell the other peers about it.</p>\n\n<p>A negative confirmation is also acceptable. I have a suspicion that a guarantee cannot actually be achieved, only an arbitrarily high probability.</p>\n", 'ViewCount': '71', 'Title': 'Message receipt verification in a cluster', 'LastEditorUserId': '39', 'LastActivityDate': '2012-08-03T09:56:09.247', 'LastEditDate': '2012-08-03T09:56:09.247', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '2802', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1642', 'Tags': '<algorithms><distributed-systems><computer-networks><fault-tolerance>', 'CreationDate': '2012-07-17T07:56:19.143', 'Id': '2784'},2431:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Suppose I'm renaming a file and the electricity goes off right in the middle. Naively, it looks like the file could be in some \u201chalf-renamed\u201d state. Maybe the name would have half the old name and half the new name. Or maybe the file could disappear altogether because it no longer exists under the old name but it doesn't exist yet under the new name.</p>\n\n<p>How can a filesystem protect against loss of power while a file is renamed? Are these just theoretical techniques or are they used in practice?</p>\n", 'ViewCount': '187', 'Title': 'What if the electricity goes off while a file is being renamed?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-08-03T12:54:15.710', 'LastEditDate': '2012-08-03T09:53:31.963', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '3018', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2344', 'Tags': '<operating-systems><filesystems><fault-tolerance>', 'CreationDate': '2012-08-03T03:18:06.503', 'Id': '3012'},2432:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am unable to understand why there is a requirement of 3m+1 generals overall given m traitors. As per my understanding, the steps are as follows:</p>\n\n<ol>\n<li>Each general decides a strategy and forwards their strategy to all the other ($3m$) generals.</li>\n<li>Each general forwards a vector containing the strategies (of all the other generals they received) to all the generals ($m$)</li>\n<li>Now, each general has a list of vectors corresponding to the vote made by each general and using a majority criteria (majority vote) decides each general's strategy and thus, the strategy that it itself chooses.</li>\n</ol>\n\n<p>If there are $3m+1$ generals then, with $m$ (loyal) generals choosing to 'attack' and $m+1$ (loyal) generals choosing to 'defend' and $m$ traitors, then since every loyal general forwards the message correctly, each of the $m$ 'attacking' generals will receive $m-1 + m$ (from the other 'attacking' generals and the $m$ 'defending' generals) confirmations of attack for all the other $m-1$ 'attacking' generals, similarly $m-1 + m$ confirmations of 'defend' for the strategy adopted by each one of the defending generals. The traitors however can alter either by sending whatever they'd like (different bits) to the attackers and the defenders [send <code>d</code> for all the defenders and <code>a</code> for all the attackers, but send conflicting values \u2014 <code>d</code> to the defenders and <code>a</code> to the attackers \u2014 for all the traitors' values], thus making them follow a different plan (defenders will defend, while attackers will attack).</p>\n\n<p>This can't be right, because all the papers and presentations I've gone through state that $3m+1$ with only $m$ traitors will definitely give you the correct solution (all loyal generals follow the same plan). Can anybody go through my understanding, find the flaw and re-explain it to me?</p>\n\n<p>Also, I have understood the $m = 1$ example, it would be nice if someone could explain to me how it fails when $m = 2$ and there are 6 generals and how it succeeds if $m = 2$ and there are 7 generals... I've tried a lot and am stuck.</p>\n", 'ViewCount': '213', 'Title': 'Impossibility condition in the Byzantine Generals problem', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-11T10:33:46.873', 'LastEditDate': '2012-09-10T13:56:22.730', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2777', 'Tags': '<distributed-systems><fault-tolerance>', 'CreationDate': '2012-09-10T13:00:42.823', 'FavoriteCount': '0', 'Id': '3489'},2433:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve stumbled at the first OralMessage algorithm in Lamport, et al\'s paper.</p>\n\n<p>I\'ve searched the web and there are dozens of sites, restating in exactly the same terms and examples, which isn\'t helping me.</p>\n\n<p>Lamport claims the algorithm can handle (n-1)/3 traitors, and works when the commander is a traitor.</p>\n\n<p>My restatement of the algorithm:</p>\n\n<ol>\n<li><p>The commander sends a value to each of the lieutenants.(round 0)</p></li>\n<li><p>Each lieutenant:\nforwards each message he receives to the other lieutenants:<br>\ndon\'t forward messages that already have your name          (eg you are b and receive \'cb1\')<br>\ndon\'t forward messages if they already have (N - 1)/3 names. (eg N=10 and you receive \'gcd0\')<br>\nadd your name to front of message before forwarding         (eg you are b and receive \'c0\', send \'bc0\')</p></li>\n<li><p>after all messages have been sent, each lieutenant:<br>\nexamines the received messages and makes their decision.<br>\nif its a tie, then decide 0.  </p>\n\n<p>I\'m not sure how to do 3, the paper says the algorithm "assumes a sequence of [majority] functions" (nested?)<br>\nIn the example, I\'m assuming to take the majority in each vector of round 2 (ie left to right), and then take the majority of these.  </p></li>\n</ol>\n\n<p>EXAMPLE</p>\n\n<p>Commander is a traitor, N=7, M=(7-1)/3=2, so 6 lieutenants one of whom is a traitor. I have assigned the lieutenants letters b-g.</p>\n\n<p>Here are the messages <strong>received</strong> at each node in rounds 1 &amp; 2, assuming a node can send to itself. (the messages in brackets are redundant from B\'s point of view. I don\'t know if this is important.):</p>\n\n<pre><code>&lt;(b1) ,c0   ,d0   ,eX   ,f1   ,g1   &gt;\n\n&lt;     ,(cb1),(db1),(ebX),(fb1),(gb1)&gt;\n&lt;(bc0),     ,dc0  ,ecX  ,fc0  ,gc0  &gt;\n&lt;(bd0),cd0  ,     ,edX  ,fd0  ,gd0  &gt;\n&lt;(beX),ceX  ,deX  ,     ,feX  ,geX  &gt;\n&lt;(bf1),cf1  ,df1  ,efX  ,     ,gf1  &gt;\n&lt;(bg1),cg1  ,dg1  ,egX  ,fg1  ,     &gt;\n</code></pre>\n\n<p>Note:<br>\n\'dc0\' is sent to everyone by \'d\' (because \'d\' was the last to prepend their name)<br>\n\'X\' indicates an unreliable message. \'e\' is a traitor and always sends unreliable messages  </p>\n\n<p>BUT \'step 3\' gives 1,0,0,X,1,1 which is no better than round 1.<br>\nAND the majority of these is 1 if X is 1, and 0 if X is 0. So the traitor can confound us.</p>\n\n<p>What am I doing wrong?</p>\n', 'ViewCount': '103', 'Title': "Lamport's Byzantine Generals Algorithm", 'LastEditorUserId': '12863', 'LastActivityDate': '2014-04-09T03:32:24.300', 'LastEditDate': '2014-03-09T04:58:42.557', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '15342', 'Tags': '<distributed-systems><fault-tolerance>', 'CreationDate': '2014-03-06T12:44:42.930', 'FavoriteCount': '1', 'Id': '22338'},2434:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading the following computer systems paper:</p>\n\n<p><a href="https://www.usenix.org/system/files/conference/osdi12/osdi12-final-75.pdf" rel="nofollow">https://www.usenix.org/system/files/conference/osdi12/osdi12-final-75.pdf</a></p>\n\n<p>And I was trying to understand why it claims that it does not need data locality for it be perform well.</p>\n\n<p>Basically, in the abstract it says:</p>\n\n<p>"...FDS multiplexes an application\'s large scale I/O across the available throughput and latency budget of every disk in a closer. FDS therefore makes many optimizations around data locality unnecessary."</p>\n\n<p>What I was not sure was, why does multiplexing an applications I/O across the servers in the datacenter, make it unnecessary to have to optimize in terms of data locality?</p>\n\n<p>Basically, as I read the paper they make a big deal that locality is something they don\'t need and that they can achieve the benefits of it without having servers being close to the clients they provide data access. The part I am not sure is, what is the crux of what makes them not depend on data locality? Is it the CLOS network? Is it because they don\'t serve clients around the world? Is it because their servers are all in one data center anyways and not scattered around the world? What is it that makes their performance be so amazing?</p>\n\n<hr>\n\n<p>Paper Reference:</p>\n\n<p>Title: Flat Datacenter Storage</p>\n\n<p>Author(s): Edmund B. Nightingale, Jeremy Elson, Jinliang Fan, Owen Hofmann, Jon Howell, Yutaka Suzue</p>\n\n<p>Institution(s): Microsoft Research, Univeristy of Texas at Austin</p>\n', 'ViewCount': '18', 'Title': 'How does FDS (flat datacenter storage) make optimizations around locality unnecessary?', 'LastEditorUserId': '13012', 'LastActivityDate': '2014-03-28T12:39:47.403', 'LastEditDate': '2014-03-28T04:59:30.653', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13012', 'Tags': '<distributed-systems><fault-tolerance>', 'CreationDate': '2014-03-28T03:37:05.833', 'Id': '23163'}