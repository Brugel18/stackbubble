125_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The 3-Partition problem asks whether a set of $3n$ integers can be partitioned into $n$ sets of three integers such that each set sums up to some given integer $B$. The Balanced Partition problem asks whether $2n$ integers can be partitioned into two equal cardinality sets such that both sets have the same sum. Both problems are known to be NP-complete. However, 3-Partition is strongly NP-complete. I haven't seen in the literature any reduction from 3-Partition to Balanced Partition.</p>\n\n<p>I'm looking for (simple) reduction from the 3-Partition to the Balanced Partition problem.</p>\n", 'ViewCount': '661', 'Title': 'Reduction from 3-Partition problem to Balanced Partition problem', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-15T08:51:52.980', 'LastEditDate': '2012-03-31T06:46:55.977', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><reductions><np-complete>', 'CreationDate': '2012-03-25T23:50:10.927', 'FavoriteCount': '2', 'Id': '783'},125_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '603', 'Title': 'Reducing directed hamiltonian cycle to graph coloring', 'LastEditDate': '2012-03-31T06:51:22.663', 'AnswerCount': '1', 'Score': '5', 'OwnerDisplayName': 'Johan Sannemo', 'PostTypeId': '1', 'OwnerUserId': '1276', 'FavoriteCount': '1', 'Body': '<p>The 3-SAT problem can be reduced to both the graph coloring and the directed hamiltonian cycle problem, but is there any chain of reductions which reduce directed hamiltonian cycle to graph coloring in polynomial time?</p>\n', 'Tags': '<complexity-theory><np-complete><reductions>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-31T06:51:22.663', 'CommentCount': '9', 'AcceptedAnswerId': '886', 'CreationDate': '2012-03-26T21:01:13.650', 'Id': '864'},125_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Two things (this may be naive):</p>\n\n<ol>\n<li><p>Does anyone believe there is a sub-exponential time algorithm for the <a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">Subset-sum problem</a>? It seems obvious to me that you would have to look through all possible subsets to prove (the negation of) an existential statement. It seems obvious in the same way that if somebody asked you "Is $x$ in this list of $n$ numbers?", it\'s obvious that you would have to look through all $n$ numbers.</p></li>\n<li><p>If Subset-sum can be polynomial time reduced to <a href="http://en.wikipedia.org/wiki/K-SAT#3-satisfiability" rel="nofollow">3SAT</a> and we agree on (1), then doesn\'t that mean $NP \\neq P$?</p></li>\n</ol>\n', 'ViewCount': '503', 'Title': 'Subset-sum and 3SAT', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-08T16:41:26.820', 'LastEditDate': '2012-04-08T06:35:06.860', 'AnswerCount': '3', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '959', 'Tags': '<complexity-theory><time-complexity><np-complete><reductions>', 'CreationDate': '2012-04-07T21:28:36.573', 'Id': '1118'},125_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let me start off by noting <strong>this is a homework problem, please provide only advice and related observations, NO DIRECT ANSWERS please</strong>.  With that said, here is the problem I am looking at:</p>\n\n<blockquote>\n  <p>Let HALF-CLIQUE = { $\\langle G \\rangle$ | $G$ is an undirected graph having a complete\n  subgraph with at least $n/2$ nodes, where n is the number of nodes in $G$\n  }. Show that HALF-CLIQUE is NP-complete.</p>\n</blockquote>\n\n<p>Also, I know the following:</p>\n\n<ul>\n<li>In terms of this problem a <em>clique</em>, is defined as an undirected subgraph of the input graph, wherein every two nodes are connected by an edge.  A <em>$k$-clique</em> is a clique that contains $k$ nodes.</li>\n<li>According to our textbook, Michael Sipser\'s "<em>Introduction to the Theory of Computation</em>", pg 268, that the problem CLIQUE = {$\\langle G,k\\rangle$ | $G$ is an undirected graph with a $k$-clique} is in NP</li>\n<li>Furthermore, according to the same source (on pg 283) notes that CLIQUE is in NP-Complpete (thus also obviously in NP).</li>\n</ul>\n\n<p>I think I have the kernel of an answer here, however I could use <em>some indication of what is wrong with it or any related points that might be relevant to an answer</em>.  This is the general idea I have so far,</p>\n\n<blockquote>\n  <p>Ok, I\'d first note that a certificate would simply be a HALF-QLIQUE of $\\text{size} \\geq n/2$.  Now it appears that what I would need to do is to create a verifier that is a polynomial time reduction from CLIQUE (which we know is NP-Complete) to HALF-CLIQUE.  My idea would be that this would be done by creating a Turing machine which runs the turing machine verifier in the book for CLIQUE with the additional constraint for HALF-CLIQUE.</p>\n</blockquote>\n\n<p>This sounds correct to me, but I don\'t really trust myself yet in this subject. Once again, I would like to remind everyone <strong>this is a HOMEWORK PROBLEM</strong> so please try to avoid answering the question.  Any guidance which falls short of this would be most welcome!   </p>\n', 'ViewCount': '1464', 'Title': 'HALF CLIQUE - NP Complete Problem', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-10T03:18:31.263', 'LastEditDate': '2012-04-10T03:18:31.263', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '1184', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-04-09T20:30:50.973', 'Id': '1176'},125_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am taking a complexity course and I am having trouble with coming up with reductions between NPC problems. How can I find reductions between problems? Is there a general trick that I can use? How should I approach a problem that asks me to prove a problem is NPC?</p>\n', 'ViewCount': '417', 'Title': 'Finding reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T16:05:26.590', 'LastEditDate': '2012-04-22T16:05:26.590', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '1068', 'Tags': '<complexity-theory><np-complete><proof-techniques><reductions>', 'CreationDate': '2012-04-13T01:29:02.757', 'FavoriteCount': '8', 'Id': '1240'},125_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>We know that $st\\text{-}non\\text{-}connectivity$ is in <a href="http://en.wikipedia.org/wiki/NL_%28complexity%29" rel="nofollow">$\\mathsf{NL}$</a> by <a href="https://en.wikipedia.org/wiki/Immerman%E2%80%93Szelepcs%C3%A9nyi_theorem" rel="nofollow">Immerman\u2013Szelepcs\xe9nyi theorem</a> theorem and since $st\\text{-}connectivity$ is $\\mathsf{NL\\text{-}hard}$ therefore $st\\text{-}non\\text{-}connectivity$ is many-one log-space reducible to $st\\text{-}connectivity$. But is there a direct/combinatorial reduction that doesn\'t go through the configuration graph of the Turing machines in $\\mathsf{NL}$?</p>\n\n<blockquote>\n  <p><a href="http://en.wikipedia.org/wiki/St-connectivity" rel="nofollow">$\\mathsf{stConnectivity}$</a> (a.k.a. $stPATH$):</p>\n  \n  <p>Given directed graph $G$ and vertices $s$ and $t$,</p>\n  \n  <p>Is there a directed path from vertex $s$ to vertex $t$? </p>\n</blockquote>\n\n<hr>\n\n<h3>Clarifications:</h3>\n\n<p>You can assume a graph is given by its adjacency matrix (however this is not essential since standard representations of graphs are log-space convertible to each other.)</p>\n\n<p>It is possible to unpack the proof of $\\mathsf{NL\\text{-}hard}$ness of $st\\text{-}connectivity$ and move it into the proof so the proof does not use it that theorem as a lemma. However this is still the same construction essentially. What I am looking for is <em>not</em> this, I want a conceptually direct reduction. Let me give an analogy with the $\\mathsf{NP}$ case. We can reduce various $\\mathsf{NP\\text{-}complete}$ problems to each other by using the fact that they are in $\\mathsf{NP}$ therefore reduce to $SAT$ and $SAT$ reduces to the other problem. And we can unpack and combine these two reductions to get a direct reduction. However it is often possible to give a conceptually much simpler reduction that doesn\'t go through this intermediate step (you can remove mentioning it, but it is still there conceptually). For example, to reduce $HamPath$ or $VertexCover$ or $3\\text{-}Coloring$ to $SAT$ we don\'t say $HamPath$ is in $\\mathsf{NP}$ and therefore reduces to $SA$ since $SAT$ is $\\mathsf{NP\\text{-}hard}$. We can give a simple intuitive formula that is satisfiable iff the graph has a Hamiltonian path. \nAnother example, we have reductions from other problems in $\\mathsf{NL}$ to $st\\text{-}Connectivity$ which do not rely on $\\mathsf{NL\\text{-}complete}$ness of $st\\text{-}Connectivity$, e.g. $Cycle$, $StronglyConnected$, etc, they involve modification on the input graph (and do not refer to any Turing machines that is solving them). </p>\n\n<p>I still don\'t see any reason why this cannot be done for this one.\nI am looking for a reduction of this kind.</p>\n\n<p>It might be the case that this is not possible and any reduction would conceptually go through the $\\mathsf{NL\\text{-}hard}$ness result. However I don\'t see why that should be the case, why the situation would be different from the $\\mathsf{NP}$ case.\nObviously to give a negative answer to my question we would need to be more formal about when does a proof <em>conceptually</em> include another proof (which is proof theory question that AFAIK not settle in a satisfactory way). However note that for a positive answer one does not need such a formal definition and I am hoping that is the case. (I will think about how to formalize what I am asking in a faithful way when I find more free time. Essentially I want a reduction that would work even if we didn\'t know that the problem is complete for $\\mathsf{NL}$.)</p>\n\n<p>Using the proof of Immerman\u2013Szelepcs\xe9nyi theorem is fine, using $\\mathsf{NL\\text{-}complete}$ness of $stPATH$ and configuration graph of an $\\mathsf{NL}$ machine is what I want to avoid.</p>\n', 'ViewCount': '257', 'Title': 'Direct reduction from $st\\text{-}non\\text{-}connectivity$ to $st\\text{-}connectivity$', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-11T06:25:20.147', 'LastEditDate': '2012-10-09T18:13:36.133', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<complexity-theory><reductions><space-complexity>', 'CreationDate': '2012-04-25T20:28:48.090', 'FavoriteCount': '1', 'Id': '1509'},125_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m studying for my final in theory of computation, and I\'m struggling with the proper way of answering whether this statement is true of false.</p>\n\n<p>By the <a href="https://en.wikipedia.org/wiki/Mapping_reducibility" rel="nofollow">definition</a> of $\\leq_m$ we can construct the following statement, </p>\n\n<p>$w \\in A \\iff f(w) \\in B \\rightarrow w \\notin A \\iff f(w) \\notin B$ </p>\n\n<p>This is where I\'m stuck, I want to say that since we have such computable function $f$ then it\'ll only give us the mapping from A to B if there is one, otherwise it wont. </p>\n\n<p>I don\'t know how to phrase this correctly, or if I\'m even on the right track.</p>\n', 'ViewCount': '776', 'Title': 'If A is mapping reducible to B then the complement of A is mapping reducible to the complement of B', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T07:12:26.980', 'LastEditDate': '2012-05-23T07:12:26.980', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1520', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '196', 'Tags': '<complexity-theory><computability><reductions>', 'CreationDate': '2012-04-26T20:00:07.483', 'Id': '1517'},125_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to solve a problem for class that is stated like so:</p>\n\n<blockquote>\n  <p>A bipartite graph is an undirected graph in which every cycle has even\n  length.  We attempt to show that the Hamiltonian cycle (a cycle that\n  passes through each node exactly once) problem polynomially reduces to\n  the Hamiltonian cycle problem in bipartite graphs. We need a function\n  $T:  \\{\\text{graphs}\\} \\to \\{\\text{bipartite graphs}\\}$ such that $T$ can be computed in\n  polynomial time and for any graph $G$, $G$ has Hamiltonian cycle iff $T(G)$\n  has a Hamiltonian cycle. Let $T(G)$ be the bipartite graph obtained by\n  inserting a new vertex on every edge. What is wrong with this\n  transformation?</p>\n</blockquote>\n\n<p>I think the problem with the transformation is that for $T(G)$ you need to insert an edge between each pair of vertices and not just insert a new vertex on every edge. I'm actually a bit stumped by this one. Any advice would be much appreciated! </p>\n", 'ViewCount': '355', 'Title': 'Finding the flaw in a reduction from Hamiltonian cycle to Hamiltonian cycle on bipartitie graphs', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-27T22:10:39.560', 'LastEditDate': '2012-04-27T22:10:39.560', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'thomascirca', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-04-24T00:09:38.290', 'Id': '1527'},125_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '337', 'Title': 'Turing reducibility implies mapping reducibility', 'LastEditDate': '2012-04-30T01:11:53.080', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '196', 'FavoriteCount': '1', 'Body': '<p>The question is whether the following statement is true or false:</p>\n\n<p>$A \\leq_T B \\implies A \\leq_m B$</p>\n\n<p>I know that if $A \\leq_T B$ then there is an oracle which can decide A relative to B. I know that this is not enough to say that there is a computable function from A to B that can satisfy the reduction.</p>\n\n<p>I don\'t know how to word this in the proper way or if what I\'m saying is enough to say that the statement is false. How would I go about showing this?</p>\n\n<p>EDIT: This is not a homework problem per se, I\'m reviewing for a test.\nWhere $\\leq_T$ is <a href="http://en.wikipedia.org/wiki/Turing_reduction" rel="nofollow">Turing reducibility</a>, and $\\leq_m$ is <a href="http://en.wikipedia.org/wiki/Mapping_reduction" rel="nofollow">mapping reducibility</a>.</p>\n', 'Tags': '<computability><reductions><turing-machines>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-03T11:58:52.843', 'CommentCount': '0', 'AcceptedAnswerId': '1563', 'CreationDate': '2012-04-29T04:57:06.113', 'Id': '1562'},125_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a general question about mapping reductions. I have seen several examples of reducing functions to $A_{TM}$</p>\n\n<p>where $A_{TM} = \\{\\langle M, w \\rangle : \\text{ For } M \\text{ is a turing machine which accepts string } w\\}$</p>\n\n<p>which is great for proving undecidability. But say I want to prove unrecognizability instead. That is, I want to use the corollary that given $A \\le_{m} B$, if $A$ is unrecognizable then $B$ is unrecognizable.</p>\n\n<p>So for any arbitrary unrecognizable language $C$ which can be reduced to $\\overline{A_{TM}}$ (any example language would suffice for sake of example), how can I reduce $\\overline{A_{TM}} \\le_{m} C$?</p>\n\n<p>For simplicity, suffice to merely consider TM in $\\overline{A_{TM}}$.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>For clarification, $\\overline{A_{TM}} = \\{ \\langle M, w \\rangle : M \\text{ is a turing machine which does not accept string } w \\}$</p>\n', 'ViewCount': '381', 'Title': 'Mapping Reductions to Complement of A$_{TM}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T13:12:53.150', 'LastEditDate': '2012-05-09T13:12:53.150', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1604', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1057', 'Tags': '<computability><proof-techniques><reductions>', 'CreationDate': '2012-05-01T00:13:40.497', 'Id': '1603'},125_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Since Integer Linear Programming is NP-complete, there is a Karp reduction from any problem in NP to it. I thought this implied that there is always a polynomial-sized ILP formulation for any problem in NP.</p>\n\n<p>But I\'ve seen papers on specific NP problems where people write things like "this is the first poly-sized formulation" or "there is no known poly-sized formulation". That\'s why I\'m puzzled.</p>\n', 'ViewCount': '246', 'Title': 'Does every NP problem have a poly-sized ILP formulation?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-11-18T22:33:09.293', 'LastEditDate': '2012-05-18T16:13:07.690', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '1504', 'Tags': '<complexity-theory><np-complete><reductions><linear-programming>', 'CreationDate': '2012-05-15T19:21:47.390', 'FavoriteCount': '1', 'Id': '1860'},125_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We know that the $polyL$-hierarchy doesn't have complete problems, as it would conflict with the space hierarchy theorem. But: Are there complete problems for each level of this hierarchy?</p>\n\n<p>To be precise: Does the class $DSPACE(\\log(n)^k)$ have complete problems under $L$-reductions for each $k &gt; 0$?</p>\n", 'ViewCount': '162', 'Title': 'Complete Problems for $DSPACE(\\log(n)^k)$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T12:41:04.607', 'LastEditDate': '2012-05-26T12:54:24.433', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '2106', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '641', 'Tags': '<complexity-theory><reductions><space-complexity>', 'CreationDate': '2012-05-26T09:28:27.063', 'Id': '2088'},125_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1918', 'Title': 'Reducing minimum vertex cover in a bipartite graph to maximum flow', 'LastEditDate': '2012-11-09T11:07:26.610', 'AnswerCount': '2', 'Score': '7', 'OwnerDisplayName': 'Summer_More_More_Tea', 'PostTypeId': '1', 'OwnerUserId': '1727', 'FavoriteCount': '1', 'Body': '<p>Is it possible to show that the minimum vertex cover in a bipartite graph can be reduced to a maximum flow problem? Or to the minimum cut problem (then follow max-flow min-cut theorem, the claim holds).</p>\n\n<p>Intuitively: for each flow, pick one endpoint, then it is a minimum vertex cover in bipartite graph. But can it be shown rigorously?</p>\n', 'Tags': '<complexity-theory><graph-theory><reductions><network-flow>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-09T11:07:26.610', 'CommentCount': '0', 'CreationDate': '2012-06-03T02:37:49.540', 'Id': '2208'},125_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '286', 'Title': 'Are there complete problems for P and NP under other kinds of reductions?', 'LastEditDate': '2012-06-07T18:07:21.893', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1412', 'FavoriteCount': '1', 'Body': '<p>I know that the complexity class $\\mathsf{P}$ has complete problems w.r.t. $\\mathsf{NC}$ and $\\mathsf{L}$ reductions.</p>\n\n<p>Are these two classes the only possible classes of reductions under which $\\mathsf{P}$ has complete problems?  </p>\n\n<p>Also, what classes of reduction can be used for $\\mathsf{NP}$ beside polynomial-time reductions?</p>\n', 'Tags': '<complexity-theory><reductions>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-07T21:29:11.087', 'CommentCount': '5', 'AcceptedAnswerId': '2236', 'CreationDate': '2012-06-04T08:41:03.090', 'Id': '2222'},125_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am aware that for a problem to be considered NP-Hard, any problem in NP must be reduceable to your problem (problem which you are trying to prove is NP-Hard).</p>\n\n<p>Let's assume that you have proven that a problem <code>Y</code> is NP-Hard, and you have a problem <code>X</code> which you know is in NP, and you would like to solve.</p>\n\n<p>To solve <code>X</code>, which of the following reductions would be carried out?</p>\n\n<ol>\n<li>X -> Y</li>\n<li>Y -> X</li>\n</ol>\n\n<p>Which of the following? i.e. would you reduce <code>X</code> to <code>Y</code> or vice-versa, if you would like to solve <code>X</code> which is in NP, and <code>Y</code> which is NP-Hard?</p>\n", 'ViewCount': '222', 'Title': 'Solve a problem through reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-10T12:45:26.697', 'LastEditDate': '2012-06-10T11:29:36.043', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1814', 'Tags': '<algorithms><complexity-theory><reductions><np-hard>', 'CreationDate': '2012-06-10T08:06:59.850', 'Id': '2312'},125_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Equipartition Problem:</p>\n\n<p>Instance: $2n$ positive integers $x_1,\\dots,x_{2n}$ such that their sum is even. Let $B$ denote half their sum, so that $\\sum x_{i} = 2B$.</p>\n\n<p>Query: Is there a subset $I \\subseteq [2n]$ of size $|I| = n$ such that $\\sum_{i \\in I} x_{i} = B$?</p>\n\n<p>Can the <a href="http://en.wikipedia.org/wiki/Partition_problem" rel="nofollow">partition problem</a> - same as the above but without the restriction on $|I|$ -  be reduced to the above problem ?</p>\n', 'ViewCount': '375', 'Title': 'Reduction to equipartition problem from the partition problem?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-22T09:48:20.123', 'LastEditDate': '2012-06-12T18:36:52.223', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'OwnerDisplayName': 'Shalabh', 'PostTypeId': '1', 'OwnerUserId': '2882', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2012-03-23T16:58:13.290', 'Id': '2347'},125_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading "Efficient Cryptographic Schemes Provably as Secure as Subset Sum" by R. Impagliazzo and M. Naor (<a href="http://www.stevens.edu/algebraic/Files/SubsetSum/impagliazzo96efficient.pdf" rel="nofollow">paper</a>) and came across the following statement in the proof of Theorem 3.1 (pages 10-11):</p>\n\n<blockquote>\n  <p>Let $\\  l(n) = (1-c)n \\ $ for $ \\ c &gt; 0  \\ $ ...</p>\n  \n  <p>Given $a_1, a_2, \\cdots, a_n \\in \\{0,1\\}^{l(n)}$ and a target sum $T$, we construct an input to the collision finding algorithm as follows:</p>\n  \n  <ol>\n  <li><p>Let the collision finding algorithm select a (non-empty) $ s_1 \\in \\{0,1\\}^n $</p></li>\n  <li><p>compute $T\' = \\sum_{i \\in s_1} a_i$.  Choose a random $j$ such that $j \\in s_1$ and define $a_j\' = a_j - T\' + T$.</p></li>\n  <li><p>Give the instance $a_1, a_2, \\cdots , a_j\', \\cdots, a_n$ and $s_1$ to the algorithm that finds collisions.  The algorithm attempts to find $s_2$ such that $f_{(a_1, a_2, \\cdots, a_j\', \\cdots, a_n)}(s_2) = T\'$.</p></li>\n  </ol>\n  \n  <p>If the algorithm returns $s_2$ that collides with $s_1$ and $j \\notin s_2$, then <strong>$s_2$ is a solution to our original problem</strong>, since swapping $a_j$ and $a_j\'$ does not affect the sum over $s_2$.</p>\n</blockquote>\n\n<p>Where the emphasis is mine.</p>\n\n<p>Where $f$ concatenates $\\stackrel{\\rightarrow}{a}$ with the sum of the $a_i$\'s:</p>\n\n<p>$$ f( \\stackrel{\\rightarrow}{ a } , S) = f_{(a_1, a_2, \\cdots, a_n)}(S) = \\ \\stackrel{\\rightarrow}{a}, \\sum_{i \\in S} a_i \\mod 2^{l(n)} $$</p>\n\n<p>(taken from the top of page 3 from the same paper).</p>\n\n<p>For the life of me, I don\'t understand how $s_2$ is a solution to the original instance.  Can someone elaborate on what they mean?  What am I missing?</p>\n\n<p>The above definition for the subset sum problem is, if I\'m not mistaken, just another form of the <a href="http://garden.irmacs.sfu.ca/?q=op/theoretical_computer_science/subset_sums_equality" rel="nofollow">pigeonhole subset sum problem</a> (i.e. $\\sum_j a_j &lt; 2^n -1$ ).  If I read the above right, they are claiming that, given an oracle that finds collisions, they can then construct a solution to the original (pigeonhole) subset sum problem but I do not see how this is done.  Any help would be appreciated.</p>\n', 'ViewCount': '138', 'Title': 'Does a collision oracle for the pigeonhole subset sum problem produce solutions?', 'LastEditorUserId': '67', 'LastActivityDate': '2013-12-04T13:14:36.753', 'LastEditDate': '2012-06-21T22:17:31.350', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '67', 'Tags': '<complexity-theory><computability><np-complete><reductions>', 'CreationDate': '2012-06-21T20:44:25.477', 'Id': '2442'},125_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given an undirected graph, I define a structure called <em>k-key</em> as a path containing $k$ vertices which are connected to a simple cycle which contains $k$ vertices as well.</p>\n\n<p>Here's the <em>k-key problem</em>: given an undirected graph $G$ and a number $k$, decide whether $G$ contains k $k$-key.</p>\n\n<p>I want to show that the k-key problem is a NP-complete.</p>\n\n<p>I want to make a reduction from the 'Undirected Hamiltonian Cycle' problem in which the input is a graph, and the problem is to decide whether it contains a Hamiltonian path. I already know that this problem is NP-complete. The input for the reduction would be an undirected graph $G$ and the output is $G'$ graph and $k$. Can you please help me understand what manipulation I should do to the original graph in order to show this reduction? And why should it work?</p>\n", 'ViewCount': '129', 'Title': 'The $\\text{k-key}$ problem', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-22T09:50:38.897', 'LastEditDate': '2012-07-17T05:56:17.920', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2678', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2126', 'Tags': '<complexity-theory><np-complete><reductions><np-hard>', 'CreationDate': '2012-07-10T18:16:52.777', 'Id': '2676'},125_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '361', 'Title': 'Is Karp Reduction identical to Levin Reduction', 'LastEditDate': '2012-07-17T16:29:13.687', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2121', 'FavoriteCount': '2', 'Body': "<h3>Definition: Karp Reduction</h3>\n\n<p>A language $A$ is Karp reducible to a language $B$ if there is a polynomial-time computable function $f:\\{0,1\\}^*\\rightarrow\\{0,1\\}^*$ such that for every $x$, $x\\in A$ if and only if $f(x)\\in B$.</p>\n\n<h3>Definition: Levin Reduction</h3>\n\n<p>A search problem $V_A$ is Levin reducible to a search problem $V_B$ if there is polynomial time function $f$ that Karp reduces $L(V_A)$ to $L(V_B)$ and there are polynomial-time computable functions $g$ and $h$ such that</p>\n\n<ol>\n<li><p>$\\langle x, y \\rangle \\in V_A \\implies \\langle f(x), g(x,y) \\rangle \\in V_B$,</p></li>\n<li><p>$\\langle f(x), z \\rangle \\in V_B \\implies \\langle x, h(x,z) \\rangle \\in V_A$</p></li>\n</ol>\n\n<p>Are these reductions equivalent?</p>\n\n<hr>\n\n<p>I think the two definitions are equivalent. For any two $\\mathsf{NP}$ languages $A$ and $B$, if $A$ is Karp reducible to $B$, then $A$ is Levin reducible to $B$. </p>\n\n<p>Here is my proof:</p>\n\n<p>Let $x$ and $\\overline{x}$ be arbitrary instances of $A$ while $x'$ be that of $B$. \nSuppose $V_A$ and $V_B$ are verifiers of $A$ and $B$. \nLet $y$ and $\\overline{y}$ be arbitrary certificates of $x$ and $\\overline{x}$ according to $V_A$. \nLet $z$ be that of $x'$ according to $V_B$. </p>\n\n<p>Construct new verifiers $V'_A$ and $V'_B$ with new certificates $y'$ and $z'$:</p>\n\n<p>$V'_A(x,y'):$</p>\n\n<ol>\n<li>$y'=\\langle 0,\\overline{x},\\overline{y}\\rangle$: If $f(x)\\ne f(\\overline{x})$, reject. \nOtherwise output $V_A(\\overline{x},\\overline{y})$.</li>\n<li>$y'=\\langle 1,z\\rangle$: Output $V_B(f(x),z)$.</li>\n</ol>\n\n<p>$V'_B(x',z'):$</p>\n\n<ol>\n<li><p>$z'=\\langle 0,z\\rangle$: Output $V_B(x',z)$.</p></li>\n<li><p>$z'=\\langle 1,x,y\\rangle$: If $x'\\ne f(x)$, reject. \nOtherwise output $V_A(x,y)$.</p></li>\n</ol>\n\n<p>The polynomial-time computable functions $g$ and $h$ are defined as below:</p>\n\n<p>$g(x,y')$</p>\n\n<ol>\n<li><p>$y'=\\langle 0,\\overline{x},\\overline{y}\\rangle$: Output $\\langle 1,\\overline{x},\\overline{y}\\rangle$.</p></li>\n<li><p>$y'=\\langle 1,z\\rangle$: Output $\\langle 0,z\\rangle$.</p></li>\n</ol>\n\n<p>$h(x',z')$</p>\n\n<ol>\n<li><p>$z'=\\langle 0,z\\rangle$: Output $\\langle 1,z\\rangle$.</p></li>\n<li><p>$z'=\\langle 1,x,y\\rangle$: Output $\\langle 0,x,y\\rangle$.</p></li>\n</ol>\n\n<p>Let $Y_x$ be the set of all certificates of $x$ according to $V_A$ and $Z_{x'}$ be the set of all certificates of $x'$ according to $V_B$. \nThen the set of all certificates of $x$ according to $V'_A$ is $0\\overline{x}Y_\\overline{x}+1Z_{f(x)}$ such that $f(x)=f(\\overline{x})$, \nand the set of all certificates of $x'$ according to $V'_B$ is $0Z_{x'}+1\\overline{x}Y_\\overline{x}$ such that $x'=f(\\overline{x})$. </p>\n\n<p>(This is derived from the accepting language of $V'_A$ and $V'_B$.) </p>\n\n<p>Now let $x'=f(x)$, the rest part is easy to check.</p>\n", 'Tags': '<complexity-theory><reductions><check-my-proof>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-17T16:29:13.687', 'CommentCount': '1', 'AcceptedAnswerId': '2702', 'CreationDate': '2012-07-11T06:25:12.317', 'Id': '2689'},125_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '225', 'Title': 'Is SAT in P if there are exponentially many clauses in the number of variables?', 'LastEditDate': '2012-07-21T18:44:49.583', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'FavoriteCount': '1', 'Body': "<p>I define a <em>long CNF</em> to contain at least $2^\\frac{n}{2}$ clauses, where $n$ is the number of its variables. Let $\\text{Long-SAT}=\\{\\phi: \\phi$ is a satisfiable long CNF formula$\\}$. </p>\n\n<p>I'd like to know why $\\text{Long-SAT} \\in P$. First I thought it is $\\text{NPC}$ since I can do a polynomial-time reduction from $\\text{SAT}$ to $\\text{Long-SAT}$, no?</p>\n\n<p>But maybe I can reduce $\\text{2-SAT}$ to $\\text{Long-SAT}$? How do I do that?</p>\n", 'Tags': '<complexity-theory><np-complete><reductions><satisfiability><polynomial-time>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-21T19:06:47.027', 'CommentCount': '7', 'AcceptedAnswerId': '2705', 'CreationDate': '2012-07-12T08:19:40.860', 'Id': '2704'},125_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a TSP instance $T$, decide whether changing the city coordinates by adding a vector of coordinates $v$ will change the optimal TSP objective by atleast $x$. The city coordinates are integers.</p>\n\n<p>The problem is in PSPACE but even the verification problem seems to be NP-hard. Is that true?</p>\n\n<p>If the verification problem is NP-hard, what exact complexity class does this problem belong to?</p>\n', 'ViewCount': '192', 'Title': 'What complexity class does this variation of traveling salesman problem belong to?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:04:38.777', 'LastEditDate': '2013-06-06T15:04:38.777', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2160', 'Tags': '<complexity-theory><reductions><np-hard><decision-problem><traveling-salesman>', 'CreationDate': '2012-07-13T23:45:51.823', 'Id': '2737'},125_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '573', 'Title': 'A polynomial reduction from any NP-complete problem to bounded PCP', 'LastEditDate': '2012-07-22T09:53:07.957', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2188', 'FavoriteCount': '5', 'Body': '<p>Text books everywhere assume that the <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem"><em>Bounded</em> Post Correspondence Problem</a> is NP-complete (no more than $N$ indexes allowed with repetitions). However, nowhere is one shown a simple (as in, something that an undergrad can understand) polynomial time reduction from another NP-complete problem.</p>\n\n<p>However every reduction I can think of is exponential (by $N$ or by the size of the series) in run-time. Perhaps it can be shown that it is reducible to SAT?</p>\n', 'Tags': '<complexity-theory><np-complete><reductions>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-21T22:52:57.200', 'CommentCount': '0', 'AcceptedAnswerId': '2860', 'CreationDate': '2012-07-17T07:20:37.133', 'Id': '2783'},125_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the <a href="http://en.wikipedia.org/wiki/Maximum_satisfiability_problem" rel="nofollow">MAX-SAT problem</a> NP-hard? From the Wikipedia page:</p>\n\n<blockquote>\n  <p>The MAX-SAT problem is NP-hard, since its solution easily leads to the solution of the boolean satisfiability problem, which is NP-complete</p>\n</blockquote>\n\n<p>I see that a given SAT problem can be reduced to a MAX-SAT problem: just solve the MAX-SAT problem for the boolean formula to see if all clauses can be satisfied. If yes, the SAT problem has the answer "yes", otherwise "no".</p>\n\n<p><strong>Question 1:</strong> What confuses me is that we have an optimization problem here, and no decision problem. So, can also optimization problems be considered as NP-hard? It only needs to be shown that the (optimization) problem can be reduced in polynomial-time to the SAT problem (or another NP-hard problem)?</p>\n\n<p><strong>Question 2:</strong> To reduce the SAT problem to MAX-SAT, we have to find a function $f$, which is computable in polynomial time, and with $p \\text{ in } \\text{SAT} \\Leftrightarrow f(p) \\text{ in } \\text{MAX-SAT}$.</p>\n\n<p>This is the definition I know about reduction. But here, we clearly can not find such a function $f$ since MAX-SAT is not a decision problem. How can a reduction be shown here?</p>\n', 'ViewCount': '738', 'Title': 'Is MAX-SAT NP-hard?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-07-31T17:37:12.083', 'LastEditDate': '2012-07-31T17:37:12.083', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'John Threepwood', 'PostTypeId': '1', 'OwnerUserId': '2313', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2012-07-30T15:10:19.573', 'Id': '2956'},125_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove that </p>\n\n<p>$L_1=\\{\\langle M\\rangle \\mid M \\text{ is a Turing machine and visits } q_0 \\text{ at least twice on } \\varepsilon\\} \\notin R$.</p>\n\n<p>I'm not sure whether to reduce the halting problem to it or not. I tried to construct a new machine $M'$ for $(\\langle M \\rangle,w)$, such that $M'$ visits $q_0$ twice, iff $M$ halts on $w$. This is specific $q_0$ given to me, but I didn't come to any smart construction, which would yield the requested. Maybe it's easier to show that it's $RE$ and not $coRE$? It is obvious that it's in $RE$, and I need to show that $L_2^{c}$ is not in $RE$.</p>\n\n<p>What should I do?</p>\n", 'ViewCount': '134', 'Title': 'Showing that the set of TMs which visit the starting state twice on the empty input is undecidable', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-02T05:53:06.110', 'LastEditDate': '2012-08-01T15:00:46.580', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2984', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-08-01T12:41:06.703', 'Id': '2981'},125_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Assume we have an optimization problem with function $f$ to maximize.</p>\n\n<p>Then, the corresponding decision problem 'Does there exist a solution with $f\\ge k$ for a given $k$?' can easily be reduced to the optimization problem: calculate the optimal solution and check if it is $\\ge k$.</p>\n\n<p>Now, I was wondering, is it always possible to do the reduction (in polynomial time) the other way around?</p>\n\n<p>For an example consider MAX-SAT: to reduce the optimization problem to the decision problem we can do a binary search in the integer range from 0 to the number of clauses. At each stoppage $k$ we check, with the decision problem solver, if there is a solution with $\\ge k$.</p>\n", 'ViewCount': '514', 'Title': 'Optimization problem vs decision problem - reduction', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-01T17:03:21.837', 'LastEditDate': '2012-08-02T06:18:37.633', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2313', 'Tags': '<complexity-theory><optimization><reductions><decision-problem>', 'CreationDate': '2012-08-01T13:08:35.477', 'FavoriteCount': '1', 'Id': '2983'},125_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider a sequence of $n$ positive real numbers $a_0,\\ldots,a_{n-1}$. Let $S_n$ be the set of permutations on $\\{0,\\ldots,n-1\\}$. </p>\n\n<p>We are interested to find</p>\n\n<p>$$\n\\max_{\\pi\\in S_n}\\left( \\min_{i=0}^{n-1}\\left( \\frac{a_{\\pi(i)}}{a_{\\pi(i-1)}} + \\frac{a_{\\pi(i)}}{a_{\\pi(i+1)}}\\right)\\right)\n$$</p>\n\n<p>The addition and subtraction in $\\pi$ is under mod n.</p>\n\n<p>It might be easier to consider the more general problem, where $b_0,\\ldots,b_{n-1}$ is a sequence of positive real numbers.</p>\n\n<p>$$\n\\max_{\\pi\\in S_n}\\left( \\min_{i=0}^{n-1}\\left( a_{\\pi(i)}(b_{\\pi(i-1)}+b_{\\pi(i+1)} )\\right)\\right)\n$$</p>\n\n<p>Is this problem $NP$-hard? I feel this problem is $NP$-Hard but I don't see any obvious reductions.</p>\n\n<p>The greedy approach: sort the numbers, then insert them one by one into the list such that it maximizes the minimum of the sum of quotients. Turns out to be not optimal.</p>\n\n<pre><code>Greedy Smallest First\n[5, 4, 4] 1.8\n[5, 5, 4, 4] 1.8\n[5, 5, 5, 4, 4] 1.8\n[5, 9, 5, 5, 4, 4] 1.5555555555555556\nGreedy: [5, 9, 5, 5, 4, 4] 1.5555555555555556\nBest: [4, 5, 4, 5, 9, 5] 1.6\n\nGreedy Largest First\n[5, 22, 20] 0.4772727272727273\n[4, 5, 22, 20] 1\n[4, 4, 5, 22, 20] 1.2\n[4, 3, 4, 5, 22, 20] 1.4772727272727273\n\nGreedy: [4, 3, 4, 5, 22, 20] 1.4772727272727273\nBest: [3, 4, 5, 20, 22, 4] 1.5\n</code></pre>\n", 'ViewCount': '114', 'Title': 'Find a permutation that maximize the minimum of $\\frac{a_n}{a_{n-1}} + \\frac{a_n}{a_{n+1}}$', 'LastEditorUserId': '220', 'LastActivityDate': '2012-08-02T20:31:07.420', 'LastEditDate': '2012-08-02T20:31:07.420', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '220', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2012-08-02T17:47:23.803', 'FavoriteCount': '3', 'Id': '3007'},125_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>After looking at other questions and my textbook, I seem to get some confusion. </p>\n\n<p>I do get that when there is a polynomial algorithm of NPC, there is a polynomial algorithm for a NP problem. </p>\n\n<p>But the statement describing reduction seems obscure to me at least in the beginning of my studies in computational complexity. </p>\n\n<p>So, can we transform an exponential algorithm for NPC (which we have) into an exponential algorithm for another non-NPC NP problem in polynomial time? </p>\n', 'ViewCount': '103', 'Title': 'Can an exponential algorithm for an NPC problem be transformed into an algorithm for other NP problems in polynomial time?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-16T11:55:20.967', 'LastEditDate': '2012-08-16T09:30:50.490', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2540', 'Tags': '<complexity-theory><terminology><np-complete><reductions>', 'CreationDate': '2012-08-16T08:49:13.167', 'Id': '3216'},125_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m reading few proofs which prove a given problem is NP complete. The proof technique has following steps.</p>\n\n<ol>\n<li>Prove that current problem is NP, i.e., given a certificate, prove\nthat it can be verified in polynomial time.</li>\n<li>Take any known NP-complete problem (call "Easy") and reduce <strong>all</strong>\nof it\'s instances to <strong>few</strong> instances of given problem (call\n"Hard"). Note this is <strong>not</strong> necessarily an 1:1 mapping.</li>\n<li>Prove that above reduction can be done in polynomial time.</li>\n</ol>\n\n<p>All is well here. Is this knowledge right "if you can solve any NP-complete problem in polynomial time, then all NP-complete problems can be solved in polynomial time" ?</p>\n\n<p>If yes, then as per above proof technique, let\'s say "Easy" problem can be solved in polynomial time, how does that imply "hard" can be solved in polynomial time? What am I missing here? Or is this true, that "hard" problem can be reduced to the "easy" problem too?</p>\n', 'ViewCount': '391', 'Title': 'How are all NP Complete problems similar?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-16T23:07:03.297', 'LastEditDate': '2012-08-16T19:50:19.087', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '3232', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2375', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-08-16T18:21:21.570', 'Id': '3226'},125_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In <a href="http://rads.stackoverflow.com/amzn/click/0072970545" rel="nofollow">Cormen\'s Algorithms book</a> on NP-completeness they prove various problems are NP-complete by reducing a previously proved NP-complete problem (call $K$) to current problem (call $L$). Each proof involves some clever construction which reduces all instances of $K$ to few instances of $L$. Here is the proof order they follow. <strong>CIRCUIT-SAT, SAT, 3 CNF-SAT, CLIQUE, VERTEX-COVER, HAM-CYCLE, TSP</strong>. e.g. in reducing <strong>VERTEX-COVER</strong> to <strong>HAM-CYCLE</strong> they use a <strong>widget</strong> which does the trick.</p>\n\n<p>After this <a href="http://cs.stackexchange.com/questions/3226/how-are-all-np-complete-problems-similar">previous question of mine</a>, I think one can reduce back. i.e. one can reduce <strong>HAM-CYCLE</strong> to <strong>VERTEX-COVER</strong> problem. I tried searching web for such reductions, but most of the link return the normal reduction order. I\'m interested to see if one can reduce in <strong>reverse order</strong>. i.e. TSP to HAM-CYCLE to VERTEX-COVER to CLIQUE to 3 CNF-SAT to SAT</p>\n\n<p>I\'m looking for reverse constructive proofs. I know all of these problems belong to NP-complete hence equivalent. </p>\n\n<p>You don\'t have to give complete proof as an answer. Proof sketches are fine too. If you can point me where these proofs are available online, that\'s completely fine too. I\'m just trying to lean how constructions are leveraged among problems that look so different on surface. Thanks!</p>\n', 'ViewCount': '744', 'Title': 'Reducing TSP to HAM-CYCLE to VERTEX-COVER to CLIQUE to 3 CNF-SAT to SAT', 'LastEditorUserId': '2375', 'LastActivityDate': '2012-09-18T03:26:11.287', 'LastEditDate': '2012-08-17T22:28:01.183', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2375', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-08-17T14:19:49.773', 'Id': '3239'},125_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '468', 'Title': 'Types of reductions and associated definitions of hardness', 'LastEditDate': '2012-08-22T10:33:50.667', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2250', 'FavoriteCount': '3', 'Body': '<p>Let A be reducible to B, i.e., $A \\leq B$. Hence, the Turing machine accepting $A$ has access to an oracle for $B$. Let the Turing machine accepting $A$ be $M_{A}$ and the oracle for $B$ be $O_{B}$. The types of reductions:</p>\n\n<ul>\n<li><p>Turing reduction: $M_{A}$ can make multiple queries to $O_{B}$.</p></li>\n<li><p>Karp reduction: Also called "polynomial time Turing reduction": The input to $O_{B}$ must be constructed in polytime. Moreover, the number of queries to $O_{B}$ must be bounded by a polynomial. In this case: $P^{A} = P^{B}$.</p></li>\n<li><p>Many-one Turing reduction: $M_{A}$ can make only one query to $O_{B}$, during its the last step. Hence the oracle response cannot be modified. However, the time taken to constructed the input to $O_{B}$ need not be bounded by a polynomial.\nEquivalently: ($\\leq_{m}$ denoting many-one reduction)</p>\n\n<blockquote>\n  <p>$A \\leq_{m} B$ if $\\exists$ a computable function $f: \\Sigma^{\\ast} \\to \\Sigma^{\\ast}$ such that $f(x) \\in B \\iff x\\in A$.</p>\n</blockquote></li>\n<li><p>Cook reduction: Also called "polynomial time many-one reduction": A many-one reduction where the time taken to construct an input to $O_{B}$ must be bounded by a polynomial.\nEquivalently: ($\\leq^{p}_{m}$ denoting many-one reduction)</p>\n\n<blockquote>\n  <p>$A \\leq^p_{m} B$ if $\\exists$ a <em>poly-time</em> computable function $f: \\Sigma^{\\ast} \\to \\Sigma^{\\ast}$ such that $f(x) \\in B \\iff x\\in A$.</p>\n</blockquote></li>\n<li><p>Parsimonious reduction: Also called "polynomial time one-one reduction": A Cook reduction where every instance of $A$ mapped to a unique instance of $B$.\nEquivalently: ($\\leq^{p}_{1}$ denoting parsimonious reduction)</p>\n\n<blockquote>\n  <p>$A \\leq^p_{1} B$ if $\\exists$ a <em>poly-time</em> computable bijection $f: \\Sigma^{\\ast} \\to \\Sigma^{\\ast}$ such that $f(x) \\in B \\iff x\\in A$.</p>\n</blockquote>\n\n<p>These reductions preserve the number of solutions. Hence $\\#M_{A} = \\#O_{B}$.</p></li>\n</ul>\n\n<p>We can define more types of reductions by bounding the number of oracle queries, but leaving those out, could someone kindly tell me if I have gotten the nomenclature for the different types of reductions used, correctly.\nAre NP-complete problems defined with respect Cook reduction or parsimonious reduction? Can anyone kindly give an example of a problem that is NP-complete under Cook and not under parsimonious reduction.</p>\n\n<p>If I am not wrong, the class #P-Complete is defined with respect to Karp reductions.</p>\n', 'Tags': '<complexity-theory><np-complete><reductions><complexity-classes>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-19T20:30:35.610', 'CommentCount': '0', 'AcceptedAnswerId': '3290', 'CreationDate': '2012-08-22T05:45:07.493', 'Id': '3286'},125_30:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>An optimisation problem requires minimising some function $f(x)$, where $x$ is a\nvector of integers. What is the corresponding decision version of the problem?</p>\n', 'ViewCount': '31', 'Title': 'Produce decision version of the problem', 'LastEditorUserId': '472', 'LastActivityDate': '2012-08-22T20:13:03.270', 'LastEditDate': '2012-08-22T20:12:13.753', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '3294', 'Score': '1', 'OwnerDisplayName': 'Princeps Tairu', 'PostTypeId': '1', 'Tags': '<complexity-theory><optimization><reductions>', 'CreationDate': '2012-08-22T15:23:59.557', 'Id': '3293'},125_31:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The $\\text{NP-Complete}$ class of problems is defined w.r.t Karp Reductions, which are <strong>polytime many-one reductions</strong>. However, <em>they need not necessarily preserve the number of solutions</em>. A more restrictive type: <strong>polytime one-one reductions</strong> do indeed preserve the number of solutions.</p>\n\n<p>Suppose $f:\\Sigma^{\\ast}\\to \\mathbb{N}$ is a counting function in $\\text{#P}$ and the decision problem $f_{ &gt; 0}$ defined as: <strong>Is $f(x) &gt; 0$ ?</strong> is in $NP$.</p>\n\n<p>Now if $f_{&gt; 0}$ is in $\\text{NP-Complete}$, can we immediately tell that $f$ is in $\\text{#P-Complete}$ or, do we could only say so, if the reduction map (showing $\\text{NP-Completeness}$) was <strong>one-one</strong>.</p>\n', 'ViewCount': '148', 'Title': 'Hardness of counting solutions to NP-Complete problems, assuming a type of reduction', 'LastEditorUserId': '31', 'LastActivityDate': '2012-08-23T07:45:55.997', 'LastEditDate': '2012-08-23T07:45:55.997', 'AnswerCount': '0', 'CommentCount': '14', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2250', 'Tags': '<complexity-theory><reductions><complexity-classes>', 'CreationDate': '2012-08-22T23:09:57.760', 'FavoriteCount': '2', 'Id': '3295'},125_32:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Although the reduction from vertex cover problem to set cover problem is quite simple, I did not find anywhere the reduction in the opposite direction. From the similarity in the type of problems, I guess this reduction should be simple too. However, despite trying for some time, I could not develop this. So, any ideas how this reduction can be done?</p>\n', 'ViewCount': '902', 'Title': 'Reduction from set cover problem to vertex cover problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-30T15:54:51.960', 'LastEditDate': '2012-08-29T00:03:22.587', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2596', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-08-28T20:36:19.960', 'Id': '3354'},125_33:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For an assignment I have to program an application to schedule conversations. \nThere is an event where representatives of the elementary schools talks with the representatives of high schools. They will talk about the students that will be transferred to the highschool. There are approximately 200 elementary schools and 40 high schools that will be participating in this event. The schools already know which student is transferring to which high school. The conversations will only be between representatives of E and H from student that will be transferring to H.</p>\n\n<p>The rules are:</p>\n\n<ol>\n<li>The duration of each conversation is based on the amount of\nstudents per representatives.Each conversation last 5 minutes per student. If a group consist of 1 student, this conversation last 10 minutes.</li>\n<li>No timeclashes</li>\n<li>All the students of the same group will be scheduled together, so, a\nrepresentatives will only face the same representative once.</li>\n<li>Timespan is 13.00-19.00</li>\n<li>The waiting time of a representative is at most 20% of his time. A\nwaiting time is an empty timeslot between the 1st and last\nconversation.</li>\n<li>Schedules for 2 days</li>\n<li>Each representatives participate for 1 day.</li>\n</ol>\n\n<p>The problem is that I know that this is hard to solve, but I dont know if it's NP-hard. Right now I only know this problem is similar to a Job Shop Problem. What can I do to proof that my problem is NP-hard? I read that I need to reduce a known problem to my problem. But how do I do this? I have read different articles and books, but I still don't understand the steps to do it.</p>\n", 'ViewCount': '285', 'Title': 'How to reduce to an NP-hard problem?', 'LastEditorUserId': '2700', 'LastActivityDate': '2012-09-06T14:12:00.927', 'LastEditDate': '2012-09-06T14:12:00.927', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2700', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2012-09-05T15:53:58.833', 'FavoriteCount': '1', 'Id': '3439'},125_34:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am trying to understand this problem from <a href="https://docs.google.com/viewer?a=v&amp;q=cache%3azCRhhxjqT5cJ%3awww.cs.berkeley.edu/~vazirani/algorithms/chap8.pdf%20&amp;hl=en&amp;gl=us&amp;pid=bl&amp;srcid=ADGEEShy1bvJEehdocFNfXKJs7p_TSog4n_ktXYth1MI0n1aUBo_L5Wbd-gzn5OH3QMnAv8mHqNKXJ8t1CXv3rle7avzGFVFN7DliQEASoN2ikYTFglAz_PSPA9K1TW1nY9ybkd3w4OV&amp;sig=AHIEtbTJ6FYl_HzkdU7W-mDJO3BB27sKqw">Algorithms. by S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani, chapter8</a>, Pg281. Problem 8.19</p>\n\n<p>A <em>kite</em> is a graph on an even number of vertices, say $2n$, in which $n$ of the vertices form a clique\nand the remaining $n$ vertices are connected in a \u201ctail\u201d that consists of a path joined to one of the\nvertices of the clique. Given a graph $G$ and a goal $g$, the KITE problem asks for a subgraph which\nis a kite and which contains $2g$ nodes. Prove that KITE is NP-complete.</p>\n\n<p>Any pointers to start with this problem? I am completely lost with it.</p>\n', 'ViewCount': '675', 'Title': 'NP-complete proof from Dasgupta problem on Kite', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-12T10:58:38.283', 'LastEditDate': '2012-09-12T10:58:38.283', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3511', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2120', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-09-12T07:23:42.460', 'Id': '3509'},125_35:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is a Turing Machine that is allowed to read and write symbols from an infinite alphabet more powerful than a regular TM (that is the only difference, the machine still has a finite number of states)?</p>\n\n<p>Intuition tells me not, since you need an infinite number of states to differentiate each symbol. So I think some of the symbols or the transitions caused by the symbols (or some subsets of the transitions) have to be equivalent. So you can actually simulate such machine with a regular TM and a bounded subset of such symbols or transitions.</p>\n\n<p>How could I approach a formal proof of this?</p>\n', 'ViewCount': '414', 'Title': 'Infinite alphabet Turing Machine', 'LastActivityDate': '2012-09-28T13:35:38.480', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '3534', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1451', 'Tags': '<computability><turing-machines><reductions><simulation>', 'CreationDate': '2012-09-13T23:01:24.267', 'Id': '3533'},125_36:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it possible to reduce MaxUNSAT to <a href="http://en.wikipedia.org/wiki/Maximum_satisfiability_problem" rel="nofollow">MaxSAT</a> in a polynomial way ?</p>\n\n<p>When considering the MaxSAT problem, one often considers also the <code>MinUNSAT</code> problem, which is almost the same. And for a propositional formula <code>f</code> in <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form" rel="nofollow">CNF</a> it holds:</p>\n\n<pre><code>|f| = MaxSAT(f) + MinUNSAT(f)\n</code></pre>\n\n<p>where <code>|f|</code> is the number of clauses of f.</p>\n\n<p>When considering <code>MaxUNSAT</code> and the corresponding <code>MinSAT</code> problem, the same relationship holds:</p>\n\n<pre><code>|f| = MaxUNSAT(f) + MinSAT(f)\n</code></pre>\n\n<p>Now, I was wondering if there is also a relationship between those two pairs, e.g. to reduce <code>MaxSAT</code> to <code>MaxUNSAT</code> or <code>MinSAT</code> (or the other way round) ?</p>\n\n<p>Unfortunately, I could not figure out one by myself. And maybe there is none ?</p>\n\n<p><strong>Update 1:</strong> Inspired by Yuval Filmus\'s answer, I will give a reduction for my question.</p>\n\n<p><strong>Reduction from MaxUNSAT to its corresponding decision problem:</strong></p>\n\n<p>Let $\\phi = {C_1, ..., C_m}$ a set of clauses over the variables $x_1, ..., x_n$, then it holds:\n$$MaxUNSAT(\\phi) = BinarySearch(0, |\\phi|, MaxUNSAT(\\phi, k) )$$\nwith \n$$\nBinarySearch(start, end, CompareProcedure(k))\n:= \\\\\\text{Searches for the element $e$ between $start$ and $end$ with help of the $CompareProcedure(k)$, so that holds $CompareProcedure(e) = true$ and $CompareProcedures(e+1) = false$ }$$\nand\n$$MaxUNSAT(\\phi, k) := \\exists v\\in\\{0, 1\\}^n:\\sum_{i=1}^m 1 - I_v(C_i) \\geq k$$\nwhere $I_v$ is the interpretation of a propositional formula under assignment $v$.</p>\n\n<p><strong>Reduction from decision problem $MaxUNSAT(\\phi, k)$ to SAT:</strong></p>\n\n<p>One can reduce the devision problem $MaxUNSAT(\\phi, k)$ to the SAT problem by adding blocking variables to each clause and adding a cardinality constraint as propositional formula to limit the number of used clauses with help of the blocking variables.</p>\n\n<p>I can describe this in more detail, if needed.</p>\n\n<p><strong>Conculsion:</strong></p>\n\n<p>One can reduce the MaxUNSAT problem to the SAT problem and then solve the SAT problem with the MaxSAT problem. This is a reduction that works in polynomial time.</p>\n', 'ViewCount': '127', 'Title': 'How to reduce MaxUNSAT to MaxSAT?', 'LastEditorUserId': '2313', 'LastActivityDate': '2012-09-24T21:55:55.063', 'LastEditDate': '2012-09-24T21:55:55.063', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2313', 'Tags': '<complexity-theory><optimization><reductions><satisfiability>', 'CreationDate': '2012-09-20T08:42:23.210', 'Id': '4625'},125_37:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In question <a href="http://cs.stackexchange.com/questions/4625/how-to-reduce-maxunsat-to-maxsat">How to reduce MaxUNSAT to MaxSAT?</a> I was asking, how to reduce the MaxUNSAT problem to MaxSAT. With help of the given answer I could give a polynomial reduction : $MaxUNSAT \\leq decisionProblemMaxUNSAT \\leq SAT \\leq MaxSAT$.</p>\n\n<p><strong>Question:</strong> Is there a more direct reduction without much overhead from MaxUNSAT to MaxSAT (or to minUNSAT)?</p>\n\n<p>Because the two problems are very similiar, it seems there is a more direct reduction, but I could not figure out one.</p>\n\n<p>Something like $MaxUNSAT(\\phi) = MaxSAT(\\neg\\phi)$ (which does not work).</p>\n', 'ViewCount': '61', 'Title': 'How to reduce MaxUNSAT to MaxSAT in a (almost) direct way?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-03T21:41:01.693', 'LastEditDate': '2012-09-24T22:21:34.283', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2313', 'Tags': '<complexity-theory><optimization><reductions><satisfiability>', 'CreationDate': '2012-09-24T21:59:46.447', 'Id': '4724'},125_38:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '634', 'Title': 'Planarity conditions for Planar 1-in-3 SAT', 'LastEditDate': '2012-10-01T18:24:10.170', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '2', 'Body': '<p><strong>Planar 3SAT</strong> is NP-complete. A planar 3SAT instance is a 3SAT instance for which the graph built using the following rules is planar:</p>\n\n<ol>\n<li>add a vertex for every $x_i$ and $\\bar{x_i}$</li>\n<li>add a vertex for every clause $C_j$</li>\n<li>add an edge for every $(x_i,\\bar{x_i})$ pair</li>\n<li>add an edge from vertex $x_i$ (or $\\bar{x_i}$) to each vertex that represent a clause that contains it</li>\n<li>add edges between two consecutive variables  $(x_1,x_2),(x_2,x_3),...,(x_n,x_1)$</li>\n</ol>\n\n<p>In particular, rule 5 builds a "backbone" that splits the clauses in two distinct regions.</p>\n\n<p><strong><a href="http://en.wikipedia.org/wiki/One-in-three_3SAT">Planar 1-in-3 SAT</a></strong> is NP-complete, too.</p>\n\n<blockquote>\nBut for planar 1-in-3 SAT are the planarity conditions defined in the same way as in Planar 3SAT ? In particular, can we assume that there is a backbone that links the variables $(x_i,x_{i+1})$  ?\n</blockquote>\n', 'Tags': '<np-complete><reductions><satisfiability><3-sat>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-01T18:24:10.170', 'CommentCount': '0', 'AcceptedAnswerId': '4832', 'CreationDate': '2012-10-01T10:44:10.560', 'Id': '4826'},125_39:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'Hardness and directions of reductions', 'LastEditDate': '2012-10-01T21:07:30.707', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2826', 'FavoriteCount': '1', 'Body': "<p>Let us say we know that problem A is hard, then we reduce A to the unknown problem B to prove B is also hard.</p>\n\n<p>As an example: we know 3-coloring is hard. Then we reduce 3-coloring to 4-coloring. By conflating one of the colors in the 3-coloring you have a 4-coloring, ergo 4-coloring is hard.</p>\n\n<p>That's the how. But why is this a proof that 4-coloring is hard? Is it that you can use the solution to the 4-coloring problem to solve the 3-coloring problem? If so, how? If not, why is it a valid proof?</p>\n\n<p>Bonus q: Must the polynomial reductions be able to go in both ways?</p>\n\n<p>Edit: if you would be able to explain why this is so by an example you would do the internet a favor. I couldn't find this explained in a concrete way anywhere.</p>\n", 'Tags': '<complexity-theory><np-complete><reductions>', 'LastEditorUserId': '2826', 'LastActivityDate': '2012-10-01T21:42:20.007', 'CommentCount': '2', 'AcceptedAnswerId': '4836', 'CreationDate': '2012-10-01T20:36:15.753', 'Id': '4835'},125_40:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>From <a href="http://en.wikipedia.org/wiki/Reduction_%28complexity%29" rel="nofollow">Wikipedia</a>:</p>\n\n<blockquote>\n  <p>Given two subsets A and B of N and a set of functions F from N to N\n  which is closed under composition, A is called reducible to B under F\n  if $$\n     \\exists f \\in F \\mbox{ . } \\forall x \\in \\mathbb{N} \\mbox{ . } x \\in A \\Leftrightarrow f(x) \\in B $$ We write $$\n     A \\leq_{F} B $$ Let S be a subset of P(N) and \u2264 a reduction, then S is called closed under \u2264 if $$\n     \\forall s \\in S \\mbox{ . } \\forall A \\in P(\\mathbb{N}) \\mbox{ . } A \\leq s \\Rightarrow A \\in S $$ A subset A of N is called hard for S\n  if $$\n     \\forall s \\in S \\mbox{ . } s \\leq A $$ A subset A of N is called complete for S if A is hard for S and A is in S.</p>\n</blockquote>\n\n<p>I am trying to relate the above definitions to those for problems: problem A can be reduced to problem B, a set of problems are NP-hard, a set of problems are NP-complete. But I don\'t know how to relate. I think one link I am missing is to see how a subset of problem can be seen as a subset of $\\mathbb{N}$?</p>\n', 'ViewCount': '266', 'Title': 'Understanding the definition of reduction', 'LastEditorUserId': '472', 'LastActivityDate': '2012-10-03T20:37:42.277', 'LastEditDate': '2012-10-03T20:37:42.277', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '4851', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '336', 'Tags': '<complexity-theory><terminology><reductions>', 'CreationDate': '2012-10-03T13:27:53.813', 'Id': '4850'},125_41:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As the title suggests. Also, such a language must satisfy that neither it nor its complement are semi-decidable. I already know that $All_{TM}, EQ_{TM}, T$ (that is the set of all deciders) satisfy this property. But I tried reducing these to their complements directly, and via some sort of intermediate language, but to no avail. Can anyone help?</p>\n', 'ViewCount': '503', 'Title': 'Find an undecidable language that is mapping-reducible to its complement', 'LastActivityDate': '2012-11-17T21:30:14.087', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<computability><reductions>', 'CreationDate': '2012-10-16T04:13:05.393', 'Id': '6100'},125_42:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2996', 'Title': 'How can I reduce Subset Sum to Partition?', 'LastEditDate': '2012-10-16T18:57:03.110', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '3048', 'FavoriteCount': '4', 'Body': '<p>Maybe this is quite simple but I have some trouble to get this reduction. I want to reduce <a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">Subset Sum</a> to  <a href="http://en.wikipedia.org/wiki/Partition_problem" rel="nofollow">Partition</a> but at this time I don\'t see the relation!</p>\n\n<p>Is it possible to reduce this problem using a Levin Reduction ?</p>\n\n<p>If you don\'t understand write for clarification!</p>\n', 'Tags': '<complexity-theory><np-complete><reductions>', 'LastEditorUserId': '3048', 'LastActivityDate': '2013-04-20T02:41:52.543', 'CommentCount': '0', 'AcceptedAnswerId': '6113', 'CreationDate': '2012-10-16T18:04:04.593', 'Id': '6111'},125_43:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>$L_1$ and $L_2$ are two languages defined on the alphabet $\\sum$.\n  $L_1$ is reducible to $L_2$ in polynomial time. Which of the following\n  cannot be true?</p>\n  \n  <ul>\n  <li>$L_1 \\in P$ and $L_2$ is finite</li>\n  <li>$L_1 \\in NP$ and $L_2 \\in P$</li>\n  <li>$L_1$ is undecidable and $L_2$ is decidable</li>\n  <li>$L_1$ is recursively enumerable and $L_2$ is recursive</li>\n  </ul>\n</blockquote>\n\n<p>My reasoning is as follow,</p>\n\n<p>If $A \\le_p B$, and $B \\in P$, then $A$ can be reduced to $B$ in polynomial time and solved in polynomial time making $A \\in P$. Thus I initially figured the 2nd choice as false and thus the right answer.</p>\n\n<p>However using the same argument on mapping reducibility, the 3rd choice seems to be false as well. The fourth choice is the same as the third one.</p>\n\n<p>I was unsuccessful in reasoning anything about the 1st choice.</p>\n\n<p>To put my above arguments in context, I am learning about theory of computation and have just about skimmed the surface of computability and complexity theory. Helo me out.</p>\n', 'ViewCount': '354', 'Title': 'Polynomial time reducibility', 'LastActivityDate': '2012-10-25T08:36:57.790', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '6307', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<complexity-theory><reductions><complexity-classes>', 'CreationDate': '2012-10-24T13:41:22.653', 'Id': '6291'},125_44:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '101', 'Title': 'Reduction of A_LBA to E_LBA', 'LastEditDate': '2012-11-06T20:48:13.643', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Kevin Stadler', 'PostTypeId': '1', 'OwnerUserId': '4479', 'Body': "<p>I have a rather interesting one to ponder and would love if I could get an answer for it. We were discussing the topic of mapping reduction today in my Computing theory course and I was wondering why this reduction can't exist, $A_{LBA} \\leq_{m} E_{LBA}$, since both of them are linear bound automata (LBAs). I do realize that $E_{LBA}$ is undecidable, $A_{LBA}$ is decidable, and the normal proof uses $A_{TM}$, or $E_{TM}$, to prove the undecidibility of $E_{LBA}$. I am just curious why the proof is using a TM to prove an LBA. But, my Professor could not come up with a solution to my confusion. I was wondering is this possible, if so, why or why not.</p>\n\n<p><strong>Definitions:</strong></p>\n\n<p>$A_{LBA} = \\{\\langle M, w\\rangle \\mid \\text{$M$ is a linear bound automaton that accepts the string $w$}\\}$</p>\n\n<p>$E_{LBA} = \\{\\langle M \\rangle \\mid \\text{$M$ is a linear bound automaton with $L(M)=\\emptyset$}\\}$</p>\n\n<p>$A_{TM}$ and $E_{TM}$ are the equivalent problems for Turing Machines.</p>\n", 'Tags': '<computability><turing-machines><reductions><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T20:48:13.643', 'CommentCount': '0', 'AcceptedAnswerId': '6516', 'CreationDate': '2012-11-06T05:19:27.213', 'Id': '6515'},125_45:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '244', 'Title': 'Reduce the following problem to SAT', 'LastEditDate': '2012-11-07T10:26:52.693', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1718', 'FavoriteCount': '3', 'Body': "<p>Here is the problem. Given $k, n, T_1, \\ldots, T_m$, where each $T_i \\subseteq \\{1, \\ldots, n\\}$. Is there a subset $S \\subseteq \\{1, \\ldots, n\\}$ with size at most $k$ such that $S \\cap T_i \\neq \\emptyset$ for all $i$? I am trying to reduce this problem to SAT. My idea of a solution would be to have a variable $x_i$ for each of 1 to $n$. For each $T_i$, create a clause $(x_{i_1} \\vee \\cdots \\vee x_{i_k})$ if $T_i = \\{i_1, \\ldots, i_k\\}$. Then and all these clauses together. But this clearly isn't a complete solution as it does not represent the constraint that $S$ must have at most $k$ elements. I know that I must create more variables, but I'm simply not sure how. So I have two questions:</p>\n\n<ol>\n<li>Is my idea of solution on the right track?</li>\n<li>How should the new variables be created so that they can be used to represent the cardinality $k$ constraint?</li>\n</ol>\n", 'Tags': '<complexity-theory><reductions><np-hard>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-07T16:44:49.113', 'CommentCount': '1', 'AcceptedAnswerId': '6522', 'CreationDate': '2012-11-07T02:59:38.507', 'Id': '6521'},125_46:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a book that proves the halting problem with this simple statement:</p>\n\n<p>$$\nA_\\text{TM} \\le_m  \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon\n$$</p>\n\n<p>It states that halting problem reduces to the language consisting of $\\langle M, \\omega \\rangle$ for which a Turing machine $M$ accepts $\\omega$ is undecidable.</p>\n\n<p>What does this mean? What does the notation $\\le_m$ indicate?</p>\n', 'ViewCount': '88', 'Title': 'Why does $A_\\text{TM} \\le_m \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon$?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-12T09:28:48.157', 'LastEditDate': '2012-11-07T20:47:20.573', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '7902', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-11-07T19:55:12.923', 'Id': '6541'},125_47:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '456', 'Title': 'Reducing the integer factorization problem to an NP-Complete problem', 'LastEditDate': '2013-12-19T14:18:14.570', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '12230', 'FavoriteCount': '2', 'Body': "<p>I'm struggling to understand the relationship between NP-Intermediate and NP-Complete. I know that if P != NP based on Lander's Theorem there exists a class of languages in NP but not in P or in NP-Complete. Every problem in NP can be reduced to an NP-Complete problem, however I haven't seen any examples for reducing a suspected NPI problem (such as integer factorization) into an NP-Complete problem. Does anyone know of any example of this or another NPI->NPC reduction?</p>\n", 'Tags': '<np-complete><reductions><factoring>', 'LastEditorUserId': '12230', 'LastActivityDate': '2013-12-19T14:18:14.570', 'CommentCount': '2', 'AcceptedAnswerId': '6605', 'CreationDate': '2012-11-10T00:38:55.120', 'Id': '6588'},125_48:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given that the <a href="http://en.wikipedia.org/wiki/Hamiltonian_path_problem" rel="nofollow">Hamiltonian cycle problem</a> is NP-complete, I want to prove that the following problem is NP-complete:</p>\n\n<blockquote>\n  <p>Given an undirected graph $G(V,E)$ and vertices $s,t\\in V$, does there\n  exist a path from $s$ to $t$ with at least $k$ edges such that all vertices\n  in the path are distinct?</p>\n</blockquote>\n\n<p>I thought of assigning a weight of $1$ to every edge and on similar grounds, but I am not able to compensate for the "at least $k$" edges part.</p>\n\n<p>It would be appreciated if somebody could help me with  the approach.</p>\n', 'ViewCount': '211', 'Title': 'Reduction to Hamiltonian cycle', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-18T23:50:01.033', 'LastEditDate': '2012-11-18T07:30:57.460', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4635', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2012-11-18T04:09:10.590', 'FavoriteCount': '1', 'Id': '6735'},125_49:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a set $A=\\{a_{1},a_{2},a_{3},\\ldots,a_{n}\\}$, then construct  a set $P=\\{p_{1}, p_{2}, p_{3}, \\ldots , p_{n}\\}$ such that</p>\n\n<ol>\n<li><p>$|p_{i}|=a_{i}$, and </p></li>\n<li><p>$\\sum_{i = 1,}^{n}p_{i} = 0$.</p></li>\n</ol>\n\n<p>This problem is NP-complete, which I want to prove.</p>\n\n<p>How do I do it? </p>\n\n<p>I am thinking of a reduction from the subset sum problem. But the problem is that because of the mod.</p>\n', 'ViewCount': '248', 'Title': 'Showing a partition-like problem is NP-complete', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T03:37:17.053', 'LastEditDate': '2012-11-22T03:37:17.053', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4635', 'Tags': '<np-complete><reductions><partitions>', 'CreationDate': '2012-11-19T06:31:23.380', 'Id': '6757'},125_50:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Subset-sum:</strong> Given a list of numbers, find if a non-empty sublist has sum 0 (there\'s a variation where we want sum=k instead of 0, but 0 is easier for analysis)</p>\n  \n  <p><strong>Partition:</strong> Given a list, can it be partitioned into two non-empty sublists with equal sum?</p>\n</blockquote>\n\n<p>I want to reduce subset-sum to partition. The reductions I found so far are same as <a href="http://cs.stackexchange.com/questions/6111/how-can-i-reduce-subset-sum-to-partition">this one</a> but it has following faults :</p>\n\n<ol>\n<li>For $B=0$, you can always partition $L\'$ into $\\{2S-0\\}$, $\\{S+0\\} U L$.</li>\n<li>It supposes $2S-B$ and $S+B$ have to go to different partitions! You could have both of them in same partition along with elements that sum to $-S$, hence total sum $= 2S$ as needed.</li>\n</ol>\n', 'ViewCount': '284', 'Title': 'reducing subset-sum to partition', 'LastEditorUserId': '4717', 'LastActivityDate': '2012-11-25T05:55:50.390', 'LastEditDate': '2012-11-24T20:21:14.430', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '6882', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4717', 'Tags': '<complexity-theory><np-complete><reductions><partitions>', 'CreationDate': '2012-11-24T20:06:48.693', 'Id': '6877'},125_51:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Optimization factoring:<br>\nInput: $N\\in \\mathbb{N}$<br>\nOutput: All prime factors of $N$</p>\n\n<p>Decision factoring:<br>\nInput: $N, k\\in \\mathbb{N}$<br>\nOutput: True iff $N$ has a prime factor of at most $k$</p>\n\n<p>How can I solve the optimization problem in polynomial time if the decision problem is polynomially solvable?</p>\n', 'ViewCount': '57', 'Title': 'Optimization-factoring $\\le_p$ Decision-factoring', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-26T01:10:28.467', 'LastEditDate': '2012-11-25T20:58:32.787', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '6900', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4730', 'Tags': '<optimization><reductions><factoring>', 'CreationDate': '2012-11-25T20:54:34.053', 'Id': '6897'},125_52:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '146', 'Title': 'NP-complete reductions', 'LastEditDate': '2012-11-26T11:49:55.377', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4735', 'FavoriteCount': '1', 'Body': '<p>I\'ve read that "Every problem in NP can be reduced to every NP-complete problem". </p>\n\n<p>My question is on the choice of the word "reduce". If I were to "reduce" a polynomial problem in NP to an exponential problem in NP, I just plain feel weird about using the word "reduce" because I feel like I\'ve increased the problem, not reduced it. So, why do we use the word reduce?</p>\n\n<p>Also, why do we write "reduce A to B" as $A\\le_{p} B$. It seems backwards.</p>\n', 'Tags': '<complexity-theory><terminology><np-complete><reductions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-05T22:56:51.973', 'CommentCount': '2', 'AcceptedAnswerId': '7200', 'CreationDate': '2012-11-26T08:29:17.163', 'Id': '6912'},125_53:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '444', 'Title': 'Graph 3-colorability is self-reducible', 'LastEditDate': '2012-11-30T19:23:12.183', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4799', 'FavoriteCount': '1', 'Body': '<p>I am interested in self-reducibility of Graph 3-Coloralibity problem.</p>\n\n<p><strong>Definition of Graph 3-Coloralibity problem.</strong></p>\n\n<p>Given an undirected graph $G$ does there exists a way to color the nodes red, green, and blue so that no adjacent nodes have the same color?</p>\n\n<p><strong>Definition of self-reducibility.</strong></p>\n\n<p>A language $L$ is self-reducible if a oracle turing machine TM $T$ exists such that $L=L(T^L)$ and for any input $x$ of length $n$, $T^L(x)$ queries the oracle for words of length at most $n-1$.</p>\n\n<p>I would like to show in very strict and formal way that Graph 3-colorability is self-reducible.</p>\n\n<p>Proof of self-reducibility of SAT can be used as example (<a href="http://cseweb.ucsd.edu/~mihir/cse200/decision-search.pdf" rel="nofollow">self-reducibility of SAT</a>).</p>\n\n<p>In my opinion, the general idea of proof of self-reducibility of Graph 3-colorability is different from proof of SAT self-reducibility in few aspects.</p>\n\n<ul>\n<li>SAT has two choices for every literal (true or false) and Graph 3-colorability has three choices (namely, red green blue).</li>\n<li>Choices of SAT literal are independent on each other and choices of colors of Graph 3 colorability are strictly dependent, any adjacent node must have different color, this property potentially could help to make less iteration among all colors.</li>\n</ul>\n\n<p><strong>The general idea of proof</strong>.</p>\n\n<p>Let\'s denote by $c_{v_i}$  the color of the vertex $v_i$, which can take one of the following values (red,green,blue). Define graph $G\'$ from a given graph $G$ by coloring the arbitrary vertex $v_0$, assign $c_{v_0}$ to \'red\' and put the graph $G\'$ with colored vertex $v_0$ to the input of the oracle. If oracle answers 1, which means that the modified graph is still 3-colorable, save the current assignments and start new iteration, with the different vertex $v_1$ chosen arbitrarily, color vertex $v_1$ according to the colors of the adjacent vertices.\nif oracle answers 0, which means the previous assignment has broken 3 colorability, pick different color from the set of three colors, but still according to colors of adjacent vertices.</p>\n\n<p>The previous proof is not mathematical robust, the question is how to improve it and to make it more formal and mathematical strict. It looks like I need more carefully distinguish the cases when new vertex doesn\'t have any edges with already colored vertices and when the new vertex is adjacent to already colored vertices. </p>\n\n<p>In addition I would like to prove that Graph 3-colorability is downward self-reducible.</p>\n\n<p><strong>Definition of downward self-reducible language.</strong></p>\n\n<p>The language $A$ is said to be downward self-reducible if it is possible to determine in polynomial time if $x \\in A$ using the results of shortest queries. </p>\n\n<p>The idea seems to be simple and intuitive: start with coloring an arbitrary vertex, and on each iteration add one more colored vertex and check by oracle if graph is still 3-colorable, if not reverse previous coloring and check another color.</p>\n\n<p>But how to write the proof in a strict way and more important  how to find an appropriate encoding of a graph.</p>\n\n<p>In short, I would like to show that Graph 3-colorability is self-reducible and downward self-reducible in strict and formal way.</p>\n\n<p>I will appreciate sharing your thoughts with us.</p>\n\n<p><strong>Update:</strong></p>\n\n<p><strong>downward self-reducibility</strong></p>\n\n<p>Downward self-reducibility is applied to decision problem and it\'s oracle answers the same decision problem with shorter input, at the end of the process of downward self-reduction we should have the right color assignments.</p>\n\n<p>Every 3 - colorable graph $G$ with more than three vertices, has two vertices $x,y$ with the same color. Apparently, there is only three colors and more than three vertices so some number of non-adjacent vertices might have the same color. If we merge $x$ and $y$ with the same color as the result we still have 3 - colorable graph, just because, if graph is 3 - colorable, then there are exist right assignment of all vertices that are adjacent to $x$ and $y$ according to the same color of $x, y$, so by merging $x, y$ we don\'t need to change any color of any vertices, we only need to add more edges between already correctly colored vertices (I know it\'s not the best explanation, I will appreciate if someone could explain it better). On every iteration we take two non-adjacent vertices $x,y$ of graph $G$, merge $x$ and $y$ and get graph $G\'$ which is our shorter input to the oracle. Oracle answers if it\'s 3-colorable or not. Now the problem is before setting $G\'$ on the input of oracle I should color the merged vertex and test colorability of $G\'$, if it\'s not 3-colorable change the color, but how to implement it correctly, I need right encoding for it.</p>\n\n<p><strong>self-reducibility</strong></p>\n\n<p>First, we should check if a given graph $G$ is 3-colorable at all, so set it on input of oracle, and oracle will answer if it\'s 3 - colorable, if yes then start the process. Any two nonadjacent vertices can have the same color in 3-colorable graph. The process of self-reducibility we should run in iterations, I think we can start from small subgraph $G\'$ of a given graph $G$ and on every iteration add one more vertices from $G$ to $G\'$. In paralel, we should maintain the assignment of already colored vertices. Unfortunately, I still don\'t get the idea completely. Would appreciate for help and hints. </p>\n', 'Tags': '<complexity-theory><reductions>', 'LastEditorUserId': '4799', 'LastActivityDate': '2012-11-30T19:23:12.183', 'CommentCount': '5', 'AcceptedAnswerId': '7016', 'CreationDate': '2012-11-29T11:10:30.967', 'Id': '7013'},125_54:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Unfortunately I have no idea how to show this:</p>\n\n<blockquote>\n  <p>Show that the set of ${\\sf P}$-complete languages is not closed under intersection.</p>\n</blockquote>\n\n<p>As far as I understand my lecture notes, ${\\sf P}$-completeness is defined as follows:</p>\n\n<ul>\n<li>$A \\subset \\Sigma^{*}$ is complete for ${\\sf P}$ iff $A \\in \\text{P}$ and $\\forall B \\in {\\sf P}, B \\le_L A$</li>\n<li>$\\le_L$ is ${\\sf LOGSPACE}$-reduction: for $A,B \\subset \\Sigma^{*}$, the relation $A \\le_{L} B$ is defined by\n$$A \\le_{L} B \\quad\\text{iff}\\quad \\exists f \\in {\\sf FLOGSPACE}, (x \\in A \\Leftrightarrow f(x) \\in B)$$</li>\n</ul>\n', 'ViewCount': '224', 'Title': 'Proof for P-complete is not closed under intersection', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-04T12:04:27.640', 'LastEditDate': '2012-11-29T20:54:49.207', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4713', 'Tags': '<complexity-theory><time-complexity><reductions>', 'CreationDate': '2012-11-29T12:48:39.203', 'Id': '7014'},125_55:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given an undirected Graph. I want to find a hamiltonian path with no restriction to starting or ending vertices. I know there are some smart algorithms for solving that.<br>\nNow let's make things interesting: sometimes, when I arrive at a vertex, the edges connected to that vertex change. I.e. some will be removed, others appear. It is only depending on the edge I used before which egdes will change.<br>\nThat means, if I go from vertex $v_1$ to $v_x$, edges connected to $v_x$ will change in the way $b_{1,x}$. if I arrived $v_x$ via $v_2$, edges will change in the way $b_{2,x}$ and so on.  </p>\n\n<p>I am looking for a efficient algorithm telling me if there is a hamiltonian path and output that if so. Has anybody ideas on how to approach that? Or has anyone an idea if this can be transformed into another better known problem?</p>\n", 'ViewCount': '133', 'Title': 'Hamiltonian path in dynamic graph', 'LastActivityDate': '2012-11-30T11:59:23.053', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4769', 'Tags': '<algorithms><graph-theory><reductions>', 'CreationDate': '2012-11-30T11:59:23.053', 'Id': '7046'},125_56:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>To show that a NP problem is NP-complete, we also have to show that $L \\leq_{p} L'$  , where $L$ is proven NP-complete and you have to prove $L'$ also is. The thing I am confused is how in all NP-complete problems in CLRS they just state the reduction algorithm for $L$ to convert to $L'$ is polynomial. How can one prove it's polynomial time, provided an example such a clique or ham cycle kind of problem?</p>\n", 'ViewCount': '110', 'Title': 'How to determine the polynomial runtime of an NP reduction?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-01T14:06:20.573', 'LastEditDate': '2012-12-01T14:06:20.573', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7069', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<complexity-theory><np-complete><reductions><proof-techniques>', 'CreationDate': '2012-12-01T05:03:35.287', 'Id': '7068'},125_57:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am interesting in proving that there is no search problem that is polynomial bounded and  self-reducible, as long as ${\\sf P} \\neq  {\\sf NP} \\cap {\\sf coNP}$.</p>\n\n<p>The problem is I don't know how to approach the proof, below I wrote few ideas with open questions.</p>\n\n<p>We can start by denoting the search problem in set ${\\sf NP} \\cap {\\sf coNP}$ in terms of search problem relations $R_1$ and $R_2$ such that $S = \\left \\{ x:R_1(x) \\neq \\emptyset \\right \\}  = \\left \\{ x:R_2(x) = \\emptyset \\right \\} $. But how to present that the decision problem $S$ is not in ${\\sf P}$. I don't know (but it seems to be crucial to show that $S$ is not in ${\\sf P}$). </p>\n\n<p>Having defined $S$ the next step would be to show that there is a relation $R$ that is self-reducible to $S$, but is not polynomial bounded.</p>\n\n<p>In short, the question is how to define relation $R$ that is self-reducible to $S$. How to prove that $R$ is not polynomial bounded. Actually proving that $R$ is polynomial bounded may be redundant because $S$ is in ${\\sf NP} \\cap {\\sf coNP}$ and it's given that ${\\sf NP} \\cap {\\sf coNP} \\neq {\\sf P} $.</p>\n\n<p><strong>Addendum:</strong> I was given a hint</p>\n\n<p>$R = \\left \\{ (x,1y):(x,y) \\in R_1 \\right \\} \\cup \\left \\{ (x,0y):(x,y) \\in R_2 \\right \\}$</p>\n\n<p>If I will be able to show that search problem relation R is self-reducible to S, than I think the problem is solved.</p>\n", 'ViewCount': '94', 'Title': 'Not self-reducible NP problem', 'LastActivityDate': '2012-12-01T07:19:31.027', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4778', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2012-12-01T07:19:31.027', 'Id': '7072'},125_58:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to reduce NOT-ALL-EQUAL SAT to MAX-CUT with weighted edges. </p>\n\n<p>I know that if there are weights to the edges, then I can reduce NOT-ALL-EQUAL SAT to MAX CUT by have a $G$ with $2n$ nodes ($x_i$ and $\\bar{x}_i$) and edges between the nodes based on each clause. And, adding edges between $x_i$ and $\\bar{x}_i$, so on.\nBut, I am not sure how to assign weights if I have to reduce a NOT-ALL-EQUAL SAT to weighted MAX CUT. </p>\n\n<p>How should I go about this problem? </p>\n', 'ViewCount': '272', 'Title': 'NAE SAT reduction to weighted MAX CUT', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-03T18:13:55.633', 'LastEditDate': '2012-12-02T11:40:23.967', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Pavanred', 'PostTypeId': '1', 'OwnerUserId': '4831', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2012-12-01T22:19:24.880', 'Id': '7097'},125_59:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Provided that we have to compare it against the graph coloring problem which is NPC. So far,\nI can only think of connecting edges from a vertex in a provided graph to all the other edges it is not connected to then I separate the new graph g2, then I connect all the vertices that are not connected in the g2. And then I count the number of subsets. However it doesnt seem to work with a graph that requires four colors? </p>\n', 'ViewCount': '417', 'Title': 'Proving that the clique cover problem is in NPC by reducing from k-coloring', 'LastEditorUserId': '2826', 'LastActivityDate': '2013-01-08T12:48:32.413', 'LastEditDate': '2012-12-06T19:48:46.213', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<graph-theory><np-complete><reductions>', 'CreationDate': '2012-12-04T13:05:33.323', 'FavoriteCount': '2', 'Id': '7155'},125_60:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m reviewing for a computability test, and my professor has not provided solutions to his practice questions. I came up with a "solution" to this problem, but it really seems like my answer is wrong (since I call upon $\\mathsf{Halt}$ twice)...</p>\n\n<p>We are given this initial language for some machine $M$:</p>\n\n<p>$\\mathsf{2Strings} = \\left\\{ \\left&lt;M\\right&gt;\\ |\\ L(M)\\text{ contains at least 2 distinct strings }\\land M\\text{ is a }TM \\right\\}$</p>\n\n<p>And we are told to "<em>[s]how that [the language] is recursive-enumerable.</em>" The problem title is <strong>Reduction</strong>, so I assume we are supposed to use that.</p>\n\n<p>My solution is as follows:</p>\n\n<ol>\n<li>Pass $\\left&lt;M\\right&gt;$ to the following reduction:</li>\n<li>Create $w_1 \\in L(M), w_2 \\in L(M)$, so that $w_1 \\not= w_2$, and let $M\' = M$.</li>\n<li>Pass $\\left&lt;M\', w_1\\right&gt;$ to $\\mathsf{Halt}$. If the answer is <strong>Yes</strong>, proceed to step 4. Otherwise, return <strong>No</strong>.</li>\n<li>Pass $\\left&lt;M\', w_2\\right&gt;$ to $\\mathsf{Halt}$. If the answer is <strong>Yes</strong>, return <strong>Yes</strong>. Otherwise, return <strong>No</strong>.</li>\n</ol>\n\n<p>Basically, this is my logic: We pass each of two distinct strings from $L(M)$ to $\\mathsf{Halt}$ separately; if either one says <strong>No</strong>, our answer is <strong>No</strong>. If both say <strong>Yes</strong>, the answer is <strong>Yes</strong>.</p>\n\n<p>Is my answer valid? More importantly, is it correct? If not, what should I do to fix it?</p>\n', 'ViewCount': '163', 'Title': 'Reducing a problem to Halt', 'LastActivityDate': '2012-12-23T04:55:15.973', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7218', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2827', 'Tags': '<computability><reductions>', 'CreationDate': '2012-12-06T20:09:25.660', 'Id': '7215'},125_61:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m reviewing for finals and have a sample problem that I <strong>think</strong> I understand, but would like someone to bless my understanding or smack me and tell me why I\'m wrong.</p>\n\n<p>I\'m presented with a problem $\\Pi$  of unknown complexity class.  If I can transform $\\Pi$ to some problem $X$, where $X  \\in {\\sf P}$, what does that tell me about $\\Pi$?</p>\n\n<p>I think allows me to conclude that $\\Pi \\in {\\sf P}$, right? If I can reduce $\\Pi$ to another problem that\'s deterministically solvable in polynomial time, and the transformation itself can be done "easily" in polynomial time, then I can conclude that $\\Pi$ is deterministically solvable in polynomial time, and therefore that $\\Pi \\in {\\sf P}$ correct?</p>\n\n<p>Conversely, given the same input, transforming $X$ to $\\Pi$ in polynomial time allows me to conclude nothing meaningful, since nothing is known about  $\\Pi$ right?</p>\n', 'ViewCount': '110', 'Title': 'Implications of polynomial time reductions', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-16T19:03:45.837', 'LastEditDate': '2012-12-16T19:03:45.837', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7439', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5084', 'Tags': '<complexity-theory><reductions><complexity-classes><p-vs-np>', 'CreationDate': '2012-12-16T15:28:34.083', 'Id': '7438'},125_62:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Apparently, if ${\\sf P}={\\sf NP}$, all languages in ${\\sf P}$ except for $\\emptyset$ and $\\Sigma^*$ would be ${\\sf NP}$-complete.</p>\n\n<p>Why these two languages in particular? Can't we reduce any other language in ${\\sf P}$ to them by outputting them when accepting or not accepting?</p>\n", 'ViewCount': '485', 'Title': "If P = NP, why wouldn't $\\emptyset$ and $\\Sigma^*$ be NP-complete?", 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-17T13:35:57.770', 'LastEditDate': '2012-12-17T07:05:48.280', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<np-complete><reductions>', 'CreationDate': '2012-12-17T00:08:33.127', 'Id': '7453'},125_63:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I wonder if there is a simple example of sets $A$ and $B$ such that $A$ is Turing-reductible to $B$ but not many-to-one reductible to $B$.</p>\n', 'ViewCount': '155', 'Title': 'Is there a simple example of sets such that $A \\leq_T B$ but not $A \\leq_m B$?', 'LastActivityDate': '2013-01-07T04:55:17.633', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7803', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2069', 'Tags': '<turing-machines><reductions>', 'CreationDate': '2013-01-06T10:07:29.000', 'Id': '7801'},125_64:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $A$ be the language $\\{\\langle M\\rangle\\mid M\\text{ is a Turing machine that accepts only one string}\\}$</p>\n\n<p>According to my understanding, if a Turing machine is able to decide if another Turing machine will accept only one string, then the halting problem could also be solved. Therefore, $A$ is non-recursively enumerable in my understanding.\nIs it correct ? </p>\n', 'ViewCount': '123', 'Title': 'Language comprising of Turing machine encodings', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-10T08:58:45.577', 'LastEditDate': '2013-01-10T06:55:38.930', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-01-10T01:54:48.163', 'Id': '7858'},125_65:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider the following problem:  Given two graphs $G_1 = (V_1, E_1)$ and $G_2 = (V_2, E_2)$ and some non-negative integer $k \\in \\mathbb{N}$, is it possible to delete at most $k$ vertices from $G_1$ to obtain $G_1'$ such that $G_1' \\cong G_2$, i.e. the resulting graph is isomorphic to $G_2$.</p>\n\n<p>I have to show that this problem is NP-complete.</p>\n\n<p>Can somebody help me with this problem? It is school homework and I don't know how to solve it.</p>\n", 'ViewCount': '271', 'Title': 'How to prove this isomorphism-related graph problem is NP-complete?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-09T14:38:21.540', 'LastEditDate': '2014-01-09T14:38:21.540', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'Charlie', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-01-16T13:04:17.763', 'FavoriteCount': '1', 'Id': '8970'},125_66:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I try to figure out <strong>a redundant power of two-sided error randomized Karp - reduction.</strong></p>\n\n<p>It\'s well known fact and it is relatively hard to show that <a href="http://en.wikipedia.org/wiki/BPP_(complexity)" rel="nofollow">BPP</a> is reducible by a one-sided error randomized Karp-reduction to coRP (in case of promise problem).</p>\n\n<p>Without delving into details it make sense that the combination of the one - sided error probability of the reduction and the one-sided error probability of coRP leads to two-sided error probability of BPP. Of course the proof of that is not so intuitive.</p>\n\n<p>The question it is possible by two-sided error randomized Karp-reduction to reduce BPP to some constant set in P? In the light of the power of one - sided randomized Karp - reduction, it make sense that two-sided randomized Karp - reduction is strong enough to reduce BPP to constant set, but how to show it formally?</p>\n\n<p><strong>Addendum:</strong></p>\n\n<p><strong>BPP</strong> is the set of the problems that is solvable in polynomial time by two-sided error randomized algorithm, so as a result of two - sided error randomized algorithm we will get some output, them the problem in BPP can be reduced to problem P by two-sided error randomized Karp - reduction in sense that reduction is allowed to make error on both sides. Does it mean that two - sided error randomized reduction will justify the two-sided error that was made by the algorithm in solving the problem in BPP?</p>\n', 'ViewCount': '97', 'Title': 'The Power of Randomized Reduction', 'LastEditorUserId': '1379', 'LastActivityDate': '2013-10-05T07:50:18.583', 'LastEditDate': '2013-01-21T09:54:55.740', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<complexity-theory><reductions><randomized-algorithms>', 'CreationDate': '2013-01-19T09:56:05.707', 'Id': '9037'},125_67:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '157', 'Title': 'Building functionally complete boolean circuits out of trinary logic', 'LastEditDate': '2013-02-22T02:18:36.030', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '1', 'Body': '<p>There are some not-very-commonly considered forms of <a href="http://en.wikipedia.org/wiki/Three-valued_logic" rel="nofollow">trinary logic</a> using 3 truth values. Even entire (unusual/rare) <a href="http://en.wikipedia.org/wiki/Ternary_computer" rel="nofollow">ternary computers</a> have been built from it.</p>\n\n<blockquote>\n  <p>Is there some knowledge or reference of how to convert some trinary logic systems into functionally complete boolean circuits/logic?</p>\n</blockquote>\n\n<p>"Functionally complete" means all boolean functions can be computed. I am asking the more general question above in case the following more specific question does not have an answer. The motivation is more this specific following case. Consider the following "trinary truth table" for a single trinary operator.</p>\n\n<pre><code>   a b c\n\na  a c a\nb  c b b\nc  a b c\n</code></pre>\n\n<blockquote>\n  <p>Is it possible to somehow create functionally complete boolean circuits out of the single above trinary truth table operator? Or, maybe it can be definitively proven it\'s not possible?</p>\n</blockquote>\n\n<p>I am also looking for any reference to that or something similar. </p>\n', 'Tags': '<reference-request><logic><reductions><circuits>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-22T02:18:36.030', 'CommentCount': '4', 'AcceptedAnswerId': '9215', 'CreationDate': '2013-01-27T18:15:08.947', 'Id': '9211'},125_68:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '88', 'Title': 'Does reduction from an NP-complete problem to some problem $X$ imply that $X\\in NP$?', 'LastEditDate': '2013-02-06T14:52:09.737', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'user6697', 'PostTypeId': '1', 'OwnerUserId': '6697', 'Body': '<p>I am having problems resolving the following question:</p>\n\n<blockquote>\n  <p>Given some problem $X$. If there exists a polynomial time reduction from (for example) $\\mbox{SAT}$ to $X$, $(\\mbox{SAT} \\leq_{p} X)$ and since we know that $\\mbox{SAT}$ is $\\mbox{NP-complete}$, to show that $X$ is $\\mbox{NP-complete}$ is it necessary to show that $X\\in \\mbox{NP}$ via some third party algorithm?</p>\n</blockquote>\n\n<p>If yes, then why?</p>\n', 'Tags': '<complexity-theory><terminology><reductions><np>', 'LastEditorUserId': '683', 'LastActivityDate': '2013-02-06T14:52:09.737', 'CommentCount': '1', 'AcceptedAnswerId': '9520', 'CreationDate': '2013-02-05T12:34:42.987', 'Id': '9519'},125_69:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $\\mathcal{A}$ be a problem in $\\text{NP} \\cap \\text{co}$-$\\text{NP}$.</p>\n\n<p>Now assume we can reduce another problem $\\mathcal{B}$ to it using Cook reduction.</p>\n\n<p>What conclusions can we draw about $\\mathcal{B}$? Does this question even make sense?</p>\n\n<p>I'm asking because from what I understand Cook reductions differ from Karp reductions (for example, $\\text{NP}$ cannot be distinguished from $\\text{co}$-$\\text{NP}$).\nI'm pretty confused and can't seem to really understand the properties of Cook reductions. Any good reference about the topic would also be appreciated!</p>\n\n<p>I hope this question is not too basic, but I was not able to find anything about it. </p>\n", 'ViewCount': '156', 'Title': 'Problems that are Cook-reducible to a problem in NP $\\cap$ co-NP', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T08:30:35.880', 'LastEditDate': '2013-02-08T08:30:35.880', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9592', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '691', 'Tags': '<complexity-theory><reductions><np>', 'CreationDate': '2013-02-08T03:11:17.540', 'Id': '9586'},125_70:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've seen a reduction that's done by adding another vertex to the graph and creating a path through that vertex.</p>\n\n<p>Why do I need to add a vertex? Cant I just remove an edge? Lets say the graph with the HamCycle is G,s,t when removing the edge between s and t dont I get a path the goes through all the vertexes that's qualified as a Hamiltonian path?</p>\n", 'ViewCount': '169', 'Title': 'HamCycle to HamPath reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-11T12:21:48.907', 'LastEditDate': '2013-02-11T12:08:05.400', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9672', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6821', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-02-11T10:46:12.443', 'Id': '9669'},125_71:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having trouble understanding a mapping reduction and I would appreciate your help. Define</p>\n\n<p>$\\quad \\begin{align}\n  A_{TM} &amp;= \\{ \\langle M, w \\rangle \\mid M \\text{ Turing machine}, w \\in \\mathcal{L}(M)\\} \\\\\n  S_{TM} &amp;= \\{ \\langle M,w \\rangle \\mid M \\text{ Turing machine}, w \\in \\mathcal{L}(M) \\implies w^R \\in \\mathcal{L}(M)\\} \\\\\n\\end{align}$</p>\n\n<p>and consider the reduction of $A_{TM}$ to $S_{TM}$ as follows.</p>\n\n<p>Given $\\langle M, w \\rangle$ the following Turing machine $M'$ is defined:</p>\n\n<pre><code>M' on input x:  \n  if x = 01 then accept  \n  else run M on w and accept x if M accepts w\n</code></pre>\n\n<p>I don't understand the reduction entirely, this reduction is supposed to solve $S_{TM}$ using $A_{TM}$.  Why do I need to check if <code>x = 01</code>? There is no need to check anything about the reverse of $w$?  How is that covered by the reduction?</p>\n", 'ViewCount': '177', 'Title': 'Mapping reductions for dummies', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-27T06:29:53.117', 'LastEditDate': '2013-03-27T11:59:03.577', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6821', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-02-11T16:15:33.440', 'FavoriteCount': '1', 'Id': '9683'},125_72:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>There is a well known definition of <strong>parsimonious reduction</strong>.</p>\n\n<p>The standard definition of parsimonious reduction is very intuitive. It simply means that the two problem have the same number of solutions, when on input of one of them we applied function $f$.</p>\n\n<p>We say there is a parsimonious reduction from #A to #B if there is a polynomial time transformation $f$ such that for all $x$, $|\\{y,(x, y) \\in  A\\}| = |\\{z : (f(x), z) \\in B\\}|$.</p>\n\n<p>I am interested in definition of <strong>strongly parsimonious reduction</strong>.</p>\n\n<p>The only definition I found:</p>\n\n<p>"Strongly parsimonious reduction of $R\'$ to $R$ is a parsimonious reduction $g$ that is coupled with an efficiently computable 1-1 mapping of pairs $(g(x), y) \\in R$ to pairs $(x, h(x, y)) \\in  R\'$ (i.e., $h$ is efficiently computable and $h(x, \xb7)$ is a 1-1 mapping of $R(g(x))$\nto $R\'(x)$). For technical reasons, we also assume that $|g(x)| \u2265 |x|$ for every $x$."</p>\n\n<p>The problem is I simply don\'t understand what this definition means. I tried to separate it to smaller block, but so far with no success. According  to the definition there are two function $g(x)$ and $h(x,y)$ are they are applied simultaneously to two different problem $R$ and $R\'$. How the usages of two function can be explained. What is the difference between two reduction, parsimonious reduction  and strongly parsimonious reduction.</p>\n\n<p>I would appreciate any help in understanding the definition of strongly parsimonious reduction.</p>\n', 'ViewCount': '88', 'Title': 'Definition of Strongly Parsimonious Reduction', 'LastActivityDate': '2013-02-13T22:12:32.960', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9750', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-02-13T12:52:57.913', 'Id': '9744'},125_73:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I may have missed something in my classes - but with $A\\leq_{P}B$... Does this show that, if $A\\in \\textbf{NP-Complete}$, that $B\\in \\textbf{NP}$ or $B\\in \\textbf{NP-Complete}$?</p>\n\n<p>Or maybe I got things backwards. If $A$ is polynomial-time-reducable to $B$, and $B$ is $\\textbf{NP}$-complete, does that make $A$ $\\textbf{NP}$ or $\\textbf{NP}$-complete?</p>\n', 'ViewCount': '67', 'Title': 'What do time complexity reductions prove?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:17:52.437', 'LastEditDate': '2013-05-24T03:17:52.437', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '9754', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><terminology><reductions>', 'CreationDate': '2013-02-13T23:41:37.760', 'Id': '9753'},125_74:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having a very hard time understanding what's what.</p>\n\n<p>$$L_{1}\\leq_{p}L_{2}$$</p>\n\n<p>If $L_2$ is stated to be in $\\textbf{NP}$, is it necessarily true that $L_1$ is $\\textbf{NP}$-Complete? I need to show the following for an assignment, but I'm having a dispute with a fellow student because he claims that I can't claim that $L_1$ is $\\textbf{NP}$-Complete...</p>\n\n<blockquote>\n  <p>Suppose that $L_1\\leq_p L_2\\leq_p L_3$. Also suppose that $L_3$ is in $\\textbf{NP}$. Explain how to solve $L_1$ deterministically in exponential time.</p>\n</blockquote>\n\n<p>I say (and I could be wrong - and that's a strong possiblity since I have very little understanding of this material) that since $L_3$ is in $\\textbf{NP}$, $L_2$ also has to be in $\\textbf{NP}$, and so therefore $L_1$ has to be in $\\textbf{NP}$. And if that's the case, then $L_1$ can easily be converted to a deterministic algorithm through a breadth first search through the non-deterministic computation tree. Is there something I'm missing?</p>\n", 'ViewCount': '70', 'Title': 'Polynomial time reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:34:11.407', 'LastEditDate': '2013-02-14T06:34:11.407', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9759', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><terminology><np-complete><reductions>', 'CreationDate': '2013-02-14T02:24:22.693', 'Id': '9758'},125_75:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am asking for help to explain some crucial points of the central lemma and it\'s proof of famous paper <a href="http://www.cs.princeton.edu/courses/archive/fall05/cos528/handouts/NP_is_as.pdf" rel="nofollow">NP is as easy as detecting unique solutions by L.Valiant and V.Vazirani</a>.</p>\n\n<p>The proof can be found in the section <strong>2. The proof</strong> of the paper. </p>\n\n<p><strong>The idea of the lemma</strong>: lemma shows that there is a randomized polynomial - time reduction from SAT to Unique-SAT. Lemma uses GF[2] inner product with polynomial few {0,1} vectors.</p>\n\n<p><strong>Problem in general</strong>: I have some difficulties in understanding the definition of the lemma and in usage of GF[2] for proving the lemma. </p>\n\n<p><strong>Specific questions:</strong></p>\n\n<p>Following is the number of citations from the paper with relevant question to the citation. </p>\n\n<blockquote>\n  <p><strong>Lemma 2.1.</strong> If $f$ is any CNF formula in $x_1,...,x_n$ and $w_1,...,w_k \\in \\{0,1\\}^n$, </p>\n</blockquote>\n\n<p>Q:I think $x_1,...,x_n$ are literals, but what are $w_1,..,w_k$? Are they literals or something else? If yes, why to distinct between them and $x$ literals.</p>\n\n<p>A:$w_1,..,w_k$ are the truth assignments. </p>\n\n<blockquote>\n  <p>then one can construct in linear time a formula $f\'_k$ whose solution $v$ satisfy $f$ and the equations $v\\cdot  w_1=...=v\\cdot w_k=0$. Furthermore, one can construt a polynomial-size CNF formula $f_k$ in variables $x_1,...,x_n,y_1,...y_m$,</p>\n</blockquote>\n\n<p>Q: $x_1,...x_n$ are unknown literals, how can we construct $f_k$ with unknown literals and where $y_1,...,y_m$ came from?</p>\n\n<blockquote>\n  <p>for some $m$ such that there is a bijection between solutions of $f_k$ and $f\'_k$, defined be equality on the $x_1,...,x_n$ values.</p>\n  \n  <p><strong>Proof</strong>: It is sufficient to show the lemma for $k=1$. Then, $f\'_k$ is</p>\n  \n  <p>$f \\wedge (x_{i_1} \\bigoplus x_{i_2} \\bigoplus ... \\bigoplus x_{i_j} \\bigoplus 1)$</p>\n</blockquote>\n\n<p>Q: this is the most vague point, how do we come to the such construction of $f\'_1$ and why showing only $f\'_1$ sufficient for the proof.</p>\n\n<p>I hope you forgive me for my naivety. I will appreciate any hint in accordance to the above questions.</p>\n', 'ViewCount': '106', 'Title': 'Proof of SAT is randomly reducible to UNIQUE-SAT', 'LastEditorUserId': '1379', 'LastActivityDate': '2013-02-14T17:47:28.463', 'LastEditDate': '2013-02-14T17:47:28.463', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<complexity-theory><reductions><proof-techniques>', 'CreationDate': '2013-02-14T09:57:05.487', 'Id': '9766'},125_76:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have as an assignment question to show that $QuadSat=\\{\\langle\\phi\\rangle\\mid\\phi$ is a satisfiable 3CNF formula with at least 4 satisfying assignments$\\}$ is $\\sf NP$-Complete.</p>\n\n<p>My solution is as follows, which is pretty much copied almost 100% from a textbook example with only an extra requirement for satisfiablity at the end...</p>\n\n<blockquote>\n  <p>$$QuadSat\\leq_{p} Clique$$\n  Let $\\phi$ be a formula with k clauses such as\n  $$\\phi=\\bigwedge_{1}^{k}(a_k\\vee b_k\\vee c_k)$$\n  The reduction $f$ generates the strong $\\langle G,k\\rangle$, where $G$ is an undirected graph defined as follows:</p>\n  \n  <p>The nodes in $G$ are organized into $k$ groups of three nodes each called the \\textbf{triples}, $t_1, \\dots, t_k$. Each triple corresponds to one of the clauses in $\\phi$, and each node in a triple corresponds to a literal in the associated clause. Label each node of $G$ with its corresponding literal in $\\phi$.</p>\n  \n  <p>The edges of $G$ connect all but two types of pairs of nodes in $G$: No edge is present between nodes in the same triple, and no edge is present between two nodes with contradictory labels. $QuadSat$ is satisfiable if and only if the resulting graph $G$ contains four or more $k$-$cliques$. Each unique $k$-$clique$ in $G$ represents a set of satisfying assignments to $QuadSat$.</p>\n  \n  <p>The reduction runs in polynomial time, because the construction of the graph is a polynomial function; one pass through all the triples to create all the vertices for $V$, and one pass through the same triples to create the edges.</p>\n</blockquote>\n\n<p>I feel like my explanation as to why my reduction is polynomial in time is severely weak, possibly bordering on wrong. How can I explain this better?</p>\n\n<p>And something else: I think this only proves that QuadSat is in NP, but not necessarily NP Complete. How can I prove this?</p>\n', 'ViewCount': '117', 'Title': 'How do I explain that a polynomial time reduction is in fact polynomial time?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T14:39:23.387', 'LastEditDate': '2013-02-16T14:39:23.387', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9812', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><np-complete><reductions><proof-techniques>', 'CreationDate': '2013-02-15T13:50:38.367', 'Id': '9806'},125_77:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Between my textbook and various online sources (namely wikipedia), I'm very confused... can somebody clear up which words are synonymous and which mean different things?</p>\n\n<ul>\n<li>Many-to-one reduction</li>\n<li>Mapping reduction</li>\n<li>Turing reduction</li>\n<li>Cook reduction</li>\n<li>Karp reduction</li>\n<li>Polynomial-time many-to-one reduction</li>\n<li>Polynomial time turing reduction</li>\n</ul>\n\n<p>I've also seen others, but I can't recall them currently.</p>\n", 'ViewCount': '105', 'Title': 'What is the difference between these terms?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-17T08:53:28.023', 'LastEditDate': '2013-02-17T08:53:28.023', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '9855', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><computability><terminology><reductions>', 'CreationDate': '2013-02-17T01:30:50.600', 'Id': '9847'},125_78:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '250', 'Title': 'Showing that minimal vertex deletion to a bipartite graph is NP-complete', 'LastEditDate': '2013-02-18T00:25:04.840', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '3092', 'FavoriteCount': '1', 'Body': '<p>Consider the following problem whose input instance is a simple graph $G$ and a natural integer $k$.</p>\n\n<blockquote>\n  <p>Is there a set $S \\subseteq V(G)$ such that $G - S$ is bipartite and $|S| \\leq k$?</p>\n</blockquote>\n\n<p>I would like to show that this problem is $\\rm{NP}$-complete by reducing either 3-SAT, $k$-CLIQUE, $k$-DOMINATING SET or $k$-VERTEX COVER to it.</p>\n\n<p>I believe I can reduce the 3-COLORING problem to it so I would only need to see how to reduce one of the mentioned problems to it.  But since that would be rather messy I am wondering if someone sees an elegant reduction to the aforementioned problems.</p>\n\n<p>Also, is there a name for this decision problem?</p>\n', 'Tags': '<complexity-theory><np-complete><reductions>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-18T10:57:25.470', 'CommentCount': '5', 'AcceptedAnswerId': '9865', 'CreationDate': '2013-02-17T17:54:20.413', 'Id': '9863'},125_79:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read somewhere that, if $A\\leq_p B$ and $B\\leq_p A$, then it is said that $A\\equiv_p B$. What exactly does this mean? Is it saying that both $A$ and $B$ are the exact same level of complexity?</p>\n', 'ViewCount': '130', 'Title': 'Anti-symmetry of polynomial time reductions', 'LastActivityDate': '2013-02-20T20:30:36.690', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9986', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-02-20T20:12:24.670', 'Id': '9985'},125_80:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the reduction $3\\mathsf{SAT}\\leq_p \\mathsf{IndSet}$ as follows:</p>\n\n<p><img src="http://i.stack.imgur.com/PCe9v.png" alt="enter image description here"></p>\n\n<p>How can I argue that it\'s in polynomial time? I understand how the reduction works, but even though it appears rather trivial, I can\'t explain why it\'s efficient.</p>\n\n<blockquote>\n  <p>To place $\\mathsf{IndSet}$ in $\\mathsf{NP}$-Hard, we will show $3\\mathsf{SAT}\\leq_p \\mathsf{IndSet}$:</p>\n  \n  <p>Given\n  $$\\phi=\\bigwedge_{m=1}^{n}(x_m\\vee y_m\\vee z_m)$$\n  with $m$ clauses, produce the graph $G_\\phi$ that contains a triangle for each clause, with vertices of the triangle labeled by the literals of the clause. Add an edge between any two complementary literals from different triangles. Finally, set $k=m$. In our example, we have triangles on $x,y,\\overline{z}$ and on $\\overline{x},w,z$ plus the edges $(x,\\overline{x})$ and $(\\overline{z},z)$.</p>\n  \n  <p>We need to prove two directions. First, if $\\phi$ is satisfiable, then $G_\\phi$ has an independent set of size at least $k$. Secondly, if $G_\\phi$ has an independent set of size at least $k$, then $\\phi$ is satisfiable. (Note that the latter is the contrapositive of the implication "if $\\phi$ is not satisfiable, then $G_\\phi$ does not have an independent set of size at least k".)</p>\n  \n  <p>For the first direction, consider a satisfying assignment for $\\phi$. Take one true literal from every clause, and put the corresponding graph vertex into a set $S$. Observe that $S$ is an independent set of size $k$ (where $k$ is the number of clauses in $\\phi$).</p>\n  \n  <p>For the other direction, take an independent set $S$ of size $k$ in $G_\\phi$. Observe that $S$ contains exactly one vertex from each triangle (clause) , and that $S$ does not contain any conflicting pair of literals (such as $x$ and $\\overline{x}$, since any such pair of conflicting literals are connected by an edge in $G_\\phi$). Hence, we can assign the value True to all the literals corresponding with the vertices in the set $S$, and thereby satisfy the formula $\\phi$.</p>\n  \n  <p>This reduction is polynomial in time because $\\Huge\\dots?$</p>\n</blockquote>\n\n<p>I\'ve looked at many different examples of how this is done, and everything I find online includes everything in the proof except the argument of why this is polynomial. I presume it\'s being left out because it\'s trivial, but that doesn\'t help me when I\'m trying to learn how to explain such things.</p>\n', 'ViewCount': '94', 'Title': 'How can I argue that $3\\mathsf{SAT}\\leq_p \\mathsf{IndSet}$ is polynomial in time?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-24T16:15:03.743', 'LastEditDate': '2013-02-24T16:15:03.743', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10015', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-02-21T17:41:56.177', 'Id': '10014'},125_81:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to prove that the following problem $0$-$1$ $\\mathsf{ Ineq}$ is $\\mathsf{NL}$-complete.</p>\n\n<p>Given a finite set of variables $V$, a finite set of inequalities of the form $x \\le y$ (where $x, y \\in V$) and a finite set of equalities of the form $x=a$ (where $x \\in V$ and $a \\in \\{0,1\\}$), is there an assignment of values from $\\{0, 1\\}$ to the variables satisfying all the inequalities and all the equalities?</p>\n\n<p>How can I start to resolve the proof?</p>\n', 'ViewCount': '64', 'Title': 'Prove that $0$-$1$ $\\mathsf{ Ineq}$ is $\\mathsf{NL}$-complete', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-22T10:06:31.597', 'LastEditDate': '2013-02-22T10:06:31.597', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10023', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6978', 'Tags': '<complexity-theory><graph-theory><reductions><space-complexity>', 'CreationDate': '2013-02-21T18:41:55.347', 'Id': '10017'},125_82:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am studying computational theory with Sipser\'s textbook. I can\'t quite understand the definition of "reduction". For example, "this problem can be reduced to ATM ..."</p>\n\n<p>What exactly does "to reduce" mean? I can\'t draw the picture in my head. Can anyone can help me understand this definition? </p>\n', 'ViewCount': '177', 'Title': 'What is a "reduction", really?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-21T13:03:11.430', 'LastEditDate': '2014-01-21T13:03:11.430', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6807', 'Tags': '<terminology><reductions>', 'CreationDate': '2013-03-08T21:47:29.300', 'FavoriteCount': '1', 'Id': '10393'},125_83:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following variant of the FACTORING problem (given N,M decide whether N has a prime factor less than M):</p>\n\n<blockquote>\nMULTIPLE-FACTORING: Given three integers $1 \\leq K \\leq M \\leq N$ decide if there are at least $K$ prime factors of $N$ less than $M$\n</blockquote>\n\n<p>FACTORING $\\leq_m$ MULTIPLE-FACTORING (just pick $K=1$) and</p>\n\n<p>MULTIPLE-FACTORING $\\leq_T$ FACTORING (find all factors of $N$ using FACTORING, and count if their number is $\\geq K$)</p>\n\n<p>But is MULTIPLE-FACTORING many one reducible to FACTORING?<br>\n(MULTIPLE-FACTORING $\\leq_m^?$ FACTORING)</p>\n', 'ViewCount': '62', 'Title': 'Karp reduction between FACTORING and a variant of it', 'LastEditorUserId': '140', 'LastActivityDate': '2013-03-11T07:46:28.627', 'LastEditDate': '2013-03-11T07:46:28.627', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '140', 'Tags': '<complexity-theory><reductions><factoring><np>', 'CreationDate': '2013-03-11T00:00:51.463', 'FavoriteCount': '1', 'Id': '10441'},125_84:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have to reduce $L_\\text{empty}$ to $L_\\text{inf}$</p>\n\n<p>where </p>\n\n<p>$\\qquad L_\\text{empty} = \\{e \\mid |L(P_e)| = 0 \\}$ and<br>\n$\\qquad L_\\text{inf}= \\{e \\mid |L(P_e)| = \\infty \\}$.</p>\n\n<p>where $P_e$ is the program with G\xf6del number $e$, and $L(P_e)$ the language it accepts.</p>\n\n<p>So can I define a program $P$ like this</p>\n\n<pre><code>input n\nRun Pe on 1...n for n steps\nif Pe accepts any number then \n  enter an infinite loop and start accepting infinite number\nif Pe does not accept any number then \n  accept 1\n</code></pre>\n\n<p>Now if I can define program P like above then asking the question whether the index of $P$ is in $L_\\text{inf}$ will tell me whether the language accepted by $P_e$ is empty or not.</p>\n', 'ViewCount': '75', 'Title': 'Can I use infinite numbers in a reduction?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-11T07:31:15.733', 'LastEditDate': '2013-03-11T07:31:15.733', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7222', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-03-11T00:40:18.537', 'Id': '10442'},125_85:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A decision problem is NP-complete if it is in NP and all other problems in NP can be reduced to it by a reduction that runs in polynomial time. Why it is important to require that the reduction runs in polynomial time, as opposed to accepting any computable reduction.</p>\n', 'ViewCount': '414', 'Title': 'NP-complete and polynomial time reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-15T11:05:07.020', 'LastEditDate': '2013-03-15T11:05:07.020', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'fudu', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<terminology><np-complete><reductions>', 'CreationDate': '2013-03-12T10:34:33.867', 'Id': '10488'},125_86:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following problem. Given a $m \\times n$ integer matrix $A$ and a $p \\times q$ integer matrix $B$, do there exist one-to-one functions \n$$r:\\{1,2,...,m\\} \\rightarrow \\{1,2,...,p\\}$$\n$$c:\\{1,2,...,n\\} \\rightarrow \\{1,2,...,q\\}$$\nwhere for all $1 \\leq i \\leq m$ and $1 \\leq j \\leq n$, $A[i,j] \\leq B[r(i),c(j)]$? </p>\n\n<p>What is the best way to show this problem is NP-complete? I am currently considering reducing the clique problem to this problem.  </p>\n', 'ViewCount': '71', 'Title': 'Prove Matrix Correspondence is NP-complete', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-18T07:36:52.923', 'LastEditDate': '2013-03-18T07:36:52.923', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10596', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-03-18T02:57:18.987', 'Id': '10595'},125_87:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Define the problem $W$:</p>\n\n<blockquote>\n  <p><strong>Input:</strong> A multi-set of numbers $S$, and a number $t$.</p>\n  \n  <p><strong>Question:</strong> What is the smallest subset $s \\subseteq S$ so that $\\sum_{k \\in s} k = t$, if there is one? (If not, return <code>none</code>.)</p>\n</blockquote>\n\n<p>I am trying to find some polytime equivalent decision problem $D$ and provide a polytime algorithm for the non-decision problem $W$ assuming the existence of a polytime algorithm for $D$.</p>\n\n<p>Here is my attempt at a related decision problem:</p>\n\n<blockquote>\n  <p>$\\mathrm{MIN\\text{-}W}$:</p>\n  \n  <p><strong>Input:</strong> A multi-set of numbers $S$, two numbers $t$ and $k$.</p>\n  \n  <p><strong>Question:</strong> Is there a subset $s \\subseteq S$ so that $\\sum_{k \\in s} k = t$ and $|s| \\leq k$?</p>\n</blockquote>\n\n<p>Proof of polytime equivalence:</p>\n\n<p>Assume $W \\in \\mathsf{P}$.</p>\n\n<pre><code>solveMIN-W(S, t, k):\n1. S = sort(S)\n2. Q = {}\n3. for i=1 to k:\n4.     Q.add(S_i)\n5.     res = solveW(Q, t)\n6.     if res != none and res = t: return Yes\n7. return No\n</code></pre>\n\n<p>I'm not sure about this algorithm though. Can anyone help please?</p>\n", 'ViewCount': '89', 'Title': 'How to prove polynomial time equivalence?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-22T13:44:52.263', 'LastEditDate': '2013-03-22T13:44:52.263', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10692', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><reductions><p-vs-np>', 'CreationDate': '2013-03-22T04:50:15.547', 'Id': '10690'},125_88:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I\'m trying to understand P/NPC problems. The one I\'m trying to tackle now is subset sum (we have a collection of integers $S$ and a $k$ param: is there a subset of $S$ that sum of all it\'s elements is equal to $k$?) problem and the proof that ss is an NPC problem by reduction from 3SAT. </p>\n\n<p>I\'ve found two PDF\'s that attempt to solve that, but the problem is, I don\'t have the foggiest idea how to \'explain in in my own words\'. </p>\n\n<p>Okay, some links ahead and questions related to them: </p>\n\n<p><a href="http://people.clarkson.edu/~alexis/PCMI/Notes/lectureB07.pdf" rel="nofollow">Here</a>, on page 4th, there\'s a logic table for 3SAT clause that apparently proves why ss is NPC, but I don\'t get it - what exactly are those s and t values, and how does that table proves NPC\'ness? And how k is computed in that table? It\'s simply not clear to me :(</p>\n\n<p><a href="http://valis.cs.uiuc.edu/~sariel/teach/2004/b/webpage/lec/10_npc_notes.pdf" rel="nofollow">Another link</a>\non pages 5 and 6 there are another tables that appear out of nowhere with no explanation that I could understand.</p>\n\n<p>So, if anybody knows what I\'m talking about and could help me, please answer :). Or, if it\'s possible, can anybode give me a simple and straightforward proof why subset sum is NPC?</p>\n', 'ViewCount': '812', 'Title': 'Proving NP Completeness of a subset-sum problem - how?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-23T15:55:25.050', 'LastEditDate': '2013-03-23T15:55:25.050', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'user67311', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-03-18T16:01:15.190', 'Id': '10702'},125_89:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '368', 'Title': 'How to prove NP-hardness of a longest-path problem?', 'LastEditDate': '2013-11-13T17:56:10.210', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7168', 'FavoriteCount': '1', 'Body': "<p>I have this question:</p>\n\n<pre><code>Input: \nG(V, E) = an undirected graph, V={v1, v2, ..., vn} (V = set of nodes, E = set of edges)\nwhere there is a path connecting from v1 to vn.\n\nQuestion: \nWhat is the maximum number of nodes you can visit when starting from v1 and ending at vn. \n(including v1 and vn) \nEach node can only be visited at most once.\n</code></pre>\n\n<p>I want to prove that this is NP-hard by reducing it from a known NP-complete problem, such as undirected Hamiltonian path or subset-sum.</p>\n\n<p>However I don't know exactly how to do this and this is where I need help.</p>\n\n<p>Can anyone help please?</p>\n", 'Tags': '<complexity-theory><reductions><proof-techniques><np-hard>', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-13T17:56:10.210', 'CommentCount': '1', 'AcceptedAnswerId': '10734', 'CreationDate': '2013-03-24T03:02:15.400', 'Id': '10732'},125_90:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this problem which is described as follows:</p>\n\n<p>Input:\n    You are given a multi-set $M$ (a set that can contain duplicates), and two numbers $P$ and $T$.\n    $M = {(x_1,y_1), (x_2,y_2), ..., (x_n,y_n)}$.\n    Each $x$ and $y$ is an integer $&gt;= 0$.\n    $P$ in an integer $&gt;= 0$.\n    $T$ is an integer $&gt; 0$.</p>\n\n<p>Question:\n    Is there a subset $G$ of $M$, such that the sum of every $x$ value of $G$ is $&gt; P$ and the sum of every $y$ value of $G$ is $&lt; T$?\n    (Note: You are basically taking from $M$. For example: if $M$ has two $(1,1)$'s then $G$ can contain at most two $(1, 1)$'s)</p>\n\n<p>I want to reduce it to from the subset sum problem, but I am not sure how because there's two conditions to solve for...</p>\n\n<p>Can anyone help with this problem?</p>\n", 'ViewCount': '144', 'Title': 'How to reduce from subset-sum problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T12:06:45.403', 'LastEditDate': '2013-03-25T12:06:45.403', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10748', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2013-03-24T17:43:29.840', 'Id': '10747'},125_91:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a problem where I am supposed to analyze the <code>Steiner tree problem</code> by doing the following 3 steps.</p>\n\n<p>1) Look up what the Steiner tree problem is.</p>\n\n<p>2) Find a polynomial time reduction to it from one of these 8 known NP-complete problems:</p>\n\n<ul>\n<li>3-col </li>\n<li>subset-sum </li>\n<li>clique </li>\n<li>hampath </li>\n<li>Uhampath </li>\n<li>sat </li>\n<li>3-sat </li>\n<li>vertex-cover.</li>\n</ul>\n\n<p>3) Prove that it is NP-complete.</p>\n\n<hr>\n\n<p>My first problem is that I don't understand what the Steiner tree problem is. I can't find the problem anywhere. Wikipedia has  a page on it, but doesn't really describe it in simple terms.</p>\n\n<p>Can anyone help me out on this, and also give me hints for number 1, 2 and 3?</p>\n", 'ViewCount': '202', 'Title': 'How to analyze the Steiner tree problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-26T11:23:15.850', 'LastEditDate': '2013-03-26T11:23:15.850', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions><trees>', 'CreationDate': '2013-03-26T00:09:08.733', 'FavoriteCount': '2', 'Id': '10790'},125_92:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '296', 'Title': 'Subset Sum: reduce special to general case', 'LastEditDate': '2013-04-02T22:46:23.867', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7549', 'FavoriteCount': '2', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Subset_sum_problem">Wikipedia</a> states the subset sum problem as finding a subset of a given set of integers, whose sum is zero. Further it describes it as equivalent to finding a subset with sum $s$ for any given $s$.</p>\n\n<p>So I believe as they are equivalent, there must be a reduction in either side. The one from $s$ to zero is trivial by setting $s = 0$. But I had no luck finding a reduction from zero to $s$, i.e. given a set of integers $A$, construct a set of integers $B$ containing a subset with sum $s$ (for any $s$), if and only if there is as subset of $A$ with sum zero.</p>\n\n<p>Can you give me some pointers?</p>\n', 'Tags': '<complexity-theory><reductions><np-hard>', 'LastEditorUserId': '268', 'LastActivityDate': '2013-04-03T06:52:39.257', 'CommentCount': '0', 'AcceptedAnswerId': '10987', 'CreationDate': '2013-04-02T22:06:48.883', 'Id': '10981'},125_93:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>In the paper <a href="http://link.springer.com/content/pdf/10.1007/BF01300131">Complexity of the Frobenius Problem</a> by Ram\xedrez-Alfons\xedn, a problem was proved to be NP-complete using Turing reductions.\nIs that possible? How exactly? I thought this was only possible by a polynomial time many one reduction. Are there any references about this?</p>\n\n<p>Are there two different notions of NP-hardness, even NP-completeness? But then I am confused, because from a practical viewpoint, if I want to show that my problem is NP-hard, which do I use?</p>\n\n<p>They started the description as follows:</p>\n\n<blockquote>\n  <p>A  polynomial  time  Turing  reduction from  a problem $P_1$  to  another problem $P_2$  is  an  algorithm  A  which  solves  $P_1$  by  using  a  hypothetical  subroutine A\'  for  solving  $P_2$  such  that,  if  A\' were  a  polynomial  time  algorithm  for  $P_2$  then  A would  be  a  polynomial  time  algorithm  for  $P_1$.  We  say  that  $P_1$  can  be  Turing  reduced to  $P_2$. </p>\n  \n  <p>A  problem  $P_1$  is  called  (Turing)  NP-hard  if  there  is  an  NP-complete  decision \n  problem $P_2$  such  that  $P_2$  can  be  Turing  reduced  to  $P_1$.</p>\n</blockquote>\n\n<p>And then they use such a Turing reduction from an NP-complete problem to show NP-completeness of some other problem.</p>\n', 'ViewCount': '355', 'Title': 'Can one show NP-hardness by Turing reductions?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:48:09.817', 'LastEditDate': '2013-04-08T14:48:09.817', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7309', 'Tags': '<complexity-theory><time-complexity><np-complete><reductions>', 'CreationDate': '2013-04-08T00:05:59.537', 'FavoriteCount': '1', 'Id': '11120'},125_94:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In computability and complexity theory (and maybe other fields), reductions are ubiquitous. There are many kinds, but the principle remains the same: show that one problem $L_1$ is at least as hard as some other problem $L_2$ by mapping instances from $L_2$ to solution-equivalent ones in $L_1$. Essentially, we show that any solver for $L_1$ can also solve $L_2$ if we allow it to use the reduction function as preprocessor.</p>\n\n<p>I have performed my share of reductions over the years, and something keeps bugging me. While every new reduction requires a (more or less) creative construction, the task can feel repetitive. Is there a pool of canonical methods?</p>\n\n<p>What are techniques, patterns and tricks one can regularly employ for constructing reduction functions?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '548', 'LastEditorDisplayName': 'user742', 'Title': 'What are common techniques for reducing problems to each other?', 'LastActivityDate': '2014-01-17T18:09:43.470', 'LastEditDate': '2013-05-15T10:15:37.360', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><computability><reductions><proof-techniques><reference-question>', 'CreationDate': '2013-04-10T21:31:03.203', 'FavoriteCount': '10', 'Id': '11209'},125_95:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In an exercise I have to show that minimizing a multivariate polynomial with $n$ variables over the hyper-cube $H = \\{ (x_1, \\ldots, x_n) : 0 \\leq x_i \\leq 1 \\}$ is NP-Hard. Formally, given $p(x_1, \\ldots, x_n)$ and $\\alpha$, does $\\min_{0 \\leq x_i \\leq 1} p(x_1, \\ldots, x_n) \\leq \\alpha$?</p>\n\n<p>My idea is to reduce it to MAX-SAT as follows. Suppose I am given the formula:</p>\n\n<p>$(x_1 \\vee \\overline{x_2} \\vee x_3) \\wedge (\\overline{x_1} \\vee \\overline{x_3}) \\wedge (\\overline{x_1} \\vee x_2 \\vee \\overline{x_3})$</p>\n\n<p>Then I consider:</p>\n\n<p>$p(y_1, y_2, y_3) = y_1 (1 - y_2) y_3 + (1 - y_1) (1 - y_3) + (1 - y_1) y_2 (1 - y_3)$</p>\n\n<p>If $p$ reaches a minimum at a corner of $H$ then the assignment:\n$$x_i = \\textit{true} \\ \\text{if} \\ y_i = 0 \\ \\text{and} \\ x_i = \\textit{false} \\ \\text{if} \\ y_i = 1$$\nis a solution for MAX-SAT value for the corresponding formula and since MAX-SAT is NP-Hard we are done. However, how do I proceed if $p$ reaches its minimum at an interior point? Or is it the case that it will always be a corner?</p>\n', 'ViewCount': '118', 'Title': 'Minimizing a multivariate polynomial over the hyper-cube is NP-Hard', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T03:01:45.210', 'LastEditDate': '2013-04-11T23:39:17.320', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'fran.aubry', 'PostTypeId': '1', 'OwnerUserId': '7697', 'Tags': '<complexity-theory><reductions><optimization><np-hard>', 'CreationDate': '2013-04-11T15:42:38.420', 'Id': '11246'},125_96:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '226', 'Title': 'If A is poly-time reducible to B, is B poly-time reducible to A?', 'LastEditDate': '2013-04-14T11:11:21.183', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7715', 'FavoriteCount': '1', 'Body': '<p>Basically, is the following statement true?</p>\n\n<blockquote>\n  <p>$A \\leq_p B$ $\\rightarrow$ $B \\leq_p A$</p>\n</blockquote>\n', 'Tags': '<complexity-theory><reductions><polynomial-time>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T08:23:29.080', 'CommentCount': '3', 'AcceptedAnswerId': '11294', 'CreationDate': '2013-04-13T21:49:36.997', 'Id': '11292'},125_97:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the proof of Trakhtenbrot\'s theorem (as given in "Elements of Finite Model Theory" by Leonid Libkin), for every Turing machine $M$, author constructs a FO sentence $\\Phi_M$ of vocabulary $\\sigma$ such that $\\Phi_M$ is finitely satisfiable iff $M$ halts on the empty input. Then he says that as the latter is known to be undecidable so the theorem holds.</p>\n\n<p>My doubt is, the vocabulary $\\sigma$ that was constructed depends on the Turing Machine $M$. But the theorem holds for any relational vocabulary with at least one binary relation symbol and also it should not depend on the machine $M$. Perhaps the claim of author is enough to imply the theorem for arbitrary vocabulary, but I am unable to see how.</p>\n', 'ViewCount': '161', 'Title': "Proof of Trakhtenbrot's theorem", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T09:57:57.300', 'LastEditDate': '2013-04-15T09:54:06.163', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<turing-machines><logic><reductions><undecidability><finite-model-theory>', 'CreationDate': '2013-04-15T08:38:12.270', 'Id': '11327'},125_98:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '211', 'Title': 'Is Hidoku NP complete?', 'LastEditDate': '2013-05-06T22:36:24.267', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7549', 'FavoriteCount': '2', 'Body': u'<p>A Hidoku is a $n \\times n$ grid with some pre-filled integers from 1 to $n^2$. The goal is to find a path of successive integers (from 1 to $n^2$) in the grid. More concrete, each cell of the grid must contain a different integer from 1 to $n^2$ and each cell with value $z \u2260 n^{2}$ must have a neighbor cell with value $z + 1$ (can also be diagonally).</p>\n\n<p>Is it NP hard to decide whether a given Hidoku is solvable? What reduction could be used?</p>\n\n<p>Edit: according to the comments, I give a little clarification. Given is a grid of cells, some of them already contain values (integers from 1 to n\xb2). We must fill all remaining cells with integers from 1 to $n^2$, such that no two cells have the same value and that every cell with value $z \u2260 n\xb2$ has a neighbor with value $z + 1$. That is, after filling out the cells, we must find the path $1, 2, 3,\\cdots, n^2$. In the grid, which logically visits each cell.</p>\n\n<p>An example of a Hidoku woud be <a href="http://www.janko.at/Raetsel/Hidoku/018.c.gif" rel="nofollow">http://www.janko.at/Raetsel/Hidoku/018.c.gif</a>.\nAn already solved Hidoku is <a href="http://diepresse.com/images/uploads/3/f/7/586743/spectrumsommerraetsel_7august_hidoku_schwer_loesung20100810172340.gif" rel="nofollow">http://diepresse.com/images/uploads/3/f/7/586743/spectrumsommerraetsel_7august_hidoku_schwer_loesung20100810172340.gif</a>, where you can see the path I was refering to.</p>\n', 'Tags': '<complexity-theory><reductions><np-hard>', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-05-06T22:36:24.267', 'CommentCount': '8', 'AcceptedAnswerId': '11336', 'CreationDate': '2013-04-15T12:51:57.417', 'Id': '11330'},125_99:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I got stuck on this question while studying for final exam.</p>\n\n<p><img src="http://i.stack.imgur.com/AdZCy.png" alt="the language"></p>\n\n<p>I thought about reducing L\' to L to prove that L\' is recognizable since L is recognizable. I am not 100% sure if that is correct.</p>\n', 'ViewCount': '68', 'Title': 'Prove that the Language is Recognizable', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-19T03:28:21.033', 'LastEditDate': '2013-04-19T03:28:21.033', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '11396', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7779', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-04-18T22:57:49.270', 'Id': '11391'},125_100:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Why isn't the set $\\{ \\langle i, j \\rangle \\mid W_i = \\overline W_j\\}$ a r.e. set?</p>\n\n<p>Note: $W_x = L(M_x)$</p>\n", 'ViewCount': '51', 'Title': "Why isn't set $\\{ \\langle i, j \\rangle \\mid W_i = \\overline{W_j}\\}$ a recursively enumerated set?", 'LastEditorUserId': '2205', 'LastActivityDate': '2013-04-19T07:08:49.287', 'LastEditDate': '2013-04-19T06:44:43.583', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '11400', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<computability><reductions>', 'CreationDate': '2013-04-19T02:15:16.947', 'Id': '11395'},125_101:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Meeting rooms on university campuses may or may not contain coffee machines. We would\n  like to ensure that every meeting room either has a coffee machine or is close enough to a\n  meeting room that does have a coffee machine. (For any two meeting rooms, the architect\n  has told us whether or not they are close enough.) Our problem is to determine among all the\n  meeting rooms of any university campus, which ones should have coffee machines so that we\n  use as few coffee machines as possible. Specify this problem as an optimization problem on a\n  graph. Formulate the corresponding Coffee-machine Decision Problem (abbreviated Coffee).\n  Prove that the Coffee Machine Decision Problem is NP-complete.</p>\n  \n  <p>Hint: You could use Vertex Cover. For every edge, add two more edges and one more vertex.</p>\n</blockquote>\n\n<p>I'm confused at the hint given and why this problem isn't just a straight reduction from Vertex Cover.  What's the point of adding two more edges and a vertex for every edge?</p>\n", 'ViewCount': '126', 'Title': 'How does the problem of having a coffee-machine close relate to vertex cover?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T15:23:25.990', 'LastEditDate': '2013-04-21T15:23:25.990', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7787', 'Tags': '<complexity-theory><np-complete><reductions><decision-problem>', 'CreationDate': '2013-04-19T09:11:08.353', 'Id': '11402'},125_102:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the set cover problem we want to find in the $\\mathbb{S} \\subset 2^\\mathbb{U}$ the subset $\\{s_i\\}_{1..k}$, such that $\\cup s_i = \\mathbb{U}$ for given $K$, where $k \\le K$.\nBut how to reduce the set cover problem to the set covering decision problem (determining whether is there such cover or not)? The same with problems like a TSP is always easy enough: we exclude some elements, check if the needed condition is still met and know already, are these elements needed or not. But it doesn't work here and I am stuck. I would be appreciated if you could give me some hints for this problem.</p>\n", 'ViewCount': '77', 'Title': 'Set cover problem and the existence of such cover', 'LastEditorUserId': '7785', 'LastActivityDate': '2013-04-19T10:15:45.540', 'LastEditDate': '2013-04-19T09:59:40.590', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11406', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7785', 'Tags': '<np-complete><reductions>', 'CreationDate': '2013-04-19T09:38:40.953', 'Id': '11403'},125_103:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's say I have a decision problem  $P$ on graphs for which I know that it is NP-hard on graphs with maximum degree $d$. Does this then imply that it is NP-hard on $d$-regular graphs? Although it might seem obviously true, maybe it is inherent in the reduction to show that $P$ is hard, that some vertices have degree less than $d$.</p>\n", 'ViewCount': '71', 'Title': 'NP hardness through Restriction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:43:50.053', 'LastEditDate': '2013-04-21T14:43:50.053', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11456', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7816', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2013-04-21T02:47:17.720', 'Id': '11453'},125_104:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '66', 'Title': 'Prove NP-completeness of deciding whether there is an edge-tour of at most a given length', 'LastEditDate': '2013-04-21T15:43:16.887', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Mariska', 'PostTypeId': '1', 'OwnerUserId': '7799', 'Body': "<p>We are given a graph G, integer b &lt; |E|, and subset F in E. The problem is to detect whether there is a cycle in the graph with length at most b and includes each edge in F. Prove that this is NP Complete. </p>\n\n<p>I'm thinking of reducing from Hamiltonian Path, but still can't think of the appropriate transformation function. </p>\n", 'Tags': '<complexity-theory><np-complete><reductions>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T15:43:16.887', 'CommentCount': '1', 'AcceptedAnswerId': '11464', 'CreationDate': '2013-04-21T13:16:30.233', 'Id': '11463'},125_105:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am attempting to prove the following problem is undecidable. Given a Turing machine $M$ and input $x$, does $M$ visit infinitely many tape cells on input $x$? </p>\n\n<p>I am considering a reduction from the halting problem. Is this the right approach? </p>\n', 'ViewCount': '109', 'Title': 'Show the problem of a machine visiting infinitely many tape cells on some input is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-04T15:47:41.333', 'LastEditDate': '2013-04-21T23:15:04.180', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<computability><turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2013-04-21T22:25:41.810', 'Id': '11479'},125_106:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For the following question:</p>\n\n<p>If B is an element of PSPACE and A is an element of PSPACE-Complete, and A polynomial reduces to B, then B is an element of PSPACE-Complete.</p>\n\n<p>I am trying to prove this, but I don't understand how to get started. Can anyone help please?</p>\n", 'ViewCount': '45', 'Title': 'Showing transitivity of PSPACE?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T09:10:18.867', 'LastEditDate': '2013-04-23T09:10:18.867', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<complexity-theory><reductions><proof-techniques><space-complexity>', 'CreationDate': '2013-04-23T02:15:09.323', 'Id': '11506'},125_107:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can we prove that $h(x) = g(f(x))$ is a reduction function for $A \\leq_m C$,</p>\n\n<p>if $f$ is the reduction function of  $A \\leq_m B$ and $g$ is the reduction function for  $B \\leq_m C$</p>\n\n<p>The given Proposition is: $A \\leq_m B, B \\leq_m C \\Rightarrow A \\leq_m C$</p>\n\n<p>I was thinking about using $HALT_{TM}$ for A. So on input $\\langle M, w\\rangle \\in A$ if and only if $\\langle M'',w'' \\rangle \\in  C$</p>\n\n<p>The output of A would be $ \\langle M', w' \\rangle$ and the output of B would be $\\langle M'',w'' \\rangle$</p>\n\n<p>If the constructed $M$ rejects the input $x$, then it loops forever, so $C$ is not recursive if $A$ is not recursive</p>\n\n<p>If this isn't sufficient, then what am I missing?</p>\n", 'ViewCount': '318', 'Title': 'How to prove Transitive property of Reducibility with a TM?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:32:52.450', 'LastEditDate': '2013-08-22T14:32:52.450', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11537', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-04-24T11:19:14.237', 'Id': '11536'},125_108:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a question, i was trying to reduce 3-SAT to a particular graph problem and i'm not quite sure about a thing i used in the reduction.\nIn fact the reduction build a bipartite graph, the edge $(x_1,c_1)$ exist if the variable $x_1$ is in the clause number 1, the costs on that edge are dependent on the truthfulness of the variable $x_1$, cost 1 if $x_1$ is true and 0 elsewhere. My question :is it permitted in a reduction or should i have the entire graph instance independent from values taken by the variables ?</p>\n\n<p>Thank you all!</p>\n", 'ViewCount': '110', 'Title': 'Reduction from 3-SAT to a graphe problem', 'LastEditorUserId': '7934', 'LastActivityDate': '2013-04-28T00:16:23.053', 'LastEditDate': '2013-04-28T00:16:23.053', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '11544', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7880', 'Tags': '<complexity-theory><graphs><np-complete><reductions><3-sat>', 'CreationDate': '2013-04-24T22:56:55.940', 'Id': '11541'},125_109:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose you are given a polynomial-time algorithm for the following problem related to INDEPENDENT SET:</p>\n\n<p>INDEPENDENT SET VALUE</p>\n\n<p>Input: An undirected graph G.</p>\n\n<p>Output:The size of the largest independent set in G (but not the set itself).</p>\n\n<p>Show how you can use this algorithm to solve the INDEPENDENT SET problem in polynomial time: given a graph G, return an independent set which is as large as possible.</p>\n\n<p>Any help would be really appreciated. I am pretty lost in this question</p>\n', 'ViewCount': '132', 'Title': 'How to reduce INDEPENDENT SET to INDEPENDENT SET SIZE?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-26T09:48:23.050', 'LastEditDate': '2013-04-26T09:48:23.050', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7909', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions>', 'CreationDate': '2013-04-26T08:16:10.927', 'FavoriteCount': '1', 'Id': '11570'},125_110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's say I have an optimization problem called $k$-foo which asks for a solution of size $k$ minimizing some quality criterion.</p>\n\n<p>Now the corresponding decision problem $foo(M)$ would be: <br> Is there a solution to foo with quality at least $M$ of size $k$.</p>\n\n<p>For problems on one parameter (for example vertex cover) it is obvious that solving the optimization problem sovles the decision problem.</p>\n\n<p>But here I do not see such a correspondance between the $k$-foo optimization problem and the $foo(M)$ decision problem. How does for example showing that $foo(M)$ is NP-hard implies that $k$-foo is NP-hard?</p>\n\n<p>The $k$-center problem is an example of such a problem where the decision version takes the radius as input and asks wether a solution of size $k$ exists.  </p>\n", 'ViewCount': '80', 'Title': 'Decision vs Optimization version for Problems of two Parameters', 'LastEditorUserId': '7921', 'LastActivityDate': '2013-04-26T23:12:46.047', 'LastEditDate': '2013-04-26T23:12:46.047', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7921', 'Tags': '<reductions><optimization><np-hard><decision-problem>', 'CreationDate': '2013-04-26T22:04:14.953', 'FavoriteCount': '1', 'Id': '11589'},125_111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '106', 'Title': 'Is linear-time reduction symmetric?', 'LastEditDate': '2013-05-01T10:12:30.693', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Bruce', 'PostTypeId': '1', 'OwnerUserId': '7984', 'Body': '<p>By reduction I mean the following:</p>\n\n<blockquote>\n  <p>Problem X linear reduces to problem Y if X can be solved with:<br>\n  a) Linear number of standard computational steps.<br>\n  b) Constant calls to subroutine for Y.  </p>\n</blockquote>\n\n<p>If a problem X reduces to a problem Y, is the opposite reduction also possible? Say</p>\n\n<p>X = Given an array tell if all elements are distinct<br>\nY = Sort an array using comparison sort  </p>\n\n<p>Now, X reduces to Y in linear time i.e. if I can solve Y, I can solve X in linear time. Is the reverse always true? Can I solve Y, given I can solve X? If so, how?</p>\n', 'Tags': '<complexity-theory><reductions>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-01T10:12:30.693', 'CommentCount': '0', 'AcceptedAnswerId': '11688', 'CreationDate': '2013-04-30T20:30:10.923', 'Id': '11687'},125_112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to show that non-emptiness of context free language is P-complete. So, I am trying to reduce CVP to this problem by generating grammar from circuit. I consider all type of gates in circuit and I make right production in grammar. </p>\n\n<p>I hope that it is good way to prove that it is P-complete, but I have a problem with showing that it is log-space reduction. I think that if I have this circuit, I need only one pointer to the structure, because I can directly write the production. Howerver, I need also have information how the non-terminal symbol is named. Of course, I can use binary numbers for variable names (and it is log-space), but it seems to me that I need know all names to produce grammar production. I have no idea how to go in this graph (circuit) and give a names of next non-terminals and use only log-space.</p>\n\n<p>Could anyone explain me how to prove that it is log-space reduction? </p>\n', 'ViewCount': '55', 'Title': 'Reduction CVP to CFG problem', 'LastActivityDate': '2013-05-02T13:46:54.640', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8009', 'Tags': '<context-free><reductions>', 'CreationDate': '2013-05-02T13:46:54.640', 'Id': '11732'},125_113:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to reduce $MAX3SAT$ to $MAX2SAT$ ...<br>\nMAX-n-SAT : given $\\phi $ n-CNF formula and number k does $\\phi$ has an assignment that satisfy k clauses? </p>\n', 'ViewCount': '62', 'Title': 'reducing Max3SAT to Max2sat', 'LastActivityDate': '2013-05-02T21:51:27.307', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11742', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7934', 'Tags': '<algorithms><np-complete><reductions><approximation>', 'CreationDate': '2013-05-02T20:59:20.690', 'Id': '11739'},125_114:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This might be a bit of an abstruse question, but it's something I've been trying to prove.</p>\n\n<p>I'm trying to show that it is undecidable whether a given Turing Machine is a member of the set of all Turing Machines that either always halt, or have non-halting loops where all of which can be detected (a positive decision made on it's existence) by some Turing Mahcine.</p>\n\n<p>I'm trying to do a reduction from the Entscheidungsproblem, and my proof looks something like this:</p>\n\n<p>Create a Turing machine $D$ on input $&lt;M,w&gt;$ that does the following:</p>\n\n<ol>\n<li><p>Mechanically create TM $M_2$ which does the following on $x$:</p>\n\n<ol>\n<li>if $M$ accepts $w$ (via simulation from UTM): accept $x$.</li>\n<li>if $M$ rejects $w$: loop in a manner such that $M_2$ would not be a member of the aforementioned set.</li>\n</ol></li>\n<li><p>Run decider for above problem on $M_2$:</p>\n\n<ul>\n<li>if decider accepts, it should accept because if $M$ accepts $w$, $M_2$ must always halt and must be a member of the set in question.</li>\n<li>if decider rejects, it should reject because if $M$ does not accept $w$, $M_2$ must have a non mechanically detectable loop and is not in the set.</li>\n</ul></li>\n</ol>\n\n<p>The above Turing Machine $D$ should therefore decide Entscheidungsproblem and shows the reduction. However, I'm not sure how to show that it possible to mechanically create a loop which cannot be mechanically detected, or whether an alternate method of proof would be adequate.</p>\n\n<p>Any insight in this proof would be appreciated.</p>\n", 'ViewCount': '111', 'Title': 'Undecidability of whether a given TM halts or only has loops which can be detected by some TM', 'LastEditorUserId': '8262', 'LastActivityDate': '2013-06-19T01:38:13.963', 'LastEditDate': '2013-05-20T01:15:44.853', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '1', 'OwnerDisplayName': 'Phillip Huff', 'PostTypeId': '1', 'OwnerUserId': '8262', 'Tags': '<turing-machines><reductions><halting-problem><undecidability>', 'CreationDate': '2013-05-19T01:12:03.770', 'Id': '12141'},125_115:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If A many-one reduces to B, does the complement of A many-one reduce to the complement of B? My gut says no but I am having a hard time finding a counterexample.</p>\n', 'ViewCount': '115', 'Title': 'If A many-one reduces to B, does the complement of A many-one reduce to the complement of B?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-06-20T02:38:20.557', 'LastEditDate': '2013-05-21T01:57:38.250', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8273', 'Tags': '<complexity-theory><formal-languages><reductions>', 'CreationDate': '2013-05-20T20:07:12.047', 'Id': '12168'},125_116:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a set of rectangles, $D = \\{ (a_1, b_1), (a_2, b_2) \\dots , (a_n, b_n) \\}$, where in each pair $(a_i, b_i)$, $a_i$ represents the height of the rectangle and $b_i$ the width, and given another pair $(w, h)$ representing the width and height of a container $C$, does exist a way that taking some of the squares in $D$, the <strong>whole</strong> container C is perfectly filled? Here, $a_i, b_i, w, h \\in \\mathbb N$.</p>\n\n<p>I am trying to reduce it from Subset Sum, but can't find the way... Hope you guys can give me a hint over it!</p>\n", 'ViewCount': '38', 'Title': 'Showing filling a container with rectangles is hard by reducing from SUBSET-SUM', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-30T23:52:12.767', 'LastEditDate': '2013-05-30T23:52:12.767', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12205', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8287', 'Tags': '<complexity-theory><np-complete><reductions><np><polynomial-time>', 'CreationDate': '2013-05-21T21:33:02.157', 'Id': '12202'},125_117:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Input</strong>: A set of $n$ Users $U=\\{u_1, ..., u_n\\}$ and a set of $m$ products $I=\\{i_1, ..., i_m\\}$. Associated with each pair $u \\in U$ and $i \\in I$  is the probability $p_{u,i}$ of $u$ purchasing the product $i$.<br/>\n  <strong>Task</strong>: Assign each user exactly $k$ products so that the following objective function is maximized:<br/>\n  $$\\sum_{i \\in I(U)} ({1-\\prod_{u\\in U(i)}{(1-p_{u,i})}})$$<br/>\n  Where $I(U)\\subseteq I$ is the set of products assigned to some user, and $U(i) \\subseteq U$ is the set of users to whom a product $i$ is assigned.</p>\n</blockquote>\n\n<p>Question: Is this problem NP-Hard?</p>\n', 'ViewCount': '56', 'Title': 'Hardness of a special case of maximum matching', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-28T07:27:34.407', 'LastEditDate': '2013-05-28T07:27:34.407', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8344', 'Tags': '<complexity-theory><reductions><np-hard><matching>', 'CreationDate': '2013-05-25T02:15:10.840', 'Id': '12260'},125_118:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So we know that there exists a Turing Machine $M$ and a polynomial $T$ such that:</p>\n\n<ul>\n<li>$M$ halts on all inputs within at most $T(|x|)$ steps</li>\n<li>If $x$ is in $L$ then $M$ accepts $x$</li>\n<li>If $x$ is not in $L$ then $M$ rejects $x$</li>\n</ul>\n\n<p>We need to show that for any other problem $L'$, there exists a polynomial time computable function $f$ such that for all $x$, $f(x)$ is in $L'$ if and only if $x$ is in $L$.</p>\n\n<p>I imagine the answer is simple but I'm stumped.</p>\n", 'ViewCount': '90', 'Title': u"Prove that if a problem L can be decided in polynomial time, then L \u2264p L' for any other problem L'", 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-28T17:44:24.253', 'LastEditDate': '2013-05-28T17:44:24.253', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8402', 'Tags': '<complexity-theory><reductions><decision-problem><polynomial-time>', 'CreationDate': '2013-05-28T09:11:53.633', 'Id': '12329'},125_119:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So, there are multiple possible definitions of "np-complete", two of which being:  </p>\n\n<ol>\n<li><p>A decision problem $L$ is np-complete if and only if:  $L \\in \\text{NP}$  and  $\\forall L\' \\in \\text{NP}: L\' \\preceq_{p} L$</p></li>\n<li><p>A decision problem $L$ is np-complete if and only if:  $L \\in \\text{NP}$  and  there exists a np-complete problem $L \\in \\text{NP}$ such that: $L\' \\preceq_{p} L$</p></li>\n</ol>\n\n<p>My question is, why are those two definitions equivalent, or put differently, (why) is np-complete an equivalence class? </p>\n\n<p>If it is an equivalence class I can understand equivalence of the above two definitions, but I fail to see why this is the case, since the (one-to-many) poly-time reduction $\\preceq_{p}$ is not symmetric... :-/</p>\n', 'ViewCount': '90', 'Title': 'Is np-complete an equivalence class?', 'LastActivityDate': '2013-05-28T23:29:25.010', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12347', 'Score': '3', 'OwnerDisplayName': 'user2429385', 'PostTypeId': '1', 'OwnerUserId': '8426', 'Tags': '<complexity-theory><complexity-classes><reductions><np><np-complete>', 'CreationDate': '2013-05-28T17:09:44.347', 'Id': '12346'},125_120:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If ${A}{ \\le _M} {{B}} $ then $\\overline A { \\le _M}\\overline B$ since the mapping reduction function is computable. </p>\n\n<p>So, if ${A_{TM}}{ \\le _M}\\overline {{A_{TM}}} $ then $\\overline{A_{TM}}{ \\le _M} {{A_{TM}}} $, hence $A{}_{TM} \\notin RE$. However, $A{}_{TM} \\in RE$.</p>\n\n<p>So is the claim above is true?</p>\n', 'ViewCount': '87', 'Title': 'The complement of the acceptance problem reduces to the acceptance problem: ${A_{TM}}{ \\le _M}\\overline {{A_{TM}}} $ is this claim true?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-05-31T13:04:46.543', 'LastEditDate': '2013-05-31T13:04:46.543', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8462', 'Tags': '<computability><reductions><computation-models>', 'CreationDate': '2013-05-31T11:54:45.417', 'Id': '12396'},125_121:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having trouble understanding reduction. Lets say you have a decision problem A that is NP-Complete. Also, another problem B the can be reduced from A.</p>\n\n<p>What can you say about B if:</p>\n\n<p>1) The reduction is done in polynomial time<br>\n2) The reduction is done in exponential time  </p>\n\n<p>I know that if A is reduced to B means that if we knew how to solve B, then solving A would be easy. But I don't understand what 1 &amp; 2 signify. </p>\n\n<p>Would it be right to say that for 1)<br>\nB is in the same Class as A  </p>\n\n<p>And for 2)<br>\nThat B > then NP-Complete?</p>\n", 'ViewCount': '75', 'Title': 'Exponential reduction vs Polynomial Reduction', 'LastActivityDate': '2013-05-31T13:50:21.463', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12398', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8463', 'Tags': '<np-complete><reductions><polynomial-time>', 'CreationDate': '2013-05-31T12:23:20.910', 'Id': '12397'},125_122:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to show that \n$$EQ_{DTM} = \\{ (\\langle M_1\\rangle,\\langle M_2\\rangle) \\mid M_1\\text{ and } M_2 \\text{ are  DTMs  and } L(M_1)=L(M_2)\\}$$\n and \n$$\\overline{EQ_{DTM}}$$\n are not semi-decidable. I think there must be a reduction from the complement of the halting problem.</p>\n', 'ViewCount': '140', 'Title': 'Show that the equivalence problem for deterministic Turing machines and its complement is not semi-decidable', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-02T19:23:57.457', 'LastEditDate': '2013-06-02T00:57:25.937', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8480', 'Tags': '<turing-machines><reductions><undecidability>', 'CreationDate': '2013-06-01T19:58:49.277', 'Id': '12417'},125_123:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let  consider a general version of <a href="http://en.wikipedia.org/wiki/Two_Generals%27_Problem" rel="nofollow">Two Generals\' Problem</a>, when there are $n$ generals located on the arbitrary graph and they should agree on exactly the same value whether to attack or not to attack. </p>\n\n<p>It\'s well known  that Two Generals\' Problem represents a version of the <a href="http://en.wikipedia.org/wiki/Consensus_%28computer_science%29" rel="nofollow">Consensus Problem</a> with unlimited number of the stopping failures, I think this is the only reason why Two Generals\' Problem and Generals\' Problem (with $n$ generals) don\'t have solution.</p>\n\n<p>There is a proof of lacking solution for Two Generals\' Problem (can be found in the textbook of Lynch).</p>\n\n<p>The following is the exercise from the textbook of Lynch, that I have not solved so far.</p>\n\n<p>Show that a solution to the (deterministic) coordinated attack problem (Generals\' Problem) for any nontrivial connected graph implies a solution for the simple graph consisting of two processes connected by one edge. (Therefore, this problem is unsolvable in any nontrivial graph.)</p>\n\n<p>Apparently, there is a reduction from an edge case to graph. But how to show it mathematically rigorous?</p>\n\n<p><strong>Addendum:</strong></p>\n\n<p>Can I say something like this?\nWhen we are given the primary problem of Two Generals and they initial values $a_i$ (inclination whether to attack or not), we in arbitrarily add more dummy generals with the only requirement if $a_1=a_0=a$ for primary problem set all dummy\'s general input to $a$, otherwise set arbitrary input value $b \\in \\{0,1\\}$. Find the solution on the graph, the solution on the graph is the solution for the primary problem. </p>\n', 'ViewCount': '157', 'LastEditorDisplayName': 'user742', 'Title': 'Coordinated Attack Problem On The Arbitrary Graph', 'LastActivityDate': '2013-09-20T17:48:32.680', 'LastEditDate': '2013-09-20T09:33:24.167', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4778', 'Tags': '<algorithms><complexity-theory><graph-theory><reductions><distributed-systems>', 'CreationDate': '2013-06-07T13:49:01.323', 'Id': '12508'},125_124:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working on old MC-Questions about decidability und don\'t have the answers to the following ones:</p>\n\n<p>1.) $L_1$ and $L_2$ are not decidable $\\Rightarrow$ No superset of $L_1 \\cup L_2$ is decidable</p>\n\n<p>2.) For Turing-acceptable languages L is "L = $\\emptyset$" a non-trivial property.</p>\n\n<p>3.) There are context-free languages $L_1$ and $L_2$ so that $L_1 \\cap L_2$ is not decidable.</p>\n\n<p>4.) $L$ is decidable $\\Leftrightarrow$ $L \\le \\{0\\}^* \\cdot \\{1\\}^*$</p>\n\n<p>I think 1.) is false, because $\\Sigma^*$ as a superset of many undecidable languages for example is decidable and 2.) is true, because there are Turing-acceptable languages with (exactly one) and without the property. I have no idea at 3.) and 4.). </p>\n', 'ViewCount': '233', 'Title': 'Multiple-Choice Questions about decidability', 'LastActivityDate': '2013-06-08T12:44:09.483', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8480', 'Tags': '<turing-machines><context-free><reductions><undecidability>', 'CreationDate': '2013-06-08T12:30:17.683', 'Id': '12527'},125_125:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The notion of <a href="http://en.wikipedia.org/wiki/Polynomial-time_reduction" rel="nofollow">polynomial time Turing reductions</a> (Cook reductions) is an abstraction of a very intuitive concept: efficiently solving a problem by using another algorithm as a subroutine. </p>\n\n<p>For example, by stating "$A$ is polynomial time Turing reduced to $B$", we indicate that we can solve the problem $A$ in a polynomial number of steps by making use of an algorithm which can solve the problem $B$.</p>\n\n<p>Then if $B$ is in $\\mathsf{NP}$, why not $A$?</p>\n', 'ViewCount': '314', 'Title': 'Why NP is not closed under Turing reduction', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-08T20:38:39.947', 'LastEditDate': '2013-06-08T20:38:39.947', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'Zhong Yantao', 'PostTypeId': '1', 'Tags': '<complexity-theory><reductions><closure-properties><np>', 'CreationDate': '2013-06-08T09:08:33.743', 'Id': '12541'},125_126:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the book on complexity by Arora and Barak, there is an exercise to show $Space(n)\\neq NP$, the proof of which goes by showing that $NP$ is closed under Karp reductions, while $Space(n)$ isn't.</p>\n\n<p>To show that $Space(n)$ isn't closed under Karp reductions, the suggested technique (both in the solutions given at my place of study as well as those given at many other universities) is to assume we have a TM that decides language $L$ in $Space(n^2)$. Now take an encoding $enc(x)$ of some $x$ in $L$ with $|enc(x)| = n$ and blow it up (in quadratic, thus polynomial time) to an encoding $enc'(x)$ of $x$ with $|enc'(x)| = n^2$ by padding the smaller encoding with $n^2-n$ padding symbols. Now we take the same TM, and it can decide $L$ in space linear in $enc'(x)$ by ignoring the padding stuff and just operating on $enc(x)$. This implies that $Space(n^2) \\subseteq Space(n)$, which contradicts the space hierarchy theorem, so $Space(n)$ can't be closed under Karp reductions.</p>\n\n<p>My problem here is that while I realize that we can easily show that $NP$ is closed under Karp reductions, it somewhat confuses me regarding what this says about $NTime(s(n))$. It seems to me that this approach will also work to show that $NTime(s(n))$ isn't closed under Karp reductions for any time-constructible function s(n) using the time hierarchy theorem, or am I mistaken here?</p>\n", 'ViewCount': '95', 'Title': 'Space(n) not closed under Karp reductions - what about NTime(n)?', 'LastEditorUserId': '6689', 'LastActivityDate': '2013-06-16T23:04:50.010', 'LastEditDate': '2013-06-16T19:32:14.977', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12704', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6689', 'Tags': '<complexity-theory><reductions><closure-properties>', 'CreationDate': '2013-06-16T18:31:07.150', 'Id': '12702'},125_127:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm working on old multiple choice exams and would like to know if the following statements are true or false:</p>\n\n<p>a) $L_1 \\le_p L_2 \\le_p L_3 \\Rightarrow L_1 \\le_p L_3$</p>\n\n<p>b) If $L \\in \\mathsf{NP}$ and $U \\le_p L$ holds for all languages $U \\in \\mathsf{PSPACE}$ then $\\mathsf{NP} = \\mathsf{PSPACE}$</p>\n\n<p>c) $L \\in P \\Leftrightarrow L \\le_p \\{a\\}^*$</p>\n\n<p>Statement a) was part of the lecture, Statesments b) and c): I don't know.</p>\n", 'ViewCount': '80', 'Title': 'Properties of polynomial time many-one reductions', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-25T14:41:00.997', 'LastEditDate': '2013-06-25T14:31:06.470', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8862', 'Tags': '<complexity-theory><reductions><polynomial-time>', 'CreationDate': '2013-06-25T13:12:53.783', 'FavoriteCount': '1', 'Id': '12889'},125_128:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am interested in showing connection between CSP (Constraint Satisfaction Problems) as it\'s defined in <a href="https://www.cs.duke.edu/courses/fall10/cps270/csp.pdf" rel="nofollow">CSP</a> (definition with Constraint graph, sometimes called binary CSP) and 3SAT problem, when domain of CSP contains of 7 values. </p>\n\n<p>The specific requirement is to show reduction from 3SAT to GAP CSP, when domain of CSP contains of 7 values.</p>\n\n<p>Let try to reduce 3SAT to CSP, every clause of 3SAT can be represent as a vertex of CSP, and edges connect two clauses (vertices) when these clauses have at least one common variable. Set the values (assignments) from the domain of 7 values to every nodes such that to ensure the consistency (each variable get the same value in all clauses). </p>\n\n<p>The problem is I cannot get what is so special about 7 values, apparently, we should have 8 different assignments to the vertices, how can I show that 7 values is enough?</p>\n\n<p>In addition, I still don\'t have a good intuition about the constraints, for me constraints represented by the edge of the graph, and they ensure the consistency of the assignment (each variable get the same value in all assignments).</p>\n\n<p>Having codded 3SAT as CSP how can we show the reduction to GAP CSP?</p>\n', 'ViewCount': '84', 'Title': 'Connection CSP and 3SAT', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-28T11:03:56.603', 'LastEditDate': '2013-06-28T11:03:56.603', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-06-28T07:01:20.957', 'Id': '12945'},125_129:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to solve the question 6.12 in Arora-Barak (Computational Complexity: A modern approach). The question asks you to show that the\n$\\mathsf{PATH}$ problem (decide whether a graph $G$ has a path from a given node $s$ to another given node $t$) which is complete for $\\mathbf{NL}$ is also contained in $\\mathbf{NC}$ (this is easy). The question then also makes a remark that this implies that $\\mathbf{NL} \\subseteq \\mathbf{NC}$ which is not obvious to me.</p>\n\n<p>I think in order to show this, one has to show that $\\mathbf{NC}$ is closed under logspace reductions, i.e</p>\n\n<p>$$(1): B \\in \\mathbf{NC} \\hbox{ and } A \\le_l B \\Longrightarrow A \\in \\mathbf{NC}$$ </p>\n\n<p>where $\\le_l$ is the logspace reduction defined as</p>\n\n<p>$$A \\le_l B :\\Longleftrightarrow (\\exists M \\hbox{ TM}, \\forall x)[x \\in A \\Longleftrightarrow M(x) \\in B]$$</p>\n\n<p>($M$ is a TM which runs in logarithmic space).</p>\n\n<p>I would appreciate if someone could give a tip for proving the statement $(1)$.</p>\n', 'ViewCount': '105', 'Title': '$\\mathbf{NC}$ is closed under logspace reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-22T15:25:58.423', 'LastEditDate': '2013-07-22T14:17:00.753', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13390', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9293', 'Tags': '<complexity-theory><reductions><closure-properties><complexity-classes><parallel-computing>', 'CreationDate': '2013-07-22T12:55:57.660', 'Id': '13387'},125_130:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am having a little trouble understanding what is meant by a poly-time reduction.\nSuppose I have two algorithms $A$ and $B$ and then I say that $A$ is reducible to $B$. Does polytime reduction mean that the algorithm that solves $A$ using $B$ as a helper runs in $O(n^k)$ for some $k$?</p>\n\n<p>So for example suppose:</p>\n\n<p>$A$ is an algorithm that takes as input a list of numbers and returns whether there is a sublist whose sum is $0$.</p>\n\n<p>$B$ is an algorithm that takes as input a list of numbers, and an integer $k$, and returns whether there is a sublist of length $k$ whose sum is $0$.</p>\n\n<p>Then </p>\n\n<pre><code>def A(L):\n     for i in range (1, len(L)+1)"\n           if B(L, i):\n                return true\n     return false\n</code></pre>\n\n<p>Since this $A$ calling $B$ as a helper runs in $O(n)$ so can this be described as a polytime reduction from $A$ to $B$?</p>\n', 'ViewCount': '450', 'Title': 'What does a polynomial time reduction mean?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-07-31T15:40:51.483', 'LastEditDate': '2013-07-31T15:40:10.873', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13543', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9410', 'Tags': '<time-complexity><reductions>', 'CreationDate': '2013-07-31T15:06:30.910', 'Id': '13541'},125_131:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am looking for an example, which corresponds to what I've learned in my Applied Automata Theory Class:</p>\n\n<p>Given a NFA $\\mathcal{A}$, </p>\n\n<ul>\n<li>a $\\approx _\\mathcal{A}$ quotient automaton can be bigger then a $\\sim_\\mathcal{A}$ quotient automaton and this can be bigger than an optimal quotient </li>\n<li>and an optimal quotient does not need to be the smallest equivalent NFA.</li>\n</ul>\n\n<p>$\\approx _\\mathcal{A}$ denotes the bisimulation relation (block refinement algorithm) and $\\sim_\\mathcal{A}$ denotes the canonical congruence, where $p \\sim_\\mathcal{A} q \\text{ iff } \\delta^*(p,w) \\in F \\text{ iff } \\delta^*(q,w) \\in F$, where DFA $\\mathcal{A}= (Q, \\Sigma, q_0, \\delta, F)$.</p>\n\n<p>Follow-up:</p>\n\n<p>The original Automaton $\\mathcal{A}$ over $\\Sigma={\\{a,b\\}}$ recognizing $\\mathcal{L} = \\Sigma a^*$:</p>\n\n<p>The original automaton $\\mathcal{A} = (\\{1,2,3,4,5,6\\}, \\Sigma, 1, \\Delta, \\{{3,4}\\}) $ with $\\Delta$:\n\\begin{pmatrix}\n&amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5 &amp; 6\\\\\n1 &amp;- &amp; b &amp; a &amp; -&amp; -&amp;- &amp;  \\\\\n2 &amp;b &amp; b &amp; - &amp; a &amp; -&amp;- &amp;  \\\\\n3 &amp;- &amp; b &amp; - &amp; a&amp; a&amp;- &amp;  \\\\\n4 &amp;- &amp; b &amp; - &amp; a&amp; a&amp;- &amp;  \\\\\n5 &amp;- &amp; - &amp; - &amp; -&amp; -&amp;b &amp;  \\\\\n6 &amp;- &amp; - &amp;  &amp; a&amp; b&amp;b &amp;  \\\\\n\\end{pmatrix}</p>\n\n<p>The quotient automaton $\\mathcal{A}_{\\approx}  = (\\{12,34,5,6\\}, \\Sigma, 12, \\Delta_{\\approx}, \\{{34}\\}) $ with $\\Delta_{\\approx}$:\n\\begin{pmatrix}\n&amp; 12 &amp; 34 &amp; 5 &amp; 6\\\\\n12 &amp;b &amp; a &amp; - &amp; - \\\\\n34 &amp;b &amp; a &amp; a &amp; - \\\\\n5 &amp;- &amp; - &amp; - &amp; b \\\\\n6 &amp;- &amp; a &amp; b &amp; b  \\\\\n\\end{pmatrix}</p>\n\n<p>The quotient automaton $\\mathcal{A}_{\\sim}  = (\\{126,34,5\\}, \\Sigma, 126, \\Delta_{\\sim}, \\{{34}\\}) $ with $\\Delta_{\\sim}$:\n\\begin{pmatrix}\n&amp; 126 &amp; 34 &amp; 5 \\\\\n126 &amp;b &amp; a &amp; b \\\\\n34 &amp;b &amp; a &amp; a  \\\\\n5 &amp;b &amp; - &amp; -  \\\\\n\\end{pmatrix}</p>\n\n<p>The optimal quotient automaton $\\mathcal{A_{OPT}}  = (\\{1256,34\\}, \\Sigma, 1256, \\Delta_{OPT}, \\{{34}\\}) $ with $\\Delta_{OPT}$:\n\\begin{pmatrix}\n&amp; 1256 &amp; 34 \\\\\n1256 &amp;a,b &amp; a \\\\\n34 &amp;a,b &amp; a  \\\\\n\\end{pmatrix}</p>\n\n<p>The first property is satisfied since $\\mathcal{A}_{\\approx}$ has 4 states and $\\mathcal{A}_{\\sim}$ has 3 states. But in my example $\\mathcal{A}_{OPT}$ is the smallest automaton recognizing the given language. When do they differ?</p>\n", 'ViewCount': '83', 'Title': 'Quality of Reduction of finite automata using different congruences', 'LastEditorUserId': '1382', 'LastActivityDate': '2013-08-01T12:30:08.780', 'LastEditDate': '2013-08-01T12:30:08.780', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1382', 'Tags': '<automata><reductions><finite-automata>', 'CreationDate': '2013-07-31T18:04:22.847', 'Id': '13546'},125_132:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im sorry if this question has some trivial answer which I am missing. Whenever I study some problem which has been proven undecidable, I observe that the proof relies on a reduction to another problem which has been proven to be undecidable. I understand that it creates some kind of an order on the degree of difficulty of a problem. But my question is - has it been proven that all problems which are undecidable can be reduced to another problem which is undecidable. Is it not possible that there exists a undecidable problem which can proved to have no reduction to any other undecidable problem (Hence to prove the undecidability of such a problem, one cannot use reductions). If we use reductions to create an order on the degree of computability then this problem cannot be assigned such a degree. </p>\n', 'ViewCount': '174', 'Title': 'Reductions among Undecidable Problems', 'LastActivityDate': '2013-08-01T13:30:51.810', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13564', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '8912', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-08-01T07:07:54.960', 'Id': '13559'},125_133:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a problem $\\Pi_1$ that I want to show that is NP-hard. I know that I must find an NP-hard problem $\\Pi_2$ and a polynomial time reduction $f()$ from instances of $\\Pi_2$ to $\\Pi_1$ such that $I_2$ is an Yes-instance of $\\Pi_2$ iff $I_1=f(I_2)$ is an Yes-instance of $\\Pi_1$.</p>\n\n<p>What if I find a (constant sized) family of reductions $f_i()$ such that $I_2$ is an Yes-instance of $\\Pi_2$ iff at least one $f_i(I_2)$ is an Yes-instance of $\\Pi_1$? Is this enough? Is there a way of translating this one in the "classical" definition? How to formalize this?</p>\n\n<p>I know that in the second situation I can say that I can\'t solve $\\Pi_1$ in polynomial time unless P=NP, but I\'m no sure that is equivalent of saying that $\\Pi_1$ is NP-hard.</p>\n', 'ViewCount': '99', 'Title': 'NP-Hardness reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-12T18:55:32.767', 'LastEditDate': '2013-08-11T13:21:08.910', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1373', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2013-08-09T23:22:09.297', 'Id': '13698'},125_134:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to prove that\n$\\textbf{REACH} \\leq_{\\textbf{L}} \\textbf{CIRCUIT-VALUE}$</p>\n\n<p>$\\textbf{REACH}$ is the well-known reachability problem: checking whether there is a connection from vertex $\\textbf{a}$ to vertex $\\textbf{b}$ in a graph $\\textbf{G}$.</p>\n\n<p>$\\textbf{CIRCUIT-VALUE}$ is the well-known CVP problem: checking whether a boolean circuit with gates outputs $\\textbf{TRUE}$.</p>\n\n<p>The reduction I\'m interested in is the "Mapping-Reduction".\nI\'ve considered, converting a given Graph to be used as input for the $\\textbf{CIRCUIT-VALUE}$-Problem. This conversion must be logarithmic.</p>\n', 'ViewCount': '94', 'ClosedDate': '2013-11-11T13:49:59.257', 'Title': 'Prove that REACH can be logarithmically reduced to CIRCUIT-VALUE', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-10T07:54:52.697', 'LastEditDate': '2013-09-06T15:04:46.460', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9978', 'Tags': '<complexity-theory><turing-machines><reductions>', 'CreationDate': '2013-09-04T09:07:34.980', 'Id': '14123'},125_135:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '179', 'Title': 'Showing NP-hardness of HALF-SAT', 'LastEditDate': '2013-09-06T16:05:06.570', 'AnswerCount': '2', 'Score': '0', 'OwnerDisplayName': 'Sebastian', 'PostTypeId': '1', 'OwnerUserId': '10048', 'Body': '<p>Yesterday I wrote my undergraduate exam in complexity theory. I had to leave off one question, which bugs me since then. Consider:\n$$ HALF-SAT = \\{ \\varphi \\mid \\varphi \\text{ is a formula which is satisfied by at least half of all assignments }\\} $$\nI\'d like to know how I can prove NP-hardness.</p>\n\n<p>FWIW, here\'s what I figured out:</p>\n\n<ol>\n<li>HALF-SAT is <em>probably</em> not $\\in$ NP, at least in no verifiable way I can think of (not really relevant to the question)</li>\n<li>SAT $\\preceq$ HALF-SAT doesn\'t work, at least not by just adding clauses with new variables, doesn\'t change satisfiable-assignments/arbitrary-assignments ratio</li>\n<li>TAUT $\\preceq$ HALF-SAT via $\\varphi \\mapsto \\varphi \\wedge x_{new}$, but that\'s coNP-hardness (together with NP-hardness this further lets me assume 1., intuitively)</li>\n</ol>\n\n<p>And no, this has nothing to do with the problem you find via googling "HALF-SAT".</p>\n', 'Tags': '<complexity-theory><reductions><np-hard>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-06T16:05:06.570', 'CommentCount': '2', 'AcceptedAnswerId': '14166', 'CreationDate': '2013-09-03T16:46:25.667', 'Id': '14165'},125_136:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>as the title states, I am trying to figure out if my approach to solving mapping reduction from $E_{TM}$ to some other language is correct. As you surely know, $E_{TM} = \\left \\{ &lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M)= \\emptyset \\right \\} $. What i am trying to check is whatever a string <strong>x</strong> is in L(M). My idea is to analyse $&lt;M&gt;$ in oder to check if there are any transition to $q_{accept}$, if so then L(M) cannot be empty. Now let\'s take another language, for instance let $REVERSE_{TM} = \\left \\{&lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M) = L(M)^{R} \\right \\} $ or even $REGULAR_{TM} = \\left \\{&lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M) \\ is \\ regular \\right \\} $.\nLet\'s prove that $E_{TM} \\leq_{m} REVERSE_{TM} $. Since i need to convert an istance <em>"yes"</em> <strong>w</strong> of $E_{TM}$ trought a function <strong>f</strong>, to <strong>f(w)</strong> which is an instance <em>"yes"</em> of $REVERSE_{TM}$. $f(&lt;M&gt;) = &lt;M^{\'}&gt;$, where $&lt;M^{\'}&gt;$ is a TM whose behaviour on input x is</p>\n\n<ol>\n<li><p>if $x \\neq x^{R}$ then accept.</p></li>\n<li><p>if $x = x^{R}$ then,</p>\n\n<ul>\n<li><p>analyse $&lt;M&gt;$ and if there are no transitions to $q_{accept}$ then accept</p></li>\n<li><p>else do not accept x </p></li>\n</ul></li>\n</ol>\n\n<p>Which language does M\' recognize? It should recognize $ \\Sigma^{*} $ if $L(M) = \\emptyset $ meanwhile it should match $ \\left \\{ x \\in \\Sigma^{*} \\mid x \\neq x^{R} \\right \\} $.\nWe know that $(\\Sigma^{*})^{R} = \\Sigma^{*}$, so $&lt;M\'&gt; \\in REVERSE_{TM} &lt;=&gt; L(M) = \\emptyset$. I think this mapping reduction should be correct but is it correct to let M\' analyse M in order to figure out if L(M) is really empty (if it\'s empty there should be no transition to $q_{accept}$) ? Or is there another way to solve these reduction from $E_{TM}$ ? </p>\n', 'ViewCount': '68', 'Title': 'Correct approach to Mapping Reduction from $E_{TM}$', 'LastActivityDate': '2013-09-07T14:27:57.417', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9989', 'Tags': '<formal-languages><turing-machines><reductions>', 'CreationDate': '2013-09-07T14:27:57.417', 'Id': '14194'},125_137:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '121', 'Title': '$\\mathsf{co\\text{-}NP}$ and Cook reductions', 'LastEditDate': '2013-09-16T07:26:19.233', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8942', 'FavoriteCount': '1', 'Body': '<p>Can someone help me understand the steps in this argument? There is a decision problem that is in $\\mathsf{co\\text{-}NP}$ (under standard Karp reductions) and is $\\mathsf{NP}$-hard with respect to Cook reductions. Does this imply that if it is in $\\mathsf{NP}$ then $\\mathsf{NP} = \\mathsf{co\\text{-}NP}$ and if so, why?</p>\n', 'Tags': '<complexity-theory><reductions><np-hard>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T07:26:19.233', 'CommentCount': '0', 'AcceptedAnswerId': '14286', 'CreationDate': '2013-09-12T08:36:22.790', 'Id': '14278'},125_138:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '237', 'Title': 'Minimal size of contracting a DAG into a new DAG', 'LastEditDate': '2013-11-03T18:16:54.507', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '10273', 'FavoriteCount': '3', 'Body': "<p>We have a DAG. We have a function on the nodes $F\\colon V\\to \\mathbb N$ (loosely speaking, we number the nodes). We would like to create a new directed graph with these rules: </p>\n\n<ol>\n<li>Only nodes with the same number can be contracted into the same new node. $F(x) \\neq F(y) \\Rightarrow x' \\neq y'$. (However, $x' \\neq y'\\nRightarrow F(x) \\neq F(y)$.)</li>\n<li>We add all the old edges between new nodes: $(x,y) \\in E \\land x' \\neq y' \\iff (x',y')\\in E'$.</li>\n<li>This new graph is still a DAG.</li>\n</ol>\n\n<p>What is the minimal $|V'|$? What is an algorithm creating a minimal new graph?</p>\n", 'Tags': '<algorithms><graphs><np-complete><reductions>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T04:56:53.490', 'CommentCount': '9', 'AcceptedAnswerId': '16277', 'CreationDate': '2013-09-23T08:24:13.643', 'Id': '14552'},125_139:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Why is the reduction $\\textbf{SAT} \\leq_P \\textbf{3SAT}$ possible, but $\\textbf{SAT} \\leq_P \\textbf{2SAT}$ not possible, given, that $\\textbf{SAT}$ is $\\textbf{NP}$-complete, $\\textbf{2SAT} \\in \\textbf{NP}$ and $\\textbf{3SAT} \\in \\textbf{NP}$?</p>\n', 'ViewCount': '118', 'Title': 'SAT not reducible to 2SAT', 'LastActivityDate': '2013-09-25T18:55:47.837', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14602', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9978', 'Tags': '<reductions>', 'CreationDate': '2013-09-25T15:32:21.143', 'FavoriteCount': '1', 'Id': '14596'},125_140:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '38', 'Title': 'On approximations and reductions', 'LastEditDate': '2013-10-01T23:30:34.090', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9753', 'FavoriteCount': '1', 'Body': '<p>This may be a naive question but I am a bit clueless. I was under the opinion that given two NP complete problems, $P1$ and $P2$, if $P2 \\in APX$ and $P1 \\notin APX$, then we cannot have a direct reduction $P2\\leq P1$ but we can have a reduction $P1\\leq P2$.</p>\n\n<p>In this paper on page 165 <a href="http://www.lancaster.ac.uk/staff/letchfoa/articles/cut-projection.pdf" rel="nofollow">http://www.lancaster.ac.uk/staff/letchfoa/articles/cut-projection.pdf</a>, there is a reduction $MAXCUT \\leq STABLESET$. That is, given an instance of <em>STABLESET</em>, I can find an instance of <em>MAXCUT</em>. Why cant I use the approximate solution for <em>MAXCUT</em> to find an approximate solution to <em>STABLESET</em>?</p>\n', 'Tags': '<complexity-theory><reductions>', 'LastEditorUserId': '9753', 'LastActivityDate': '2013-10-02T06:55:41.410', 'CommentCount': '0', 'AcceptedAnswerId': '14746', 'CreationDate': '2013-10-01T22:53:24.303', 'Id': '14741'},125_141:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The <em>MAXDICUT</em> problem on a directed graph $G$ is where one is given integer $t$ and a graph $G$ and one has to decide if there is a subset $S \\subset \\mathcal{V}(G)$ such that $$|\\{(i\\rightarrow j)\\in\\mathcal{E}(G)\\mid i\\in S \\text{ and } j\\cap S=\\emptyset\\}|\\geq t$$</p>\n\n<p>Consider a $(c^a,d^a)$-regular directed hypergraph $H$ (meaning every hyperedge $\\{i_1\\rightarrow i_2,i_3,i_4,\\dots,i_{c^a}\\}\\in\\mathcal{E}(H)$ has $c^a$ vertices with  $head(i_1\\rightarrow i_2,i_3,i_4,\\dots,i_{c^a})=i_1$ and every vertex is on $d^a$ hyperedges with each vertex being a head on only one hyperedge) on $n^a$ vertices with fixed $n\\geq 4$ and fixed $c,d\\geq 2$ and variable parameter $a\\geq 1$. Consider the problem of given an integer $t$ and a hypergraph $H$ with above parameters, one has to decide if there is a subset $S \\subset \\mathcal{V}(H)$ such that $$|\\{\\mathcal{I}=\\{i_1\\rightarrow i_2,i_3,i_4,\\dots,i_{c^a}\\}\\in\\mathcal{E}(H)\\mid i_1\\in S \\text{ and } \\mathcal{I}\\setminus i_1\\cap S=\\emptyset\\}|\\geq t$$</p>\n\n<p>Call this problem <em>REGULAR-HYPERGRAPH-MAXDICUT</em>. Clearly this problem is NP-complete. Note that a directed $d$-regular graph on $n$ vertices with one outgoing edge per vertex is a $(2,d)$-regular hypergraph on $n$ vertices. So <em>REGULAR-HYPERGRAPH-MAXDICUT</em> $\\leq$ <em>MAXDICUT</em>.</p>\n\n<p>Now consider a $(c^a,d^a)$-regular directed hypergraph $H$ on $n^a$ vertices with fixed $n\\geq 4$ and fixed $c,d\\geq 2$ and variable parameter $a\\geq 1$. Given this graph, form a sequence of $d^a$-regular directed graphs $G_j$ on $n^a$ vertices for $j=1\\rightarrow c^a-1$ by projecting the hyperedge $\\{i_1\\rightarrow i_2,i_3,i_4,\\dots,i_{c^a}\\}\\in\\mathcal{E}(H)$ to the edge $\\{i_1 \\rightarrow i_{j+1}\\}$ and dropping the remaining possibles projections. Conversely given such $G_i$s, we can glue each set of edges from $i_1$ to get back the hypergraph $H$. Note each vertex of $G_i$ lies on $d^a$ edges.</p>\n\n<p>Given this graph, form a sequence of $r^m$-regular directed graphs $\\mathcal{G}_j$ on $N^m$ vertices for $j=1\\rightarrow r^m-1$ by projecting the hyperedge $\\{i_1\\rightarrow i_2,i_3,i_4,\\dots,i_{c^a}\\}\\in\\mathcal{E}(\\mathcal{H}([G,m]))$ to the edge $\\{i_1 \\rightarrow i_{j+1}\\}$ and dropping the remaining possibles projections. Conversely given such $\\mathcal{G}_j$ graphs, we can glue each set of edges from $i_1$ to get back the hypergraph $\\mathcal{H}[G,m]$. Note each vertex of $G_i$ lies on $r^m$ edges. </p>\n\n<p>Now from the $G_j$ construct the graph sum $\\mathcal{G}$ which is the directed graph with the hyperedge $\\{i_1\\rightarrow i_2,i_3,i_4,\\dots,i_{c^a}\\}\\in\\mathcal{E}(\\mathcal{H}([G,m]))$ replaced by a sequence of edges $\\{i_1\\rightarrow i_2,i_1\\rightarrow i_3,i_1\\rightarrow i_4,\\dots,i_1\\rightarrow i_{c^a}\\}\\in\\mathcal{E}(\\mathcal{G}$. It is clear \\emph{MAXDICUT} problem on $\\mathcal{G}$ solves the <em>HYPERGRAPH-MAXDICUT</em> problem in $\\mathcal{H}([G,m])$.</p>\n\n<p>Can the above give <em>MAXDICUT</em> $\\leq$ <em>REGULAR-HYPERGRAPH-MAXDICUT</em>? (THE ISSUE IS WHEN WE CHOOSE AN HYPEREDGE WE CHOOSE ALL ITS VERTICES. THIS IS NOT THE CASE WHEN WE REPLACE THE HYPERGRAPH WITH A DIRECTED GRAPH).</p>\n\n<p>Is <em>REGULAR-HYPERGRAPH-MAXDICUT</em> $\\leq_{APX}$ <em>MAXDICUT</em> and <em>MAXDICUT</em> $\\leq_{APX}$ <em>REGULAR-HYPERGRAPH-MAXDICUT</em>? This will give a constant factor approximation to <em>REGULAR-HYPERGRAPH-MAXDICUT</em> where the constant factor is independent of $a$.</p>\n\n<p>Can we generalize to a possible version of <em>IRREGULAR-HYPERGRAPH-MAXDICUT</em>? Would this yield constant factor approximations to <em>IRREGULAR-HYPERGRAPH-MAXDICUT</em> as well?</p>\n', 'ViewCount': '39', 'Title': 'Constant factor approximation of hypergraph maxdicut', 'LastEditorUserId': '9753', 'LastActivityDate': '2013-10-02T19:15:11.187', 'LastEditDate': '2013-10-02T19:15:11.187', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<reductions><approximation-algorithms><max-cut>', 'CreationDate': '2013-10-02T08:29:17.627', 'Id': '14751'},125_142:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is known that HORN-3SAT is complete for $P$ under Logspace many-one reductions ($&lt;_L^m$). </p>\n\n<p>This implies that $\\bar{A} &lt;_L^m A$ for any $P$-complete problem $A$, where $\\bar{A}$ means the complement of $A$. This immediately follows from that fact that $P$ is closed under complement and the $P$-hardness of $A$. </p>\n\n<p>My question is to find such Logspace many-one reduction $\\bar{A} &lt;_L^m A$ for any $P$-complete problem $A$ (such as HORN-3SAT). The reduction must show the mapping between short certificates of $A$ and $\\bar{A}$. </p>\n\n<p>EDIT: As David stated in his comment on the case of HORN-3SAT problem,  we know that Logspace function exists but it seems that it is hard to find explicitly.</p>\n', 'ViewCount': '144', 'Title': '$P$-complete problems and Logspace reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-11T07:29:59.773', 'LastEditDate': '2013-10-11T07:29:59.773', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-10-09T12:54:01.173', 'FavoriteCount': '0', 'Id': '14947'},125_143:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've got this problem:</p>\n\n<blockquote>\n  <ul>\n  <li><p>Write down a definition of P-completeness analogous to the definition of\n  NP-completeness, i.e., using polynomial-time reductions.</p></li>\n  <li><p>Which problems are P-complete in this sense, and why?</p></li>\n  <li>Thus, what is the problem, i.e., what must be changed if the goal is to come\n  up with a more interesting notion of P-completeness?</li>\n  </ul>\n</blockquote>\n\n<p>I have an idea about the first part, but I don't have any idea about the second and third part. The first part is like the NP-Complete, and small change for P-Complete, which is wrong I know, but I want it that way!</p>\n", 'ViewCount': '129', 'Title': 'Definition P-Completeness', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-28T07:43:43.407', 'LastEditDate': '2013-10-28T07:43:43.407', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10795', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-10-16T14:33:48.637', 'FavoriteCount': '1', 'Id': '16138'},125_144:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>While Learning about removing null moves from NFA , I came across a thought....</p>\n\n<p>To <strong>Remove Epsilon moves</strong> we follow following steps :</p>\n\n<ol>\n<li>Find <strong>Closure of all states</strong> which have null moves</li>\n<li>Mark <strong>these states which have null moves</strong></li>\n<li><strong>Make a revised transition table without epsilon column</strong> and Find all possible transition for those marked states by using their Closures.</li>\n<li>you will get nfa without null moves/epsilon moves</li>\n</ol>\n\n<p>Where is the issue : Actually, Doubt arises when you think of an nfa like this :</p>\n\n<p>If we try to remove epsilon moves out of it...</p>\n\n<p><img src="http://i.stack.imgur.com/x4yZj.png" alt="enter image description here"></p>\n\n<p>Initial transition Table : \n<img src="http://i.stack.imgur.com/hZeZX.png" alt="enter image description here"></p>\n\n<p>Now finding closure for q0, q1 and q3.</p>\n\n<p><strong>Which is CL(q0) = {q0,q1,q2}\nCL(q1) = {q1,q2}\nCL(q3) = {q2,q3}\nWe find a transition table after following above steps which is :</strong> \n<img src="http://i.stack.imgur.com/XDT2A.png" alt="enter image description here"></p>\n\n<p>The question gets quite tricky...</p>\n\n<p>because now this nfa has q1,q2 where there is no way to reach them..</p>\n\n<p>So What do you think we will remove q1 and q2 as they are unreachable or we will draw a nfa with them... </p>\n', 'ViewCount': '1992', 'Title': 'Removing Null moves from NFA', 'LastEditorUserId': '10861', 'LastActivityDate': '2014-02-27T16:49:27.293', 'LastEditDate': '2013-10-20T07:59:28.647', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><reductions><finite-automata>', 'CreationDate': '2013-10-19T20:40:25.610', 'Id': '16237'},125_145:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this question I'm struggling with. </p>\n\n<p>Let $A=\\{&lt;i,n&gt;|\\;n \\in \\phi ^{(i)}\\}$. In other words, $A$ is the language defined by the set of all pairs $&lt;i,n&gt;$ such that $n$ is $\\leq_m$ to the $i$th Turing jump.\nA is definitely not an arithmetically definable language, and you can prove this by contradiction. </p>\n\n<p>I have to find a language, let's say $B$, that is more complex than $A$ $i.e.$ $B\\nleq_T A$. I thought about $B=\\{&lt;i,n&gt;|\\;n \\not\\in \\phi ^{(i)}\\}$, but I'm not sure about my reasoning, I think an oracle turing machine with an oracle $A$ couldn't reduce to $B$..</p>\n\n<p>And one last thing, do you think there exists a language that is more complex than any other (it doesn't reduce to anything)?</p>\n\n<p>If you have any hints that could help me solve those two questions I would be really grateful! </p>\n", 'ViewCount': '62', 'Title': 'What would be a not arithmetically definable language that is not Turing reducible to another given not arithmetically definable language?', 'LastActivityDate': '2013-10-24T16:13:26.107', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '16405', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<complexity-theory><computability><reductions><arithmetic>', 'CreationDate': '2013-10-21T00:29:52.033', 'Id': '16271'},125_146:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '102', 'Title': 'Direct reduction from Near-Clique to Clique', 'LastEditDate': '2013-10-22T13:16:24.780', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10913', 'FavoriteCount': '2', 'Body': '<p>An undirected graph is a Near-Clique if adding one more edge would make it a clique. Formally, a graph $G=(V,E)$ contains a near-clique of size&nbsp;$k$ if there exists $S\\subseteq V$ and $u,v\\in S$ where $|S|=k$, $(u,v)\\notin E$, and $S$&nbsp;forms a clique in $(V,E\\cup\\{(u,v)\\})$. How can I show a direct reduction from Near-Clique to Clique?</p>\n', 'Tags': '<complexity-theory><graph-theory><reductions><np>', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-10-23T03:08:34.873', 'CommentCount': '1', 'AcceptedAnswerId': '16349', 'CreationDate': '2013-10-22T09:31:12.100', 'Id': '16325'},125_147:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m interested in the question of how best to teach NP-completeness to computer science majors.  In particular, should we teach it using Karp reductions or using Turing reductions?</p>\n\n<p>I feel that the concepts of NP-completeness and reductions are something that every computer science major ought to learn.  However, when teaching NP-completeness, I\'ve noticed that the use of Karp reductions has some downsides.</p>\n\n<p>First of all, Karp reductions seem to be unnecessarily confusing for some students.  The intuitive notion of a reduction is "if I have an algorithm to solve problem X, then I can use it to solve problem Y, too".  That\'s very intuitive -- but it maps much better to Turing reductions than to Karp reductions.  As a result, I see students who are trying to prove NP-completeness get led astray by their intuition and form an incorrect proof.  Trying to teach both kinds of reductions and emphasizing this aspect of Karp reductions sometimes feels a little bit like needless formalism and takes up unnecessary class time and student attention on what feels like an inessential technical detail; it\'s not self-evident why we use this more restricted notion of reduction.</p>\n\n<p>I do understand the difference between Karp reductions and Turing (Cook) reductions, and how they lead to different notions of NP-completeness.  I realize that Karp reductions give us a finer granularity of distinctions between complexity classes.  So, for serious study of complexity theory, Karp reductions are obviously the right tool.  But for computer science students who are just learning this and are never going to go into complexity theory, I\'m uncertain whether this finer distinction is critical is critical for them to be exposed to.</p>\n\n<p>Finally, as a student, I remember feeling puzzled when I ran across a problem like "tautology" -- i.e., given a 3CNF formula, check whether it is a tautology.  What was confusing was that this problem is clearly hard: any polynomial-time algorithm for it would imply that $P=NP$; and solving this problem is obviously as hard as solving the tautology problem.  However, even though intuitively tautology is as hard as satisfiability, tautology is not NP-hard.  Yes, I understand today why this is the case, but at the time I remember being puzzled by this.  (What went through my head once I finally understood was: Why do we draw this distinction between NP-hard and co-NP-hard, anyway?  That seems artificial and not very well-motivated by practice.  Why do we focus on NP rather than co-NP?  They seem equally natural.  From a practical perspective, co-NP-hardness seems to have essentially the same practical consequences as NP-hardness, so why do we get all hung up on this distinction?  Yes, I know the answers, but as a student, I remember this just made the subject feel more arcane and poorly motivated.)</p>\n\n<p>So, my question is this.  When we teach NP-completeness to students, is it better to teach using Karp reductions or Turing reductions?  Has anyone tried teaching the concept of NP-completeness using Turing reductions?  If so, how did it go?  Would there be any non-obvious pitfalls or disadvantages if we taught the concepts using Turing reductions, and skipped the conceptual issues associated with Karp reductions?</p>\n\n<hr>\n\n<p>Related: see <a href="http://cs.stackexchange.com/a/11124/755">http://cs.stackexchange.com/a/11124/755</a> and <a href="http://cs.stackexchange.com/a/16376/755">http://cs.stackexchange.com/a/16376/755</a>, which mentions that the reason why we use Karp reductions in the literature is because it enables us to distinguish between NP-hardness and co-NP-hardness.  However, it does not seem to give any answer that\'s focused on a pedagogical perspective of whether this ability is critical for the learning objectives of an algorithms class that should be taken by every CS major.  See also <a href="http://cstheory.stackexchange.com/q/138/5038">http://cstheory.stackexchange.com/q/138/5038</a>, which has a similar discussion.</p>\n', 'ViewCount': '210', 'Title': 'Teaching NP-completeness - Turing reductions vs Karp reductions', 'LastEditorUserId': '755', 'LastActivityDate': '2013-10-24T05:18:25.377', 'LastEditDate': '2013-10-24T05:18:25.377', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<np-complete><reductions><education>', 'CreationDate': '2013-10-23T23:45:23.683', 'FavoriteCount': '1', 'Id': '16386'},125_148:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider $\\Pi$ to be the problem to decide if there is a subset of numbers that sum to $0$ in the given list of integers. </p>\n\n<p>How does one construct a promise problem equivalent to $xSAT$ from this? $xSAT$ is in $NP\\cap coNP$. </p>\n\n<p>How is it possible that the original problem was NP complete and the transformed problem is in coNP? </p>\n\n<p>Doesn't this mean NO instances also have short certificates for the original problem $\\Pi$?</p>\n", 'ViewCount': '64', 'Title': 'Promise problems', 'LastEditorUserId': '9753', 'LastActivityDate': '2013-10-28T16:32:29.723', 'LastEditDate': '2013-10-28T16:32:29.723', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9753', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2013-10-28T15:56:10.873', 'Id': '16505'},125_149:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove that every language that is not the empty set or {0,1}* is complete for NL (nondeterministic logarithmic space) under polynomial-time Karp reductions.</p>\n\n<p>I'm really not sure how to even approach this problem or what languages are being discussed if you exclude both the empty set and {0,1}*. Any suggestions to get me going in the right direction? Thanks!</p>\n\n<p><strong>Edit:</strong></p>\n\n<p>I feel like I may still be understanding the problem incorrectly. I seem to be finding that polynomial-time reductions can't be used to define NL completeness, but that's what I feel this question is asking. What am I thinking about wrongly here? Thanks.</p>\n", 'ViewCount': '95', 'Title': 'Proving languages are complete on NL?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-03T22:52:22.417', 'LastEditDate': '2013-11-03T22:52:22.417', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11153', 'Tags': '<complexity-theory><reductions><polynomial-time>', 'CreationDate': '2013-11-03T18:01:48.380', 'Id': '16677'},125_150:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '281', 'Title': 'CNF Generator for Factoring Problems', 'LastEditDate': '2013-11-07T21:03:05.140', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10572', 'FavoriteCount': '1', 'Body': '<p>I\'ve been reading these:</p>\n\n<ul>\n<li><a href="http://cstheory.stackexchange.com/questions/6755/fast-reduction-from-rsa-to-sat">Fast Reduction from RSA to SAT</a></li>\n<li><a href="http://cgi.cs.indiana.edu/~sabry/cnf.html" rel="nofollow">CNF Generator for Factoring Problems</a> (Also have C code implementation)</li>\n</ul>\n\n<p>I don\'t understand how the reduction from <a href="https://en.wikipedia.org/wiki/Integer_factorization" rel="nofollow">FACT</a> to <a href="https://en.wikipedia.org/wiki/Clausal_normal_form" rel="nofollow">$3\\text{-SAT}$</a> works. Are there any simple articles in which I can read about it?</p>\n\n<p>My final goal is to eventually implement a reduction from $3\\text{-SAT}$ to the <a href="https://en.wikipedia.org/wiki/Hamiltonian_path_problem" rel="nofollow">undirected Hamiltonian circuit problem</a>.</p>\n', 'Tags': '<algorithms><graph-theory><reductions><factoring><hamiltonian-path>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-13T22:15:26.360', 'CommentCount': '7', 'AcceptedAnswerId': '16805', 'CreationDate': '2013-11-07T06:57:01.380', 'Id': '16789'},125_151:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to show that Quadratic Programming is NP-hard.</p>\n\n<p>I am currently reading a couple of papers which state that QP is NP-Hard and prove it by transforming SAT to QP, however I am finding the diction quite tough since I am just a beginner in the field. Would anyone happen to know the answer to this question who can maybe explain it to me in simpler terms?</p>\n', 'ViewCount': '66', 'Title': 'Transforming SAT to Quadratic Programming in polynomial time', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T16:52:50.120', 'LastEditDate': '2013-11-12T16:52:50.120', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '17952', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11330', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2013-11-12T06:44:40.763', 'Id': '17946'},125_152:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a homework question I need to show an explicit reduction from independent set (of size k) to CNF-SAT. I don\'t have anything formal written out so I will just give an idea of what I think needs to be done, any feedback or hint/help would be greatly appreciated:</p>\n\n<p>So I figure that given my a graph $G$ (it doesn\'t state in the question but I am guessing it is undirected graph) and an integer $G$ my variables for the boolean formula that I will need to define composes of the following:</p>\n\n<p>$var(\\phi) = \\{s_{ij}\\ | 1\\leq i \\leq k, j\\in{V}\\}$ where $s_{ij}$ is the $i$-th element of the independent set $S$ is $j$, which is node in the graph $G$. Now I want to convert this into a series of clauses that will be a series of conjunctions so I have these in mind:</p>\n\n<p>Have one series of conjunctions that will be every "not pair" of elements, i.e. $(\\overline{s_{ia}}\\vee \\overline{s_{ib}})$, that will indicate that no two nodes are the same in the $i$-th spot in the independent set S. Another series of conjunctions that will consists of every 2,3,4, all the way to k pairs of elements such that no elements in the clause share an edge. Then we take the conjunctions of these two major groups and that will be my Boolean formula. Like I said any feedback or if you want me to clarify something would be great!</p>\n', 'ViewCount': '79', 'ClosedDate': '2013-11-13T22:06:09.400', 'Title': 'Giving an explicit reduction for IND-SET $\\leq_{p}$ CNF-SAT', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:05:35.303', 'LastEditDate': '2013-11-13T22:05:35.303', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2013-11-12T22:18:12.250', 'Id': '17972'},125_153:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following two languages, which are languages of TM descriptions:</p>\n\n<p>$$INFINITE = \\{ \\langle M \\rangle | \\mbox{M is a TM and L(M) is infinite} \\}$$</p>\n\n<p>$$A_{ALL} = \\{ \\langle M \\rangle | \\mbox{M is a TM and } L(M) = \\Sigma^* \\}$$</p>\n\n<p>Neither of these languages are decidable, recognizable, or co-recognizable. However, I believe they're in $\\Pi_2$, since a TM belongs to $INFINITE$ iff for every x, there is a string y and computation history H where y has length greater than x and H is a history that shows that M accepts y and a TM belongs to $A_{ALL}$ iff for every w, there is a computation history H that shows that M accepts w. (I'm not sure if this reasoning is correct or not, though).</p>\n\n<p>I have been wondering for a while whether either of these languages are mapping reducible to one another. I don't see a quick way to prove that the languages are <em>not</em> reducible to one another, but I similarly can't see a simple reduction in either direction.</p>\n\n<p>Are either of these languages reducible to the other? If so, how?</p>\n\n<p>Thanks!</p>\n", 'ViewCount': '51', 'Title': 'Is it possible to mapping reduce either of these languages to the other?', 'LastActivityDate': '2013-11-26T09:33:52.140', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18368', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><reductions>', 'CreationDate': '2013-11-25T07:37:46.777', 'Id': '18323'},125_154:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How do I precisely define the function which is a mapping reduction of A to B for the following examples?</p>\n\n<p>What is the process of figuring this out?</p>\n\n<p>Given: A and B are languages over the alphabet {0,1}.</p>\n\n<p>Examples:</p>\n\n<ul>\n<li>A is the language described by 1*0*, B is the language described by 01*0*</li>\n<li>A={w | the length of w is even}, B={w | the length of w is odd}</li>\n<li>A=B={w | the length of w is even}</li>\n<li>A={0,1}*, B={00,1,101}</li>\n</ul>\n\n<p>I am studying this material and I am not sure of how to 'precisely' define these functions. Could somebody provide me with solutions and a methodology to finding the solution?</p>\n", 'ViewCount': '53', 'Title': 'Finding a function which is a mapping reduction of A to B', 'LastEditorUserId': '11622', 'LastActivityDate': '2013-11-29T00:25:26.853', 'LastEditDate': '2013-11-29T00:22:45.743', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18458', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11622', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-11-25T23:31:44.567', 'Id': '18339'},125_155:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a <strong><em>really</em></strong> bad professor for my automata class. She is all over the place, except where she needs to be. </p>\n\n<p>I have two problems and I don't know how to even start. I know for some of you these problems might look simple but I'm really struggling.</p>\n\n<p>Here are the problems. </p>\n\n<ol>\n<li>Reduce Hamiltonian cycle problem to Traveling salesman problem. Only reduction algorithm is needed. No need for correctness proof.</li>\n<li>Reduce Hamiltonian path problem to a Hamiltonian cycle problem. Only reduction algorithm is needed. No need for correctness proof.</li>\n</ol>\n\n<p>Assume you are talking to dumb person. I really want to understand this, but unfortunately I'm learning not because of my professor but despite of her. </p>\n\n<p>Any help is appreciated.</p>\n", 'ViewCount': '127', 'Title': 'reduce hamiltonian cycle to a traveling salesman and hamiltonian path to hamiltonian cycle', 'LastEditorUserId': '10511', 'LastActivityDate': '2013-12-06T16:06:31.747', 'LastEditDate': '2013-12-03T02:50:35.020', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<reductions>', 'CreationDate': '2013-12-03T01:54:32.097', 'Id': '18554'},125_156:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read <a href="http://blog.computationalcomplexity.org/2011/10/if-you-find-mistake-in-someone-elses.html" rel="nofollow">on a blog</a> that there are mistakes in Karp\'s paper where he proved that 0-1 programming is NP-Complete, but I couldn\'t find it, can anyone explain? And I doubt that there are also mistakes where he proved Steiner Tree Problem is NP-Compelete but not sure.</p>\n\n<p>The blog post a little old and I thought asking the writer of the blog may not receive answer quickly enough. I didn\'t find any referrence in other places so I thought this question may worth asking. </p>\n', 'ViewCount': '89', 'Title': "Mistake in Karp's paper on NP-Complete problems?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-03T08:53:58.347', 'LastEditDate': '2013-12-03T08:49:56.580', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18566', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11589', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-12-03T06:48:29.323', 'Id': '18559'},125_157:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is a polynomial reduction to the maximum clique problem of the following problem</p>\n\n<p><em>Given a set of n\naxis-aligned rectangles in the plane, how big is the largest subset of these rectangles\nthat contain a common point?</em></p>\n\n<p>The maximum clique problem is <em>given a graph \n what is the\nnumber of nodes in its largest complete subgraph.</em></p>\n', 'ViewCount': '88', 'Title': 'Reduction to maximum clique', 'LastActivityDate': '2013-12-06T14:30:00.900', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11821', 'Tags': '<reductions>', 'CreationDate': '2013-12-06T14:30:00.900', 'Id': '18684'},125_158:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I understand and know how to show that a language B is NP-Complete.</p>\n\n<ol>\n<li>Show that $B\\in NP$</li>\n<li>Show that every language $A\\in NP$ is polynomial time reducible to $B$</li>\n</ol>\n\n<p>For step 2, it is sufficient to give a polynomial time reduction from a language that is already known to be NP-Complete. I am reading Sipser\'s "Theory of Computation" textbook, and the main method he gives is a reduction from $3SAT$. I would agree that $3SAT$ is probably the simplest reduction choice, unless the problem is a trivial modification of an NP-Complete problem that you already know of.</p>\n\n<p>What I am struggling with is, finding reductions from $3SAT$ or any NP-Complete language to the new language $B$. The other tip that Sipser gives is the notion of variable and clause "gadgets" which refer to the structures in the new language which correspond to the variables and clauses in $3SAT$. I tried the Undirected Hamiltonian Path problem for a few hours but could not get anywhere useful in finding sufficient "gadgets" so that I could solve the problem. Looking at the $k$-clique problem and the $k$-vertex-cover problem, the "gadgets" that Sipser uses are not something that I would think of...</p>\n\n<ol>\n<li>How can I begin to find these "gadgets"?</li>\n<li>Specifically with a reduction from $3SAT$, what are the common techniques?</li>\n</ol>\n\n<p>This is a fascinating theory! Please help!</p>\n', 'ViewCount': '74', 'ClosedDate': '2013-12-09T16:36:34.470', 'Title': 'Tips for showing a language is NP-Complete', 'LastEditorUserId': '6815', 'LastActivityDate': '2013-12-09T16:38:34.207', 'LastEditDate': '2013-12-09T16:38:34.207', 'AnswerCount': '0', 'CommentCount': '13', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-12-09T03:19:15.097', 'Id': '18769'},125_159:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '61', 'Title': 'CNF SAT conversions', 'LastEditDate': '2013-12-10T00:58:52.430', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8508', 'FavoriteCount': '1', 'Body': '<p>I am interested in reductions from 3-CNF boolean expressions to similar restricted forms. For example, I am interested in knowing how to reduce a 3-CNF formula to another 3-CNF formula where each variable appears in at most $b$ clauses. I observed this is used in MAX-SAT so I am interested in knowing such reductions. Is there a paper/book that contains descriptions of such forms and their properties?</p>\n', 'Tags': '<complexity-theory><reductions><satisfiability>', 'LastEditorUserId': '8508', 'LastActivityDate': '2013-12-10T01:07:49.217', 'CommentCount': '0', 'AcceptedAnswerId': '18805', 'CreationDate': '2013-12-09T22:05:24.017', 'Id': '18793'},125_160:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $M$ be a finite set of even cardinality. Define $C=\\{\\{a,b\\}:a,b \\in M, a \\neq b\\}$ the set of all pairs over $M$. Let $w:C \\rightarrow \\mathbb{R}^+_0$ be a function.</p>\n\n<p>Now find $C' \\subset C$ with the following constraints:</p>\n\n<p>$$\n\\bigcup C' = M \\\\\n\\forall x,y \\in C': x \\cap y = \\emptyset \\\\\n\\sum_{x \\in C'}w(x) \\text{ minimal}\n$$</p>\n\n<p>In words: Find a subset $C'$ of pair-wise disjunctive pairs over $M$ that covers $M$, with the sum of these pairs being minimal. Any element of $M$ must appear in exactly one pair.</p>\n\n<p>I could not find an efficient algorithmic solution, and I also fail to relate this to any other known (optimization) problem. I was thinking of the subset sum problem, but I don't see any relation.</p>\n\n<p>So the questions is: Can you find an efficient algorithm to find $C'$? A good approximation might also be sufficient. If not, can you reduce this to any other known computer science problem? </p>\n", 'ViewCount': '87', 'Title': 'Find subset with minimal sum under constraints', 'LastActivityDate': '2013-12-10T00:52:40.407', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '18801', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11970', 'Tags': '<algorithms><reductions><optimization>', 'CreationDate': '2013-12-10T00:01:00.097', 'Id': '18799'},125_161:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let Two-Solutions-SAT be the language of Boolean formulas that have exactly two distinct satisfying assignments. Show Two-Solutions-SAT is co-NP-hard.</p>\n\n<p>I know how to show that the complement of Two-Solutions-SAT is in NP, it's relatively easy to create a nondeterministic polynomial time TM that decides it.</p>\n\n<p>My problem comes with reducing from SAT to the complement of Two-Solutions-SAT. I understand how to reduce from SAT to 3SAT, but in the case of 3SAT you will always have CNF's with 3 variables. With the complement of Two-Solutions-SAT, you have to somehow reduce to the case where you have 0 or 1 or >= 3 distinct satisfying assignments, and I'm not sure how to go about reducing to that.</p>\n\n<p>Thanks</p>\n", 'ViewCount': '260', 'Title': 'Question on SAT reduction', 'LastActivityDate': '2013-12-12T02:56:18.300', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18909', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11300', 'Tags': '<complexity-theory><np-complete><reductions><np-hard>', 'CreationDate': '2013-12-10T05:24:42.023', 'FavoriteCount': '1', 'Id': '18815'},125_162:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Show that the set $K^{c}$ = $\\lbrace M \\mid M(M) \\text{ diverges} \\rbrace$ is not recursively enumerable.</p>\n</blockquote>\n\n<p>This question is essentially asking to show that the set of turing machines which diverge when run on their own code is not RE.</p>\n\n<p>My idea is to attempt to reduce this problem to something which is the complement of the halting problem.  Thus, the idea is to take a machine M and a word w, and construct a new machine which diverges on it's own code when M diverges on w, but haven't had much luck with that.</p>\n\n<p>This is from a practise exam, but please treat it as a homework question so I can attempt to work through a solution.</p>\n", 'ViewCount': '76', 'Title': 'Turing machine which diverges on its own code', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-10T18:32:40.683', 'LastEditDate': '2014-01-10T18:32:40.683', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11999', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-12-10T21:36:02.977', 'Id': '18840'},125_163:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>SSUM is the same as the Subset Sum Problem with the only additional requirement is all the numbers must be unique in the subset.  </p>\n\n<p>To prove it's NP complete, the verifier is quite easy to construct being the same as one for the Subset Sum except you add the additional requirement of making sure all numbers are unique. </p>\n\n<p>With the reduction, I assume you can use the same reduction as before from 3SAT, I'm just figuring out a way when evaluating that reduction, to determine if two or more numbers are the same. I'm using the 3SAT reduction in Sipser with the table of columns and rows. If one needs any more information I would be happy to provide. </p>\n", 'ViewCount': '84', 'Title': 'Proving SSum is NP-Complete?', 'LastActivityDate': '2013-12-11T21:49:28.287', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<np-complete><reductions><3-sat>', 'CreationDate': '2013-12-11T20:02:45.520', 'Id': '18891'},125_164:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm trying to understand reduction, this is from my textbook and is not a homework problem or even any exercise, just trying to understand an example they present.</p>\n\n<p>This is the reduction they give: </p>\n\n<p>PROOF We let R be a TM that decides REGULARTM and construct TM S to\ndecide ATM . Then S works in the following manner.</p>\n\n<p>S = \u201cOn input $M$, $w$ , where M is a TM and w is a string:</p>\n\n<ol>\n<li><p>Construct the following TM $M_{2}$ .</p>\n\n<p>$M_{2}$ = \u201cOn input x:</p>\n\n<ol>\n<li><p>If x has the form $0^{n} 1^{n}$ , accept .</p></li>\n<li><p>If x does not have this form, run M on input w and\naccept if M accepts w.\u201d</p></li>\n</ol></li>\n<li><p>Run R on input $M_{2}$ .</p></li>\n<li><p>If R accepts, accept ; if R rejects, reject .\u201d</p></li>\n</ol>\n\n<p>So, we start with a machine that decides whether a language of a TM is regular. And we want to use that to decide if a TM halts on a given input.</p>\n\n<p>My question: What if $w$ does have the form $0^{n} 1^{n}$? Well, $M_{2}$ accepts that string just cause of the form. But we never actually run $M$ on $w$. So how can we say that it will accept or reject it? We have no idea what it does because we never ran it on $w$.</p>\n", 'ViewCount': '61', 'Title': 'Reducing from a Turing machine that recognizes is regular to the halting problem', 'LastActivityDate': '2013-12-11T21:54:13.870', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '18898', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12039', 'Tags': '<turing-machines><reductions><undecidability>', 'CreationDate': '2013-12-11T20:13:17.863', 'Id': '18894'},125_165:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two NP NP-hard functional problems, A and B, one can find a reduction of A to B. Is it possible to find a reduction that would honour approximations? That is, if you have an approximation algorithm for B that yield approximate solutions within accuracy $\\delta$, is it possible to reduce A to B in such a way that one would be able to derive an approximate solution of A within accuracy $\\epsilon = \\epsilon(\\delta)$?</p>\n', 'ViewCount': '85', 'Title': 'Approximation algorithms for NP-complete problems', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-19T05:48:21.523', 'LastEditDate': '2013-12-16T20:06:37.607', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10447', 'Tags': '<complexity-theory><reductions><approximation-algorithms>', 'CreationDate': '2013-12-16T18:26:00.343', 'Id': '19050'},125_166:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need help with showing that \n$$NeverHalt_{TM} = \\{\\langle M\\rangle \\mid \\text{$M$ is a TM which runs forever on every input $w$}\\}$$\nis undecidable by giving an explicit mapping reduction.</p>\n\n<p>To show that a language reduces to any other language we must show that yes-instances are mapped to yes-instances and no-instances are mapped to no instances. We need to find a TM whose language will "help" us solve $NeverHalt_{TM}$, given $\\langle M\\rangle$.</p>\n\n<p>I am not really sure where to go from here or in general how to proceed with undecidability problems.</p>\n', 'ViewCount': '66', 'Title': 'Mapping reduction to show NeverHalt is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T22:15:30.900', 'LastEditDate': '2014-02-02T22:15:30.900', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-12-17T00:13:34.353', 'Id': '19055'},125_167:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The theory of NP-completeness was initially built on Cook (polynomial-time Turing) reductions. Later, Karp introduced polynomial-time many-to-one reductions. A Cook reduction is more powerful than a Karp reduction since there is no restriction on the number of calls to the oracle. So, I am interested in NP-complete graph problem that does not have a known Karp reduction from a NP-complete problem. </p>\n\n<blockquote>\n  <p>Is there a natural graph problem known to be $NP$-complete only under Cook reduction, but not known to be NP-complete under Karp reductions?</p>\n</blockquote>\n', 'ViewCount': '129', 'Title': 'Graph problem known to be $NP$-complete only under Cook reduction', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-18T08:06:32.597', 'LastEditDate': '2013-12-18T08:06:32.597', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2013-12-17T20:00:33.290', 'FavoriteCount': '1', 'Id': '19069'},125_168:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two languages $L_1$ and $L_2$ that are in $\\mathsf{P}$, can it be proven that there is a polynomial time reduction from $L_1$ to $L_2$ and vice versa? If so, how?</p>\n\n<p>I noticed that if $L_1$ is the empty language, and $L_2$ is the "full language" $\\{ 0,1 \\}^*$, there does not seem to be a reduction from $L_2$ to $L_1$, but this is not clear to me. I know how a reduction works, so that is not a problem for me.</p>\n', 'ViewCount': '97', 'Title': 'Does two languages being in P imply reduction to each other?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-03T14:04:01.493', 'LastEditDate': '2014-01-03T14:04:01.493', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19428', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12504', 'Tags': '<complexity-theory><reductions><polynomial-time>', 'CreationDate': '2013-12-31T22:04:51.200', 'Id': '19427'},125_169:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Many problems in computer science come in two flavors:</p>\n\n<ul>\n<li>Optimization problem: "Find an object with the largest size".</li>\n<li>Threshold problem: "Given $n$, find an object with a size of at least $n$, or reply that such an object does not exist".</li>\n</ul>\n\n<p>Given a solution for the optimization problem, we can solve the threshold problem simply by running the optimization solution and checking if the result has a size of at least $n$. But this doesn\'t help us if the optimization problem is NP-complete.</p>\n\n<p>MY QUESTION IS: If we have a constant-factor approximation algorithm for the optimization problem, how can we use it for the threshold problem?</p>\n\n<p>An obvious answer is: Given $n$, run the approximation algorithm. If the result has a size of at least $n$, return it. If the result has a size of less than $n/c$ (where c is the approximation constant), return that an object of size $n$ does not exist. Otherwise, return "I don\'t know".</p>\n\n<p>Is there a better way?</p>\n', 'ViewCount': '48', 'Title': 'Using approximations to optimization problems for threshold problems', 'LastEditorUserId': '1342', 'LastActivityDate': '2014-01-31T16:18:31.590', 'LastEditDate': '2014-01-01T14:23:41.853', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1342', 'Tags': '<np-complete><reductions><optimization><approximation>', 'CreationDate': '2014-01-01T13:25:36.750', 'Id': '19433'},125_170:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In <a href="http://www.dece.nctu.edu.tw/files/writing/7180_8835b76e.pdf" rel="nofollow">this</a> paper (page 3 Theorem 1) the authors want to prove that their problem is NP-complete. Their method is as follows. Let their problem be known as $P$. They show that their problem can be written as a $0\\text{-}1$ integer program. Then they claim that $0\\text{-}1$ integer programs are NP-complete and therefore their problem $P$ is NP-complete.</p>\n\n<p>I find this proof hard to believe. For the problem $P$ to be NP-hard I think one has to reduce the $0\\text{-}1$ integer program into an instance of problem $P$ and not the other way around.</p>\n\n<p>Please can someone explain if this proof in the paper is acceptable? </p>\n', 'ViewCount': '129', 'Title': 'Can one reduce a problem of unknown complexity to a hard problem to show hardness?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-07T14:09:03.943', 'LastEditDate': '2014-01-06T22:02:58.273', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '19555', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2014-01-06T19:50:00.527', 'Id': '19541'},125_171:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Throughout the subject of reductions, I was wondering:</p>\n\n<blockquote>\n  <p>If we take $L_1 = \\Sigma^* $ and $L_2 = \\emptyset$, is $L_1 \\leq L_2$? is $L_2 \\leq L_1$?</p>\n</blockquote>\n\n<p>What I mean is, Is there some sort of reduction between any of the two with the other one? </p>\n\n<p>I tried this:</p>\n\n<blockquote>\n  <p>Let us try $L_2 \\leq L_1$, we need to show that such a reduction exists. Suppose f(x) is that reduction function in which $x \\in L_2$ iff $f(x) \\in L_1$. </p>\n</blockquote>\n\n<p>But there aren't any $x$ in $\\emptyset = L_2$, does that show that such a reduction doesn't exist?</p>\n", 'ViewCount': '65', 'Title': 'Reduction between $\\Sigma^*$ and $\\emptyset$', 'LastActivityDate': '2014-01-09T23:06:11.213', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19600', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<reductions>', 'CreationDate': '2014-01-09T16:51:05.003', 'Id': '19599'},125_172:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'Can $\\emptyset$ be reducible to any other language?', 'LastEditDate': '2014-01-10T15:13:43.020', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Body': '<p>While solving some question, that involved the empty set $\\emptyset$, I was really wondering, is $\\emptyset$ reducible to <em>any</em> other language, i.e., $\\emptyset \\leq A$ such that $A$ is a language over a given alphabet $\\Sigma^*$?</p>\n\n<p>I mean, one can never take $x \\in \\emptyset$, right? or am I missing anything?</p>\n\n<p>Maybe $\\emptyset \\leq \\emptyset$? because if I take a reduction $f$ such that $x \\in \\emptyset \\Leftrightarrow f(x) \\in \\emptyset$, this is always true, because $x \\in \\emptyset$ is never true and $f(x) \\in \\emptyset$ is also never true, so that function is a reduction function in the empty-concept, no?</p>\n', 'ClosedDate': '2014-02-07T06:14:13.823', 'Tags': '<computability><reductions>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-10T15:37:51.697', 'CommentCount': '3', 'AcceptedAnswerId': '19630', 'CreationDate': '2014-01-10T13:53:57.107', 'Id': '19628'},125_173:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><strong>So we have two problems:</strong></p>\n\n<p>Problem A: Given a list of <strong>positive</strong> integers, decide whether the list contains a subset adding to a given number t.</p>\n\n<p>Problem B: Given a list of integers, decide whether the list contains a subset adding to 0.</p>\n\n<p>I have to prove that A can be reduced to B in polynomial time. And a really simple reduction came into mind. Here goes my proof.</p>\n\n<p>So let L be the list of positive integers from the problem A, I just create L\' add -t to the it, and pass L\' to B, this is the reduction.</p>\n\n<p>To prove this is a reduction, let\'s see that, <strong>L is a positive instance of A if and only if L\' is a positive instance of B</strong>. Am I doing it right?</p>\n\n<p>So first:</p>\n\n<p>=>) It\'s just obvious to prove that, given a list of integers which contains a subset adding up to t, this list, along with -t adds up to 0.</p>\n\n<p>&lt;=) Let S be the subset of L\' that adds up to 0. Given that, by construction, all integers in L\' are positive but one, which is -t, -t must be in S. If S contains the only negative number -t, and S adds up to 0, S{-t}, adds up to t. Then S{-t} is a subset of S{-t} = L that adds up to t. </p>\n\n<p><strong>Question:</strong> </p>\n\n<ul>\n<li><p>Is my proof correct? </p></li>\n<li><p>Is there any obvious mistake which makes it invalid? </p></li>\n<li><p>Are there any minor mistakes which could be fixed to "improve" it?</p></li>\n</ul>\n\n<p><strong>Extra question:</strong></p>\n\n<p>And also, I would like to ask a more generic question. Consider the problem A, but removing the "positive" part, so L can now contain both positive and negative numbers on it. I know A\' (the new A) is still reductible to B, because they both belong to the NP-complete problem class. So my other question is:</p>\n\n<ul>\n<li>How can I reduce A\' to B?</li>\n</ul>\n', 'ViewCount': '38', 'ClosedDate': '2014-01-13T16:03:11.043', 'Title': 'Is this reduction done correctly?', 'LastEditorUserId': '12801', 'LastActivityDate': '2014-01-13T17:32:17.800', 'LastEditDate': '2014-01-13T17:32:17.800', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12801', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2014-01-13T13:52:50.153', 'Id': '19692'},125_174:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have been reading Karp's famous paper on the NP-Completeness of different problems, <em>Reducibility among combinatorial problems</em>, and I have a question on the reduction from <em>SAT</em> to <em>0/1 Integer Programming</em> defined there.</p>\n\n<p>The problem <em>0/1 Integer Programming</em> is defined as:<br>\nInput: Integer matrix $A$ and integer vector $d$<br>\nProperty: There exists a 0/1 vector $x$ such that $Ax=b$.<br>\nLet $B$ be a boolean formula in CNF with $p$ variables $x_1,\\dots, x_p$ and $n$ clauses $C_1,\\dots,C_n$.\nThe reduction from <em>SAT</em> should work like this ($C_i$ is the $i^{\\text{th}}$ clause of the boolean formula):\n$$ \na_{ij} = \\begin{cases}\n          1   &amp;\\text{if } x_j \\in C_i \\\\\n          -1  &amp;\\text{if } \\bar{x}_j \\in C_i\\\\\n          0   &amp;\\text{otherwise}\n         \\end{cases}\n$$\nand\n$$\n b_i = 1- (\\text{ the number of complemented variables in } C_i ).\n$$\nNow if I use this procedure on the satisfiable formula\n$(x_1 \\vee x_2 ) \\wedge (x_1 \\vee x_3 ) \\wedge (x_2 \\vee x_3 )$, I get\n$$\nA =\\left( \\begin{array}{ccc}\n1 &amp; 1 &amp; 0 \\\\\n1 &amp; 0 &amp; 1 \\\\\n0 &amp; 1 &amp; 1 \\end{array} \\right), \\text{ and }\nb = \\left( \\begin{array}{c}\n1 \\\\\n1 \\\\\n1  \\end{array} \\right),\n$$\nwhich has no 0/1 solution. So my question is:<br>\nHave I made a very silly mistake, or is Karp's original reduction faulty?</p>\n", 'ViewCount': '73', 'Title': "0/1 Integer Programming and Karp's Reduction", 'LastActivityDate': '2014-01-18T04:08:20.907', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19802', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10734', 'Tags': '<np-complete><reductions>', 'CreationDate': '2014-01-14T16:09:41.033', 'Id': '19716'},125_175:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Let $h$ be a total computable function. Is $S = \\{x \\mid f_x \\neq h\\}$\n  recursively enumerable?</p>\n</blockquote>\n\n<p>Originally this was an exercise that restricted $h$ to: $h(x) = x + 1$ . However, it can be formulated as a more general case.</p>\n\n<p>By Rice's Theorem, it is not recursive. Intuitively, </p>\n\n<ul>\n<li><p>$S$ is not r.e. as if it was, it would mean that we would know that\n$f_x(y)$ halts for some input $y$ in order to check if it has a different image of $h(y)$.</p></li>\n<li><p>$\\overline{S}$ is not r.e. as if it was, we would be able to check if $f_x(y)\n   = h(y)$ for every input $y$ (we would check equality for infinite inputs).</p></li>\n</ul>\n\n<p>How would you solve this problem?</p>\n\n<p><strong>Note:</strong> I tried something, but I'll post it as an answer. Some thoughts would be great and really helpful. Any approach to this problem using reduction or diagonalization methods would be useful.</p>\n", 'ViewCount': '101', 'Title': 'Is the set of programs that compute some function other than $h$ recursively enumerable?', 'LastEditorUserId': '11974', 'LastActivityDate': '2014-02-12T20:54:26.437', 'LastEditDate': '2014-01-19T17:14:35.563', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<computability><reductions><semi-decidability>', 'CreationDate': '2014-01-18T20:07:54.740', 'Id': '19815'},125_176:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We have had <a href="http://cs.stackexchange.com/search?q=cook+reduction+is%3Aquestion">several questions about the relation of Cook and Karp reductions</a>. It\'s clear that Cook reductions (polynomial-time Turing reductions) do not define the same notion of NP-completeness as Karp reductions (polynomial-time many-one reductions), which are usually used. In particular, Cook reductions can not separate NP from co-NP even if P $\\neq$ NP. So we should not use Cook reductions in typical reduction proofs. </p>\n\n<p>Now, students found a peer-reviewed work [1] that uses a Cook-reduction for showing that a problem is NP-hard. I did not give them full score for the reduction they took from there, but I wonder.</p>\n\n<p>Since Cook reductions <em>do</em> define a similar notion of hardness as Karp reductions, I feel they <em>should</em> be able to separate P from NPC resp. co-NPC, assuming P $\\neq$ NP. In particular, (something like) the following should be true:</p>\n\n<p>$\\qquad\\displaystyle L_1 \\in \\mathrm{NP}, L_2 \\in \\mathrm{NPC}_{\\mathrm{Karp}}, L_2 \\leq_{\\mathrm{Cook}} L_1 \\implies L_1 \\in \\mathrm{NPC}_{\\mathrm{Karp}}$.</p>\n\n<p>The important nugget is that $L_1 \\in \\mathrm{NP}$ so above noted insensitivity is circumvented. We now "know" -- by definition of NPC -- that $L_2 \\leq_{\\mathrm{Karp}} L_1$.</p>\n\n<p>As has been <a href="http://chat.stackexchange.com/transcript/message/13483686#13483686">noted by Vor</a>, it\'s not that easy (notation adapted):</p>\n\n<blockquote>\n  <p>Suppose that $L_1 \\in \\mathrm{NPC}_{\\mathrm{Cook}}$, then by definition, for all languages $L_2 \\in \\mathrm{NPC}_{\\mathrm{Karp}} \\subseteq \\mathrm{NP}$ we have $L_2 \\leq_{\\mathrm{Cook}} L_1$; and if the above implication is true then $L_1 \\in \\mathrm{NPC}_{\\mathrm{Karp}}$ and thus $\\mathrm{NPC}_{\\mathrm{Karp}} = \\mathrm{NPC}_{\\mathrm{Cook}}$ which is still an open question.</p>\n</blockquote>\n\n<p>There may be other differences between the two NPCs but co-NP.</p>\n\n<p>Failing that, are there any known (non-trivial) criteria for when having a Cook-reduction implies Karp-NP-hardness, i.e. do we know predicates $P$ with</p>\n\n<p>$\\qquad\\displaystyle L_2 \\in \\mathrm{NPC}_{\\mathrm{Karp}}, L_2 \\leq_{\\mathrm{Cook}} L_1, P(L_1,L_2) \\implies L_1 \\in \\mathrm{NPC}_{\\mathrm{Karp}}$?</p>\n\n<hr>\n\n<ol>\n<li><a href="http://dx.doi.org/10.1089/cmb.1994.1.337" rel="nofollow">On the Complexity of Multiple Sequence Alignment</a> by L. Wang and T. Jiang (1994)</li>\n</ol>\n', 'ViewCount': '71', 'Title': 'Can we construct a Karp reduction from a Cook reduction between NP problems?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T07:56:44.503', 'LastEditDate': '2014-02-05T07:56:44.503', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><reference-request><np-complete><reductions>', 'CreationDate': '2014-01-29T18:33:16.763', 'FavoriteCount': '1', 'Id': '20074'},125_177:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an example for a reduction of 3CNF to Clique, there is one thing I don't get about it, hopefully you could clarify it.  The reduction works like this:</p>\n\n<blockquote>\n  <p>Construct a graph G = (V, E) as follows:</p>\n  \n  <p>Vertices: Each literal corresponds to a vertex.</p>\n  \n  <p>Edges: All vertices are connected with an edge except the vertices of\n  the same clause and vertices with negated literals.</p>\n</blockquote>\n\n<p>Why is it important that that negated literals will not be connected? How would that effect the reduction?</p>\n", 'ViewCount': '42', 'Title': 'Reducing 3CNF to Clique: Why do we omit negated literals?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-31T08:16:45.470', 'LastEditDate': '2014-01-31T08:16:45.470', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '20133', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9851', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2014-01-30T18:38:25.957', 'Id': '20127'},125_178:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There's something in my class notes i don't understand, if anyone here could clarify it would be great. </p>\n\n<p>Given a mapping reduction from A to B that's Injective and Surjective, if B is in <code>RE</code> than A must be in <code>R</code>. From what I can gather, since the reduction function is Injective and Surjective the reduction works the other way to, from B to A. But why aren't they both in R?</p>\n", 'ViewCount': '29', 'Title': 'A two way Mapping reduction', 'LastActivityDate': '2014-02-02T14:38:20.750', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11171', 'Tags': '<reductions>', 'CreationDate': '2014-02-02T14:38:20.750', 'Id': '20219'},125_179:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reducing a given Turing Machine to the complement of the known undecidable problem, \n$$ Complement(A_{TM}) = \\{ \\langle M,w \\rangle \\mid M  \\text{ is TM}, w \\not\\in L(M) \\}$$</p>\n\n<p>To this Turing Machine, known as SPARSE TM:\n$$\nSPARSE_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is 1-tape TM}, |L(M)| \\leq 1000\\} \n$$</p>\n\n<p>Here is what I have so far, but I think I need help because one of the statements I make seems fishy.</p>\n\n<p>Assume there is a TM <code>S</code> that decides the complement of the accept TM and a TM <code>R</code> that decides SPARSE. Then <code>S</code> looks like:</p>\n\n<pre><code>S = "On input `&lt;M,w&gt;`:\n    Construct M\':\n        M\' = "On input x:\n            if x in L(M):  #Fishy statement\n                accept\n            else: reject\n     Run R on &lt;M\'&gt;\n     if R accepts: accept; if R rejects: reject\n</code></pre>\n\n<p>This (if right) would then reduce the SPARSE TM and prove that it is undeciable, right? Any help would be appreciated.</p>\n', 'ViewCount': '89', 'Title': 'Reduction to complement of Accept Problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T00:25:49.743', 'LastEditDate': '2014-02-06T21:17:23.187', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21410', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<computability><turing-machines><reductions><undecidability>', 'CreationDate': '2014-02-06T20:30:09.477', 'Id': '21400'},125_180:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a statement I am trying to prove, and I'm very close, but I think I'm missing a couple of key concepts about regular and context-free languages.</p>\n\n<p><strong>Question:</strong> Let\n$\nA = \\{ ww \\ | \\ w \\ \\epsilon \\ \\Sigma^{*} \\}\n$.</p>\n\n<p>Show that any language $L$ is Turing-decidable if and only if $L$ is many-one reducible to $A$.</p>\n\n<p>Where I am so far:</p>\n\n<ol>\n<li><p>Language $A$ is not context-free, but the complement of $A$ is context-free.</p></li>\n<li><p>Both $A$ and the complement of $A$ are decidable.</p></li>\n</ol>\n\n<p>So, that means I can prove one direction of the <em>iff</em> statement fairly easily: </p>\n\n<p>If $L$ is many-one reducible to $A$ then since $A$ is decidable from statement (2) above, also $L$ is decidable.</p>\n\n<p>The other direction is giving me problems. This is all I have  gleaned so far:</p>\n\n<p>If $L$ is Turing-decidable, then $L$ is a regular language.</p>\n\n<p>Is there some relation between regular and context-free languages with respect to reductions that I am missing? Or should I be making a different logic jump in this part of the proof?</p>\n", 'ViewCount': '116', 'Title': 'Proving iff statement with reductions', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-07T01:46:54.643', 'LastEditDate': '2014-02-07T00:14:22.467', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<turing-machines><reductions>', 'CreationDate': '2014-02-06T21:29:05.920', 'Id': '21405'},125_181:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is an upper bound on formula size when converting 3-SAT to UNIQUE 3-SAT?</p>\n\n<p>We can use the <a href="http://en.wikipedia.org/wiki/Valiant%E2%80%93Vazirani_theorem" rel="nofollow">Valiant Vazirani Therom</a>, also found <a href="http://people.csail.mit.edu/madhu/ST07/scribe/lect12.pdf" rel="nofollow">here (in more detail)</a>.</p>\n\n<p>Essentially, it is a randomized algorithm that converts a SAT formula into another SAT formula that has only 1 satisfying variable assignment (called UNIQUE-SAT) with high probability.</p>\n\n<p>I\'m wondering what the upper bounds are on the size of the formula.  The information I have proves that it is polynomial, but I hope we can get more specific.  Can anyone find a more exact upper bounds?</p>\n', 'ViewCount': '43', 'Title': 'What is an upper bound on formula size when converting 3-SAT to UNIQUE 3-SAT?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-10T18:09:47.103', 'LastEditDate': '2014-02-10T18:09:47.103', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1667', 'Tags': '<complexity-theory><reductions><3-sat>', 'CreationDate': '2014-02-10T17:08:04.963', 'Id': '21497'},125_182:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p><strong>The problem:</strong></p>\n  \n  <p><em>Input</em>: An $n \\times n$ matrix of 0's and 1's, and a position <em>pos</em> of this matrix (i.e. a pair of integers $i,j$ with $1 \\leq i,j \\leq n$)</p>\n  \n  <p><em>Output</em>:</p>\n  \n  <p>YES if there exists a path through <strong>adjacent</strong> matrix entries $\\dagger$, starting at <em>pos</em>, covering each matrix entry with a 1 <strong>exactly once</strong>, and not covering the matrix entries with a 0.</p>\n  \n  <p>NO otherwise.</p>\n</blockquote>\n\n<p>$\\dagger$ a matrix entry is adjacent to the one immediately to its left, to the one immediately to its right, to the one immediately upwards and the one immediately below.</p>\n\n<hr>\n\n<p>Informally, the matrix can be seen as a labyrinth where the 0's are walls, you start somewhere, and you have to walk through the whole maze without repeating any position.</p>\n\n<p>Example input:</p>\n\n<pre><code>1100\n1100\n0000\n0001\nPos: (1,1)\n</code></pre>\n\n<p>Corresponding output:</p>\n\n<pre><code>No (because you can't reach the position (4,4))\n</code></pre>\n\n<hr>\n\n<p>Is this problem NP-complete? If it is, what other NP-complete problem has been reduced to it? If it isn't, what approach can I use to design an efficient algorithm?</p>\n\n<p>I think this is a particular case of the hamiltonian path problem (except that you have a fixed starting point). The graph can be constructed by taking the matrix entries with 1's as vertices. 2 vertices are adjacent iff their corresponding matrix entries are adjacent. So I think that reducing this problem to the hamiltonian path problem should be easy. Of course, to prove it is NP-complete, we would have to do the reduction backwards.</p>\n", 'ViewCount': '67', 'Title': 'Is this path finding problem in a 01-matrix NP-complete?', 'LastEditorUserId': '14555', 'LastActivityDate': '2014-02-11T20:50:59.417', 'LastEditDate': '2014-02-11T20:50:59.417', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21511', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14555', 'Tags': '<complexity-theory><np-complete><reductions><np>', 'CreationDate': '2014-02-10T23:14:29.853', 'Id': '21510'},125_183:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The Triangle Cover Graph problem is this:</p>\n\n<blockquote>\n  <p>Given a graph $G = (V,E)$ and an integer $k$, does there exist a set of at most $k$ vertices of $G$ such that every triangle contained in $G$ also contains a vertex of the set?</p>\n</blockquote>\n\n<p>This problem is obviously in $NP$ as its verifier is just the set which you can easily check.  However, what's the reduction to be able to show that this is NP Complete?</p>\n\n<p>I recognize the fact that a good reduction for this problem would be for 3-SAT as you could easily take a 3-sat instance and make a 3-vertex triangle in the graph corresponding to the variables which are in each clause.  However, I wasn't able to come up with a way to connect the different triangles together to ensure that the assignment of vertices would be a satisfiable truth assignment.</p>\n", 'ViewCount': '58', 'Title': 'Reducing 3SAT to Triangle Cover Graph', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-19T14:58:51.107', 'LastEditDate': '2014-02-19T14:58:51.107', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14824', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions>', 'CreationDate': '2014-02-19T00:19:18.737', 'FavoriteCount': '1', 'Id': '21792'},125_184:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Writing a proof by contradiction is fairly formulaic--first you assume the opposite, then derive a contradiction.  I would like to know the steps and conventions for writing a many-one reduction proof.  <a href="http://cs.stackexchange.com/a/4582/14650">This answer</a> was somewhat helpful, but like other explanations I\'ve heard, it sounds too similar to a proof by contradiction for me to understand the difference.</p>\n\n<p>My specific points of confusion:</p>\n\n<ul>\n<li>The exact meaning of $A \\leq _{m} B$</li>\n<li>Do we reduce an unknown problem to a known problem, or the opposite</li>\n<li>Does the reduction function transform a known problem into an unknown problem, or the opposite</li>\n<li>How a many-one reduction is different from a proof by contradiction.  It seems like a simpler version of the same logic; if so, how is the simplification justified</li>\n</ul>\n\n<p>I am only interested in many-one reductions of language/Turing machine problems (in case the term has meaning in other contexts as well).  Any help is appreciated, including links and illustrative examples.  Thanks.</p>\n', 'ViewCount': '45', 'Title': 'How to write a many-one reduction proof', 'LastEditorUserId': '14650', 'LastActivityDate': '2014-02-26T15:04:25.143', 'LastEditDate': '2014-02-26T03:32:52.807', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22021', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14650', 'Tags': '<turing-machines><reductions>', 'CreationDate': '2014-02-25T03:35:11.147', 'Id': '22011'},125_185:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to show that some problem $P_1$ is NP-hard. I have a problem $P_2$ that is NP-complete. From an instance of $P_2$ I created in polynomial time an instance of the problem $P_1$.</p>\n\n<p>My question is: Should I verify both direction ($\\Leftrightarrow$) or only one direction ($\\Rightarrow$)? More precisely, which one to show from these two:</p>\n\n<ul>\n<li>Solve $P_1\\;\\Leftrightarrow$ solve  $P_2$</li>\n<li>Solve $P_1\\;\\Rightarrow$ solve  $P_2$</li>\n</ul>\n', 'ViewCount': '24', 'Title': 'There is equivalence in an NP-hardness proof or not?', 'LastActivityDate': '2014-03-03T22:03:14.687', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22240', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12683', 'Tags': '<complexity-theory><np-complete><reductions><np-hard>', 'CreationDate': '2014-03-03T21:51:46.457', 'Id': '22239'},125_186:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a graph $G=(V,E)$ and a set of colors $k&lt;V$. Find a assignment of colors to vertices that minimizes the number of adjacent vertices in conflict. (Two adjacent vertices are in conflict if they have the same color.)</p>\n\n<p>I want to prove the above problem is NP-complete. Call the above problem P1.</p>\n\n<p>Answer: I am trying to reduce the k-coloring problem.</p>\n\n<p>P2: Given a graph $G=(V,E)$ and set of colors $k&lt;V$ is the graph k-colorable (zero conflicts)?</p>\n\n<p>P2 is feasible iff P1 has optimal value is exactly $0$. Therefore if P1 is solved we know solution to P2.</p>\n\n<p>Is this solution correct? Is it what is suggested by the first comment of user G.Bach in <a href="http://cs.stackexchange.com/questions/21431/a-variation-of-the-graph-coloring-problem">A variation of the graph coloring problem</a> ?</p>\n', 'ViewCount': '99', 'Title': 'Proving NP-completeness of a graph coloring problem', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-04T09:15:10.200', 'LastEditDate': '2014-03-04T09:15:10.200', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '22259', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<complexity-theory><graph-theory><np-complete><reductions>', 'CreationDate': '2014-03-03T23:56:50.917', 'Id': '22246'},125_187:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider a set of $N$ nodes. There is a $N\\times N$ non-negative valued matrix $D$ where the $(i,j)$th element $d_{ij}$ gives the "positive metric" between node $i$ and $j$, where $i,j\\in [N]$. Thus the diagonal entries of $D$ are all zero and $d_{ij}=d_{ji}$ so $D$ is symmetric. </p>\n\n<p>Then there is a set of  $k$ colors. I want to assign these colors to the $N$ nodes such that the minimum  metric of a common color between any pair of nodes is maximized. So if $c(i)$ is the color assigned to $i\\in [N]$ by the assignment $a\\in A$, where $A$ is the set of all possible color assignments, we are looking for $$\\max_{a\\in A} \\min_{i,j} \\{d_{ij}:c(i)=c(j)\\}.$$</p>\n\n<p>Is this problem NP-hard?  If it is, cwhat sort of reduction can be used to show that this problem is NP-hard?</p>\n', 'ViewCount': '98', 'Title': 'Relaxed graph coloring, with penalties for assigning adjacent vertices the same color', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-14T15:39:13.670', 'LastEditDate': '2014-03-14T15:39:13.670', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22257', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<complexity-theory><reductions><np-hard>', 'CreationDate': '2014-03-04T03:42:40.617', 'Id': '22256'},125_188:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The complexity class $\\Sigma_{k}^{p}$ is recursively defined as follows:\n\\begin{align}\n\\Sigma_{0}^{p} &amp; := P, \\\\\n\\Sigma_{k+1}^{p} &amp; := P^{\\Sigma_{k}^{p}}.\n\\end{align}</p>\n\n<p>Why is every language that is reducible to a language in $\\Sigma_i^p$ also in $\\Sigma_i^p$?</p>\n\n<p>This comes in the proof of the theorem: If there is a PH-complete problem, then PH (the <a href="http://en.wikipedia.org/wiki/Polynomial_hierarchy" rel="nofollow">polynomial hierarchy</a>) collapses.</p>\n', 'ViewCount': '76', 'Title': 'Every language that is reducible to a language in $\\Sigma_i^p$ is also in $\\Sigma_i^p$ . How?', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-07T17:01:02.787', 'LastEditDate': '2014-03-07T17:01:02.787', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15338', 'Tags': '<complexity-theory><reductions>', 'CreationDate': '2014-03-06T11:28:06.663', 'Id': '22337'},125_189:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What I'm trying to do is to show a problem in NP can be reduced to the min weight vertex cover problem </p>\n\n<p>I've chosen the max independent weight problem = \ninput: A graph G with weights on each vertex,\noutput: An independent set with the max total weight</p>\n\n<p>Before reducing, I've tried to show that the max indep. weight problem is in NP (which is usually the first step in these reductions). I'm trying to construct a verification algorithm for this problem; but I'm stuck on trying to show that the verification algorithm can check if a certificate is the max indep. set in polynomial time. </p>\n\n<p>Any guidance or comments would be greatly appreciated.\nThanks</p>\n", 'ViewCount': '30', 'Title': 'Proving that Max Weighted Independent Set is in NP', 'LastActivityDate': '2014-03-07T02:45:59.663', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22361', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15375', 'Tags': '<reductions><np>', 'CreationDate': '2014-03-07T02:31:43.293', 'Id': '22360'},125_190:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Most books assume that this is obvious, but I can't see how each $\\Sigma_k=NP^{\\Sigma_{k-1}}$ level in the polynomial hierarchy is closed under polynomial-time reductions. Is there something that I'm missing?</p>\n", 'ViewCount': '10', 'ClosedDate': '2014-03-07T18:51:58.633', 'Title': 'Show polynomial hierarchy levels closed under reduction', 'LastActivityDate': '2014-03-07T09:25:11.540', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15383', 'Tags': '<complexity-theory><time-complexity><reductions><complexity-classes>', 'CreationDate': '2014-03-07T09:25:11.540', 'Id': '22369'},125_191:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to reduce the vertex cover problem to a SAT problem, or rather tell whether a vertex cover of size k exists for a given graph, after solving with a SAT solver. I know how to reduce a 3-SAT problem to vertex cover problem, by constructing the subgraphs for each variable (x, !x) and for each clause (a triable). But I am not getting,how to do other way round?</p>\n\n<p>I was thinking of first forming a DNF ,with electing k vertices at first and then convert it to a CNF, by enumerating all clauses. Is there any other method?</p>\n', 'ViewCount': '164', 'Title': 'Reduce Vertex cover to SAT', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-12T17:03:09.430', 'LastEditDate': '2014-03-09T19:50:54.783', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22441', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '13302', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2014-03-09T12:43:04.730', 'Id': '22426'},125_192:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let f be a polynomial-time reduction of a decision problem A to a decision\nproblem B. We know that, if B $\\in$ P then A $\\in$ P. Similarly, if B $\\in$ NP then\nA $\\in$ NP. However, what about the other direction? Assume that A $\\in$ NP and\nconsider the following non-deterministic algorithms to decide whether y $\\in$ B:</p>\n\n<ol>\n<li>"Guess" non-deterministically some x.</li>\n<li>Verify that f(x) = y by computing f(x) in polynomial time and comparing\nit with y. If f(x)$\\neq$y, reject.</li>\n<li>Check (using the polynomial-time nRAM for A) whether x $\\in$ A and return\nthe answer.</li>\n</ol>\n\n<p>Why does this not qualify as a proof that B $\\in$ NP?</p>\n', 'ViewCount': '82', 'Title': 'Does a polynomial-time reduction from A to B imply that B is in NP if A is?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-11T11:40:48.993', 'LastEditDate': '2014-03-11T11:25:21.833', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15531', 'Tags': '<complexity-theory><reductions><np>', 'CreationDate': '2014-03-11T09:52:00.990', 'Id': '22495'},125_193:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If $P = NP$ would this imply that polynomial time reduction from an $NP$- to a $P$-problem would be possible? And if $P\\neq NP$ does it imply that a polynomial time reduction from an $NP$- to a $P$-problem would be impossible?</p>\n', 'ViewCount': '50', 'Title': 'P, NP and polynomial time reduction?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-19T00:04:25.510', 'LastEditDate': '2014-03-19T00:04:25.510', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22770', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14819', 'Tags': '<complexity-theory><np-complete><reductions>', 'CreationDate': '2014-03-18T20:12:32.437', 'Id': '22769'},125_194:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to show that $CO-2Col \\le_L USTCON$ (Log-Space reduction)</p>\n\n<h2>$USTCON$</h2>\n\n<blockquote>\n  <p>The $s-t$ connectivity problem for <strong>undirected</strong> graphs is\n  called $USTCON$.</p>\n  \n  <p>[Input]: An undirected graph $G=(V,E)$, $s,t \\in V$.</p>\n  \n  <p>[Output]: 1 iff $s$ is connected to $t$ in $G$.</p>\n</blockquote>\n\n<hr>\n\n<h2>$CO-2Col$</h2>\n\n<blockquote>\n  <p>A graph is $2$-colorable if there is a way to color the vertices\n  of $G$ with $2$ colors, such that for every edge the two vertices\n  on the edge are colored differently. $CO-2Col$ is the following\n  problem:</p>\n  \n  <p>[Input]: An undirected graph $G$.</p>\n  \n  <p>[Output]: 1 iff $G$ is NOT $2$-colorable.</p>\n</blockquote>\n\n<hr>\n\n<p>My <strong>solution</strong> is for an input graph $G$ the reduction outputs $(G\',s,t)$ where\n $s$ an arbitrary vertex of $G$, $t$ is one of its neighbours and\n$G\'=G^2$ namely an edge $(u,v)\\in E(G\')$,iff there is $w \\in V (w \\ne u,v)$\nsuch that $(u,w)\\in E(G)$ and $(w,v)\\in E(G)$. </p>\n\n<p>$G$ is bipartite \niff $G\'$ is not connected (and $s$ and $t$ belongs to different\nparts).</p>\n\n<p>But this only works when the input graph $G$ is <strong>connected</strong>.</p>\n\n<p>A counter example: (if we choose s,t to be A,B)</p>\n\n<p><img src="http://i.stack.imgur.com/JYLSD.jpg" alt="Counter example"></p>\n\n<p>How can I improve my reduction that it will work at the unconnected case? or maybe a new reduction is needed?</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '89', 'Title': 'Log-Space Reduction $CO-2Col \\le_L USTCON$', 'LastActivityDate': '2014-03-20T20:01:06.013', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22829', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15890', 'Tags': '<complexity-theory><reductions><space-complexity>', 'CreationDate': '2014-03-19T21:19:01.533', 'Id': '22826'},125_195:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose you have a set of binary strings of length n, the magnitude of a string is the number of 1's it has. and you want the program to return true if there is a string of length n that has a magnitude of &lt;= k and there is a index i for every y in the set string[i] = y[i] = 1 for all strings.</p>\n\n<p>Example for n = 5, k = 3:</p>\n\n<p>0 1 0 0 1</p>\n\n<p>1 0 0 1 0</p>\n\n<p>0 0 1 0 0</p>\n\n<p>1 0 1 0 0</p>\n\n<p>0 1 0 1 0</p>\n\n<p>1 1 1 0 0 would be a solution to the above set.</p>\n", 'ViewCount': '46', 'ClosedDate': '2014-03-24T18:48:39.507', 'Title': 'SAT reduction to prove NP completeness', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-20T23:03:49.493', 'LastEditDate': '2014-03-20T21:45:00.517', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15920', 'Tags': '<np-complete><reductions>', 'CreationDate': '2014-03-20T15:45:49.130', 'Id': '22870'},125_196:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading the reduction given by Sipser in his textbook "Introduction to the Theory of Computation," on page 303. The reduction is:</p>\n\n<p>\\begin{equation} 3SAT \\leq_p KCLIQUE \\end{equation}</p>\n\n<p>I am really trying to understand everything formally -- putting everything in a strict logical notation helps me learn Math. To clarify, the content of this proof, has not helped me give other reductions because I don\'t understand one direction of the $\\iff$ in the logic of reductions.</p>\n\n<p>In this reduction, $f$ must be s.t:\n\\begin{equation} w\\in 3SAT \\iff f(w) \\in KCLIQUE \\end{equation}\nand $f$ computes within a polynomial number of steps of the input size. The polynomial part is easy for me to understand, so no problem here!</p>\n\n<p>I see that the above logical statement is equivalent to:\n\\begin{equation} w\\in 3SAT \\implies f(w) \\in KCLIQUE \\land w\\not\\in 3SAT \\implies f(w) \\not\\in KCLIQUE\\end{equation}\nThe above just says yes-instances map to yes-instances and no-instances map to no-instances.</p>\n\n<p>It appears that Sipser shows us:\n\\begin{equation} w\\in 3SAT \\implies f(w) \\in KCLIQUE \\land f(w) \\in KCLIQUE \\implies w\\in 3SAT\\end{equation}</p>\n\n<p>Which is also equivalent to the above by taking the contrapositive of the second implication.</p>\n\n<p>Here is my understanding of the $\\implies$ direction. Given a yes-instance of $3SAT$, show that the reduction $f$ gives us a yes-instance for $KCLIQUE$. This seems completely natural.</p>\n\n<p><strong>I don\'t really understand the other direction</strong> -- namely, given a yes-instance of KCLIQUE we are supposed to show that we get a yes-instance of $3SAT$. However since the reduction goes from $3SAT$ to $KCLIQUE$ i.e. the domain is the language $3SAT$ and the Codomain is the language $KCLIQUE$, I don\'t understand <strong>how</strong> we show this. </p>\n\n<p>It appears that the argument is; Our reduction has provided us this graph, from which we can create a satisfying assignment from?</p>\n\n<p>Please help me understand the other direction, and thanks for your time.</p>\n', 'ViewCount': '40', 'Title': 'Polynomial Reduction 3SAT to K-Clique', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-25T10:07:17.047', 'LastEditDate': '2014-03-25T08:48:36.160', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<complexity-theory><np-complete><reductions><proof-techniques>', 'CreationDate': '2014-03-25T06:23:45.563', 'Id': '23030'},125_197:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to figure out a reduction to prove $W[1]$-hardness for this, but I am having significant trouble. Here is the problem:</p>\n\n<p><strong>Bag Automaton</strong>: \nA non deterministic finite state automaton $M=(Q,I,s,F,d)$. $Q$ is the set of states, $I$ is the set of items, $s\\in Q$ is the start state, $F\\subseteq Q$ is the set of accepting states, $d\\subseteq Q\\times 2^I\\times Q\\times 2^I$ is the set of transitions, where $2^I$ is the set of all subsets of $I$. \nA computation of a Bag Automaton starts in $s$, with given item set $I' \\subseteq I$. At each step the bag automaton in state $q$ and associated item set  $I^* \\subseteq I$ does a state transition $(q,A,q',B)$, $A\\subseteq I^*$, which sets the state to $q'$ and the bag automaton's item set to $(I'-A) \\cup B $. $M$ accepts if there is a sequence of transitions from $s$ to an $f \\in F$.</p>\n\n<p><strong>Bag Automaton Computation</strong>\nInput: A Bag Automaton $M=(Q,I,s,F,d)$, a set $I' \\subseteq I$ and a positive integer $k$.</p>\n\n<p>Parameters: $k$</p>\n\n<p>Question: Can $M$ accept on $I'$ by executing at most $k$ transitions?</p>\n\n<p>I am almost certain a reduction from clique where the initial bag contains all vertices will work, but I cannot figure out how to formalize it.</p>\n", 'ViewCount': '51', 'Title': 'Reduction from clique to bag automata', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-01T15:00:21.597', 'LastEditDate': '2014-04-01T15:00:21.597', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '16079', 'Tags': '<complexity-theory><automata><reductions><parametrized-complexity>', 'CreationDate': '2014-03-31T00:46:42.120', 'Id': '23276'},125_198:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to show how to reduce the Partition problem to the 3-Partition problem.<br>\nI'll first describe the problem using the definitions and notations I'm familiar with (I hope they're legit), and will then ask my question.<br>\nSo, the Partition problem is as follow:<br>\nGiven a multiset of integers $X$, we have to decide whether or not $X$ can be <strong>partitioned</strong> into two sub-sets $A,B$ such that $\\sum_{x_i\\in A}x_i=\\sum_{x_i\\in B}x_i$.<br>\nIn the 3-Partition problem, given a multiset of integers $Y$, we have to decide whether or not $Y$ can be <strong>partitioned</strong> into <strong>three</strong> sub-sets $A,B,C$ such that $\\sum_{x_i\\in A}x_i=\\sum_{x_i\\in B}x_i=\\sum_{x_i\\in C}x_i$.  </p>\n\n<p>I want to show a reduction $Partition\\leq _p 3Partition$, \nThat is, to show that given $X$ as input for the Partition problem, I can build $Y$ as input for the 3-Partition problem, s.t. $X$ can be partitioned to two iff $Y$ can be partitioned to three.<br>\nSo given $X$, let $\\sum_{x_i\\in X}x_i=m$, and define $Y$ as:<br>\n$Y=\\left \\{ x_1, x_2,...,x_n,\\frac{m}{2}|x_i\\in X \\right \\}$.   </p>\n\n<p>Proof:<br>\nThe first direction is easy: suppose that $X$ can be partitioned to two sub-sets $A,B$ s.t. the above conditions hold, then $Y$ can be partitioned to three: $A,B,C$, while $C=\\left \\{\\frac{m}{2} \\right \\}$.<br>\nI'm stuck with the second direction: suppose that $Y$ can be partitioned to three, <strong>why does that guarantee that $X$ can be partitioned to two?</strong></p>\n\n<p>b.t.w, how can I be sure that $\\frac{m}{2}$ is an integer? do I even have to pay attention to it?</p>\n", 'ViewCount': '25', 'Title': 'Reduction from Partition problem to 3-Partition problem', 'LastActivityDate': '2014-04-05T11:29:09.473', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23447', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<reductions>', 'CreationDate': '2014-04-05T09:45:08.870', 'Id': '23444'},125_199:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to prove that 3SAT is polynome time reducable to CNF-SAT, but I don't know how to do this. A formula F is in 3SAT iff f(F) is in KNFSAT, but since 3SAT is a part of KNFSAT, every formula that is in 3SAT will automatically be in CNF-SAT. Is my conclusion correct? And how do I actually show this in a correct manner? </p>\n", 'ViewCount': '26', 'Title': '3SAT to CNF-SAT reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T14:09:36.477', 'LastEditDate': '2014-04-07T14:09:36.477', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23514', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<complexity-theory><reductions><satisfiability><3-sat>', 'CreationDate': '2014-04-07T13:16:48.117', 'Id': '23513'},125_200:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m trying to understand/show that DNF VALID is coNP-hard. I have given an algorithm for the complement of DNF VALID and shown that this is in NP (since the complement of a language in NP is in coNP), but I\'m really struggling to show that DNF VALID is coNP-hard. </p>\n\n<blockquote>\n  <p>The complement of DNF VALID = {\u03d5 | \u03d5 is not in DNF OR \u03d5 is falsifiable}</p>\n</blockquote>\n\n<p>A simple algorithm for the complement of DNF VALID:</p>\n\n<pre><code>On a non-deterministic TM M: "on input \u03d5 (boolean formula):\n 1. Scan through \u03d5 and check whether \u03d5 is on DNF. \n      If it is, accept, \n      if not, continue to step 2. \n 2. Non-deterministically choose a valuation for \u03d5\n 3. If \u03d5 is falsifiable accept, if not, reject\n</code></pre>\n\n<p>To show that DNF VALID is coNP-hard I think that I need to show that a language that is NP-complete can be reduced in polynomial time to the complement of DNF VALID, but I\'m not sure with which language to choose, and I could really use some help on how to go forth with the reduction. </p>\n', 'ViewCount': '45', 'Title': 'Showing that DNF VALID is coNP-hard', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-11T06:47:22.733', 'LastEditDate': '2014-04-11T06:47:22.733', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23666', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16655', 'Tags': '<complexity-theory><reductions><co-np>', 'CreationDate': '2014-04-10T18:09:27.833', 'Id': '23654'},125_201:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to find reduction from 3-SAT to Max-2-SAT, so far no luck.<br>\nLet me first describe it.  </p>\n\n<blockquote>\n  <p><strong>3-SAT</strong>: Given a CNF formula $\\varphi$, where every clause in $\\varphi$ has <em>exactly</em> 3 literals in it, one should determine if there exist an assignment that satisfies it.  </p>\n  \n  <p><strong>Max-2-SAT</strong>: Given a CNF formula, where every clause in $\\phi$ has <em>exactly</em> 2 literals in it, and a positive number $k$, one should determine if there exist an assignment that satisfies <em>at least</em> $k$ clauses.</p>\n</blockquote>\n\n<p>Let me first show what I have tried so far.<br>\nGiven $\\varphi=\\wedge _{i=1}^{n}C_i$ where: $C_i=(l_{i_1}\\vee l_{i_2} \\vee l_{i_3})$,<br>\nI set: $\\phi=\\wedge _{j=1}^{3n}D_i$, where: $D_i=(l_{i_1}\\vee l_{i_2})\\wedge(l_{i_1}\\vee l_{i_3})\\wedge(l_{i_2}\\vee l_{i_3})$ and $k=2n$.<br>\nIt\'s quite easy to see that this will not work...<br>\nAlthough, if there exist an assignment which satisfies $\\varphi$ it means there exist an assignment that satisfies $k=2n$ clauses in $\\phi$, the second direction is not true.<br>\nI found several reductions online (such as <a href="http://www.stanford.edu/~rrwill/williams-max2sat-encyc.pdf" rel="nofollow">this</a>, for example), but none of them were useful since in my problem, each clause in $\\phi$ must have <strong>exactly</strong> two literals, where in the link above, the formula can also contain 1-length clause in it.</p>\n\n<p>I could really use some help here.</p>\n', 'ViewCount': '68', 'Title': '3-SAT to Max-2-SAT Reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-13T23:39:21.800', 'LastEditDate': '2014-04-12T13:39:18.530', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<complexity-theory><reductions><np-hard><satisfiability>', 'CreationDate': '2014-04-12T11:58:23.407', 'FavoriteCount': '0', 'Id': '23702'},125_202:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>If $A \\leq_m B$ and $A$ is not mapping reducible to $co\\text{-}B$, then $A \\leq_T co\\text{-}B$.</p>\n</blockquote>\n\n<p>Is this true?</p>\n\n<p>My intuition is false even if we can find some special case to make it true such as $A=B=co\\text{-}A_{TM}$. However, I still can't find a counterexample. </p>\n\n<p>Could anyone give me a little hint?   </p>\n", 'ViewCount': '23', 'Title': 'If A is mapping-reducible to B and is not mapping-reducible to co-B, is A Turing-reducible to co-B?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-15T17:54:12.253', 'LastEditDate': '2014-04-15T10:12:39.880', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<computability><reductions>', 'CreationDate': '2014-04-15T02:39:51.667', 'Id': '23802'},125_203:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m having trouble grasping this the concept of reductions. I found the solution and it looks like this:</p>\n\n<p><img src="http://i.stack.imgur.com/eqv7G.png" alt="enter image description here"></p>\n\n<p>Assume that $M_5$ is a Turing Machine that can decide if a given Turing Machine $M$\naccepts any string of length $5$, i.e., $L(M)$ contains a string of length $5$. The above figure shows how we can use this to construct a Turing Machine that can solve the Halting\nproblem.</p>\n\n<p>The output $M\u2032$ of our translator behaves as follows:</p>\n\n<ol>\n<li>$M\u2032$ erases its own input and replaces it with the string w.</li>\n<li>It them simulates $M$ on $w$.</li>\n<li>If $M$ halts on $w$, then it goes into a final state (accepts its input).\nIt is clear that if $M$ halts on $w$, $M\u2032$ accepts all its inputs. So it accepts a string of length 5 as well.\nIf $M$ does not halt on $w$, $M\u2032$ does not accept any string at all. So it does not accept any\nstring of length 5 either.\nSo $L(M\u2032)$ includes a string of length $5$ if and only of $M$ accepts $w$. So by running $M_5$ on $M\u2032$, we can decide if $M$ halts on $w$ or not. But we know that this is not possible since the halting problem is undecidable. Hence $M_5$ does not exist and the given problem is undecidable.</li>\n</ol>\n\n<p>What I am confused about is: "if $M$ halts on $w$, $M\u2032$ accepts all its inputs" and "If $M$ does not halt on $w$, $M\u2032$ does not accept any string at all". Can someone clarify why this is the case? I\'ve been trying to work out the logic for so long. If any of you guys could help this would be great!</p>\n\n<p><a href="http://web.engr.oregonstate.edu/~tadepall/cs321/09/assigns/sol-a7.pdf" rel="nofollow">Source</a></p>\n', 'ViewCount': '55', 'Title': 'Showing that deciding whether a given TM accepts a word of length 5 is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-15T10:42:26.763', 'LastEditDate': '2014-04-15T10:14:36.127', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23808', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2014-04-15T05:22:14.183', 'Id': '23804'},125_204:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to reduce an optimization problem to a decision problem, more specifically, consider the Max-Cut problem in its decision version:<br>\nGiven $(G=(V,E),k)$ as input, where $G$ is an undirected weighted graph (all weights are positive integers, formally: $w: E\\rightarrow \\mathbb{N}$ is the weight function) and $k\\in\\mathbb{N}$, one should decide whether there exist a cut $(V_1,V_2)$, s.t its weight is at least $k$, meaning $k\\leq \\sum _{u\\in V_1, v\\in V_2}w(u,v)$.<br>\nThe optimization version is simply <strong>finding</strong> the maximum weighted cut.<br>\nWhat I'm trying to achieve is, given an algorithm $A$ that can solve the decision problem, I want to describe an algorithm that can <strong>find</strong> the maximum cut in $G$.<br>\nSo, first of all, this is what I had in mind:   </p>\n\n<ul>\n<li>Find the weight of the maximum cut in $G$ (this can be done with a simple for loop that starts with 1 and stops at $m$, where $m=\\sum _{e\\in E}w(e)$ while in each iteration the algorithm queries $A$), define $k$ to be the weight of the maximum cut.</li>\n<li>Initialize new set $S\\leftarrow \\phi$</li>\n<li>For $e\\in E$ do:\n<ul>\n<li>Omit edge $e=(u,v)$ from $G$, to create new graph $G_e$.</li>\n<li>If  $A(G_e,k)=0$ (both ends of $e$ are at the same set), $S\\leftarrow S\\cup \\left \\{ u,v \\right \\}$</li>\n<li>else if $A(G_e,k)=1$ then...(?)<br>\nThis is where I'm stuck, I'm not sure how can I tell which end of $e$ should be in $S$...<br>\nIn fact, I'm not even sure if this is the right way to do it.</li>\n</ul></li>\n</ul>\n\n<p>Any help and thoughts will be appreciated.</p>\n", 'ViewCount': '29', 'Title': 'Reducing optimization problem to decision problem', 'LastActivityDate': '2014-04-20T19:33:55.867', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23956', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<reductions>', 'CreationDate': '2014-04-20T17:20:12.430', 'Id': '23953'},125_205:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to reduce the MAX-2SAT problem to finding a cut in a graph, with no luck so far.<br>\nLet me first show a description of the problem:<br>\n<strong>2SAT</strong>: Given a boolean formula $\\varphi$ in a CNF form, where every clause has 2 literals (a variable or its negation), one should decide whether there is an assignment that will satisfy $\\varphi$.<br>\nThe 2SAT problem is in $P$.  </p>\n\n<p><strong>MAX-2SAT</strong>: Given a boolean formula $\\varphi$ in a CNF form, where every clause has 2 literals, and $k\\in \\mathbb{N}$, one should decide if there is an assignment that will satisfy at least $k$ clauses in $\\varphi$.<br>\nThis is an $NPC$ problem, and I\'m trying to reduce it to finding the maximum cut in a graph:<br>\n<strong>MAX-CUT</strong>: Given $(G=(V,E), w, k)$, where $G$ is an undirected graph, $w$ is a weight function; $w: E\\rightarrow \\mathbb{N}$ and $k\\in\\mathbb{N}$, one should decide whether there exist a cut $(V_1,V_2)$, s.t its weight is at least $k$, meaning $k\\leq \\sum _{u\\in V_1, v\\in V_2}w(u,v)$.</p>\n\n<p>I tried some obvious constructions that didn\'t work, like setting:<br>\n$G=(V,E)$<br>\n$V=\\left \\{ v_x|x\\text{ is a literal in } \\varphi \\right \\}$<br>\n$E=\\left \\{(v_x,u_z)|\\text{ There exist a clause } x\\vee z \\text{ in } \\varphi\\right \\}$<br>\nand finally setting $w(e)=1$  $\\forall e\\in E$</p>\n\n<p>This obviously didn\'t work, since having $k$ satisfied clauses in $\\varphi$ does not imply a $k$-weighted cut in $G$.<br>\n(If the above can be improved to achieve the desired reduction, I would love to get some guidance)<br>\nI looked around online, and found that it is possible to construct an "implication graph" from $\\varphi$, where every clause $(x\\vee z)$ in $\\varphi$ is translated to the equivalent logical expressions: $\\bar{x}\\Rightarrow z$ and $\\bar{z}\\Rightarrow x$, and these, in turn, are translated to vertices $\\bar{x}, z, \\bar{z}, x$, and <strong>directed</strong> edges $\\bar{x}\\rightarrow z$ and $\\bar{z}\\rightarrow x$, but I just can\'t see how that helps, since, again, $k$ satisfied clauses in $\\varphi$ does not imply $k$-weighted cut in $G$.<br>\nAny help would be greatly appreciated.</p>\n', 'ViewCount': '48', 'Title': 'How to reduce MAX-2SAT problem to finding a cut in a graph', 'LastActivityDate': '2014-04-21T18:30:22.827', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<reductions>', 'CreationDate': '2014-04-21T11:39:29.070', 'Id': '23984'},125_206:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In the standard proof why Subset-Sum is (weakly) NP-complete, one reduces Vertex Cover to Subset-Sum by using suitable numbers with O(m+n) bits (where m is the number of edges and n the number of vertices). But how can we talk about a polynomial time reduction if we generate exponential-size numbers?</p>\n\n<p>I guess that this is the key why Vertex Cover is strongly NP-complete and Subset-Sum is only weakly NP-complete. But I didn't get why it is in fact a polynomial time reduction.</p>\n", 'ViewCount': '92', 'Title': 'Why is the reduction from Vertex-Cover to Subset-Sum of polynomial time?', 'LastActivityDate': '2014-04-24T12:49:16.590', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24079', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15270', 'Tags': '<np-complete><reductions>', 'CreationDate': '2014-04-24T11:39:01.647', 'Id': '24078'},125_207:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let us consider  where G is an undirected weighted graph G = is an undirected graph. f &lt;=|V| is an integer and d>=0 is a real number. Is it possible to select f vertices of G as token locations, such that the length of the shortest path between any vertex and its nearest tokens is at most d. </p>\n\n<p><strong>token placement belongs to NP:</strong> the certificate is a weighted directed graph, with f token locations and the value d. Given the certificate, we can verify in polynomial time that the path from any vertex to its closest token location is at most d. Given that there are n vertices within the graph, this will take us polynomial time. </p>\n\n<p><strong>Reduction:</strong> I want to select the shortest path between any vertex and its nearest token. Thus reminds me of subset sum \nreduce from subset sum, I have 1 set S and a target value t. \nLet me construct a graph made of one vertex with k edges, k being the number of elements in the set S. the k edges are k self loops on the vertex v.  each element within S is assigned to the weight of one self loops. Reduction takes polynomial time, given that I have n elements in a set S, I have to draw a graph with n self loops. this takes polynomial time. </p>\n\n<p>Proof of correctness:\n1) if subset Sum has a solution, this means that there is a set S' such that the sum of all the elements within S' equal the target value t. Thus, there must be a set of edges within the graph whose sum of weights equals t. Given that the number of elements within the subset S' equals the number of edges whose weights sum up to t. This means, that considering graph G made of e edges, each edge's weight being one element within the set S,this means that there is a set f of edges such that f= the size of S' whose values are at most equal to d, where d equals the target value t. all of the elements within S' correspond to one or more edge weights flowing into the single vertex of the graph. Thus, given the target value t and the set of token locations f. There must be an edge between any vertex and its closest token locations such that it is less than or equal to the target value. f is the number of times the same  node v is visited. </p>\n\n<p>2) If the token problem has a solution, this means that there is a set f of token locations, , number of times v is visited and the edge weight of any edge e in the graph is at most d.  Let us sum up f edge weights within G. Thus, we have a subset of weights whose sum equals to the value d. Since, all of the edges flow into the vertex. Thus, given f token locations, a value d and a graph G, the path from any vertex to its closest token location(which is itself given self loops) is at most d, where d could be the weight of one edge if f=1 or the sum of the weights of many edges if f>1. given f token locations which refer to f edge weights, the sum of all the f edge weights equals the value d. \nThe edges weights of the f edges traversed included in the subset K, their sum is d. The subset K is equivalent to the subset S' in the subset sum problem and the weight d is equivalent to the target value in the subset problem. </p>\n\n<p>Conclusion: token placement has a solution iff subset sum has a solution. </p>\n\n<p>this means that there are f token locations surrounding vertex v, such that the length of any </p>\n", 'ViewCount': '42', 'ClosedDate': '2014-04-25T06:56:07.297', 'Title': "what's wrong with this NP completeness proof", 'LastEditorUserId': '17053', 'LastActivityDate': '2014-04-25T16:01:41.893', 'LastEditDate': '2014-04-25T16:01:41.893', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17053', 'Tags': '<complexity-theory><np-complete><reductions><np>', 'CreationDate': '2014-04-24T23:35:04.413', 'Id': '24091'},125_208:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have no source for this, but I've heard people offhandedly mention problems that are NP Complete under polylog reductions (I <em>think</em> SAT was one of them).</p>\n\n<p>This confuses me - it seems to me that this is a violation of the nondetermistic time hierarchy.  If SAT (or whatever) can be solved in $NTIME(n^c)$ for some $c$, and any $NP$-problem can be reduced to SAT in $O(n^k)$ time for some fixed $k$, then it seems that we can solve any $NP$ problem in $O(n^{c+k})$ nondetermistic time -- obviously false.</p>\n\n<p>So, it seems to me that SAT (or whatever) can only be NP-Complete under polytime reductions, and that for any polynomial, we can find a problem whose reduction to SAT takes <em>more</em> than that polynomial amount of time.</p>\n\n<p>What am I missing?</p>\n", 'ViewCount': '65', 'Title': 'How is it possible for a problem to be NP-Complete under polylog-time reductions?', 'LastActivityDate': '2014-04-28T02:57:19.630', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16172', 'Tags': '<np-complete><reductions>', 'CreationDate': '2014-04-28T01:25:31.030', 'Id': '24167'},125_209:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to prove that the Acyclic Subgraph Problem (AS) is NP-hard by showing that the Independent Set Problem (IS) is polynomially reducible to AS. </p>\n\n<p><strong>AS is as follows:</strong> Given a directed graph G = (V, E) and an integer k, does G contain a subset V' of\nk vertices such that the induced subgraph on V'is acyclic?</p>\n\n<p><strong>IS is as follows:</strong> Given an undirected graph G = (V, E) and an integer k, does G contain a subset V' of k vertices such that no two vertices in V'are adjacent to one another?</p>\n\n<p><strong>I have developed the following:</strong>\nGiven an undirected graph, <em>G = (V,E)</em>, we can construct a directed graph, <em>D =(V, E')</em>. We do this by addd the edges <em>(u,v)</em> and <em>(v,u)</em> for every edge in <em>E</em>. If <em>G</em> has an independent set of size <em>k</em>, then the corresponding vertices in <em>D</em> are an acyclic subgraph. Similarly, if <em>D</em> has an acyclic subgraph of size <em>k</em>, then those <em>k</em> vertices must form an independent set in <em>D</em> as if there is an edge between two vertices in <em>D</em>. Then, there is a directed cycle between them, thus those <em>k</em> vertices form an independent set in <em>G</em>. </p>\n\n<p>Can anyone help me further with this proof? I am not sure if what I have is going in the right direction or not. </p>\n\n<p>Any help is appreciated, thanks! </p>\n", 'ViewCount': '23', 'Title': 'Prove that Acyclic Subgraph is NP-Hard by showing Independent Set can be reduced to Acyclic Subgraph', 'LastActivityDate': '2014-04-28T19:11:30.353', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17151', 'Tags': '<algorithms><np-complete><reductions><np-hard>', 'CreationDate': '2014-04-28T19:11:30.353', 'Id': '24197'},125_210:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '11', 'Title': 'Is it possible to do reductions with non-decision problems?', 'LastEditDate': '2014-05-02T21:48:04.360', 'AnswerCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16780', 'FavoriteCount': '1', 'Body': "<p>I've recently begun studying reductions in my algorithms class. All the reductions I've seen have been from decision problem $\\to$ decision problem.</p>\n\n<p>Is it possible to do reductions with non-decision problems? \nCan NP-hardness be shown in that way?</p>\n", 'ClosedDate': '2014-05-02T21:57:12.900', 'Tags': '<complexity-theory><reductions><optimization>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T21:48:04.360', 'CommentCount': '3', 'CreationDate': '2014-05-02T20:58:15.810', 'Id': '24327'}