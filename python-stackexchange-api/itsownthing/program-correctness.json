{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have been reading about PHP and many authors mention semantic and logical errors separately. As an example of a semantic error, they give a function called with incorrect number of parameters: this will not be caught by the parser, but will throw an error when run.</p>\n\n<p>Yet in languages such as C++, this will be caught by the compiler. I would say that it\'s a syntax error then. What is the difference then between a semantic and a logical error?</p>\n\n<p>For example, in <a href="http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap01.htm" rel="nofollow">How to think like a computer scientist</a>, the author uses "logic error" and "semantic error" interchangeably. On the other hand, in the <a href="http://flylib.com/books/en/4.350.1.159/1/" rel="nofollow">Visual Basic .NET. Primer Plus</a>, "logic error" is separated from "semantic error".</p>\n', 'ViewCount': '519', 'Title': 'Can all languages have semantic and logical errors?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-13T01:58:13.523', 'LastEditDate': '2012-09-12T22:52:42.637', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'OwnerDisplayName': 'user970696', 'PostTypeId': '1', 'Tags': '<terminology><programming-languages><compilers><program-correctness>', 'CreationDate': '2012-08-31T09:12:57.057', 'FavoriteCount': '1', 'Id': '3519'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Can GDB be run on itself? How or why not?\nI see something about it <a href="http://www.math.utah.edu/docs/info/gdbint_3.html" rel="nofollow">http://www.math.utah.edu/docs/info/gdbint_3.html</a>\nBut GDB might not be written in a language that it can debug?</p>\n', 'ViewCount': '107', 'Title': 'Can GDB debug itself?', 'LastActivityDate': '2013-01-30T15:23:59.747', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '9310', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2529', 'Tags': '<correctness-proof><program-correctness>', 'CreationDate': '2013-01-30T14:47:04.433', 'Id': '9308'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In Corman, Introduction To Algorithms, 3rd edition, question 2-4 it asks to count the number of inversions in a list of numbers in $\\theta( n \\lg n )$ time.  He uses a modified Merge Sort to accomplish this.  However, there is something in his algorithm which seems redundant / unnecessary to me:</p>\n\n<pre><code>MERGE-INVERSIONS(A, p, q, r)\nn1 = q - p + 1\nn2 = r - q\nlet L[1 ... n1 + 1] and R[1 ... n2 + 1] be new arrays\nfor i = 1 to n1\n    L[i] = A[p + i - 1]\nfor j = 1 to n2\n    R[j] = A[q + j] \nL[n1 + 1] = infinity\nR[n2 + 1] = infinity\ni = 1\nj = 1\ninversions = 0\ncounted = FALSE\nfor k = p to r\n    if counted == FALSE and R[j]  &lt; L[i]\n        inversions = inversions + n1 - i + 1\n        counted = TRUE\n    if L[i] &lt;= R[j] \n        A[k] = L[i]\n        i++\n    else A[k] = R[j] \n        j++\n        counted = FALSE\nreturn inversions\n</code></pre>\n\n<p>The <code>counted</code> variable seems redundant to me and I would have written the last for loop as follows:</p>\n\n<pre><code>inversions = 0\nfor k = p to r\n    if L[i] &lt;= R[j] \n        A[k] = L[i]\n        i++\n    else A[k] = R[j] \n        inversions = inversions + n1 - i + 1\n        j++\nreturn inversions\n</code></pre>\n\n<p>What am I missing, or is <code>counted</code> really unnecessary?</p>\n', 'ViewCount': '959', 'Title': 'Counting Inversions Using Merge Sort', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-17T11:56:28.703', 'LastEditDate': '2013-02-17T11:38:20.870', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9861', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<algorithms><algorithm-analysis><sorting><program-correctness>', 'CreationDate': '2013-02-17T10:23:24.240', 'Id': '9858'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Would it be correct to characterize loop invariants as a type of tautology?  I ask since the invariant must basically always be true, before the loop starts, before each iteration and after the loop terminates.  I realize that there is the possibility that the invariant could become false during the body of the loop.  But since inside the loop "doesn\'t count" is it fair to characterize the invariant as a tautology?</p>\n', 'ViewCount': '92', 'Title': 'Loop Invariants as Tautologies', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T21:25:07.547', 'LastEditDate': '2013-03-12T14:08:56.163', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '10471', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6728', 'Tags': '<algorithm-analysis><logic><correctness-proof><loop-invariants><program-correctness>', 'CreationDate': '2013-03-12T07:57:56.437', 'Id': '10469'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Suppose you have some loop and and integer k:</p>\n\n<pre><code>int k = 5;\nfor (int i = 0 ; i &lt; N; i++)\n{\n  //(*)\n  //do something \n}\n</code></pre>\n\n<p>The loop invariant at (*) is:\n$\\{ K=k\\}$</p>\n\n<p>Does that guarantee that $k$ doesn't change in between iterations? if not, is there any otherway to guarantee that?</p>\n", 'ViewCount': '35', 'Title': 'Does this loop invariant guarantee that the variable never changes?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-12T23:04:59.827', 'LastEditDate': '2013-04-12T23:04:59.827', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11270', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<loop-invariants><program-correctness><hoare-logic>', 'CreationDate': '2013-04-12T16:12:13.507', 'Id': '11269'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've been reading a book on using loop invariants and induction to prove program correctness. Then I came across the following program which got me thinking...</p>\n\n<h1>Specification for Cube_Root(n)</h1>\n\n<p>Pre-Condition : n is a natural number.\nPost-Condition: Cube_Root returns a natural number i that is the cube root of n or it returns -1 if no such root exists</p>\n\n<p>Cube_Root(n)\n  i = 0\n  while i &lt; n\n    if i * i * i = n\n      return(i)\n    else\n      i = i + 1</p>\n\n<p>return(-1)</p>\n\n<p>In the book, the proof proceeds by finding a loop invariant. \nSo for example let us define the following as our loop invariant:</p>\n\n<p>Loop Invariant P(i): i is either the natural number cube root of n or i >= n\nThe proof is then supposed to proceed by induction on i.\nSo we need to prove that P(0) is true, assume that P(i) is true for some i and then establish that if P(i) is true then P(i+1) is true.</p>\n\n<p>P(0) is trivial to prove true:\n  Basis P(0): i = 0. \n    if n == 0 then i is a natural number and the the cube root of n\n    otherwise n > 0 (since n is a natural number) and hence i &lt; n</p>\n\n<p>However, the problem arises when you try to infer P(i+1) from P(i). it doesn't look like you can because if i is not the cube root of n, it doesn't tell you anything about whether i+1 is or is not the cube root of n.</p>\n\n<p>So my question(s) are:</p>\n\n<p>1) Has it been proven that for any program there exists a loop invariant on which you can \n   use induction to prove the program is correct?\n2) The loop invariant chosen for Cube_Root is obviously true after the loop terminates \n   which proves that the post-condition of the program is satisfied. Hence, that proves \n   partial correctness of the program. However, we did not need to use induction to prove \n   that. Is that an acceptable proof? If not, how do we use induction to prove Cube_Root \n   correct?</p>\n", 'ViewCount': '529', 'Title': 'Proof of Program Correctness - Loop Invariants', 'LastActivityDate': '2013-06-13T07:52:09.430', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8639', 'Tags': '<loop-invariants><program-correctness>', 'CreationDate': '2013-06-12T14:59:53.087', 'Id': '12638'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '385', 'Title': 'Formal program verification in practice', 'LastEditDate': '2013-08-17T15:04:01.323', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '9667', 'FavoriteCount': '3', 'Body': '<p>As a software engineer, I write a lot of code for industrial products. Relatively complicated stuff with classes, threads, some design efforts, but also some compromises for performance. I do a lot of testing, and I am tired of testing, so I got interested in formal proof tools, such as Coq, Isabelle... Could I use one of these to formally prove that my code is bug-free and be done with it? - but each time I check out one of these tools, I walk away unconvinced that they are usable for everyday software engineering. Now, that could only be me, and I am looking for pointers/opinions/ideas about that :-)</p>\n\n<p>Specifically, I get the impression that to make one of these tools work for me would require a huge investment to properly define to the prover the objects, methods... of the program under consideration. I then wonder if the prover wouldn\'t just run out of steam given the size of everything it would have to deal with. Or maybe I would have to get rid of side-effects (those prover tools seem to do really well with declarative languages), and I wonder if that would result in "proven code" that could not be used because it would not be fast or small enough. Also, I don\'t have the luxury of changing the language I work with, it needs to be Java or C++: I can\'t tell my boss I\'m going to code in OXXXml from now on, because it\'s the only language in which I can prove the correctness of the code... </p>\n\n<p>Could someone with more experience of formal proof tools comment? Again - I would <em>LOVE</em> to use a formal prover tool, I think they are great, but I have the impression they are in an ivory tower that I can\'t reach from the lowly ditch of Java/C++... (PS: I also <em>LOVE</em> Haskell, OCaml... don\'t get the wrong idea: I am a fan of declarative languages and formal proof, I am just trying to see how I could realistically make that useful to software engineering)</p>\n\n<p>Update: Since this is fairly broad, let\'s try the following more specific questions: 1) are there examples of using provers to prove correctness of industrial Java/C++ programs? 2) Would Coq be suitable for that task? 3) If Coq is suitable, should I write the program in Coq first, then generate C++/Java from Coq? 4) Could this approach handle  threading and performance optimizations? </p>\n', 'Tags': '<programming-languages><program-correctness><software-verification>', 'LastEditorUserId': '9667', 'LastActivityDate': '2013-08-22T15:58:29.473', 'CommentCount': '7', 'AcceptedAnswerId': '13842', 'CreationDate': '2013-08-17T01:51:39.910', 'Id': '13785'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '150', 'Title': 'Could program verification techniques prevent bugs of the genre of Heartbleed from occurring?', 'LastEditDate': '2014-04-16T12:41:34.870', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'Mok-Kong Shen', 'PostTypeId': '1', 'OwnerUserId': '6437', 'FavoriteCount': '1', 'Body': '<p>On the matter of the Heartbleed bug, Bruce Schneier wrote in his Crypto-Gram of 15th April:\n\'"Catastrophic" is the right word. On the scale of 1 to 10, this is an 11.\' I read several years ago that a kernel of a certain operating system has been rigorously verified with a modern program verification system. Could hence bugs of the genre of Heartbleed be prevented from occurring via application of program verification techniques today or is this yet unrealistic or even principally impossible?</p>\n', 'Tags': '<cryptography><correctness-proof><security><software-verification><program-correctness>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-23T20:21:04.283', 'CommentCount': '1', 'CreationDate': '2014-04-15T14:30:22.640', 'Id': '23856'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Without using any Haore logic, given the following Hoare triple: <code>(|x \u2265 1|) C (|y \u2265 1|)</code> is partially correct and using the definition of partial correctness. </p>\n\n<p>How to determine if <code>(|x &gt; 1|) C (|y \u2265 1|)</code> is partially correct or not?</p>\n\n<p>C is a piece of code</p>\n', 'ViewCount': '8', 'ClosedDate': '2014-04-29T08:37:05.757', 'Title': u'How to determine if (|x > 1|) C (|y \u2265 1|) is partially correct ? - Partial correctness', 'LastActivityDate': '2014-04-29T02:04:46.897', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17160', 'Tags': '<program-correctness><hoare-logic><reasoning>', 'CreationDate': '2014-04-29T02:04:46.897', 'Id': '24206'}},