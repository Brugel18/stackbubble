{'Body': '<p>Given a TSP instance $T$, decide whether changing the city coordinates by adding a vector of coordinates $v$ will change the optimal TSP objective by atleast $x$. The city coordinates are integers.</p>\n\n<p>The problem is in PSPACE but even the verification problem seems to be NP-hard. Is that true?</p>\n\n<p>If the verification problem is NP-hard, what exact complexity class does this problem belong to?</p>\n', 'ViewCount': '192', 'Title': 'What complexity class does this variation of traveling salesman problem belong to?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:04:38.777', 'LastEditDate': '2013-06-06T15:04:38.777', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2160', 'Tags': '<complexity-theory><reductions><np-hard><decision-problem><traveling-salesman>', 'CreationDate': '2012-07-13T23:45:51.823', 'Id': '2737'}{'ViewCount': '3016', 'Title': 'How can I verify a solution to Travelling Salesman Problem in polynomial time?', 'LastEditDate': '2013-06-06T15:04:45.980', 'AnswerCount': '4', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '1558', 'FavoriteCount': '5', 'Body': '<p>So, <a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem#Computational_complexity">TSP (Travelling salesman problem) decision problem is <strong>NP complete</strong></a>.</p>\n\n<p>But I do not understand how I can verify that a given solution to TSP is in fact optimal in polynomial time, given that there is no way to find the optimal solution in polynomial time (which is because the problem is not in P)?</p>\n\n<p>Anything that might help me see that the verification can in fact be done in polynomial time?</p>\n', 'Tags': '<complexity-theory><np-complete><traveling-salesman>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:04:45.980', 'CommentCount': '0', 'AcceptedAnswerId': '2835', 'CreationDate': '2012-07-20T07:25:47.367', 'Id': '2834'}{'Body': "<p>For the branch-and-cut method, it is essential to know many facets of the polytopes generated by the problem. However, it is currently one of the hardest problems to actually calculate all facets of such polytopes as they rapidly grow in size.</p>\n\n<p>For an arbitrary optimization problem, the polytope used by branch-and-cut or also by cutting-plane-methods is the convex hull of all feasible vertices. A vertex is an assignment of all variables of the model. As a (very simple) example: if one would maximize $2\\cdot x+y$ s.t. $x+y \\leq 1$ and $0\\leq x,y\\leq 1.5$ then the vertices $(0,0)$, $(0,1)$ and $(1,0)$ are feasible vertices. $(1,1)$ violates the inequality $x+y\\leq 1.5$ and is therefore not feasible. The (combinatorical) optimization problem would be to choose among the feasible vertices. (In this case, obviously $(1,0)$ is the optimum). The convex hull of these vertices is the triangle with exactly these three vertices. The facets of this simple polytope are $x\\geq0$, $y\\geq 0$ and $x+y\\leq 1$. Note that the description through facets is more accurate than the model. In most hard problems - such as the TSP - the number of facets exceeds the number of model inequalities by several orders of magnitude.</p>\n\n<p>Considering the Travelling Salesman Problem, for which number of nodes is the polytope fully known and how much facets are there. if it is not complete, what are lower bounds on the number of facets?</p>\n\n<p>I'm particularly interested in the so-called hamiltonian path formulation of the TSP:</p>\n\n<p>$$min \\sum_{i=0}^{n-1}(\\sum_{j=0}^{i-1}c_{i,j}\\cdot x_{i,j}+\\sum_{j=i+1}^{n-1}c_{i,j}\\cdot x_{i,j})$$ s.t.</p>\n\n<p>$$\\forall i \\neq j:\\ \\ 0 \\leq x_{i,j}\\leq 1$$\n$$\\forall i \\neq j\\ \\ \\ x_{i,j}+x_{j,i}\\leq 1$$\n$$\\forall j \\ \\ \\sum_{i=0}^{j-1}x_{i,j}+\\sum_{i=j+1}^{n-1}x_{i,j}\\leq 1$$\n$$\\forall j \\ \\ \\sum_{i=0}^{j-1}x_{j,i}+\\sum_{i=j+1}^{n-1}x_{j,i}\\leq 1$$\n$$\\sum_{i=0}^{n-1}(\\sum_{j=0}^{i-1}x_{i,j}+\\sum_{j=i+1}^{n-1}x_{i,j})=n-1$$</p>\n\n<p>If you have any information about polytopes of other formulations of the TSP, feel free to share that too.</p>\n", 'ViewCount': '458', 'Title': 'Known facets of the Travelling Salesman Problem polytope', 'LastEditorUserId': '39', 'LastActivityDate': '2014-01-10T11:09:53.913', 'LastEditDate': '2013-06-06T15:04:53.917', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1227', 'Tags': '<algorithms><optimization><linear-programming><mathematical-programming><traveling-salesman>', 'CreationDate': '2012-08-29T21:07:54.547', 'FavoriteCount': '2', 'Id': '3367'}{'ViewCount': '152', 'Title': 'Recommended Reading for non-CS undergraduate student doing a research Project on Travelling Salesman Problem', 'LastEditDate': '2013-06-06T15:05:33.373', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'rrampage', 'PostTypeId': '1', 'OwnerUserId': '2642', 'FavoriteCount': '1', 'Body': '<p>I am an undergraduate student in Industrial Engineering. I have taken the topic of Travelling Salesman Problem as a Research Project for my final year. More specifically, I am focusing on <strong>Convex Hulls for solving the Euclidean TSP</strong>.</p>\n\n<p>I have gone through the published literature and have found that there are no approximation bounds for solving TSP using this method. I have just a little background in TheoCS (Started reading for fun since the last 3 months).</p>\n\n<p><strong>My Question:</strong> </p>\n\n<p>Additional Books / Papers needed for achieving a good understanding of the mathematical rigor of the problem.</p>\n\n<p>Here\'s what I am currently going through:</p>\n\n<ul>\n<li>Approximation Algorithms - Vazirani</li>\n<li>Introduction to Algorithms - CLRS</li>\n<li>Introduction to Graph Theory - Douglas West</li>\n<li>Randomized Algorithms - Motwani and Raghavan</li>\n</ul>\n\n<p>I have also completed an introductory online course on Algorithms by Udacity.</p>\n\n<p>I think I may need some background reading in Computational Geometry (Currently I do not know more than what I read in the chapter from Cormen)</p>\n\n<p>This is my first question here, so sincere apologies in case my question does not conform to the Community Standards.</p>\n\n<p>EDIT:</p>\n\n<p>A resource I stumbled across today: <a href="http://press.princeton.edu/titles/9531.html" rel="nofollow">In Pursuit of the Traveling Salesman - Mathematics at the Limits of Computation</a>.\nThis is a good book for popular reading, providing a survey of the problem and various methods that have been used to solve it.</p>\n', 'Tags': '<reference-request><optimization><books><traveling-salesman>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:05:33.373', 'CommentCount': '0', 'CreationDate': '2012-09-13T21:59:28.047', 'Id': '3539'}{'Body': '<p>I am interested if there exists a following version of the travelling salesman problem:</p>\n\n<blockquote>\n  <p>INSTANCE: A finite set $C = \\{1,2,\\dots,k\\}$ of cities, a positive integer distance $\\delta(i,j)$ for each pair of cities, and two positive integers $d$ and $B$.</p>\n  \n  <p>QUESTION: Is there a tour that visits every city in $C$, includes exactly $d$ detours, and has total length no more then $B$?  In other words, suppose $OPT$ is the optimal permutation of the cities; that is, $OPT(i)$ is the next city after city $i$ in an optimal traveling salesman tour.  Is there an ordering $x(0), \\dots, x(k-1)$ of the cities such that $$\\sum_{i=1}^{k} \\delta(x(i), x((i+1) \\bmod k)) \\leq B$$ and there are exactly $d$ indices $i$ where $x((i+1) \\bmod k) \\ne OPT(x(i))$?</p>\n</blockquote>\n\n<p>The $d$ implies that if my shortest tour is $a\\rightarrow b \\rightarrow c\\rightarrow a$ but $d=1$ then what would be the shortest path if I had to first go to $c$, $ a \\rightarrow c \\rightarrow ...$. So $d$ tells me that I have to make $d$ number of wrong choices but I can choose these choices in any way I want to to minimize the length of the path.</p>\n\n<p>Is this a problem worthwhile describing? Or if it has been described where could I see an example? </p>\n', 'ViewCount': '90', 'Title': 'Travelling salesman problem with detours', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:05:07.807', 'LastEditDate': '2013-06-06T15:05:07.807', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6697', 'Tags': '<complexity-theory><graph-theory><np-hard><decision-problem><traveling-salesman>', 'CreationDate': '2013-02-15T10:58:21.960', 'Id': '9802'}{'Body': '<p>I am interested in the following version of TSP:</p>\n\n<p><strong>Assumption:</strong> TSP where the distances are non-negative. We know the algorithm A which computes the optional solution for such instances of TSP.<br>\n<strong>Task:</strong> State an algorithm that uses the algorithm A and computes an optimal solition for instances where negative distances are allowed. </p>\n', 'ViewCount': '173', 'Title': 'Traveling salesman problem - negative distances allowed', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-10T14:04:07.183', 'LastEditDate': '2013-06-06T15:04:59.887', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '12388', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8072', 'Tags': '<complexity-theory><np-complete><traveling-salesman>', 'CreationDate': '2013-05-30T23:58:46.050', 'Id': '12387'}{'Body': u'<p>I want to solve the Physical Travelling Salesman Problem using an evolutionary algorithm.</p>\n\n<p>The objective of the PTSP is to visit the maximum number of waypoints of the map in the minimum number of time steps. \nThe map takes the form of a two-dimensional board, where ten waypoints are scattered around and multiple obstacles are present.</p>\n\n<p>Now, I have a way to run random games and create "population" \u2014 a list of waypoints in the order we visit them.\nI need some idea how to do the crossover. I mean, how to create the next generation.\nI saw ideas, but they take in account that each gene contains <em>all</em> the waypoints on the map. (Take a random part from parent1 and take the waypoints that do not appear in parent1 from parent2 in the order they appear in parent2).\nWhat to do in case a gene contains just part of the waypoints?</p>\n', 'ViewCount': '120', 'Title': 'Evolutionary algorithm for the Physical Travelling Salesman Problem', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-06T15:03:33.913', 'LastEditDate': '2013-06-06T15:03:33.913', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'user2459338', 'PostTypeId': '1', 'OwnerUserId': '8546', 'Tags': '<genetic-algorithms><traveling-salesman>', 'CreationDate': '2013-06-06T11:02:17.433', 'Id': '12485'}{'Body': '<p>In Graph-Theory there are many ways for efficient approximation-algorithms to solve the Metric TSP. The best solution seems to be the Christofides Heuristic with a factor of 1.5 to the optimal solution. My Teacher said, there would be the so called $\\frac{4}{3}$-conjecture, which states: there might be a approximation solution for the metric tsp, that has only a $\\frac{4}{3}$-factor.</p>\n\n<p>But i cannot find any literature or further information about this assumption. Maybe you can?</p>\n', 'ViewCount': '54', 'Title': 'Where can i find literature about the $\\frac{4}{3}$-conjecture for approximation of the Metric TSP?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T14:49:29.627', 'LastEditDate': '2013-06-10T14:49:29.627', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12594', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6828', 'Tags': '<complexity-theory><reference-request><np-complete><approximation><traveling-salesman>', 'CreationDate': '2013-06-10T10:33:26.633', 'Id': '12593'}{'Body': '<p>I try to solve Physical Travelling Salesman Problem using evolutionary algorithm and I have diffucult to detemine how to choose the parent , on which we do the crossover.</p>\n\n<p>Assume I have popultion of 100. \nThe parent should be selected randomally? or according to their fitness? \nIf I choose them randomally I don\'t think the result be enough good but in the other hand, if I will choose the 2 with the best fitness, I will always choose the same! (Maybe child  of them , but most of my population will never be choosed!).</p>\n\n<p>What I miss?</p>\n\n<p>I also need some advise on how to calculate fitness. The parameters are the amount of waypoints each van collect and the total time.</p>\n\n<p>My problem here is becuase there are unit that don\'t manage to collect any points and thus thier fitness is 0 and step by step my array full with 0....(I am working with the code here : <a href="http://www.ptsp-game.net/" rel="nofollow">http://www.ptsp-game.net/</a> ant there is problem of time exceed..)</p>\n', 'ViewCount': '56', 'Title': 'Evolutionary algorithm - how to select the parents', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-05T14:23:17.103', 'LastEditDate': '2014-02-05T14:23:17.103', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8546', 'Tags': '<traveling-salesman><genetic-algorithms>', 'CreationDate': '2013-06-13T05:07:01.893', 'Id': '12648'}{'ViewCount': '406', 'Title': 'About metric TSP instances', 'LastEditDate': '2013-07-03T21:59:48.323', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8997', 'FavoriteCount': '1', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Christofides_algorithm" rel="nofollow">Christofides\' 1.5-approximation</a> considers complete graphs as inputs, and as I understand this is essential. If the input graph is not complete, how can I add new edges with suitable weights such that the resulting complete graph still satisfies the triangle inequality, and, of course, the TSP solution for the complete graph only uses original edges? Thank you.  </p>\n', 'Tags': '<graphs><approximation><traveling-salesman>', 'LastEditorUserId': '8997', 'LastActivityDate': '2013-07-04T00:20:24.543', 'CommentCount': '0', 'AcceptedAnswerId': '13077', 'CreationDate': '2013-07-03T21:27:28.363', 'Id': '13070'}{'Body': '<p>Is there an efficient algorithm which gives the minimum cost closed walk in an undirected graph, which visits all vertices?</p>\n\n<p>Does this problem have a name? I tried to reduce this to similar problems (in particular the traveling salesman problem) to see if it was NP-hard, but was unsuccessful.</p>\n\n<p>Here\'s an example:</p>\n\n<p><img src="http://i.stack.imgur.com/3dxzt.png" alt="enter image description here"></p>\n\n<p>Then a possible closed walk is: A,B,C,D,C,B,A, with a cost of 6.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '203', 'Title': 'Minimum cost closed walk in a graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-15T11:10:55.033', 'LastEditDate': '2013-07-14T09:51:41.813', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '13283', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9173', 'Tags': '<algorithms><graphs><np-hard><graph-traversal><traveling-salesman>', 'CreationDate': '2013-07-14T05:04:52.683', 'Id': '13267'}{'Body': u'<p>The paragraph on V-opt heuristic TSP algorithms at <a href="http://en.wikipedia.org/wiki/Travelling_salesman_problem#Heuristic_and_approximation_algorithms" rel="nofollow">this site</a> mentions a very effective algorithm due to Lin-Kernigham-Johnson. That page says: </p>\n\n<blockquote>\n  <p>For many years Lin\u2013Kernighan\u2013Johnson had identified optimal solutions for all TSPs where an optimal solution was known and had identified the best known solutions for all other TSPs on which the method had been tried.</p>\n</blockquote>\n\n<p>Impressive, so what is the complexity of that algorithm? Does the algorithm often work faster than predicted  based on theoretical complexity (if yes, how much)? Is that algorithm used most often in software that solves the TSP?</p>\n', 'ViewCount': '138', 'Title': 'Complexity of the V-opt heuristic Traveling Salesman algorithm', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-23T22:21:29.497', 'LastEditDate': '2013-07-22T14:15:56.187', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13404', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6641', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><traveling-salesman>', 'CreationDate': '2013-07-22T01:01:32.150', 'Id': '13380'}{'Body': '<p>Can you provide an example of NN algorithm failure on the Euclidean traveling salesman problem?</p>\n\n<p>I was trying to construct a specific example of this for my friends and was failing.</p>\n', 'ViewCount': '229', 'Title': 'When does the nearest neighbor heuristic fail for the Traveling Salesperson?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-08-30T18:00:29.553', 'LastEditDate': '2013-08-14T19:07:46.930', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '13744', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9662', 'Tags': '<algorithms><heuristics><traveling-salesman>', 'CreationDate': '2013-08-14T18:37:46.277', 'Id': '13742'}{'ViewCount': '1579', 'Title': u'Traveling Salesman - Held\u2013Karp algorithm - BIG improvement', 'LastEditDate': '2013-10-17T22:35:11.870', 'AnswerCount': '1', 'Score': '-9', 'PostTypeId': '1', 'OwnerUserId': '10572', 'FavoriteCount': '1', 'Body': u'<p>I think that I found a polynomial solution to TSP problem. How ever in order to prove the "think" there are many questions need to be answered. I hope you be able to help me.</p>\n\n<ul>\n<li><a href="http://cs.stackexchange.com/questions/14998/traveling-salesman-heldkarp-algorithm-improvement">Part 0</a> - The first question that I asked about it, comes with <a href="https://drive.google.com/folderview?id=0B1ttIJPHEPWFTUVfSFBYb185V1k&amp;usp=sharing" rel="nofollow">sample source code</a>.</li>\n<li><strong>Part 1</strong> - The fundamentals, the basic theory of my algorithm.</li>\n<li><a href="http://cs.stackexchange.com/questions/16165/traveling-salesman-using-the-shorter-path-in-order-to-find-1">Part 2</a> - Stop condition number 1: Using the shorter path in order to find 1 </li>\n<li><a href="http://cs.stackexchange.com/questions/16166/traveling-salesman-intersections">part 3</a> - Stop condition number 2: Intersections</li>\n<li><a href="http://cs.stackexchange.com/questions/16175/traveling-salesman-intersections-looping">Part 4</a> - Stop condition number 3: Intersections Looping</li>\n<li><a href="http://cs.stackexchange.com/questions/16177/traveling-salesman-exact-algorithm">final part</a> - Exact solution</li>\n</ul>\n\n<h2>Base assumption:</h2>\n\n<p><strong>If we found the shortest route for a given input of $N$ cities (let it be called main route), so each sub route between any 2 cities on the "main route" will be also the shortest route.</strong></p>\n\n<p>This assumption is easy to prove. Lets say we found a shorter route between two cities on the "Main route". So now we can improve our main route and make him shorter, how ever this is not possible as the main route is the shortest rout by definition.</p>\n\n<p>Also I want to show you the definition of sub route,(you can skip this if you think it\'s to obvious) I will show it by example. If I have the next route: A,C,E,F,H,K so sub route between C and F is: A,C,E,F when I want to find a shorter route for this given sub route, I can only change the places of the cities C, and E, there could be only 2 options for sub routes between A, and F.</p>\n\n<p>Now I will try to show you my implementation, and I want you tell me if I made any bad assumptions or having bad calculations.</p>\n\n<p>Lets say you been given the next input of Cities: A,B,C,D,E,F,H. In order to find the shortest path you will need to perform 720 tests($(7-1)!$). I want to show you how you can cut half of those tests. </p>\n\n<p>When you will start to calculate, this is how your first tests will look like:</p>\n\n<ul>\n<li>A->B->C->D->E->F->G</li>\n<li>A-><strong>C</strong>-><strong>B</strong>->D->E->F->G</li>\n<li>A-><strong>C</strong>-><strong>B</strong>->D->E-><strong>G</strong>-><strong>F</strong></li>\n<li>A->B->C->D->E-><strong>G</strong>-><strong>F</strong> </li>\n<li>A->B->C->D->F-><strong>E</strong>-><strong>G</strong></li>\n<li>A-><strong>C</strong>-><strong>B</strong>->D-><strong>F</strong>-><strong>E</strong>->G</li>\n</ul>\n\n<p>When you start calculating test 1, you should stop when reaching city D. Stop and calculate what would be the shortest path, starting at A, finishing at D and going thru B,C. Latter you can assume that any path starting with A, going thru C,B and finished in D no matter how it would continue, if it will not start with the shortest path that you found, it will not be the shortest path. So now you can skip all the tests that start with A,B,C,D or A,C,B,D, depending on which of those paths is shorter.</p>\n\n<p>Now in order to save more than just $\\frac{(N-1)!}{2}$ calculation I will create a longer sub routes and calculate the shortest path between them, dropping all other options. The only problem with that, is I may repeatedly calculate the same sub routes, as I may find them in different parts of the main route. For example: for the given route: A,B,C,D,E,F,G,H lets say that I found the shortest route between B to E thru C,D. But that was just from my first test of: A,B,C,D,E,F,G,H. Later I will come in to testing: A,F,G,H,B,D,C,E as eventually I will have to test all the options. So again in order to drop part of those options I will try to find what will be the shortest path between B to E thru D,C(Remember I can can drop calculation from any part of the route) and will have to calculate it again. To avoid that I will store all the sub routes calculation in to maps.</p>\n\n<p>So lets see how long it will take me to create all the maps with K cities length. First I need to select the starting city, got N options for that, now select the last city, got $N -1$ options for that, and now select all the cities in between order is not metter and without repetition. I will use <a href="http://www.mathsisfun.com/combinatorics/combinations-permutations-calculator.html" rel="nofollow">this</a> formula for that: </p>\n\n<blockquote>\n  <p>$\\frac{N!}{ (N - R)!R!}$</p>\n</blockquote>\n\n<p>In our case $N$ is $N-2$ and $R$ is $K - 2$ so we will get:</p>\n\n<blockquote>\n  <p><strong>$\\frac{N!} {(N - K)!(K - 2)!}$</strong> The number of $K$ cities length maps from $N$ cities.</p>\n</blockquote>\n\n<p>Now lets assume that we created all the $K$ length maps and we want to create $2K - 1$ length maps. We do not need to start from 0, we can use our $K$ length maps to help us. Like this:</p>\n\n<p>Lets say we want to create the next map of 7 cities and we already created a map of 4 cities. So the cities are: A,B,C,D,E,F,H. Our first test will be: A,B,C,D,E,F,H. We can save us lots of time if we split it in two maps of 4 cities. \n - Map 1: From A to D thru B,C\n - Map 2: From D to H thru E,F</p>\n\n<p>Lets see how many maps like this could be: There are 5 options for the common city in the middle and there are $2C4$ options for the first two cities( 2 choice 4, selecting 2 cities out of 4. Order is not important, repetition is not allowed) and the last 2 cities is just what reminds. After summing it up we will have get 30 options to create 1 map of 7 cities.\nLets say it in more general way: To create all the maps for K length cities(assuming that we already created all the $\\frac{(K + 1)}{2}$ length cities maps) will be: $K - 2$ options for the common city at the middle. And $\\frac{(K - 3)} {2}C(K - 3)$ options for the cities that belongs to Map 1. Summing all together we will get:</p>\n\n<blockquote>\n  <p>$\\frac{(k - 2)!}{(\\frac{K - 3}{2}!)^2}$ The number of calculation need to be done to create $K$ cities length map when we already created $\\frac{K + 1}{2}$ cities length map.</p>\n</blockquote>\n\n<p>Now in order to find the shortest path for $N$ cities length we need to create all the maps with $\\frac{N + 1}{2}$ length and just one map with $N$ length. In cases when $N$ is not belong to $f(x) = f(x - 1)  * 2 - 1$; we will still need to create the biggest maps length group possible but we will have more than 1 city in common when we will split the problem in 2 maps. For example when N = 10. We will create all the 4 length maps, and all the 7 length maps. Lets give a sample: For the given cities A,B,C,D,E,F,G,H,I,A find the shortest path. We will split it in two maps of 7.</p>\n\n<ul>\n<li>Map 1: From A to G thru B,C,D,E,F</li>\n<li>Map 2: From D to A thru E,F,G,H,I</li>\n</ul>\n\n<p>For map 1 we will choose who is going to be the last city, we have 8 options to that.\nAnd we have $5C8$ options for the cities of the map 1, and the rest is going to map 2. You may ask yourself now how could it be that map 1 will actually have the exact common cities with map 2, isn\'t there a chance that they be ordered in some other way. Well according to my base assumption there isn\'t. so if we will sum it all together we will get: 448 options for that. Now lets say it in general way: To find the shortest path for input of $N$ cities, we will first need to find all the maps with $length &lt; N$ that belongs to $f(x) = f(x - 1)  * 2 - 1; F(0) = 4$. Lets say that the longest map of all those maps is G length and $f^{-1}(G) = G\'$( sorry for not knowing how to express $G$ with $N$). So we will have $N - 2$ options for the last city of map 1 and $(G - 2)C(N - 2)$ summing it up will give:</p>\n\n<blockquote>\n  <p>$\\frac{(N - 2)!} {(N - G)!(G - 2)!}$</p>\n</blockquote>\n\n<p>So the efficiency of finding the shortest path for N cities will be(Also added the time it will take to create the first 4 length maps) </p>\n\n<blockquote>\n  <p>$(\\frac{N(N-1)(N-2)(N-3)}{2}) + (\\sum_{i}^{G\'}\\frac{(f(i) - 2)!}{(\\frac{f(i) - 3}{2}!)^2})+ (\\frac{(N - 2)!} {(N - G)!(G - 2)!})$</p>\n  \n  <p>Using $f(x)=f(x\u22121)\u22172\u22121;F(0)=4$</p>\n</blockquote>\n\n<p>I think its better than $O(2^N)$</p>\n\n<p>Please help me to do the math, and tell me if I have any mistakes in my math or conclusions. Also please avoid writing an answers without fully understanding what I stated you are welcome to ask me more in <a href="http://chat.stackexchange.com/rooms/11065/tsp-chat">chat</a>.</p>\n', 'ClosedDate': '2014-02-02T11:24:39.057', 'Tags': '<complexity-theory><np-complete><np-hard><traveling-salesman>', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-10-18T07:59:35.663', 'CommentCount': '12', 'CreationDate': '2013-10-14T14:53:59.097', 'Id': '16076'}{'Body': '<p>In the text book, Introduction to Algorithm, 3rd Edition.</p>\n\n<p>In the chapter, <strong>Approximation Algorithms</strong> and for the problem <strong>Travelling Salesman Problem</strong>, the author says: </p>\n\n<p><img src="http://i.stack.imgur.com/99jYL.png" alt="enter image description here"></p>\n\n<p>I am wondering how triangle inequality gives rise to this assertion? It seems that this property is not that important, as I searched through the rest of this section, it does not appear.</p>\n', 'ViewCount': '143', 'Title': 'without triangle inequality, finding good approximate tours for TSP in polynomial time is impossible unless P=NP?', 'LastActivityDate': '2013-10-18T00:46:42.290', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><complexity-theory><traveling-salesman><approximation-algorithms>', 'CreationDate': '2013-10-16T17:31:49.740', 'Id': '16143'}{'Body': '<p>In the chapter, <em>Approximation Algorithms</em> of <em>Introduction to Algorithm, 3rd Edition</em>, for the approximation problem <strong>Travelling Salesman Problem</strong>, the author proposes a approximation method that first constructs a minimum spanning tree.</p>\n\n<p><img src="http://i.stack.imgur.com/G9Bvx.png" alt="enter image description here"></p>\n\n<p>In order to prove this algorithm is a 2-approximation algorithm, the author claims that:</p>\n\n<p>The weight of the minimum spanning tree $T$ is less than the cost of the optimal tour.</p>\n\n<p>I am wondering if the minimum spanning tree(which is <strong>acyclic</strong>) of $G$ ensures that its weight is <strong>necessarily</strong> smaller than any tour(which is <strong>cyclic</strong>) of the same graph $G$</p>\n\n<p>PS: </p>\n\n<p>The original claim is:</p>\n\n<p><img src="http://i.stack.imgur.com/MGgcu.png" alt="enter image description here"></p>\n', 'ViewCount': '134', 'Title': 'Approximated TSP: weight of minimum spanning tree less than cost of the optimal tour?', 'LastActivityDate': '2013-10-16T17:49:55.960', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><graph-theory><traveling-salesman><approximation-algorithms>', 'CreationDate': '2013-10-16T17:45:18.160', 'FavoriteCount': '1', 'Id': '16144'}{'Body': '<p>What is the efficiency of <a href="http://www.math.uwaterloo.ca/tsp/concorde.html" rel="nofollow">Concorde</a> TSP solver program. And is it have any weaknesses? I build my own exact solver and I want to compare it to Concorde. What would be the best way to do this?</p>\n', 'ViewCount': '155', 'Title': 'Concorde time efficiency', 'LastActivityDate': '2013-10-22T16:27:45.543', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '16339', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<traveling-salesman>', 'CreationDate': '2013-10-22T11:38:27.583', 'Id': '16331'}{'Body': "<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices, also all the vertices are connected with edges.</p>\n\n<p>I want to change the vertices values, so that the average ratio between the length of two edges (taken over all pairs of edges), will be as small as possible, I want to keep just one rule. For any vertex on the graph, it's neighbors sorted by Euclidean distance from that vertex, must remind in the same order.</p>\n\n<p>The idea behind this, if solution could be provided, that it will be possible to treat groups of vertices as one. It will reduce the difficulty of solving TSP.</p>\n", 'ViewCount': '64', 'Title': 'Trim graph to minimum', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-10-23T13:50:52.117', 'LastEditDate': '2013-10-23T13:50:52.117', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-23T12:39:35.833', 'Id': '16361'}{'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.  I found a <a href="http://tsp-vs-world.blogspot.co.il/2013/10/intersections-optimal-tsp-route.html" rel="nofollow">geometric proof</a> that every optimal TSP solution contains no intersections.</p>\n\n<p>How many non-intersecting routes could be there? Or in other words: what is the probability to guess an optimal solution to a TSP problem if we just enumerate or sample non-intersecting routes?</p>\n\n<p><strong>Edit:</strong> I want to ignore the case that D.W. mentioned. For every path that you can swap between two neighbors vertices(If we represent the path as an array of vertices so neighbors will be two vertices with consecutive indexes) without changing its non-intersecting quality, all of those paths will be considered as one.</p>\n\n<p><strong>Edit</strong> I found that this kind of removing crossings from the graph also know as <a href="http://en.wikipedia.org/wiki/2-opt" rel="nofollow">2-OPT</a> </p>\n', 'ViewCount': '236', 'Title': 'Calculating the number of non-intersecting routes in an Euclidean graph', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-11-03T12:37:57.193', 'LastEditDate': '2013-11-03T12:37:57.193', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-26T09:50:01.253', 'FavoriteCount': '1', 'Id': '16439'}{'Body': "<p>I am well aware of the DP solution to the traveling salesman problem; also known as the Held and Karp algorithm for TSP.</p>\n\n<p>I have implemented it with bitmask, and it's something like this:</p>\n\n<pre><code>int TSP(int pos, int bitmask) {\n    if (bitmask == (1&lt;&lt;(K+1))-1)\n        return dist[pos][0];              // Completing the round trip\n\n    if (memo[pos][bitmask] != -1)\n        return memo[pos][bitmask];\n\n    int answer = INF;\n    for (int i = 0; i &lt;= K; i++) {\n        if (i != pos &amp;&amp; (bitmask &amp; (1 &lt;&lt; i)) == 0)\n               answer = Math.min(answer, dist[pos][i] + TSP(i, bitmask | (1 &lt;&lt; i)));\n    }\n\n    return memo[pos][bitmask] = answer;     // Storing the best dist for the set of traveled cities and untraveled ones.\n</code></pre>\n\n<p>This algorithm is quite fast; computation of 15 cities is relatively fast enough. However, I notice that it could be further improved to accommodate around 20 cities.</p>\n\n<p>1) If the dist matrix is symmetrical, perhaps we can make use of this property to prevent repeated calculations. (e.g a->b->c->d->a == a->d->c->b->a)</p>\n\n<p>2) Using both a upper and lower bound to prune. The above algorithm is able to get its first possible optimal solution in a very short time, might be able to use that.</p>\n\n<p>I have tried to improve the algorithm based on the aforementioned two principles. However, I don't get a better algorithm.</p>\n\n<p>Am I making a futile attempt at improving something impossible? What do you think?</p>\n", 'ViewCount': '89', 'Title': 'Traveling Salesman with Held and Karp Algorithm', 'LastActivityDate': '2013-10-27T15:00:58.337', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10999', 'Tags': '<graph-theory><np-complete><dynamic-programming><traveling-salesman>', 'CreationDate': '2013-10-27T15:00:58.337', 'Id': '16474'}{'Body': "<p>I have a nice idea to optimize TSP by removing nodes, its going to be hard for me to explain my self, so please be patient with me and try to understand what I am saying.</p>\n\n<p>I have a symmetric(the weight of $AB$ is equal to $BA$), undirected graph where all the weights are 1 or 2.</p>\n\n<p>I am trying to find TSP optimal tour for this graph. Also I know that the optimal tour is only contains edges with the weight of 1.</p>\n\n<p>I been looking in to my data and I found that there is a node that only have two edges of 1 connected to it - lets call this node $B$ and those edges that connected to him $AB$ and $BC$. I know that $AB,BC$ must be part of the optimal tour because in any other way we will have an edge with the weight of 2, and by definition this can't be . So I am removing the node $B$ and adding extra edge $AC$ between the endpoints of the removed node, and I am giving him the weight of 1. Now when I will solve the TSP I can replace it by the two edges that I removed.</p>\n\n<p>Now I want to try something bigger and I am not sure that it will work, so this is what the question is about. Lets assume that we have not 2 but 3 edges connected to one node with the weight of 1, can we remove this node and add extra two edges using the same idea as before?</p>\n", 'ViewCount': '86', 'Title': 'Symmetric TSP optimization by removing nodes', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-11-04T12:30:04.023', 'LastEditDate': '2013-11-04T10:43:43.307', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graph-theory><traveling-salesman>', 'CreationDate': '2013-11-04T08:32:03.913', 'Id': '16696'}{'ViewCount': '114', 'Title': 'Why does TSP require no repetition of cities?', 'LastEditDate': '2013-11-09T20:35:56.287', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8913', 'FavoriteCount': '1', 'Body': '<p>It seems odd to me that the TSP denies the possibility of repeated cities.  The goal of this traveling salesman is to go as fast as possible and visit all of the cities, right?  So what if it is faster to travel through a city you have already been to?</p>\n', 'Tags': '<terminology><traveling-salesman>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T21:38:56.643', 'CommentCount': '2', 'AcceptedAnswerId': '17856', 'CreationDate': '2013-11-09T19:37:55.033', 'Id': '17854'}{'Body': '<p>I need to implement TSP algorithm by brute force for learning purposes.</p>\n\n<p>I\'ve understood there\'s a set of cities, let\'s call it <strong><em><code>V</code></em></strong> and it\'s possible to get a matrix representation for the costs for going from a <strong><em><code>v1</code></em></strong> city to a <strong><em><code>v2</code></em></strong> city. I\'ll assume there are not cycles, so  it\'s no possible to going from <strong><em><code>v1</code></em></strong> back to <strong><em><code>v1</code></em></strong></p>\n\n<p>Then, I should generate a matrix after these sum series:</p>\n\n<p><img src="http://i.stack.imgur.com/lXusa.png" alt="Formulas"></p>\n\n<p><strong>However, I really can\'t see in a practice way how a matrix would be outputed from restrictions.</strong></p>\n\n<p>Let\'s say we got 3 cities:</p>\n\n<blockquote>\n  <p>Madrid, Berlin and Malmo</p>\n</blockquote>\n\n<p>So the path costs are (and they\'re not forced to be the same for ways back):</p>\n\n<p><strong>From Madrid to:</strong></p>\n\n<p>Berlin: 12<br>\nMalmo:  20</p>\n\n<p><strong>From Berlin to</strong></p>\n\n<p>Madrid: 32<br>\nMalmo:  12</p>\n\n<p><strong>From Malmo to:</strong></p>\n\n<p>Madrid: 14<br>\nBerlin: 17</p>\n\n<p>So my input is:    </p>\n\n<p>$$\\begin{bmatrix} 0 &amp; 12 &amp; 20 \\\\ 32 &amp; 0 &amp; 12 \\\\ 14 &amp; 17 &amp; 0\\end{bmatrix}$$    </p>\n\n<p>How should the matrix be outputed according to the sum series?</p>\n\n<blockquote>\n  <p><em><strong>I assume the algorithm would need to generate a matrix from this exampple:</em></strong></p>\n</blockquote>\n\n<p>There are 3 cities <strong><em><code>x1</code></em></strong>, <strong><em><code>x2</code></em></strong> and <strong><em><code>x3</code></em></strong> and got the costs matrix shown below:</p>\n\n<p>$$\\begin{bmatrix} 10 &amp; 2 &amp; 1 \\\\ 3 &amp; 10 &amp; 2 \\\\ 11 &amp; 2 &amp; 10\\end{bmatrix}$$ </p>\n\n<p>Following, example shows the next matrix:</p>\n\n<p>$$\\begin{bmatrix} x_{11}+x_{12}+x_{13} &amp;  &amp;  \\\\  &amp; x_{21}+x_{22}+x_{23} &amp;  \\\\  &amp;  &amp; x_{31}+x_{32}+x_{33}\\\\x_{11} &amp; x_{21} &amp; x_{31} \\\\ x_{12} &amp; x_{22} &amp; x_{32} \\\\  x_{13}&amp; x_{23} &amp; x_{33} \\end{bmatrix}$$ </p>\n\n<p>Which would be the same as:</p>\n\n<p>$$\\begin{bmatrix} 1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;1\\\\ 1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\\\ 0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1\\\\ 0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0\\\\ \\end{bmatrix}$$ </p>\n\n<p>Then, considering the power ser of the three cities, matrix got the following rows added:</p>\n\n<p>$$\\begin{bmatrix} 0&amp;1&amp;1 &amp; 0&amp;0&amp;0 &amp; 0&amp;0&amp;0 \\\\ 0&amp;0&amp;0 &amp; 1&amp;0&amp;1 &amp; 0&amp;0&amp;0 \\\\ 0&amp;0&amp;0 &amp; 0&amp;0&amp;0 &amp; 1&amp;1&amp;0 \\\\ 0&amp;0&amp;1 &amp; 0&amp;0&amp;1 &amp; 0&amp;0&amp;0 \\\\ 0&amp;1&amp;0 &amp; 0&amp;0&amp;0 &amp; 0&amp;1&amp;0 \\\\ 0&amp;0&amp;0 &amp; 1&amp;0&amp;0 &amp; 1&amp;0&amp;0  \\end{bmatrix}$$ </p>\n\n<p>Finally, the whole generated matrix is:</p>\n\n<p>$$\\begin{bmatrix} 1&amp;1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;1&amp;1&amp;1&amp;0&amp;0&amp;0\\\\ 0&amp;0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;1\\\\ 1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;0&amp;1&amp;0\\\\ 0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1\\\\ 0&amp;1&amp;0&amp;0&amp;1&amp;0&amp;0&amp;1&amp;0\\\\ 0&amp;1&amp;1 &amp; 0&amp;0&amp;0 &amp; 0&amp;0&amp;0 \\\\ 0&amp;0&amp;0 &amp; 1&amp;0&amp;1 &amp; 0&amp;0&amp;0 \\\\ 0&amp;0&amp;0 &amp; 0&amp;0&amp;0 &amp; 1&amp;1&amp;0 \\\\ 0&amp;0&amp;1 &amp; 0&amp;0&amp;1 &amp; 0&amp;0&amp;0 \\\\ 0&amp;1&amp;0 &amp; 0&amp;0&amp;0 &amp; 0&amp;1&amp;0 \\\\ 0&amp;0&amp;0 &amp; 1&amp;0&amp;0 &amp; 1&amp;0&amp;0 \\end{bmatrix}$$ </p>\n', 'ViewCount': '119', 'Title': 'Proper TSP implementation by brute force', 'LastEditorUserId': '5066', 'LastActivityDate': '2013-11-19T19:58:20.210', 'LastEditDate': '2013-11-19T19:58:20.210', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5066', 'Tags': '<algorithms><traveling-salesman>', 'CreationDate': '2013-11-17T20:39:11.493', 'Id': '18104'}{'Body': "<p>I'm given this problem:</p>\n\n<p>Consider the following closest-point heuristic for building an approximate traveling-salesman  tour. Begin with a trivial cycle consisting of a single arbitrarily chosen vertex. At each step, identify the vertex u that is not on the cycle but whose distance to any vertex on the cycle is minimum. Suppose that the vertex on the cycle that is nearest u is vertex v. Extend the cycle to include u by inserting u just after v. Repeat until all vertices are on the cycle. Prove that this heuristic returns a tour whose total cost is not more than twice the cost of an optimal tour. </p>\n\n<p>This is the same as Prim's algorithm.  Unless I'm missing something, this is not an approximate traveling salesman tour since the traveling salesman requires a Hamiltonian path where we don't revisit any nodes, but on many graphs this algorithm seems to require revisiting nodes to get back to the source node.  Am I wrong or is this problem unclearly worded?</p>\n", 'ViewCount': '120', 'Title': "Traveling Salesman's Tour Approx Algorithm: is this really a Hamiltonian Path?", 'LastActivityDate': '2013-11-19T10:58:35.200', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18152', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11474', 'Tags': '<traveling-salesman><spanning-trees><approximation-algorithms>', 'CreationDate': '2013-11-19T06:43:05.060', 'Id': '18147'}{'ViewCount': '128', 'Title': 'Can Euclidean TSP be exactly solved in time better than (sym)metric TSP?', 'LastEditDate': '2013-11-20T22:51:30.667', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '1', 'Body': u'<p>Symmetric/Metric TSP can be solved via the Held-Karp algorithm in $\\mathcal O(n^2 2^n)$.</p>\n\n<p>See <a href="http://epubs.siam.org/doi/abs/10.1137/0110015">A dynamic programming approach to sequencing problems</a> by Michael Held and Richard M. Karp, 1962.</p>\n\n<p>In <a href="http://faculty.cs.tamu.edu/chen/courses/689/2006/reading/w1.pdf">Exact Algorithms for NP-Hard Problems: A Survey (PDF)</a> Woeginger writes:</p>\n\n<blockquote>\n  <p>This result was published in 1962, and from nowadays point of view almost looks trivial. Still, it yields the best time complexity that is known today.</p>\n</blockquote>\n\n<p>Thus, this is the best known upper-bound.</p>\n\n<p><b>Question:</b></p>\n\n<blockquote>\n  <p>Are there any better results for Euclidean TSP? Or does that best-known bound apply to Euclidean TSP as well.</p>\n</blockquote>\n\n<p>How is Euclidean TSP different? Well,</p>\n\n<ul>\n<li>Euclidean TSP can be encoded into $\\mathcal O(n \\log m)$ space, where $n$ is the number of cities, and $m$ is the bound on the integer coordinates of the city locations. As opposed to (sym)metric TSP variants, which essentially require a distance matrix of size $\\mathcal O(n^2 \\log m)$. Thus, it might be easier to solve; for example, perhaps Euclidean TSP can be more easily encoded into k-SAT, because the distance function is implicit.</li>\n<li><p>Contrary to popular notion, Euclidean TSP\'s reduction from k-SAT is quite different from (sym)metric TSP. UHC (undirected Hamiltonian cycle), symmetric TSP, and metric TSP are pretty directly related to each-other. But formulations of reductions from (sym)metric TSP to Euclidean TSP are not easy to come by. Paragraph, from interesting article, <a href="http://rjlipton.wordpress.com/2012/04/22/the-travelling-salesmans-power/">The Travelling Salesman\u2019s Power</a> by K. W. Regan (bold mine):</p>\n\n<blockquote>\n  <p>Now the reductions from 3SAT to TSP, especially Euclidean TSP, are less familiar, and we ascribe this to their being far more \u201cexpansive.\u201d <b>Texts usually reduce 3SAT to Hamiltonian Cycle, then present the latter as a special case of TSP, but this does not apply to Euclidean TSP</b>. The ${\\mathsf{NP}}$-completeness of Euclidean TSP took a few years until being shown by Christos Papadimitriou, and a 1981 <a href="http://www.cs.technion.ac.il/~itai/publications/Algorithms/Hamilton-paths.pdf">paper</a> by him with Alon Itai and Jayme Luiz Szwarcfiter advertised a \u201cnew, relatively simple, proof.\u201d This proof uses vertex-induced subgraphs of the grid graph in the plane, for which the shortest possible TSP tour and any Hamiltonian cycle have the same length. Despite this simplification, the gadgets involved are large\u2014a diagram of one occupies most of one journal page.</p>\n</blockquote>\n\n<p>Hunting down k-SAT $\\rightarrow$ Euclidean TSP reductions is quite an adventure; so far I\'ve found two of them. One $\\rm k\\text{-}SAT \\rightarrow CircuitSAT \\rightarrow PlanarCircuitSAT \\rightarrow EuclideanTSP$, and another, even tougher one to find, $\\rm k\\text{-}SAT \\rightarrow DHC \\rightarrow UHC \\rightarrow PlanarUHC \\rightarrow EuclideanTSP$. The latter reduction can perhaps be seen to make Euclidean TSP parallel (sym)metric TSP.</p></li>\n</ul>\n', 'Tags': '<graph-theory><reference-request><time-complexity><np-hard><traveling-salesman>', 'LastEditorUserId': '2755', 'LastActivityDate': '2014-02-05T14:16:06.677', 'CommentCount': '0', 'AcceptedAnswerId': '18218', 'CreationDate': '2013-11-20T22:46:01.723', 'Id': '18209'}{'Body': '<p>What type of algorithm would you suggest me to use for this problem? I want to implement an algorithm that minimize the total distance in a graph (TSP) but for only X nodes. Also, we can go as many times we want on every vertices and/or edges. Let\'s say, on my graph, that I want the minimum distance for visiting every blue node. What algorithm and heuristic would you recommand me? An approximation running in reasonable time would be acceptable.</p>\n\n<p>For this example, this is an undirected graph, the vertices are points in the plane and the cost of an edge is the distance between its endpoints.</p>\n\n<p><img src="http://i.imgur.com/YheHQPT.jpg" alt="graph"></p>\n', 'ViewCount': '74', 'Title': 'Algorithm to use for a TSP variant', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-12-04T00:26:11.793', 'LastEditDate': '2013-12-04T00:26:11.793', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18593', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11797', 'Tags': '<algorithms><graphs><heuristics><traveling-salesman>', 'CreationDate': '2013-12-03T23:17:30.113', 'Id': '18589'}{'ViewCount': '508', 'Title': 'How does the 3-opt algorithm for TSP work?', 'LastEditDate': '2014-01-19T16:11:51.803', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12945', 'FavoriteCount': '1', 'Body': u'<p>I understand that the 3-Opt Heuristic for solving the Traveling Salesman problem involves removing three edges from a graph and adding three more to recomplete the tour. However, I\'ve seen many papers that mention that when three edges are removed, there remain only 2 possible ways to recombine the tour - this doesn\'t make sense to me.</p>\n\n<p>For example, I found a paper [1] that says:</p>\n\n<blockquote>\n  <p>The 3-opt algorithm works in a similar fashion, but instead of removing two edges we remove three. This means that we have two ways of reconnecting the three paths into a valid tour1 (\ufb01gure 2 and \ufb01gure 3). A 3-opt move can actually be seen as two or three 2-opt moves.</p>\n</blockquote>\n\n<p>However, I count 8 different ways to reconnect the tour (7 if not counting the permutation before removing the edges). What am I missing here? <strong>Edit: 3 different ways, not 8</strong></p>\n\n<p>Also, can someone link me to an algorithm for 3-opt if possible? I\'m just trying to understand it but I haven\'t come across any clear algorithms yet; all resources I find simply say "remove three edges, reconnect them". That\'s it, which is sort of vague.</p>\n\n<p>Here are the 3 tours that seem to me to be 3-opt moves after removing three edges.</p>\n\n<p><img src="http://i.stack.imgur.com/KynPB.png" alt="enter image description here"></p>\n\n<hr>\n\n<ol>\n<li><a href="http://web.tuke.sk/fei-cit/butka/hop/htsp.pdf" rel="nofollow">Heuristics for the Traveling Salesman Problem</a> by C. Nilsson</li>\n</ol>\n', 'Tags': '<algorithms><optimization><heuristics><traveling-salesman>', 'LastEditorUserId': '12945', 'LastActivityDate': '2014-03-03T18:36:23.367', 'CommentCount': '6', 'AcceptedAnswerId': '19810', 'CreationDate': '2014-01-18T16:42:44.363', 'Id': '19808'}{'Body': u"<p>The optimization version of TSP asks for the length of the shortest tour. Unlike the decision version of TSP, there's no obvious way to verify a proposed solution of the optimization problem in polynomial time. But is there a proof of whether or not it can be verified in polynomial time assuming P \u2260 NP?</p>\n", 'ViewCount': '56', 'Title': u'Has it been proven that the optimization TSP is (or is not) polynomial-time verifiable if P \u2260 NP?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:42:30.540', 'LastEditDate': '2014-02-02T13:42:30.540', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '20209', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '836', 'Tags': '<complexity-theory><optimization><np><traveling-salesman>', 'CreationDate': '2014-02-02T05:46:32.140', 'Id': '20204'}{'Body': '<p>Is it possible to calculate, efficiently, the minimum tour distance for TSP? That is, the distance without having to provide the actual tour.</p>\n\n<p>If this is not possible (I assume it is not), how tight a lower bound can we efficiently calculate?</p>\n', 'ViewCount': '41', 'Title': 'Efficiently calculating the minimum distance for TSP', 'LastActivityDate': '2014-02-26T23:56:06.770', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15083', 'Tags': '<traveling-salesman>', 'CreationDate': '2014-02-26T22:45:34.827', 'Id': '22067'}{'Body': '<p>I am wondering what is the difference between Bottleneck Travelling Salesman Problem and normal Travelling Salesman Problem?</p>\n\n<p>Thank you</p>\n', 'ViewCount': '43', 'ClosedDate': '2014-03-11T06:27:58.377', 'Title': 'Difference between BTSP and TSP', 'LastActivityDate': '2014-03-09T15:09:06.390', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22431', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15429', 'Tags': '<algorithms><traveling-salesman>', 'CreationDate': '2014-03-08T20:06:43.840', 'Id': '22409'}{'ViewCount': '72', 'Title': 'Approximation algorithms for Euclidean Traveling Salesman', 'LastEditDate': '2014-04-13T09:51:49.107', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15429', 'FavoriteCount': '1', 'Body': "<p>I am trying to find a way to solve Euclidean TSP in a polynomial time. I looked at some papers but I couldn't decide which one is better. What is the general approximation algorithm for solving this problem in polynomial time?</p>\n", 'ClosedDate': '2014-04-13T09:54:22.080', 'Tags': '<algorithms><reference-request><approximation><traveling-salesman>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-13T09:51:49.107', 'CommentCount': '5', 'CreationDate': '2014-03-09T18:25:51.543', 'Id': '22438'}{'Body': '<p>Let me preface this question by giving some helpful <a href="http://lcm.csa.iisc.ernet.in/dsa/node187.html" rel="nofollow">background material</a>. </p>\n\n<p>I\'m trying to solve the traveling salesman problem using branch and bound. Concretely, for a partial solution, I\'m using the solution the algorithm would attain by making greedy choices as an upper bound, and comparing this bound to the current best solution. If the bound attained using this heuristic is better than the cost of the best known solution, we continue exploring the partial solution. Otherwise, we prune and discard. Note that the greedy solution attained is always valid.</p>\n\n<p>The above link mentions a method for finding a global lower bound. This is fairly intuitive: for each node, we add to the bound the sum of the two minimum cost edges to other nodes (representing the cheapest in/out edges, if you will) and divide by two to avoid double counting. The solution implied by this global bound is almost never a valid solution but instead gives a hard limit on the lowest cost we could ever hope to attain. </p>\n\n<p>Here\'s how I\'m currently trying to calculate a local lower bound (a lower bound for a partial solution) with cost $C(S)$.</p>\n\n<ul>\n<li>Set <code>bound</code> to the current accumulated cost, $C(S)$</li>\n<li>For each unvisited node, add to <code>bound</code> the sum of the two least cost edges, making sure that the edges selected don\'t lead to a node already visited</li>\n<li>return <code>bound/2</code></li>\n</ul>\n\n<p>Here\'s my question: How is the above solution different from the greedy bound? Maybe a better lower bound would be to add to <code>bound</code> the sum of the two least cost edges, paying <strong>no attention to whether these edges lead to nodes already visited</strong>. Also, how do I actually use this bound to prune the search space? Do I compare the local lower bound computed for a partial solution with the global lower bound, pruning if $L(S) &lt; GL$ or if $L(S) &gt; C(B)$, or if $L(S) &gt; L(B)$? (here $GL$ corresponds to the global lower bound; $L(S)$ computes the local lower bound on a partial solution; $C(B)$ represents the trip cost on the best known solution; $L(B)$ is the lower bound on the best solution). Also, how will $L(S)$ ever be less than the global lower bound (i.e. an infeasible solution) if we only ever use (valid) edges to cities we haven\'t yet visited? </p>\n\n<p>Comments and suggestions on using this lower bound as well as its efficacy would be very much appreciated. Thank you. </p>\n', 'ViewCount': '70', 'Title': 'Traveling Salesman: how to use a lower bound?', 'LastEditorUserId': '16389', 'LastActivityDate': '2014-04-08T08:07:23.937', 'LastEditDate': '2014-04-08T03:01:07.293', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16389', 'Tags': '<complexity-theory><optimization><lower-bounds><traveling-salesman><branch-and-bound>', 'CreationDate': '2014-04-07T17:34:38.440', 'Id': '23520'}{'Body': '<p>I always thought that TSP currently requires time exponential in the number of cities to solve.</p>\n\n<blockquote>\n  <p>How, then, has <a href="http://www.math.uwaterloo.ca/tsp/concorde.html" rel="nofollow">Concorde</a> optimally solved a TSP instance with\n  <strong>85,900 cities</strong>?!?</p>\n</blockquote>\n\n<p>Is this a typo? Is the base of the exponential 1.0000000000000001 or similar? Was it an instance specifically constructed to be solvable easily? What <em>is</em> the asymptotic runtime of the best known TSP solving algorithm?</p>\n', 'ViewCount': '93', 'Title': 'What is the asymptotic runtime of the best known TSP solving algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-13T10:00:05.303', 'LastEditDate': '2014-04-13T10:00:05.303', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23732', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16732', 'Tags': '<algorithms><np-hard><traveling-salesman>', 'CreationDate': '2014-04-13T07:43:43.813', 'Id': '23731'}{'Body': '<p>Suppose there is a travelling salesman who wants to travel through N cities in k countries(k &lt;= N). For convenience, he will travel all the cities within a certain country and then move to another. In each country, he wants to find out the shortest simple path to traverse through all the cities.[Classic TSP problem] </p>\n\n<p>Q1. Suppose moving to another country costs nothing. Is that still a NP-complete problem? Any suggestion for a proof?</p>\n\n<p>Q2. (There could be connections with certain costs between two cities in two different countries.) Suppose the salesman has to visit the countries (but not cities) in a certain order. Is that still a NP-complete problem? Any suggestion for a proof?</p>\n\n<hr>\n\n<p>(Precisely, I should have used "NP-hard problem". I hope you can translate it into the decision version.)</p>\n\n<p>Q1:\nIt is intuitive that a general TSP instance can be reduced to this problem for k = 1. What I know about is that you can reduce a general instance of a known NP-c problem into a "special" instance of the problem that you wish to reduce to. However, I think "k=1 (with N)" is a very special case that it is much harder than instances when k > 1. That\'s why I am not quite certain if this intuitive approach is correct.</p>\n\n<p>"This is a dump of an exercise problem, not a question." I feel sorry for my algorithm teacher. I made this exercise up for a similar situation in my research (not in the area of algorithm for sure). If I let k = 1, the instance got reduced to seems to be the hardest instance which I doubt if it is general. Since the sub-problems are NP-c (in decision version), let the cost for jth country with m cities be $T_j(m)$, then $\\Sigma_k T_j(m)$ is much smaller than $T(N)$. Also, the problem is not that hard when k = N. (k is part of the input?)</p>\n\n<p>"Is it NP-complete if its sub-problems are NP-complete?" (So I made up the problem.) If so, that intuitive approach seems correct.</p>\n\n<p>Q2:\nI think it is kind of related to Q1. I didn\'t post it because I tend to solve it on my own.(Hints are welcome.) If you solve it, I may have to consider putting you as a coauthor later :).</p>\n\n<hr>\n\n<p>Thanks</p>\n', 'ViewCount': '52', 'ClosedDate': '2014-04-18T14:53:45.803', 'Title': 'A variant of Travelling Salesman: Is it NP-complete if its sub-problems are NP-complete?', 'LastEditorUserId': '16864', 'LastActivityDate': '2014-04-18T20:32:55.147', 'LastEditDate': '2014-04-18T20:32:55.147', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16864', 'Tags': '<np-complete><traveling-salesman>', 'CreationDate': '2014-04-17T21:29:13.760', 'Id': '23896'}