{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '243', 'Title': 'Polymorphism and Inductive datatypes', 'LastEditDate': '2012-03-30T02:36:02.300', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '68', 'FavoriteCount': '1', 'Body': u'<p>I\'m curious. I\'ve been working on this datatype in <em>OCaml</em>:</p>\n\n<pre><code>type \'a exptree =\n  | Epsilon\n  | Delta of \'a exptree * \'a exptree\n  | Omicron of \'a\n  | Iota of \'a exptree exptree\n</code></pre>\n\n<p>Which can be manipulated using explicitly typed recursive functions (a feature that has been added quite recently). Example:</p>\n\n<pre><code>let rec map : \'a \'b. (\'a -&gt; \'b) -&gt; \'a exptree -&gt; \'b exptree =\n  fun f -&gt;\n    begin function\n    | Epsilon -&gt; Epsilon\n    | Delta (t1, t2) -&gt; Delta (map f t1, map f t2)\n    | Omicron t -&gt; Omicron (f t)\n    | Iota tt -&gt; Iota (map (map f) tt)\n    end\n</code></pre>\n\n<p>But I\'ve never been able to define it in <em>Coq</em>:</p>\n\n<pre><code>Inductive exptree a :=\n  | epsilon : exptree a\n  | delta : exptree a -&gt; exptree a -&gt; exptree a\n  | omicron : a -&gt; exptree a\n  | iota : exptree (exptree a) -&gt; exptree a\n.\n</code></pre>\n\n<p><em>Coq</em> is whining. It doesn\'t like the last constructor, and says something I don\'t completely understand or agree with:</p>\n\n<pre><code>Error: Non strictly positive occurrence of "exptree" in "exptree (exptree a) -&gt; exptree a".\n</code></pre>\n\n<p>What I can understand is that inductive types using a negation inside their definition like <code>type \'a term = Constructor (\'a term -&gt; \u2026)</code> are rejected, because they would lead to ugly non well-founded beasts like (untyped) \u03bb-terms.\nHowever this particular <code>exptree</code> datatype seems genuine enough: looking at its <em>OCaml</em> definition, it\'s argument <code>\'a</code> is never used in negative positions.</p>\n\n<p>It seems that <em>Coq</em> is overcautious here.\nSo is there really a problem with this particular inductive datatype?\nOr could <em>Coq</em> be slightly more permissive here?</p>\n\n<p>Also, what about other proof assistants, are they able to cope with such an inductive definition (in a natural way)?</p>\n', 'Tags': '<logic><programming-languages><coq><inductive-datatypes>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-30T02:36:02.300', 'CommentCount': '0', 'AcceptedAnswerId': '885', 'CreationDate': '2012-03-28T11:47:06.847', 'Id': '851'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am working on an expression based language of ML genealogy, so it naturally needs type inference >:)</p>\n\n<p>Now, I am trying to extend a constraint-based solution to the problem of inferring types, based on a simple implementation in EOPL (Friedman and Wand), but they elegantly side-step algebraic datatypes.</p>\n\n<p>What I have so far works smoothly; if an expression <code>e</code> is <code>a + b</code>, <code>e : Int</code>, <code>a : Int</code> and <code>b : Int</code>. If <code>e</code> is a match,</p>\n\n<pre><code>match n with\n  | 0 -&gt; 1\n  | n' -&gt; n' * fac(n - 1)`, \n</code></pre>\n\n<p>I can rightly infer that the <code>t(e) = t(the whole match expression)</code>, <code>t(n) = t(0) = t(n')</code>, <code>t(match) = t(1) = t(n' * fac(n - 1)</code> and so on...</p>\n\n<p>But I am very unsure when it comes to algebraic datatypes. Suppose a function like filter:</p>\n\n<pre><code>let filter pred list =\n  match list with\n    | Empty -&gt; Empty\n    | Cons(e, ls') when pred e -&gt; Cons (e, filter ls')\n    | Cons(_, ls') -&gt; filter \n</code></pre>\n\n<p>For the list type to remain polymorphic, Cons needs to be of type <code>a * a list -&gt; a list</code>. So, in establishing these constraints, I obviously need to look up these types of my algebraic constructors - the problem I now have is the 'context-sensitivity' of multiple uses of algebraic constructors - how do I express in my constraint equations that the <code>a</code> in each case needs to be the same?</p>\n\n<p>I am having trouble finding a general solution to this, and I am unable to find much literature on this. Whenever I find something similar - expression based language with constraint-based type inference - they stop just short of algebraic datatypes and polymorphism.</p>\n\n<p>Any input is much appreciated!</p>\n", 'ViewCount': '214', 'Title': 'Constraint-based Type Inference with Algebraic Data', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-20T10:07:16.937', 'LastEditDate': '2012-04-06T23:30:01.300', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '979', 'Tags': '<programming-languages><type-theory><functional-programming><inductive-datatypes><typing>', 'CreationDate': '2012-04-06T23:09:22.253', 'Id': '1092'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Assume that we have a set $D$ and each member of $D$ is a data and key pair. We want a data structure that would support the following operations:</p>\n\n<ul>\n<li>Insert $(d,k)$ into $D$,</li>\n<li>Delete member $e$, (no need to search to find $e$, e.g. $e$ points to a member in $D$),</li>\n<li>MostFrequent, which returns a member $e \\in D$ such that $e.key$ is one of the most frequent keys in $D$ (note that the most frequent key doesn't need to be unique).</li>\n</ul>\n\n<p>What would be an efficient implementation of this data structure?</p>\n\n<p>My solution is a heap for the keys and their frequencies prioritized by the frequencies plus a hash table where the hash function maps members with the same key to the same slot in the hash table (with pointers from each part to the other). </p>\n\n<p>This can give $\\Theta(\\lg n)$ for the first two operations and $\\Theta(1)$ for the third (worst case running time). </p>\n\n<p>I am wondering if there is more efficient solution? (or a simpler solution with the same efficiency?)</p>\n", 'ViewCount': '870', 'Title': 'An efficient data structure supporting Insert, Delete, and MostFrequent', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-23T16:20:22.333', 'LastEditDate': '2012-11-02T21:39:10.150', 'AnswerCount': '3', 'CommentCount': '10', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<algorithms><data-structures><abstract-data-types>', 'CreationDate': '2012-11-02T17:00:40.447', 'FavoriteCount': '5', 'Id': '6455'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1073', 'Title': 'Implement queue with a linked list; why would it be bad to insert at the head and remove at the tail?', 'LastEditDate': '2013-03-10T19:51:55.500', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '1', 'Body': '<p>In my textbook, Data Structures and Algorithms in Java, the author says when implementing a queue using a linked list you choose the front of the queue to be at the head of the list, and the rear of the queue to be at the tail of the list. In this way, you remove from the head and insert at the tail.</p>\n\n<p>The author then asks cryptically, "Why would it be bad to insert at the head and remove at the tail?" without providing an answer.</p>\n\n<p>I can\'t see what the difference really is. In effect, "Head" and "Tail" are just arbitrary names we define. What would be so bad if to enqueue() we add a head and create a reference to the old head, and to dequeue() we take from the tail and move the tail over?</p>\n\n<p>What is the answer to the author\'s question?</p>\n', 'Tags': '<time-complexity><linked-lists><abstract-data-types>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-10T19:51:55.500', 'CommentCount': '0', 'AcceptedAnswerId': '10435', 'CreationDate': '2013-03-10T19:10:25.620', 'Id': '10434'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I think of type as a range of values that the variable can take whereas the rest is known constant or does not matter. Variables (instances or objects), which share common properties, are considered to belong to the same type/kind/class. That is, the type properties are constant across the type. The type is actually a common property of a class of objects (variables). The variables have a variable part, which may change, making them flipping from one subtype to the other. However, the same applies to subtypes: subtypes also share a common constant property.</p>\n\n<p>I may describe a class by a circle in Vienn Diagramm. Its subspheres would be types or variables. I think that the variable means that it has some fixed part, its type, and variable part, which make it variable and not constant. The constants or values would be an elementary point in the diagramm. </p>\n\n<p>For instance, integer is a subtype of real. Integer variable means that it can take concrete values within the range of the integer area. Similarly, boolean variables, taking only values 0 and 1, are subtype of integer. But, what is a constant 1? Is it a real or integer or boolean variable or it is a specific type, instances of which have a common property: they have a value of 1? Is it a known treatment?</p>\n\n<p>My interest stems from the practice: how can I save memory fixing the common part of variables in a language processing framework?</p>\n', 'ViewCount': '86', 'Title': 'Is constant a variable or subtype?', 'LastActivityDate': '2013-05-31T10:52:28.827', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<type-theory><type-inference><inductive-datatypes>', 'CreationDate': '2013-05-30T10:01:44.873', 'Id': '12372'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '360', 'Title': 'What makes type inference for dependent types undecidable?', 'LastEditDate': '2013-10-09T18:44:37.213', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '8685', 'FavoriteCount': '1', 'Body': '<p>I have seen it mentioned that dependent type systems are not inferable, but are checkable. I was wondering if there is a simple explanation of why that is so, and whether or not there is there a limit of "dependency" where types can be indexed by values, below which type inference is possible and above which it is not?</p>\n', 'Tags': '<undecidability><type-theory><type-inference><dependent-types>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:37.213', 'CommentCount': '2', 'AcceptedAnswerId': '12957', 'CreationDate': '2013-06-15T15:35:18.983', 'Id': '12691'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>When should I call a definition recursive and when should I call it inductive?</p>\n\n<p>I have read Carl Mummert\'s <a href="http://math.stackexchange.com/a/228870/468">nice answer</a> on MSE. So if I understand correctly we refer to definitions of objects like natural numbers, lists, trees, etc. as inductive whereas we refer to definitions of operations over objects like $+$ or $head$ or $leftchild$ as recursive.</p>\n\n<p>Is this the correct way to distinguish these in programming languages theory?</p>\n\n<p>Are there examples where using either would make sense?</p>\n', 'ViewCount': '187', 'Title': 'Inductive vs. recursive definition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-17T13:01:02.477', 'LastEditDate': '2013-07-12T10:59:05.280', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<terminology><programming-languages><logic><recursion><inductive-datatypes>', 'CreationDate': '2013-07-11T09:02:21.290', 'FavoriteCount': '1', 'Id': '13225'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am reading about dependent types theory in the <a href="http://homotopytypetheory.org/book/" rel="nofollow">Homotopy Type Theory</a> online book. </p>\n\n<p>In section 1.3 of the <em>Type Theory</em> chapter, it introduces the notion of hierarchy of <em>Universes</em>: $\\mathcal{U}_0 : \\mathcal{U}_1 : \\mathcal{U}_2 : \\cdots$, where</p>\n\n<blockquote>\n  <p>every universe $\\mathcal{U}_i$ is an element of the next universe $\\mathcal{U}_{i+1}$. Moreover, we assume that our universes are cumulative, that is that all the elements of the $i^{\\mathrm{th}}$ universe are also elements of\n  the $(i+1)^{\\mathrm{th}}$ universe.</p>\n</blockquote>\n\n<p>Yet, when I look at the formation rules for the various types in appendix A, at first glance, if a universe appears above the bar as a premise, the same universe appears below. For instance for the coproduct types formation rule:</p>\n\n<p>$$\\dfrac{\\Gamma \\vdash A : \\mathcal{U}_i \\quad \\Gamma \\vdash B : \\mathcal{U}i}{\\Gamma \\vdash A + B : \\mathcal{U}_i}(+\\mbox{-}FORM)$$</p>\n\n<p>So my question is why is a hierarchy necessary? <strong>Under what circumstances do you need to jump from a universe to one higher in the hierarchy?</strong> It is really not obvious to me how given any combination of $A_m: \\mathcal{U}_i$, you can end up with a type $B$ that is <strong>not</strong> in $\\mathcal{U}_i$. In more details: the formation rules in sections of the appendix A.2.4, A.2.5, A.2.6, A.2.7, A.2.8, A.2.9, A.2.10, A.3.2, either mention $\\mathcal{U}_i$ in the premise and judgement, or just in the judgement. </p>\n\n<p>The book also hints that there is a formal way to assign universes: </p>\n\n<blockquote>\n  <p>If there is any doubt about whether an\n  argument is correct, the way to check it is to try to assign levels consistently to all universes appearing in it.</p>\n</blockquote>\n\n<p><strong>What is the process for assigning levels consistently?</strong></p>\n\n<p><a href="http://cs.stackexchange.com/questions/12929/example-of-a-false-proposition-when-assuming-type-type">$\\mathcal{U}:\\mathcal{U}$ would lead to the Russell paradox</a>.\nAvoiding the Russell paradox is explicitly mentioned in the book (page 24). It also goes into more details page 54, 55 that is uses \u201cRussell-style universes\u201d rather than \u201cTarski-style universes\u201d. So at a very high level, I take for granted that the theory wants to avoid the paradox. Unfortunately I don\'t have the background to make sense of out that directly. What I am after in this question, is really just scratching the surface by getting some examples of things in $\\mathcal{U}_j$ and not in $\\mathcal{U}_i$ for $j &gt; i$ and may be anything else that give me a feel for how the hierarchies work. </p>\n', 'ViewCount': '172', 'Title': 'Universes in dependent type theory', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:30.993', 'LastEditDate': '2013-10-09T18:44:30.993', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '13296', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9179', 'Tags': '<type-theory><homotopy-type-theory><dependent-types>', 'CreationDate': '2013-07-15T13:01:16.747', 'Id': '13285'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '104', 'Title': '"OOD allows ADTs to be created and used."', 'LastEditDate': '2013-07-30T10:22:35.197', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9416', 'FavoriteCount': '1', 'Body': '<p>I just had a CS mid-term and one of the questions was:</p>\n\n<blockquote>\n  <p>OOD allows ADTs to be created and used.</p>\n  \n  <ul>\n  <li>True</li>\n  <li>False</li>\n  </ul>\n</blockquote>\n\n<p>I answered false, but my answer was marked as incorrect. I suspect what the question means is "objected-oriented design can be used to implement abstract data types", but if that\'s what it means it seems very clumsily worded to me. My rationale for answering false was ADTs are conceptual and exist outside of any particular programming paradigm, so "creation" of an ADT is purely a theoretical exercise.</p>\n\n<p>To me it seems like the question is analogous to saying "OOD allows algorithms to be created". You might use OOD in the implementation of an algorithm, but it has nothing to do with its creation.</p>\n\n<p>Would I be right in appealing my mark? My professor is kind of an idiot and I\'ve already corrected him on several other points throughout the term, so I\'m trying to avoid antagonizing him if I\'m wrong.</p>\n', 'Tags': '<programming-languages><object-oriented><abstract-data-types>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-30T10:22:35.197', 'CommentCount': '1', 'AcceptedAnswerId': '13505', 'CreationDate': '2013-07-29T23:22:03.170', 'Id': '13503'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Most specifically, his use of small epsilon introduced at the end of section 1 of "Types, Abstraction and Parametric Polymorphism" is throwing me, but in general I would like references to symbols in the Type and Logical Relations literature.</p>\n', 'ViewCount': '51', 'Title': 'Looking for cheat sheet to J.C. Reynolds symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T10:46:17.957', 'LastEditDate': '2013-08-27T10:46:17.957', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13957', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9831', 'Tags': '<terminology><reference-request><type-theory><abstract-data-types>', 'CreationDate': '2013-08-27T03:17:11.390', 'Id': '13954'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I understand that $\\Pi$ types are generalizations of functions and can be interpreted similar to $\\forall$ in logic. I also know that $\\Sigma$ types are generalizations of tuples and can be interpreted similar to $\\exists$ in logic. But whereas I find it easy to imagine $\\Pi$ type examples by thinking in Haskell, I am having a hard time thinking of good examples of $\\Sigma$ types. Is there a particular "canonical" $\\Sigma$ type that gives a good indication of how it can be interpreted as existence when the type is thought of as a proof? </p>\n', 'ViewCount': '101', 'Title': 'Example of existence proof in dependent typing?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:45:26.560', 'LastEditDate': '2013-10-09T18:45:26.560', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9918', 'Tags': '<type-theory><dependent-types>', 'CreationDate': '2013-08-31T16:15:52.920', 'Id': '14060'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is it possible to use <a href="http://en.wikipedia.org/wiki/Dependent_type" rel="nofollow">Dependent Types</a> in the existing <a href="http://docs.racket-lang.org/ts-guide/" rel="nofollow">Typed Racket</a> implementation? (ie do they exist in it?)</p>\n\n<p>Is it reasonably possible to implement a Dependent Types System using Typed Racket?</p>\n', 'ViewCount': '148', 'Title': 'Is it possible to do Dependent Types in Typed Racket?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-22T00:32:15.773', 'LastEditDate': '2013-10-09T18:43:51.303', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19183', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<programming-languages><typing><type-checking><dependent-types><lisp>', 'CreationDate': '2013-10-08T11:39:46.047', 'Id': '14905'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>On <a href="http://en.wikipedia.org/wiki/Pizza_%28programming_language%29" rel="nofollow">this page describing the precursor to the Scala language</a> - the pizza language - they refer to it having both case classes and <a href="http://en.wikipedia.org/wiki/Pattern_matching" rel="nofollow">pattern matching</a> - and then imply that these taken together provide <a href="http://en.wikipedia.org/wiki/Algebraic_data_type" rel="nofollow">algebraic types</a>. </p>\n\n<p>Is this the case? To provide algebraic types - do you combine <a href="http://en.wikipedia.org/wiki/Scala_%28programming_language%29#Case_classes_and_pattern_matching" rel="nofollow">case classes and pattern matching</a>?</p>\n', 'ViewCount': '33', 'Title': 'Are Algebraic types just the combination of case classes and pattern matching?', 'LastActivityDate': '2013-12-07T10:26:16.887', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18712', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<type-theory><pattern-recognition><abstract-data-types>', 'CreationDate': '2013-12-07T10:12:33.263', 'Id': '18711'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the introduction of the book by B.Jacobs, "Categorical Logic and Type Theory" (it\'s online <a href="http://synrc.com/publications/cat/Category%20Theory/Categorical%20Logic/Jacobs%20B.%20Categorical%20Logic%20and%20Type%20Theory.pdf" rel="nofollow">here</a>), he classifies type systems into three general flavours: Simply typed ones, depended typed (term depended types) and polymorphic types (type depended types). He says also there are also mix types. </p>\n\n<p>Now if you start out with a dependently types theory and introduce transitive universes, hence forcing types on the level of terms, are you automatically speaking of a polymorphic type system then?</p>\n', 'ViewCount': '31', 'Title': 'Does types being terms imply your dependend theory is considered polymorphic?', 'LastActivityDate': '2013-12-16T23:43:06.890', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19054', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2695', 'Tags': '<type-theory><dependent-types>', 'CreationDate': '2013-12-16T23:07:20.903', 'Id': '19053'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>In the pre-history of dependent type theory, Per Martin L\xf6f\nintroduced a calculus that is in some sense the simplest dependent\ntype theory and the most general form of impredicative polymorphism.\nIt is often referred to as <strong><em>Type:Type</em></strong> because the kind <strong><em>Type</em></strong> is\nitself of type <strong><em>Type</em></strong>.  Unfortunately, it is inconsistent as a\nlogic. This was discovered by Girard in his famous dissertation [1],\nwho managed to express the Burali-Forti paradox in <strong><em>Type:Type</em></strong>.\nVarious people have analysed, generalised and simplified Girard's\nanalysis, see e.g. [2, 3]. This analysis seems to involve showing that\nnon-terminating terms can be typed.</p>\n\n<p>I have a question about non-termination: do we get non-normalisation <strong><em>at\nthe level of types</em></strong>? By that I mean, is there a type $T$ such that the\nreduction relation $\\rightarrow$ used, explicitly or implicitly, to\ndefine equality of types, gives rise to an infinite reduction sequence\n$$\n   T \\rightarrow T' \\rightarrow T'' \\rightarrow \\cdots?\n$$</p>\n\n<p>[1] J.-Y.. Girard, Une extension de l'interpretation fonctionelle de\nG\xf6del a l'analyse.</p>\n\n<p>[2] T. Coquand, A New Paradox in Type Theory.</p>\n\n<p>[3] A. J. C. Hurkens, A Simplification of Girard's Paradox.</p>\n", 'ViewCount': '68', 'Title': u"Non-termination of types in Martin-L\xf6f's Type:Type?", 'LastEditorUserId': '2887', 'LastActivityDate': '2013-12-19T12:26:08.823', 'LastEditDate': '2013-12-19T12:26:08.823', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19072', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<type-theory><functional-programming><dependent-types><curry-howard>', 'CreationDate': '2013-12-17T14:11:17.690', 'Id': '19065'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I know that <a href="https://en.wikipedia.org/wiki/Idris_%28programming_language%29" rel="nofollow">Idris</a> has dependent types but isn\'t turing complete. What can it not do by giving up Turing completeness, and is this related to having dependent types?</p>\n\n<p>I guess this is quite a specific question, but I don\'t know a huge amount about dependent types and related type systems.</p>\n', 'ViewCount': '236', 'Title': 'What can Idris not do by giving up Turing completeness?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-18T14:35:33.427', 'LastEditDate': '2014-01-08T10:31:43.087', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12668', 'Tags': '<computability><programming-languages><type-theory><dependent-types>', 'CreationDate': '2014-01-08T09:57:09.923', 'FavoriteCount': '1', 'Id': '19577'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '99', 'Title': 'What are the difference between and consequences of using type parameters and type indexes?', 'LastEditDate': '2014-01-30T11:09:05.900', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8612', 'FavoriteCount': '1', 'Body': "<p>In type theories, like Coq's, we can define a type with parameters, like this:</p>\n\n<pre><code>Inductive ListP (Element : Type) : Type\n  := NilP  : ListP Element\n   | ConsP : Element -&gt; ListP Element -&gt; ListP Element.\n</code></pre>\n\n<p>Alternatively, we can define a type with an index, like this:</p>\n\n<pre><code>Inductive ListI : Type -&gt; Type\n  := NilI  : forall t, ListI t\n   | ConsI : forall t, t -&gt; ListI t -&gt; ListI t.\n</code></pre>\n\n<p>My questions are:</p>\n\n<ul>\n<li>Are these fundamentally different or fundamentally the same?</li>\n<li>What are the consequences of using one over the other?</li>\n<li>When is it preferable to use one over the other?</li>\n</ul>\n", 'Tags': '<type-theory><dependent-types>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T18:09:57.497', 'CommentCount': '0', 'AcceptedAnswerId': '20115', 'CreationDate': '2014-01-30T09:44:19.307', 'Id': '20100'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>the standard List type in Coq can be expressed as:</p>\n\n<pre><code>Inductive List (A:Set) : Set :=\n  nil : List A\n| cons : A -&gt; List A -&gt; List A.\n</code></pre>\n\n<p>as I understand, W-type express a well-founded tree of elements of this type. so, what if <code>nil</code> is not qualified by <code>A</code>? i.e. we have:</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil : List A</code> </p>\n</blockquote>\n\n<p>instead of</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil A: List A</code></p>\n</blockquote>\n\n<p>is this a correct W-type? can I express this in Coq?</p>\n', 'ViewCount': '38', 'Title': 'Is this a well founded inductive type? Can I express this in Coq?', 'LastActivityDate': '2014-02-16T08:07:20.807', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21693', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9922', 'Tags': '<type-theory><dependent-types><coq><inductive-datatypes>', 'CreationDate': '2014-02-14T17:40:00.397', 'Id': '21639'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Could somebody explain the difference between dependent types and refinement types? As I understand it, a refinement type contains all values of a type fulfilling a predicate. Is there a feature of dependent types which distinguishes them? </p>\n\n<p>If it helps, I came across Refined types via the Liquid Haskell project, and dependent types via Coq and Agda. That said, I'm looking for an explanation of how the theories differ. </p>\n", 'ViewCount': '59', 'Title': 'Dependent types vs refinement types', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T05:57:58.417', 'LastEditDate': '2014-02-17T10:00:36.913', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<terminology><programming-languages><type-theory><functional-programming><dependent-types>', 'CreationDate': '2014-02-17T07:54:50.867', 'Id': '21728'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>In the book <strong>Type Theory and Functional Programming</strong> <a href="http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/" rel="nofollow">[Thompson, S 1999]</a> the author explains the relationship between specifications, types and proofs of functions:</p>\n\n<blockquote>\n  <p>The equivalent specifications can be thought of as suggesting different program development methods: using the \u2203\u2200 form, we develop the function and its proof as separate entities, either separately or together, whilst in the \u2200\u2203 form we extract a function from a proof, post hoc.</p>\n  \n  <p>This analysis of specifications makes it clear that when we seek a program to meet a specification, we look for the first component of a member of an existential type; the second proves that the program meets the constraint part of the specification.</p>\n</blockquote>\n\n<p>On this same topic, <a href="http://cs.stackexchange.com/a/21332/1709">the commenter writes</a>:</p>\n\n<blockquote>\n  <p>Specifications are in a way "more detailed" types. Or, state the other way, types are more basic specifications. <a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory" rel="nofollow">Martin-Lof type theory</a> is precisely about fusing the two ideas into one.</p>\n</blockquote>\n\n<p>My question is: <strong>What is the evidence that that types are more basic specifications, and specifications are more detailed types?</strong></p>\n', 'ViewCount': '31', 'Title': 'What is the evidence that that types are more basic specifications, and specifications are more detailed types?', 'LastActivityDate': '2014-03-07T18:34:37.163', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '22377', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<functional-programming><types>', 'CreationDate': '2014-03-07T12:23:01.227', 'Id': '22371'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I implemented dependently typed lambda calculus in the spirit of this article: <a href="http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf" rel="nofollow">http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf</a></p>\n\n<p>The calculus, works and I experimented with it and like it. However, I want to add inductive types to do more complex stuff. What are the options for doing this?</p>\n\n<p>I am thinking about two ways of doing so</p>\n\n<ul>\n<li>Introduce Fin-N, Product and W-types and represent inductive types with them.</li>\n<li>Generate induction and recursion axioms.</li>\n</ul>\n\n<p>What can you recommend? How inductive types are represented in systems like Coq, Idris and Agda? Which articles can you recommend me?</p>\n', 'ViewCount': '20', 'Title': 'Representing inductive types', 'LastActivityDate': '2014-03-12T02:23:41.080', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7729', 'Tags': '<dependent-types><coq>', 'CreationDate': '2014-03-12T02:23:41.080', 'Id': '22524'}}