{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>For the branch-and-cut method, it is essential to know many facets of the polytopes generated by the problem. However, it is currently one of the hardest problems to actually calculate all facets of such polytopes as they rapidly grow in size.</p>\n\n<p>For an arbitrary optimization problem, the polytope used by branch-and-cut or also by cutting-plane-methods is the convex hull of all feasible vertices. A vertex is an assignment of all variables of the model. As a (very simple) example: if one would maximize $2\\cdot x+y$ s.t. $x+y \\leq 1$ and $0\\leq x,y\\leq 1.5$ then the vertices $(0,0)$, $(0,1)$ and $(1,0)$ are feasible vertices. $(1,1)$ violates the inequality $x+y\\leq 1.5$ and is therefore not feasible. The (combinatorical) optimization problem would be to choose among the feasible vertices. (In this case, obviously $(1,0)$ is the optimum). The convex hull of these vertices is the triangle with exactly these three vertices. The facets of this simple polytope are $x\\geq0$, $y\\geq 0$ and $x+y\\leq 1$. Note that the description through facets is more accurate than the model. In most hard problems - such as the TSP - the number of facets exceeds the number of model inequalities by several orders of magnitude.</p>\n\n<p>Considering the Travelling Salesman Problem, for which number of nodes is the polytope fully known and how much facets are there. if it is not complete, what are lower bounds on the number of facets?</p>\n\n<p>I'm particularly interested in the so-called hamiltonian path formulation of the TSP:</p>\n\n<p>$$min \\sum_{i=0}^{n-1}(\\sum_{j=0}^{i-1}c_{i,j}\\cdot x_{i,j}+\\sum_{j=i+1}^{n-1}c_{i,j}\\cdot x_{i,j})$$ s.t.</p>\n\n<p>$$\\forall i \\neq j:\\ \\ 0 \\leq x_{i,j}\\leq 1$$\n$$\\forall i \\neq j\\ \\ \\ x_{i,j}+x_{j,i}\\leq 1$$\n$$\\forall j \\ \\ \\sum_{i=0}^{j-1}x_{i,j}+\\sum_{i=j+1}^{n-1}x_{i,j}\\leq 1$$\n$$\\forall j \\ \\ \\sum_{i=0}^{j-1}x_{j,i}+\\sum_{i=j+1}^{n-1}x_{j,i}\\leq 1$$\n$$\\sum_{i=0}^{n-1}(\\sum_{j=0}^{i-1}x_{i,j}+\\sum_{j=i+1}^{n-1}x_{i,j})=n-1$$</p>\n\n<p>If you have any information about polytopes of other formulations of the TSP, feel free to share that too.</p>\n", 'ViewCount': '458', 'Title': 'Known facets of the Travelling Salesman Problem polytope', 'LastEditorUserId': '39', 'LastActivityDate': '2014-01-10T11:09:53.913', 'LastEditDate': '2013-06-06T15:04:53.917', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1227', 'Tags': '<algorithms><optimization><linear-programming><mathematical-programming><traveling-salesman>', 'CreationDate': '2012-08-29T21:07:54.547', 'FavoriteCount': '2', 'Id': '3367'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><a href="http://en.wikipedia.org/wiki/Fibonacci_number" rel="nofollow">Binet\'s formula</a> for the nth Fibonacci numbers is remarkable because the equation "converts" via a few arithmetic operations an irrational number $\\phi$ into an integer sequence. However, using finite precision arithmetic, one would always have some (small) roundoff error. </p>\n\n<blockquote>\n  <p>Is there a discussion/description somewhere of how to calculate the Fibonacci sequence using Binet\'s formula (ie <em>not</em> the recurrence relation) and floating point arithmetic which results in no roundoff error?</p>\n</blockquote>\n', 'ViewCount': '277', 'Title': "Calculating Binet's formula for Fibonacci numbers with arbitrary precision", 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-04T09:51:48.217', 'LastEditDate': '2012-12-04T04:02:54.733', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7150', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '699', 'Tags': '<algorithms><discrete-mathematics><floating-point><arithmetic><mathematical-programming>', 'CreationDate': '2012-12-04T03:33:25.020', 'Id': '7145'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>We have two integers $z, k$ </p>\n\n<p>We form a sequence now of first z natural numbers. i.e. $1, 2, 3, 4, \\ldots z$.</p>\n\n<p>Now we have to find total number of permutations of this sequence such that the sum of any two adjacent numbers is $ \\le k$</p>\n\n<p>( $z \\leq 10^6$, $\\;\\;z &lt; k &lt; 2*z$ )</p>\n\n<p>Here is what I have been able to think untill now. If <code>k=2*z-1,</code> the answer is <code>z!</code></p>\n\n<p>Now if we reduce the value of <code>k to 2*z-2</code>, then we take the highest pair as a group and permute with rest of the elements, we subtract this value from the previous case of <code>k=2*z-1</code></p>\n\n<p>i.e. <code>dp(z,k)= z!</code> for <code>k=2*z-1</code>. and <code>dp(z,k-1)=dp(z,k)-(z-1)!*2</code> for <code>k=2*z-2</code>.</p>\n\n<p>I want to know if I am going in the right direction. Any help on the closed form would be good.</p>\n', 'ViewCount': '278', 'Title': 'Permuting natural numbers', 'LastEditorUserId': '8505', 'LastActivityDate': '2013-06-09T02:10:39.487', 'LastEditDate': '2013-06-08T21:07:24.343', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '12548', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8505', 'Tags': '<algorithms><permutations><mathematical-programming>', 'CreationDate': '2013-06-08T00:10:29.857', 'Id': '12522'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m conflicted whether to post this here or in either math.stackexchange or mathematica.stackexchange.</p>\n\n<p>Define a "<strong>simple zonotope</strong>" to be a regular $2n$-gon which is tiled by the following rule: all tiles are rhombi. They key point here is that rhombuses have equal side lengths (say equal to 1), but their shapes are allowed to vary arbitrarly. Here\'s an example of a 12-gon zonotope:</p>\n\n<p><img src="http://i.stack.imgur.com/YATPS.png" alt="Zonotope"></p>\n\n<p>There are many characterizations and properties of these objects. For example, one can encode a zonotope using $2n$ vectors (one for each outer edge) since we can just translate copies of each vector.</p>\n\n<p><strong>What I would like to do is the following:</strong> I have the adjacency matrix of a graph that I believe to be a simple zonotope. Specifically, you can assume that we are starting with a <em>planer geometric graph</em>, in that I have an adjacency matrix, in addition to having (x,y) coordinates of each point. In other words, it\'s fairly straightforward to identify which vertices go to the outer vertices of the $2n$-polygon.Here\'s an example of a geometric graph that I could have:</p>\n\n<p><img src="http://i.stack.imgur.com/TFPlL.png" alt="enter image description here"></p>\n\n<p>In the above picture, the two red vertices indicate the north/south poles of the zonotope they are mapped to (which happens to be the zonotope in the first picture). </p>\n\n<blockquote>\n  <p>Question: What is the most painless way of drawing the simple zonotope from a given adjacency matrix plus geometric graph coordinates? </p>\n</blockquote>\n\n<p>Some observations: part of the algorithm is somewhat clear to me: one should work from the outside in. Once a specific rhombus side has been identified, all sides below it must be the same until we run into the opposite side of the zonotope. However this all seems very computationally expensive. I am honestly not preferential to any specific solution. I would even accept something akin to attaching springs to vertices and then running the algorithm until the graph converges to a zonotope.</p>\n', 'ViewCount': '79', 'Title': 'Drawing Zonotopes from an Adjacency Matrix', 'LastEditorUserId': '9472', 'LastActivityDate': '2013-08-01T18:59:46.497', 'LastEditDate': '2013-08-01T18:59:46.497', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9472', 'Tags': '<graph-theory><computational-geometry><mathematical-programming>', 'CreationDate': '2013-08-01T18:52:44.327', 'Id': '13568'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '106', 'Title': 'Writing a program to find polynomial $f(x)$ from $f(1)$ and $f(f(1))$', 'LastEditDate': '2013-10-06T18:17:17.187', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7890', 'FavoriteCount': '1', 'Body': '<p>Let $f(x)=a_0+a_1x+a_2x^2+\\dots+a_nx^n$, where $a_i\\ge0$ and $a_i$ is integer.</p>\n\n<p>Given $f(1)=p$ and $f(f(1))=q$, we have to find $a_0$, $a_1$, $a_2$, $a_3$, $\\dots$, $a_n$, where such $f(x)$ exists. Or we have to confirm if such $f(x)$ exists or if the polynomial is ambiguous e.g. for $p=1$ and $q=2$, no such $f(x)$ exists but for $p=1$ and $q=1$, $f(x)=1$, $f(x)=x^2$ both can be solution.</p>\n\n<p>I have to write a program to do that. What should be my procedure?</p>\n', 'Tags': '<mathematical-programming><polynomials>', 'LastEditorUserId': '7890', 'LastActivityDate': '2013-10-07T22:36:49.737', 'CommentCount': '0', 'AcceptedAnswerId': '14876', 'CreationDate': '2013-10-06T04:32:02.160', 'Id': '14853'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Suppose I am given a number $n$ (less than $10^8$) and $m$ (less than $10^7$) and $p$ (less than $10^4$), I have to write a program to find number of numbers that divide $n^m$ exactly $p$ times.</p>\n\n<p>Mathematically, I have to find number of distinct $x$ such that\n$$ n^m \\equiv 0 \\mod x^p \\qquad\\text{and}\\qquad n^m \\ne 0 \\mod x^{p+1} $$</p>\n\n<p>(From <a href="http://uva.onlinejudge.org/external/122/12216.html" rel="nofollow">UVa Online Judge</a>)</p>\n\n<p>What approach could be better than brute force?</p>\n', 'ViewCount': '55', 'Title': 'Finding number of numbers dividing n^m exactly p times', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-10T09:25:41.220', 'LastEditDate': '2013-10-10T09:25:41.220', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7890', 'Tags': '<algorithms><number-theory><arithmetic><mathematical-programming>', 'CreationDate': '2013-10-10T08:27:13.950', 'Id': '14981'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to know which algorithm is fastest for multiplication of two n-digit numbers?\nSpace complexity can be relaxed here! </p>\n', 'ViewCount': '1423', 'Title': 'What is the fastest algorithm for multiplication of two n-digit numbers?', 'LastActivityDate': '2013-11-03T08:50:13.817', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '16228', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '10700', 'Tags': '<algorithms><mathematical-programming>', 'CreationDate': '2013-10-19T12:49:57.087', 'FavoriteCount': '1', 'Id': '16226'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have been given a graph with n nodes. Now, I have to color every node of this graph by k colors, number from 0 to k-1. Now, there is a rule.</p>\n\n<p>For a node $x$ with adjacent nodes $y_1 , y_2, y_3, y_4,... y_m$, $color(x)=(color(y_1)+color(y_2)+color(y_3)+...+color(y_m)) \\pmod k $</p>\n\n<p>where $color(a)$ indicates a color number from 0 to k-1. I have to find number of ways I can color the whole graph.</p>\n\n<p>My approach to the problem was simple. I was constructing a $n*n$ matrix for n nodes in graph with equations like $col(x)-col(y_1)-col(y_2)-col(y_3)...-col(y_m)$. And trying to find number of all zero rows, which will provide us number of free variable. Is my approach correct?</p>\n', 'ViewCount': '56', 'Title': 'Solving a graph problem by Gaussian elimination', 'LastActivityDate': '2013-11-11T03:05:35.403', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '17903', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7890', 'Tags': '<graphs><linear-algebra><mathematical-programming>', 'CreationDate': '2013-11-10T03:10:23.457', 'Id': '17864'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '130', 'Title': 'Theorem Proofs in Coq', 'LastEditDate': '2013-12-09T18:57:00.543', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '11942', 'FavoriteCount': '1', 'Body': "<h1>Background</h1>\n\n<p>I am learning assistance, Coq, on my own. So far, I have completed reading Yves Bertot's <em>Coq in a Hurry</em>. Now, my goal is to prove some basic results concerning the natural numbers, culminating with the so-called division algorithm. However, I have encountered some setbacks on my way towards that goal. In particular, the two following results have proved (pun intended) to be more difficult to prove in Coq than I initially imagined. In fact, I have, after many fruitless attempts, resorted to prove them by hand (as shown below). This is clearly not helping me become more proficient in handling Coq; which is why I turn to this forum. My hope is that someone on this site is able and <strong>willing</strong> to help me translate my proofs below into a proof that Coq accepts. All help is sincerely appreciated!</p>\n\n<h2>Theorem A</h2>\n\n<p>For all $x,y \\in N$ \\begin{equation} x &lt; S(y) \\subset x &lt; y \\lor \\text{I}(N,x,y) \\end{equation}\n<strong>Proof:</strong></p>\n\n<p>Suppose $x &lt; S(y)$. Hence there is a $z \\in N$ with \\begin{equation} \\text{I}(N,x+S(z),S(y)) \\tag{*}\\end{equation}\nHence by (Peano 1b and 3) \\begin{equation} \\text{I}(N,x+z,y) \\end{equation}</p>\n\n<p>Define a predicate \\begin{equation} Q(u):=(\\text{I}(N,x+u,y) \\subset x&lt;y \\lor \\text{I}(N,x,y) \\end{equation}</p>\n\n<p>It is sufficient to show $Q(z)$. We prove this by induction on $z$. To see $Q(0)$, not ethat if $\\text{I}(N,x+0,y)$ holds then $\\text{I}(N,x,y)$ is true by Peano 1a. Thus, $x&lt;y \\lor \\text{I}(n,x,y)$. Now, we prove $Q(S(v))$: Suppose $\\text{I}(N,x+S(v),y)$. From this definition we have $x&lt;y$ and thus $x&lt;y \\lor \\text{I}(N,x,y)$ also in this case. Finally, Peano's fifth axiom gives $Q(z)$ and by $(*)$ we get $x &lt; y \\lor \\text{I}(N,x,y)$. \n\\begin{equation} \\tag{$\\square$} \\end{equation}</p>\n\n<h2>Theorem B</h2>\n\n<p>For all $x,y \\in N$ \\begin{equation} x &lt;y \\lor \\text{I}(N,x,y) \\lor y&lt;x \\end{equation}\n<strong>Proof:</strong></p>\n\n<p>If $x&lt;y$ then $\\neg \\text{I}(N,x,y)$ by definition, and if $x&gt;y$ then $\\neg \\text{I}(N,x,y)$ also by definition. If $x&gt;y$ <strong>and</strong> $y&gt;x$ then by transitivity and reflexivity, we have $\\text{I}(N,x,y)$, which is a contradiction. Consequently, no more than one of the statements is true. </p>\n\n<p>We keep $y$ fixed and induct on $x$. When $\\text{I}(N,0,y)$ we have $0 &lt; y \\lor \\text{I}(N,0,y)$ for all $y$, which proves the base case. Next, suppose the theorem holds for $x$; now we want to prove the theorem for $S(x)$. From the trichotomy for $x$, there are three cases: $x&lt;y,\\text{I}(N,x,y)$, and $x&gt;y$. If $x&gt;y$, then clearly $S(x) &gt;y$. If $\\text{I}(N,x,y)$, then $S(x) &gt;y$ (as $S(x) &gt;x$ for all $x\\in \\mathbb{N}$). Finally, suppose $x &lt;y$ Then, by theorem A we have $S(x) &lt; y$ or $\\text{I}(N,S(x),y)$, and in either case we are done.\n\\begin{equation} \\tag{$\\square$} \\end{equation}</p>\n\n<p>The theorems that I wish to prove, can be expressed as follows in Coq. </p>\n\n<blockquote>\n  <p>Lemma less_lem (x y:N) : \n  less x (succ y) -> or (less x y) (I N x y).</p>\n  \n  <p>Theorem Ntrichotomy: (forall x y:N, \n  or (less x y) (or (I N x y) (less y x))).</p>\n</blockquote>\n\n<h2>Useful results</h2>\n\n<p>Here, I have gathered some of the results that I have defined, and proved up to this point. These are the ones that I refer to above. *<em>This is the code that I have managed to write so far, note that most consists of definitions. *</em></p>\n\n<pre><code>(* Sigma types *)\n\n\nInductive Sigma (A:Set)(B:A -&gt; Set) :Set :=\n  Spair: forall a:A, forall b : B a,Sigma A B.\n\nDefinition E (A:Set)(B:A -&gt; Set)\n  (C: Sigma A B -&gt; Set)\n  (c: Sigma A B)\n  (d: (forall x:A, forall y:B x, \n      C (Spair A B x y))): C c :=\n\nmatch c as c0 return (C c0) with\n| Spair a b =&gt; d a b\nend. \n\n\n(* Binary sum type *)\n\nInductive sum' (A B:Set):Set := \ninl': A -&gt; sum' A B | inr': B -&gt; sum' A B.\n\nPrint sum'_rect.\n\nDefinition D (A B : Set)(C: sum' A B -&gt; Set)\n(c: sum' A B)\n(d: (forall x:A, C (inl' A B x)))\n(e: (forall y:B, C (inr' A B y))): C c :=\n\nmatch c as c0 return C c0 with\n| inl' x =&gt; d x\n| inr' y =&gt; e y\nend.\n\n(* Three useful finite sets *)\n\nInductive N_0: Set :=.\n\nDefinition R_0\n  (C:N_0 -&gt; Set)\n  (c: N_0): C c :=\nmatch c as c0 return (C c0) with\nend.\n\nInductive N_1: Set := zero_1:N_1.\n\nDefinition R_1 \n  (C:N_1 -&gt; Set)\n  (c: N_1)\n  (d_zero: C zero_1): C c :=\nmatch c as c0 return (C c0) with\n  | zero_1 =&gt; d_zero\nend.\n\nInductive N_2: Set := zero_2:N_2 | one_2:N_2.\n\nDefinition R_2 \n  (C:N_2 -&gt; Set)\n  (c: N_2)\n  (d_zero: C zero_2)\n  (d_one: C one_2): C c :=\nmatch c as c0 return (C c0) with\n  | zero_2 =&gt; d_zero\n  | one_2  =&gt; d_one\nend.\n\n\n(* Natural numbers *)\n\nInductive N:Set :=\nzero: N | succ : N -&gt; N.\n\nPrint N. \n\nPrint N_rect.\n\nDefinition R \n  (C:N -&gt; Set)\n  (d: C zero)\n  (e: (forall x:N, C x -&gt; C (succ x))):\n  (forall n:N, C n) :=\nfix F (n: N): C n :=\n  match n as n0 return (C n0) with\n  | zero =&gt; d\n  | succ n0 =&gt; e n0 (F n0)\n  end.\n\n(* Boolean to truth-value converter *)\n\nDefinition Tr (c:N_2) : Set :=\nmatch c as c0 with\n  | zero_2 =&gt; N_0\n  | one_2 =&gt; N_1\nend.\n\n(* Identity type *)\n\nInductive I (A: Set)(x: A) : A -&gt; Set :=\nr :  I A x x.\n\nPrint I_rect.\n\nTheorem J \n  (A:Set)\n  (C: (forall x y:A, \n              forall z: I A x y, Set))\n  (d: (forall x:A, C x x (r A x)))\n  (a:A)(b:A)(c:I A a b): C a b c.\ninduction c.\napply d.\nDefined.\n\n(* functions are extensional wrt\n  identity types *)\n\nTheorem I_I_extensionality (A B: Set)(f: A -&gt; B):\n(forall x y:A, I A x y -&gt; I B (f x) (f y)).\nProof.\nintros x y P.\ninduction P.\napply r.\nDefined.\n\n\n(* addition *)\n\nDefinition add (m n:N) : N \n := R (fun z=&gt; N) m (fun x y =&gt; succ y) n.\n\n(* multiplication *)\n\nDefinition mul (m n:N) : N \n := R (fun z=&gt; N) zero (fun x y =&gt; add y m) n.\n\n\n(* Axioms of Peano verified *)\n\nTheorem P1a: (forall x: N, I N (add x zero) x).\nintro x.\n(* force use of definitional equality\n  by applying reflexivity *)\napply r.\nDefined.\n\n\nTheorem P1b: (forall x y: N, \nI N (add x (succ y)) (succ (add x y))).\nintros.\napply r.\nDefined.\n\n\nTheorem P2a: (forall x: N, I N (mul x zero) zero).\nintros.\napply r.\nDefined.\n\n\nTheorem P2b: (forall x y: N, \nI N (mul x (succ y)) (add (mul x y) x)).\nintros.\napply r.\nDefined.\n\nDefinition pd (n: N): N :=\nR (fun _=&gt; N) zero (fun x y=&gt; x) n.\n\n(* alternatively\nDefinition pd (x: N): N :=\nmatch x as x0 with\n  | zero =&gt; zero\n  | succ n0 =&gt; n0\nend.\n*)\n\nTheorem P3: (forall x y:N, \nI N (succ x) (succ y) -&gt; I N x y).\nintros x y p.\napply (I_I_extensionality N N pd (succ x) (succ y)).\napply p.\nDefined.\n\nDefinition not (A:Set): Set:= (A -&gt; N_0).\n\nDefinition isnonzero (n: N): N_2:=\nR (fun _ =&gt; N_2) zero_2 (fun x y =&gt; one_2) n.\n\n\nTheorem P4 : (forall x:N, \nnot (I N (succ x) zero)).\nintro x.\nintro p.\n\napply (J N (fun x y z =&gt; \n    Tr (isnonzero x) -&gt; Tr (isnonzero y))\n    (fun x =&gt; (fun t =&gt; t)) (succ x) zero)\n.\napply p.\nsimpl.\napply zero_1.\nDefined.\n\nTheorem P5 (P:N -&gt; Set):\nP zero -&gt; (forall x:N, P x -&gt; P (succ x))\n   -&gt; (forall x:N, P x).\nintros base step n.\napply R.\napply base.\napply step.\nDefined.\n\n(* I(A,-,-) is an equivalence relation *)\n\nLemma Ireflexive (A:Set): (forall x:A, I A x x).\nintro x.\napply r.\nDefined.\n\nLemma Isymmetric (A:Set): (forall x y:A, I A x y -&gt; I A y x).\nintros x y P.\ninduction P.\napply r.\nDefined.\n\nLemma Itransitive (A:Set): \n(forall x y z:A, I A x y -&gt; I A y z -&gt; I A x z).\nintros x y z P Q.\ninduction P.\nassumption.\nDefined.\n\n\nLemma succ_cong : (forall m n:N, I N m n -&gt; I N (succ m) (succ n)).\nintros m n H.\ninduction H.\napply r.\nDefined.\n\nLemma zeroadd: (forall n:N, I N (add zero n) n).\nintro n.\ninduction n.\nsimpl.\napply r.\napply succ_cong.\nauto.\n\nDefined.\n\nLemma succadd: (forall m n:N, I N (add (succ m) n) (succ (add m n))).\nintros.\ninduction n.\nsimpl.\napply r.\nsimpl.\napply succ_cong.\nauto.\n\nDefined.\n\nLemma commutative_add: (forall m n:N, I N (add m n) (add n m)).\nintros n m; elim n.\napply zeroadd.\nintros y H; elim (succadd m y).\nsimpl.\nrewrite succadd.\napply succ_cong.\nassumption.\n\n\nDefined.\n\nLemma associative_add: (forall m n k:N, \nI N (add (add m n) k) (add m (add n k))).\nintros m n k.\ninduction k.\nsimpl.\napply Ireflexive.\nsimpl.\napply succ_cong.\nassumption.\nDefined.\n\nDefinition or (A B : Set):= sum' A B.\n\n\nDefinition less (m n: N) :=\n Sigma N (fun z =&gt; I N (add m (succ z)) n).\n\n\n\nLemma less_lem (x y:N) : \nless x (succ y) -&gt; or (less x y) (I N x y).\nintro.\ndestruct H.\nright.\n\n(* Here is where I'm working right now *)\n\nDefined.\n\n\nTheorem Ntrichotomy: (forall x y:N, \nor (less x y) (or (I N x y) (less y x))).\n</code></pre>\n", 'Tags': '<automated-theorem-proving><proof-assistants><mathematical-programming><coq>', 'LastEditorUserId': '106', 'LastActivityDate': '2013-12-10T16:39:28.090', 'CommentCount': '6', 'AcceptedAnswerId': '18792', 'CreationDate': '2013-12-08T23:54:04.043', 'Id': '18765'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<h2>Question</h2>\n\n<blockquote>\n  <p>How do I write more intuitive proofs of the two following results in Coq? </p>\n</blockquote>\n\n<pre><code>Theorem Course_of_values_ind: \n        InductiveRel N less\n\n  Theorem DivRem: (forall d n:N, \n      (Sigma N (fun q =&gt; (Sigma N (fun s =&gt;\n         and  (I N n (add (mul (succ d) q) s)) (less s (succ d))))))).\n</code></pre>\n\n<h2>Background</h2>\n\n<p>I recognize all of these results are already built into Coq, and so it is possible to provide much easier proofs than what I am asking for. This is something I have managed to do on my own; simply using the Coq library for this particular task. Even though this is much more concise (and thus arguably more elegant), I find don\'t find it very instructive.<strong>Luke Mathieson</strong> provided a good example of this when he gave an alternative proof in Coq of trichonomy for natural numbers:</p>\n\n<pre><code>(*\n  The following is just to show what can be done with some of the tactics\n  The omega tactic implements a Pressburger arithmetic solver, so anything\n  with natural numbers, plus, multiplication by constants, and basic logic\n  can just be solved. Not very interesting for practicing Coq, but cool to\n  know.\n*)\n\nRequire Import Omega.\n\nExample trich\' : forall (n m : nat),\n  n &lt; m \\/ n = m \\/ m &lt; n.\nProof.\n  intros.\n  omega.\nQed\n</code></pre>\n\n<p>Notice that the actual proof of the theorem in Coq does not reveal how the proof would look like informally. Thus, my hope is that someone may be kind enough to give a more, shall we say "intuitive", proof of the Euclidean division algorithm in Coq. The proof I have in mind will uses structural induction, which rests on the validity of the following lemma:</p>\n\n<blockquote>\n  <p><strong>Lemma</strong>: *$(\\mathbb{N},&lt;)$ is well founded. (Course_of_values_ind)*</p>\n</blockquote>\n\n<p>As this is so critical to the proof of the Euclidean division algorithm I decided to prove it. </p>\n\n<p><strong>Proof</strong>:</p>\n\n<p>Suppose that $P(x)$ set $(x:N$) is a progressive predicate  (definition is given below the proof of the Euclidean division algorithm) on $N$. Define \\begin{equation} Q(x)=_{def}(\\forall y:N)(y&lt;x \\subset P(y)) \\tag{*}\\end{equation}</p>\n\n<p>It is enough to prove $(\\forall x:N)Q(x)$, as then for any $x:N$ we have $x&lt;S(x)$ and so $P(x)$. $Q(0)$ follows by Peano\'s forth axiom. The inductive step $(\\forall x N)(Q(x) \\subset Q(S(x)))$ follows by theorem A (see <a href="http://cs.stackexchange.com/questions/18765/theorem-proofs-in-coq">Theorem Proofs in Coq</a>) combined with Peano 1a and 1b (see Code-file). </p>\n\n<blockquote>\n  <p>For all natural numbers $n$ and $m$ if $n&gt;0$, if $m&gt;0$ then there are natural numbers $q$ and $r$ such that $n=qm+r$ and $r&lt;m$. </p>\n</blockquote>\n\n<p>One may formalize this as:</p>\n\n<blockquote>\n  <p>\\begin{equation}(\\forall n:\\mathbb{N})(\\forall k:\\mathbb{N})(\\exists q:\\mathbb{N})(\\exists r:\\mathbb{N})(n=_{\\mathbb{N}}q\\cdot S(k)+r \\land r&lt;S(k) \\end{equation}</p>\n</blockquote>\n\n<p>where $m:=S(k)$. Now, an informal proof of the so-called Eucliean theorem can be given as:</p>\n\n<p>Proof:</p>\n\n<p>Let $k$\xa0be an arbitrary natural number, define $m:=S(k)$ and then proceed by strong induction on $n$ (this is justified by lemma). Suppose $n$ is a natural number and for every $l &lt;n$ there are natural numbers $q$ and $r$  such that $l=mq+r$ and $r &lt;m$. We now have two cases:</p>\n\n<ol>\n<li>$n&lt;m$. Let $q=0$ and $r=n$, Then clearly $n=qm+r$ and $r&lt;m$.</li>\n<li>$n \\geq m$ Let $l=n-m&lt;n$ and observe that since $n \\geq m$, $l$ is a natural number. By the inductive hypothesis one may now choose $q\'$ and $r\'$ such that $l=q\'m+r\'$ and $r\'&lt;m$. But, this means we have $n-m=q\'m+r\'$, so $n=q\'m+r\'+m=m(q\'+1)+r\'$. So, if we let $q=q\'+1$ and $r=r\'$, then we have $n=qm+r$ and $r&lt;m$. </li>\n</ol>\n\n<h1>Definitions of the terms I use in my informal proofs</h1>\n\n<pre><code>      Definition Progressive \n           (A:Set)(R: A -&gt; A -&gt; Set)(P:A -&gt; Set):=\n        (forall x:A, \n         (forall y:A, R y x -&gt; P y) -&gt; P x).\n\n        Definition InductiveRel \n        (A:Set)(R: A -&gt; A -&gt; Set):=\n        (forall P:A-&gt;Set, Progressive A R P -&gt; \n        forall x:A, P x). \n\n        Theorem Course_of_values_ind: \n        InductiveRel N less\n    Definition Decidable (A B:Set)(R: A -&gt; B -&gt; Set):Set :=\n    forall x:A, forall y:B, or (R x y) (not (R x y)).\n\n\n    Definition and (A B:Set) := prod A B.\n    Definition and_el_left (A B: Set)(p: and A B) \n    := fst p.\n    Definition and_el_right (A B: Set)(p: and A B) \n    := snd p.\n(* Euclidean Division *)\n\nTheorem DivRem: (forall d n:N, \n  (Sigma N (fun q =&gt; (Sigma N (fun s =&gt;\n     and  (I N n (add (mul (succ d) q) s)) (less s (succ d))))))).\n</code></pre>\n\n<h2>Code-file</h2>\n\n<p>This code was generously provided by <strong>cody</strong> (again see <a href="http://cs.stackexchange.com/questions/18765/theorem-proofs-in-coq">Theorem Proofs in Coq</a>). It is my intent to add the results presented above to this code as soon as they are all complete. </p>\n\n<pre><code>(* Inductive Sigma (A:Set)(B:A -&gt; Set) :Set := Spair: forall a:A, forall b : B a,Sigma A B. *)\n\n(* Definition E (A:Set)(B:A -&gt; Set) (C: Sigma A B -&gt; Set) (c: Sigma A B)  *)\n(*   (d: (forall x:A, forall y:B x, C (Spair A B x y))): C c := *)\n(*   match c as c0 return (C c0) with  *)\n(*     | Spair a b =&gt; d a b  *)\n(*   end. *)\n\nPrint sigT.\n\n(* Binary sum type *)\n\n(* Inductive sum\' (A B:Set):Set := inl\': A -&gt; sum\' A B | inr\': B -&gt; sum\' A B. *)\n\n(* Print sum\'_rect. *)\n\n(* Definition D (A B : Set)(C: sum\' A B -&gt; Set) (c: sum\' A B)  *)\n(*   (d: (forall x:A, C (inl\' A B x))) (e: (forall y:B, C (inr\' A B y))): C c := *)\n(*   match c as c0 return C c0 with  *)\n(*     | inl\' x =&gt; d x  *)\n(*     | inr\' y =&gt; e y  *)\n(*   end. *)\n\nPrint sum.\n\n(* Three useful finite sets *)\n\n(* Inductive N_0: Set :=. *)\n\n(* Definition R_0 (C:N_0 -&gt; Set) (c: N_0): C c :=  *)\n(*   match c as c0 return (C c0) with end. *)\n\nPrint False.\n\n\n(* Inductive N_1: Set :=  *)\n(*   zero_1 : N_1. *)\n\n(* Definition R_1 (C:N_1 -&gt; Set) (c: N_1) (d_zero: C zero_1): C c :=  *)\n(*   match c as c0 return (C c0) with  *)\n(*     | zero_1 =&gt; d_zero  *)\n(*   end. *)\n\nPrint unit.\n\n\n(* Inductive N_2: Set :=  *)\n(*  | zero_2 : N_2  *)\n(*  | one_2 : N_2. *)\n\n(* Definition R_2 (C:N_2 -&gt; Set) (c: N_2) (d_zero: C zero_2) (d_one: C one_2): C c :=  *)\n(*   match c as c0 return (C c0) with  *)\n(*     | zero_2 =&gt; d_zero  *)\n(*     | one_2 =&gt; d_one  *)\n(*   end. *)\n\nPrint bool.\n\n(* Natural numbers *)\n\n(* Inductive N:Set :=  *)\n(* |zero: N  *)\n(* | succ : N -&gt; N. *)\n\n(* Print N. *)\n\n(* Print N_rect. *)\n\n(* Definition R (C:N -&gt; Set) (d: C zero) (e: (forall x:N, C x -&gt; C (succ x))): (forall n:N, C n) :=  *)\n(*   fix F (n: N): C n :=  *)\n(*   match n as n0 return (C n0) with  *)\n(*     | zero =&gt; d  *)\n(*     | succ n0 =&gt; e n0 (F n0)  *)\n(*   end. *)\n\nPrint nat.\n\n(* Boolean to truth-value converter *)\n\n(* Definition Tr (c:N_2) : Set :=  *)\n(*   match c as c0 with  *)\n(*     | zero_2 =&gt; N_0  *)\n(*     | one_2 =&gt; N_1  *)\n(*   end. *)\n\nDefinition Tr (b : bool) : Type := if b then unit else False.\n\n(* Identity type *)\n\n(* Inductive I {A: Type}(x: A) : A -&gt; Type :=  *)\n(*   r : I x x. *)\n\n(* Print I_rect. *)\n\n(* Hint Resolve r.  *)\n\nPrint identity.\n\nNotation "x ~ y" := (identity x y)(at level 60).\n\nNotation "#":=(identity_refl)(at level 10).\n\nDefinition J \n  (A : Type)\n  (C: (forall x y : A, forall e : x ~ y, Type)) \n  (d: (forall x:A, C x x (# x))) :\n  (forall (a : A)(b : A)(e : a ~ b),  C a b e) :=\n    fun a b e =&gt;\n      match e in _ ~ b with\n        | # =&gt; d a\n      end.\n\nCheck J.\n\n(* functions are extensional wrt identity types *)\n\nDefinition id_ext {A B: Type} {x y : A} (f: A -&gt; B): \n  (x ~ y -&gt; (f x) ~ (f y))\n  := fun p =&gt;\n    match p with\n      # =&gt; # (f x)\n    end.\n\n(* addition *)\n\n(* Definition add (m n:N) : N := R (fun z=&gt; N) m (fun x y =&gt; succ y) n. *)\n\nPrint plus.\n\n(* multiplication *)\n\n(* Definition mul (m n:N) : N := R (fun z=&gt; N) zero (fun x y =&gt; add y m) n. *)\n\nPrint mult.\n\n(* Axioms of Peano verified *)\n\nRequire Import Arith.\n\nTheorem P1a: (forall x: nat, (0 + x) ~ x).\nProof.\n  simpl; auto.\nDefined.\n\n\nTheorem P1b: forall x y: nat, ((S x) + y) ~ (S (x + y)).\nProof.\n  simpl; auto.\nDefined.\n\nTheorem P2a: (forall x: nat, (0 * x) ~ 0).\nProof.\n  simpl; auto.\nDefined.\n\nTheorem P2b: forall x y: nat, ((S x) * y) ~ (y + (x * y)).\nProof.\n  simpl; auto.\nDefined.\n\n(* Definition pd (n: N): N := R (fun _=&gt; N) zero (fun x y=&gt; x) n. *)\n\nPrint pred.\n\nTheorem P3: (forall x y: nat, (S x) ~ (S y) -&gt; x ~ y).\nProof.\n intros x y p.\n apply (id_ext pred p).\nDefined.\n\n(* Definition not (A:Set): Set:= (A -&gt; N_0). *)\n\nPrint notT.\n\nDefinition isnonzero (n: nat): bool:= if n then false else true.\n\nEval compute in isnonzero 1.\nEval compute in isnonzero 0.\n\nNotation "x !~ y":= (notT (x ~ y))(at level 60).\n\nDefinition false_if_succ (n : nat) : Type := if n then unit else False.\n\nHint Resolve tt.\n\nTheorem P4 : (forall x: nat, (S x) !~ 0).\nProof.\n  intro x.\n  intro.\n  assert (false_if_succ (S x)).\n  rewrite H.\n  simpl; auto.\n  simpl in X; auto.\nQed.\n\n\nTheorem P5 (P:nat -&gt; Type): P 0 -&gt; (forall x:nat, P x -&gt; P (S x)) -&gt; (forall x:nat, P x).\nProof.\n  intros; induction x; auto.\nDefined.\n\n(* I(A,-,-) is an equivalence relation *)\n\n(*All these are in the std library *)\n\nLemma Ireflexive (A:Set): (forall x:A, x ~ x).\nProof.\n  auto.\nDefined.\n\nLemma Isymmetric (A:Set): (forall x y:A, x ~ y -&gt; y ~ x).\nProof.\n  auto.\nDefined.\n\nLemma Itransitive (A:Set): (forall x y z:A, x ~ y -&gt; y ~ z -&gt; x ~ z).\nProof.\n  intros x y z e1 e2.\n  rewrite e1; auto.\nDefined.\n\nLemma S_cong : (forall m n:nat, m ~ n -&gt; (S m) ~ (S n)).\nProof.\n  intros m n e; rewrite e; auto.\nDefined.\n\nLemma zeroadd: (forall n:nat, (n + 0) ~ n).\nProof.\n  induction n; simpl; auto.\n  rewrite IHn; auto.\nDefined.\n\nHint Rewrite zeroadd.\n\nLemma Sadd: (forall m n:nat, (m + (S n)) ~ (S (m + n))).\nProof.\n  induction m; intro n; auto.\n  simpl; rewrite IHm; auto.\nDefined.\n\nHint Rewrite Sadd.\n\nLemma commutative_add: (forall m n:nat, (m + n) ~ (n + m)).\nProof.\n  induction m; intro n.\n  rewrite zeroadd; auto.\n  simpl; rewrite IHm.\n  rewrite Sadd; auto.\nDefined.\n\nLemma associative_add: (forall m n k:nat, ((m + n) + k) ~ (m + (n + k))).\nProof.\n  induction m; auto.\n  intros n k; simpl.\n  rewrite IHm; auto.\nDefined.\n\nPrint sum.\n\nOpen Scope type_scope.\n\n(* Definition or (A B : Set):= (A + B). *)\n\nDefinition less (m n: nat) := { z : nat &amp; S (z + m) ~ n}.\n\nNotation "m &lt; n" := (less m n)(at level 70).\n\nLemma less_lem : forall n m : nat, n &lt; (S m) -&gt; (n &lt; m) + (n ~ m).\nProof.\n  intros n m leq.\n  elim leq.\n  induction x; simpl; intro e.\n  right.\n  apply P3; auto.\n  left.\n  exists x.\n  apply P3; auto.\nDefined.\n\n\nTheorem nattrichotomy: forall n m:nat, (n &lt; m) + (n ~ m) + (m &lt; n).\nProof.\n  induction n; induction m; simpl.\n  left; right; auto.\n  left; left.\n  exists m; rewrite zeroadd; auto.\n  right; exists n; rewrite zeroadd; auto.\n  destruct IHm as [ leq | gt ].\n  destruct leq as [lt | eq].\n  left; left; destruct lt.\n  exists (S x).\n  simpl; rewrite i; auto.\n  left; left; exists 0.\n  rewrite eq; simpl; auto.\n  generalize (less_lem _ _ gt); intro less_eq.\n  destruct less_eq as [less| eq].\n  right.\n  destruct less.\n  exists x.\n  rewrite Sadd; rewrite&lt;- i; auto.\n  left;right; rewrite eq; auto.\nDefined.\n</code></pre>\n', 'ViewCount': '115', 'Title': 'Euclidean Algorithm in Coq', 'LastEditorUserId': '11942', 'LastActivityDate': '2013-12-12T20:56:15.797', 'LastEditDate': '2013-12-12T12:25:32.687', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11942', 'Tags': '<proof-techniques><automated-theorem-proving><proof-assistants><mathematical-programming><coq>', 'CreationDate': '2013-12-12T00:51:07.960', 'Id': '18908'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Having large matrices, $W$ (the unknown) and $M$ (known), is it possible to solve for $W$ in this equation\n$$W \\cdot W^{T} = M,$$\nwhere $M$ can have negative entries.</p>\n', 'ViewCount': '26', 'Title': 'Solving for the matrix $W$ in an equation involving $W \\cdot W^{T}$', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-05T11:24:43.127', 'LastEditDate': '2014-03-05T11:24:43.127', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22302', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<linear-algebra><matrices><mathematical-programming>', 'CreationDate': '2014-03-05T10:37:02.450', 'Id': '22301'}}