3020:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3590', 'Title': 'Computing the longest common substring of two strings using suffix arrays', 'LastEditDate': '2013-02-07T13:55:33.637', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '4916', 'FavoriteCount': '2', 'Body': "<p>After I learned how to build a suffix array in $O(N)$ complexity, I am interested in discovering the applications of the suffix arrays. One of these is finding the longest common substring between two strings, in $O(N)$ time. I found on the internet the following algorithm:</p>\n\n<ol>\n<li>merge the two strings $A$ and $B$ into one string $AB$</li>\n<li>compute the suffix array of $AB$</li>\n<li>compute the $LCP$(longest common prefix) array</li>\n<li>the answer is the largest value $LCP[i]$</li>\n</ol>\n\n<p>I tried to implement it, but as many implementation details were not said(i.e. when concatenating the strings, should I put a special character between them($AcB$)?), my code failed on many test cases. Could someone elaborate more on this algorithm?</p>\n\n<p>Thanks in advance.</p>\n\n<p><strong>Note:</strong> I do not guarantee the correctness of this algorithm; I found it on a blog, and I'm not sure it is working. If you think it is incorrect, please suggest another algorithm.</p>\n", 'Tags': '<algorithms><suffix-array>', 'LastEditorUserId': '4916', 'LastActivityDate': '2013-02-10T01:10:19.597', 'CommentCount': '2', 'AcceptedAnswerId': '9619', 'CreationDate': '2013-02-06T20:18:26.923', 'Id': '9555'},3021:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>From what I have come to understand, the best way to implement it is to use the suffix  array $S$ of the string $w$ and its LCP-array (Longest Common Prefix) $L$.</p>\n\n<p>The answer can be obtained by </p>\n\n<p>$$ \\sum_{i=1}^{|w|} \\left( |S[i]| -L[i-1] \\right).$$</p>\n\n<p>What I don't get is how and why is this working?</p>\n\n<p>I would be very grateful if someone explained this.</p>\n", 'ViewCount': '914', 'Title': 'Number of distinct substrings in a string', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-19T07:11:22.433', 'LastEditDate': '2013-07-19T07:11:22.433', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13241', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9073', 'Tags': '<algorithms><data-structures><strings><substrings><suffix-array>', 'CreationDate': '2013-07-07T19:30:34.867', 'Id': '13140'},3022:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We are given an array $a[1 \\ldots n]$ with all $a[i]&gt;0$.</p>\n\n<p>Now we need to find how many distinct sums can be formed from its subarrays (where a subarray is a contiguous range of the array, i.e., $a[j\\ldots k]$ for some $j,k$, the sum is the sum of all of the elements of the subarray). For example, if $a=[1,2,1]$, then the answer is 4: we can form $ 1,2,3,4$.</p>\n\n<p>I know how to count the number of distinct sums in $O(n^2)$ time.</p>\n\n<p>Furthermore, I have come to realise this is similar to the classical problem where we need to find the number of distinct substrings of a string. I was thinking of the possibility of constructing a suffix array and solving it in a similar fashion (in $O(n)$ time). But I have not been able to figure out how to modify that to work here. For example, if we use suffix array for $a=[1,2,1]$ we will get 5 cases instead of the four acceptable ones. Is this possible to do this using suffix arrays or am I thinking in the wrong direction?</p>\n\n<p>Also there is one more direction I have been thinking in. Divide and conquer. Like if I divide the array into two parts every time until it is reduced to a single element. A single element can have one sum. Now if we combine two single elements, It can be done in two ways: if both single ranges have same element then we get 2 different sums, or if both have different elements we get 3 different sums. But I am not being able to generalize this for merging arrays of length greater than 1. Is it possible to merge two m size arrays and get the answer in $O(m)$?</p>\n', 'ViewCount': '262', 'Title': 'Counting number of sums from contiguous subarrays of an array', 'LastEditorUserId': '683', 'LastActivityDate': '2013-07-14T08:29:17.840', 'LastEditDate': '2013-07-14T08:29:17.840', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8622', 'Tags': '<arrays><substrings><suffix-array>', 'CreationDate': '2013-07-13T20:31:03.527', 'FavoriteCount': '1', 'Id': '13262'},3023:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have been reading a paper <a href="http://academic.research.microsoft.com/Paper/298449" rel="nofollow">Finding Maximal Pairs with Bounded Gap</a>:</p>\n\n<p>An in there, there is a sentence (page 6 second paragraph):</p>\n\n<blockquote>\n  <p>The \u201csmaller-half trick\u201d is used in several methods for finding tandem repeats,\n  e.g. [2, 5, 26]. It says that the sum over all nodes <em>v</em> in an arbitrary binary tree of size <em>n</em> of terms that are $O(n_{1})$, where $n_{1}\\leq n_{2}$ are the numbers of leaves in the subtrees rooted at the two children of <em>v</em>, is $O(n\\log n)$</p>\n</blockquote>\n\n<p>Although it sounds very straightforward, I just cannot see why this is true. Could someone with some experience regarding this trick please explain why this is true?\nI read several other papers but just don\'t see it.</p>\n', 'ViewCount': '57', 'Title': 'Suffix trees - "smaller half trick"', 'LastEditorUserId': '683', 'LastActivityDate': '2013-10-21T02:04:16.937', 'LastEditDate': '2013-10-21T01:40:07.977', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16273', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6697', 'Tags': '<time-complexity><suffix-array>', 'CreationDate': '2013-10-20T11:35:12.720', 'Id': '16253'},3024:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a string $(a_0,a_1,\\ldots a_n)$. I want to find the length of the longest common prefix of the substrings $(a_0,a_1,\\ldots a_{n-1})$ and $(a_1,a_2,\\ldots a_n)$. I know this has atleast $O(n)$ complexity. Lets call this operation as <em>prefix-suffix match</em>.</p>\n\n<p>I want to calculate <em>prefix-suffix match</em> length for all suffixes of a string. Now the naive algorithm which doesn't take into account that all the strings for which I am doing this operation are related has $O(n^2)$ complexity. Now my question is can we do this in better complexity. </p>\n\n<p>Note that what I want is similar to LCP array of a slightly modified suffix array. Where the suffixes are sorted based on length instead of lexicographic ordering. </p>\n", 'ViewCount': '98', 'Title': 'String matching for all suffixes', 'LastActivityDate': '2013-10-24T16:07:22.660', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10915', 'Tags': '<algorithms><strings><suffix-array>', 'CreationDate': '2013-10-22T10:41:46.603', 'Id': '16328'}