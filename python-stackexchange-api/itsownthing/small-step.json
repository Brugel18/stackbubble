315_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question arises from my reading of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">"Types and Programming Languages"</a> (<a href="http://www.worldcat.org/oclc/47705787" rel="nofollow">WoldCat</a>) by Benjamin C. Pierce.</p>\n\n<p>For the small step operational semantic evaluation rules for the arithmetic expressions (NB) in Figure 3-2 on page 41, there is the rule </p>\n\n<blockquote>\n  <p>$pred\\;(succ\\;nv_1)\\rightarrow\\;nv_1$</p>\n</blockquote>\n\n<p>My understanding is that it is to keep out invalid input like </p>\n\n<blockquote>\n  <p>$pred\\;(false)$</p>\n</blockquote>\n\n<p>but how did he come to that exact syntax for the rule? Is there some algorithm that is used to massage the rules into the necessary form? Is there some book or paper that explains how to formulate rules for small step operational semantics?</p>\n\n<p>Note: I am aware that there is a forum dedicated to questions for the book <a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list" rel="nofollow">here</a>. </p>\n', 'ViewCount': '76', 'Title': 'How does one deduce small step operational semantics?', 'LastActivityDate': '2013-03-08T01:26:40.747', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10348', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<semantics><operational-semantics><small-step>', 'CreationDate': '2013-03-07T00:29:07.013', 'Id': '10347'},315_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question arises from my reading of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">"Types and Programming Languages"</a> (<a href="http://www.worldcat.org/oclc/47705787" rel="nofollow">WorldCat</a>) by Benjamin C. Pierce.</p>\n\n<p>On page 36 is the definition for <em>satisfied</em></p>\n\n<blockquote>\n  <p>A rule is <em>satisfied</em> by a relation if, for each instance of the rule,\n  either the conclusion is in the relation or one of the premises is\n  not.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>instance</em></p>\n\n<blockquote>\n  <p>An <em>instance</em> of an inference rule is obtained by consistently replacing\n  each metavariable by the same term in the rule\'s conclusion and all its\n  premises (if any).</p>\n  \n  <p>For example </p>\n  \n  <p><code>if true then true else (if false then false else false) -&gt; true</code></p>\n  \n  <p>is an instance of <strong>E-IFTRUE</strong>, where both occurrences of $t_2$ have been\n  replaced by <code>true</code> and $t_3$ has been replaced by <code>if false then false else\n  false</code>.</p>\n</blockquote>\n\n<p>On page 15 is the definition for <em>relataion</em></p>\n\n<blockquote>\n  <p>An n-place <em>relation</em> on a collection of sets $S_1, S_2,..., S_n$ is a\n  set $R\\subseteq  S_1\\times\\;S_2\\;\\times\\;...\\;\\times\\;S_n$ of tuples\n  of elements from $S_1$ through $S_n$. We say that the elements $s_1\\in\n&gt; S_1$ thorugh $s_n\\in S_n$ are related by $R$ if $(s_1,...,s_n)$ is an\n  element or $R$.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>one-step evaluation relation ($\\rightarrow $)</em> </p>\n\n<blockquote>\n  <p>The <em>one-step evaluation relation $\\rightarrow $</em> is the smallest\n  binary relation on terms satisfying the three rules of Figure 3-1.\n  When the pair $(t,t\')$ is in the evaluation relation,  we say that "the\n  evaluation statement (or judgment) $t \\rightarrow t\'$ is derivable."</p>\n</blockquote>\n\n<p>On page 34 are the three rules from Figure 3-1</p>\n\n<p><strong>E-IFTRUE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;true\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IFFALSE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;false\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IF</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}\\frac{t_1\\rightarrow\\;t_1\'}{if\\;t_1\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;if\\;t_1\'\\;then\\;t_2\\;else\\;t_3}\\end{equation}</p>\n</blockquote>\n\n<p>Can someone explain this definition and give an example for parts of the defintion.<br>\n1. The conclusion is in the relation.<br>\n2. One of the premises is not.  </p>\n\n<p>Note: I am aware that there is a forum dedicated to questions for the book <a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list" rel="nofollow">here</a>.</p>\n\n<p>Note: You can use <a href="http://scholar.google.com/" rel="nofollow">Google Scholar</a> to see more of the details to this question in context.</p>\n\n<p>EDIT</p>\n\n<p>To connect some of the dots about my comment regarding unification and term rewriting.</p>\n\n<p>When I saw</p>\n\n<p>$$(A\\rightarrow B)\\equiv (\\neg A \\vee B)$$</p>\n\n<p>it reminded me of <a href="http://en.wikipedia.org/wiki/Horn_clause" rel="nofollow">Horn claues</a> from <a href="http://en.wikipedia.org/wiki/Prolog" rel="nofollow">Prolog</a>, that along with the example then connected with my understanding of <a href="http://en.wikipedia.org/wiki/Rewriting" rel="nofollow">term rewriting</a>. Having the book "<a href="http://www.cambridge.org/gb/knowledge/isbn/item1166682/?site_locale=en_GB" rel="nofollow">Term Rewriting and All That</a>" (<a href="http://www.worldcat.org/title/term-rewriting-and-all-that/oclc/37315354&amp;referer=brief_results" rel="nofollow">WorldCat</a>) by Franz Baader and Tobias Nipkow, I quickly looked up satisfiability and found satisfiable on page 58. This is actually the start of whole chapter on Equational Problems; but it also covers <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29" rel="nofollow">unification</a>. At that point I realized that the definition was dealing with <a href="http://en.wikipedia.org/wiki/Satisfiability" rel="nofollow">Satisfiability</a> and from there is was a topic I was already familiar. What threw me was the way Benjamin defined it. He used a very precise definition right up front in a manner I didn\'t associate with my knowledge.  </p>\n\n<p>If you work through the code as I am and understand logic programming, then the definition makes perfect sense.</p>\n', 'ViewCount': '107', 'Title': 'TAPL: Explanation and example(s) for satisfied', 'LastEditorUserId': '268', 'LastActivityDate': '2013-03-11T01:59:40.410', 'LastEditDate': '2013-03-11T01:59:40.410', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10403', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<satisfiability><operational-semantics><small-step><term-rewriting>', 'CreationDate': '2013-03-08T14:05:18.400', 'Id': '10386'},315_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to construct the small-step semantic rules involving the for-loops, but I can't find anything about it in the literature (only about while-loops).</p>\n\n<p>I was wondering if anyone could help me out with this? This is a first attempt, where $s$ represents a statement and $e$ an expression:</p>\n\n<p>$\\quad \\displaystyle\\sigma, \\text{for } s_1 \\, e_1 \\, e_2 \\, s_2 \\, \\rightarrow \\, \\sigma, \\text{if } e_1 \\text{ then (} s_2 ; \\, e_2; \\, \\text{for } s_1 \\, e_1 \\, e_2 \\, s_2 \\text{ ) else } skip$</p>\n\n<p>Where $\\sigma$ is a local value store, $s_1$ is for example $i = 0$, $e_1$ could equal $i &lt; 4$ and $e_2$ $i=i+1$. </p>\n", 'ViewCount': '27', 'Title': 'Small-step semantics: for-loops', 'LastEditorUserId': '16897', 'LastActivityDate': '2014-04-21T10:32:24.130', 'LastEditDate': '2014-04-21T10:32:24.130', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23983', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16897', 'Tags': '<formal-languages><programming-languages><semantics><operational-semantics><small-step>', 'CreationDate': '2014-04-21T10:18:48.197', 'Id': '23981'}