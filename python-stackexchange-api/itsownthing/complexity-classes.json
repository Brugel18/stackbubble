{'Body': "<p>What does the complexity class $\\oplus P^{\\oplus P}$ mean? I know that $\\oplus P$ is the complexity class which contains languages $A$ for which there is a polynomial time nondeterministic Turing machine $M$ such that $x \\in A$ iff the number of accepting states of the machine $M$ on the input $x$ is odd.</p>\n\n<p>But what does $\\oplus P^{\\oplus P}$ mean? I just can't follow what it actually does :)</p>\n\n<p>What are practical consequences of such complexity class and how it is possible to show that $\\oplus P^{\\oplus P} = \\oplus P$?</p>\n", 'ViewCount': '245', 'Title': 'What is complexity class $\\oplus P^{\\oplus P}$', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-15T08:01:04.303', 'LastEditDate': '2012-05-14T23:38:46.803', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1487', 'Tags': '<complexity-theory><terminology><complexity-classes>', 'CreationDate': '2012-05-14T16:02:11.397', 'Id': '1836''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I think I heard in somewhere that it has been proven that $\\mathsf{NP}$ is strictly contained in $\\mathsf{EXP}$, that is $\\mathsf{NP} \\subsetneq \\mathsf{EXP}$. Is this right? Wikipedia and book resources do not seem to bring me an answer..</p>\n\n<p>I just found a post similar to this, but I am not sure whether $\\mathsf{NP}$ is <em>strictly</em> contained in $\\mathsf{EXP}$.</p>\n', 'ViewCount': '634', 'Title': 'NP $\\subsetneq$ EXP?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-23T08:44:26.817', 'LastEditDate': '2013-05-24T08:03:36.003', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1412', 'Tags': '<complexity-theory><complexity-classes><np>', 'CreationDate': '2012-05-15T15:36:25.137', 'FavoriteCount': '1', 'Id': '1853''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there any decision problem that is in a complexity class properly included in DLOGTIME? (except $O(1)$, of course)</p>\n\n<p>If there is, can we create complete problems for DLOGTIME? So, can there be reduction by $O(\\log(\\log n))$ or smaller?</p>\n', 'ViewCount': '66', 'Title': 'Complexity class that properly included in DLOGTIME', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-28T11:02:54.960', 'LastEditDate': '2013-06-28T11:02:54.960', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1412', 'Tags': '<complexity-theory><time-complexity><complexity-classes>', 'CreationDate': '2012-06-04T08:35:54.763', 'FavoriteCount': '1', 'Id': '2221''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '1705', 'Title': 'Generalised 3SUM (k-SUM) problem?', 'LastEditDate': '2012-08-02T02:55:51.060', 'AnswerCount': '3', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '26', 'FavoriteCount': '7', 'Body': '<p>The <a href="http://en.wikipedia.org/wiki/3SUM">3SUM</a> problem tries to identify 3 integers $a,b,c$ from a set $S$ of size $n$ such that $a + b + c = 0$.</p>\n\n<p>It is conjectured that there is not better solution than quadratic, i.e. $\\mathcal{o}(n^2)$. Or to put it differently: $\\mathcal{o}(n \\log(n) + n^2)$.</p>\n\n<p>So I was wondering if this would apply to the generalised problem: Find integers $a_i$ for $i \\in [1..k]$ in a set $S$ of size $n$ such that $\\sum_{i \\in [1..k]} a_i = 0$.</p>\n\n<p>I think you can do this in $\\mathcal{o}(n \\log(n) + n^{k-1})$ for $k \\geq 2$ (it\'s trivial to generalise the simple $k=3$ algorithm).<br>\nBut are there better algorithms for other values of $k$?</p>\n', 'Tags': '<complexity-theory><combinatorics><complexity-classes>', 'LastEditorUserId': '26', 'LastActivityDate': '2012-08-02T05:04:34.593', 'CommentCount': '0', 'AcceptedAnswerId': '2995', 'CreationDate': '2012-07-31T21:45:29.147', 'Id': '2973''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Wondering about any known relations between <a href="http://qwiki.stanford.edu/index.php/Complexity_Zoo%3aR#rl" rel="nofollow">$\\mathsf{RL}$</a> complexity class (one sided error with logarithmic space) and its complementary class, $\\mathsf{coRL}$.</p>\n\n<p>Are they the same class?</p>\n\n<p>What are $\\mathsf{coRL}$\'s relation to $\\mathsf{NL}$, $\\mathsf{P}$?</p>\n', 'ViewCount': '99', 'Title': 'What is known about coRL and RL?', 'LastActivityDate': '2012-08-03T21:42:01.333', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3032', 'Score': '4', 'OwnerDisplayName': 'Uri', 'PostTypeId': '1', 'OwnerUserId': '2356', 'Tags': '<complexity-theory><complexity-classes><probabilistic-algorithms>', 'CreationDate': '2012-08-01T23:47:44.633', 'Id': '3031''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '468', 'Title': 'Types of reductions and associated definitions of hardness', 'LastEditDate': '2012-08-22T10:33:50.667', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2250', 'FavoriteCount': '3', 'Body': '<p>Let A be reducible to B, i.e., $A \\leq B$. Hence, the Turing machine accepting $A$ has access to an oracle for $B$. Let the Turing machine accepting $A$ be $M_{A}$ and the oracle for $B$ be $O_{B}$. The types of reductions:</p>\n\n<ul>\n<li><p>Turing reduction: $M_{A}$ can make multiple queries to $O_{B}$.</p></li>\n<li><p>Karp reduction: Also called "polynomial time Turing reduction": The input to $O_{B}$ must be constructed in polytime. Moreover, the number of queries to $O_{B}$ must be bounded by a polynomial. In this case: $P^{A} = P^{B}$.</p></li>\n<li><p>Many-one Turing reduction: $M_{A}$ can make only one query to $O_{B}$, during its the last step. Hence the oracle response cannot be modified. However, the time taken to constructed the input to $O_{B}$ need not be bounded by a polynomial.\nEquivalently: ($\\leq_{m}$ denoting many-one reduction)</p>\n\n<blockquote>\n  <p>$A \\leq_{m} B$ if $\\exists$ a computable function $f: \\Sigma^{\\ast} \\to \\Sigma^{\\ast}$ such that $f(x) \\in B \\iff x\\in A$.</p>\n</blockquote></li>\n<li><p>Cook reduction: Also called "polynomial time many-one reduction": A many-one reduction where the time taken to construct an input to $O_{B}$ must be bounded by a polynomial.\nEquivalently: ($\\leq^{p}_{m}$ denoting many-one reduction)</p>\n\n<blockquote>\n  <p>$A \\leq^p_{m} B$ if $\\exists$ a <em>poly-time</em> computable function $f: \\Sigma^{\\ast} \\to \\Sigma^{\\ast}$ such that $f(x) \\in B \\iff x\\in A$.</p>\n</blockquote></li>\n<li><p>Parsimonious reduction: Also called "polynomial time one-one reduction": A Cook reduction where every instance of $A$ mapped to a unique instance of $B$.\nEquivalently: ($\\leq^{p}_{1}$ denoting parsimonious reduction)</p>\n\n<blockquote>\n  <p>$A \\leq^p_{1} B$ if $\\exists$ a <em>poly-time</em> computable bijection $f: \\Sigma^{\\ast} \\to \\Sigma^{\\ast}$ such that $f(x) \\in B \\iff x\\in A$.</p>\n</blockquote>\n\n<p>These reductions preserve the number of solutions. Hence $\\#M_{A} = \\#O_{B}$.</p></li>\n</ul>\n\n<p>We can define more types of reductions by bounding the number of oracle queries, but leaving those out, could someone kindly tell me if I have gotten the nomenclature for the different types of reductions used, correctly.\nAre NP-complete problems defined with respect Cook reduction or parsimonious reduction? Can anyone kindly give an example of a problem that is NP-complete under Cook and not under parsimonious reduction.</p>\n\n<p>If I am not wrong, the class #P-Complete is defined with respect to Karp reductions.</p>\n', 'Tags': '<complexity-theory><np-complete><reductions><complexity-classes>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-19T20:30:35.610', 'CommentCount': '0', 'AcceptedAnswerId': '3290', 'CreationDate': '2012-08-22T05:45:07.493', 'Id': '3286''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The $\\text{NP-Complete}$ class of problems is defined w.r.t Karp Reductions, which are <strong>polytime many-one reductions</strong>. However, <em>they need not necessarily preserve the number of solutions</em>. A more restrictive type: <strong>polytime one-one reductions</strong> do indeed preserve the number of solutions.</p>\n\n<p>Suppose $f:\\Sigma^{\\ast}\\to \\mathbb{N}$ is a counting function in $\\text{#P}$ and the decision problem $f_{ &gt; 0}$ defined as: <strong>Is $f(x) &gt; 0$ ?</strong> is in $NP$.</p>\n\n<p>Now if $f_{&gt; 0}$ is in $\\text{NP-Complete}$, can we immediately tell that $f$ is in $\\text{#P-Complete}$ or, do we could only say so, if the reduction map (showing $\\text{NP-Completeness}$) was <strong>one-one</strong>.</p>\n', 'ViewCount': '148', 'Title': 'Hardness of counting solutions to NP-Complete problems, assuming a type of reduction', 'LastEditorUserId': '31', 'LastActivityDate': '2012-08-23T07:45:55.997', 'LastEditDate': '2012-08-23T07:45:55.997', 'AnswerCount': '0', 'CommentCount': '14', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2250', 'Tags': '<complexity-theory><reductions><complexity-classes>', 'CreationDate': '2012-08-22T23:09:57.760', 'FavoriteCount': '2', 'Id': '3295''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a number of related questions about these two topics.</p>\n\n<p>First, most complexity texts only gloss over the class $\\mathbb{NC}$.  Is there a good resource that covers the research more in depth?  For example, something that discusses all of my questions below.  Also, I\'m assuming that $\\mathbb{NC}$ still sees a fair amount of research due to its link to parallelization, but I could be wrong.    The section in the complexity zoo isn\'t much help.</p>\n\n<p>Second, computation over a semigroup is in $\\mathbb{NC}^1$ if we assume the semigroup operation takes constant time.  But what if the operation does not take constant time, as is the case for unbounded integers?  Are there any known $\\mathbb{NC}^i$-complete problems?</p>\n\n<p>Third, since $\\mathbb{L} \\subseteq \\mathbb{NC}^2$, is there an algorithm to convert any logspace algorithm into a parallel version?</p>\n\n<p>Fourth, it sounds like most people assume that $\\mathbb{NC} \\ne \\mathbb{P}$ in the same way that $\\mathbb{P} \\ne \\mathbb{NP}$.  What is the intuition behind this?</p>\n\n<p>Fifth, every text I\'ve read mentions the class $\\mathbb{RNC}$ but gives no examples of problems it contains.  Are there any?</p>\n\n<p>Finally, <a href="http://cs.stackexchange.com/a/1656/2911">this answer</a> mentions problems in $\\mathbb{P}$ with sublinear parallel execution time.  What are some examples of these problems?  Are there other complexity classes that contain parallel algorithms that are not known to be in $\\mathbb{NC}$?</p>\n', 'ViewCount': '228', 'Title': 'Some questions on parallel computing and the class NC', 'LastEditorUserId': '2911', 'LastActivityDate': '2012-09-24T15:39:26.497', 'LastEditDate': '2012-09-21T19:18:26.083', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2911', 'Tags': '<complexity-theory><reference-request><parallel-computing><complexity-classes>', 'CreationDate': '2012-09-21T18:50:22.743', 'FavoriteCount': '1', 'Id': '4659''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<blockquote>\n  <p>$L_1$ and $L_2$ are two languages defined on the alphabet $\\sum$.\n  $L_1$ is reducible to $L_2$ in polynomial time. Which of the following\n  cannot be true?</p>\n  \n  <ul>\n  <li>$L_1 \\in P$ and $L_2$ is finite</li>\n  <li>$L_1 \\in NP$ and $L_2 \\in P$</li>\n  <li>$L_1$ is undecidable and $L_2$ is decidable</li>\n  <li>$L_1$ is recursively enumerable and $L_2$ is recursive</li>\n  </ul>\n</blockquote>\n\n<p>My reasoning is as follow,</p>\n\n<p>If $A \\le_p B$, and $B \\in P$, then $A$ can be reduced to $B$ in polynomial time and solved in polynomial time making $A \\in P$. Thus I initially figured the 2nd choice as false and thus the right answer.</p>\n\n<p>However using the same argument on mapping reducibility, the 3rd choice seems to be false as well. The fourth choice is the same as the third one.</p>\n\n<p>I was unsuccessful in reasoning anything about the 1st choice.</p>\n\n<p>To put my above arguments in context, I am learning about theory of computation and have just about skimmed the surface of computability and complexity theory. Helo me out.</p>\n', 'ViewCount': '354', 'Title': 'Polynomial time reducibility', 'LastActivityDate': '2012-10-25T08:36:57.790', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '6307', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<complexity-theory><reductions><complexity-classes>', 'CreationDate': '2012-10-24T13:41:22.653', 'Id': '6291''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '220', 'Title': 'Intuition behind Relativization', 'LastEditDate': '2012-11-15T09:19:53.543', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1379', 'FavoriteCount': '1', 'Body': '<p>I take course on Computational Complexity. My problem is I don\'t understand <strong>Relativization method</strong>. I tried to find a bit of intuition in many textbooks, unfortunately, so far with no success. I will appreciate if someone could shed the light on this topic so that I will be able to continue by myself.\nFew following sentences are questions and my thoughts about relativization, they will help to navigate the discussion. </p>\n\n<p>Very often relativization comes in comparison with diagonalization, which is a method that helps distinguish between countable set and uncountable set. It somehow comes from relativization that $P$ versus $NP$ question cannot be solved by diagonalization. I don\'t really see the idea why relativization show the useless of diagonalization, and if it\'s useless why is actually useless.</p>\n\n<p>The idea behind oracle Turing machine $M^A$ at first is very clear. However, when it comes to $NP^A$ and $P^A$ the intuition disappears. Oracle is a blackbox that is designed for special language and answers the question whether the string on the input of the oracle is in the language in time 1. As I understood TM that contains an oracle is just make some auxiliary operations and ask the oracle. So the core of the TM is the oracle, everything else is less important. What\'s the difference between $P^A$ and $NP^A$, even thought oracle in both of them works in time 1.</p>\n\n<p>The last  thing is the proving the existence of an oracle $B$ such that $P^B \\neq NP^B$. I found the proof in several textbooks and in all of them the proof seems very vague. I tried to use <strong>"Introduction to complexity" by Sipser, Chapter9. Intractability</strong>, and didn\'t get the idea of construction of a list of all polynomial time oracle TMs $M_i$. </p>\n\n<p>This is more or less everything what I know about relativization, I will appreciate if someonw would decide to share his/her thoughts on the topic.</p>\n\n<p><strong>Addendum</strong>: in one of the textbooks I found example of $NP^B$ language (Computational Complexity: A Modern Approach by Boaz Barak Sanjeev Arora. Theorem 3.7. Page 74). $U_B=\\left \\{ 1^n:some \\space string \\space of  \\space length \\space  n  \\space is \\space  in \\space B\\right \\} $ it\'s unary language. I believe that (1,11,111,1111,...) are all in $U_B$. Author affirms that such a language is in $NP^B$ which is I cannot understand why, hence oracle for B can resolve everything in time 1. Why do we need nondeterministic TM with oracle. If it\'s not good example of $NP^B$ please put yours such that to approve the existence of $NP^B$.</p>\n', 'Tags': '<complexity-theory><np-complete><complexity-classes><relativization><np>', 'LastEditorUserId': '1379', 'LastActivityDate': '2012-11-15T09:19:53.543', 'CommentCount': '6', 'AcceptedAnswerId': '6666', 'CreationDate': '2012-11-14T14:14:35.827', 'Id': '6665''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I would like to ask you some clarification on the following question:\nknow that ${\\sf NP}$ is a subset of ${\\sf IP}$ \nand also ${\\sf coNP}$ it is a subset of ${\\sf IP}$.\nSo ${\\sf IP}$ is a biggest class, but how much it is big?</p>\n\n<p>May i say that ${\\sf PSPACE}$ is a subset of ${\\sf IP}$? or that they may intersect?</p>\n\n<p>Can you give me a easy clarification about it?</p>\n', 'ViewCount': '160', 'Title': 'Relation between interactive proof systems (IP), NP, coNP, PSPACE', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-16T21:07:21.567', 'LastEditDate': '2012-11-16T21:07:21.567', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4488', 'Tags': '<complexity-theory><time-complexity><space-complexity><complexity-classes><interactive-proof-systems>', 'CreationDate': '2012-11-15T13:47:04.607', 'Id': '6679''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '271', 'Title': 'Proving that if $\\mathrm{NTime}(n^{100}) \\subseteq \\mathrm{DTime}(n^{1000})$ then $\\mathrm{P}=\\mathrm{NP}$', 'LastEditDate': '2012-12-13T02:35:05.343', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2329', 'FavoriteCount': '3', 'Body': "<p>I'd really like your help with proving the following.</p>\n\n<p>If $\\mathrm{NTime}(n^{100}) \\subseteq \\mathrm{DTime}(n^{1000})$ then $\\mathrm{P}=\\mathrm{NP}$.</p>\n\n<p>Here, $\\mathrm{NTime}(n^{100})$ is the class of all languages which can be decided by nondeterministic Turing machine in polynomial time of $O(n^{100})$ and $\\mathrm{DTime}(n^{1000})$  is the class of all languages which can be decided by a deterministic Turing machine in polynomial time of $O(n^{1000})$.</p>\n\n<p>Any help/suggestions?</p>\n", 'Tags': '<time-complexity><complexity-classes><p-vs-np>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:35:05.343', 'CommentCount': '2', 'AcceptedAnswerId': '6730', 'CreationDate': '2012-11-16T12:57:46.333', 'Id': '6695''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I try to understand if someone can apply a <strong>NTM</strong> to recognize <strong>coNP</strong> language.</p>\n\n<p>From the definition we know that:</p>\n\n<p><strong>NP</strong> - set of languages that can be recognized by NTM in polynomial time.</p>\n\n<p><strong>coNP</strong> - set of all languages that are complement to NP language.</p>\n\n<p>as with P versus NP question, we have NP versus coNP question.</p>\n\n<p>Unfortunately, is not defined explicitly if can one recognize coNP language with NTM.</p>\n\n<p>However, if we take a look at few examples from the set of coNP languages, few questions emerge.</p>\n\n<p>TAUTOLOGY = {$\\varphi$:$\\varphi$ is satisfied by every assingment}</p>\n\n<p>$\\bar{SAT}$ = {$\\varphi$: $\\varphi$ is not satisfiable }</p>\n\n<p>These languages are known to be coNP language and intuitively it seems like one can construct NTM to recognize these languages. On the other hand, if one can construct NTM to recognize them why them not in NP class (by definition)? Maybe not all language of coNP can be solved by NTM just few of them, if yes, we will have intersection of NP class and coNP class. And if every language from coNP class cannot be solved by NTM, does it mean that limitation of NTM is located in coNP class. Is NTM is limited at all?</p>\n\n<p>I am a little bit confused, I will appreciate if someone will shed the light on this topic.</p>\n', 'ViewCount': '79', 'Title': 'coNP and limitation of NDTM', 'LastEditorUserId': '1379', 'LastActivityDate': '2012-11-17T23:36:10.440', 'LastEditDate': '2012-11-17T18:56:14.323', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<complexity-theory><np-complete><complexity-classes>', 'CreationDate': '2012-11-17T17:37:12.450', 'Id': '6718''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In this Wikipedia article about the <a href="http://en.wikipedia.org/wiki/Clique_%28graph_theory%29">Clique problem in graph theory</a> it states in the beginning that the problem of finding a clique of size K, in a graph G is NP-complete:</p>\n\n<blockquote>\n  <p>Cliques have also been studied in computer science: finding whether there is a clique of a given size in a graph (the clique problem) is NP-complete, but despite this hardness result many algorithms for finding cliques have been studied.</p>\n</blockquote>\n\n<p>But in this other Wikipedia article about the <a href="http://en.wikipedia.org/wiki/Clique_problem">Clique problem in CS</a>\n it says it is solving the problem for a fixed size k is a problem in P, it can be brute forced in polynomial time.</p>\n\n<blockquote>\n  <p>A brute force algorithm to test whether a graph G contains a k-vertex clique, and to find any such clique that it contains, is to examine each subgraph with at least k vertices and check to see whether it forms a clique. This algorithm takes time O(n^k k^2): there are O(n^k) subgraphs to check, each of which has O(k^2) edges whose presence in G needs to be checked. Thus, the problem may be solved in polynomial time whenever k is a fixed constant. When k is part of the input to the problem, however, the time is exponential.</p>\n</blockquote>\n\n<p>Is there something I am missing here? Maybe a difference in the wording of the problem? And what does the last sentence mean, that "When k is part of the input to the problem, however, the time is exponential."? Why is there a difference when the k is part of the input to the problem?</p>\n\n<p>My idea is that to find a clique of size k in a graph G, is that we first choose a subset of size k of nodes from G, and test wether they are all related to the other k nodes, which can be done in constant time. And repeat this until we have a clique of size k. The number of sets of k nodes we can choose from G is n! / k!*(n-k)!. </p>\n', 'ViewCount': '1742', 'Title': 'Is the k-clique problem NP-complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-24T15:19:38.560', 'LastEditDate': '2012-11-24T15:19:38.560', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6848', 'Score': '8', 'OwnerDisplayName': 'Eivind', 'PostTypeId': '1', 'Tags': '<complexity-theory><graph-theory><np-complete><complexity-classes>', 'CreationDate': '2012-11-22T08:52:36.760', 'Id': '6847''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m reviewing for finals and have a sample problem that I <strong>think</strong> I understand, but would like someone to bless my understanding or smack me and tell me why I\'m wrong.</p>\n\n<p>I\'m presented with a problem $\\Pi$  of unknown complexity class.  If I can transform $\\Pi$ to some problem $X$, where $X  \\in {\\sf P}$, what does that tell me about $\\Pi$?</p>\n\n<p>I think allows me to conclude that $\\Pi \\in {\\sf P}$, right? If I can reduce $\\Pi$ to another problem that\'s deterministically solvable in polynomial time, and the transformation itself can be done "easily" in polynomial time, then I can conclude that $\\Pi$ is deterministically solvable in polynomial time, and therefore that $\\Pi \\in {\\sf P}$ correct?</p>\n\n<p>Conversely, given the same input, transforming $X$ to $\\Pi$ in polynomial time allows me to conclude nothing meaningful, since nothing is known about  $\\Pi$ right?</p>\n', 'ViewCount': '110', 'Title': 'Implications of polynomial time reductions', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-16T19:03:45.837', 'LastEditDate': '2012-12-16T19:03:45.837', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7439', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5084', 'Tags': '<complexity-theory><reductions><complexity-classes><p-vs-np>', 'CreationDate': '2012-12-16T15:28:34.083', 'Id': '7438''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is it possible that P != NP and the cardinality of P is the same as the cardinality of NP?  Or does P != NP mean that P and NP must have different cardinalities?</p>\n', 'ViewCount': '655', 'Title': 'Does P != NP imply that | NP | > | P |?', 'LastActivityDate': '2014-04-09T02:56:34.357', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'Jason Baker', 'PostTypeId': '1', 'OwnerUserId': '4849', 'Tags': '<complexity-classes><p-vs-np>', 'CreationDate': '2012-12-31T17:09:57.310', 'FavoriteCount': '5', 'Id': '7665''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '241', 'Title': 'Concrete understanding of difference between PP and BPP definitions', 'LastEditDate': '2013-02-15T07:31:32.413', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5356', 'FavoriteCount': '3', 'Body': '<p>I am confused about how  <strong>PP</strong> and <strong>BPP</strong> are defined. Let us assume $\\chi$ is the characteristic function for a language $\\mathcal{L}$. <em>M</em> be the probabilistic Turing Machine. Are the following definitions correct:<br>\n$BPP =\\{\\mathcal{L} :Pr[\\chi(x) \\ne M(x)] \\geq \\frac{1}{2} + \\epsilon \\quad \\forall x \\in \\mathcal{L},\\ \\epsilon &gt; 0 \\}$<br>\n$PP =\\{\\mathcal{L} :Pr[\\chi(x) \\ne M(x)] &gt; \\frac{1}{2} \\}$  </p>\n\n<p>If the definition are wrong, please try to make minimal change to make them correct (i.e. do not give other equivalent definition which use counting machine or some modified model). I can not properly distinguish the conditions on probability on both the definitions.  </p>\n\n<p>Some concrete examples with clear insight into the subtle points would be very helpful. </p>\n', 'Tags': '<complexity-theory><terminology><randomized-algorithms><complexity-classes>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T07:31:32.413', 'CommentCount': '0', 'AcceptedAnswerId': '7849', 'CreationDate': '2013-01-09T11:28:04.633', 'Id': '7848''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Does the proof of the widely believed result P $\\neq$ NP depend on the proof of NP $\\neq$ Co-NP ?</p>\n', 'ViewCount': '201', 'Title': 'If NP $\\neq$ Co-NP then is P $\\neq$ NP', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-12T17:03:17.257', 'LastEditDate': '2013-01-12T17:03:17.257', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<complexity-theory><complexity-classes><p-vs-np>', 'CreationDate': '2013-01-10T01:36:06.260', 'Id': '7861''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '334', 'Title': 'P, NP and specialised Turing Machines', 'LastEditDate': '2013-02-08T08:34:13.790', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6769', 'FavoriteCount': '2', 'Body': "<p>I'm sort of new, but very interested to the field of computing and complexity theory, and I want to clarify my understanding about how to class problems, and how strongly the problems relate to the machine being used to solve them.</p>\n\n<p><strong>My Understanding</strong></p>\n\n<ul>\n<li>Standard Turing Machine - a Turing Machine which has a finite alphabet, finite number of states and a single right-infinite tape</li>\n<li>Turing-Equivalent Machine - a Turing Machine which, can emulate, and be emulated by, a Standard Turing Machine (quite often with some trade-off between space and time achieved by the emulation)</li>\n<li><code>P</code> - the class of problems which can be solved in polynomial time using a Standard Turing Machine (defined above)</li>\n<li><code>NP</code> - the class of problems which can be verified in polynomial time using a Standard Turing Machine</li>\n<li><code>NP-complete</code> - the hardest problems which are still in <code>NP</code>, which all <code>NP</code> problems can be converted to in polynomial time</li>\n</ul>\n\n<p><strong>My Question</strong></p>\n\n<p>Are the complexity classes (<code>P</code>, <code>NP</code>, <code>NP-complete</code>, etc) related to the algorithm, or the algorithm and the machine?</p>\n\n<p>Said in another way, if you could create a Turing Equivalent Machine (that can solve all the problems that a Standard TM can, but in a different amount of time/space) and this new machine could solve an <code>NP-complete</code> problem in time which grows as a polynomial with respect to the input, would that imply <code>P=NP</code>?</p>\n\n<p>Or must the <code>NP-complete</code> problem be solvable on all possible Turing Machines in polynomial time to be considered in <code>P</code>?</p>\n\n<p>Or do I mis-understand something fundamental above?</p>\n\n<p>I have had a look (maybe not with the correct search terms, I don't know all the jargon quite well) but it seems most lectures/notes etc. focus on standard machines but say that custom machines often have some time/space speed up at the expense of space/time, without saying how that bears on complexity classes. I'm not really familiar enough with the jargon in this field yet to find papers which explain this.</p>\n", 'Tags': '<complexity-theory><computability><terminology><turing-machines><complexity-classes>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T20:15:58.060', 'CommentCount': '1', 'AcceptedAnswerId': '9593', 'CreationDate': '2013-02-08T02:06:20.137', 'Id': '9585''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '295', 'Title': 'Can we make a problem harder than NP and coNP if they are not equal?', 'LastEditDate': '2013-02-15T16:30:56.863', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Jose Antonio Martin H', 'PostTypeId': '1', 'OwnerUserId': '6655', 'Body': '<p>Let us assume that $\\mathsf{NP} \\neq \\mathsf{coNP}$. Consider the graph 3-colorability problem.</p>\n\n<p>Since $\\mathsf{NP} \\neq \\mathsf{coNP}$ implies $\\mathsf{P} \\neq \\mathsf{NP}$ and 3-coloribility is $\\mathsf{NP}$-complete and its complement is $\\mathsf{coNP}$-complete , we have:</p>\n\n<ol>\n<li>3-coloribility is not in $\\mathsf{P}$, i.e. there are no polynomial-time algorithm for deciding if a given graph is 3-colorable.</li>\n<li>non-3-coloribility is not in $\\mathsf{NP}$, i.e. there are no polynomial-time verifier with polynomial-size certificatesfor non-3-colorability.</li>\n</ol>\n\n<p>However, we know that for many classes of graphs, polynomial algorithms exists for 3-colorability and also they have polynomial-time verifiers with polynomial-size certificates for non-3-colorability. But this is not the case for all graphs since we we assumed that  $\\mathsf{NP} \\neq \\mathsf{coNP}$.</p>\n\n<p>We can define the following problem:</p>\n\n<blockquote>\n  <p>Input: a graph $G$,<br>\n  Task: determine if $G$ is 3-colorable or non-3-colorable and provide a certificate for the answer. The certificate is either a 3-coloring or a non-3-colorability certificate. </p>\n</blockquote>\n\n<p>What is the complexity of this problem?</p>\n\n<p>YES version is in $\\mathsf{NP}$ . And the NO version is in $\\mathsf{coNP}$. Note that the answer is not always YES since $\\mathsf{NP} \\neq \\mathsf{coNP}$.</p>\n', 'Tags': '<complexity-theory><complexity-classes>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-16T06:15:30.230', 'CommentCount': '6', 'AcceptedAnswerId': '9735', 'CreationDate': '2013-02-13T00:01:44.327', 'Id': '9734''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '160', 'Title': 'Is the open question NP=co-NP the same as P=NP?', 'LastEditDate': '2013-02-15T07:34:14.460', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6569', 'FavoriteCount': '1', 'Body': "<p>I'm wondering this based on several places online that call $\\sf NP=$ co-$\\sf NP$ a major open problem... but I can't find any indication as to whether or not this is the same as $\\sf P=NP$ problem...</p>\n", 'Tags': '<complexity-theory><complexity-classes><p-vs-np>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T10:57:56.617', 'CommentCount': '0', 'AcceptedAnswerId': '9798', 'CreationDate': '2013-02-15T01:38:55.790', 'Id': '9795''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Are all algorithms which have polynomial time complexity belong to P class ? And P class do not have any algorithm which does have not polynomial complexity ? </p>\n\n<p>Are all algorithms which have non polynomial complexity belong to NP or NP-Hard or both ?</p>\n\n<p>I am just trying to understand the basic relationship.</p>\n', 'ViewCount': '157', 'ClosedDate': '2013-02-19T03:39:35.053', 'Title': 'The exact relation between complexity classes and algorithm complexities', 'LastActivityDate': '2013-02-19T00:36:46.637', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '9910', 'Score': '2', 'OwnerDisplayName': 'avi', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<complexity-classes><np><polynomial-time>', 'CreationDate': '2013-02-18T15:56:37.437', 'Id': '9909''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '141', 'Title': 'How to show that the complement of a language in $\\mathsf P$ is also in $\\mathsf P$?', 'LastEditDate': '2013-03-04T13:30:31.070', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7140', 'Body': u'<p>If $L$ is a binary language (that is, $L \\subseteq \\Sigma = \\{0,1\\}^\u2217$) and $\\overline{L}$ is the complement of $L$:</p>\n\n<p>How can I show that if $L \\in \\mathsf P$, then $\\overline{L} \\in \\mathsf P$ as well?</p>\n', 'ClosedDate': '2013-03-04T19:39:55.200', 'Tags': '<complexity-theory><formal-languages><time-complexity><complexity-classes>', 'LastEditorUserId': '2152', 'LastActivityDate': '2013-03-04T17:31:28.363', 'CommentCount': '2', 'AcceptedAnswerId': '10270', 'CreationDate': '2013-03-04T12:32:28.090', 'Id': '10257''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I need to disprove that a <code>PARITY</code> gate can be simulated using a <strong>single</strong> <code>MAJORITY</code> gate, or even a <code>THRESHOLD</code> gate. How do I go about doing this? Some ideas as to how to go about contradiction or otherwise would be helpful.</p>\n\n<p>One possible argument would be monotonicity of <code>MAJORITY</code> and <code>THRESHOLD</code> while <code>PARITY</code> is non-monotone (Page 134 of <a href="http://www.igi.tugraz.at/psfiles/47.pdf" rel="nofollow">this paper</a>). But, I do not find this sufficiently convincing.</p>\n', 'ViewCount': '70', 'Title': 'PARITY using depth one TC0 circuit', 'LastEditorUserId': '2935', 'LastActivityDate': '2013-03-04T15:12:11.170', 'LastEditDate': '2013-03-04T15:12:11.170', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2935', 'Tags': '<complexity-theory><complexity-classes><circuits>', 'CreationDate': '2013-03-04T14:57:01.100', 'Id': '10261''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If $L$ is a binary language ($\\Sigma = (0, 1)^*$) and $\\overline{L}$ is the complement of $L$, the set of binary strings not in $L$.</p>\n\n<p>How can I show that, if $L$ is in the complexity class $P$, then so is $\\overline{L}$?</p>\n', 'ViewCount': '84', 'Title': 'Show complement of language in same complexity class?', 'LastActivityDate': '2013-03-04T16:51:16.363', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10268', 'Score': '0', 'OwnerDisplayName': 'Calum Murray', 'PostTypeId': '1', 'OwnerUserId': '7140', 'Tags': '<complexity-classes><formal-languages>', 'CreationDate': '2013-03-04T12:00:27.847', 'Id': '10265''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I want to prove that $E \\subsetneq EXP$ and i would like to do so using the Time Hierarchy Theorem </p>\n\n<p>I need to choose $f(n)$, i think $2^{cn}$ is a good choice, so here is my Proof:</p>\n\n<ul>\n<li>$E\\subseteq TIME(2^{cn})$</li>\n<li>$TIME(2^{cn}) \\subsetneq TIME(n^2 \\cdot (2^{cn})^2)$ Time Hierarchy Theorem</li>\n<li>$E \\subsetneq EXP$</li>\n</ul>\n\n<p>Is this correct ?</p>\n\n<hr>\n\n<p>I have done something similar with $P\\subsetneq EXP$: <br> <strong>PROOF IDEA</strong>:</p>\n\n<ul>\n<li>$P\\subseteq TIME(2^n)$</li>\n<li>$TIME(2^n)\\subsetneq TIME(n^2\\cdot (2^n)^2) \\ \\text{Time Hierarchy Theorem}$</li>\n<li>$TIME(n^2\\cdot (2^n)^2)\\subseteq EXP$</li>\n<li>$P\\subsetneq EXP$</li>\n</ul>\n\n<hr>\n\n<blockquote>\n  <p><strong>Complexity class E:</strong> $E=\\bigcup_{c\\ge 0}TIME(2^{cn})$ <br>\n  <strong>Complexity Class EXPTIME:</strong> $EXP=\\bigcup_{c\\ge 0}TIME(2^{n^c})$ <br>\n  <strong>Time Hierarchy Theorem:</strong> $TIME(f(n)) \\subsetneq TIME(n\xb2\\cdot (fn)\xb2)$</p>\n</blockquote>\n\n<p>The <strong><em>Time Hierarchy Theorem</em></strong> shows that allowing Turing Machines more computation time strictly increases the class of languages that they can decide. Recall that a function $f : N \u2192 N$ is a time-constructible function if there is a Turing machine that, given the input $1^n$ , writes down $1^{f(n)}$ on its\ntape in $O(f (n))$ time. </p>\n', 'ViewCount': '115', 'Title': 'How to Prove E $\\subsetneq$ EXP?', 'LastEditorUserId': '6672', 'LastActivityDate': '2013-03-17T13:20:00.520', 'LastEditDate': '2013-03-16T16:16:54.643', 'AnswerCount': '2', 'CommentCount': '10', 'AcceptedAnswerId': '10560', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6672', 'Tags': '<complexity-theory><time-complexity><complexity-classes>', 'CreationDate': '2013-03-16T14:04:12.593', 'Id': '10551''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '357', 'Title': 'Do any decision problems exist outside NP and NP-Hard?', 'LastEditDate': '2013-04-04T07:16:45.770', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7572', 'FavoriteCount': '1', 'Body': '<p><a href="http://cs.stackexchange.com/questions/9063/np-hard-that-is-not-np-complete-and-not-undecidable">This question</a> asks about NP-hard problems that are not NP-complete. I\'m wondering if there exist any decision problems that are neither NP <em>nor</em> NP-hard.</p>\n\n<p>In order to be in NP, problems have to have a verifier that runs in polynomial time on a deterministic Turing machine. Obviously, all problems in P meet that criteria, but what about the problems with sub-exponential complexity? They do not belong to P and it\'s not obvious to me that they all have efficient deciders. And they certainly don\'t qualify for NP-complete.</p>\n\n<p>I\'m willing to believe that all decision problems are either NP or NP-hard or both, but nobody has actually <em>said</em> that (that I can find). I\'m also willing to believe that such problems do exist, even if they are very contrived. Maybe someone more knowledgeable can put this issue to rest for me. Thanks.</p>\n\n<p><strong>Edit</strong></p>\n\n<p>I abused the term \'subexponential\' in my question. In my mind it meant some problem with a complexity between exponential and polynomial like L-notation in <a href="http://en.wikipedia.org/wiki/Big_O_notation#Orders_of_common_functions" rel="nofollow">this table</a>. See the links in Raphael\'s answer for more details.</p>\n', 'Tags': '<complexity-theory><np-complete><np-hard><decision-problem><complexity-classes>', 'LastEditorUserId': '7572', 'LastActivityDate': '2013-04-04T13:33:02.737', 'CommentCount': '4', 'AcceptedAnswerId': '11012', 'CreationDate': '2013-04-04T04:53:18.070', 'Id': '11009''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '115', 'Title': 'Why does a polynomial-time language have a polynomial-sized circuit?', 'LastEditDate': '2013-04-08T14:41:49.757', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'John Smith', 'PostTypeId': '1', 'OwnerUserId': '4631', 'Body': '<p>I wish to understand why P is a subset of PSCPACE, that is why a polynomial-time langauge does have a polynomial-sized circuit. I read many proofs like <a href="http://www.stanford.edu/~rrwill/week3.pdf" rel="nofollow">this one here on page 2-3</a>, but all the proofs use the same technique used in the Cook-Levin theorem to convert the computation of M on an n-bit input x to a polynomial sized circuit. </p>\n\n<p>What I don\'t understand is that the resulting circuit is dependent on the input x, because what is being converted into a circuit is the computation of M on the specific input x. By definition of PSIZE, the same circuit must work for all the inputs in a fixed length, and thus is not dependent on one specific input. </p>\n\n<p>So how is the process of creating a poly-sized circuit family for a poly-time deterministic Turing machine works exactly?</p>\n', 'Tags': '<complexity-theory><time-complexity><space-complexity><complexity-classes><polynomial-time>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:41:49.757', 'CommentCount': '1', 'AcceptedAnswerId': '11121', 'CreationDate': '2013-04-07T21:22:54.587', 'Id': '11117''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I\'m a bit confused about the definition of BPP. The way BPP is defined in typical text books (Arora/Barak for example) is that if M(x) is a Probabilistic Turing Machine (PTM) that recognizes a language $L(x)$, then $Pr[M(x)=L(x)]&gt; 2/3$. My question is, what is the probability taken over? Arora/Barak remark (<a href="http://www.cs.princeton.edu/theory/complexity/bppchap.pdf" rel="nofollow">7.2</a>) that the probability is taken over internal coin tosses of $M(x)$, i.e., fix a value of $x$, and run all possible $2^{T(|x|)}$ experiments of internal coin tosses, and compute the majority of accept state. But if this is true, then Amplification theorem cannot hold because by definition if the probability is computed by executing all $2^{T(|x|)}$ possible coin-flips, then no matter how many times I run the algorithm, the probability is not going to change. (For example, if I have a bag with 2 red balls and 1 blue ball, then no matter how many times I pick a ball from the bag (and return it), the probability of picking a red ball is going to remain 2/3.)</p>\n\n<p>Basically, a PTM is a random process in two variables: The input string $x \\in \\{0,1\\}^*$ and random coin tosses $ r \\in \\{0,1\\}^{T(|x|)}$. For the amplification theorem to hold, I think one needs to fix a value of $r$ and run the machine on all values of $x$, and compute $Pr[M(x) = L(x)]$. Then for a fixed $x$, running $M(x)$ multiple times will have amplification effect, but if the probability is computed over internal coin tosses, then the Amplification theorem cannot hold.</p>\n\n<p>What am I misunderstanding here?</p>\n', 'ViewCount': '94', 'Title': 'Accurate definition of BPP', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:39:16.167', 'LastEditDate': '2013-04-08T14:39:16.167', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'MachPortMassenger', 'PostTypeId': '1', 'Tags': '<complexity-theory><terminology><complexity-classes><randomness>', 'CreationDate': '2013-04-07T03:51:38.153', 'FavoriteCount': '1', 'Id': '11119''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>When Savitch\'s famous theorem is stated, one often sees the requirement that $S(n)$ be space constructible (interestingly, it is omitted in Wikipedia). My simple question is: Why do we need this? I understand the requirement for $S(n)$ being in $\\Omega(\\log n)$, which is clear from the proof. But no proof I have seen so far explicitly uses that $S(n)$ is space constructable.</p>\n\n<p>My explanation: in order to call the procedure REACH (or PATH or whatever you like to call it), the last parameter needs to be "spelled out", and in order not to leave our space bounds of S(n) for one call, we must not need more than $S(n)$ space to write it down. </p>\n', 'ViewCount': '106', 'Title': "Why is one often requiring space constructibility in Savitch's theorem?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T06:54:59.833', 'LastEditDate': '2013-04-10T13:33:01.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11217', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<complexity-theory><space-complexity><complexity-classes><nondeterminism>', 'CreationDate': '2013-04-09T18:45:00.597', 'Id': '11168''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '135', 'Title': 'How is a witness found in a proof of $\\mathsf{NP} \\subseteq \\mathsf{P}/\\log \\implies \\mathsf{P} = \\mathsf{NP}$?', 'LastEditDate': '2013-04-11T20:23:08.153', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Caleb', 'PostTypeId': '1', 'OwnerUserId': '1765', 'Body': '<p>I\'m having a hard time understanding the actual proof of this proposition:</p>\n\n<p>$\\qquad \\mathsf{NP} \\subseteq \\mathsf{P}/\\log \\implies \\mathsf{P} = \\mathsf{NP}$</p>\n\n<p>The sketch of the proof is on slides 6-8 of <a href="http://www.cs.uiuc.edu/class/sp08/cs579/slides/CC-S08-Lect10.pdf" rel="nofollow">this PDF</a>.</p>\n\n<p>So I let $L \\in \\mathsf{NP}$. That means that there\'s a deterministic polynomial-time TM $M^1_L$ s.t. $x \\in L \\iff \\exists w. M^1_L(x,w) = 1$. I now need to construct a deterministic poly-time TM $M^2_L$ s.t. $x \\in L \\iff M^2_L(x) = 1$.</p>\n\n<p>Looking at the proof in the slides above, I realize that given $x\\in\\{0,1\\}^n$, $M^2_L$ needs to somehow find a witness $w$ for $x$ and then simply return whatever $M^1_L(x,w)$ does. But how do I find that witness?</p>\n', 'Tags': '<complexity-classes><time-complexity>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-12T08:35:31.197', 'CommentCount': '5', 'AcceptedAnswerId': '11253', 'CreationDate': '2013-04-07T23:07:59.247', 'Id': '11223''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As I understand, the <a href="http://en.wikipedia.org/wiki/Assignment_problem" rel="nofollow">assignment problem</a> is in P as the Hungarian algorithm can solve it in polynomial time - O(n<sup>3</sup>). I also understand that the assignment problem is an <a href="http://en.wikipedia.org/wiki/Integer_programming" rel="nofollow">integer linear programming</a> problem, but the Wikipedia page states that this is NP-Hard. To me, this implies the assignment problem is in NP-Hard.</p>\n\n<p>But surely the assignment problem can\'t be in both P and NP-Hard, otherwise P would equal NP? Does the Wikipedia page simply mean that the general algorithm for solving all ILP problems is NP-Hard? A few other sources state that ILP is NP-Hard so this is really confusing my understanding of complexity classes in general.</p>\n', 'ViewCount': '1180', 'Title': 'Are all Integer Linear Programming problems NP-Hard?', 'LastActivityDate': '2013-07-22T11:05:12.550', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '11476', 'Score': '2', 'OwnerDisplayName': 'Matt', 'PostTypeId': '1', 'OwnerUserId': '1554', 'Tags': '<complexity-theory><complexity-classes><linear-programming><integer-programming>', 'CreationDate': '2013-04-21T19:27:20.410', 'Id': '11475''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I know that the CVAL problem is P-complete.\nIn the CVAL problem the input is a Boolean circuit together with an input to this circuit, and the answer is the evaluation of the given circuit on the given input.</p>\n\n<p>I wish to know if the problem of evaluating a Boolean formula on a given assignment is also P-complete. From one hand, it seems that a Boolean circuit and a Boolean formula are very similar objects. Also, the proof of that CVAL is P-complete results from the Cook-Levin problem, the same theorem that actually shows that SAT is NP-Complete, so I don't see a reason why this problem won't be P-Complete.\nFrom the other hand, it seems pretty easy to evaluate a Boolean formula in logarithmic space, so if this problem is indeed P-complete I think it would imply L = P which is unknown. </p>\n\n<p>So I think I'm missing something.. any ideas people? </p>\n", 'ViewCount': '89', 'Title': 'Is the problem of evaluating a boolean formula on a given assignment P-complete?', 'LastActivityDate': '2013-05-01T17:23:20.530', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11705', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4631', 'Tags': '<complexity-theory><time-complexity><complexity-classes>', 'CreationDate': '2013-05-01T15:23:31.873', 'Id': '11697''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>For every integer $t$, is there a problem whose solutions can be verified in $O(n^{s})$ time but cannot be found in $O(n^{st})$ time?</p>\n\n<p>By verifying, I mean that given a candidate solution $y$, we can judge whether $y$ is correct or not in time $O(n^s)$.</p>\n', 'ViewCount': '401', 'Title': 'A Problem on Time Complexity of Algorithms', 'LastEditorUserId': '72', 'LastActivityDate': '2013-05-09T22:53:07.350', 'LastEditDate': '2013-05-09T14:35:06.697', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8074', 'Tags': '<complexity-theory><time-complexity><asymptotics><complexity-classes><lower-bounds>', 'CreationDate': '2013-05-07T01:48:11.327', 'Id': '11844''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have a question about the structure of the complexity class $APX$. Obviously, unless $P=NP$, no problem in the class $PTAS$ can be $APX$-complete (under the AP-reduction). However, what about the rest of problems in $APX$? Are there any problems known that are in $APX$, do not have a $PTAS$ (unless $P=NP$) and at the same time are provably not $APX$-complete (unless $P=NP$)?</p>\n\n<p>For the class $NP$, Ladner's Theorem guarantees the existence of problems in $NP - P$ that are not $NP$-complete (unless $P=NP$) - the so-called $NP$-intermediate problems. I am curious if any similar result has been proved for $APX - PTAS$ with respect to approximation preserving reductions.</p>\n\n<p>It is possible that the answer to this question is trivial - to be honest, the only $APX$-complete problem I know is MAX-3-SAT. However, I wonder how hard it is with respect to other problems in $APX - PTAS$.</p>\n", 'ViewCount': '92', 'Title': 'Are there any problems in $APX - PTAS$ that are not $APX$-complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-19T15:01:57.763', 'LastEditDate': '2013-05-19T15:01:57.763', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12132', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2091', 'Tags': '<complexity-theory><approximation><complexity-classes>', 'CreationDate': '2013-05-18T13:53:24.377', 'Id': '12112''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '44', 'Title': 'how to prove this unsolvable problem about halting problem (turing machine)', 'LastEditDate': '2013-05-19T06:11:29.767', 'AnswerCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8244', 'FavoriteCount': '1', 'Body': u'<p>Show that the problem of deciding, for a given TM M, whether M halts for all inputs within n^2(namely n square ) steps(n is the length of the input) is unsolvable. You can use the fact without proof that the \u03b5-halting problem(that asks if a given TM halts for input \u03b5,namely, for the empty string) is unsolvable. (Hint: Use the input just to count the number of steps and basically simulate the behavior against the \u03b5 input for m steps. m may be any (easy to realize) number if it is at most n^2 and grows unlimitedly as n.).                             My answer is: Assume TM M decides whether halt or not within n^2 steps. TM S decides that when \u03b5 is a input halting or not.        use as a input of S, M1 is a TM. make a TM S:1.Use   on TM M.        2. If reject,then S rejects.        3.if accept, execute \u03b5 on M until halting. Who can tell me is this right or wrong? If it is wrong, then how to correct?</p>\n', 'ClosedDate': '2013-05-18T21:58:12.343', 'Tags': '<algorithms><complexity-classes><correctness-proof>', 'LastEditorUserId': '8244', 'LastActivityDate': '2013-05-19T06:11:29.767', 'CommentCount': '3', 'CreationDate': '2013-05-18T15:19:56.223', 'Id': '12116''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am new in complexity theory and this question is a part of a homework that I have and I am stuck on it.</p>\n\n<blockquote>\n  <p>Let ${\\sf coNP}$ be the class of languages $\\{\\overline{L}: L \\in {\\sf NP} \\}$.</p>\n  \n  <p>Show that if ${\\sf NP} \\neq {\\sf coNP}$, then ${\\sf P}\\neq  {\\sf NP}$.</p>\n</blockquote>\n', 'ViewCount': '729', 'Title': 'Proving that if coNP $\\neq$ NP then P $\\neq$ NP', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-05-21T18:53:59.637', 'LastEditDate': '2013-05-21T18:53:59.637', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'user16111', 'PostTypeId': '1', 'Tags': '<complexity-theory><complexity-classes><np><p-vs-np>', 'CreationDate': '2013-05-21T09:05:11.783', 'Id': '12195''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It is clear that any language in $\\mathsf{EXP}^{\\mathsf{EXP}}$ can be computed in <a href="https://en.wikipedia.org/wiki/2-EXPTIME" rel="nofollow">$\\mathsf{2EXP} = \\mathsf{DTime}(2^{2^{\\mathsf{poly}(n)}})$</a>.</p>\n\n<p>My question is whether the converse is true: is $\\mathsf{2EXP} \\subseteq \\mathsf{EXP}^{\\mathsf{EXP}}$?</p>\n', 'ViewCount': '72', 'Title': '$\\mathsf{2EXP} = \\mathsf{EXP}^{\\mathsf{EXP}}$?', 'LastActivityDate': '2013-05-24T18:11:41.933', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'user16109', 'PostTypeId': '1', 'Tags': '<complexity-theory><complexity-classes>', 'CreationDate': '2013-05-21T05:35:01.390', 'FavoriteCount': '1', 'Id': '12248''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '100', 'Title': 'Assuming NP $\\neq$ P, are there NPI languages only P languages reduce to?', 'LastEditDate': '2013-05-28T07:01:25.540', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7934', 'FavoriteCount': '1', 'Body': '<p>let $L_c$ be the class of all languages that have a polynomial reduction to some language L, for example if $L=SAT$ then $SAT_c=NP$.</p>\n\n<p>Assuming know that $NP\\neq P$ we know that there exist languages that are not NP-hard and not in P, i.e. those in NPI. My question is there a language L in NPI such that $L_c \\setminus \\{L\\}=P$?   </p>\n', 'Tags': '<complexity-theory><complexity-classes>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-28T07:01:25.540', 'CommentCount': '2', 'AcceptedAnswerId': '12307', 'CreationDate': '2013-05-27T03:59:29.337', 'Id': '12300''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>So, there are multiple possible definitions of "np-complete", two of which being:  </p>\n\n<ol>\n<li><p>A decision problem $L$ is np-complete if and only if:  $L \\in \\text{NP}$  and  $\\forall L\' \\in \\text{NP}: L\' \\preceq_{p} L$</p></li>\n<li><p>A decision problem $L$ is np-complete if and only if:  $L \\in \\text{NP}$  and  there exists a np-complete problem $L \\in \\text{NP}$ such that: $L\' \\preceq_{p} L$</p></li>\n</ol>\n\n<p>My question is, why are those two definitions equivalent, or put differently, (why) is np-complete an equivalence class? </p>\n\n<p>If it is an equivalence class I can understand equivalence of the above two definitions, but I fail to see why this is the case, since the (one-to-many) poly-time reduction $\\preceq_{p}$ is not symmetric... :-/</p>\n', 'ViewCount': '90', 'Title': 'Is np-complete an equivalence class?', 'LastActivityDate': '2013-05-28T23:29:25.010', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12347', 'Score': '3', 'OwnerDisplayName': 'user2429385', 'PostTypeId': '1', 'OwnerUserId': '8426', 'Tags': '<complexity-theory><complexity-classes><reductions><np><np-complete>', 'CreationDate': '2013-05-28T17:09:44.347', 'Id': '12346''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to find complexity class of finding winning strategy for first player in following game:</p>\n\n<p>Intance of 'Stones' game is:</p>\n\n<ul>\n<li>finite set $X$</li>\n<li>relation $R \\subseteq X^3$</li>\n<li>set $Y \\subseteq X$ and node $f \\in X$</li>\n</ul>\n\n<p>At the beggining we place stone in every element of $Y$. \nEvery player in his turn can move stone from $x$ to $z$ iff. $\\exists y.R(x, y, z) \\wedge y\\ has\\ stone\\ placed\\ in\\ it$.\nPlayer who places stone in $f$ wins.</p>\n\n<p>I think it's $PSPACE-complete$, but I was trying to proove this for some time, and I run out of ideas.</p>\n\n<p>I won't lie, it's homework assignment for my complexity class. Any help will be highly appreciated.</p>\n", 'ViewCount': '54', 'Title': "'Stones' game complexity", 'LastActivityDate': '2013-06-01T03:24:19.843', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8469', 'Tags': '<complexity-theory><space-complexity><complexity-classes><game-theory>', 'CreationDate': '2013-06-01T03:24:19.843', 'FavoriteCount': '1', 'Id': '12407''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>What does $A^B$ mean where A and B are complexity classes?</p>\n\n<p>The "Polynomial Hierarchy" page says:</p>\n\n<p>$A^B$ is the set of decision problems solvable by a Turing machine in class A augmented by an oracle for some complete problem in class B</p>\n\n<p>In that case what is a Turing machine in class A?</p>\n\n<p>(besides just a machine of some sort that can solve problems in A, because that doesn\'t give any insight as to what it means to augment such a machine with an oracle)</p>\n\n<p>The motivation for this question was: <a href="http://cs.stackexchange.com/q/12466/6716">What is a Turing Machine in class coNP</a>. </p>\n', 'ViewCount': '70', 'Title': 'What does $A^B$ mean?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T13:37:08.837', 'LastEditDate': '2013-06-06T13:37:08.837', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8526', 'Tags': '<turing-machines><complexity-classes>', 'CreationDate': '2013-06-06T03:04:41.157', 'Id': '12480''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>does $BPP\\subseteq P^{NP}$ ? it seems reasonable but I don't know if there is a proof of this!could any one post a proof or any material that discusses the statement or something that look like this .  </p>\n", 'ViewCount': '54', 'Title': 'BPP upper bound', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-17T05:48:37.233', 'LastEditDate': '2013-07-17T05:48:37.233', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13301', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8570', 'Tags': '<complexity-theory><complexity-classes><randomized-algorithms><oracle-machines>', 'CreationDate': '2013-07-16T12:50:19.600', 'Id': '13300''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am trying to solve the question 6.12 in Arora-Barak (Computational Complexity: A modern approach). The question asks you to show that the\n$\\mathsf{PATH}$ problem (decide whether a graph $G$ has a path from a given node $s$ to another given node $t$) which is complete for $\\mathbf{NL}$ is also contained in $\\mathbf{NC}$ (this is easy). The question then also makes a remark that this implies that $\\mathbf{NL} \\subseteq \\mathbf{NC}$ which is not obvious to me.</p>\n\n<p>I think in order to show this, one has to show that $\\mathbf{NC}$ is closed under logspace reductions, i.e</p>\n\n<p>$$(1): B \\in \\mathbf{NC} \\hbox{ and } A \\le_l B \\Longrightarrow A \\in \\mathbf{NC}$$ </p>\n\n<p>where $\\le_l$ is the logspace reduction defined as</p>\n\n<p>$$A \\le_l B :\\Longleftrightarrow (\\exists M \\hbox{ TM}, \\forall x)[x \\in A \\Longleftrightarrow M(x) \\in B]$$</p>\n\n<p>($M$ is a TM which runs in logarithmic space).</p>\n\n<p>I would appreciate if someone could give a tip for proving the statement $(1)$.</p>\n', 'ViewCount': '105', 'Title': '$\\mathbf{NC}$ is closed under logspace reductions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-22T15:25:58.423', 'LastEditDate': '2013-07-22T14:17:00.753', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13390', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9293', 'Tags': '<complexity-theory><reductions><closure-properties><complexity-classes><parallel-computing>', 'CreationDate': '2013-07-22T12:55:57.660', 'Id': '13387''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Are there classes of problems that cannot be solved by an oracle machine? If so, are there specific problem examples of that class of problems?</p>\n\n<p>Even the Omega number, at least the first N digits, could be computed as the Oracle could just return TRUE or FALSE for each {0,1}-digits... </p>\n', 'ViewCount': '35', 'ClosedDate': '2013-08-04T23:28:03.570', 'Title': 'Problems unsolvable by an oracle machine?', 'LastActivityDate': '2013-08-04T21:59:11.873', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'OwnerDisplayName': 'Phil', 'PostTypeId': '1', 'Tags': '<complexity-classes><computability>', 'CreationDate': '2013-08-04T13:09:27.020', 'FavoriteCount': '0', 'Id': '13601''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '176', 'Title': 'Complexity of deciding if a formula has exactly 1 satisfying assignment', 'LastEditDate': '2013-08-23T23:03:31.500', 'AnswerCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '667', 'FavoriteCount': '4', 'Body': '<p>The decision problem</p>\n\n<blockquote>\n  <p>Given a Boolean formula $\\phi$, does $\\phi$ have exactly one satisfying assignment?</p>\n</blockquote>\n\n<p>can be seen to be in $\\Delta_2$, $\\mathsf{UP}$-hard and $\\mathsf{coNP}$-hard. Is anything more known about its complexity?</p>\n', 'Tags': '<complexity-theory><complexity-classes><satisfiability>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-25T18:38:59.147', 'CommentCount': '0', 'AcceptedAnswerId': '13888', 'CreationDate': '2013-08-23T13:09:52.587', 'Id': '13887''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It seems that factoring a number known to be composite is in its own interesting little complexity class, e.g. polynomial time using quantum computing even though no one has proved $\\mathsf{P} = \\mathsf{NP}$ for quantum computing. </p>\n\n<p>Are there interesting, non-obvious examples of problems with polynomial-time verifiability for solutions, which have been shown to be polynomial-time equivalent to factoring a composite number into primes, under the classical non-quantum computational model?   </p>\n', 'ViewCount': '83', 'Title': 'Are there problems that are polynomial-time equivalent to factoring composites?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-17T08:13:13.480', 'LastEditDate': '2013-09-17T08:13:13.480', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14368', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9584', 'Tags': '<complexity-theory><complexity-classes><factoring>', 'CreationDate': '2013-09-16T17:55:59.850', 'Id': '14359''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In Chap 34.3 <em>NP-completeness and reducibility</em> of the  book, <em>Introduction to Algorithm(3rd Edition)</em>, the author states(the original text):</p>\n\n<p>We call the function <em>f</em> the <strong><em>reduction function</em></strong>, and a polynomial-time algorithm <em>F</em> that computes <em>f</em> is a <strong><em>reduction algorithm</em></strong>.</p>\n\n<p>In my mind, function should be a machine dependent implementation(a set of instructions) of the algorithm. Why does he say <em>algorithm</em> computes <em>function</em>?</p>\n', 'ViewCount': '66', 'Title': 'NP-COMPLETE:Why say "reduction algorithm computes reduction function"?', 'LastActivityDate': '2013-09-27T07:31:37.107', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14637', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<np-complete><complexity-classes>', 'CreationDate': '2013-09-27T07:05:01.130', 'Id': '14636''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>To continue this <a href="http://cs.stackexchange.com/questions/16483/complexity-of-deciding-the-satisfiability-of-a-quasi-monotone-cnf-formula">post</a>, let us define the Monotone$(+, 2^-)$-SAT problem: </p>\n\n<p>Given a monotone CNF formula $F^+$, where each variable appears exactly once (as a positive literal), and a monotone 2-CNF formula $F_2^-$ defined on the same variables as $F^+$, where all variables are negated. Is $F^+ \\land F_2^-$ satisfiable ?</p>\n\n<p>Is this problem NP-complete?</p>\n', 'ViewCount': '128', 'Title': 'Complexity of Monotone (+,2) SAT problem?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-05T16:22:04.540', 'LastEditDate': '2013-11-05T16:22:04.540', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '10228', 'Tags': '<complexity-theory><np-complete><decision-problem><complexity-classes>', 'CreationDate': '2013-11-01T22:56:57.180', 'FavoriteCount': '1', 'Id': '16634''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>It is well known that any CNF formula can be transform in polynomial time into a 3-CNF formula  by using new variables (<a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability" rel="nofollow">see here</a>). If using new variables is not allowed, it is not always possible (take for instance the single clause formula : $(x_1 \\lor x_2 \\lor x_3 \\lor x_4)$). </p>\n\n<p>Let define the (SAT to 3-SAT) problem : Given $F$, a CNF formula. Is it possible to transform $F$ into an equivalent 3-CNF defined <em>on the same variables</em> as $F$ ? - where "equivalent" means with the same set of models.</p>\n\n<p>What is the complexity of this problem ?</p>\n\n<p><strong>Edit</strong> : It has been shown <a href="http://cstheory.stackexchange.com/questions/19821/transform-a-cnf-into-an-equivalent-3-cnf-defined-on-the-same-variables">on cstheory</a> that the problem is co-NP hard.</p>\n', 'ViewCount': '184', 'Title': 'Complexity of (SAT to 3-SAT) Problem?', 'LastEditorUserId': '10228', 'LastActivityDate': '2013-12-24T00:47:22.790', 'LastEditDate': '2013-12-23T22:53:00.603', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '10228', 'Tags': '<complexity-theory><satisfiability><decision-problem><complexity-classes>', 'CreationDate': '2013-11-05T15:46:40.127', 'FavoriteCount': '1', 'Id': '16741''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Are there problems that are in NP class but not in #P class? \nAccording to Wiki definition: </p>\n\n<blockquote>\n  <p>More formally, #P is the class of function problems of the form "compute \u0192(x)," where \u0192 is the number of accepting paths of a nondeterministic Turing machine running in polynomial time"</p>\n</blockquote>\n\n<p>So I am thinking, if you already have a poly nondeterministic Turing machine that can accept correct paths, then you can just use this to count in poly time.\nIs there something I am missing here?</p>\n', 'ViewCount': '118', 'Title': 'Problems in NP but not in #P', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-17T18:16:09.373', 'LastEditDate': '2013-11-15T18:30:47.287', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11383', 'Tags': '<complexity-theory><complexity-classes><np>', 'CreationDate': '2013-11-14T17:17:08.513', 'Id': '18026''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Show that if 3SAT is polynomial-time reducible to $complement of 3SAT$ then $PH = NP$.</p>\n\n<p>Above problem is Exercise problem from Arora and Barak,</p>\n\n<p>i don't know how to solve this problem,if anybody knows how to solve please post the solution </p>\n\n<p>Thanks for help!!</p>\n", 'ViewCount': '71', 'ClosedDate': '2013-11-16T15:29:29.187', 'Title': 'Proving $PH = NP$', 'LastActivityDate': '2013-11-15T13:09:15.560', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<complexity-theory><np-complete><complexity-classes><nondeterminism><polynomial-time>', 'CreationDate': '2013-11-15T09:28:14.230', 'Id': '18043''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider a certicate for 3SAT that lists an assignment for each occurrence of a variable in the order\nof appearence,e.g. 100000 for ($x\\bigvee$$y\\bigvee$z)$\\bigwedge$($\\neg(w)$$\\bigvee$$y\\bigvee$z). This certicate is of polynomial length and can\nbe read once to check the satisability of the given formula. Does this prove that SAT is in NL?</p>\n', 'ViewCount': '42', 'Title': 'Is SAT is in NL?( under certain conditions)', 'LastEditorUserId': '10145', 'LastActivityDate': '2013-11-16T06:45:03.890', 'LastEditDate': '2013-11-16T02:49:02.610', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<complexity-theory><np-complete><complexity-classes>', 'CreationDate': '2013-11-16T02:34:40.960', 'Id': '18061''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>On one hand, <a href="http://en.wikipedia.org/wiki/Horn-satisfiability" rel="nofollow">Horn-SAT</a> is known to be tractable in linear time - where Horn-SAT is the problem of deciding whether a given set of propositional Horn clauses (with at most one positive literal) is satisfiable or not.\nOn the other hand, Double-SAT is NP-complete (see this post : <a href="http://cs.stackexchange.com/questions/6371/proving-double-sat-is-np-complete">Proving Double-SAT is NP-complete</a>) - where Double-SAT is the problem of deciding whether a given set of propositionnal clauses has at least two models.</p>\n\n<p>Let Double-Horn-SAT be the problem of deciding whether a given set of propositional Horn clauses has at least two models.</p>\n\n<p>What is the complexity of Double-Horn-SAT ?</p>\n', 'ViewCount': '41', 'Title': 'Complexity of Double-Horn-SAT?', 'LastActivityDate': '2013-12-03T22:13:38.727', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '18585', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10228', 'Tags': '<complexity-theory><np-complete><satisfiability><complexity-classes>', 'CreationDate': '2013-12-03T20:28:43.277', 'Id': '18581''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I cannot conceive of any problem that can be solved in exponential time, but cannot be checked in polynomial time. </p>\n', 'ViewCount': '135', 'Title': 'Are there any problems in complexity class EXP that are not in NP?', 'LastActivityDate': '2013-12-21T18:59:37.437', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12289', 'Tags': '<complexity-classes>', 'CreationDate': '2013-12-21T18:55:07.113', 'FavoriteCount': '1', 'Id': '19176''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '96', 'Title': 'Is DSPACE properly contained in NSPACE?', 'LastEditDate': '2014-01-17T22:20:45.957', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '12901', 'FavoriteCount': '0', 'Body': '<p>It may be a dumb question, but is $\\mathsf{DSPACE}(f(n)) \\subset \\mathsf{NSPACE}(f(n))$ or is $\\mathsf{DSPACE}(f(n)) \\subseteq \\mathsf{NSPACE}(f(n))$?  In other words, is the containment relation proper or not?  Wikipedia says the first one, while the ComplexityZoo says the other one.</p>\n', 'Tags': '<complexity-theory><complexity-classes><space-complexity>', 'LastEditorUserId': '755', 'LastActivityDate': '2014-01-18T14:14:48.173', 'CommentCount': '1', 'AcceptedAnswerId': '19797', 'CreationDate': '2014-01-17T20:15:15.043', 'Id': '19794''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>As in title. Does $NSPACE(n) \\subseteq DTIME(2^n)$ ?</p>\n', 'ViewCount': '49', 'ClosedDate': '2014-01-21T12:59:56.790', 'Title': 'Does $DTIME(2^n)$ contain $NSPACE(n)$ ?', 'LastActivityDate': '2014-01-21T11:10:30.410', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12901', 'Tags': '<complexity-theory><complexity-classes>', 'CreationDate': '2014-01-21T10:04:02.517', 'Id': '19865''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>And if so would this grant us any insight into the relations between P, NP, and EXPTIME?</p>\n', 'ViewCount': '37', 'Title': 'Is it possible for an NP problem to be reduced to an EXPTIME problem in polynomial time?', 'LastActivityDate': '2014-02-28T23:24:48.163', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15148', 'Tags': '<complexity-classes>', 'CreationDate': '2014-02-28T22:50:44.337', 'Id': '22142''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Most books assume that this is obvious, but I can't see how each $\\Sigma_k=NP^{\\Sigma_{k-1}}$ level in the polynomial hierarchy is closed under polynomial-time reductions. Is there something that I'm missing?</p>\n", 'ViewCount': '10', 'ClosedDate': '2014-03-07T18:51:58.633', 'Title': 'Show polynomial hierarchy levels closed under reduction', 'LastActivityDate': '2014-03-07T09:25:11.540', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15383', 'Tags': '<complexity-theory><time-complexity><reductions><complexity-classes>', 'CreationDate': '2014-03-07T09:25:11.540', 'Id': '22369''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Define the complexity class $C$ to be the class of all languages that can be verified by a TM that has:</p>\n\n<ul>\n<li>Input tape: Read only, move in both directions.</li>\n<li>Witness tape: Read only, move only in one direction.</li>\n<li>Work tape: Read-Write, move in both directions.</li>\n</ul>\n\n<p>The machine itself is deterministic (the guesses are the value of the witness tape). The space complexity is the size of the work tape, and is polynomial. We say the machine\naccepts an input if and only if there exists a setting for the witness tape, with which the\nmachine accepts.</p>\n\n<p>Prove: $C = \\mathrm{PSPACE}$</p>\n\n<p>Well, it's obvious that $\\mathrm{PSPACE} \\subset C$ since any TM $M$ can be converted into a TM $M'$ that simply ignores its witness tape and runs in the same space complexity as $M$.</p>\n\n<p>However, I'm struggling with the other direction. The problem is that the witness can be exponential in the input and I can't see how we can enumerate over all witnesses using only polynomial space.</p>\n\n<p>edit: I had a mistake, the witness tape can only be read in one direction.</p>\n", 'ViewCount': '36', 'Title': 'Polynomial space complexity with exponential size witnesses', 'LastEditorUserId': '7068', 'LastActivityDate': '2014-03-22T18:32:45.640', 'LastEditDate': '2014-03-22T18:32:45.640', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22912', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<complexity-theory><space-complexity><complexity-classes>', 'CreationDate': '2014-03-21T17:49:32.217', 'Id': '22907''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '46', 'Title': u'Assume that SAT \u2208 PSIZE, does it imply that NP = coNP?', 'LastEditDate': '2014-03-24T22:45:55.480', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7068', 'FavoriteCount': '1', 'Body': "<p>Assume that $\\mathrm{SAT} \\in \\mathrm{PSIZE}$, does it imply that $\\mathrm{NP} = \\mathrm{coNP}$ ?</p>\n\n<p>I think that I've managed to show that if $\\mathrm{SAT} \\in \\mathrm{PSIZE}$, then both $\\mathrm{NP}$ and $\\mathrm{coNP}$ are contained in $\\mathrm{PSIZE}$, but I can't see how does help me. Any ideas ?</p>\n", 'Tags': '<complexity-theory><time-complexity><complexity-classes><circuits>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T22:45:55.480', 'CommentCount': '8', 'AcceptedAnswerId': '23019', 'CreationDate': '2014-03-24T21:11:49.613', 'Id': '23018''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider, for example, the definition for $\\Sigma_2^p$ complexity class.</p>\n\n<p>$$ x \\in L \\Leftrightarrow \\exists u_1 \\forall u_2 \\;M(x, u_1, u_2) = 1, $$</p>\n\n<p>where $u_1, u_2 \\in \\{0,1\\}^{p(|x|)}$, for some polynomial $p$. Here, $M$ must be polynomial time. But polynomial in the size of what exactly? For example, if we choose (guess) some $u_1$, do I consider it to be fixed size when talking about time complexity of $M$? More precisely, should $M$ be polynomial only in the size of $x$? </p>\n\n<p>An example. Consider the problem whether, given a graph $A$, there exists a graph\n$B$ such that $B$ is subgraph isomorphic to $A$.</p>\n\n<p>$$A \\in L \\Leftrightarrow \\exists B \\; \\text{SubGraphIsomorphic}(A, B) = 1 $$</p>\n\n<p>Now, subgraph isomorphism is NP-complete. If $B$ is fixed, then there is a TM\nthat implements $\\text{SubGraphIsomorphic}$ in deterministic polynomial time. If $B$ is not fixed, then I cannot claim such a thing unless I know $\\sf P=NP$. Is this problem in $\\Sigma_{1}^{p}$, i.e. $\\sf NP$? (Ok, this problem has trivial solutions, but I hope it helps to pinpoint my confusion.)</p>\n\n<p>My confusion generalizes for all $\\Sigma_{i}^p$. </p>\n', 'ViewCount': '35', 'Title': 'Polynomial Hierarchy --- polynomial time TM', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-29T20:09:59.553', 'LastEditDate': '2014-03-29T20:09:59.553', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23207', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<complexity-theory><time-complexity><complexity-classes><polynomial-time>', 'CreationDate': '2014-03-29T01:14:37.587', 'Id': '23204''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>What is the proof of  P \u2286 NP? I cannot happen to find a good explanation for it. I read that the <code>verifier</code> will just ignore the proof and accept any proof if the solution is YES and reject all proofs if the answer is NO. I\'m also unclear about verifier.</p>\n\n<p>Definition of P and NP I follow:</p>\n\n<p>P: a problem \'Q\' is said to be in P if there exists an efficient (polynomial worst-case time) algorithm for solving the problem. E.g.- "is a given natural number \'x\' even?".</p>\n\n<p>NP: a problem \'Q\' is said to be in NP if there exists efficient verifiers (an algorithm for verifying if a given proof is correct).</p>\n', 'ViewCount': '58', 'ClosedDate': '2014-04-02T15:13:50.323', 'Title': u'Proof of P \u2286 NP', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T15:12:09.783', 'LastEditDate': '2014-04-02T15:12:09.783', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16381', 'Tags': '<complexity-theory><decision-problem><complexity-classes>', 'CreationDate': '2014-04-02T13:10:01.710', 'Id': '23340''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Many of us are familiar with the $P$ class. Counting solutions is believed to be a difficult task and that is why we usually end up approximating the number of solutions (we relax the accuracy of the counting). I want to ask, if relaxing the quality of the solutions counted has been addressed as a problem. Is there for example, any algorithms able to answer the question: How many vertex covers there are, with 3 times the cardinality of the minimum vertex cover? Is the problem $P-$ complete?  </p>\n', 'ViewCount': '30', 'Title': 'Counting approximate solutions', 'LastEditorUserId': '2499', 'LastActivityDate': '2014-04-04T04:29:07.460', 'LastEditDate': '2014-04-04T03:04:32.083', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23411', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12201', 'Tags': '<complexity-theory><complexity-classes>', 'CreationDate': '2014-04-04T02:44:13.297', 'Id': '23409''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In my computation book by Sipser, he says that since every language that can be decided in time $o(n \\log n)$ is regular, then that can be used to show $TIME(n \\log (\\log n))\\setminus TIME(n)$ must be the empty set. Can anyone show me why this is?</p>\n\n<p>both $TIME(n\\log(\\log n))$ and $TIME(n)$ are regular. I think that only means we can subtract the two sets and the result will still be regular. I just dont understand how its possible to subtract the collection of $O(n\\log(\\log n))$ time TM decidable languages from the collection of $O(n)$ time TM decidable languages and get the empty set. These two collections are not equal so I feel like there will be something left over</p>\n', 'ViewCount': '100', 'Title': u'Why is TIME(n log (log n)) \\ TIME(n) = \u2205?', 'LastEditorUserId': '31', 'LastActivityDate': '2014-04-13T15:30:31.163', 'LastEditDate': '2014-04-13T15:30:31.163', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23726', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<complexity-theory><regular-languages><time-complexity><complexity-classes>', 'CreationDate': '2014-04-13T01:15:28.793', 'Id': '23721''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to construct a deterministic multi-tape turing machine for the following language in order to show that $L$ is in $DTIME(n)$:</p>\n\n<p>$$L = \\{ www \\mid w \\in \\{a,b\\}^+ \\}$$</p>\n\n<p>I'm not sure how to get started. Any hints would be appreciated.</p>\n", 'ViewCount': '24', 'Title': 'Deterministic Multi-tape Turing Machine construction', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-19T06:59:45.943', 'LastEditDate': '2014-04-19T06:59:45.943', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23929', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10423', 'Tags': '<turing-machines><complexity-classes>', 'CreationDate': '2014-04-19T04:35:44.833', 'Id': '23928''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>My textbook says: "The Boolean hierarchy is contained in the class $P^{NP}\\subseteq\\Sigma^P_2\\cap\\Pi^P_2$." However, it provides neither a proof nor a proof sketch nor some hint. How can I convince myself that the claim is true?</p>\n', 'ViewCount': '55', 'Title': 'Why is the Boolean hierarchy contained in the class $P^{NP}$?', 'LastActivityDate': '2014-04-21T14:15:30.400', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23987', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14654', 'Tags': '<complexity-theory><complexity-classes><oracle-machines>', 'CreationDate': '2014-04-20T19:06:08.477', 'Id': '23955''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>We know that $BPP \\subseteq BQP$ but we have no proof $BPP \\subset BQP$\n(Though we have the proof that BQP $!=$ BPP with an oracle)</p>\n\n<p>Since Simon's problem (as factoring) it's easily solvable by a quantum computer, and in exponential time complexity solvable by a classical computer, that's a hint of the separation between BQP and BPP and therefore this can be a pure NP problem. \nAm I right?</p>\n", 'ViewCount': '26', 'Title': "Is Simon's problem a good NP-intermediate candidate?", 'LastActivityDate': '2014-04-21T14:52:08.960', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23989', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7955', 'Tags': '<complexity-theory><complexity-classes><quantum-computing>', 'CreationDate': '2014-04-21T12:57:28.700', 'Id': '23985''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is it more plausible that $NP\\subseteq TIME[O(n^{\\log n})]$ than $NP\\subseteq P$? I don't see this mentioned much and is there a reason why? If this question doesn't make sense, explain why.</p>\n", 'ViewCount': '52', 'Title': '$NP\\subseteq TIME[O(n^{\\log n})]$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T22:07:30.020', 'LastEditDate': '2014-04-22T22:07:30.020', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '24034', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16999', 'Tags': '<complexity-theory><time-complexity><complexity-classes><np>', 'CreationDate': '2014-04-22T20:20:35.647', 'Id': '24033''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I can't understand what my professor wrote about these inclusions concerning deterministic classes:</p>\n\n<p>$$\nDTIME(f) \\subseteq DSPACE(f) \\subseteq \\sum_{c\\in\\Bbb N}DTIME(2^{c(log+f)})  \n$$</p>\n\n<p>I understood the first inclusion:</p>\n\n<blockquote>\n  <p>The Turing Machine needs to do at least one step in order to check the\n  next cell on tape</p>\n</blockquote>\n\n<p>I didn't get the second one:</p>\n\n<blockquote>\n  <p>The number of configurations of the Turing Machine with fixed space is finite, and the computation must stop within a maximum number of steps equal to these settings, otherwise wewould have a cycle.</p>\n</blockquote>\n\n<p>I don't understand the argument of the summation: why that $2$ and that $c(log+f)$?\nWhy is it written like that?</p>\n", 'ViewCount': '78', 'Title': 'Inclusion of complexity classes (Deterministic Turing Machine)', 'LastActivityDate': '2014-04-28T17:47:37.320', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '24192', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17046', 'Tags': '<turing-machines><time-complexity><space-complexity><complexity-classes>', 'CreationDate': '2014-04-28T15:51:17.557', 'Id': '24185''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Is the class $\\sf NP$ closed under complement or is it unknown? I have looked online, but I couldn't find anything. </p>\n", 'ViewCount': '55', 'Title': 'Is the class NP closed under complement?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-30T17:43:47.400', 'LastEditDate': '2014-04-30T17:17:57.027', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '24265', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Tags': '<complexity-theory><closure-properties><complexity-classes><np>', 'CreationDate': '2014-04-30T16:23:40.070', 'Id': '24261''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>The definition of the complexity class $\\mathsf{NP}$ seems to ensure (as good as possible) that it is computably enumerable. It looks as if the class could be enumerated by enumerating all Turing machines, and for each Turing machine report for each $k\\in\\mathbb{N}$ the language generated by stopping each computation after $n^k$ steps, and reject if the input hasn't been accepted before reaching this step limit.</p>\n\n<p>This only gives a computable enumeration of Turing machines. However, it seems that the corresponding languages will be decidable, because the enumeration includes an explicit time bound for each of its Turing machines. Hence this should give an computable enumeration of $\\mathsf{NP}$.</p>\n\n<blockquote>\n  <p>Question: Is the conclusion from this reasoning correct, i.e. is $\\mathsf{NP}$ computably enumerable? One issue that I have is that even for decidable languages, we can only (computably) decide whether two given languages are different, but not whether they are equal. Hence it seems that we can't avoid to report the same language more than once. The deeper issue here is that being computably enumerable is a property of subsets of the natural numbers, but the complexity class $\\mathsf{NP}$ doesn't seem to correspond to a subset of the natural numbers in any canonical way.</p>\n</blockquote>\n", 'ViewCount': '101', 'Title': 'Is the complexity class NP computably enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-03T00:18:54.527', 'LastEditDate': '2014-05-02T21:46:47.193', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1557', 'Tags': '<computability><complexity-classes><np><enumeration>', 'CreationDate': '2014-05-02T20:51:31.623', 'Id': '24326''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The question is in the title, I suppose. I am studying complexity classes, and I understand that NP-Hard is the set of problems that are at least as hard as the hardest problems in NP. Therefore, it will naturally contain PSPACE problems.</p>\n\n<p>However, I was specifically wondering if there were any PSPACE problems that were not in NP-Hard? (from my understanding, implying that they are <em>easier</em> than the hardest problems in NP).</p>\n', 'ViewCount': '67', 'Title': "Are there any PSPACE problems that don't exist in NP-Hard?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-03T09:36:05.037', 'LastEditDate': '2014-05-03T09:36:05.037', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24338', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17290', 'Tags': '<complexity-theory><np-hard><complexity-classes>', 'CreationDate': '2014-05-03T02:37:37.397', 'Id': '24336''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}