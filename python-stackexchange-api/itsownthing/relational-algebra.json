{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '319', 'Title': "Does the 'difference' operation add expressiveness to a query language that already includes 'join'?", 'LastEditDate': '2012-04-02T15:35:05.827', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '5', 'FavoriteCount': '1', 'Body': '<p>The set difference operator (e.g., <code>EXCEPT</code> in some SQL variants) is one of the many fundamental operators of relational algebra. However, there are some databases that do not support the set difference operator directly, but which support <code>LEFT JOIN</code> (a kind of outer join), and in practice this can be used instead of a set difference operation to achieve the same effect.</p>\n\n<p>Does this mean that the expressive power of a query language is the same even without the set difference operator, so long as the <code>LEFT JOIN</code> operator is maintained? How would one prove this fact?</p>\n', 'Tags': '<database-theory><relational-algebra><finite-model-theory>', 'LastEditorUserId': '69', 'LastActivityDate': '2013-05-29T00:50:34.590', 'CommentCount': '1', 'AcceptedAnswerId': '28', 'CreationDate': '2012-03-06T19:06:05.667', 'Id': '2'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Does SQL  need subqueries?</p>\n\n<p>Imagine a sufficiently generalized implementation of the structured query language for relation databases. Since the structure of the canonical SQL <code>SELECT</code> statement is actually pretty important for this to make sense, I don't appeal directly to relational algebra, but you could frame this in those terms by making appropriate restrictions on the form of expressions.</p>\n\n<p>An SQL <code>SELECT</code> query generally consists of a projection (the <code>SELECT</code> part) some number of <code>JOIN</code> operations (the <code>JOIN</code> part), some number of <code>SELECTION</code>  operations (in SQL, the <code>WHERE</code> clauses), and then set-wise operations (<code>UNION</code>, <code>EXCEPT</code>, <code>INTERSECT</code>, etc.), followed by another SQL <code>SELECT</code> query.</p>\n\n<p>Tables being joined can be the computed results of expressions; in other words, we can have a statement such as:</p>\n\n<pre><code>SELECT t1.name, t2.address\n  FROM table1 AS t1 \n  JOIN (SELECT id, address \n          FROM table2 AS t3 \n         WHERE t3.id = t1.id) AS t2\n WHERE t1.salary &gt; 50,000;\n</code></pre>\n\n<p>We will refer to the use of a computed table as part of an SQL query as a subquery. In the example above, the second (indented) <code>SELECT</code> is a subquery.</p>\n\n<p>Can all SQL queries be written in such a way as to not use subqueries? The example above can:</p>\n\n<pre><code>SELECT t1.name, t2.address\n  FROM table1 AS t1 \n  JOIN table2 AS t2\n    ON t1.id = t2.id\n WHERE t1.salary &gt; 50,000;\n</code></pre>\n\n<p>This example is somewhat spurious, or trivial, but one can imagine instances where considerably more effort might be required to recover an equivalent expression. In other words, is it the case that for every SQL query $q$ with subqueries, there exists a query $q&#39;$ without subqueries such that $q$ and $q&#39;$ are guaranteed to produce the same results for the same underlying tables? Let us limit SQL queries to the following form:</p>\n\n<pre><code>SELECT &lt;attribute&gt;,\n      ...,\n      &lt;attribute&gt;\n FROM &lt;a table, not a subquery&gt;\n JOIN &lt;a table, not a subquery&gt;\n  ...\n JOIN &lt;a table, not a subquery&gt;\nWHERE &lt;condition&gt;\n  AND &lt;condition&gt;\n  ...\n  AND &lt;condition&gt;\n\nUNION\n -or-\nEXCEPT\n -or-\n&lt;similar&gt;\n\nSELECT ...\n</code></pre>\n\n<p>And so on. I think left and right outer joins don't add much, but if I am mistaken, please feel free to point that out... in any event, they are fair game as well. As far as set operations go, I guess any of them are fine... union, difference, symmetric difference, intersection, etc... anything that is helpful. Are there any known forms to which all SQL queries can be reduced? Do any of these eliminate subqueries? Or are there some instances where no equivalent, subquery-free query exists? References are appreciated... or a demonstration (by proof) that they are or aren't required would be fantastic. Thanks, and sorry if this is a celebrated (or trivial) result of which I am painfully ignorant.</p>\n", 'ViewCount': '1403', 'Title': 'Do subqueries add expressive power to SQL queries?', 'LastActivityDate': '2013-06-06T21:52:42.197', 'AnswerCount': '3', 'CommentCount': '6', 'AcceptedAnswerId': '2267', 'Score': '21', 'PostTypeId': '1', 'OwnerUserId': '69', 'Tags': '<database-theory><relational-algebra>', 'CreationDate': '2012-03-08T05:55:29.920', 'FavoriteCount': '2', 'Id': '129'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following query:</p>\n\n<pre><code>SELECT Customer.Name FROM Customer\nINNER JOIN Order on Order.CustomerId = Customer.Id\nWHERE Customer.Preferred = True AND\n      Order.Complete = False\n</code></pre>\n\n<p>Let\'s suppose all of the relevant attributes (Customer.Preferred, Order.Complete, Order.CustomerId and Customer.Id) are indexed. How can I evaluate this as quickly as possible?</p>\n\n<p>Standard optimization advice would say that I should do the select on each table first, then the join using sort-merge or whatever the cardinality would imply. But this involves two passes through the data - I\'m wondering if there\'s a better way.</p>\n\n<hr>\n\n<p><strong>EDIT</strong>: I think asking if there was a "better way" was too ill-defined. Suppose we are trying to find $\\sigma_a(A)\\bowtie_j\\sigma_b(B)$. Observe that we can find this in $O(\\alpha)$ (where $\\alpha$ is the cardinality of $\\sigma_a(A)$) with the following pseudocode:</p>\n\n<pre><code>for each a in A:\n   find foreign tuple in B  // constant-time, if using hash table\n   check if foreign tuple meets foreign constraint  // again, constant time\n</code></pre>\n\n<p>As mentioned by some answerers, there are various minor permutations (do the for loop over B instead, etc.). But they all seem to be $O(\\alpha)$ or $O(\\beta)$. Is there a better way?</p>\n\n<p>Note that if it the query were a self join, we could just do the merge part of a sort-merge join, (since our indexes would already be sorted) which would run in time proportional to the number of results. So I ask if a similar thing can be done here.</p>\n\n<p>I am more than happy to accept a proof that there is no better method as an answer. I believe that there is no faster algorithm, but I\'m unable to prove it.</p>\n', 'ViewCount': '86', 'Title': 'Optimizing a join where each table has a selection', 'LastEditorUserId': '1590', 'LastActivityDate': '2012-06-11T21:35:22.203', 'LastEditDate': '2012-06-11T21:35:22.203', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1590', 'Tags': '<optimization><database-theory><relational-algebra><databases>', 'CreationDate': '2012-05-21T20:03:25.400', 'FavoriteCount': '0', 'Id': '1980'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am trying to understand how a <code>OUTER UNION</code> $\u222a^\u2733$ works, and why it is only partially compatible. </p>\n\n<p>I am aware this operation was created to take union of tuples from two relations if the relation are not type compatible (which I understand).</p>\n\n<p>Examples of this operation will be great!</p>\n', 'ViewCount': '144', 'Title': 'What is OUTER UNION and why is it partially compatible', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T20:04:37.257', 'LastEditDate': '2012-11-29T16:45:39.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6999', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4790', 'Tags': '<terminology><database-theory><relational-algebra>', 'CreationDate': '2012-11-28T18:25:12.240', 'Id': '6997'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve taken an introductory database course where like many good database courses, they taught relational algebra, including $\\theta$-joins. However, I\'ve recently read E. F. Codd\'s 1970 paper, <a href="http://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf" rel="nofollow"><em>A Relational Model of Data for Large Shared Databanks</em></a>, and the concept of $\\theta$-joins is nowhere to be found. He does use the symbol  $\\theta$ in the paper in section 2.2 though, but to refer to something much more general than joins.</p>\n\n<p>In fact, Natural Joins are even defined slightly differently then the definition I\'m familiar with. It requires that the original relations be completely recoverable from the joined relation.</p>\n\n<p>So my question is when/in what paper/by who was the modern notion of the $\\theta$-join introduced that is often taught by universities? </p>\n\n<p><a href="http://en.wikipedia.org/wiki/Relational_algebra#.CE.B8-join_and_equijoin" rel="nofollow">(A link to Wikipedia\'s definition of a $\\theta$-join, similar to the one I learned in my course)</a></p>\n', 'ViewCount': '98', 'Title': 'Origin of theta-joins', 'LastActivityDate': '2013-03-03T05:53:03.093', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10211', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7046', 'Tags': '<reference-request><history><relational-algebra>', 'CreationDate': '2013-02-28T22:56:28.393', 'FavoriteCount': '1', 'Id': '10158'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I'm just starting to learn about query processing and such in databases and I'm having some trouble.  I don't really understand how to compute the minimum number of block reads given a relation and a query I guess you could say.  If anyone could help me out, it'd be much appreciated.  Here is an example that I'm working on:</p>\n\n<ul>\n<li>R1(A,B,C) A is a primary key and C is a foreign key to R2.C</li>\n<li>R2(C,D,E) C is a primary key</li>\n<li>R1 has 20,000 records, with 200 records per block. There is a primary B+-tree index on\nA with height h = 3</li>\n<li>R2 has 45,000 records, with 4,500 records per block. There is a primary B+-tree index\non C with height hC = 3 and a secondary B+-tree index on D with height hD = 2.</li>\n</ul>\n\n<p>Find the minimum number of block reads for each statement.  I can only hold one block of memory for each relation at a time. </p>\n\n<ul>\n<li>Where B=1(R1)</li>\n<li>Where C=1(R2)</li>\n</ul>\n\n<p>I'm not looking for answers.  I'm looking for explanation of how to actually do it and guide me along the way.  Aka equations, etc. It's kind of difficult to find anything beneficial online at all. </p>\n", 'ViewCount': '79', 'Title': 'Computing number of block reads given relational algebra statement', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-24T06:20:57.237', 'LastEditDate': '2013-04-24T06:20:57.237', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11512', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7233', 'Tags': '<database-theory><databases><relational-algebra>', 'CreationDate': '2013-04-22T16:03:39.790', 'Id': '11492'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Using the following relations:</p>\n\n<pre><code>consultant(id,Name,Skill) \n\nCustomerCompany(Id,name Address, Phone, Email, WebAddr,Market)\n\nproject(id,StartDate,EndDate,ConsultantID,CustomerId,Days)\n\nInvoice(id,Date,Customer,Amount,Status)\n</code></pre>\n\n<p>Im trying to work out the following scenario using SQL and Relational algebra</p>\n\n<p>Find the names of the consultants and the names of customers, where the consultant has worked for the customer, and the customer received an invoice in the range of GBP 100k to 200k</p>\n\n<p>Using SQL i have:</p>\n\n<pre><code>Select I.amount, C.name \nfrom CustomerCompany C, Invoice I \nwhere I.Customer= C.id and &gt; all\n( \n  select C.name, Con.Name \n  from CustomerCompany, Con Consultant \n  where i.amount between 100 and 200\n );\n</code></pre>\n\n<p>Relational algebra:</p>\n\n<pre><code>amount = \u03c3(Invoice, amount&gt;=100 and amount&lt;=200)\n\njoininv= \u24cd(amount, Customer, CustomerCompany, id)\n\njoincon \u24cd(joiniv, Consultant id, Project, ConsultantID)\n\n\u03c0 =(joincon, name, Name)\n</code></pre>\n\n<p>I was wondering if write or wrong?</p>\n\n<p>Thanks for any help!</p>\n', 'ViewCount': '69', 'Title': 'relational algebra and SQL', 'LastEditorUserId': '4306', 'LastActivityDate': '2013-05-11T19:24:17.987', 'LastEditDate': '2013-05-11T15:02:54.793', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8054', 'Tags': '<databases><relational-algebra>', 'CreationDate': '2013-05-09T16:24:35.557', 'Id': '11913'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '409', 'Title': '"At least one" clause in Relational Algebra', 'LastEditDate': '2013-05-30T23:49:18.537', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8123', 'FavoriteCount': '1', 'Body': '<p>I\'m fairly new to the syntax of relational algebra, and I\'m having a hard time understanding how I could set a "at least one" clause. </p>\n\n<p>Example: I have:</p>\n\n<ul>\n<li>a table with books (listing the title, year published and ID), </li>\n<li>a table with authors (listing their name and ID),</li>\n<li>a table which lists what author wrote what book (through a tuple of the IDs mentioned before).</li>\n</ul>\n\n<p>How could I, in relational algebra, get "All the authors that have published at least one book per year between 2008 and 2010"?</p>\n\n<p>I have figured this so far. At step "b", the Natural join is used since both tables have PublicationID in common. Thus, the resulting table is |PublicationID|AuthorID|Year|. So I\'m simply missing the step "c", where I don\'t understand how to gather a sub-set of the authors that published at least one book per year between 2008 and 2010. </p>\n\n<p>$ a \\leftarrow \\pi_{PublicationID,Year} (Publication)$ </p>\n\n<p>$ b \\leftarrow a \\bowtie AuthorPublication $ </p>\n\n<p>$ c \\leftarrow \\sigma_{something} $</p>\n', 'Tags': '<database-theory><databases><relational-algebra>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-30T23:49:55.977', 'CommentCount': '5', 'AcceptedAnswerId': '12227', 'CreationDate': '2013-05-22T16:16:54.920', 'Id': '12218'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m thinking this should be just one or two things, since lambda calculus is so tiny and still Turing complete.</p>\n\n<p>Probably just recursion (something like "MY_QUERY(param) = select * from param UNION MY_QUERY(DO_SOMETHING_WITH(param))"). But I don\'t see how I could define aggregate functions with this.</p>\n\n<p>Any idea?</p>\n', 'ViewCount': '59', 'Title': 'Smallest set of features that would make relational algebra Turing complete', 'LastActivityDate': '2013-09-30T05:24:28.267', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<turing-completeness><relational-algebra>', 'CreationDate': '2013-09-30T05:24:28.267', 'Id': '14694'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this equivalence relation problem: </p>\n\n<p>Let $R$ and $S$ be two equivalence relations on the same set $A$. Define a new relation $U$ such that $U(x,y) \\leftrightarrow [R(x,y) \\text{ or } S(x,y)]$. Is $U$ necessarily an equivalence relation? </p>\n\n<p>I said that is was an equivalence relation because $U$ is only true if $R$ or $S$ is true, and only depends on one. I do not know know exactly how to explain it, or prove this. Should I use proof by contradiction to prove this and make the negated statement $!U(x,y) \\leftrightarrow {![R(x,y) \\text{ or } S(x,y)]}$ and from this we can see that $U$ is an equivalence relation because the negation is saying that $R(x,y)$ or $S(x,y)$ isn't an equivalence when it actually is?</p>\n\n<p>I am kind of stuck so any help is appreciated.  </p>\n", 'ViewCount': '95', 'Title': 'Equivalence relation Mathematical base In Computer science', 'LastEditorUserId': '9612', 'LastActivityDate': '2013-10-07T08:43:11.273', 'LastEditDate': '2013-10-07T08:43:11.273', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10282', 'Tags': '<relational-algebra>', 'CreationDate': '2013-10-07T02:34:10.040', 'Id': '14873'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For the following schema</p>\n\n<pre><code>Country ("countryID", cName)\nCoffeeShop ("shopID", sName, countryID, city)\nProduct ("productID", size)\nServes ("shopID", "productID")\nProductNames ("productID", "countryID", pName)\n</code></pre>\n\n<p>where attributes in quotation marks are primary keys, I must write a relational algebra statement for the following query:</p>\n\n<pre><code>List names of products that have same names in all countries they are served.\n</code></pre>\n\n<p>The thing that made me stuck on this problem is the fact that the product must not necessarily be served in all countries, but rather have the same name in all countries it is served. Without comparing for an initial value, I couldn\'t get a solution that makes more sense and that is possible to be written as a relational algebra statement.</p>\n', 'ViewCount': '69', 'Title': 'Relational algebra statement for a query', 'LastActivityDate': '2013-12-22T23:31:30.650', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7809', 'Tags': '<relational-algebra>', 'CreationDate': '2013-10-23T15:48:29.710', 'Id': '16367'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to separate a weird relationship. It goes like this:</p>\n\n<ol>\n<li>One waiter can serve more than one kind of drink and one kind of drink can be served by more than one waiter.</li>\n<li>One waiter can wear more than one kind of shirt (eg different uniforms daily, or random uniform assignments, etc), and one kind of shirt can be worn by more than one waiter.</li>\n</ol>\n\n<p>There are two many-to-many relationships here that share the waiters, but can be separately resolved. But because they share the waiters entity, then many kinds of drinks can be served while wearing many kinds of shirts.</p>\n\n<p>The relational model looks like this:</p>\n\n<p><img src="http://i.stack.imgur.com/AoRal.png" alt="the model"></p>\n\n<p>My question is, how do I resolve this? It doesn\'t look like it lends itself easily to being decomposed into one-to-many relationships.</p>\n\n<p>Edit: I changed the image to fit in better with the description, but the problem that results here is the waiter-drinks and waiter-shirt entities still exist as a result of normalizing the drinks and waiters relationship (that is many-to many) and the waiter and shirt (also many-to-many). The resulting entities then have a many-to-many relationship as waiter-drinks and waiter-shirt.</p>\n\n<p>Where am I wrong?</p>\n', 'ViewCount': '47', 'Title': 'Resolving many to many relationships?', 'LastEditorUserId': '15032', 'LastActivityDate': '2014-03-30T07:53:44.673', 'LastEditDate': '2014-02-28T07:44:10.080', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15032', 'Tags': '<databases><relational-algebra>', 'CreationDate': '2014-02-25T16:54:23.817', 'Id': '22028'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a table of pairs of objects, which defines an equivalence relation. How can I extract a single object from each of the equivalence classes using relational algebra?</p>\n\n<p>It can easily be done with iteration. For example, associate a unique <code>classId</code> with every object, then for every pair <code>(a, b)</code> set <code>classId(a) = classId(b) = min(classId(a), classId(b))</code>, until all pairs share the same <code>classId</code> on both ends.<br>\nI wouldn't know how to do it more efficiently.</p>\n", 'ViewCount': '12', 'Title': 'Finding representatives of equivalence classes', 'LastActivityDate': '2014-03-04T18:32:02.143', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22279', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5167', 'Tags': '<relational-algebra>', 'CreationDate': '2014-03-04T17:09:51.790', 'Id': '22275'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What does superscript + mean in relational algebra?  Suppose $A$ is a subset of attributes of all attributes in a relation $R$.  What does $A^+$ mean?</p>\n', 'ViewCount': '21', 'Title': 'What does superscript + mean in relational algebra?', 'LastActivityDate': '2014-03-12T01:18:11.810', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15575', 'Tags': '<relational-algebra><notation>', 'CreationDate': '2014-03-12T00:48:36.790', 'Id': '22520'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Does anybody know any toy database / relations that are particularly good and also <strong>complete</strong> to demonstrate and test relational algebra concepts?  I'm hoping some database researchers should have already made that and improved over long time from pedagogical practices.</p>\n", 'ViewCount': '14', 'Title': 'In search for toy relations to test relational algebra', 'LastActivityDate': '2014-03-12T03:44:29.897', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15575', 'Tags': '<databases><relational-algebra>', 'CreationDate': '2014-03-12T03:44:29.897', 'Id': '22528'}