{'Body': '<p>Representing numeric values using <a href="http://en.wikipedia.org/wiki/Positional_notation">positional notation</a> is one of the milestones in the history of arithmetic. Babylons used a base 60 system, Maya a base 20 system; base 10 system became "the standard" used by modern civilizations; digital computers use the <a href="http://en.wikipedia.org/wiki/Binary_numeral_system">Binary numeral system</a>, ....</p>\n\n<p>But if we look at nature, we found that life itself "heavily rely" on an alphabet of 4 symbols: the <a href="http://en.wikipedia.org/wiki/DNA">DNA</a> has four <a href="http://en.wikipedia.org/wiki/Base_%28chemistry%29">(chemical) bases</a>: adenine, cytosine, guanine and thymine (A, C, G, T) that are used to store the "instructions and information" to generate and drive the parts of a living organism.</p>\n\n<blockquote>\nBut on a higher level, are there <em>"natural algorithms"</em> (algorithms found in natural processes, in animal behaviours or in everyday human behaviours) that take advantages of "numeral systems" other than the <a href="http://en.wikipedia.org/wiki/Unary_numeral_system">unary representation</a>. \n</blockquote>\n\n<p>To be more precise I would like to know whether or not natural processes or living creatures make use of a finite, discrete alphabet of "symbols" and use them in a manner similar to a positional notation: the symbols are placed together and used as a whole to  represent "something" (an action, an information, an object, ...) among many other possibilites ... a sort of "index" in an exponential number of possibilites.</p>\n\n<p>Another (obvious) non numeric example is the human language where (in general) a combination of finite number of sounds ("alphabet") are combined to form the words.</p>\n', 'ViewCount': '99', 'Title': 'Numeral systems other than unary used in nature or in animal and human behaviours', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-19T21:54:13.267', 'LastEditDate': '2013-11-19T21:54:13.267', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '140', 'Tags': '<integers><notation><numeral-representations>', 'CreationDate': '2012-10-06T19:31:03.573', 'Id': '4906''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Why do we use other bases which are neither binary (for computers) nor decimals (for humans)?</p>\n\n<p>Computers end up representing them in binary, and humans strongly prefer getting their decimal representation. Why not stick to these two bases?</p>\n', 'ViewCount': '605', 'Title': 'Why hex, octal or hexadecimal? Computers use binary and humans decimals', 'LastEditorUserId': '10637', 'LastActivityDate': '2014-01-25T21:10:56.423', 'LastEditDate': '2014-01-25T13:47:40.913', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10637', 'Tags': '<numeral-representations>', 'CreationDate': '2014-01-25T12:47:11.180', 'FavoriteCount': '2', 'Id': '19963''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '28', 'Title': 'Is This Property (Representative Property) Can Be Generalized?', 'LastEditDate': '2014-04-27T23:48:57.763', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17125', 'FavoriteCount': '1', 'Body': u'<p>I recently came across with a question that asks for the greatest subset of a given set, which includes relatively prime elements.(Randomly selected item from a set is always relatively prime to all others.)\nMy approach was eliminating the subsets depending on if the subset satisfies the rule.\nWhich means testing one by one all possible subsets. In order to determine which subset is going to be tested, I have choosen the following way:</p>\n\n<p>Let S be a set and "n" is the size of the set. Since there are 2^n possible subsets, all computer needs to do is to check all possible subsets. However, the question is in which way and regarding what property. In other words what would be the "rule" for computer to do it.</p>\n\n<p>I came up with a method which I call "Representative Property". By using ones and zeroes I could represent all the elements of the set to indicate their existance or absence in the subset which is going to be tested.</p>\n\n<p>\u0130f n=5, then There is 32 possible subsets. \nStarting from 2^n -1 in which case 31, converting 31 to binary we get "11111". What binary 11111 represent is all the elements of the set is included in the subset which is going to be tested.</p>\n\n<p>By incrementing that value by one I could get 11110,11101,11100,...00010,00001 where "1" stands for existance of the element and the "0" is vice versa.</p>\n\n<p>This is the code for who wonders all work...</p>\n\n<pre><code>import java.util.Scanner;\nimport java.util.ArrayList;\n\npublic class Quest_1 {\n\nprivate static boolean isRelativePrime(ArrayList&lt;Integer&gt; newInfo) {\n    int j;\n    for(int i=newInfo.size()-1;i&gt;=0;i--){\n\n        for(int k=i-1;k&gt;=0;k--){\n            j=2;\n            while (j&lt;newInfo.get(k)||j&lt;newInfo.get(i)){\n                if(newInfo.get(k)%j == 0 &amp;&amp; newInfo.get(i)%j== 0)\n                    return false;\n                j++;\n            }\n        }\n    }\n    return true;\n}\npublic static String reverse(String source) {\n    int i, len = source.length();\n    StringBuffer dest = new StringBuffer(len);\n\n    for (i = (len - 1); i &gt;= 0; i--)\n        dest.append(source.charAt(i));\n    return dest.toString();\n}\npublic static String binary(int i, int k){\n\n\n    int count = 0;\n    String empty ="";\n\n    while(i&gt;0){\n\n        if (i%2==0)\n            empty = empty +"0";\n        else\n            empty = empty +"1";\n        i = i/2;\n        count++;\n\n    }\n\n    while(count &lt; k){\n        empty = empty+"0";\n        count++;\n    }\n    empty = reverse(empty);\n    return empty;\n}\n\npublic static void main(String[] args) {\n    Scanner scan = new Scanner(System.in);\n    System.out.print("Ka\xe7 eleman? ");\n    String binary;\n    int max = 0;\n    int componentSize = scan.nextInt();\n\n    ArrayList&lt;Integer&gt; info = new ArrayList&lt;Integer&gt;();\n    ArrayList&lt;Integer&gt; newInfo = new ArrayList&lt;Integer&gt;();\n    for (int i = 0;i&lt;componentSize;i++){\n\n        info.add(scan.nextInt());\n\n    }\n    for(int l=0;l&lt;info.size();l++)\n        System.out.println("***----****------****** "+info.get(l));\n    for(int k=(int)Math.pow(2, componentSize)-1; k&gt;0; k--){\n        // takes the string.if "1" add,then compare.if relatPrime is true omit, else leave it\n        binary = binary( k, componentSize);\n        int index=binary.length()-1;\n        while(index &gt;= 0){\n\n            if(binary.charAt(index)==\'1\')\n                newInfo.add(info.get(index));\n\n            index--;\n        }\n        if(isRelativePrime(newInfo) &amp;&amp; max&lt;newInfo.size())\n            max = newInfo.size();\n        index=newInfo.size()-1;\n        while(index&gt;=0){\n            newInfo.remove(index);\n            index--;\n        }\n    }\n    System.out.println("here is the max: "+max);\n}\n\n}\n</code></pre>\n\n<p>Now here comes the question. Can this way, I mean representing the computations with numbers , be generalized?</p>\n\n<p>For example: there is a password whose length is 5.\n"1" stands for a, "2" for b and etc.</p>\n\n<p>or\nfor chess games, by decrementing the test case number, Can all the possibilities be evaluated ? And what is this process called,checking all the possibilities?</p>\n\n<p>I am majoring CS, first semester. Therefore, I am open to all suggestions.</p>\n\n<p>(I am really sorry for everything wrong, I\'d really appreciated,if you kindly warned me.)</p>\n', 'Tags': '<algorithms><decision-problem><numeral-representations>', 'LastEditorUserId': '17125', 'LastActivityDate': '2014-04-28T01:09:02.173', 'CommentCount': '1', 'AcceptedAnswerId': '24165', 'CreationDate': '2014-04-27T23:19:38.823', 'Id': '24160''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}