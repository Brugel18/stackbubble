470:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1567', 'Title': 'How to define quantum Turing machines?', 'LastEditDate': '2012-12-13T02:14:16.660', 'AnswerCount': '2', 'Score': '30', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '3', 'Body': '<p>In quantum computation, what is the equivalent model of a Turing machine? \nIt is quite clear to me how quantum <strong>circuits</strong> can be constructed out of quantum gates, but how can we define a quantum Turing machine (QTM) that can actually benefit from quantum effects, namely, perform on high-dimensional systems?</p>\n', 'Tags': '<quantum-computing><turing-machines><computation-models>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:14:16.660', 'CommentCount': '4', 'AcceptedAnswerId': '230', 'CreationDate': '2012-03-08T04:51:08.750', 'Id': '125'},471:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>Note this is a question related to study in a CS course at a university, it is NOT homework and can be found <a href="http://www.cs.ucf.edu/~dmarino/ucf/transparency/cot4210/exam/">here</a> under Fall 2011 exam2.</em></p>\n\n<p>Here are the two questions I\'m looking at from a past exam.  They seem to be related, the first:</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{CFG}} = \\{ &lt; \\! G \\! &gt; \\mid G \\text{ is a Context Free Grammar with } |\\mathcal{L}(G)|&lt;\\infty \\} $</p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{CFG}}$ is a decidable language.   </p>\n</blockquote>\n\n<p>and...</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{TM}} = \\{ &lt; \\! M\\!&gt; \\mid M \\text{ is a Turing Machine with } |\\mathcal{L}(M)|&lt;\\infty \\}$ </p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{TM}}$ is an undecidable language.   </p>\n</blockquote>\n\n<p>I am a bit lost on how to tackle these problems, but I have a few insights which I think may be in the right direction.  The first thing is that I am aware of is that the language $A_{\\mathrm{REX}}$, where </p>\n\n<blockquote>\n  <p>$\\qquad A_{\\mathrm{REX}} = \\{ &lt;\\! R, w \\!&gt; \\mid R \\text{ is a regular expression with } w \\in\\mathcal{L}(R)\\}$</p>\n</blockquote>\n\n<p>is a decidable language (proof is in Michael Sipser\'s <i>Theory of Computation</i>, pg. 168).  The same source also proves that a Context Free Grammar can be converted to a regular expression, and vice versa.  Thus $A_{\\mathrm{CFG}}$, must also be decidable as it can be converted to a regular expression.  This, and the fact that $A_{\\mathrm{TM}}$ is <b>un</b>-decidable, seems to be related to this problem.</p>\n\n<p>The only thing I can think of is passing G to Turing machines for $A_{\\mathrm{REX}}$ (after converting G to a regular expression) and $A_{\\mathrm{TM}}$.  Then accepting if G does and rejecting if G doesn\'t.  As $A_{\\mathrm{TM}}$ is undecidable, this will never happen.  Somehow I feel like I\'m making a mistake here, but I\'m not sure of what it is.  Could someone please lend me a hand here? </p>\n', 'ViewCount': '639', 'Title': 'Decidablity of Languages of Grammars and Automata', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T02:52:20.370', 'LastEditDate': '2012-03-27T02:52:20.370', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '629', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><computability><context-free><regular-languages><turing-machines>', 'CreationDate': '2012-03-21T20:07:51.783', 'Id': '627'},472:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>OK, so here is a question from a past test in my Theory of Computation class:</p>\n\n<blockquote>\n  <p>A useless state in a TM is one that is never entered on any input string.  Let $$\\mathrm{USELESS}_{\\mathrm{TM}} = \\{\\langle M, q \\rangle \\mid  q \\text{ is a useless state in }M\\}.$$\n  Prove that $\\mathrm{USELESS}_{\\mathrm{TM}}$ is undecidable. </p>\n</blockquote>\n\n<p>I think I have an answer, but I'm not sure if it is correct.   Will include it in the answer section.</p>\n", 'ViewCount': '765', 'Title': 'A Question relating to a Turing Machine with a useless state', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T20:56:08.023', 'LastEditDate': '2012-03-25T20:56:08.023', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '637', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<computability><undecidability><formal-methods><turing-machines>', 'CreationDate': '2012-03-22T00:21:58.210', 'Id': '636'},473:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2944', 'Title': 'Are Turing machines more powerful than pushdown automata?', 'LastEditDate': '2012-03-25T15:41:43.987', 'AnswerCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': "<p>I've came up with a result while reading some automata books, that Turing machines appear to be more powerful than pushdown automata. Since the tape of a Turing machine can always be made to behave like a stack, it'd seem that we can actually claim that TMs are more powerful. </p>\n\n<p>Is this true?</p>\n", 'Tags': '<formal-languages><computability><automata><turing-machines><pushdown-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-16T18:31:50.493', 'CommentCount': '4', 'AcceptedAnswerId': '670', 'CreationDate': '2012-03-22T20:00:29.897', 'Id': '669'},474:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1652', 'Title': 'Are there minimum criteria for a programming language being Turing complete?', 'LastEditDate': '2012-04-15T18:17:23.073', 'AnswerCount': '5', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '385', 'FavoriteCount': '6', 'Body': '<p>Does there exist a set of programming language constructs in a programming language in order for it to be considered Turing Complete?</p>\n\n<p>From what I can tell from <a href="http://en.wikipedia.org/wiki/Turing_completeness">wikipedia</a>, the language needs to support recursion, or, seemingly, must be able to run without halting. Is this all there is to it?</p>\n', 'Tags': '<computability><programming-languages><turing-machines><turing-completeness>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-19T19:43:12.440', 'CommentCount': '3', 'AcceptedAnswerId': '995', 'CreationDate': '2012-04-02T13:40:03.487', 'Id': '991'},475:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following algorithmic problem:</p>\n\n<blockquote>\n  <p>Determine the space Turing complexity of recognizing DNA strings that are Watson-Crick palindromes. </p>\n</blockquote>\n\n<p>Watson-Crick palindromes are strings whose reversed complement is the original string. The <em>complement</em> is defined letter-wise, inspired by DNA: A is the complement of T and C is the complement of G. A simple example for a WC-palindrome is ACGT.</p>\n\n<p>I've come up with two ways of solving this.</p>\n\n<p><strong>One requires $\\mathcal{O}(n)$ space.</strong></p>\n\n<ul>\n<li>Once the machine is done reading the input. The input tape must be copied to the work tape in reverse order. </li>\n<li>The machine will then read the input and work tapes from the left and compare each entry to verify the cell in the work tape is the compliment of the cell in the input. This requires $\\mathcal{O}(n)$ space. </li>\n</ul>\n\n<p><strong>The other requires $\\mathcal{O}(\\log n)$ space.</strong></p>\n\n<ul>\n<li>While reading the input. Count the number of entries on the input tape.</li>\n<li>When the input tape is done reading\n<ul>\n<li>copy the complement of the letter onto the work tape</li>\n<li>copy the letter L to the end of the work tape</li>\n</ul></li>\n<li>(Loop point)If the counter = 0, clear the worktape and write yes, then halt</li>\n<li>If the input tape reads L\n<ul>\n<li>Move the input head to the left by the number of times indicated by the counter  (requires a second counter)</li>\n</ul></li>\n<li>If the input tape reads R \n<ul>\n<li>Move the input head to the right by the number of times indicated by the counter (requires a second counter)</li>\n</ul></li>\n<li>If the cell that holds the value on the worktape matches the current cell on the input tape\n<ul>\n<li>decrement the counter by two</li>\n<li>Move one to the left or right depending if R or L is on the worktape respectively</li>\n<li>copy the Complement of L or R to the worktape in place of the current L or R</li>\n<li>continue the loop</li>\n</ul></li>\n<li>If values dont match, clear the worktape and write no, then halt</li>\n</ul>\n\n<p>This comes out to about $2\\log n+2$ space for storing both counters, the current complement, and the value L or R.</p>\n\n<p><strong>My issue</strong></p>\n\n<p>The first one requires both linear time and space. The second one requires $\\frac{n^2}{2}$ time and $\\log n$ space. I was given the problem from the quote and came up with these two approaches, but I don't know which one to go with. I just need to give the space complexity of the problem. </p>\n\n<p><strong>The reason I'm confused</strong></p>\n\n<p>I would tend to say the second one is the best option since it's better in terms of time, but that answer only comes from me getting lucky and coming up with an algorithm. It seems like if I want to give the space complexity of something, it wouldn't require luck in coming up with the right algorithm. Am I missing something? Should I even be coming up with a solution to the problem to answer the space complexity?</p>\n", 'ViewCount': '406', 'Title': 'The space complexity of recognising Watson-Crick palindromes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T07:35:10.873', 'LastEditDate': '2012-04-11T20:15:46.800', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '1224', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<algorithms><algorithm-analysis><turing-machines><space-complexity>', 'CreationDate': '2012-04-11T15:21:09.507', 'Id': '1223'},476:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '337', 'Title': 'Turing reducibility implies mapping reducibility', 'LastEditDate': '2012-04-30T01:11:53.080', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '196', 'FavoriteCount': '1', 'Body': '<p>The question is whether the following statement is true or false:</p>\n\n<p>$A \\leq_T B \\implies A \\leq_m B$</p>\n\n<p>I know that if $A \\leq_T B$ then there is an oracle which can decide A relative to B. I know that this is not enough to say that there is a computable function from A to B that can satisfy the reduction.</p>\n\n<p>I don\'t know how to word this in the proper way or if what I\'m saying is enough to say that the statement is false. How would I go about showing this?</p>\n\n<p>EDIT: This is not a homework problem per se, I\'m reviewing for a test.\nWhere $\\leq_T$ is <a href="http://en.wikipedia.org/wiki/Turing_reduction" rel="nofollow">Turing reducibility</a>, and $\\leq_m$ is <a href="http://en.wikipedia.org/wiki/Mapping_reduction" rel="nofollow">mapping reducibility</a>.</p>\n', 'Tags': '<computability><reductions><turing-machines>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-03T11:58:52.843', 'CommentCount': '0', 'AcceptedAnswerId': '1563', 'CreationDate': '2012-04-29T04:57:06.113', 'Id': '1562'},477:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '542', 'Title': 'Please explain this formal definition of computation', 'LastEditDate': '2012-05-05T20:24:28.687', 'AnswerCount': '3', 'Score': '5', 'OwnerDisplayName': 'Stefano Borini', 'PostTypeId': '1', 'OwnerUserId': '1377', 'FavoriteCount': '2', 'Body': "<p>I am trying to attack TAOCP once again, given the sheer literal heaviness of the volumes I have trouble committing to it seriously. In TAOCP 1 Knuth writes, page 8, basic concepts::</p>\n\n<blockquote>\n  <p>Let $A$ be a finite set of letters. Let $A^*$ be the set of all strings in $A$ (the set of all ordered sequences $x_1$ $x_2$ ... $x_n$ where $n \\ge 0$ and $x_j$ is in $A$ for $1 \\le j \\le n$). The idea is to encode the states of the computation so that they are represented by strings of $A^*$ . Now let $N$ be a non-negative integer and Q (the state) be the set of all $(\\sigma, j)$, where $\\sigma$ is in $A^*$ and j is an integer $0 \\le j \\le N$; let $I$ (the input) be the subset of Q with $j=0$ and let $\\Omega$ (the output) be the subset with $j = N$. If $\\theta$ and $\\sigma$ are strings in $A^*$, we say that $\\theta$ occurs in $\\sigma$ if $\\sigma$ has the form $\\alpha \\theta \\omega$ for strings $\\alpha$ and $\\omega$. To complete our definition, let $f$ be a function of the following type, defined by the strings $\\theta_j$, $\\phi_j$ and the integers $a_j$, $b_j$ for $0 \\le j \\le N$:</p>\n  \n  <ul>\n  <li>$f((\\sigma, j)) = (\\sigma, a_j)$ if $\\theta_j$ does not occur in $\\sigma$</li>\n  <li>$f((\\sigma, j)) = (\\alpha \\psi_j \\omega, b_j)$ if $\\alpha$ is the shortest possible string for which $\\sigma = \\alpha \\theta_j \\omega$</li>\n  <li>$f((\\sigma,N)) = (\\sigma, N)$</li>\n  </ul>\n</blockquote>\n\n<p>Not being a computer scientist, I have trouble grasping the whole passage. I kind of get the idea that is behind a system of opcodes, but I haven't progressed effectively in understanding. I think that the main problem is tat I don't know how to read it effectively. </p>\n\n<p>Would it be possible to explain the passage above so that I can understand it, and give me a strategy in order to get in the logic in interpreting these statements?</p>\n", 'Tags': '<formal-languages><turing-machines><computation-models>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-10T13:45:00.413', 'CommentCount': '8', 'CreationDate': '2012-05-04T22:03:23.210', 'Id': '1666'},478:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Define $\\mathrm{Prefix}  (L) = \\{x\\mid \\exists y .xy \\in L \\}$. I'd love your help with proving that $\\mathsf{RE}$ languages are closed under $\\mathrm{Prefix}$.</p>\n\n<p>I know that recursively enumerable languages are formal languages for which there exists a Turing machine  that will halt and accept when presented with any string in the language as input, but may either halt and reject or loop forever when presented with a string not in the language.</p>\n\n<p>Any help for how should I approach to this kind of a proof?</p>\n", 'ViewCount': '755', 'Title': 'Proving that recursively enumerable languages are closed against taking prefixes', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T09:56:00.747', 'LastEditDate': '2012-05-10T15:21:06.183', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '1732', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><turing-machines><closure-properties>', 'CreationDate': '2012-05-08T15:36:31.447', 'Id': '1731'},479:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose that $L(M) = L$ where $M$ is a $TM$ that moves only to the right side.</p>\n\n<p>I need to Show that $L$ is regular.</p>\n\n<p>I'd relly like some help, I tried to think of any way to prove it but I didn't reach to any smart conclusion. what is it about the only side right moves and the regularity? </p>\n", 'ViewCount': '216', 'Title': '$L(M) = L$ where $M$ is a $TM$ that moves only to the right side so $L$ is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T14:56:52.800', 'LastEditDate': '2012-05-14T14:56:52.800', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '1784', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><turing-machines>', 'CreationDate': '2012-05-10T20:04:18.130', 'Id': '1779'},4710:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I would like to use your help with the following problem:</p>\n\n<p>$L=\\{\u27e8M\u27e9 \u2223 L(M) \\mbox{ is context-free} \\}$. Show that $L \\notin RE \\cup  CoRE$.</p>\n\n<p>I know that to prove $L\\notin RE$, it is enough to find a language $L'$ such that $L'\\notin RE$ and show that there is a reduction from $L'$ to $L$ $(L'\\leq _M L)$.</p>\n\n<p>I started to think of languages which I already know that they are not in $RE$, and I know that $Halt^* =\\{\u27e8M\u27e9 \u2223 M\\mbox{ halts for every input} \\} \\notin RE$. I thought of this reduction from $Halt^*$ to $L$: $f(\u27e8M\u27e9)=(M')$. for every $\u27e8M\u27e9$: if $M$ halts for every input  $L(M')=0^n1^n$ otherwise it would be $o^n1^n0^n$, but this is not correct, Isn't it? How can I check that $M$ halts for every input to begin with? and- is this the way to do that?</p>\n", 'ViewCount': '295', 'Title': u'Proof that $\\{\u27e8M\u27e9 \u2223 L(M) \\mbox{ is context-free} \\}$ is not (co-)recursively enumerable', 'LastEditorUserId': '1589', 'LastActivityDate': '2012-05-22T01:10:33.537', 'LastEditDate': '2012-05-21T21:24:16.623', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1985', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<formal-languages><computability><context-free><turing-machines>', 'CreationDate': '2012-05-21T19:28:38.840', 'Id': '1979'},4711:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the usual definition of probabilistic poly-time machine it is said that the machine halts in polynomial time for all inputs. </p>\n\n<p>Is the intention really to say that the machine halts for all inputs, or that if it halts it must be in polynomial time?</p>\n', 'ViewCount': '124', 'Title': 'Probabilistic poly-time machine always halts on all inputs?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-25T20:13:41.407', 'LastEditDate': '2012-05-25T11:15:04.400', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'OwnerDisplayName': 'user583311', 'PostTypeId': '1', 'Tags': '<complexity-theory><terminology><turing-machines><probabilistic-algorithms>', 'CreationDate': '2012-05-24T14:21:16.507', 'Id': '2047'},4712:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following question from <a href="http://www.cs.princeton.edu/theory/complexity/" rel="nofollow">Computational Complexity - A modern Approach</a> by Sanjeev Arora and Boaz Barak:</p>\n\n<blockquote>\n  <p><em>[Q 4.1]</em><br>\n  Prove the existence of a universal TM for space bounded computation (analogously to the deterministic universal TM of Theorem 1.9). </p>\n</blockquote>\n\n<p>That is, prove that there exists a Turing Machine $SU$ such that for every string $\\alpha$ and input $x$, if the TM $M_\\alpha$ -- the TM represented by $\\alpha$ -- halts on $x$ before using $t$ cells of its work tape, then $SU(\\alpha, t, x) = M_\\alpha(x)$ and moreover, $SU$ uses at most $C\\cdot t$ cells of its work tape, where $C$ is a constant depending only on $M_\\alpha$.</p>\n\n<p>After checking theorem 1.9 and the universal TM with time bound, I see that the construct $SU(\\alpha, t, x)$ means that the Turing machine SU stops after $t$ steps. However if this is the case, then it means that we can create a Turing Machine equivalent to $M_\\alpha$ such that the new Turing Machine stops in $t$ steps where $t$ is the "space" used in the original.</p>\n\n<p>However, this seems a dubious interchange of space and time. If on the other hand, $t$ actually meant that the second machine stops within $t$ space, too, then the second part does not make sense any more because it says $SU$ uses $Ct$ cells, which is not $t$.</p>\n\n<p>So my question is how do I interpret this? Is the first interpretation really possible?</p>\n', 'ViewCount': '324', 'Title': 'Space bounded Turing Machine - clarification on Computational Complexity (book: Arora-Barak ) question 4.1', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T18:37:19.410', 'LastEditDate': '2012-05-27T18:23:04.883', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2113', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1209', 'Tags': '<complexity-theory><terminology><turing-machines><space-complexity>', 'CreationDate': '2012-05-27T17:36:53.217', 'Id': '2110'},4713:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$L=\\{&lt;\\!M,x\\!&gt;\\, \\mid M's \\text{ transition function can only move right and   } M\\text{ halts on } x \\}$. I need to show that $L$ is recursive/decidable.</p>\n\n<p>I thought of checking the encoding of $M$ first and determine whether its transition function moves only right (Can I do that?). If so then try to simulate $M$ on $x$ for $|Q|+1$ steps, if it stops then $&lt;\\!M,x\\!&gt;\\, \\in L$ otherwise it is not.</p>\n\n<p>Is this correct?</p>\n", 'ViewCount': '237', 'Title': 'Show that the halting problem is decidable for one-pass Turing machines', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T09:58:30.713', 'LastEditDate': '2012-06-03T15:42:33.780', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2213', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<formal-languages><computability><turing-machines><check-my-proof>', 'CreationDate': '2012-06-03T14:32:39.493', 'Id': '2212'},4714:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The document I am reading is here: <a href="http://www.cs.odu.edu/~toida/nerzic/390teched/tm/definitions.html" rel="nofollow">Turing Machines</a></p>\n\n<p>Before getting into the question, here is the notation used on the picture:</p>\n\n<blockquote>\n  <p>Here $\\Delta$ denotes the blank and R, L and S denote move the head right, left\n  and do not move it, respectively. A transition diagram can also be\n  drawn for a Turing machine. The states are represented by vertices and\n  for a transition $\\delta( q, X ) = ( r, Y, D )$ , where D represents R, L \n  or S , an arc from q to r is drawn with\n  label ( X/Y , D ) indicating that the state is changed from q to r,\n  the symbol X currently being read is changed to Y and the tape head is\n  moved as directed by D.</p>\n</blockquote>\n\n<p>According to the document:</p>\n\n<blockquote>\n  <p>A Turing machine T is said to decide a language L if and only if T\n  writes "yes" and halts if a string is in L and T writes "no" and halts\n  if a string is not in L</p>\n</blockquote>\n\n<p>Here is the three examples:</p>\n\n<ul>\n<li>Case 1:</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/lGDWj.jpg" alt="Case 1"></p>\n\n<ul>\n<li>Case 2:</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/SlYEj.jpg" alt="Case 2"></p>\n\n<ul>\n<li>Case 3:</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/Eextt.jpg" alt="Case 3"></p>\n\n<p>I just want to verify my understanding. According to the definition, in case 1 and case 2, its turing machines cannot decide because the machines cannot tell whether invalid inputs rather than { a } (such as aa, aaa, aaaa....) is in L or not. </p>\n\n<p>In case 2, if another a appears after the first a, or if the input is empty, the machine goes to state S and loop forever. </p>\n\n<p>In case 3, if <code>a</code> is detected and only a single <code>a</code> exists, that <code>a</code> is replaced by <code>1</code> and the machine accepts. Otherwise, a <code>0</code> is replaced and the input is decided not in the language.</p>\n\n<p>Am I correct on all of these? However, in case 3, what if I give any input which contains other character rather than <code>a</code> (such as string <code>ab</code>, <code>bc</code>...)? Or is it said that TM decides only languages over a set of alphabet $\\Sigma$ allowed by the Turing Machine?</p>\n\n<p>If a string which is longer than a single <code>a</code> (like <code>aa</code>, <code>aaa</code>,<code>ab</code>,<code>bc</code>...), the machine may loop forever (like in case 2) or halt without accepting (in other words, it is "crashed", where it does not have transition rules for a symbol in the input such as <code>b</code> in the case of above Turing Machines). Is this correct also?</p>\n', 'ViewCount': '307', 'Title': 'Turing machine and language decidability', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-04T23:29:48.913', 'LastEditDate': '2012-06-04T23:29:48.913', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '2219', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-06-04T05:51:42.557', 'Id': '2218'},4715:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I get the proof of going from an enumerator to a Turing Machine (keep running enumerator and see if it matches input) but I don't see how the other way works.</p>\n\n<p>According to my notes and the book (Intro to the Theory of Computation - Sipser), to get Turing enumerator from a Turing machine, we basically write all combinations of the alphabet. You then run the TM on this input, if it accepts print it out, replace with new string repeat ad infinitum.</p>\n\n<p>The problem I am having is surely this requires the language to be decidable. Otherwise it might get stuck on the third word in some infinite loop doomed never to accept or reject and certainly never print out the whole language. </p>\n\n<p>What am I missing?</p>\n", 'ViewCount': '117', 'Title': 'Turing Recognisable => enumerable', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-06T11:16:44.820', 'LastEditDate': '2012-06-06T11:16:44.820', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2239', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1759', 'Tags': '<computability><turing-machines><intuition>', 'CreationDate': '2012-06-05T19:38:42.417', 'Id': '2238'},4716:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $C$ be a non-trivial set of recursively enumerable languages ($\\emptyset \\subsetneq C \\subsetneq \\mathrm{RE}$) and let $L$ be the set of encodings of Turing machines that recognize some language in $C$: $$L=\\{\\langle M \\rangle \\mid L(M) \\in C \\}$$</p>\n\n<p>Suppose that $\\langle M_{loopy}\\rangle \\in L$, where $M_{loopy}$ is a TM that never halts.\nI wonder if  it is possible that $L \\in \\mathrm{RE}$?</p>\n\n<p>By Rice's theorem I know that $L \\notin \\mathrm{R}$ (the set of recursive languages), so either $L \\notin \\mathrm{RE}$ or $\\overline{L} \\notin \\mathrm{RE}$. Does it have to be the first option since $M_{loopy} \\in L$?</p>\n", 'ViewCount': '167', 'Title': 'Can the encodings set of a non-trivial class of languages which contains the empty set be recursively enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-10T20:19:25.683', 'LastEditDate': '2012-06-09T08:34:45.397', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '2298', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-06-08T21:46:15.523', 'Id': '2293'},4717:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Here is the document: <a href="http://spark-public.s3.amazonaws.com/automata/slides/19_tm4.pdf" rel="nofollow">More Undecidable Problems</a></p>\n\n<p>For a given property $P$ of languages, define $L_P$ as the set of all Turing machines (resp. their encodings) that accept languages with $P$, that is</p>\n\n<p>$\\qquad \\displaystyle L_{p} = \\{ \u27e8M\u27e9 \\mid \\mathcal{L}(M) \\text{ has property } P \\}$</p>\n\n<p>If $P$ is a trivial property, that is if $P$ holds for all or no language, $L_P$ is decidable, too (as $L_P=\\emptyset$ or $L_P = \\{\\langle M\\rangle \\mid M \\text{ Turing machine }\\}$. If $P$ is not trivial, $L_p$ is undecidable (by Rice\'s theorem), which means the strings in this language (or with such property) cannot be determined if it can be halt.</p>\n\n<p>We determine a language $M$ has property $P$ by reduce $M$ to another $M\'$, and check that if $M\'$ accepts the reduced string $x$ from the initial string $w$, we can conclude that $L(M)$ and $L(M\')$ have property $P$.</p>\n\n<p>However, as the title suggests, we only reduce a single string $w$ to $x$ and if $x$ is accepted, but we conclude the whole $L(M\')$ has property $P$. Thus, $M\'$ is obviously part of $L_p$. <em>What if some random strings in $L(M\')$ do not have property $P$?</em></p>\n\n<p><em>What if M accepts some string, but the reduction of those strings are not accepted by M\'?</em></p>\n\n<p>A reduction from language $L$ to language $L\u2019$ is an algorithm (TM that always halts) that takes a string $w$ and converts it to a string $x$, with the property that: <strong>$x$ is in $L\u2019$ if and only if $w$ is in $L$</strong>. </p>\n\n<p><em>Does this imply the reduced language $L\'$ will contain every property $P$ from $L$?</em> Since we can conclude that if $L\'$ is decidable, then $L$ is decidable as well and vice verse. <em>Can we conclude the same thing to property $P$?</em></p>\n', 'ViewCount': '231', 'Title': "How can a TM M' have a property P if it only accepts a single string x from language of P?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-11T13:43:44.273', 'LastEditDate': '2012-06-11T13:16:13.410', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-06-10T14:54:25.343', 'Id': '2319'},4718:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '300', 'Title': 'Why is Turing completeness right?', 'LastEditDate': '2012-06-23T15:17:09.140', 'AnswerCount': '2', 'Score': '9', 'OwnerDisplayName': 'MathematicalOrchid', 'PostTypeId': '1', 'OwnerUserId': '1951', 'FavoriteCount': '1', 'Body': '<p>I am using a digital computer to write this message. Such a machine has a property which, if you think about it, is actually quite remarkable: It is <em>one machine</em> which, if programmed appropriately, can perform <em>any possible computation</em>.</p>\n\n<p>Of course, calculating machines of one kind or another go back to antiquity. People have built machines which for performing addition and subtraction (e.g., an abacus), multiplication and division (e.g., the slide rule), and more domain-specific machines such as calculators for the positions of the planets.</p>\n\n<p>The striking thing about a computer is that it can perform <em>any</em> computation. Any computation at all. And all without having to rewire the machine. Today everybody takes this idea for granted, but if you stop and think about it, it\'s kind of amazing that such a device is possible.</p>\n\n<p>I have two actual <em>questions</em>:</p>\n\n<ol>\n<li><p>When did mankind figure out that such a machine was possible? Has there ever been any serious <em>doubt</em> about whether it can be done? When was this settled? (In particular, was it settled before or after the first actual implementation?)</p></li>\n<li><p>How did mathematicians <em>prove</em> that a Turing-complete machine really can compute everything?</p></li>\n</ol>\n\n<p>That second one is fiddly. Every formalism seems to have some things that <em>cannot</em> be computed. Currently "computable function" is <em>defined as</em> "anything a Turing-machine can compute". But how do we know there isn\'t some slightly more powerful machine that can compute more stuff? How do we know that Turing-machines are the correct abstraction?</p>\n', 'Tags': '<computability><turing-machines><history>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-23T22:50:06.447', 'CommentCount': '7', 'AcceptedAnswerId': '2465', 'CreationDate': '2012-06-23T13:58:23.750', 'Id': '2462'},4719:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': 'Time complexity version of the Church-Turing Thesis', 'LastEditDate': '2012-07-16T23:22:05.273', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1590', 'FavoriteCount': '1', 'Body': '<p>There\'s a <a href="http://plato.stanford.edu/entries/church-turing/#Bloopers" rel="nofollow">lot of debate</a> about what exactly the Church-Turing thesis is, but roughly it\'s the argument that "undecidable" should be considered equivalent to "undecidable by a universal turing machine."</p>\n\n<p>I\'m wondering if there\'s an analogous statement for time complexity, i.e. an argument that if some language is decided in $\\Theta\\left(f(n)\\right)$ on a universal turing machine, then we should say its time complexity is $\\Theta\\left(f(n)\\right)$. </p>\n\n<p>This isn\'t equivalent to the CT thesis - e.g. quantum computers decide precisely those languages which are decidable in a non-quantum TM, but they may run that decision procedure more quickly.</p>\n', 'Tags': '<computability><terminology><turing-machines><church-turing-thesis>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:22:05.273', 'CommentCount': '3', 'AcceptedAnswerId': '2766', 'CreationDate': '2012-07-02T16:28:33.263', 'Id': '2587'},4720:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>The question is exercise 1.9 from Arora-Barak's book <em>Computational Complexity \u2014 A Modern Approach</em>:</p>\n\n<hr>\n\n<p>Define a RAM Turing machine to be a Turing machine that has random access memory. We formalize this as follows: The machine has an infinite array A that is initialized to all blanks. It accesses this array as follows. One of the machine's work tapes is designated as the address tape. Also the machine has two special alphabet symbols denoted by R and W and an additional state we denote by q_access. Whenever the machine enters q_access, if its address tape contains 'i'R (where 'i' denotes the binary representation of i) then the value A[i] is written in the cell next to the R symbol. If its tape contains 'i'Wa (where a is some symbol in the machine's alphabet) then A[i] is set to the value a.</p>\n\n<p>Show that if a Boolean function $f$ is computable within time $T(n)$ (for some time constructible $T$) by a RAM TM, then is is in $\\mathrm{DTIME}(T(n)^2)$.</p>\n\n<hr>\n\n<p>The trivial solution by using an additional tape recording pairs (address,value) turns out to be in $\\mathrm{DTIME}(T(n)^3)$, since that tape can be of size $O(T(n)^2)$ with $O(T(n))$ pairs while the address of each pair can be of size $O(T(n))$.</p>\n", 'ViewCount': '225', 'Title': 'Prove that a boolean function computable in T(n) by a RAM machine is in DTIME(T(n)^2)', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-16T14:05:18.777', 'LastEditDate': '2012-08-17T14:04:18.113', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2121', 'Tags': '<complexity-theory><turing-machines><machine-models><simulation>', 'CreationDate': '2012-07-10T08:35:08.447', 'FavoriteCount': '1', 'Id': '2666'},4721:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '755', 'Title': 'What is the difference between quantum TM and nondetermistic TM?', 'LastEditDate': '2012-08-21T07:36:36.807', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '1', 'Body': '<p>I was going through the discussion on the question <a href="http://cs.stackexchange.com/questions/125/how-to-define-quantum-turing-machines/">How to define quantum-turing-machines?</a> and I feel that quantum TM and <em>nondetermistic</em> TM are one and the same. The answers to the other question do not touch on that. Are these two models one and the same?</p>\n\n<p>If no,</p>\n\n<ol>\n<li>What are the differences between quantum TM and NDTM? </li>\n<li>Is there any computation which a NDTM would do quicker than Quantum TM? </li>\n<li>If this is the case then quantum TM is a DTM, then why is there so much fuzz about this technology, we already have so many DTM. Why to design a new DTM in the end?</li>\n</ol>\n', 'Tags': '<computability><turing-machines><quantum-computing><nondeterminism>', 'LastEditorUserId': '2137', 'LastActivityDate': '2012-08-21T07:36:36.807', 'CommentCount': '1', 'AcceptedAnswerId': '2721', 'CreationDate': '2012-07-13T05:56:28.627', 'Id': '2718'},4722:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '529', 'Title': 'Does a never-halting machine always loop?', 'LastEditDate': '2012-07-18T10:09:48.590', 'AnswerCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2157', 'FavoriteCount': '2', 'Body': "<p>A Turing machine that returns to a previously encountered state with its read/write head on the same cell of the exact same tape will be caught in a loop. Such a machine doesn't halt.</p>\n\n<p>Can someone give an example of a never-halting machine that doesn't loop?</p>\n", 'Tags': '<computability><turing-machines><halting-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T10:09:48.590', 'CommentCount': '4', 'AcceptedAnswerId': '2730', 'CreationDate': '2012-07-13T15:18:18.840', 'Id': '2728'},4723:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I cannot understand decidability really well. I have been reading from books and internet, but I am little bit confused. \nAccording to the book (as I understood), we can decide on decidability of a problem by constructing Turing Machines. Let us say that we want to decide whether an NFA is a decidable language. First, we need to construct a Turing Machine that accepts if the run on w in NFA ends in accept state, otherwise Turing Machine rejects. \nAccording to this definition, I can construct any Turing Machine that can decide every NFA. As a result, I can say that every NFA that can be constructed is decidable. Is this true ?</p>\n\n<p>Additionally, I realized that we cannot decide whether two Context Free Grammars produce same languages. However, we can decide whether two NFA produce same language. Therefore, can we conclude that as our machines get complicated, some of the problems get harder to decide ? </p>\n\n<p>I mean lets take an example. Let us say that there is an NFA that accepts some string w whose length is a composite number. I think that this is a decidable problem.</p>\n\n<p>As you can see that I am little bit confused with these concepts. It will be a lot better for me to go over an example, because it is difficult for me to understand only from conceptual explanations.</p>\n', 'ViewCount': '90', 'Title': 'Decidability of Machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:04:31.740', 'LastEditDate': '2012-07-17T22:04:31.740', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Marigi Maskere', 'PostTypeId': '1', 'Tags': '<computability><automata><finite-automata><turing-machines>', 'CreationDate': '2009-12-06T15:47:36.283', 'Id': '2797'},4724:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2459', 'Title': 'Is a push-down automaton with two stacks equivalent to a turing machine?', 'LastEditDate': '2012-08-13T10:22:59.483', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'Lazer', 'PostTypeId': '1', 'OwnerUserId': '1558', 'FavoriteCount': '2', 'Body': '<p>In <a href="http://stackoverflow.com/a/559969/113124">this answer</a> it is mentioned</p>\n\n<blockquote>\n  <p>A regular language can be recognized by a finite automaton. A context-free language requires a stack, and <strong>a context sensitive language requires two stacks (which is equivalent to saying it requires a full Turing machine)</strong>.</p>\n</blockquote>\n\n<p>I wanted to know regarding the truth of the bold part above. Is it in fact true or not? What is a good way to reach at an answer to this?</p>\n', 'Tags': '<computability><automata><turing-machines>', 'LastEditorUserId': '917', 'LastActivityDate': '2012-08-13T10:22:59.483', 'CommentCount': '5', 'AcceptedAnswerId': '2833', 'CreationDate': '2012-07-19T10:50:44.883', 'Id': '2832'},4725:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $f$ be a fixed time-constructable function.</p>\n\n<p>The classical universal simulation result for TMs (Hennie and Stearns, 1966) states that there is a two-tape TM $U$ such that given</p>\n\n<ul>\n<li>the description of a TM $\\langle M \\rangle$, and</li>\n<li>an input string $x$,</li>\n</ul>\n\n<p>runs for $g(|x|)$ steps and returns $M$'s answer on $x$. And $g$ can be taken to be any function in $\\omega(f(n)\\lg f(n))$.</p>\n\n<p>My questions are:</p>\n\n<blockquote>\n  <ol>\n  <li><p>What is the best known simulation result on a single tape TM? Does the result above also still hold?</p></li>\n  <li><p>Is there any improvement on [HS66]? Can we simulate TMs on a two-tape TM for $f(n)$ steps in a faster way? \n  Can we take $g(n)$ to be in $\\omega(f(n))$ in place of $\\omega(f(n)\\lg f(n))$?</p></li>\n  </ol>\n</blockquote>\n", 'ViewCount': '278', 'Title': 'Universal simulation of Turing machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-16T13:15:01.727', 'LastEditDate': '2012-08-16T11:33:15.097', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '3220', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<complexity-theory><reference-request><turing-machines><machine-models><simulation>', 'CreationDate': '2012-07-23T15:49:05.823', 'Id': '2878'},4726:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In Sipser\'s textbook "Introduction to the Theory of Computation, Second Edition," he defines nondeterministic time complexity as follows:</p>\n\n<blockquote>\n  <p>Let $N$ be a nondeterministic Turing machine that is a decider.  The <strong>running time</strong> of $N$ is the function $f : \\mathbb{N} \\rightarrow \\mathbb{N}$, where $f(n)$ is the maximum number of steps that $N$ uses on any branch of its computation on any input of length $n$ [...].</p>\n</blockquote>\n\n<p>Part of this definition says that the running time of the machine $N$ is the maximum number of steps taken by that machine on any branch.  Is there a reason that all branches are considered?  It seems like the length of the shortest accepting computation would be a better measure (assuming, of course, that the machine halts), since you would never need to run the machine any longer than this before you could conclude whether the machine was going to accept or not.</p>\n', 'ViewCount': '129', 'Title': 'Why does NTIME consider the length of the longest computation?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-24T08:48:55.467', 'LastEditDate': '2012-07-24T08:48:55.467', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '2892', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<complexity-theory><time-complexity><terminology><turing-machines><nondeterminism>', 'CreationDate': '2012-07-23T22:49:08.547', 'Id': '2887'},4727:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The problem, coming from an interview question, is:</p>\n\n<blockquote>\n  <p>You have a stream of incoming numbers in range 0 to 60000 and you have\n  a function which will take a number from that range and return the\n  count of occurrence of that number till that moment. Give a suitable\n  Data structure/algorithm to implement this system.</p>\n</blockquote>\n\n<p>The stream is infinite, so if fixed size data structures re used, i.e. primitive types in Java or C, they will overflow. So there is the need to use data structures that have a size that grows over time. As pointed by the interviewer, the memory occupied by those data structures will diverge.</p>\n\n<p>The model of computation is a Turing machine with three tapes:</p>\n\n<ul>\n<li>infinite read-only one-way input tape;</li>\n<li>constant space bounded read-write two way work tape;</li>\n<li>infinite write-only one-way output tape.</li>\n</ul>\n\n<p>The main reason to choose the model above is that in the real world there is virtually no limit to the quantity of input that can be acquired using a keyboard or a network connection. Also, there is virtually no limit to the quantity of information that can be displayed on amonitor over time. But memory is limited and expensive.</p>\n\n<p>I modeled the problem as the problem to recognize the language L of all couples (number,number of occurrences so far).</p>\n\n<p>As a corollary of the Theorem 3.13 in Hopcroft-Ullman I know that every language recognized by a constant space bounded machine is regular.</p>\n\n<p>But, in any given moment, the language L is a finite language, because the number of couples to be recognized is finite: 60001. So I can\'t use the pumping lemma for regular languages to prove that such language is not regular.</p>\n\n<p>Is there a way I can complete my proof?</p>\n\n<p>The original question is <a href="http://stackoverflow.com/questions/11708957/find-the-count-of-a-particular-number-in-an-infinite-stream-of-numbers-at-a-part">here</a>.</p>\n', 'ViewCount': '198', 'Title': 'Counting with constant space bounded TMs', 'LastEditorUserId': '851', 'LastActivityDate': '2012-07-30T11:41:01.430', 'LastEditDate': '2012-07-30T11:41:01.430', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '2951', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<regular-languages><turing-machines><finite-automata><space-complexity><streaming-algorithm>', 'CreationDate': '2012-07-29T16:44:46.170', 'Id': '2948'},4728:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove that </p>\n\n<p>$L_1=\\{\\langle M\\rangle \\mid M \\text{ is a Turing machine and visits } q_0 \\text{ at least twice on } \\varepsilon\\} \\notin R$.</p>\n\n<p>I'm not sure whether to reduce the halting problem to it or not. I tried to construct a new machine $M'$ for $(\\langle M \\rangle,w)$, such that $M'$ visits $q_0$ twice, iff $M$ halts on $w$. This is specific $q_0$ given to me, but I didn't come to any smart construction, which would yield the requested. Maybe it's easier to show that it's $RE$ and not $coRE$? It is obvious that it's in $RE$, and I need to show that $L_2^{c}$ is not in $RE$.</p>\n\n<p>What should I do?</p>\n", 'ViewCount': '134', 'Title': 'Showing that the set of TMs which visit the starting state twice on the empty input is undecidable', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-02T05:53:06.110', 'LastEditDate': '2012-08-01T15:00:46.580', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2984', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-08-01T12:41:06.703', 'Id': '2981'},4729:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to understand the proof of the time hierarchy theorem appearing in sipser's book.  The proof requires a TM M to simulate an arbitrary TM N without too much slowdown. In particular, it is assumed that the encoding of N's tape alphabet using M's alphabet causes only a constant factor slowdown. This seems plausible since if N's alphabet is size k then M can use $\\log k$ cells to represent each symbol that N writes to the tape.</p>\n\n<p>But my question is this: If this is how the simulation works then before the simulation starts M will have to change the input so that each bit is repeated $\\log k$ times and I don't know how to do this without adding a quadratic term to the time. I should say its assumed that N's computation is no faster than $O(n\\log(n))$.   </p>\n", 'ViewCount': '140', 'Title': 'For the time hierarchy theorem, how is the input translated efficiently?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T12:18:07.830', 'LastEditDate': '2012-08-05T12:18:07.830', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2371', 'Tags': '<complexity-theory><turing-machines><simulation>', 'CreationDate': '2012-08-05T00:21:24.043', 'FavoriteCount': '1', 'Id': '3038'},4730:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '572', 'Title': 'Is it decidable whether a TM reaches some position on the tape?', 'LastEditDate': '2012-08-11T12:12:07.167', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1183', 'FavoriteCount': '1', 'Body': "<p>I have these questions from an old exam I'm trying to solve. For each problem, the input is an encoding of some Turing machine $M$.</p>\n\n<blockquote>\n  <p>For an integer $c&gt;1$, and the following three problems:</p>\n  \n  <ol>\n  <li><p>Is it true that for every input $x$, M does not pass the $|x|+c$ position when running on $x$?</p></li>\n  <li><p>Is it true that for every input $x$, M does not pass the $\\max \\{|x|-c,1 \\}$ position when running on $x$?</p></li>\n  <li><p>Is it true that for every input $x$, M does not pass the $(|x|+1)/c$ position when running on $x$?</p></li>\n  </ol>\n  \n  <p>How many problems are decidable? </p>\n</blockquote>\n\n<p>Problem number (1), in my opinion,  is in $\\text {coRE} \\smallsetminus \\text R$ if I understand correct since, I can run all inputs in parallel, and stop if some input reached this position and for showing that it's not in $\\text R$ I can reduce the complement of <strong>Atm</strong> to it. I construct a Turing machine $M'$ as follows: for an input $y$ I check if $y$ is a history of computation, if it is, then $M'$ running right and doesn't stop, if it's not, then it stops.</p>\n\n<p>For (3), I believe that it is decidable since for $c \\geqslant 2$ it is all the Turing machines that always stay on the first cell of the stripe, since for a string of one char it can pass the first cell, so I need to simulate all the strings of length 1 for $|Q|+1$ steps (Is this correct?), and see if I'm using only the first cell in all of them.</p>\n\n<p>I don't really know what to do with (2).</p>\n", 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '1183', 'LastActivityDate': '2012-08-12T03:39:42.523', 'CommentCount': '2', 'AcceptedAnswerId': '3127', 'CreationDate': '2012-08-10T19:10:45.963', 'Id': '3119'},4731:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The complexity class $\\newcommand{\\sharpp}{\\mathsf{\\#P}}\\sharpp$ is defined as </p>\n\n<p>$\\qquad \\displaystyle \\sharpp = \\{f \\mid \\exists \\text{ polynomial-time NTM } M\\ \\forall x.\\, f(x) = \\#\\operatorname{accept}_{M}(x)\\}$. </p>\n\n<p>It is known that $\\sharpp$ is closed under addition, multiplication and binomial coefficient. I was wondering if it is closed under power. For example, we are given a $\\sharpp$ function $f$ and another $\\sharpp$ function $g$. Is it true that $f^{g}$ or $g^{f}$ are $\\sharpp$ functions as well?  </p>\n\n<p>This is edit after the question has been answered.</p>\n\n<p>Is ($f$ modulo $g$) a $\\sharpp$ function? How about when we are given a $\\newcommand{\\FP}{\\mathsf{FP}}\\FP$ function $h$. Then is ($f$ modulo $h$) a $\\sharpp$ function? </p>\n', 'ViewCount': '139', 'Title': 'Is #P closed under exponentiation? modulo?', 'LastEditorUserId': '1093', 'LastActivityDate': '2012-08-12T23:36:10.113', 'LastEditDate': '2012-08-12T23:36:10.113', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3137', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1093', 'Tags': '<complexity-theory><turing-machines><closure-properties>', 'CreationDate': '2012-08-12T12:30:28.490', 'Id': '3134'},4732:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '389', 'Title': 'How to show two models of computation are equivalent?', 'LastEditDate': '2012-08-13T22:04:59.613', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'FavoriteCount': '1', 'Body': "<p>I'm seeking explanation on how one could prove that two models of computation are equivalent. I have been reading books on the subject except that equivalence proofs are omitted. I have a basic idea about what it means for two models of computation to be equivalent (the automata view: if they accept the same languages). Are there other ways of thinking about equivalence? If you could help me understand how to prove that the Turing-machine model is equivalent to lambda calculus, that would be sufficient.</p>\n", 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><machine-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:00.330', 'CommentCount': '5', 'AcceptedAnswerId': '3162', 'CreationDate': '2012-08-13T21:03:50.690', 'Id': '3154'},4733:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need help finding an algorithm which, given a Turing machine description $\\langle M \\rangle$, decides whether there exists an input $w$ such that in the computation of $M(w)$, the head only moves right and $M$ never stops.</p>\n', 'ViewCount': '173', 'Title': 'Decider for the family of Turing machines that move infinitly to the right on some input', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-14T21:42:57.557', 'LastEditDate': '2012-08-14T15:43:25.920', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'user1521539', 'PostTypeId': '1', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-07-12T17:46:55.297', 'FavoriteCount': '1', 'Id': '3180'},4734:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We know the halting problem (on Turing Machines) is undecidable for Turing Machines. Is there some research into how well the human mind can deal with this problem, possibly <em>aided</em> by Turing Machines or general purpose computers?</p>\n\n<p><em>Note</em>: Obviously, in the strictest sense, you can always say no, because there are Turing Machines so large they couldn't even be read in the life span of a single human. But this is a nonsensical restriction that doesn't contribute to the actual question. So to make things even, we'd have to assume humans with an arbitrary life span.</p>\n\n<p>So we could ask: Given a Turing Machine T represented in any suitable fashion, an arbitrarily long-lived human H and an arbitrary amount of buffer (i.e. paper + pens), can H decide whether T halts on the empty word?</p>\n\n<hr>\n\n<p><em>Corollary: If the answer is yes, wouldn't this also settle if any computer has a chance of passing the turing-test?</em></p>\n", 'ViewCount': '1255', 'Title': 'Human computing power: Can humans decide the halting problem on Turing Machines?', 'LastActivityDate': '2013-05-18T19:19:20.827', 'AnswerCount': '7', 'CommentCount': '10', 'Score': '21', 'PostTypeId': '1', 'OwnerUserId': '26', 'Tags': '<computability><turing-machines><halting-problem><human-computing>', 'CreationDate': '2012-08-21T10:46:52.483', 'FavoriteCount': '6', 'Id': '3271'},4735:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '354', 'Title': 'Using a step-counting function in a Turing Machine construction', 'CommunityOwnedDate': '2012-09-11T12:58:07.527', 'LastEditDate': '2012-09-12T09:44:18.067', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2775', 'Body': "<p>I have an question relating to the elementary foundations of Turing Machine theory. I would like to have a clarification of the status of a function $\\phi$ (a mapping between TM indexes) I shall introduce in the formal question after the preamble. First to the preamble.</p>\n\n<p>Let us assume that we have a fixed Turing Machine language and corresponding Universal Turing Machine. Thus ${TM_i}$ is an enumeration of machines, with UTM say as the Universal Machine in that enumeration. Let us also introduce a numerical parameter <strong>c</strong> for this example: (for example <strong>c</strong> = 500).</p>\n\n<p>Now execution of any TM can be simulated on UTM.</p>\n\n<p><strong>EDIT (Explaining notation)</strong> I am using some notation in this question which I shall outline here. Let S be an arbitrary input string for TM, then I shall write:</p>\n\n<p>$$UTM(TM_i; S)$$</p>\n\n<p>to indicate that $TM_i$ is using S as its input. So we will have the equation:\n$$UTM(TM_i; S) = TM_i(S)$$\nsince UTM is Universal, and its purpose is simply to simulate TMs on their input. If S is a composition of x,y I shall write:\n$$UTM(TM_i;x,y)$$</p>\n\n<p>(End notation discussion.)</p>\n\n<p>Let us modify UTM to UTM2 (and using the above notation) with the following property when a given $TM_i$ is executed on UTM2:</p>\n\n<p>$UTM_2(TM_i;c,x) = UTM(TM_i;c,x) = TM_i(x)$ if $TM_i$ requires <strong>c</strong> steps or less to compute the output</p>\n\n<p>$UTM_2(TM_i;c,x)=0$ if $TM_i(x)$ requires at least <strong>c</strong> steps for computation</p>\n\n<p><strong>EDIT</strong> The original question with this second condition has been answered. In this edit I would like to modify the condition to the following (introducing UTM3 which also meets the first condition):</p>\n\n<p>$UTM_3 (TM_i; c, x) = [s]$ if $TM_i (x)$ requires at least <strong>c</strong> steps for computation.</p>\n\n<p>In this expression [s] is the string on the tape which results after <strong>c</strong> steps of computation by $TM_i$ on Input. (EDIT The corresponding state of $TM_i$ will not be a Final state (ACCEPT or REJECT), but just an arbitrary state $q_j$. This is because UTM3 stops executing after <strong>c</strong> steps, ignoring the Turing Machine convention requiring termination only in Final states.) As a result (almost) all input strings x, including those with |x| > c will be modified (in a maximum of c string positions) - expressed in Language terms many such strings will just have their ACCEPTANCE calculation prematurely terminated in a non-Final state - but some strings of arbitrary length will still be ACCEPTED by some Turing Machines in less than <strong>c</strong> steps (IE those for which ACCEPTANCE requires examining less than the first <strong>c</strong> terms.)</p>\n\n<p>So under UTM2/3 the output is determined partly by a (hidden) step counting function. Here UTM2/3 has taken on some of the role of an operating system, by monitoring the actual steps taken by the simulated machines, and using some step-counting variable to behave as above.</p>\n\n<p>(EDIT: We show below that UTM2/3 is a Universal Machine)and so capable of <em>executing</em> any TM - on any argument - it is provided with, at least as far as <strong>c</strong> steps. Despite this limitation I believe that an infinite number of (TM,input) pairs will result in a non-zero output. So most TMs executed on UTM2/3 will not behave as they do on UTM. In UTM3 the outputs will explicitly depend on x,i and c.(End preamble.)</p>\n\n<p>The question is whether any given $TM_i$ can be modified into $TM_{\\phi (i,c)}$ with the property that (generalising to arbitrary c):</p>\n\n<p>$UTM_3(TM_i; c, x)$ = $UTM (TM_{\\phi(i,c)}; x)$       (for all $x$ and $c$)</p>\n\n<p><strong>EDIT2\\phi</strong> Both questions for the $\\phi(i,c)$ have been answered. For reasons discussed below I want to modify the definition to $\\phi(i)$. This new definition is:</p>\n\n<p>$UTM_3(TM_i; c, x)$ = $UTM (TM_{\\phi(i)}; c,x)$ = $TM_{\\phi(i)}(c,x)$       (for all $x$ and $c$)</p>\n\n<p>This condition is meant to ensure that $TM_{\\phi (i)}$ is a correct simulation of $TM_i$.\nThe specific questions to be proven about $\\phi: (i) \\rightarrow i$ are: (i) Is $\\phi$ well defined and non-trivial; (ii) Is $\\phi$ recursive; (iii) Is $\\phi$ non-recursive? </p>\n\n<p>In the LHS of the above definitions c is an input, which is ignored by $TM_i$ but used by UTM3 to determine the stopping stage. Asking for $\\phi(x,c)$ made this a <em>fixed</em> parameter built into the definition of $TM_{\\phi(x,c)}$. However the correct UTM simulation will be given <strong>c</strong> as in the modified equation RHS. This parameter needs to be used by $TM_{\\phi(i)}$ along with its own input x, to construct the correct simulation. (EDIT) Of course since the UTM is a regular Universal Machine it simply simulates the execution of $TM_{\\phi(i)}$ - the parameters on <em>its</em> tape - like <strong>c</strong> - are meant for its TM's only.</p>\n\n<p>Note that a special symbol <strong>u</strong> could be introduced switching off the UTM3 counts, and so</p>\n\n<p>$$UTM3(TM_i;u,x) = UTM(TM_i;u,x) = TM_i(x)$$</p>\n\n<p>Also the same problem can be formulated for the original UTM2 (with modified $\\phi$).</p>\n\n<p>This question is a simplification of a problem I am trying to understand (I am a math but not a CS major, but have some textbooks like Hopcroft/Ullmann), and I hope that I can get some clarification on this piece.</p>\n", 'Tags': '<complexity-theory><computability><turing-machines>', 'LastEditorUserId': '2775', 'LastActivityDate': '2012-09-12T09:44:18.067', 'CommentCount': '6', 'AcceptedAnswerId': '3488', 'CreationDate': '2012-09-10T11:53:12.470', 'Id': '3487'},4736:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a question and I haven't been able to figure out the answer yet. I need to do the on-line simulation of a two-head tape Turing machine using single-head tape(s). I've found some online articles for the fact that one single-head tape doesn't suffice for this problem and the simulation should be done using two single-head tapes, but I haven't been able to present an accurate simulation of two-head TM using these single-head tapes. Are there any thoughts on how to do so? Thanks,</p>\n", 'ViewCount': '198', 'Title': 'On-line simulation of a two-head tape Turing machine using single-head tape(s)', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T00:40:34.167', 'LastEditDate': '2012-09-13T06:43:33.710', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'Parsa Rastegari', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models><simulation>', 'CreationDate': '2012-09-13T00:29:00.457', 'Id': '3526'},4737:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>It's easy to see how a multi-track Turing machine can simulate a single-track Turing machine; it does so by ignoring all but the first track. But how does it work the other way? I need a specification of a transition function that does the job. If there are $k$ tracks, then we can think of symbols as being vectors and arrange them one after another in the tape; but again, what's the transition function like in the equivalent single-track machine?</p>\n", 'ViewCount': '399', 'Title': 'How does a single-track Turing machine simulate a multi-track Turing machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-14T23:20:23.407', 'LastEditDate': '2012-09-13T12:38:47.133', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '3552', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<computability><turing-machines><simulation>', 'CreationDate': '2012-09-13T11:25:55.437', 'Id': '3529'},4738:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is a Turing Machine that is allowed to read and write symbols from an infinite alphabet more powerful than a regular TM (that is the only difference, the machine still has a finite number of states)?</p>\n\n<p>Intuition tells me not, since you need an infinite number of states to differentiate each symbol. So I think some of the symbols or the transitions caused by the symbols (or some subsets of the transitions) have to be equivalent. So you can actually simulate such machine with a regular TM and a bounded subset of such symbols or transitions.</p>\n\n<p>How could I approach a formal proof of this?</p>\n', 'ViewCount': '414', 'Title': 'Infinite alphabet Turing Machine', 'LastActivityDate': '2012-09-28T13:35:38.480', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '3534', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1451', 'Tags': '<computability><turing-machines><reductions><simulation>', 'CreationDate': '2012-09-13T23:01:24.267', 'Id': '3533'},4739:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Does accepting mean that the TM will read and recognize a char from the cell it's currently reading from? And is it the case that a TM halts iff the input is decidable?</p>\n", 'ViewCount': '548', 'Title': 'What is the difference between halting, accepting, and deciding in the context of Turing machines?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T13:08:49.083', 'LastEditDate': '2012-09-15T13:08:49.083', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '3556', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2835', 'Tags': '<terminology><turing-machines><undecidability>', 'CreationDate': '2012-09-15T01:49:13.377', 'Id': '3554'},4740:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'d like to understand what approaches should one adopt when deciding/proving that a given function <em>F</em> is uncomputable, by any Turing Machine (TM). The ones I\'ve tried so far are as follows:</p>\n\n<ul>\n<li>Reduction, from a known uncomputable function (such as $UC(\\alpha)$, the uncomputable function as proved by Cantor\'s diagonalization argument in Chapter 1 of the book "Computational Complexity" by Sanjeev Arora and Boaz Barak, or $HALT(\\alpha, x)$, which is nothing but the function in the <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="nofollow">Halting problem</a>), to <em>F</em>. If such a reduction is possible, it can be argued that <em>F</em> is uncomputable as otherwise, the problems that are proved to be uncomputable would become be computable as well.</li>\n<li>Proof by contradiction, in which one shows that if there is a TM <em>M</em> that computes <em>F</em>, it would lead to some sort of inconsistency in either the <em>M</em>\'s output, or the functions evaluated value.</li>\n</ul>\n\n<p>I\'ve applied (or rather, tried to apply) both the above techniques to some reductions, two of which I now state here (for illustrating the limitations of my approach):</p>\n\n<blockquote>\n  <ol>\n  <li><p>If whenever a TM <em>M</em> accepts a string <em>w</em> $\\in$ ${\\{0,1\\}}^*$, it also accepts $w^R$, the TM <em>M</em> is said to possess property <em>R</em>. ($w^R$ is the string obtained by reversing $w$ i.e. $(110)^R$ is $011$). Let $R: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: $R(\\alpha) = 1$ if $M_\\alpha$ possesses property $R$, and $R(\\alpha) = 0$ otherwise. Prove that $R$ is uncomputable.</p></li>\n  <li><p>Let $B: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: \n  $B(\\alpha,x) = 1$ if $M_\\alpha$ writes a non-blank symbol on its output tape while computing input $x$, $B(\\alpha,x) = 0$ otherwise. Prove that function $B$ is uncomputable.</p></li>\n  </ol>\n</blockquote>\n\n<p>For problem 1, I tried reducing the uncomputable function $UC$ to $R$, but the reason I couldn\'t quite complete the reduction is because $R$ is a property of the Turing Machine, not dependent on any input instance, where $UC$ depends on the output of a specific instance $M_\\alpha(\\alpha)$. Also, for both $R(\\alpha)$ = 0 and $R(\\alpha)$ = 1, it is possible that $M_\\alpha$ can go on indefinitely for some inputs! </p>\n\n<p>For problem 2, I tried reducing the function $HALT$ to $B$ (thus attempting to make a TM that computes $HALT(\\alpha,x)$ by using the output of a TM $M_\\beta$ that computes $B$). But here as in problem 1, <em>it is possible</em> that for both outputs of $M_\\beta(\\alpha,x)$, the TM $M_\\alpha$ may not halt at all on input $x$! </p>\n\n<p>So, I\'m stumped here - I understand intuitively why these functions should be uncomputable (No TM should be able to predict whether another TM would halt/output anything on any possible input), I\'m not quite able to derive a concrete proof! So, I really want to understand what approaches am I missing here, or are there holes in the current approaches that I\'ve tried so far!</p>\n\n<p>Note: For self-containment, I\'m stating what are the functions UC and HALT here as well:</p>\n\n<p>$UC: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$UC(\\alpha) = 0$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ = 1</p>\n\n<p>$UC(\\alpha) = 1$, otherwise.</p>\n\n<p>$HALT: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$HALT(\\alpha, x) = 1$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ halts on input $x$.</p>\n\n<p>$HALT(\\alpha, x) = 0$, otherwise.</p>\n', 'ViewCount': '338', 'Title': 'What approaches are most useful when proving uncomputability of a given function?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-20T12:16:37.440', 'LastEditDate': '2012-09-16T21:19:35.027', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '476', 'Tags': '<computability><turing-machines><proof-techniques><undecidability>', 'CreationDate': '2012-09-16T20:40:29.383', 'FavoriteCount': '1', 'Id': '4577'},4741:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '266', 'Title': 'Time complexity of an enumeration of SUBSET SUM instances', 'LastEditDate': '2012-10-04T17:08:49.840', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>An instance of the <strong><a href="http://en.wikipedia.org/wiki/Subset_sum_problem" rel="nofollow">SUBSET SUM</a></strong> problem (given $y$ and $A = \\{x_1,...,x_n\\}$ is there a non-empty subset of $A$ whose sum is $y$) can be represented on a one-tape Turing Machine with a list of comma separated numbers in binary format.\nIf $\\Sigma = \\{0,1,\\#\\}$ a reasonable format could be:</p>\n\n<p>$( 1 \\; (0|1)^* \\; \\#)^* \\#$</p>\n\n<p>Where the first required argument is the value $y$ and $\\#\\#$ encodes the end of the input. For example:</p>\n\n<pre><code> 1  0  0  #  1  0  #  1  #  #\n^^^^^^^^     ^^^^     ^\n   y          x1     x2\nInstance: y=4, A={2,1}\n</code></pre>\n\n<p>I would like to enumerate the SUBSET SUM instances.</p>\n\n<blockquote>\n<b>Question</b>: What is the (best) time complexity that can be achieved by a Turing Machine $TM_{Enum}$ that on input $m$ (which can be represented on the tape with a string of size $\\log m + 1$) - outputs the $m$-th SUBSET SUM instance in the above format?\n</blockquote>\n\n<p><strong>EDIT</strong>:</p>\n\n<p>Yuval\'s answer is fine, this is only a longer explanation.</p>\n\n<p>Without loss of  generality we set that $y &gt; 0$ and $0 &lt; x_1 \\leq x_2 \\leq ...  \\leq x_n$, $n \\geq 0$</p>\n\n<p>And we can represent an instance of subset sum using this encoding:</p>\n\n<p>$y \\# x_1\\# d_2\\# ...\\# d_{n} \\#\\#$ where $d_i \\geq 1, x_i = x_{i-1} + d_i - 1 \\; , i \\geq 2$</p>\n\n<p>Using a binary representation for $y,x_1, d_2, d_3, ...$ we have the following representation:</p>\n\n<p>$1 \\; ((0|1)^* \\# 1)^* \\; \\#\\#$</p>\n\n<p>Equivalent to $1 \\; (0|1|\\#1)^* \\; \\#\\#$. There is always a leading 1 and a trailing ## so we can consider only the $(0|1|\\#1)^*$ part.</p>\n\n<p>So the decoder TM on input $m$ in binary format should:</p>\n\n<ul>\n<li>output the leading 1</li>\n<li>convert $m$ to base 3 mapping digit 2 to $\\#1$</li>\n<li>when outputing the i-th intermediate $\\#$ calculate $x_i = d_i + x_{i-1}-1$</li>\n<li>output the trailing $\\#\\#$</li>\n</ul>\n\n<p>No duplicate instances are generated.</p>\n', 'Tags': '<algorithms><formal-languages><turing-machines><enumeration>', 'LastEditorUserId': '140', 'LastActivityDate': '2012-10-04T17:08:49.840', 'CommentCount': '7', 'AcceptedAnswerId': '4870', 'CreationDate': '2012-09-29T14:53:22.363', 'Id': '4794'},4742:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to ask how to determine the number of states when designing a Turing machine from the description for a language? For example:</p>\n\n<p>$\\qquad \\displaystyle L = \\{wcw \\mid w \\in \\{0,1\\}^*\\}.$</p>\n\n<p>I mean how to know how many states are there in the set $Q$, with the information from the description of that language. </p>\n', 'ViewCount': '293', 'Title': 'How to calculate the number of states in designing a Turing machine?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-10-02T12:33:15.027', 'LastEditDate': '2012-09-30T00:56:55.650', 'AnswerCount': '3', 'CommentCount': '5', 'Score': '5', 'OwnerDisplayName': 'Chau', 'PostTypeId': '1', 'Tags': '<formal-languages><turing-machines><descriptive-complexity>', 'CreationDate': '2012-09-29T14:26:38.203', 'Id': '4801'},4743:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This looks like a fundamental result but I can't find a resource online that gives an intuitive interpretation of this complexity. Any basic explanation is appreciated.</p>\n", 'ViewCount': '59', 'Title': 'Why does it take $O(f(n)^2)$ to simulate a 3-tape $O(f(n))$-time TM on a 1-tape  TM?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-10T11:43:04.467', 'LastEditDate': '2012-10-10T11:43:04.467', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4996', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2835', 'Tags': '<turing-machines><tape-complexity>', 'CreationDate': '2012-10-10T07:11:10.470', 'Id': '4989'},4744:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '257', 'Title': 'Are all context-sensitive languages decidable?', 'LastEditDate': '2012-10-16T12:12:02.693', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '2', 'Body': '<p>I was going through the <a href="http://en.wikipedia.org/wiki/Context-sensitive_language">Wikipedia definition of <em>context-sensitive language</em></a> and I found this:</p>\n\n<blockquote>\n  <p>Each category of languages is a proper subset of the category directly above it. Any automaton and any grammar in each category has an equivalent automaton or grammar in the category directly above it.</p>\n</blockquote>\n\n<p>I could see that linear-bounded automaton is directly below decider in the article\'s ordering. If this is the case, then that means every computation on a LBA will halt at some point (since every LBA would be a decider). But I feel that there may be some computation which can run on a LBA at the same time never to halt. For example we can write a computation on LBA which would</p>\n\n<ol>\n<li>read the first symbol on the tape and move right;</li>\n<li>read the next symbol and move back left.</li>\n</ol>\n\n<p>This (useless) computation (which is obviously a LB computation) would run indefinitely oscillating left and right and never halt and hence cannot be a decider. Where am I thinking wrong?</p>\n', 'Tags': '<formal-grammars><turing-machines><undecidability><context-sensitive>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-17T06:19:22.953', 'CommentCount': '1', 'AcceptedAnswerId': '6109', 'CreationDate': '2012-10-16T11:57:26.330', 'Id': '6108'},4745:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Does there exist a procedure that determines if a polytime machine prints a certain string, and does so in less time than the machine itself takes to run?</p>\n\n<p>Define a machine $a$ that analyzes another machine $b$, input $i$, and string $r$:</p>\n\n<p>$a(b,i,r) = b(i) \\text{ prints } r$ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $[T_b = O(n^k), k &gt;= 2]$</p>\n\n<p>Is there an $a$ with run-time $T_a \\in o(T_b)$ on all $b,i,r$?</p>\n', 'ViewCount': '89', 'Title': 'determine if a machine prints a certain string in less time than it takes to run the machine itself?', 'LastEditorUserId': '4223', 'LastActivityDate': '2012-11-29T23:05:04.600', 'LastEditDate': '2012-10-17T23:41:16.120', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4223', 'Tags': '<complexity-theory><time-complexity><turing-machines>', 'CreationDate': '2012-10-17T04:15:29.833', 'Id': '6117'},4746:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '338', 'Title': 'If a Language is Non-Recognizable then what about its complement?', 'LastEditDate': '2012-10-19T08:28:33.073', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '1', 'Body': '<p>Is the complement of a Non-Recognizable language</p>\n\n<ol>\n<li>Recognizable</li>\n<li>Non-Recognizable</li>\n<li>May be Recognizable, May be Non-recognizable. I.e cant comment.</li>\n</ol>\n\n<p>A mathematical proof would be of great help since im unable to think of any way to prove this.</p>\n\n<p>I did some research on this and found below examples. Im specifying complement using a "!"</p>\n\n<ol>\n<li>!A(TM) is a non-recognizable language while A(TM) is a recognizable language.</li>\n<li>EQ(TM) is a non-recognizable language and !EQ(TM) is also non-recognizable language</li>\n</ol>\n\n<p>The above two would mean that we simply cant comment on the Recognizability of the complement of non-recognizable language. But I feel that there should be some way to prove (or disprove) this.</p>\n', 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '2137', 'LastActivityDate': '2012-10-19T09:45:19.683', 'CommentCount': '0', 'AcceptedAnswerId': '6168', 'CreationDate': '2012-10-19T08:04:00.140', 'Id': '6167'},4747:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that we can visualize a Non deterministic TM as a TM which splits into multiple copies of itself whenever it sees a non deterministic path (Yes, I also know that this is just a visualization and is usually used by beginners like me for understanding non determistisism). </p>\n\n<p>Further, I also know that a Decider is a TM that halts on all possible inputs.</p>\n\n<p>Now, my question is how can I visualize a Non determistic Decider? Does a non-determistic decider mean a TM where</p>\n\n<ol>\n<li>All the copies must halt, (OR)</li>\n<li>At-least one copy halts.</li>\n</ol>\n\n<p>Kindly explain in detail why so. Thanks.</p>\n', 'ViewCount': '181', 'Title': 'Visualizing a Non Deterministic Decider', 'LastActivityDate': '2013-06-30T16:13:23.483', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '6257', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2137', 'Tags': '<turing-machines><undecidability><nondeterminism>', 'CreationDate': '2012-10-23T06:42:09.307', 'FavoriteCount': '1', 'Id': '6253'},4748:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was told that quantum computers are not computationally more powerful than Turing machines.\nCould someone kindly help in giving some literature references explaining that fact?</p>\n', 'ViewCount': '217', 'Title': 'References on comparison between quantum computers and Turing machines', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T05:24:51.813', 'LastEditDate': '2012-10-25T11:04:54.370', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4349', 'Tags': '<computability><reference-request><turing-machines><quantum-computing>', 'CreationDate': '2012-10-24T20:44:35.533', 'Id': '6296'},4749:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>$L_0 = \\{ \\langle M, w, 0 \\rangle \\mid \\text{$M$ halts on $w$}\\}$ <br>\n  $L_1 = \\{ \\langle M, w, 1 \\rangle \\mid \\text{$M$ does not halt on  $w$}\\}$</p>\n  \n  <p>$L = L_0 \\cup L_1$</p>\n</blockquote>\n\n<p>I need to determine where in the hierarchy of languages (recursive, recursively enumerable, not recursively enumerable) $L$ and its complement $\\overline L$ belong. I reasoned as follows</p>\n\n<p>$L = \\{ \\langle M, w, x\\rangle  \\mid \\text{$M$ halts on $w$ when $x=0$, $M$ doesn't halt on $w$ when $x = 1$, $x \\in \\{0, 1\\}$}\\}$</p>\n\n<p>$L$ is clearly not recursively enumerable as a Turing machine wouldn't be able accept in all cases.  It can accept only in case the input refers to $L_0$, but can't in case the input refers to $L_1$.</p>\n\n<p>$\\overline L = \\overline L_0 \\cap \\overline L_1 = \\emptyset$<br>\nThus $\\overline L$ is recursive.</p>\n\n<p>Is my reasoning ok? This is a question from a previous exam paper.</p>\n", 'ViewCount': '121', 'Title': 'Determining the classification of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-26T14:27:29.443', 'LastEditDate': '2012-10-26T14:27:29.443', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6310', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><turing-machines><undecidability><halting-problem>', 'CreationDate': '2012-10-25T13:39:53.527', 'Id': '6309'},4750:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '376', 'Title': 'Multitape Turing machines against single tape Turing machines', 'LastEditDate': '2012-10-31T19:13:05.493', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'user7760', 'PostTypeId': '1', 'OwnerUserId': '4409', 'Body': '<p><em>Introduction</em>: I recently learned that a multi-tape Turing Machine $\\text{TM}_k$  is no more "powerful" than a single tape Turing machine $\\text{TM}$. The proof that  $\\text{TM}_k \\equiv \\text{TM}$ is based on the idea that a $\\text{TM}$ can simulate a $\\text{TM}_k$ by using a unique character to separate the respective areas of each of the $k$ tapes.</p>\n\n<p>Given this idea, how would we prove that a process taking $t(n)$ time on a $\\text{TM}_k$ can be simulated by a 2-tape Turing machine $\\text{TM}_2$ with $ O(t(n))\\log(t(n))$ time?</p>\n', 'Tags': '<time-complexity><turing-machines><simulation><tape-complexity>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-31T19:13:05.493', 'CommentCount': '0', 'AcceptedAnswerId': '6387', 'CreationDate': '2012-10-29T21:06:01.913', 'Id': '6385'},4751:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can one show that a machine with a three dimensional memory arranged in an infinite grid can be simulated by a single-tape Turing machine? I'd imagine there's some sort of mapping possible from three dimensional coordinates to single coordinates (eg. (0,0,0) -> 0, (1,0,0) -> 1, (-1,0,0) -> 2, ...) but I can't figure it out. Or maybe there's some clever way to separate the points using special symbols. Either way, I'm at a loss.</p>\n", 'ViewCount': '151', 'Title': 'Robustness of Turing Machines - 3 dimensional case', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-03T16:59:08.593', 'LastEditDate': '2012-11-03T05:45:57.907', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'Sebastian', 'PostTypeId': '1', 'Tags': '<turing-machines><simulation><machine-models>', 'CreationDate': '2012-11-02T00:06:38.447', 'Id': '6454'},4752:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/Unrestricted_grammar">this Wikipedia article</a>, unrestricted grammars are equivalent to Turing machines. The article notes that I can convert any Turing machine into an unrestricted grammar, but it only shows how to convert a grammar to a Turing machine.</p>\n\n<p>How do I indeed do that and convert the Turing machine the recognizes language $L$ into an unrestricted grammar? I have tried replacing transition rules with grammar rules, but a Turing machine can have many different configurations of states as well...</p>\n', 'ViewCount': '395', 'Title': 'How can I convert the Turing machine the recognizes language $L$ into an unrestricted grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T11:12:41.060', 'LastEditDate': '2012-11-06T10:45:20.903', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6510', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4414', 'Tags': '<formal-grammars><turing-machines><simulation>', 'CreationDate': '2012-11-06T08:24:48.120', 'Id': '6504'},4753:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '101', 'Title': 'Reduction of A_LBA to E_LBA', 'LastEditDate': '2012-11-06T20:48:13.643', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Kevin Stadler', 'PostTypeId': '1', 'OwnerUserId': '4479', 'Body': "<p>I have a rather interesting one to ponder and would love if I could get an answer for it. We were discussing the topic of mapping reduction today in my Computing theory course and I was wondering why this reduction can't exist, $A_{LBA} \\leq_{m} E_{LBA}$, since both of them are linear bound automata (LBAs). I do realize that $E_{LBA}$ is undecidable, $A_{LBA}$ is decidable, and the normal proof uses $A_{TM}$, or $E_{TM}$, to prove the undecidibility of $E_{LBA}$. I am just curious why the proof is using a TM to prove an LBA. But, my Professor could not come up with a solution to my confusion. I was wondering is this possible, if so, why or why not.</p>\n\n<p><strong>Definitions:</strong></p>\n\n<p>$A_{LBA} = \\{\\langle M, w\\rangle \\mid \\text{$M$ is a linear bound automaton that accepts the string $w$}\\}$</p>\n\n<p>$E_{LBA} = \\{\\langle M \\rangle \\mid \\text{$M$ is a linear bound automaton with $L(M)=\\emptyset$}\\}$</p>\n\n<p>$A_{TM}$ and $E_{TM}$ are the equivalent problems for Turing Machines.</p>\n", 'Tags': '<computability><turing-machines><reductions><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T20:48:13.643', 'CommentCount': '0', 'AcceptedAnswerId': '6516', 'CreationDate': '2012-11-06T05:19:27.213', 'Id': '6515'},4754:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '209', 'Title': 'Mathematical model on which current computers are built', 'LastEditDate': '2012-11-07T10:38:26.373', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Body': '<p>It is said that "The Turing machine is not intended as practical computing technology, but rather as a hypothetical device representing a computing machine. Turing machines help computer scientists understand the limits of mechanical computation." [Wikipedia]</p>\n\n<p>So on which model current machines are built?</p>\n', 'Tags': '<turing-machines><computer-architecture><machine-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-08T00:47:15.140', 'CommentCount': '0', 'AcceptedAnswerId': '6530', 'CreationDate': '2012-11-07T01:50:09.030', 'Id': '6528'},4755:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a book that proves the halting problem with this simple statement:</p>\n\n<p>$$\nA_\\text{TM} \\le_m  \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon\n$$</p>\n\n<p>It states that halting problem reduces to the language consisting of $\\langle M, \\omega \\rangle$ for which a Turing machine $M$ accepts $\\omega$ is undecidable.</p>\n\n<p>What does this mean? What does the notation $\\le_m$ indicate?</p>\n', 'ViewCount': '88', 'Title': 'Why does $A_\\text{TM} \\le_m \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon$?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-12T09:28:48.157', 'LastEditDate': '2012-11-07T20:47:20.573', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '7902', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-11-07T19:55:12.923', 'Id': '6541'},4756:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '141', 'LastEditorDisplayName': 'user3115', 'Title': "Prove multiple cell move instructions don't increase power of Turing Machines", 'LastEditDate': '2012-12-12T19:14:23.357', 'AnswerCount': '1', 'Score': '6', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Body': '<p>How can you prove that multiple-cell-move instructions, for example (X, Y, 5R) and (X, Y, 17L), do not increase the power of a Turing Machine? </p>\n\n<p>Thanks</p>\n', 'Tags': '<turing-machines>', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T19:14:23.357', 'CommentCount': '0', 'AcceptedAnswerId': '6674', 'CreationDate': '2012-11-15T07:08:48.130', 'Id': '6672'},4757:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>A TM to accept EVEN-EVEN (a collection of all strings with an even number of a\'s and an even number of b\'s) can be based on the algorithm:</p>\n\n<ol>\n<li>Move up the string, changing a\u2019s to A\u2019s</li>\n<li>Move down the string, changing b\u2019s to B\u2019s</li>\n</ol>\n\n<p>Modified algorithm: To avoid the problem of crashing on the way down the $Tape$, change the letter in the first cell to an $X$ (if it\'s an $a$) and to a $Y$ (if it\'s a $b$). This way we can recognize the left end of the tape.</p>\n\n<p>So far I have this but am not sure how to implement the modified algorithm (note: the e\'s from start to halt mean empty):</p>\n\n<p><img src="http://i.stack.imgur.com/kRj3F.png" alt="enter image description here"></p>\n\n<p>Any help is appreciated!</p>\n', 'ViewCount': '1104', 'LastEditorDisplayName': 'user3115', 'Title': 'How to draw a Turing Machine for Even-Even', 'LastActivityDate': '2013-01-16T02:44:55.000', 'LastEditDate': '2012-11-20T07:48:06.520', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<turing-machines>', 'CreationDate': '2012-11-20T04:07:46.247', 'Id': '6778'},4758:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '659', 'Title': u'G\xf6delization in Turing Machine', 'LastEditDate': '2012-11-25T07:38:35.780', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': u"<p>I was looking at G\xf6delization in Theory of Computation course. I could understand the G\xf6del numbering concepts, but couldn't understand its importance in Theory of Computation. Could anyone please point to some good materials or point out its importance.</p>\n", 'Tags': '<formal-languages><turing-machines>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-25T15:51:21.857', 'CommentCount': '0', 'AcceptedAnswerId': '6889', 'CreationDate': '2012-11-25T07:12:46.033', 'Id': '6883'},4759:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following property of recursively enumberable (RE) languages </p>\n\n<p>$$ L = \\{ J \\in \\text{RE} \\mid J \\cap L_{uni} \\ne \\emptyset \\}$$</p>\n\n<p>where $L_{uni}$ is the language of the Universal Turing machine.</p>\n\n<p>I am wondering if $L$ is semi-decidable. That is (by definition) if the set $$ S = \\{ \\langle T \\rangle \\mid L(T) \\in L\\}$$ is recursively enumerable.</p>\n\n<p>If I am not mistaken then this should be true because one can always construct a Turing machine $M$ that accepts a code $\\langle T \\rangle$ and  (using non-determinism) generates the "right" input for $T$ and $T_{uni}$, verifies that both accept the generated word (simulating the machines) and if so accepts the supplied string.</p>\n\n<p>Can someone verify this claim?</p>\n', 'ViewCount': '144', 'Title': 'Question about a semi-decidable property of languages', 'LastEditorUserId': '5180', 'LastActivityDate': '2013-02-03T12:26:24.057', 'LastEditDate': '2013-02-03T09:34:52.777', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4766', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-11-27T19:47:27.383', 'Id': '6964'},4760:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading Papadimitriou, Computational Complexity, page 24, where it is says </p>\n\n<blockquote>\n  <p>We say that $M$ accepts $L$ whenever for any string $x \\in (\\Sigma - \\{\\sqcup\\})^*$, if $x \\in L$, then $M(x) =$ ``yes\'\'; however, if $x\\notin L$, then $M(x) = \\nearrow$. </p>\n</blockquote>\n\n<p>The key issue is what happens for $x \\notin L$. This definition insists that $M$ must not halt for $x \\notin L$. Other sources I read, e.g., <a href="http://books.google.com/books?id=VQpJuiD3mHQC&amp;lpg=PA27&amp;dq=turing%20machine%20accepts&amp;pg=PA27#v=onepage&amp;q=turing%20machine%20accepts&amp;f=false" rel="nofollow">this</a> says that  if $x\\notin L$ then either $M$ does not halt, or $M$ halts at ``no\'\'. </p>\n\n<p>Prima facie this seems to me to be a significant difference. Could someone clarify to me if these definitions are equivalent and if there is no loss of generality in talking of acceptance in the sense of Papadimitriou? Or is only one of these definitions the correct one?</p>\n', 'ViewCount': '125', 'Title': 'Conflicting definitions of language accepted by Turing Machine?', 'LastEditorUserId': '1442', 'LastActivityDate': '2012-11-30T00:18:24.437', 'LastEditDate': '2012-11-29T21:10:14.513', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7027', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1442', 'Tags': '<reference-request><turing-machines>', 'CreationDate': '2012-11-29T19:40:18.567', 'Id': '7025'},4761:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Apparently, for every k-tape Turing machine that runs in time $O(t(n))$, there exists a 1-tape Turing machine that runs in $O(t^2(n))$.</p>\n\n<p>I can see how any multi-tape machine $M$ can be simulated by a 1-tape machine $S$. Just have the tape of $S$ contain all of $M$'s tapes separated by some symbol such as #.</p>\n\n<p>However, why is the running time of $S$ $O(t^2(n))$ if the running time of $M$ is $O(t(n))$? I think it would be $O(t^k(n))$ since there exist $k$ tapes, and we have to traverse through all of them.</p>\n", 'ViewCount': '296', 'Title': 'Why is it that every k-tape Turing machine has a 1-tape TM that runs in $O(t^2(n))$?', 'LastActivityDate': '2012-12-01T00:41:21.647', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7059', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines>', 'CreationDate': '2012-11-30T23:19:00.343', 'Id': '7056'},4762:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have devised the following TM for the language EQUAL. </p>\n\n<p>EQUAL accepts all strings with the same number of a\'s and b\'s. It is context free but non regular. </p>\n\n<p>Using the TM I devised, how can I show that EQUAL is recursive? How can I show that it crashes when the input is not in EQUAL.</p>\n\n<p><img src="http://i.stack.imgur.com/81uEa.png" alt="enter image description here"></p>\n', 'ViewCount': '247', 'LastEditorDisplayName': 'user3115', 'Title': 'Show the Language is Recursive', 'LastActivityDate': '2012-12-02T20:07:52.897', 'LastEditDate': '2012-12-02T19:25:52.953', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7110', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><turing-machines>', 'CreationDate': '2012-12-01T00:44:52.273', 'Id': '7061'},4763:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read of an algorithm that a <a href="http://en.wikipedia.org/wiki/Non-deterministic_Turing_machine" rel="nofollow">non-deterministic Turing machine</a> $N$ can run to determine whether a given graph $G$ has a <a href="http://en.wikipedia.org/wiki/Hamiltonian_path" rel="nofollow">Hamiltonian path</a> from the start node $s$ to a certain node $n$:</p>\n\n<ol>\n<li><p>Write a list of $x$ numbers $p_1, p_2, p_3 ... p_x$, where $x$ is the number of nodes in $G$. Each number in this list is non-deterministically selected to be from 1 to $x$.</p></li>\n<li><p>Check for repetitions in this list. If a repetition exists, reject.</p></li>\n<li><p>Check whether both $s = p_1$ and $n = p_x$. If either do not hold, reject.</p></li>\n<li><p>For each $i \\in [1, x - 1]$, check whether $(p_i, p_{i + 1})$ is an edge of $G$. If any are not, reject.</p></li>\n<li><p>Accept.</p></li>\n</ol>\n\n<p>I do not understand how this algorithm works. Specifically, in step 1, why am I making a list of random (potentially repeating) numbers from 1 to $x$ (What does this list have to do with the nodes of $G$?)?</p>\n\n<p>Likewise, in step 4, why does $(p_i, p_{i + 1})$ represent a potential edge in $G$?</p>\n', 'ViewCount': '220', 'Title': 'How does this non-deterministic algorithm to find if a Hamiltonian path exists work?', 'LastActivityDate': '2012-12-01T03:21:21.020', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7067', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines><nondeterminism>', 'CreationDate': '2012-12-01T02:39:39.353', 'Id': '7065'},4764:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need a clarification related to the following situation.</p>\n\n<p>Consider a Turing machine $T_1$ that halts for every input. In other words $J_1 = L(T_1) \\subseteq \\Sigma^*$ is recursive. Suppose we are given a function $f:\\Sigma^* \\mapsto \\Sigma^*$ and a language $J_2 \\in \\Sigma^*$ such that $$ x \\in J_2 \\iff f(x) \\in J_1.$$</p>\n\n<p>I would assume this readily implies $J_2$ is recursive as well since one can create a Turing machine $T_2$ that on given input $x$ evaluates $y = f(x)$ and simulates $T_2$ on the given input $y.$ Clearly $L(T_2) = J_2.$</p>\n\n<p>What now confuses me is the following.</p>\n\n<blockquote>\n  <p>Are there any restrictions on $f$ for this \'\'reduction\'\' to work?</p>\n</blockquote>\n\n<p>What is the usual approach here? Is $f$ assumed to be given as a black box that always evaluates $f(x)?$ If so could someone explain the motivation behind this, because it appears to me that it could as well be that $f(x)$ cannot be computed effectively and hence $T_2$ cannot be constructed in a "feasible" way.</p>\n\n<p>As for the motivation for the question, I would like to show that given $f:\\Sigma^* \\mapsto \\Sigma^*$ and a recursive language $L,$ the language $f^{-1}(L)$ is recursive as well.</p>\n', 'ViewCount': '95', 'Title': 'Reducing recursive languages', 'LastActivityDate': '2012-12-02T18:41:47.083', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7107', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-12-02T08:21:03.207', 'Id': '7101'},4765:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If we limit a turing machine so that it is not allowed to write the symbol that it reads would it reduce its power?</p>\n\n<p>For example: $( State, A, State, Z, DIRECTION)$</p>\n\n<p>$A$ cannot be the same symbol as $Z$.  </p>\n', 'ViewCount': '188', 'Title': 'Does forcing TMs to change all symbols they read change their power?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-11T22:41:56.343', 'LastEditDate': '2012-12-04T23:16:30.893', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7164', 'Score': '7', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models>', 'CreationDate': '2012-12-04T20:48:56.857', 'Id': '7162'},4766:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Design a program for a Turing machine.</p>\n\n<p>Create a decision procedure for the set of binary strings which contain the same number of 0's and 1's.</p>\n\n<p>Please help! Thanks.</p>\n\n<p>I am a beginner student and have no idea where to start. So sorry for how elementary this is. </p>\n", 'ViewCount': '1888', 'Title': "Turing Machine that Determines whether an equal amount of 1's and 0's have been scanned", 'LastActivityDate': '2012-12-05T17:44:26.100', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4874', 'Tags': '<turing-machines>', 'CreationDate': '2012-12-05T03:32:08.410', 'FavoriteCount': '1', 'Id': '7167'},4767:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm preparing for an exam, and on a sample one provided (without solutions), we have this question: Is the following solvable or non-solvable: Given a turing machine $T$, does it accept a word of even length? - Given a deterministic 1-tape turing machine $T$, does $T$ ever read the contents of the 10th cell?</p>\n\n<p>Thanks! - </p>\n", 'ViewCount': '152', 'Title': 'Solvability of Turing Machines', 'LastActivityDate': '2012-12-07T22:24:42.607', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '7242', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2012-12-07T21:57:26.213', 'Id': '7241'},4768:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I try to figure out linear speed-up of Turing machine.</p>\n\n<p><em>Prove that any problem that can be solved by a two-tape Turing machine that has time complexity t can be solved by another two-tape Turing machine having time complexity $t\u2032$, where $t\u2032(n) = O(n) + (t(n)/2)$.</em></p>\n\n<p>The idea seems to show that what the first machine does within two steps the second machine is capable to do within one step. Time complexity $O(n)$  seems to be complexity of encoding input of first machine to input of second machine.</p>\n\n<p>I have a problem with proving this statement and will appreciate any help.</p>\n\n<p>In addition, why only two-tape Turing machine was mentioned, what about one-tape Turing machine.</p>\n', 'ViewCount': '133', 'Title': 'Speed-up of two-tape Turing machine', 'LastActivityDate': '2012-12-08T11:48:09.560', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7251', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<complexity-theory><turing-machines>', 'CreationDate': '2012-12-08T05:35:16.830', 'Id': '7248'},4769:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In this question we only consider Turing machines that halt on all inputs. If $k \\in \\mathbb{N}$ then by $T_k$ we denote the Turing machine whose code is $k$.</p>\n\n<p>Consider the following function </p>\n\n<p>$$s(x,y) = \\min\\{k \\mid |L(T_k) \\cap \\{x,y\\}| = 1\\}$$</p>\n\n<p>In other words, $s(x,y)$ is the code of the smallest Turing machine that recognizes precisely one of the strings $x,y.$ We can now define the following map</p>\n\n<p>$$d(x,y) = \\left\\{\n    \\begin{array}{ll}\n  2^{-s(x,y)}  &amp; \\mbox{if } x \\ne y, \\\\\n  0 &amp; \\mbox{otherwise.}\n    \\end{array}\n\\right.\n$$</p>\n\n<p>It can be quickly verified that $d(x,y)$ induces a metric space (in fact an ultrametrics) on $\\Sigma^{*}.$</p>\n\n<p>Now I would like to prove that if $f:\\Sigma^{*} \\mapsto \\Sigma^{*}$ is a <a href="http://en.wikipedia.org/wiki/Uniform_continuity">uniformly continuous</a> function then for every recursive language L, $f^{-1}(L)$ is recursive as well. </p>\n\n<p>In other words let $f$ be a map such that for every $\\epsilon &gt; 0$ there is a $\\delta &gt; 0$ such that if for strings $x,y \\in \\Sigma^{*}$ $$\\quad d(x,y) \\leq \\delta$$ then $$ d(f(x),f(y)) &lt; \\epsilon.$$  Then we need to show that $f^{-1}(L)$ is a recursive language given that $L$ is recursive.</p>\n\n<p>Now as already noted in <a href="http://cs.stackexchange.com/questions/7101/reducing-recursive-languages">this</a> post one way to approach the problem is to show that there is a Turing machine that given a string $x \\in \\Sigma^{*}$ computes $f(x).$ </p>\n\n<p>I am stuck proving this claim and slowly wondering if there is some other approach to solve this?</p>\n\n<p>Hints, suggestions and solutions are welcome!</p>\n', 'ViewCount': '226', 'Title': 'An interesting metric space related to Turing machines', 'LastActivityDate': '2012-12-11T05:58:31.013', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7255', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-12-08T13:30:50.157', 'FavoriteCount': '3', 'Id': '7253'},4770:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '311', 'Title': 'Undecidability of the following language', 'LastEditDate': '2012-12-11T04:09:25.933', 'AnswerCount': '3', 'Score': '2', 'OwnerDisplayName': 'muddy', 'PostTypeId': '1', 'OwnerUserId': '5020', 'Body': "<p>So we can prove that the language say $A = \\{ \\langle M,w \\rangle \\mid \\text{M is TM that accepts } w^R \\text{ whenever it accepts } w \\}$ is undecidable by assuming it is decidable and use that to construct a $TM$ deciding $A_{TM}$. So by contradiction $A$ is undecidable. But what if the language was $\\{ \\langle M,w \\rangle \\mid \\text{M accepts } w \\text{ but on input } w^R \\text{halts and rejects} \\}$? </p>\n\n<p>I was thinking to prove that it's r.e, we can construct a Turing recognizer, say $K$, which recognizes this language by simulating $M$ on $w$ and do whatever $M$ does. But how does the machine know what's $w$ and $w^R$? Non determinism maybe? Or am I looking at it the wrong way?</p>\n\n<p>And to prove that it's undecidable would we use the same approach as that for $A$? </p>\n", 'Tags': '<turing-machines><undecidability>', 'LastEditorUserId': '5020', 'LastActivityDate': '2012-12-11T12:26:59.320', 'CommentCount': '2', 'AcceptedAnswerId': '7324', 'CreationDate': '2012-12-09T23:48:05.950', 'Id': '7285'},4771:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1003', 'Title': 'Can there be a perfect chess algorithm?', 'LastEditDate': '2012-12-11T18:37:17.933', 'AnswerCount': '5', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '4947', 'FavoriteCount': '2', 'Body': "<p>Current chess algorithms go about 1 or maybe 2 levels down a tree of possible paths depending on the player's move's and the opponent's moves. Let's say that we have the computing power to develop an algorithm that predicts all possible movements of the opponent in a chess game. An algorithm that has all the possible paths that opponent can take at any given moment depending on the players moves. Can there ever be a perfect chess algorithm that will never lose? Or maybe an algorithm that will always win?\nI mean in theory someone who can predict all the possible moves must be able to find a way to defeat each and every one of them or simply choose a different path if a certain one will effeminately lead him to defeat.....</p>\n\n<p>edit--\nWhat my question really is. Let's say we have the computing power for a perfect algorithm that can play optimally. What happens when the opponent plays with the same optimal algorithm? That also will apply in all 2 player games with finite number (very large or not) of moves. Can there ever be an optimal algorithm that always wins?</p>\n\n<p>Personal definition: An optimal algorithm is a perfect algorithm that always wins... (not one that never loses, but one that always wins</p>\n", 'Tags': '<algorithms><turing-machines>', 'LastEditorUserId': '4947', 'LastActivityDate': '2012-12-14T02:21:57.283', 'CommentCount': '6', 'AcceptedAnswerId': '7335', 'CreationDate': '2012-12-10T20:36:39.337', 'Id': '7313'},4772:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a deterministic Turing machine with an input tape and a work tape. The work tape is restricted to $\\log_2 n+100$ cells ($n$ represents the input length) and its tape alphabet is of size $2006$. Moreover, the Turing machine has $27$  states.</p>\n\n<p>I wonder how come the running time of such machine is $O(n^{1+\\log_2 2006}\\cdot \\log_2n)$ (The answer is the correct choice for this multiple choices question out of an exam I practise)</p>\n', 'ViewCount': '68', 'Title': 'How come this turing machine running time is $O(n^{1+\\log_2 2006}\\cdot \\log_2n)$', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-14T22:12:10.200', 'LastEditDate': '2012-12-14T22:12:10.200', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7399', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<complexity-theory><time-complexity><turing-machines>', 'CreationDate': '2012-12-14T18:55:50.397', 'Id': '7398'},4773:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I find <a href="http://theory.stanford.edu/~trevisan/cs172/ps04.pdf" rel="nofollow">this</a>,\nbut I can\'t complete it, is there any other solution for it?</p>\n', 'ViewCount': '363', 'Title': 'How can I prove that the language of a read-only Turing machines is regular?', 'LastEditorUserId': '3016', 'LastActivityDate': '2012-12-23T07:25:44.860', 'LastEditDate': '2012-12-16T20:00:37.947', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4486', 'Tags': '<regular-languages><turing-machines>', 'CreationDate': '2012-12-15T16:34:01.977', 'Id': '7412'},4774:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '122', 'Title': 'Looking for some more details on "Turing" devices', 'LastEditDate': '2012-12-20T05:57:30.353', 'AnswerCount': '3', 'Score': '0', 'OwnerDisplayName': 'Steel City Hacker', 'PostTypeId': '1', 'OwnerUserId': '5132', 'Body': "<p>I've been reading a lot of computer science literature in the recent past but haven't ran across an explanation of Turing machines, the different types, and why they seem to come up so often (I understand they are a sort of a basis for CS topics).  </p>\n\n<p>I've also seen comments by some members mentioning turing-completeness (Particularly when dealing with programming languages) and was just looking for some clarification.  </p>\n\n<p>I did search around before posting this and haven't been able to find a similar post or a website that describes this in terms that I have been able to understand or decipher.  Thanks.  </p>\n", 'Tags': '<terminology><turing-machines><computation-models><turing-completeness>', 'LastEditorUserId': '3094', 'LastActivityDate': '2012-12-20T05:57:30.353', 'CommentCount': '3', 'AcceptedAnswerId': '7520', 'CreationDate': '2012-12-19T15:33:23.660', 'Id': '7512'},4775:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1710', 'Title': 'Recursive and recursively enumerable language definition for a layman', 'LastEditDate': '2012-12-24T23:01:49.360', 'AnswerCount': '5', 'Score': '2', 'OwnerDisplayName': 'Sampath Kumar Rao', 'PostTypeId': '1', 'OwnerUserId': '5182', 'Body': "<p>I've come across many definitions of recursive and recursively enumerable languages. But I couldn't quite understand what they are .</p>\n\n<p>Can some one please tell me what they are in simple words?</p>\n\n<p>Thanks in advance.</p>\n", 'Tags': '<formal-languages><turing-machines>', 'LastEditorUserId': '3011', 'LastActivityDate': '2014-02-15T04:39:15.940', 'CommentCount': '0', 'AcceptedAnswerId': '7586', 'CreationDate': '2012-12-23T12:56:04.283', 'Id': '7585'},4776:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>First of all sorry, if this question already exists, in that case, pointing to the right direction will be appreciated.</p>\n\n<p>Secondly, sorry, if the question is below the expected level of Niveau, but all help appreciated.</p>\n\n<p>In the textbook by J. Hromkovic, named "Theoretical Computer Science, Introduction to Automata, Computability, Complexity, Algorithmics", in Page 110, in the 2003 edition, i note that the alphabet of a single tape TM which simulates a multitape TM is given by </p>\n\n<p>$$\n\\Gamma_{single\\ tape} = (\\Sigma_{multi\\ tape} \\cup \\{\xa2,\u2423 , $ \\})\\times \\{\\uparrow , \u2423 \\} \\times (\\Gamma_{multi\\ tape}\\cup\\{ \u2423,\\uparrow\\})^{k} \\cup \\Sigma_{multi\\ tape} \\cup \\{\xa2\\}\n$$</p>\n\n<p>should that not be, instead:</p>\n\n<p>$$\n(\\Gamma_{multi\\ tape} \\cup \\{\xa2,\u2423 , $ \\})\\times \\{\\uparrow , \u2423 \\} \\times (\\Gamma_{multi\\ tape}\\cup\\{ \u2423,\\uparrow\\})^{k}  \\cup \\{\xa2\\} ?\n$$ </p>\n\n<p>according to the book, the single tape TM splits its tape in "tracks" , see image i scanned from the book: <a href="http://imgur.com/CwnyS" rel="nofollow">http://imgur.com/CwnyS</a></p>\n\n<p>because, the last $\xa2$ is the primary left end marker, the first two terms of the Cartesian product series is responsible for the top two track, the rest $k$ tracks are constructed by the term which has k in exponent.</p>\n\n<p>all help is appreciated. sorry for the dummy question. i am a meteorologist, who takes his past time in computer programming.</p>\n\n<p>ps, i can neither embed (is that the correct term?) the \xa2 character by \\cent nor the \u2423 by \\textvisiblespace in a post like this. does stackexchange use a different command for those? thank you</p>\n', 'ViewCount': '141', 'Title': 'alphabet of a single tape turing machine that simulates a multitape TM', 'LastActivityDate': '2012-12-26T22:21:22.717', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7609', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5203', 'Tags': '<turing-machines>', 'CreationDate': '2012-12-26T18:12:37.493', 'Id': '7607'},4777:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Why are computable numbers (in Turing's sense) enumerable?\nIt must be very obvious, but I'm currently just not seeing it.</p>\n", 'ViewCount': '107', 'Title': "Why are computable numbers (in Turing's sense) enumerable?", 'LastActivityDate': '2012-12-31T03:51:04.403', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'Michiel Borkent', 'PostTypeId': '1', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-12-30T21:05:23.323', 'Id': '7654'},4778:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Universal_Turing_machine" rel="nofollow">universal Turing machine</a> $U_{TM}$ is a TM that takes in as input an encoding of a TM and a string, then runs the TM on the string and does whatever the simulated TM does.  The language of the universal TM is the set of all encodings of a TM/string pair as a string for which the TM accepts the string.</p>\n\n<p>I have seen several different names for the language of the universal Turing machine.  Michael Sipser refers to it as $A_{TM}$ (the acceptance language for Turing machines), while Hopcroft, Ullman, and Motwani call it $L_u$ (the universal language).</p>\n\n<p>Is the a standardized term for the language of the universal Turing machine?  I would understand if there might be many "universal Turing machines" that vary in their encoding schemes, so if the answer is "no, there is no general term for this" that would be good to know.  I\'m mostly asking because I\'m teaching an introductory course in the theory of computation and have been using the term $A_{TM}$ for this without knowing if there is a better term to use.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '256', 'Title': 'Standard notation for the language of the universal Turing machine?', 'LastActivityDate': '2013-01-02T07:46:58.950', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7688', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><terminology><turing-machines>', 'CreationDate': '2013-01-02T05:30:33.547', 'Id': '7687'},4779:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read many things about the Turing machine and understand how it works but what I can\'t get the grasp of (and what none of the books seem to try to teach) is how should I approach a problem I am given to solve? I mean: checking if a word is a palindrome, for example, consists of 11 states in the book I\'m learning from. For my current state of knowledge, just sitting over an empty sheet of paper and coming up with all these states seems next to impossible, to say the least. When I try to do something like this, I get stuck immediately since I don\'t know what should I do to make these states work somehow "together". I don\'t have such problems when programming in some prog languages but here, I just can\'t figure out how I should approach something consisting of some n-teen states. Could you please point me some direction to learn about it?</p>\n', 'ViewCount': '600', 'Title': 'Turing machine and coming up with an idea', 'LastActivityDate': '2013-01-03T00:51:58.260', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '7712', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5281', 'Tags': '<turing-machines>', 'CreationDate': '2013-01-02T22:40:09.093', 'Id': '7708'},4780:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '140', 'Title': 'Decision problem and algorithm', 'LastEditDate': '2013-01-05T12:41:30.573', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was reading about decision problem. I understand that decision problem tell yes/no answer for an input. The decision is based on a decision procedure also called an algorithm. </p>\n\n<p>The wikipedia says that </p>\n\n<blockquote>\n  <p>It is traditional to define the decision problem equivalently as: the set of inputs for which the problem returns yes.</p>\n  \n  <p>These inputs can be natural numbers, but may also be values of some other kind, such as strings over the binary alphabet $\\{0,1\\}$ or over some other finite set of symbols. The subset of strings for which the problem returns "yes" is a formal language, and often decision problems are defined in this way as formal languages.</p>\n</blockquote>\n\n<p>Whether I can take it like algorithm written in a programming language defines the set of all possibilities and gives the output based on the input?</p>\n\n<p>So in computability theory, the problem should be encoded to some form? Is this same thing as the input tape and configuration of a Turing machine (set of 0\'s and 1\'s )?</p>\n', 'Tags': '<computability><turing-machines><undecidability><decision-problem>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-05T14:46:26.633', 'CommentCount': '0', 'AcceptedAnswerId': '7790', 'CreationDate': '2013-01-05T12:27:42.627', 'Id': '7786'},4781:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I wonder if there is a simple example of sets $A$ and $B$ such that $A$ is Turing-reductible to $B$ but not many-to-one reductible to $B$.</p>\n', 'ViewCount': '155', 'Title': 'Is there a simple example of sets such that $A \\leq_T B$ but not $A \\leq_m B$?', 'LastActivityDate': '2013-01-07T04:55:17.633', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7803', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2069', 'Tags': '<turing-machines><reductions>', 'CreationDate': '2013-01-06T10:07:29.000', 'Id': '7801'},4782:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need to design a Turing Machine that accepts the (context-free) language: $L(M)=\\{0^{n}1^{n+1}: n\\ge1$}.</p>\n\n<p>$$Q=\\{q_0,q_1,q_2,q_3,q_4\\} ,\u03a3 = \\{0,1\\}, \u0393 =\\{0,1,X,Y,B\\}, F=\\{q_4\\}$$</p>\n\n<p>X- processed 0<br>\nY- processed 1<br>\nB- blank<br>\nP-move right<br>\nL-move left<br>\nSo far I\'ve succeeded to create a table for languages $\\{0^n1^n\\}$(without the red entry) and $\\{0^n1^k:k\\ge n\\}$.</p>\n\n<p><img src="http://i.stack.imgur.com/NNJCd.jpg" alt="&quot;P&quot; means the right side"></p>\n\n<p>What should it look for case in which there is minimal superiority of "1\'s"?</p>\n\n<p>@EDIT</p>\n\n<p>Meanwhile I\'ve finally hit on an idea for <strong>L(M)</strong></p>\n\n<p><img src="http://i.stack.imgur.com/sly5h.jpg" alt="enter image description here">Is it correct?</p>\n', 'ViewCount': '79', 'Title': 'Design the transition function', 'LastEditorUserId': '5206', 'LastActivityDate': '2013-01-11T16:16:58.327', 'LastEditDate': '2013-01-11T16:16:58.327', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5206', 'Tags': '<automata><turing-machines>', 'CreationDate': '2013-01-10T21:00:40.590', 'Id': '7877'},4783:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was reading about counting principle related to TOC. I understand that the set of TMs are countable infinity. I couldn't understand the significance of it. What is its not countable?</p>\n", 'ViewCount': '129', 'Title': "If set of TM's is not countable?", 'LastEditorUserId': '947', 'LastActivityDate': '2013-01-27T03:55:56.253', 'LastEditDate': '2013-01-13T07:37:55.000', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<computability><turing-machines><uncountability><church-turing-thesis>', 'CreationDate': '2013-01-13T06:49:46.727', 'Id': '7915'},4784:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm not sure if this statement is correct, but my friend said so.</p>\n\n<p>The problem arose from this T/F question:\nLet $F=\\{f: f$ be a primitive recursive function from $\\mathbb{N}$ to $\\mathbb{N}\\}$, then $2^F$ (Power set of $F$) is uncountable.</p>\n\n<p>And its answer is True. The set of primitive recursive functions is countable, and I would like to know the proof to the statement above...I believe I've seen it somewhere in the book but can't find it now.</p>\n\n<p>Thank you for your time.</p>\n", 'ViewCount': '95', 'Title': 'How to prove "The power set of a countable set must be uncountable"?', 'LastActivityDate': '2013-01-17T12:28:11.867', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '8987', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<turing-machines><recursion><uncountability>', 'CreationDate': '2013-01-17T12:17:47.200', 'Id': '8986'},4785:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '146', 'Title': 'Faster growing busy beaver function', 'LastEditDate': '2013-01-21T11:19:52.540', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '6472', 'FavoriteCount': '1', 'Body': "<p>Standard busy beaver function draws attention to final count of nonzero symbols on tape. We could instead look at largest amount of nonzero symbols appearing on tape at <em>any</em> point of computation. This function's lower bound would be $\\Sigma(n)$ and upper bound would be $S(n)$ (max shifts function). Was there made any research on such functions? If so, are there any known values for this?</p>\n", 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-11T16:00:37.653', 'CommentCount': '1', 'AcceptedAnswerId': '9032', 'CreationDate': '2013-01-18T15:27:29.833', 'Id': '9031'},4786:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it possible to design a Universal Turing Machine in which the simulation time of a given Turing Machine $M$ is bounded by a factor of $\\mathcal{O}(\\log|\\Gamma|+\\log|Q|)$ of the original running-time of $M$, where $\\Gamma$ and $Q$ are the tape alphabet and states of $M$ respectively?</p>\n\n<p>If so, how can this be done?</p>\n', 'ViewCount': '196', 'Title': 'Universal Turing Machine simulation with bounded time overhead', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-30T04:28:32.270', 'LastEditDate': '2013-01-30T04:28:32.270', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '6522', 'Tags': '<complexity-theory><turing-machines>', 'CreationDate': '2013-01-23T16:10:18.437', 'Id': '9115'},4787:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '218', 'Title': 'Is there a single valid definition for a Turing Machine, or is it mutable?', 'LastEditDate': '2013-01-26T18:06:44.223', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6569', 'FavoriteCount': '1', 'Body': '<p>I\'m just learning about Turing Machines, and I\'m a bit confused by the difference in formal description between Wikipedia and my textbook.</p>\n\n<p>My textbook says the following:</p>\n\n<p>$$M=\\langle Q,\\Sigma,\\Gamma,\\delta,q_{0},q_{accept}, q_{reject} \\rangle$$</p>\n\n<p>where:</p>\n\n<ol>\n<li>$Q$ is the set of states,</li>\n<li>$\\Sigma$ is the input alphabet not containing the blank symbol $\\sqcup$,</li>\n<li>$\\Gamma$ is the tape alphabet, where $\\sqcup\\in\\Gamma$ and $\\Sigma\\subseteq\\Gamma$,</li>\n<li>$\\delta: Q\\times\\Gamma\\to Q\\times\\Gamma\\times\\{L,R\\}$ is the transition function,</li>\n<li>$q_0\\in Q$ is the start state,</li>\n<li>$q_{accept},q_{reject}\\in Q$ are the accepting and rejecting states, respectively, and $q_{accept}\\neq q_{reject}$</li>\n</ol>\n\n<p>While Wikipedia states </p>\n\n<blockquote>\n  <p>Hopcroft and Ullman (1979, p. 148) formally define a (one-tape) Turing machine as a 7-tuple $M= \\langle Q, \\Gamma, b, \\Sigma, \\delta, q_0, F \\rangle$ where</p>\n  \n  <ul>\n  <li>$Q$ is a finite, non-empty set of states</li>\n  <li>$\\Gamma$ is a finite, non-empty set of the tape alphabet/symbols</li>\n  <li>$b \\in \\Gamma$ is the blank symbol (the only symbol allowed to occur on the tape infinitely often at any step during the computation)</li>\n  <li>$\\Sigma\\subseteq\\Gamma\\setminus\\{b\\}$ is the set of input symbols</li>\n  <li>$q_0 \\in Q$ is the initial state</li>\n  <li>$F \\subseteq Q$ is the set of final or accepting states.</li>\n  <li>$\\delta: Q \\setminus F \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{L,R\\}$ is a partial function called the transition function, where L is left shift, R is right shift. (A relatively uncommon variant allows "no shift", say N, as a third element of the latter set.)</li>\n  </ul>\n</blockquote>\n\n<p>There are obviously a few similarities, but there are a few differences as well. Namely the ordering of the items in the 7-tuple $M$. Also, my textbook has three entries for separate special states, and the Wikipedia entry has only two - My book doesn\'t have a special element just for the blank character.</p>\n', 'Tags': '<terminology><turing-machines>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-29T16:46:03.947', 'CommentCount': '0', 'AcceptedAnswerId': '9169', 'CreationDate': '2013-01-26T15:29:26.307', 'Id': '9168'},4788:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': "Where can I find a short and 'easy' peer reviewed paper on something from computability, decidability or complexity?", 'LastEditDate': '2013-01-26T20:49:07.570', 'AnswerCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6572', 'FavoriteCount': '2', 'Body': "<p>It's a homework assignment, we were asked to read, understand, and present to our colleagues a short paper/article (suggested 4-6 pages) for our Computability, Decidability or Complexity class.</p>\n\n<p>The articles I was able to find in the past couple days using google scholar a way over what we were taught, plus, 50-100+ pages is way over the scope of my assignment. In class, we were provided with an introduction to the three topics, complexity classes, relations between them, and (mostly informal) proofs for the most representative problems from each class by modelling them using all kinds of Turing Machines.</p>\n\n<p>Any possible solutions? It's the first time in my life I'm touching anything related to research, I can barely understand even the scope of most papers I find.. I guess any advice would be welcome.</p>\n", 'Tags': '<complexity-theory><computability><turing-machines><research>', 'LastEditorUserId': '6572', 'LastActivityDate': '2013-01-30T15:17:09.530', 'CommentCount': '0', 'AcceptedAnswerId': '9179', 'CreationDate': '2013-01-26T20:36:18.643', 'Id': '9178'},4789:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Frankly I'm very uncomfortable with the material right now. There are some things I can understand, but many I still do not.</p>\n\n<p>My first assignment is asking me in one question (which I do know how to do) to give a full description of a TM that accepts a language $L = \\{ x \\in \\{0,1\\}^* \\mid x \\text{ is divisible by } 4 \\}$.  I know that any binary string ending with $00$ is divisible by 4, so $\\{00,100,1100,1000,11100,11000,10100,10000,\\dots\\}$ is the language that this TM accepts.</p>\n\n<p>But on the topic of (un)decidability:  I know that a language is decidable if there exists a TM that accepts all strings in, and only strings from that language &mdash; and that same TM rejects all strings and only strings not in that language.</p>\n\n<p>Which leads to the question:  What is the difference between a Turing machine <em>accepting</em> and <em>deciding</em> a language?</p>\n", 'ViewCount': '179', 'Title': 'What is the difference between a TM accepting and deciding a language?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-01-28T14:35:48.290', 'LastEditDate': '2013-01-28T09:52:54.037', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '9247', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2013-01-28T02:15:33.753', 'Id': '9234'},4790:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So say I have a task like this:</p>\n\n<blockquote>\n  <p>Construct a Turing machine transforming the word u to the word v byt\n  removing all the sequences of form "ba" from the word u. Input\n  alphabet = {a,b,c}. </p>\n  \n  <p>Example: for IN cabbaacba, OUT cac.</p>\n</blockquote>\n\n<p>And my problem always is: can I leave blank characters in place of "ba" sequences in tasks like this so that in the end, I have something like $ca \\Phi \\Phi \\Phi \\Phi c \\Phi \\Phi$ on the tape or do I have to work on the tape in such a way that I end up with, for example "cac", written consecutively, without blanks?</p>\n', 'ViewCount': '54', 'Title': 'Clarification for a class of Turing machine problems', 'LastActivityDate': '2013-01-30T16:26:46.157', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '9316', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5281', 'Tags': '<turing-machines>', 'CreationDate': '2013-01-30T13:25:23.467', 'Id': '9306'},4791:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I'm doing some exercises with Turing machine and quite often it happens that a given set of states can be achieved if and only if some character was met. Therefore, we may have some states q3-q7 which the machine may be pointed to if and only if we spotted a and (because of the task spec, for example), we know that we may find only some chars (say b, d but not c, e) from the input language there so there's no need to have a separate state for every symbol. Can I then just program the states I'll actually use there and have some void states or do I have to put something there (like just reprinting the found character) anyway, even though I'm 100% sure the machine will never go to the state for some symbols?</p>\n", 'ViewCount': '42', 'Title': 'Are you allowed to have empty states on Turing machine?', 'LastActivityDate': '2013-01-30T19:54:52.387', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '9326', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5281', 'Tags': '<turing-machines>', 'CreationDate': '2013-01-30T17:05:20.623', 'Id': '9318'},4792:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose that I have a turing machine that receives as input the string $1^{n\\times n}$ (unary input), what is the time complexity of writing $p_1,...,p_n$ on the output tape, where $p_i$ is the i-th prime number (written in binary)? And writing the first $n$ primes  followed by their product (all written in binary)?</p>\n', 'ViewCount': '130', 'Title': 'Time complexity of generating the first n primes and their product', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-19T05:24:50.567', 'LastEditDate': '2013-01-30T20:59:19.290', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '9922', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6638', 'Tags': '<time-complexity><turing-machines>', 'CreationDate': '2013-01-30T20:31:30.967', 'Id': '9330'},4793:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am an electrical engineer, and only had one CS course in college 26 years ago. However, I am also a devoted Mathematica user.</p>\n\n<p>I have the sense that Turing Machines are very important in computer science. Is the importance only in the theory of computer science? If there are practical implications/applications what are some of them?</p>\n', 'ViewCount': '1251', 'Title': 'Practical importance of Turing machines?', 'LastActivityDate': '2013-12-23T19:45:47.950', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '6640', 'Tags': '<turing-machines>', 'CreationDate': '2013-01-31T02:07:21.367', 'FavoriteCount': '2', 'Id': '9341'},4794:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>This is one of my assignments. I am not able to comprehend how to reduce the Turing machine domain to Classical planning domain. My understanding is that we have to essentially perform complexity analysis of classical planning domain. So I have defined these two languages </p>\n\n<p>a)  PLAN-EXISTENCE(D) = {P : P is the statement of a planning problem that has a solution}</p>\n\n<p>b)  PLAN-LENGTH(D) = {(P,n) : P is the statement of a planning problem that has a  solution that contains no more than n actions (length \u2264 n) }</p>\n\n<p>And then I proceed to prove that both these are decidable in classical planning domain. </p>\n\n<p>Is this the correct approach? Please help me  </p>\n', 'ViewCount': '130', 'Title': 'Show that the Turing Machine domain can be viewed as a classical planning domain', 'LastActivityDate': '2013-02-07T19:14:31.263', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9579', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6754', 'Tags': '<complexity-theory><turing-machines><artificial-intelligence>', 'CreationDate': '2013-02-07T13:18:46.983', 'Id': '9573'},4795:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Since TMs are equivalent to algorithms, they must be able to perform algoriths like, say, mergesort. But the formal definition allows only for decision problems, i.e, acceptance of languages. So how can we cast the performance of mergesort as a decision problem?</p>\n', 'ViewCount': '233', 'Title': 'Can Turing Machines solve non-decision problems?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T17:29:15.447', 'LastEditDate': '2013-02-08T08:36:14.007', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'shilka', 'PostTypeId': '1', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2013-02-07T10:46:15.323', 'Id': '9574'},4796:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '334', 'Title': 'P, NP and specialised Turing Machines', 'LastEditDate': '2013-02-08T08:34:13.790', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6769', 'FavoriteCount': '2', 'Body': "<p>I'm sort of new, but very interested to the field of computing and complexity theory, and I want to clarify my understanding about how to class problems, and how strongly the problems relate to the machine being used to solve them.</p>\n\n<p><strong>My Understanding</strong></p>\n\n<ul>\n<li>Standard Turing Machine - a Turing Machine which has a finite alphabet, finite number of states and a single right-infinite tape</li>\n<li>Turing-Equivalent Machine - a Turing Machine which, can emulate, and be emulated by, a Standard Turing Machine (quite often with some trade-off between space and time achieved by the emulation)</li>\n<li><code>P</code> - the class of problems which can be solved in polynomial time using a Standard Turing Machine (defined above)</li>\n<li><code>NP</code> - the class of problems which can be verified in polynomial time using a Standard Turing Machine</li>\n<li><code>NP-complete</code> - the hardest problems which are still in <code>NP</code>, which all <code>NP</code> problems can be converted to in polynomial time</li>\n</ul>\n\n<p><strong>My Question</strong></p>\n\n<p>Are the complexity classes (<code>P</code>, <code>NP</code>, <code>NP-complete</code>, etc) related to the algorithm, or the algorithm and the machine?</p>\n\n<p>Said in another way, if you could create a Turing Equivalent Machine (that can solve all the problems that a Standard TM can, but in a different amount of time/space) and this new machine could solve an <code>NP-complete</code> problem in time which grows as a polynomial with respect to the input, would that imply <code>P=NP</code>?</p>\n\n<p>Or must the <code>NP-complete</code> problem be solvable on all possible Turing Machines in polynomial time to be considered in <code>P</code>?</p>\n\n<p>Or do I mis-understand something fundamental above?</p>\n\n<p>I have had a look (maybe not with the correct search terms, I don't know all the jargon quite well) but it seems most lectures/notes etc. focus on standard machines but say that custom machines often have some time/space speed up at the expense of space/time, without saying how that bears on complexity classes. I'm not really familiar enough with the jargon in this field yet to find papers which explain this.</p>\n", 'Tags': '<complexity-theory><computability><terminology><turing-machines><complexity-classes>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T20:15:58.060', 'CommentCount': '1', 'AcceptedAnswerId': '9593', 'CreationDate': '2013-02-08T02:06:20.137', 'Id': '9585'},4797:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '705', 'Title': 'Why are there more non-computable functions than computable ones?', 'LastEditDate': '2013-02-11T05:56:31.970', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'user1288420', 'PostTypeId': '1', 'OwnerUserId': '6834', 'FavoriteCount': '2', 'Body': "<p>I'm currently reading a book in algorithms and complexity. At the moment I'm, reading about computable and non-computable functions, and my book states that there are many more functions that are non-computable than computable, in fact the majority is non-computable it says. In some sense I can intuitively accept that but the book does not give a formal proof nor does it  elaborate much on the topic.</p>\n\n<p>I just wanted to see a proof/let someone here elaborate about it/understand more strictly why there are so many more non-computable functions than computable ones.</p>\n", 'Tags': '<computability><turing-machines><combinatorics>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-11T05:56:31.970', 'CommentCount': '1', 'AcceptedAnswerId': '9634', 'CreationDate': '2013-02-10T08:57:32.950', 'Id': '9633'},4798:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having trouble understanding a mapping reduction and I would appreciate your help. Define</p>\n\n<p>$\\quad \\begin{align}\n  A_{TM} &amp;= \\{ \\langle M, w \\rangle \\mid M \\text{ Turing machine}, w \\in \\mathcal{L}(M)\\} \\\\\n  S_{TM} &amp;= \\{ \\langle M,w \\rangle \\mid M \\text{ Turing machine}, w \\in \\mathcal{L}(M) \\implies w^R \\in \\mathcal{L}(M)\\} \\\\\n\\end{align}$</p>\n\n<p>and consider the reduction of $A_{TM}$ to $S_{TM}$ as follows.</p>\n\n<p>Given $\\langle M, w \\rangle$ the following Turing machine $M'$ is defined:</p>\n\n<pre><code>M' on input x:  \n  if x = 01 then accept  \n  else run M on w and accept x if M accepts w\n</code></pre>\n\n<p>I don't understand the reduction entirely, this reduction is supposed to solve $S_{TM}$ using $A_{TM}$.  Why do I need to check if <code>x = 01</code>? There is no need to check anything about the reverse of $w$?  How is that covered by the reduction?</p>\n", 'ViewCount': '177', 'Title': 'Mapping reductions for dummies', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-27T06:29:53.117', 'LastEditDate': '2013-03-27T11:59:03.577', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6821', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-02-11T16:15:33.440', 'FavoriteCount': '1', 'Id': '9683'},4799:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '261', 'Title': 'Meaning of the Halting problem', 'LastEditDate': '2013-02-12T10:29:39.797', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '6836', 'FavoriteCount': '3', 'Body': "<p>The Halting Problem is defined as:</p>\n\n<p>$H_{TM} = \\{ \\langle M, w \\rangle \\mid \\text{\\(M\\) halts on input \\(w\\)}\\}$</p>\n\n<p>I'm not sure what it means. Is $H_{TM}$ a collection of Turing Machines such that all of them accept/reject the word $w$? Is that a specific word? Or does that mean any word in their alphabet?</p>\n\n<p>Thanks</p>\n", 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-12T23:33:30.040', 'CommentCount': '2', 'AcceptedAnswerId': '9702', 'CreationDate': '2013-02-12T10:07:51.983', 'Id': '9699'},47100:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a language, how do you go about deciding if it's decidable or not? For example:</p>\n\n<p>Given a DFA $A_0$ and a TM $M_0$</p>\n\n<p>$L_1 = \\{ \\langle M \\rangle \\, | \\, M \\mbox{ is a TM and }L(M) = L(A_0) \\}$</p>\n\n<p>$L_2 = \\{ \\langle A \\rangle \\, | \\, A \\mbox{ is a DFA and }L(A) = L(M_0) \\}$</p>\n\n<p>What's the intuition/process of figuring out if $L_1$, $L_2$ are decidable or not?</p>\n\n<p>This is not homework, $L_1$ is not decidable and $L_2$ is decidable, but I have not idea why, and how to solve this problem and problems similar to it. If you could explain to me the process of doing that you will help a lot.</p>\n", 'ViewCount': '120', 'Title': 'Intuition about decidability', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-18T21:58:40.490', 'LastEditDate': '2013-02-18T21:58:40.490', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '9705', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6836', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-02-12T12:24:34.953', 'Id': '9703'},47101:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm looking at my textbook here from Michael Sipser and he says that a <strong>nondeterministic Turing machine is a decider if all its computation branches halt on all inputs.</strong> I think I recall seeing somewhere what you'd call a nondeterministic Turing machine that halts on at least one branch for all inputs, but may loop on others. Is there a name for such a thing? I see later in this chapter the word <strong>verifier</strong>, but that doesn't seem to fit... I think that refers to an algorithm.</p>\n\n<blockquote>\n  <p>A <strong><em>verifier</em></strong> for a language $A$ is an algorithm $V$, where\n  $$A=\\{w\\mid V\\text{ accepts }\\langle w,c\\rangle\\text{ for some string c}\\}.$$\n  We measure the time of a verifier only in terms of the length of $w$, so a <strong><em>polynomial time verifier</em></strong> runs in polynomial time in the length of $w$. A language $A$ is <strong><em>polynomially verifiable</em></strong> if it has a polynomial time verifier.</p>\n</blockquote>\n", 'ViewCount': '278', 'Title': 'Non-deterministic Turing machine that halts on at least one branches of computation', 'LastEditorUserId': '39', 'LastActivityDate': '2014-01-06T12:20:39.040', 'LastEditDate': '2013-02-12T18:50:22.260', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '9710', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<turing-machines><nondeterminism>', 'CreationDate': '2013-02-12T16:04:55.013', 'Id': '9706'},47102:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '161', 'Title': 'A variant of the busy beaver function', 'LastEditDate': '2013-02-15T08:39:40.037', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>Reading this question "<a href="http://cs.stackexchange.com/questions/9772/natural-re-undecidable-problems-but-not-turing-complete">Natural RE undecidable problems but not Turing-complete</a>" the following language came to my mind:</p>\n\n<p>If $\\Sigma(\\cdot)$ is the busy beaver function (maximum attainable score among all halting 2-symbol n-state Turing machines of the above-described type, when started on a blank tape), define the function:</p>\n\n<p>$$BB(\\langle M \\rangle) = \n\\begin{cases} \n1 &amp; \\text{$\\langle M \\rangle$ computes $\\Sigma(\\cdot)$}\\\\  \n0 &amp; \\text{ otherwise}\n\\end{cases}$$</p>\n\n<p>Now define the language:</p>\n\n<p>$L = \\{ \\langle M \\rangle \\; | \\; \\langle M \\rangle \\mbox{ halts and } BB(\\langle M \\rangle) = 0 \\}$</p>\n\n<blockquote>\n  <p>Is $L$ recursively enumerable? (it should be r.e.: just simulate in parallel M with all TMs of the same length, and if $M$ halts and another $M\'$ halts with a higher score add M to the enumeration).</p>\n  \n  <p>Can we reduce the halting problem to $L$ ? (it seems that it cannot "capture" the halting of the busy beavers)</p>\n</blockquote>\n', 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '140', 'LastActivityDate': '2013-02-15T09:02:42.193', 'CommentCount': '9', 'AcceptedAnswerId': '9796', 'CreationDate': '2013-02-14T18:13:35.677', 'Id': '9780'},47103:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $T$ be a Turing machine whose accepted language is $L(T)$. Let $X$ be another language. How do you approach a proof like $L(T)\\subseteq X?$</p>\n', 'ViewCount': '262', 'Title': 'Proof-sketch on the language accepted by a Turing machine', 'LastEditorUserId': '6989', 'LastActivityDate': '2013-02-23T16:47:28.233', 'LastEditDate': '2013-02-22T22:28:28.367', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10032', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6989', 'Tags': '<formal-languages><turing-machines><proof-techniques>', 'CreationDate': '2013-02-22T22:04:26.177', 'Id': '10031'},47104:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Turing machines and unrestricted grammars are two different formalisms that define the RE languages.  Some RE languages are decidable, but not all are.</p>\n\n<p>We can define the decidable languages with Turing machines by saying that a language is decidable iff there is a TM for the language that halts and accepts all strings in the language and halts and rejects all strings not in the language.  My question is this: <em>is there an analogous definition of decidable languages based on unrestricted grammars rather than Turing machines?</em></p>\n', 'ViewCount': '215', 'Title': 'Decidable languages and unrestricted grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-27T11:29:06.683', 'LastEditDate': '2013-02-27T11:19:06.537', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><turing-machines><formal-grammars>', 'CreationDate': '2013-02-26T17:07:14.603', 'Id': '10124'},47105:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a deterministic finite automaton which behaves mostly like a Turing machine, with following difference (relevant to this question):</p>\n\n<ul>\n<li>The tape is initially finite.</li>\n<li>The automaton can insert and delete cells from the tape.</li>\n<li>Actions are associated with states rather than with transitions (this includes head shift and tape manipulation).</li>\n<li>The automaton has no accepting/final state. The computation is only terminated when the machine exits the tape. The final state of the tape is the machine's output.</li>\n</ul>\n\n<p>I know most of the states in the machine are redudant (equivalent to other states). However the good old DFA minimization algorithm won't work here, because it starts its work on the final states (which I don't have).</p>\n\n<p>The algorithm should be efficiently computable (the machines in question have hundreds of thousands to millions of states).</p>\n\n<p>Is this possible in the general case? Every algorithm I make up fails in some cases.</p>\n", 'ViewCount': '123', 'Title': 'Minimizing Turing machine-like automaton with no final states', 'LastActivityDate': '2013-03-01T15:14:45.800', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10176', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7094', 'Tags': '<turing-machines><automata><finite-automata>', 'CreationDate': '2013-03-01T15:02:56.103', 'Id': '10175'},47106:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I think half the battle in answering this question lies in formulating it precisely! A search engine doesn\'t turn up much, so I was wondering if this is a well-known or well-studied question.</p>\n\n<p>My thoughts: I think the most straightforward way to formulate this question is as in my title: Given constants $t,s,k \\in \\mathbb{N}$, how many TMs are there that run in $t$ steps or fewer on all inputs of size $k$, and how many TMs are there that use $s$ tape squares or fewer on all inputs of size $k$? This seems like the most direct and simple way to ask the question, but we might want to restate it in a different way -- for example, given a function $p(k)$, how many TMs are there that run in time $p(k)$ on inputs of size $k$ for all $k$ (or how "dense" are these TMs)? This seems harder to me.</p>\n\n<p>We should probably fix a tape alphabet (or a Godel numbering??). We could consider two TMs with different but isomorphic state diagrams to be the same or different, either way.</p>\n\n<p>The immediate problem is that there are an infinite number: Take any TM that satisfies the criteria and add "dead states". I can think of two ways to deal with this. The first (which I don\'t like) is to add an additional parameter: how many TMs whose description has length $\\leq L$ satisfy the criteria? The second (which I prefer) is to consider two TMs <em>equivalent</em> on inputs of size $\\leq k$ if, for all such inputs, the TMs have exactly the same behavior (enter the same states and write/move on the tape identically). Then we would restrict to the minimal TM in each equivalence class, or just ask how many equivalence classes satisfy the criteria.</p>\n\n<p>Edit: As pointed out by Vor in the comments, the problem with the second approach is that it\'s basically the same as a circuit at that point. So how about the first one? Or is there a nicer way to formalize this question?</p>\n\n<p>Any references/literature, thoughts, or answers would be very interesting and appreciated!</p>\n', 'ViewCount': '129', 'Title': 'How many Turing Machines are there that run in time $t$ or in space $s$ on inputs of length $k$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-07T12:15:33.460', 'LastEditDate': '2013-03-06T07:13:07.320', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4197', 'Tags': '<complexity-theory><reference-request><turing-machines><combinatorics>', 'CreationDate': '2013-03-05T17:46:58.547', 'Id': '10298'},47107:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '511', 'Title': 'What is the exact relation between programming languages and Turing machines?', 'LastEditDate': '2013-03-11T07:22:24.840', 'AnswerCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2529', 'FavoriteCount': '1', 'Body': '<p>I don\'t know much about yacc, bison, flex or lex and please correct me if I\'m wrong but a programming language is also a Turing machine and a Turing machine is defined as the tuple $(Q, \\Gamma, b, \\Sigma, \\delta, q_0, F)$ where $Q$, $\\Gamma$, $b \\in \\Gamma$, $\\Sigma \\subseteq \\Gamma \\smallsetminus \\{ b \\}$ as input, $\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{ L, R, N \\}$ as transition function where $L$ = number of steps to the left, $R$ = number of steps to the right, $N$ = "standby", $q_0 \\in Q$ is the initial state and $F \\subseteq Q$ is the set of end states.</p>\n\n<p>How similar is implementing a programming language to implementing a Turing machine? Can it be said that what is done when a programming language is implemented is that a Turing machine like the above is defined? If yes, how come we can\'t just use a model that looks like the definition of a Turing machine when a programming language is defined? Instead something else like BNF seems to be the standard.</p>\n', 'Tags': '<turing-machines><formal-grammars><programming-languages><computation-models>', 'LastEditorUserId': '2980', 'LastActivityDate': '2013-03-11T07:22:24.840', 'CommentCount': '5', 'AcceptedAnswerId': '10344', 'CreationDate': '2013-03-06T23:06:28.763', 'Id': '10338'},47108:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '169', 'Title': 'Top Turing machine simulators on the web?', 'LastEditDate': '2013-03-09T02:47:07.830', 'AnswerCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '1', 'Body': '<p>There are many Turing machine simulators on the web of varying degrees of sophistication and can be highly useful for pedagogical purposes for students of widely varying ages, and they also have advanced theoretical value. </p>\n\n<p>What is a useful TM simulator available and what are its particular discriminating features that differ from other TM simulators available such that one would choose it and not another?</p>\n', 'ClosedDate': '2013-03-10T17:39:58.637', 'Tags': '<reference-request><turing-machines><compilers><education>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-09T02:47:07.830', 'CommentCount': '7', 'AcceptedAnswerId': '10383', 'CreationDate': '2013-03-08T03:32:19.103', 'Id': '10379'},47109:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading about Universal Turing Machines.</p>\n\n<p>I see that the matching lemma states, that between two symbols X and Y, if there are only 1-s and blanks, then a TM exists, which can count the number of ones.</p>\n\n<p>This is used to match strings of ones between two tapes.</p>\n\n<p>Now I wonder, would there also be a TM or a method of implementation of a TM which can match two strings? To me it intuitively appears, that inifinitely many symbols implies infinitely many states for the machine, and an example workflow may look like:\nfound symbol X, enter state stateX, exit stateX to state readnextchar if again X was found on the second tape.</p>\n\n<p>Would that not mean an infinitely long transition table? or is there an way to represent a table in a smaller way? </p>\n\n<p>if the symbols are represented via some kind of place value system, e.g. decimal, binary, would that shorten the transition table length?</p>\n', 'ViewCount': '61', 'Title': 'Matching Lemma with infinitely many symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T11:05:17.633', 'LastEditDate': '2013-03-20T10:56:13.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10642', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5203', 'Tags': '<turing-machines><machine-models>', 'CreationDate': '2013-03-19T22:41:09.000', 'Id': '10627'},47110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1097', 'Title': u'Why is this true: \u201cThere are countably many Turing Machines\u201d', 'LastEditDate': '2013-03-26T01:18:42.283', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7415', 'FavoriteCount': '2', 'Body': "<p>It is said that there are uncountably many languages but only countably many Turing Machines. Could someone make this clear to me?\nAnd this doesn't mean that the set of TM is finite, yes?</p>\n", 'ClosedDate': '2013-03-25T19:23:00.643', 'Tags': '<turing-machines><automata>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-06-18T19:56:53.950', 'CommentCount': '2', 'CreationDate': '2013-03-25T18:01:11.830', 'Id': '10780'},47111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $$L_\\emptyset = \\{\\langle M\\rangle \\mid M \\text{ is a Turing Machine and }L(M)=\\emptyset\\}.$$<br>\nIs there a Turing machine R that decides (I don't mean recognizes) the language $L_\\emptyset$?</p>\n\n<p>It seems that the same technique used to show that $\\{A \\mid A \\text{ is a DFA and } L(A)=\\emptyset\\}$ should work here as well.</p>\n", 'ViewCount': '1129', 'Title': 'Can a Turing machine decide the language $L_\\emptyset$ of machines with empty language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-22T10:30:47.150', 'LastEditDate': '2013-04-03T07:03:14.517', 'AnswerCount': '4', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-03-29T16:28:54.423', 'FavoriteCount': '1', 'Id': '10897'},47112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '53', 'Title': 'Undecidability of the language with its elements(TM) having empty language', 'LastEditDate': '2013-03-30T10:29:15.610', 'AnswerCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7415', 'FavoriteCount': '0', 'Body': '<p>We can write a decider for the language:</p>\n\n<p>$E=\\{A\\; |\\; A \\mbox{ is a DFA and } L(A)=\\emptyset\\}$</p>\n\n<p>by marking method.<br> Why we cannot use the same method to write a decider for the language with TM as follows?</p>\n\n<p>$A = \\{ M \\;|\\; M \\mbox{ is a TM and } L(M)=\\emptyset\\}$</p>\n', 'ClosedDate': '2013-04-02T07:24:28.633', 'Tags': '<turing-machines>', 'LastEditorUserId': '140', 'LastActivityDate': '2013-04-02T20:44:12.183', 'CommentCount': '0', 'CreationDate': '2013-03-30T10:24:15.420', 'Id': '10911'},47113:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>As it is explained in Sipser's book, the following language is undecidable and he proves this using the computation history method.</p>\n\n<p>$\\qquad E = \\{\\langle M \\rangle \\mid M\\ \\mathrm{LBA}, L(M)=\\emptyset\\}$</p>\n\n<p>I wanted to see if we could use the same method used for proving undecidability of the following language in the case of LBAs too (instead of using computation history method).</p>\n\n<p>$\\qquad E' = \\{\\langle M \\rangle \\mid M\\ \\mathrm{TM}, L(M)=\\emptyset\\}$</p>\n\n<p>Is it possible?</p>\n", 'ViewCount': '47', 'Title': 'Proving undecidability of the language composed of LBAs where their language is empty', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:45:43.797', 'LastEditDate': '2013-04-02T07:45:43.797', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10935', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-03-31T11:41:10.983', 'Id': '10934'},47114:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a TM(Turing Machine) accepts NO input string(even the blank), then its language is empty.</p>\n\n<p>If a TM ONLY accepts the blank string(meaning that there is nothing on the tape except for the default blank characters), then its language has only one item and it is the blank string.</p>\n\n<p>Are these definitions correct?</p>\n\n<p>Could you describe the TM for each?</p>\n\n<p>Also, this might be irrelevant but let me ask: I saw somewhere that there must be at least two states for a TM. Which states must be there all the time in a TM?</p>\n', 'ViewCount': '164', 'Title': 'Difference between a TM with an empty language and the one accepting empty string', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-09T15:17:51.617', 'LastEditDate': '2013-04-03T20:54:01.820', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '10998', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2013-04-03T17:31:21.707', 'Id': '10996'},47115:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In college we have been learning about theory of computation in general and Turing machines more specifically. One of the great theoretical results is that at the cost of a potentially large alphabet (symbols), you can reduce the number of states down to only 2.</p>\n\n<p>I was looking for examples of different Turing Machines and a common example presented is the Parenthesis matcher/checker. Essentially it checks if a string of parentheses, e.g (()()()))()()() is balanced (the previous example would return 0 for unbalanced). </p>\n\n<p>Try as I may I can only get this to be a three state machine. I would love to know if anyone can reduce this down to the theoretical minimum of 2 and what their approach/states/symbols was!</p>\n\n<p>Just to clarify, the parentheses are "sandwiched" between blank tape so in the above example\n- - - - - - - (()()()))()()() - - - - - - - would be the input on the tape. The alphabet would include (,),1,0,-, and the <em>halt</em> state does not count as a state.</p>\n\n<p>For reference the three state approach I have is as follows:\nDescription of states:</p>\n\n<pre><code> State s1: Looks for Closing parenthesis\n\n State s2: Looks for Open parenthesis\n\n State s3: Checks the tape to ensure everything is matched\n</code></pre>\n\n<p>Symbols: ),(,X\nTransitions Listed as:</p>\n\n<p>Action: State Symbol NewState WriteSymbol Motion</p>\n\n<p>// Termination behavior</p>\n\n<p>Action: s2 - <em>halt</em> 0  -</p>\n\n<p>Action: s1 -  s3    -  r</p>\n\n<p>//Transitions of TM</p>\n\n<p>Action: s1 (  s1  (   l</p>\n\n<p>Action: s1 )  s2  X  r</p>\n\n<p>Action: s1 X  s1  X  l</p>\n\n<p>Action: s2 ( s1 X  l</p>\n\n<p>Action: s2 X  s2 X r</p>\n\n<p>Action: s3 (  <em>halt</em> 0 -</p>\n\n<p>Action: s3 X  s3     X r</p>\n\n<p>Action: s3 -  <em>halt</em> 1 -</p>\n\n<p>Forgive the informal way of writing all this down. I am still learning the theoretical constructs behind this.</p>\n', 'ViewCount': '1114', 'Title': 'Two-State Turing Machine for Parenthesis Matching', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-06T21:27:16.633', 'LastEditDate': '2013-04-06T21:27:16.633', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'Four_FUN', 'PostTypeId': '1', 'OwnerUserId': '7590', 'Tags': '<context-free><turing-machines><parsing>', 'CreationDate': '2013-04-05T06:57:23.333', 'Id': '11044'},47116:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Note: This is a part of a homework question</p>\n\n<p>Were asked to construct a multi-tape Turing Machine for language {$a^n b^n c^n \\mid n \\geq 0$}</p>\n\n<p>Then it says "Discuss how much time your machines saves over a one-tape DTM using the same algorithm"\nAny hint?</p>\n\n<p>Here\'s my algorithm:</p>\n\n<p>(1) Cut-and-paste c\'s to tape 3</p>\n\n<p>(2) Cut-and-paste b\'s to tape 2</p>\n\n<p>(3) Cross out each triplets, accept if last round cuts all three, reject if there\'s leftover</p>\n\n<p>Which seems like it has a time complexity of $O(n+n+3n)=O(5n)$\nThen how do we determine the time complexity for the one-tape version?</p>\n', 'ViewCount': '197', 'Title': 'How do we determine how much time a multi-tape DTM saves over a one-tape DTM?', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-05-01T11:05:47.477', 'LastEditDate': '2013-05-01T11:05:47.477', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '11671', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<time-complexity><turing-machines><efficiency>', 'CreationDate': '2013-04-05T11:39:26.017', 'Id': '11053'},47117:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '142', 'Title': 'Program synthesis, decidability and the halting problem', 'LastEditDate': '2013-04-05T15:19:36.143', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '1', 'Body': '<p>I was reading an answer to a recent question, and sort of a strange, ephemeral thought came to mind. My asking this might betray either that my theory chops are seriously lacking (mostly true) or that it\'s just too early for me to read this site. Now, with the disclaimer out of the way...</p>\n\n<p>It is a well-known result it computability theory that the halting problem cannot be decided for TMs. However, this doesn\'t exclude the possibility that there exist machines that can solve the halting problem for certain classes of machines (just not all of them).</p>\n\n<p>Consider the set of all decidable problems. For each problem, there exist infinitely many TMs which decide that language. Could the following be possible </p>\n\n<ul>\n<li>There is a TM that decides the halting problem for a subset $S$ of Turing machines; and</li>\n<li>All decidable problems are decided by at least one Turing machine in $S$?</li>\n</ul>\n\n<p>Of course, finding the Turing machine in $S$ may not be computable itself; but we ignore that problem.</p>\n\n<p>EDIT: Based on Shaull\'s answer below, it seems that either (a) this idea is too ill-specified to be meaningful or (b) my previous attempt wasn\'t quite on the mark. As I try to elaborate in the comments to Shaull\'s answer, my intent isn\'t that we\'re guaranteed that the input TM is in $S$. What I really meant by my question is whether there could exist such an $S$, <em>such that membership in $S$ is a decidable problem</em>. The program to solve the halting problem for $S$ would, presumably, write "invalid input" on the tape or something when given an input that it recognizes as not being in $S$. When I formulate it like that, I\'m not sure whether this allows us to solve the halting problem or not, or whether Rice\'s theorem applies (is decidability a semantic property of a language w.r.t. Rice\'s theorem?)</p>\n', 'Tags': '<turing-machines><undecidability><halting-problem>', 'LastEditorUserId': '69', 'LastActivityDate': '2013-04-05T15:20:46.887', 'CommentCount': '2', 'AcceptedAnswerId': '11059', 'CreationDate': '2013-04-05T13:19:48.110', 'Id': '11056'},47118:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Prove if a oracle machine $K$ is given with $\\mathsf{P^k}=\\mathsf{NP}$ then $\\mathsf{NP}=\\mathsf{co\\text{-}NP}$.</p>\n\n<hr>\n\n<p>Lets assume that $\\mathsf{P^k}=\\mathsf{NP}$ then $\\mathsf{co\\text{-}P^k}=\\mathsf{co\\text{-}NP}$.  I am stuck here, I don't know how to prove this. Can someone help?</p>\n\n<p>I know that $\\mathsf{P}=\\mathsf{co\\text{-}P}$ but can I also say $\\mathsf{P^k}=\\mathsf{co\\text{-}P^k}$ or do I have to prove it ?</p>\n", 'ViewCount': '85', 'Title': 'Prove that if $\\mathsf{P^k}=\\mathsf{NP}$ then $\\mathsf{NP}=\\mathsf{co\\text{-}NP}$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-06T04:17:56.190', 'LastEditDate': '2013-04-05T21:03:56.313', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '11071', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6672', 'Tags': '<complexity-theory><turing-machines><np>', 'CreationDate': '2013-04-05T20:59:08.920', 'Id': '11066'},47119:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd appreciate hints for this problem</p>\n\n<p>I'm trying to design a Turing Machine which calculates $\\max \\{x_1, x_2,..,x_k \\}$.</p>\n\n<p>Assuming $1 = 1^1; 2=1^2; n=1^n$ and all numbers/strings are separated by a blank character $B$.</p>\n", 'ViewCount': '317', 'Title': 'How to find max number with a single-tape turing machine?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-13T19:54:56.923', 'LastEditDate': '2013-04-13T19:54:56.923', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11109', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<turing-machines>', 'CreationDate': '2013-04-07T18:43:55.193', 'Id': '11107'},47120:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have an exam coming up soon and I need help with this.  Consider the problem:</p>\n\n<blockquote>\n  <p>Given a Turing machine $M$, determine if $M$ halts in at most ten steps on every input.</p>\n</blockquote>\n\n<p>Is this decidable?  Prove your answer.</p>\n', 'ViewCount': '83', 'Title': 'Decidability of a Turing machine which always halts in at most ten steps', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-04-08T09:10:17.170', 'LastEditDate': '2013-04-08T09:10:17.170', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7639', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-04-08T07:26:53.610', 'Id': '11135'},47121:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In writing a decider for a machine to see if it has made a left move or not on an input of <em>w</em>, it is said that if we continue the computation for $|w|+N+1$ ($N$ : number of states) number of steps, we can make a decision for this decide.</p>\n\n<p>I didn't get why $|w|+N+1$ number of steps. Could someone explain this in more detail?</p>\n", 'ViewCount': '132', 'Title': 'Deciding if a Turing machine has made a left move', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:58:44.187', 'LastEditDate': '2013-04-10T08:58:44.187', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11162', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-04-09T12:10:26.377', 'Id': '11159'},47122:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>According to my understanding, a Turing machine that's valid <em>has</em> to have finite steps to finish a certain step. If this is right, what else determines the validity of a turing machine? </p>\n", 'ViewCount': '103', 'Title': 'What determines valid and invalid turing machines?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T18:47:11.473', 'LastEditDate': '2013-04-10T08:44:23.170', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '11202', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7600', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2013-04-09T22:46:24.153', 'Id': '11173'},47123:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If there is a Turing Machine $M_e$ (computing some partially computable function $f$), is there an algorithm to decide if $f$ diverges for all possible inputs?</p>\n', 'ViewCount': '109', 'Title': 'Does Turing Machine divergence depend on the input?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T04:44:34.687', 'LastEditDate': '2013-04-10T18:34:48.943', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'Gauk', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><undecidability><halting-problem>', 'CreationDate': '2013-04-10T10:36:06.323', 'Id': '11196'},47124:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '98', 'Title': 'Why the name Recursively Enumerable and Recursive?', 'LastEditDate': '2013-04-10T18:35:14.180', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>Why did the sets of languages accepted/decided by a TM get the name Recursively Enumerable and Recursive, respectively?</p>\n', 'ClosedDate': '2013-12-10T22:13:09.560', 'Tags': '<terminology><computability><turing-machines><history>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T20:02:27.980', 'CommentCount': '1', 'CreationDate': '2013-04-10T17:08:52.637', 'Id': '11197'},47125:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a little problem to understand the proof of the Time Hierarchy Theorem (Hennie and Stearns, 1966) that ensures the existence of a language acceptable in $U(n)$ but not acceptable in $T(n)$ for any functions $T(n),U(n)$, such that $U(n)$ is time-constructible and</p>\n\n<p>$$n \\leq T(n) = o\\left(\\frac{U(n)}{\\log T(n)}\\right).$$</p>\n\n<p>This proof is based on the existence of the Universal Turing machine simulating any Turing machine with time complexity $T(n)$ in time $T(n) \\log T(n)$.</p>\n\n<p>I understand (and believe) the proof that every $k$-tape Turing machine can be simulated by a two-tape Turing machine with a logarithmic overhead. However, I understand this construction only if the simulated Turing machine is fixed, not in the case of the Universal TM simulation.</p>\n\n<p>I see one "problem" in the reasoning given in the cited paper (and also in several standard books on computational complexity) related to the construction of the Universal machine. This "problem" is that in the Universal machine simulation, one computational step of a simulated machine is supposed to be executed in constant time by the Universal machine. In other words, the length of the description of the simulated machine is supposed to be constant.</p>\n\n<p>But is this OK? Since in the proof of the Time Hierarchy Theorem, the input given to the simulated Turing machine is exactly this description, and thus, the description is somehow dependent of $n$. I am aware of that the description can be lengthened by a sequence of leading bits, but this does not seem to solve this problem. </p>\n\n<p>That is, I cannot figure out why the computation step of a simulated machine can be supposed to be executed in a constant time by the Universal machine. The paper of Hennie and Stearns does not pay much attention to this, it merely states that this time is something that is implicitly assumed to be a constant. Similarly in the textbooks I have read on the topic.</p>\n\n<p>I simply cannot figure out why the time complexity of the simulation is $T(n)\\log T(n)$, and not $n T(n) \\log T(n)$.</p>\n\n<p>I am almost sure that I am missing something. However, I am trying to understand this for a relatively long time and somehow I cannot figure this out.</p>\n', 'ViewCount': '382', 'Title': 'Time Complexity of Universal Turing Machine Simulations and the Time Hierarchy Theorem', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T10:35:19.797', 'LastEditDate': '2013-04-14T10:35:19.797', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11284', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2091', 'Tags': '<complexity-theory><turing-machines><simulation>', 'CreationDate': '2013-04-13T09:50:42.470', 'Id': '11280'},47126:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>A TM for a recursive language corresponds to our informal notion of an algorithm.</p>\n</blockquote>\n\n<p>as per Automata Theory, Languages and Computation by Ullman et al. Then there are languages called RE and $L_d$, where there exist TM that halts for accepting strings in the case of RE languages.</p>\n\n<p>This means that we cannot construct a algorithm for RE languages that are not recursive? Then what is the significance of these RE languages from an algorithm point of view.</p>\n\n<p>What confuses me is that for RE language you can construct a TM. So you can construct an algorithm?</p>\n', 'ViewCount': '97', 'Title': "What does it mean to say that there doesn't exist an algorithm from a TM point of view?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T11:20:42.773', 'LastEditDate': '2013-04-14T11:13:02.347', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '11310', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-04-13T13:34:34.777', 'Id': '11285'},47127:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the proof of Trakhtenbrot\'s theorem (as given in "Elements of Finite Model Theory" by Leonid Libkin), for every Turing machine $M$, author constructs a FO sentence $\\Phi_M$ of vocabulary $\\sigma$ such that $\\Phi_M$ is finitely satisfiable iff $M$ halts on the empty input. Then he says that as the latter is known to be undecidable so the theorem holds.</p>\n\n<p>My doubt is, the vocabulary $\\sigma$ that was constructed depends on the Turing Machine $M$. But the theorem holds for any relational vocabulary with at least one binary relation symbol and also it should not depend on the machine $M$. Perhaps the claim of author is enough to imply the theorem for arbitrary vocabulary, but I am unable to see how.</p>\n', 'ViewCount': '161', 'Title': "Proof of Trakhtenbrot's theorem", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T09:57:57.300', 'LastEditDate': '2013-04-15T09:54:06.163', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7264', 'Tags': '<turing-machines><logic><reductions><undecidability><finite-model-theory>', 'CreationDate': '2013-04-15T08:38:12.270', 'Id': '11327'},47128:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $m$ be the number of states (without the halting-state) of a deterministic turing-machine with $\\Sigma$ = {} and $\\Gamma$ = {$\\square$, 0, 1}. Let $G(m)$ be the maximum number of ones, which can be generated by a deterministic turing-machine, before going into the halting-state. Prove that $G(m)$ $\\in$ $\\Omega(2^m)$. (This is about the so called "busy beaver" problem, with the mathematical rado-function $\\Sigma(N)$ or $bb(N)$.) Who can me help with that?</p>\n', 'ViewCount': '196', 'Title': 'calculate lower bound of busy beaver', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-16T16:27:27.937', 'LastEditDate': '2013-04-16T16:27:27.937', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7739', 'Tags': '<turing-machines>', 'CreationDate': '2013-04-15T16:24:25.400', 'Id': '11341'},47129:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I got stuck on this question while studying for final exam.</p>\n\n<p><img src="http://i.stack.imgur.com/AdZCy.png" alt="the language"></p>\n\n<p>I thought about reducing L\' to L to prove that L\' is recognizable since L is recognizable. I am not 100% sure if that is correct.</p>\n', 'ViewCount': '68', 'Title': 'Prove that the Language is Recognizable', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-19T03:28:21.033', 'LastEditDate': '2013-04-19T03:28:21.033', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '11396', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7779', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-04-18T22:57:49.270', 'Id': '11391'},47130:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A few definitions..</p>\n\n<p>$$\n\\begin{align*}\n\\mathrm{ALL}_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle  \\,\\Big|\\, \\text{$M$ a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; L(M) = \\{0,1\\}^{*} \\Bigr\\}\n\\\\[2ex]\n\\overline{\\mathrm{ALL}}_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle  \\,\\Big|\\, \\text{$M$ a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; L(M) \\ne \\{0,1\\}^{*} \\Bigr\\}\n\\\\[2ex]\nB_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle \\,\\Big|\\, \\text{$M$ is a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; \\varepsilon \\in L(M) \\Bigr\\}\n\\end{align*}\n$$</p>\n\n<p>We are showing a reduction from $B_{\\mathrm{TM}}$ to $\\overline{\\mathrm{ALL}}_{\\mathrm{TM}}$. In my notes I have the following solution to this problem which I'm trying to understand.</p>\n\n<ol>\n<li><p>Let $\\alpha \\in \\{0,1\\}^*$. Check that $\\alpha$ is of form $\\langle M \\rangle$, where $M$ is a TM over $\\{0,1\\}$. Else, let $f(\\alpha)$ be anything not in $\\overline{\\mathrm{ALL}}_{\\mathrm{TM}}$.</p></li>\n<li><p>Let $f(\\alpha)$ be $\\langle M' \\rangle$, where $M'$ on $x$ runs $M$ on $\\varepsilon$ (blank string) for up to $|x|$ steps. If $M$ accepts (in that time), then $M'$ rejects. Otherwise, $M'$ accepts.</p></li>\n</ol>\n\n<p>What I'm trying to understand is why must we run the TM $M'$ for $|x|$ steps for this to work? If we change the part #2 of the transformation to the following, why wouldn't this work?</p>\n\n<ul>\n<li>Let $f(\\alpha)$ be $\\langle M' \\rangle$, where $M'$ on $x$ runs $M$ on $\\varepsilon$ (blank string). If $M$ accepts, reject. Otherwise accept.</li>\n</ul>\n\n<p>Which then it follows that $\\varepsilon \\in L(M) \\!\\iff\\! L(M) = \\varnothing$,  that is $L(M) \\neq \\{0,1\\}^*$.</p>\n", 'ViewCount': '257', 'Title': 'Proving ALLTM complement not recognizable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:06:43.400', 'LastEditDate': '2013-04-21T14:06:43.400', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7776', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-04-19T16:41:41.893', 'Id': '11411'},47131:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am attempting to prove the following problem is undecidable. Given a Turing machine $M$ and input $x$, does $M$ visit infinitely many tape cells on input $x$? </p>\n\n<p>I am considering a reduction from the halting problem. Is this the right approach? </p>\n', 'ViewCount': '109', 'Title': 'Show the problem of a machine visiting infinitely many tape cells on some input is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-04T15:47:41.333', 'LastEditDate': '2013-04-21T23:15:04.180', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<computability><turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2013-04-21T22:25:41.810', 'Id': '11479'},47132:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve been trying for a while now to find a solution for the problem in the title: determining if a number is perfect using a Turing Machine. I only had one class on the TM and while I did "get" how it works, this particular algorithm is being really hard for me to develop.</p>\n\n<p>The algorithm I\'m trying to implement on the TM is basically this (on C, returns <code>true</code> iff <code>n</code> is a perfect number):</p>\n\n<pre><code>int main(int n) {\n  int i=1, sum=0;\n\n  while ( n &gt; i ) {\n    if ( n % i == 0 ) {\n      sum = sum + i;\n    }\n    i++;\n  }\n\n  return sum == n\n}\n</code></pre>\n\n<p>The tough part for me right now is the <code>while(n&gt;i)</code> loop and the <code>n%i</code> inside it.</p>\n\n<p>Since I already have a program that does <code>a%b</code>, I was trying to build the TM graph around it, but I\'m not sure it\'s the best idea, specially since the <code>b</code> on this case changes on every iteration. The software I\'m using to simulate the TM is called JFlap.</p>\n\n<p>The algorithm on table or graph form would be perfect.</p>\n', 'ViewCount': '366', 'Title': 'Algorithm to determine if a number is perfect on a Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-22T16:39:50.503', 'LastEditDate': '2013-04-22T11:20:04.560', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7833', 'Tags': '<algorithms><turing-machines><decision-problem><integers>', 'CreationDate': '2013-04-22T00:23:08.297', 'Id': '11481'},47133:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p><strong>Setup</strong></p>\n\n<p>I need to develop a Turing Machine that accepts a string m that has the same number of a's and b's.\nMy alphabet is {a,b}, and we use a diamond in class to represent an empty space.</p>\n\n<p><strong>Problem</strong></p>\n\n<p>The part I'm having trouble with is returning to the beginning of the string.</p>\n\n<p><strong>So far</strong></p>\n\n<p>At first I was planning on taking a character(a) marking it with a diamond, moving right until the other character(b) is found, marking that with a diamond, then moving left until the other's other character(a) is found, and repeating the process. \nThe parenthesis are for example, it could have been b,a,b just as well.</p>\n\n<p>Then at the end if there is an outlier I will know the number of a's and b's was not similar.</p>\n\n<p>But then I developed an example language\nab... and realized that this process will never end in this case, so instead I need a way of determining when I have reached the beginning of the string.</p>\n\n<p><strong>So now my question...</strong></p>\n\n<p>Is it possible to determine when I have reached the beginning of the string without introducing another letter into the alphabet, or another special character like the diamond?</p>\n", 'ViewCount': '61', 'Title': 'How to distinguish empty cells from cells outside of the input cells?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T11:33:09.260', 'LastEditDate': '2013-04-23T09:14:43.980', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11513', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7847', 'Tags': '<turing-machines><discrete-mathematics>', 'CreationDate': '2013-04-22T20:15:21.430', 'Id': '11498'},47134:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '248', 'Title': 'Does our PC work as Turing Machine?', 'LastEditDate': '2013-04-23T12:28:36.693', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7384', 'FavoriteCount': '2', 'Body': u'<p>Does our PC work as Turing Machine?  The model of a Turing Machine consists of infinite memory tape, which means infinite states. But suppose if our PC has 128 MB memory and 30GB disk it would have 256^30128000000 states and thus, it has finite states.</p>\n\n<p>I know that we can write a type of program that, if during execution we run out of memory, will request to swap memory disk with empty memory disk and resume execution.</p>\n\n<p><strong>But what if we don\u2019t swap memory disk, in this case is it right to consider PC as FA</strong>?  </p>\n', 'Tags': '<complexity-theory><computability><turing-machines><automata>', 'LastEditorUserId': '1861', 'LastActivityDate': '2013-04-23T15:53:04.873', 'CommentCount': '1', 'AcceptedAnswerId': '11516', 'CreationDate': '2013-04-23T11:46:49.043', 'Id': '11514'},47135:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can we prove that $h(x) = g(f(x))$ is a reduction function for $A \\leq_m C$,</p>\n\n<p>if $f$ is the reduction function of  $A \\leq_m B$ and $g$ is the reduction function for  $B \\leq_m C$</p>\n\n<p>The given Proposition is: $A \\leq_m B, B \\leq_m C \\Rightarrow A \\leq_m C$</p>\n\n<p>I was thinking about using $HALT_{TM}$ for A. So on input $\\langle M, w\\rangle \\in A$ if and only if $\\langle M'',w'' \\rangle \\in  C$</p>\n\n<p>The output of A would be $ \\langle M', w' \\rangle$ and the output of B would be $\\langle M'',w'' \\rangle$</p>\n\n<p>If the constructed $M$ rejects the input $x$, then it loops forever, so $C$ is not recursive if $A$ is not recursive</p>\n\n<p>If this isn't sufficient, then what am I missing?</p>\n", 'ViewCount': '318', 'Title': 'How to prove Transitive property of Reducibility with a TM?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:32:52.450', 'LastEditDate': '2013-08-22T14:32:52.450', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11537', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-04-24T11:19:14.237', 'Id': '11536'},47136:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In my class we just started learning about Turing machines.  I think I understand the concept but am unsure how to syntactically solve any problem related to one.  I am presented with the problem:</p>\n\n<blockquote>\n  <p>Build a Turing machine accepting $(b + c)^+$$\\#a^+$  (Please comment your\n  code. Any uncommented solutions will not be graded.)</p>\n</blockquote>\n\n<p>I am unsure of how to actually begin devising this machine? Could someone please help get me started?</p>\n', 'ViewCount': '890', 'Title': 'How to construct and write down a Turing machine for a given language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-25T07:23:03.987', 'LastEditDate': '2013-04-25T07:36:46.137', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '11555', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<turing-machines>', 'CreationDate': '2013-04-24T23:10:41.220', 'Id': '11542'},47137:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to solve this question in order to review for my exam, and this one has got me a bit stumped. From the looks of it, it seems like a fairly straight-forward question, but I can\'t figure out what steps to begin with.</p>\n\n<blockquote>\n  <p>Let $M$ be a linear-space Turing machine consisting of a single tape. We say $M$ is a linear-space Turing machine if M halts on every input, and if there are constants $c$ and $n_{0}$ such that for all inputs $x\\in \\Sigma^{\\ast}$ of length $n\\geq n_{0}$, $M$ running on $x$ visits at most $c\\cdot n$ tape squares.</p>\n  \n  <p>Prove that for some constant $d$, $M$ runs in time $O(2^{dn})$.</p>\n</blockquote>\n\n<p>I have a couple of ideas to begin with. First, my intuition tells me that I just have to build an algorithm that runs according to those rules and accepts/rejects in time $O(2^{dn})$. Secondly, theres a hint that tells me to "consider the number of configurations", however, I\'m not sure on how to incorporate that.</p>\n\n<p>Thank you in advance for any help.</p>\n', 'ViewCount': '209', 'Title': 'Proving that Turing Machine M runs in time $O(2^{dn})$', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-05-06T23:39:09.417', 'LastEditDate': '2013-05-06T23:39:09.417', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11563', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7904', 'Tags': '<turing-machines><space-complexity>', 'CreationDate': '2013-04-26T04:02:53.980', 'Id': '11561'},47138:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Were being asked to determine the whether this Turing Machine is decidable or not</p>\n\n<p>"Given a two way, one-tape DTM $M$ whose tape set is $\\Gamma=${$a,b,B$} and a string $x\\in${$a,b$}*, determine whether $M$ will ever overwrite a symbol $a$ by a symbol $b$ in its computation on <em>input</em> $x$"</p>\n\n<p>I\'m not looking for answers, just hints on how to even approach this problem. Like, would we declare a <em>language</em> which is a subset of that <em>language</em>, and then apply reducibility?</p>\n', 'ViewCount': '53', 'Title': 'Determining if a TM decidable or not, with limited information', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-04-26T18:31:57.527', 'LastEditDate': '2013-04-26T18:31:57.527', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11580', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2013-04-26T15:17:43.000', 'Id': '11579'},47139:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am doing some work on register machine theory which revolves around a 2-register register machine and attempting to show that it is not possible to compute an upper-bound on the final contents of its two registers on the basis of its program code and initial input, in halting configurations only. I believe this can be related in some way to the <em>busy beaver</em> problem, but I cannot quite see how, and the stipulations that it is for halting configurations only has confused me somewhat.</p>\n\n<p>What do I know so far?</p>\n\n<ul>\n<li><p>Clearly a register machine configuration specified by the 3-tuple <em>(instruction label, register 0, register 1)</em> has an infinite number of possible states, owing to the abstract nature of the machines, as no practical limit is imposed on the size of the natural numbers which can be stored in each register.</p></li>\n<li><p>I considered whether I could simply define a partial function $f : \\mathbb{N}^3 \\to \\mathbb{N}$ where the arguments are the program encoded as a natural number and the initial contents of the two registers, but I do not think this gets me anywhere. I defined the function to be undefined when the partial function computed by the register machine specification is undefined on the given input, as the problem specifies computing the upper bound for halting configurations only. <br/><br/>Therefore, I cannot use a diagonal argument to suggest it would imply the halting problem, because being undefined for a non-halting configuration suggests it would not.</p></li>\n<li><p>Secondly, I tried to come up with a proof on the basis that there is an infinite number of possible configurations which a 2-register machine can be in. In particular, there is an infinite number of possible programs $e \\in \\mathbb{N}$ which could be executed, and each of those programs can be executed on an infinite number of initial register configurations $\\mathbb{N}^2$.<br /><br />By construction, if there is a machine which can decide this partial function for any given combination, then I thought it may be the case that it required an infinite number of states in which to do so - which is of course not possible, as a register machine must be specified by a finite number of instructions.</p></li>\n</ul>\n\n<p>I am not confident that either approach is correct or not, and wonder whether either of the above is a correct tact or if a formal proof exists for this?</p>\n', 'ViewCount': '66', 'Title': 'Upper bound on register machine contents', 'LastActivityDate': '2013-04-30T16:32:15.903', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11679', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7928', 'Tags': '<computability><turing-machines><church-turing-thesis>', 'CreationDate': '2013-04-30T15:48:51.427', 'Id': '11678'},47140:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '116', 'Title': 'Is there an always-halting, limited model of computation accepting $R$ but not $RE$?', 'LastEditDate': '2013-05-10T21:42:07.617', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '0', 'Body': '<p>So, I know that the halting problem is undecidable for Turing machines. The trick is that TMs can decide recursive languages, and can accept Recursively Enumerable (RE) languages.</p>\n\n<p>I\'m wondering, is there a more limited model of computation which accepts only recursive languages, and not RE? And if so, is there such a model which is always guaranteed to halt?</p>\n\n<p>Obviously this model would be strictly less powerful than TMs and strictly more powerful than PDAs.</p>\n\n<p>I\'m open to a machine-style model, or a lambda-calculus style model.</p>\n\n<p>As an example of what I\'m thinking: the Coq language has a restriction that for any self-recursive calls, the first argument must be strictly decreasing in "size" i.e. if it is a natural number, it must be smaller, if it is a list, it must be shorter, etc. This guarantees that it always halts, but I have no idea if you can compute all of R this way.</p>\n', 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><halting-problem>', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-11T07:39:41.863', 'CommentCount': '1', 'AcceptedAnswerId': '11943', 'CreationDate': '2013-05-10T15:58:41.437', 'Id': '11936'},47141:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here I have a Turing Machine (sorry for awful drawing):</p>\n\n<p><img src="http://i.stack.imgur.com/82dec.png" alt="enter image description here"></p>\n\n<p>So, I have a question regarding the usage of <code>a</code> here. It is treated as a variable here. But since it doesn\'t alter input tape in any way, shouldn\'t it be stored in an implicit storage? My question is if this implicit storage (tell me if I am wrong) is in conflict with the fact that a Turing Machine only has a single input tape.</p>\n\n<p>My hunch is that it is syntactic sugar and it can be explicitly defined with less-intuitive notation (another input tape?), but I am not sure.</p>\n', 'ViewCount': '80', 'Title': 'Problem regarding Turing Machine notation', 'LastActivityDate': '2013-05-10T17:08:48.943', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11939', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4289', 'Tags': '<turing-machines>', 'CreationDate': '2013-05-10T16:40:37.207', 'Id': '11938'},47142:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The wikipedia article about <a href="http://en.wikipedia.org/wiki/Primitive_recursive_function" rel="nofollow">primitive recursion</a> states that </p>\n\n<blockquote>\n  <p>An equivalent definition states that a partial recursive function is one that can be computed by a Turing machine.</p>\n</blockquote>\n\n<p>My question is how one can write down formally this definition?</p>\n', 'ViewCount': '122', 'Title': 'Partial recursive function and Turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-16T06:02:08.843', 'LastEditDate': '2013-05-16T06:02:08.843', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Montaigne', 'PostTypeId': '1', 'Tags': '<terminology><turing-machines><recursion>', 'CreationDate': '2013-05-15T23:26:36.777', 'Id': '12055'},47143:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This might be a bit of an abstruse question, but it's something I've been trying to prove.</p>\n\n<p>I'm trying to show that it is undecidable whether a given Turing Machine is a member of the set of all Turing Machines that either always halt, or have non-halting loops where all of which can be detected (a positive decision made on it's existence) by some Turing Mahcine.</p>\n\n<p>I'm trying to do a reduction from the Entscheidungsproblem, and my proof looks something like this:</p>\n\n<p>Create a Turing machine $D$ on input $&lt;M,w&gt;$ that does the following:</p>\n\n<ol>\n<li><p>Mechanically create TM $M_2$ which does the following on $x$:</p>\n\n<ol>\n<li>if $M$ accepts $w$ (via simulation from UTM): accept $x$.</li>\n<li>if $M$ rejects $w$: loop in a manner such that $M_2$ would not be a member of the aforementioned set.</li>\n</ol></li>\n<li><p>Run decider for above problem on $M_2$:</p>\n\n<ul>\n<li>if decider accepts, it should accept because if $M$ accepts $w$, $M_2$ must always halt and must be a member of the set in question.</li>\n<li>if decider rejects, it should reject because if $M$ does not accept $w$, $M_2$ must have a non mechanically detectable loop and is not in the set.</li>\n</ul></li>\n</ol>\n\n<p>The above Turing Machine $D$ should therefore decide Entscheidungsproblem and shows the reduction. However, I'm not sure how to show that it possible to mechanically create a loop which cannot be mechanically detected, or whether an alternate method of proof would be adequate.</p>\n\n<p>Any insight in this proof would be appreciated.</p>\n", 'ViewCount': '111', 'Title': 'Undecidability of whether a given TM halts or only has loops which can be detected by some TM', 'LastEditorUserId': '8262', 'LastActivityDate': '2013-06-19T01:38:13.963', 'LastEditDate': '2013-05-20T01:15:44.853', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '1', 'OwnerDisplayName': 'Phillip Huff', 'PostTypeId': '1', 'OwnerUserId': '8262', 'Tags': '<turing-machines><reductions><halting-problem><undecidability>', 'CreationDate': '2013-05-19T01:12:03.770', 'Id': '12141'},47144:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '394', 'Title': 'Design a Turing Machine Checking if Apples and Bananas are Even', 'LastEditDate': '2013-05-23T12:56:20.473', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8286', 'FavoriteCount': '1', 'Body': u'<p>I am having trouble with a past exam paper. I have to design a Turing Machine to do the following, but I don\'t really know where to start with this question. Any help would be very much appreciated.</p>\n\n<hr>\n\n<p>Design a Turing Machine TM checking if the numbers of sold apples and bananas are even. Formally, given a string w over the alphabet {a,b}, TM should terminate with the following result string.</p>\n\n<pre><code>ab if the number of apples and bananas are even\na if the number of apples is even but bananas are odd\nb if the number of apples is odd and bananas are even\n\u03f5 if the number of apples and bananas are both odd\n</code></pre>\n\n<p><img src="http://i.stack.imgur.com/ikq7P.png" alt="enter image description here"></p>\n\n<p>Thanks</p>\n', 'Tags': '<turing-machines>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-05-23T12:56:20.473', 'CommentCount': '3', 'AcceptedAnswerId': '12201', 'CreationDate': '2013-05-21T20:03:38.753', 'Id': '12200'},47145:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to find two languages, $L_1, L_2 \\in RE \\setminus R$, such that $L_1 \\cup L_2 \\in R$.</p>\n\n<p>I have already proved that if $L_1\\cap L_2 \\in R$ <strong>and</strong> $L_1 \\cup L_2 \\in R$, such $L_1, L_2$ don't exist (because otherwise we'll be able to construct a Turing Machine $M_1$ which will decide $L_1$, for instance).</p>\n\n<p>However, I cannot prove that it's impossible in the case $L_1\\cap L_2 \\in RE \\setminus R$, and I can't find such languages.</p>\n", 'ViewCount': '290', 'Title': 'Is it possible that the union of two undecidable languages is decidable?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-26T05:45:47.917', 'LastEditDate': '2013-05-26T05:45:47.917', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '12253', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7611', 'Tags': '<formal-languages><turing-machines><undecidability>', 'CreationDate': '2013-05-24T18:46:22.450', 'Id': '12252'},47146:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>BB(n) is roughly the maximum number of new states an n-state TM can run into without halting. So for a particular n, if we know BB(n), then we can find out if an arbitrary n-state TM halts by running it for BB(n) steps.</p>\n\n<p>So given some n-state TM, can we construct an m-state TM, where m>n, to calculate BB(n) and thus decides if it halts?</p>\n\n<p>Now some might say that this is equivalent to solving the halting problem, but I don't think so. Because given an arbitrary TM, we don't in fact know how many states it has. And if we don't know n, we certainly can't find m.</p>\n\n<p>If the answer is in the negative, then how is it that we can in fact find out the values of BB(n) for small n? What's the connection between incomputability and unknowability?</p>\n", 'ViewCount': '59', 'Title': 'Given an n-state TM, can we construct an m-state TM (m>n) to determine if it halts?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-28T19:59:32.793', 'LastEditDate': '2013-05-28T19:59:32.793', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2157', 'Tags': '<computability><turing-machines><halting-problem><busy-beaver>', 'CreationDate': '2013-05-25T03:11:19.460', 'Id': '12261'},47147:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a PDA $P=(Q,\\sum,\\delta,q_0,F)$ construct formally a TM that accepts $L(P)$.</p>\n\n<p>My idea is to construct a Turing machine with 2 tapes, one for the input and the other for the stack. Also to add $q_a$ for accept and $q_r$ for reject and to send to $q_a$ if the TM stops on states in $F$ and send to $q_r$ otherwise.</p>\n\n<p>But I am having a trouble to define new the transition function for the TM: $\\delta_M$.</p>\n', 'ViewCount': '114', 'Title': 'construct a TM from a PDA', 'LastActivityDate': '2013-05-25T05:27:49.823', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12264', 'Score': '0', 'OwnerDisplayName': 'David', 'PostTypeId': '1', 'OwnerUserId': '15890', 'Tags': '<machine-learning><turing-machines><machine-models>', 'CreationDate': '2013-05-24T12:13:01.970', 'Id': '12263'},47148:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let's say we have an alternating Turing Machine that makes a restricted number of alternations (i.e. switches from a universal to an existential state or vice versa) that works in polynomial space.</p>\n\n<p>My question is: how efficiently can we simulate that machine by a deterministic machine? I suspect that in fact very efficiently - also using polynomial space, but I am having trouble coming up with the simulation.</p>\n", 'ViewCount': '29', 'Title': 'Simulating alternating Turing Machines with bounded alternations by a deterministic Turing Machine', 'LastActivityDate': '2013-05-28T17:56:38.310', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'Stefan Czarnecki', 'PostTypeId': '1', 'Tags': '<turing-machines>', 'CreationDate': '2013-05-15T07:28:29.843', 'Id': '12337'},47149:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am not sure whether this is the right place to ask this question, but since it involves register machine and computability, hopefully this is the right place.</p>\n\n<p>I have tried to post on Programmers and Stack Overflow, but they redirected me to this site, they said it is more related to CS.</p>\n\n<p>The question is about how can I write a register machine code/program that computes the Fibonacci number. The syntax of the code is actually really simple.</p>\n\n<p>(Below are just for reference only, sorry for the long post)<br>\n(For more explanation see the book on Formal Logic: Its Scope And Limits by Richard Carl Jeffrey)  </p>\n\n<p>According to Wikipedia a register machine is a generic class of abstract machines used in a manner similar to a Turing machine. A (processor) register is a small amount of storage available as part of a CPU or other digital processor.</p>\n\n<p>We can simplify the problem by modelling the registers as empty buckets, and we can let marbles or rocks to be put into the register ("bucket"). The rule is to add or remove marbles from the bucket to perform computations.</p>\n\n<p>The rules are:<br>\n1. A register machine uses of a finite number of buckets, and an unending supply of marbles.<br>\n2. Each bucket can be individually identified. The marbles need not be distinguishable.<br>\n3. A register machine program is a finite set of instructions:<br>\n- To add marble to a bucket (and then to go on to the next instruction).<br>\n- Or to take a marble away from a bucket (and to go on to one next\ninstruction if you can, or another one, if you can\u2019t).<br>\n4. The program can be written in a flowchart or in a list of instructions.</p>\n\n<p>Here is an example of a register machine program that performs addition.<br>\nLet A, B, C be buckets.<br>\n1. (-B; 2,4) means take away one marble from bucket B, go to instruction 2 if can, or 4 if cannot<br>\n2. (+A; 3) means add one marble to bucket A, then go to instruction 3<br>\n3. (+C; 1) means add one marble to bucket C, then go to instruction 1<br>\n4. (-C; 5,-) means take away one marble from bucket C, go to instruction 2 if can, or exit if cannot<br>\n5. (+B; 4) means add one marble to bucket B, then go to instruction 4</p>\n\n<p>It is easily shown that suppose we have 3 marbles in bucket A and 2 marbles in bucket B, and 4 marbles in bucket C. After performing this algorithm, there will be |A|+|B| = 3+2 = 5 marbles in bucket A and |B|+|C| = 2+4 = 6 marbles in bucket B.</p>\n\n<p>(I hope the example above is clear enough for illustration purpose)  </p>\n\n<p>(Now here comes the question)  </p>\n\n<p>Now, I would like to write a register machine code which when given an input of n in bucket A, returns (also in bucket A) the nth Fibonacci number. The Fibonacci numbers are 0 (the 0th), 1 (the 1st), 1 = 0 + 1 (the 2nd), etc. We can use any number of buckets, the goal is to write the code as simple as possible (i.e. with fewest instructions). Fibonacci recurrence relation is F(n)=F(n-1)+F(n-2) given F(0)=0 and F(1)=1. </p>\n\n<p>Here is my attempt and the code:<br>\nMy idea is to use bucket A as input and finally as output F(n) (since the question requires the output in bucket A), bucket B as the "counter", bucket C as the F(n-1) and bucket D as F(n-2).<br>\n1. (+C; 2)<br>\n2. (-A; 3,4)<br>\n3. (+B; 2)<br>\n4. (-D; 5,7)<br>\n5. (+A; 4)<br>\n6. (-C; 5,7)<br>\n7. (-B; 6,-)  </p>\n\n<p>But my code only works for up to n=2 sadly, I am struggling to make the code works for any n>2. </p>\n\n<p>I have been thinking for this days and nights, I would appreciate if anyone could help me on this. Please do not hesitate to ask me for clarification if anything is unclear.</p>\n\n<p>Many many thanks in advance!</p>\n', 'ViewCount': '36', 'ClosedDate': '2013-05-29T10:40:58.470', 'Title': 'How to write register machine code for Fibonacci', 'LastEditorUserId': '8141', 'LastActivityDate': '2013-05-29T08:33:20.713', 'LastEditDate': '2013-05-29T08:33:20.713', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8141', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-05-28T18:36:39.097', 'Id': '12339'},47150:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider a deterministic Turing Machine $D$ which has an infinite tape in both directions. We don't have exact information about it; what we know is that its alphabet is $\\{a, b, c\\}$ and there are at least three states $q_1, q_s, q_f$ where $q_s$ is the start state, $q_f$ is the final state. At some step of the computation, all the tape is blank except one cell containing the symbol $a$, the state is $q_1$ and the head is currently at a blank cell.</p>\n\n<p>I need to write states and transitions that will guarantee to enter to final state from state $q_1$ but I have difficulties since $D$ is both deterministic and with infinite tape in both directions.</p>\n", 'ViewCount': '109', 'Title': 'Deterministic Turing Machine with infine tape in both directions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-02T22:56:47.160', 'LastEditDate': '2013-06-02T22:56:47.160', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12420', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7809', 'Tags': '<turing-machines>', 'CreationDate': '2013-06-01T19:11:05.340', 'Id': '12415'},47151:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to show that \n$$EQ_{DTM} = \\{ (\\langle M_1\\rangle,\\langle M_2\\rangle) \\mid M_1\\text{ and } M_2 \\text{ are  DTMs  and } L(M_1)=L(M_2)\\}$$\n and \n$$\\overline{EQ_{DTM}}$$\n are not semi-decidable. I think there must be a reduction from the complement of the halting problem.</p>\n', 'ViewCount': '140', 'Title': 'Show that the equivalence problem for deterministic Turing machines and its complement is not semi-decidable', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-02T19:23:57.457', 'LastEditDate': '2013-06-02T00:57:25.937', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8480', 'Tags': '<turing-machines><reductions><undecidability>', 'CreationDate': '2013-06-01T19:58:49.277', 'Id': '12417'},47152:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On the wikipedia article about the polynomial hierarchy <a href="http://en.wikipedia.org/wiki/Polynomial_hierarchy" rel="nofollow">http://en.wikipedia.org/wiki/Polynomial_hierarchy</a></p>\n\n<p>it says "$A^B$ is the set of decision problems solvable by a Turing machine in class A augmented by an oracle for some complete problem in class B"</p>\n\n<p>What is a "Turing machine in class A" for classes P, NP, and coNP?</p>\n\n<p>I\'m guessing a Turing machine in P is a deterministic Turing machine that can only run for polynomial time in the size of its input</p>\n\n<p>and that a Turing machine in NP is a nondeterministic Turing machine that can only run for polynomial time in the size of its input</p>\n\n<p>But I have no clue what is a Turing machine in class coNP ?</p>\n', 'ViewCount': '72', 'Title': 'What is a Turing Machine in class coNP', 'LastActivityDate': '2013-06-05T09:29:27.857', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '12468', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8526', 'Tags': '<turing-machines><decision-problem><np><polynomial-time>', 'CreationDate': '2013-06-05T07:51:19.400', 'Id': '12466'},47153:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What does $A^B$ mean where A and B are complexity classes?</p>\n\n<p>The "Polynomial Hierarchy" page says:</p>\n\n<p>$A^B$ is the set of decision problems solvable by a Turing machine in class A augmented by an oracle for some complete problem in class B</p>\n\n<p>In that case what is a Turing machine in class A?</p>\n\n<p>(besides just a machine of some sort that can solve problems in A, because that doesn\'t give any insight as to what it means to augment such a machine with an oracle)</p>\n\n<p>The motivation for this question was: <a href="http://cs.stackexchange.com/q/12466/6716">What is a Turing Machine in class coNP</a>. </p>\n', 'ViewCount': '70', 'Title': 'What does $A^B$ mean?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T13:37:08.837', 'LastEditDate': '2013-06-06T13:37:08.837', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8526', 'Tags': '<turing-machines><complexity-classes>', 'CreationDate': '2013-06-06T03:04:41.157', 'Id': '12480'},47154:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Constructivist logic is a system which removes the Law of the Excluded Middle, as well as \nDouble Negation, as axioms. It\'s described on Wikipedia <a href="http://en.wikipedia.org/wiki/Constructivist_logic">here</a> and <a href="http://en.wikipedia.org/wiki/Mathematical_constructivism">here</a>. In particular, the system doesn\'t allow for proof by contradiction.</p>\n\n<p>I\'m wondering, is anyone familiar with how this affects results regarding Turing Machines and formal languages? I notice that almost every proof that a language is undecidable relies on proof by contradiction. Both the Diagonalization argument and the concept of a reduction work this way. Can there ever be a "constructive" proof of the existence of an undecidable language, and if so, what would it look like?</p>\n', 'ViewCount': '504', 'Title': 'Do undecidable languages exist in constructivist logic?', 'LastActivityDate': '2013-07-11T06:23:13.290', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '12502', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><turing-machines><logic><proof-techniques><undecidability>', 'CreationDate': '2013-06-06T16:25:28.620', 'FavoriteCount': '2', 'Id': '12492'},47155:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working on old MC-Questions about decidability und don\'t have the answers to the following ones:</p>\n\n<p>1.) $L_1$ and $L_2$ are not decidable $\\Rightarrow$ No superset of $L_1 \\cup L_2$ is decidable</p>\n\n<p>2.) For Turing-acceptable languages L is "L = $\\emptyset$" a non-trivial property.</p>\n\n<p>3.) There are context-free languages $L_1$ and $L_2$ so that $L_1 \\cap L_2$ is not decidable.</p>\n\n<p>4.) $L$ is decidable $\\Leftrightarrow$ $L \\le \\{0\\}^* \\cdot \\{1\\}^*$</p>\n\n<p>I think 1.) is false, because $\\Sigma^*$ as a superset of many undecidable languages for example is decidable and 2.) is true, because there are Turing-acceptable languages with (exactly one) and without the property. I have no idea at 3.) and 4.). </p>\n', 'ViewCount': '233', 'Title': 'Multiple-Choice Questions about decidability', 'LastActivityDate': '2013-06-08T12:44:09.483', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8480', 'Tags': '<turing-machines><context-free><reductions><undecidability>', 'CreationDate': '2013-06-08T12:30:17.683', 'Id': '12527'},47156:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have some concerns about the Halting problem. This is the proof I know:</p>\n\n<p>Let $h(M, i)$ be a function, $M$ being Turing machine and $i$ input for the Turing machine. Let $h(M, i)$ output true whenever $M(i)$ halts. Let $h(M,i)$ output false if $M(i)$ does not halt.</p>\n\n<p>Then define $p(M)$ on Turing machine $M$. $p(M)$ will halt whenever $h(M, M)$ equals false and $p(M)$ will not halt whenever $h(M, M)$ is true.</p>\n\n<p>What will $p(p)$ do? Now, suppose $p(p)$ halts not. Then $h(p, p)$ is true so $p(p)$ will halt.\nSuppose $p(p)$ halts. Then $h(p, p)$ is false so $p(p)$ will not halt.</p>\n\n<p>So $p(p)$ will either halt and halt not.</p>\n\n<p>But, I think it will loop endlessly. $h(M, i)$ calls $M(i)$ and $p(M)$ will call $h(M, M)$. This is not a problem. But evaluating $p(p)$ results in calling $h(p, p)$ - which will check the value of $p(p)$. But therefor, $p(p)$ is called again, so there was a cycle and the program will continue in an infinite loop.</p>\n\n<p>What am I thinking wrong?</p>\n', 'ViewCount': '75', 'Title': 'Halting problem', 'LastActivityDate': '2013-06-08T18:43:20.273', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12539', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8588', 'Tags': '<turing-machines><halting-problem>', 'CreationDate': '2013-06-08T18:16:33.533', 'Id': '12538'},47157:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a a few fundamental doubts in recursive enumerability and countability and below, I have written what I understand them to be with proofs. But there are contradictions at the end. What is wrong with the statements/proofs i have made?</p>\n\n<p>Countability (C=Countable): A set $X$ is C when a bijection exists between the set of natural numbers and the set $X$</p>\n\n<p>Recursive Enumerability (RE= Recursively Enumerable): Say set $S\'$ is a subset of another set $S$. When there exists a turing machine with alphabet $A$ (where $S$ is a subset of $A^*$) which halts if the input to it belongs to the set $S\'$ and does not halt if the input belongs to $S-S\'$ then I say that the set $S\'$ is recursively enumerable (given the fact that inputs comes only from the set $S$ and not from $A^*-S$ hence the latter will not concern us.) I have referred to the book "Elements of the theory of Computation" by Papadimitrou for this definition, though the introduction of an alphabet A is my own addition to make things more firm</p>\n\n<p>Now I will prove 2 statements:</p>\n\n<ol>\n<li>if a set $X$ is RE then it is C</li>\n<li>if a set $X$ is C then it is RE</li>\n</ol>\n\n<p>Hence proving 3. RE iff C </p>\n\n<p>I will prove 2 first.</p>\n\n<p>I can write a Turing Machine $M$ which when asked to check if an element $x$ belongs to $X$ or not will follow the algorithm:</p>\n\n<p>There exists a mapping from the set of natural numbers to $X$ call it $f$. $M$ can search for $x$ (like a linear search algorithm running on $X$) starting from $f(1)$ going to $f(2)$... and it keeps going till it finds $x$. By this method, $M$ terminates iff $x$ belongs to $X$.</p>\n\n<p>The behaviour above proves that $X$ is RE</p>\n\n<p>Now I prove 1- Given a Turing Machine $M$ exists which halts iff $x$ belongs to $X$</p>\n\n<p>I can construct a bijective map from the set of naturals to $X$ as follows: To map $x$ (given it belongs to $X$) , we run it as input against $M$. I take the concatenation of all configurations (Configuration=tape head position+tape content+state) of $M$ which it goes through from the starting of a computation to the end and decode that string as a natural number. It will be unique.</p>\n\n<p>Hence 1. is proven and so is 3.</p>\n\n<p>But then I find certain resources on the internet which tell me that enumerability and recursive enumerability are different things. How is it possible? Furthermore- We know that the power set of a countably infinite set is uncountably infinite. If $X$ was countably infinite, it would be RE (see 2.). Now we know that the subset of a set which is C is also C. Hence all subsets of $X$ would be C hence they would be RE. Now there would be an uncountable number of RE sets. </p>\n\n<p>Now for each RE set, we can write a turing machine (with appropriate halting behaviour) which can be encoded as a natural number implying that the "set of all RE sets" must be C. This contradicts the conclusion of the previous paragraph.</p>\n\n<p>Where exactly am I wrong?\nThankyou in advance!</p>\n', 'ViewCount': '116', 'Title': 'Where am I wrong?: "countability" and "recursive enumerability"', 'LastActivityDate': '2013-06-13T19:55:03.743', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12665', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8657', 'Tags': '<computability><turing-machines><uncountability>', 'CreationDate': '2013-06-13T19:33:00.480', 'Id': '12664'},47158:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a deep appreciation for formalisms like the Turing Machine and the $\\lambda$-Calculus, and enjoy studying them and learning more about how they relate to physical computers. I am now learning about writing GUI programs, and the graphical library (GTK) relies on things like signals and callbacks, which I have not seen modeled by either Turing Machines or the $\\lambda$-Calculus; <strong>can either the $\\lambda$-Calculus or Turing Machines model things like signals, callbacks, sleeping/waiting, or buses?</strong> If so, where can I find some good reference material to learn more? If not, why not? and are there any formalisms which are capable of expressing such things?</p>\n', 'ViewCount': '146', 'Title': 'Can the Lambda Calculus or Turing Machines model signals, callbacks, sleep/wait, or buses?', 'LastActivityDate': '2013-09-18T18:46:18.427', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><computer-architecture><lambda-calculus><church-turing-thesis>', 'CreationDate': '2013-06-20T00:58:47.687', 'Id': '12771'},47159:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As I remember:</p>\n\n<ul>\n<li>A decision problem is a problem that has the answer yes or no.</li>\n<li>An algorithm (in the context of automata theory) answers yes or no; it halts on all inputs, accepted or not.</li>\n<li>A TM represents an algorithm. The TM accepts an input string and executes with that input. If the machine ends up in an accept state, the answer is yes, otherwise no.</li>\n</ul>\n\n<p>How does a yes/no problem relate to general algorithms we are doing that have more than yes/no problems? Or is that every problem can be thought as a yes/no problem, i.e. is this a function f produce 5 (or whatever input) with input 2 (or whatever output)?</p>\n', 'ViewCount': '85', 'Title': 'How a TM can represent any algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-23T20:55:36.627', 'LastEditDate': '2013-06-21T06:24:53.090', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '12793', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-06-20T07:57:48.957', 'Id': '12781'},47160:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a question I found in a practice exam while I am preparing for my mid term exam.</p>\n\n<p>The answer needs justification, either a pseudo code or a logical explanation why not.</p>\n\n<p>What puzzled me about that question is that we already know that all LOOP programs terminate at some point, the question seems odd to me.</p>\n\n<p>Any references about LOOP and/or WHILE programs are  welcome. Our professor didn't give much.</p>\n", 'ViewCount': '90', 'Title': 'Can a Turing machine decide if a LOOP program stops for the integer input 0', 'LastActivityDate': '2013-06-26T02:48:46.597', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12905', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8874', 'Tags': '<turing-machines><halting-problem><loops>', 'CreationDate': '2013-06-26T01:31:21.623', 'Id': '12903'},47161:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Solve this problem: "build an infinite binary oscilator"</p>\n\n<p>With a Turing Machine we can solve it</p>\n\n<pre><code>a=False\nWhile True:\n   a=not a\n   print a,\n</code></pre>\n\n<p>then output will be</p>\n\n<pre><code>True False True False True False ...\n</code></pre>\n\n<p>(for ever)</p>\n\n<p>I think an oracle can\'t do it, because its definition, it could solve in "one operation", but here there\'s not halting as a request of the problem statement. Is it true?</p>\n\n<p><strong>EDIT</strong>:  Oracle definition from wikipedia</p>\n\n<p>".. an\xa0<em>oracle machine</em>\xa0is an\xa0abstract machine\xa0used to study\xa0decision problems. It can be visualized as a\xa0Turing machine with a black box, called an\xa0<em>oracle</em>, which is able to decide certain decision problems in a single operation. The problem can be of any\xa0complexity class. Even\xa0undecidable problems, like the\xa0halting problem, can be used."</p>\n\n<p>So what if that TM ask its black box oracle to create an infinite binary oscilation?</p>\n\n<pre><code>   1- oracle black box can\'t do infinite loops\n   2-TM can\'t ask that problem to oracle \n   3- Does it return a string with a source code as answer? weird\n   4-or other options...\n</code></pre>\n', 'ViewCount': '140', 'Title': 'Is oracle computer capable of doing infinite loops?', 'LastEditorUserId': '1396', 'LastActivityDate': '2013-06-27T08:30:35.333', 'LastEditDate': '2013-06-26T22:30:23.360', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12920', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<turing-machines><halting-problem><oracle-machines>', 'CreationDate': '2013-06-26T18:33:18.140', 'Id': '12917'},47162:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In <a href="http://cs.stackexchange.com/questions/909/knapsack-problem-np-complete-despite-dynamic-programming-solution">a different post</a> it came up that \n(using the Turing machine model of computation), \nit is not even safe to say that $N$ numbers can be read in $O(N)$ time.\nTo me this is boggling since \nit\'s something I take for granted in the RAM model of computation, \nand I admittedly only have a cursory understanding of Turing machines.</p>\n\n<p>However, the more boggling part is that \nthe same person claimed that in the Turing machine model \nwe cannot read $N$ numbers even in exponential time,\nBUT that we can read the input for Knapsack and fill a table of size $N$ by $w$ in exponential time.</p>\n\n<p>How can filling a two-dimensional $N$ by $w$ array take less time than \nan $N$ by $1$ array?</p>\n', 'ViewCount': '164', 'Title': 'Can we read N numbers in O(N) time?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-06-30T07:07:41.653', 'LastEditDate': '2013-06-30T07:07:41.653', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8932', 'Tags': '<complexity-theory><turing-machines>', 'CreationDate': '2013-06-30T05:49:35.830', 'FavoriteCount': '1', 'Id': '12981'},47163:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I hope my question makes sense: Starting with the premise that the untyped $\\lambda $ calculus is equivalent in power to a Turing machine, to what in a Turing machine does adding types to the $\\lambda $ calculus correspond? Is there some kind of automaton analog to typing, whether static or dynamic?</p>\n', 'ViewCount': '123', 'Title': 'To what does typing correspond in a Turing Machine?', 'LastActivityDate': '2013-07-09T03:05:03.767', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><lambda-calculus><type-theory><church-turing-thesis>', 'CreationDate': '2013-07-08T05:47:39.780', 'FavoriteCount': '2', 'Id': '13158'},47164:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '175', 'Title': 'Why every finite set is computable?', 'LastEditDate': '2013-07-10T08:48:48.523', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2260', 'FavoriteCount': '1', 'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/Recursive_set#Examples" rel="nofollow">wikipedia</a>, every finite set is computable. \nDefinition: set $S \\subset N$ is <em>computable</em> if there exists an algorithm which defines in finite time if a given number $n$ is in Set.</p>\n\n<p>Question: what is wrong with this counter-example:</p>\n\n<ul>\n<li>given some $TM$</li>\n<li>$S \\subset N$</li>\n<li>Lets assume $S$ could contain only $0$, i.e., either $S = \\{0\\}$ or $S = \\emptyset$</li>\n<li>if a given $TM$ halts then $S=\\{0\\}$ otherwise $S=\\emptyset$</li>\n</ul>\n\n<p>So set $S$ is finite, but not computable, since we cannot "compute" if a given $TM$ halts.</p>\n\n<p>What is wrong above?</p>\n', 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '2260', 'LastActivityDate': '2013-07-12T05:55:27.977', 'CommentCount': '5', 'AcceptedAnswerId': '13177', 'CreationDate': '2013-07-09T13:58:30.313', 'Id': '13173'},47165:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a practice problem for a midterm in a class I'm taking:</p>\n\n<blockquote>\n  <p>Given a regular language $L$, describe formally a Turing machine that recognize $L$. </p>\n</blockquote>\n\n<p>I'm not sure how I should do that.</p>\n", 'ViewCount': '440', 'Title': 'How can a Turing Machine recognize a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T15:30:56.463', 'LastEditDate': '2013-07-30T10:26:40.687', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<turing-machines><regular-languages><automata><finite-automata><simulation>', 'CreationDate': '2013-07-29T19:45:40.207', 'Id': '13500'},47166:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The proof of the undecidability of $A_{TM}$ in Michael Sipser\'s textbook<code>*</code> contains the definition of a Turing Machine, which accepts the encoding of a TM, if this TM doesn\'t accept its own encoding, and rejects it, if it does. If this TM is run on its own encoding, there is problem: it should accept if it doesn\'t accept and vice versa.</p>\n\n<p>My problem with this proof is that it strongly resembles <a href="http://en.wikipedia.org/wiki/Russell%27s_paradox" rel="nofollow">Russel\'s paradox</a>. This paradox arises if we define a set, which contains all sets that are not members of themselves. If we ask whether this set contains itself, there is problem: it should contain itself if it doesn\'t contain itself and vice versa. </p>\n\n<p>Russels\'s paradox has been eliminated from axiomatic set theory: in <a href="http://en.wikipedia.org/wiki/ZFC" rel="nofollow">ZFC</a>, it follows from the axioms that such a property doesn\'t define a valid set. Interestingly enough, in the theory of computation, a similar property defines a valid TM. </p>\n\n<p>That\'s why I don\'t like the proof in Sipser\'s book. I\'d like to emphasize that I know that this proof is perfectly valid, but I\'d like to know if there is another proof which follows a different chain of thought, and doesn\'t define such a TM.</p>\n\n<hr>\n\n<p><code>*</code>Sipser, M.: Introduction to the Theory of Computation (2nd ed.), 2006, page 179. On this page, Sipser uses the term <em>halting problem</em> for the language $A_{TM}$. The proper name for this language is <em>acceptance problem</em>, see the footnote on page 188.</p>\n', 'ViewCount': '101', 'Title': 'Alternative proof for the undecidability of $A_{TM}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-16T11:23:01.367', 'LastEditDate': '2013-08-16T11:23:01.367', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '13770', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<terminology><computability><turing-machines><halting-problem>', 'CreationDate': '2013-08-15T21:00:43.357', 'Id': '13766'},47167:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It\'s known that the following language, the so-called acceptance problem is undecidable:</p>\n\n<p>$A_{TM} = \\{\\langle M,w\\rangle\\,\\vert\\,M\\text{ is a TM which accepts }w\\}$</p>\n\n<p>The proof is by contradiction: Assume there is a TM $H$ which decides $A_{TM}$. Let $D$ be another TM. Given the code of a TM $M$, $\\langle M\\rangle$ as input, $D$ simulates $H$ on $\\langle M,\\langle M\\rangle\\rangle$, and accepts, if $H$ rejects this input and rejects, if $H$ accepts it. That is, $D$ accepts $\\langle M\\rangle$ if $M$ rejects its own code, and vice versa. Running $D$ on its own code, $\\langle D\\rangle$, leads to contradiction.</p>\n\n<hr>\n\n<p>Let\'s restrict $A_{TM}$ by excluding all input strings which encode a TM:</p>\n\n<p>$E = \\{w\\,\\vert\\,w\\text{ is a structurally valid encoding of a TM}\\}$\n $A\'_{TM} = \\{\\langle M,w\\rangle\\,\\vert\\,M\\text{ is a TM which accepts }w\\text{ and }w\\not\\in E\\}$</p>\n\n<p>I\'d like to know whether $A\'_{TM}$ is also undecidable. </p>\n\n<p>I tried to prove it the above way: Assume there is a TM $H\'$ which decides $A\'_{TM}$. Let $D\'$ be another TM. Given the code of a TM $M$, $\\langle M\\rangle$ as input, $D\'$ simulates $H\'$ on $\\langle M,\\langle M\\rangle\\rangle$, and accepts, if $H\'$ rejects this input and rejects, if $H\'$ accepts it. The problem is that running $D\'$ on its own code, $\\langle D\'\\rangle$, doesn\'t necessarily lead to contradiction. I mean since $\\langle D\',\\langle D\'\\rangle\\rangle$ is not a member of $A\'_{TM}$, we don\'t know what $H\'$ will do with it.</p>\n\n<hr>\n\n<p><strong>Note: An encoding of TMs, and TMs along with an input string</strong></p>\n\n<p>Let $M = (Q, \\Sigma, \\Gamma, \\delta, q_{i}, q_{a}, q_{r})$ be a TM, where </p>\n\n<ul>\n<li>$Q$ is the set of states, </li>\n<li>$\\Sigma = \\{0, 1\\}$ is the input alphabet, </li>\n<li>$\\Gamma$ is the tape alphabet ($\\Sigma\\subset\\Gamma$), </li>\n<li>$\\delta: (Q-\\{q_a, q_r\\})\\times\\Gamma\\rightarrow Q\\times\\Gamma\\times\\{L,R,S\\}$ is the transition function,</li>\n<li>$L$, $R$ and $S$ denote the respective head movements, "left", "right" and "stay", and</li>\n<li>$q_i$, $q_a$ and $q_r$ are the initial, accepting and rejecting state, respectively. </li>\n</ul>\n\n<p>Let\'s assign a unique positive integer to each element of $Q$, and do the same in case of $\\Sigma$, $\\Gamma$ and $\\{L,R,S\\}$. Now every transition rule $\\delta(p, a) = (q, b, m)$ can be encoded as $\\langle p\\rangle 1\\langle a\\rangle 1\\langle q\\rangle 1\\langle b\\rangle 1 \\langle m\\rangle$, where $\\langle x\\rangle$ denotes a sequence of $0$\'s, with length being equal to the positive integer assigned to $x$. The encoding of $M$, denoted by $\\langle M\\rangle$, can be created by concatenating its transition rules, separated by $11$\'s. The combined encoding of $M$, and an input string, $w\\in\\Sigma^*$, denoted by $\\langle M,w\\rangle$ is $\\langle M\\rangle111w$.</p>\n', 'ViewCount': '111', 'Title': 'Undecidability of a restricted version of the acceptance problem', 'LastEditorUserId': '9571', 'LastActivityDate': '2013-08-16T16:02:40.407', 'LastEditDate': '2013-08-16T14:04:03.693', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13776', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-08-16T08:47:47.587', 'Id': '13771'},47168:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to prove that this language is in co-NPC:\n$\\{ \\langle M,x,1^n \\rangle \\mid M $ is a TM and for all $c \\in \\Sigma^*$ , $M$ accepts in $ $$n$ steps when given $(x,c)$ as input $\\}$.</p>\n\n<p>I tried to do so by showing that the complement is in NPC, that is $\\{ \\langle M,x,1^n \\rangle \\mid M $ is a TM and there exists  $c \\in \\Sigma^*$ , s.t $M$ doesn't accepts in $n$ steps when given $(x,c)$ as input $\\}$.</p>\n\n<p>I can prove that it's in NP by giving a polynomial non-deterministic algorithm, but I get stuck in the reduction part and don't know from which language in NPC to do a polynomial reduction and how. Does anybody know how do deal with such reduction?</p>\n", 'ViewCount': '54', 'Title': 'Showing a language is in co-NPC', 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-18T13:57:00.253', 'LastEditDate': '2013-08-18T13:57:00.253', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9713', 'Tags': '<complexity-theory><turing-machines><np-complete>', 'CreationDate': '2013-08-17T18:24:44.037', 'Id': '13792'},47169:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given this question:</p>\n\n<blockquote>\n  <p>$L$ is an infinite language of encoded Turing machines who always halt.</p>\n  \n  <ol>\n  <li>$L$ might be decidable </li>\n  <li>$L$ might be in RE but not in R</li>\n  <li>both 1. and 2. are correct</li>\n  </ol>\n</blockquote>\n\n<p>I know the solution to this question is 3., but I seem to lack the understanding on how am I suppose to get to that solution. Could you explain how should I approach this kind of questions? Am I supposed to start drawing TMs?\nWhy is the answer is C? What's the indication of that?</p>\n\n<p>It would help me a lot if you could explain to me your thought process when facing this kind of problem.</p>\n", 'ViewCount': '67', 'Title': 'Classifying infinite languages of encodings of halting Turing machines', 'LastEditorUserId': '9844', 'LastActivityDate': '2013-08-26T17:52:28.617', 'LastEditDate': '2013-08-26T15:47:34.610', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '13945', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9844', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-08-26T15:15:31.767', 'Id': '13943'},47170:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>By a vanilla Turing machine, I mean a Turing machine with one tape (no special input or output tapes).</p>\n\n<p>The problem is as follows: the tape is initially empty, other than a string of $n$ $1$s and $0$s terminated by an end-of-string character. The tape head starts at the beginning of the string. The goal is for the tape to contain the original string in reverse order, terminated by an end-of-string character, with the tape head returned to the beginning of the string when the Turing machine finally halts.</p>\n\n<p>The Turing machine can use as large an alphabet as we like (so long as it contains $0$, $1$, and an end-of-string character), and can have as many states as we like. Is there a fixed Turing machine that can complete this task in time $o(n^2)$?</p>\n\n<p>It's easy to do this in time $O(n^2)$ using just a few states and symbols. It seems intuitively clear that something prevents us from doing it more than a constant factor faster, but I've never been able to prove it, and I often worry late into the night about miraculous applications of network coding or voodoo magic that somehow get a logarithmic speedup...</p>\n", 'ViewCount': '392', 'Title': 'Can you do an in-place reversal of a string on a vanilla turing machine in time $o(n^2)$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-28T21:23:11.410', 'LastEditDate': '2013-08-28T09:35:04.997', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '13996', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9868', 'Tags': '<complexity-theory><time-complexity><turing-machines>', 'CreationDate': '2013-08-28T06:19:06.700', 'Id': '13988'},47171:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to prove that\n$\\textbf{REACH} \\leq_{\\textbf{L}} \\textbf{CIRCUIT-VALUE}$</p>\n\n<p>$\\textbf{REACH}$ is the well-known reachability problem: checking whether there is a connection from vertex $\\textbf{a}$ to vertex $\\textbf{b}$ in a graph $\\textbf{G}$.</p>\n\n<p>$\\textbf{CIRCUIT-VALUE}$ is the well-known CVP problem: checking whether a boolean circuit with gates outputs $\\textbf{TRUE}$.</p>\n\n<p>The reduction I\'m interested in is the "Mapping-Reduction".\nI\'ve considered, converting a given Graph to be used as input for the $\\textbf{CIRCUIT-VALUE}$-Problem. This conversion must be logarithmic.</p>\n', 'ViewCount': '94', 'ClosedDate': '2013-11-11T13:49:59.257', 'Title': 'Prove that REACH can be logarithmically reduced to CIRCUIT-VALUE', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-10T07:54:52.697', 'LastEditDate': '2013-09-06T15:04:46.460', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9978', 'Tags': '<complexity-theory><turing-machines><reductions>', 'CreationDate': '2013-09-04T09:07:34.980', 'Id': '14123'},47172:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>as the title states, I am trying to figure out if my approach to solving mapping reduction from $E_{TM}$ to some other language is correct. As you surely know, $E_{TM} = \\left \\{ &lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M)= \\emptyset \\right \\} $. What i am trying to check is whatever a string <strong>x</strong> is in L(M). My idea is to analyse $&lt;M&gt;$ in oder to check if there are any transition to $q_{accept}$, if so then L(M) cannot be empty. Now let\'s take another language, for instance let $REVERSE_{TM} = \\left \\{&lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M) = L(M)^{R} \\right \\} $ or even $REGULAR_{TM} = \\left \\{&lt; M&gt; \\mid M \\ is \\ a \\ TM \\ such \\ that \\ L(M) \\ is \\ regular \\right \\} $.\nLet\'s prove that $E_{TM} \\leq_{m} REVERSE_{TM} $. Since i need to convert an istance <em>"yes"</em> <strong>w</strong> of $E_{TM}$ trought a function <strong>f</strong>, to <strong>f(w)</strong> which is an instance <em>"yes"</em> of $REVERSE_{TM}$. $f(&lt;M&gt;) = &lt;M^{\'}&gt;$, where $&lt;M^{\'}&gt;$ is a TM whose behaviour on input x is</p>\n\n<ol>\n<li><p>if $x \\neq x^{R}$ then accept.</p></li>\n<li><p>if $x = x^{R}$ then,</p>\n\n<ul>\n<li><p>analyse $&lt;M&gt;$ and if there are no transitions to $q_{accept}$ then accept</p></li>\n<li><p>else do not accept x </p></li>\n</ul></li>\n</ol>\n\n<p>Which language does M\' recognize? It should recognize $ \\Sigma^{*} $ if $L(M) = \\emptyset $ meanwhile it should match $ \\left \\{ x \\in \\Sigma^{*} \\mid x \\neq x^{R} \\right \\} $.\nWe know that $(\\Sigma^{*})^{R} = \\Sigma^{*}$, so $&lt;M\'&gt; \\in REVERSE_{TM} &lt;=&gt; L(M) = \\emptyset$. I think this mapping reduction should be correct but is it correct to let M\' analyse M in order to figure out if L(M) is really empty (if it\'s empty there should be no transition to $q_{accept}$) ? Or is there another way to solve these reduction from $E_{TM}$ ? </p>\n', 'ViewCount': '68', 'Title': 'Correct approach to Mapping Reduction from $E_{TM}$', 'LastActivityDate': '2013-09-07T14:27:57.417', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9989', 'Tags': '<formal-languages><turing-machines><reductions>', 'CreationDate': '2013-09-07T14:27:57.417', 'Id': '14194'},47173:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '202', 'Title': 'Machines in P undecidable?', 'LastEditDate': '2013-09-09T10:30:31.167', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9515', 'FavoriteCount': '1', 'Body': "<p>Given a Turing machine $M$, we say that $L(M) \\in P$ if the language decided by the machine can be decided by some machine in polynomial time. We say that $M \\in P$ if the machine runs in polynomial time. Note that there can be machines that run needlessly long but still decide a language in $P$. By Rice's theorem, we know that</p>\n\n<p>$\\{ \\langle M \\rangle \\mid M \\mbox{ is a Turing machine such that }L(M) \\in P \\mbox{ } \\}$ is undecidable. Is it known whether:</p>\n\n<p>$\\{ \\langle M \\rangle \\mid M \\mbox{ is a Turing machine such that }M \\in P \\mbox{ } \\}$ is also undecidable?</p>\n", 'Tags': '<computability><time-complexity><turing-machines>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T10:30:31.167', 'CommentCount': '4', 'AcceptedAnswerId': '14216', 'CreationDate': '2013-09-08T17:55:31.410', 'Id': '14215'},47174:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '551', 'Title': 'Undecidable among these for turing machine', 'LastEditDate': '2013-09-21T17:23:03.633', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10264', 'FavoriteCount': '2', 'Body': "<p>Below are two questions I found in Theory of Computation book but couldn't find its correct answers, can anyone please give correct answers with explanation?</p>\n\n<ol>\n<li>It is undecidable, whether\n<ol>\n<li>an arbitrary Turing machine(TM) has 15 states</li>\n<li>an arbitrary TM halts after 10 steps</li>\n<li>an arbitrary TM ever prints a specific letter</li>\n<li>an arbitrary TM accepts a string w in 5 steps</li>\n</ol></li>\n<li>Which one of the following is not decidable?\n<ol>\n<li>given a TM M, a string s and an integer k, M accepts s with k steps</li>\n<li>equivalence of two given TMs</li>\n<li>language accepted by a given DFSA(Deterministic finite state automata) is nonempty</li>\n<li>language accepted by a CFG(Context free grammar) is nonempty  </li>\n</ol></li>\n</ol>\n\n<p>Update: In first question I think 1.2 is right because halting is undecidable for Turing machine but not sure whether remaining options are decidable or not.<br>\nIn second question I think 2 is right, but not sure about the decidability of non emptiness of CFG and DFSA.</p>\n", 'Tags': '<formal-languages><turing-machines><undecidability>', 'LastEditorUserId': '10264', 'LastActivityDate': '2013-09-27T20:19:53.660', 'CommentCount': '16', 'AcceptedAnswerId': '14644', 'CreationDate': '2013-09-21T16:00:54.280', 'Id': '14498'},47175:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A type-0 grammar generates a recursively enumerable (RE) language. </p>\n\n<p>A RE language is also known as a semi-decidable language. </p>\n\n<p>A semi-decidable language is a particular kind of undecidable language: If a language is semi-decidable, we can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely. </p>\n\n<p>Problem: Provide an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>Answer (I think): The following grammar generates this language: </p>\n\n<pre><code>(a+b+) union (infinite a's)\n</code></pre>\n\n<p>Here is the grammar:</p>\n\n<pre>\nS &rarr; aA | bE\nA &rarr; aA | bB\nB &rarr; bB | &epsilon; | aE\nbE &rarr; aE \nE &rarr; aE\n</pre>\n\n<p>A method for recognizing strings in the language generated by this grammar would return true for strings that are an element of a+b+ and would run indefinitely for strings that are not an element of a+b+</p>\n\n<p>I think that this is an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>If I am incorrect, would you provide an example please?</p>\n", 'ViewCount': '73', 'Title': 'Is this an example of a type-0 grammar that is not context-sensitive?', 'LastActivityDate': '2013-09-21T20:01:25.747', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><formal-grammars><undecidability><linear-bounded-automata>', 'CreationDate': '2013-09-21T20:01:25.747', 'FavoriteCount': '1', 'Id': '14503'},47176:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I feel the notion "there are countably many Turing machines" is wrong.\nSuppose there is a Turing machine whose input alphabet is {0}. If we replace the input alphabet {0} with {a} and replace every occurrence of "0" with "a" in the transition table, then we get another Turing machine. Obviously, these two machines are different beacause they recognize different languages, but using any one reasonable encoding sheme, they could be encoded into the same string. So claiming Turing machines are countable only by enumerating their encodings is wrong, because actually there isn\'t a bijection between Turing machines and their encodings.\nIs my opinion right?</p>\n', 'ViewCount': '411', 'Title': 'Are turing machine really countable?', 'LastEditorUserId': '9612', 'LastActivityDate': '2013-10-03T16:35:08.960', 'LastEditDate': '2013-09-22T16:04:52.503', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10270', 'Tags': '<turing-machines>', 'CreationDate': '2013-09-22T12:31:17.460', 'Id': '14517'},47177:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$L = \\{ \\langle M \\rangle \\mid \\text{there is at least one input string on which the \\(M\\) does not halt} \\}$</p>\n\n<p>Here, for a Turing machine $M$, the notation $\\langle M \\rangle$ denotes an encoding, over some alphabet, of the code of the Turing machine. To which of the following language classes does $L$ belong?</p>\n\n<ol>\n<li>Regular.</li>\n<li>Context-free but not Regular.</li>\n<li>Recursive but not Context-free.</li>\n<li>Recursively enumerable but not recursive.</li>\n<li>Not recursively enumerable.</li>\n</ol>\n', 'ViewCount': '145', 'Title': 'Class of the language of Turing machines that loop on at least one input', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-26T10:10:34.713', 'LastEditDate': '2013-09-26T10:10:34.713', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<regular-languages><turing-machines><turing-completeness>', 'CreationDate': '2013-09-26T02:21:15.667', 'FavoriteCount': '1', 'Id': '14615'},47178:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm reading Sipser and I'm finding it hard to understand what the process is such that if you give me k Turing machines with k tapes, I can spit out an equivalent Turing machine with only one tape. An example would be nice. Actually, a worked out example that shows how to go from TM that has $k$ tapes to one that has 1 tape is what I'm really looking for. I have been unable to find one so far. I'm also not looking for any proofs.</p>\n", 'ViewCount': '882', 'Title': 'Show how to k tapes of Turing machines into one dimensional Turing machine', 'LastEditorUserId': '9819', 'LastActivityDate': '2014-04-20T02:40:25.263', 'LastEditDate': '2013-09-26T18:51:37.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '14621', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<turing-machines><simulation>', 'CreationDate': '2013-09-26T04:08:07.253', 'Id': '14619'},47179:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was looking at this: <a href="http://www.cs.odu.edu/~toida/nerzic/390teched/tm/othertms.html" rel="nofollow">http://www.cs.odu.edu/~toida/nerzic/390teched/tm/othertms.html</a></p>\n\n<p>At the very beginning, they show a 2d tape and (I assume) it\'s 1d equivalent. However, I cannot figure out they got from the 2d case to the 1d case. I was hoping someone could elaborate.</p>\n', 'ViewCount': '315', 'Title': 'Two Dimensional Tape of Turing Machine', 'LastActivityDate': '2013-09-26T17:07:19.787', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<computability><turing-machines><simulation>', 'CreationDate': '2013-09-26T16:50:20.973', 'Id': '14628'},47180:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '114', 'Title': 'Show a TM-recognizable language of TMs can be expressed by TM-description language of equivalent TMs', 'LastEditDate': '2013-09-30T09:36:29.020', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2260', 'FavoriteCount': '1', 'Body': '<p>I am studying "An Introduction to the Theory of Computation" by Sipser -- there is a problem *3.17 (p.161) which I can not solve. \nAny <em>hints</em> (not <em>answers</em>) from which side to attack it?</p>\n\n<blockquote>\n  <p>Let $B=\\{M_1, M_2, ...\\}$ be a Turing-recognizable language consisting of TM descriptions. Show that there is a <em>decidable</em> language C consisting of TM descriptions s.t. every machine in B has an equivalent machine in C and vice versa.</p>\n</blockquote>\n', 'Tags': '<turing-machines><decision-problem>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-30T09:36:29.020', 'CommentCount': '0', 'AcceptedAnswerId': '14681', 'CreationDate': '2013-09-29T19:10:48.200', 'Id': '14680'},47181:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have seen web sites that purport to "prove" that HTML5+CSS is Turing Complete.</p>\n\n<p>I have seen web sites that purport to "prove" that SQL is Turing Complete.</p>\n\n<p>I have seen a bunch of web sites that purport to "explain" what it means to be Turing Complete.</p>\n\n<p>Enough!</p>\n\n<p>Where can I find a book (written by an expert in computability theory) or a peer-reviewed article (in a reputable journal) that shows a proof of, "This language XYZ is capable of describing a computational machine which has the same computational power as a Turing Machine"?</p>\n', 'ViewCount': '315', 'Title': 'Clear, complete, proof that a language is Turing Compete?', 'LastActivityDate': '2013-09-30T17:12:59.010', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><automata><turing-completeness><church-turing-thesis>', 'CreationDate': '2013-09-30T11:35:37.607', 'FavoriteCount': '1', 'Id': '14697'},47182:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was given a quick lesson on Turing Machines which I found interesting. However, I came up with a problem which made me think a bit on a problem and since it's not an actual class, the answer was not given. First, let me give you some background info on a Turing Machine:</p>\n\n<pre><code>A Turing machine is a quadruple (K, sigma, small delta, s), where\n  K is a finite set of states, not containing the halt stage h;\n  sigma is an alphabet, containing the blank symbol #, but not containing symbols L and R;\n  s is in K is the initial state;\n  small delta is the rate of change.\n</code></pre>\n\n<p>With that info in mind, I have the following problem:</p>\n\n<pre><code>Consider the Turing machine M = (K, sigma, small delta, s), where\n  K = {q0,q1} //only has two states\n  sigma = {a,#} //only has a and the blank symbol\n  s = q0 //will start at 10\n\nand small delta is given by the following table.\n  q      small sigma      small delta(q,small sigma)\n  q0      a                 (q1,#)\n  q0      #                 (h,#)\n  q1      a                 (q0,a)\n  q1      #                 (q0,R) //move one cell of the tape to the right\n</code></pre>\n\n<p>With this info and the following example, we have:</p>\n\n<pre><code>a|a|#\n</code></pre>\n\n<p>Let's check the first cell, it's a and we are in the initial state. If it's a, change it to #.</p>\n\n<pre><code>#|a|#\n</code></pre>\n\n<p>We're still on the same cell, but we changed states, q1. The alphabet is #, so let's go back to the initial state and go one cell to the Right.</p>\n\n<p>The next cell has an a as well, so we change it to #. Go to state q1 and check if the alphabet is blank. It is, so we go one cell to the right.</p>\n\n<pre><code>#|#|#&lt;we're in this cell now.\n</code></pre>\n\n<p>Now we go to the initial state and check if the alphabet is a, it isn't so let's check if it's blank. It is, so we halt the whole thing.</p>\n\n<p>We have</p>\n\n<pre><code>#|#|#\n</code></pre>\n\n<p>Pretty straightforward, right? Well, I have thought of one thing. What if the tape had something that was not taken into consideration?</p>\n\n<p>Something like</p>\n\n<pre><code>a|b|a|#\n</code></pre>\n\n<p>Would the Turing machine crash or would it ignore it?</p>\n\n<p>Thank you for your time.</p>\n", 'ViewCount': '78', 'Title': 'What happens when an alphabet is not listed in a Turing Machine?', 'LastActivityDate': '2013-10-18T18:13:55.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16207', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<turing-machines>', 'CreationDate': '2013-10-18T17:55:51.023', 'Id': '16204'},47183:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $PAL = \\{ww^R\\ | w\\in\\{0,1\\}^*\\}$. </p>\n\n<p>Then let $A = \\{\\langle M\\rangle \\ | \\textit{M is a Turing Machine and } L(M)\\subseteq PAL\\}$</p>\n\n<p>Is A semi-decidable (Turing recognizable or recursively enumerable)?</p>\n\n<p>My try!</p>\n\n<p>I said it is so here is my proof, tell me if I am way off base or tell me if A ought not to semi-decidable in the first place.</p>\n\n<p>$\\underline{Proof}$</p>\n\n<p>A is semi-decidable by The Certificate Theorem, which states that:</p>\n\n<p>If $A\\subseteq\\Sigma^*$ then $A\\in SD$(semi-decidable) iff there is some decidable relation, $R\\subseteq \\Sigma^* \\times \\Sigma^*$, such that $\\forall x\\in\\Sigma^*$, $x\\in{A}$ iff $\\exists y$ such that $R(x,y)$ holds.</p>\n\n<p>We know that if $x\\in{A}$ that means that $x=\\langle M\\rangle$, so we can choose $y = \\langle M,w\\rangle$ where $w\\in{PAL}$. What we know is that when $M$ takes $w$ as an input it will accept (since we choose $w$ as an input), if that is the case then $w\\in{L(M)}\\subseteq{PAL}$. That means that $A\\in{SD}$. QED</p>\n\n<p>Any help would be greatly appreciated, have a great day!</p>\n', 'ViewCount': '191', 'Title': 'Is the language that consists of machine configurations whose language is a subset of even palindromes semi-decidable?', 'LastActivityDate': '2013-10-21T06:15:55.890', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-10-20T19:26:57.903', 'Id': '16264'},47184:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am doing a presentation about Turing machines and I wanted to give some background on FSM\'s before introducing Turing Machines. Problem is, I really don\'t know what is VERY different from one another.</p>\n\n<p>Here\'s what I know it\'s different:</p>\n\n<pre><code>FSM has sequential states depending on the corresponding condition met while Turing machines operate on infinite "Tape" with a head which reads and writes.\n\nThere\'s more room for error in FSM\'s since we can easily fall on a non-ending state, while it\'s not so much for Turing machines since we can go back and change things.\n</code></pre>\n\n<p>But other than that, I don\'t know a whole lot more differences which make Turing machines better than FSM\'s.</p>\n\n<p>Can you please help me?</p>\n', 'ViewCount': '1325', 'Title': 'Difference between a turing machine and a finite state machine?', 'LastActivityDate': '2013-10-21T22:34:21.923', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10398', 'Tags': '<turing-machines>', 'CreationDate': '2013-10-21T20:45:02.480', 'Id': '16315'},47185:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m considering an automaton $A$ over a alphabet $\\Sigma$, with a set of states $Q$, such that $\\Sigma \\subset Q$, which includes special "accept" and "blank" states not in $\\Sigma$. It also has an infinite list of cells, which begins with the input string, the rest being blank. It has a transition function $\\delta: Q \\times Q \\times Q \\to Q$. The automaton computes by updating the value  of the middle cell, $a$, using $\\delta(x,a,y)$. The automaton accepts if any cell is in the accept state. From what I understand, this automaton is very similar to a 1-dimensional cellular automaton, with the addition of the accept state.</p>\n\n<p>I\'m trying to prove that a language is recognizable by a Turing machine if and only if it can be recognized by the automaton described.</p>\n\n<p>I\'ve been trying to do a proof by construction, but I\'m really lost. I did some research on cellular automata, but the material I\'ve been finding is way over my level. I know somehow I\'m going to have to construct a TM from CA, and vica versa, but I\'m not even sure how to get started. I would really appreciate any help.</p>\n', 'ViewCount': '234', 'Title': 'Proving Equivalence of 1-dimensional Cellular Automaton and Turing Machines', 'LastEditorUserId': '630', 'LastActivityDate': '2013-10-22T13:58:25.280', 'LastEditDate': '2013-10-22T13:58:25.280', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16322', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10448', 'Tags': '<turing-machines><cellular-automata>', 'CreationDate': '2013-10-22T04:11:52.023', 'Id': '16321'},47186:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $C$ be an infinite set of characters.  I'd like an abstract machine which can recognize sequences consisting of $k$ (constant) of repetitions of a char from $C$.</p>\n\n<p>For example, if ${x,y,z} \\subset C$, and $k = 3$, it should recognize $xxx$ but not $ddd$ or $xyz$.  (The same char must be repeated.)</p>\n\n<p>Since $C$ is infinite, a finite state machine <em>cannot</em> recognize this.  A Turing machine trivially can.  But we don't anything like the power of a Turing machine; simply extending the FSM with a single register that points to a member of $C$ is enough.</p>\n\n<p>My question is: What's the simplest formal abstract machine that is powerful enough to recognize this? Is there a standard extension to FSM's that enables them to recognize this? If I have more complicated versions of this machine (e.g. <em>Move from state 2 to state 3 if you encounter a $k$ repetition of a $C$ char</em>), what's the best way to express them?</p>\n", 'ViewCount': '108', 'Title': 'Abstract machine that can recognize repetition', 'LastActivityDate': '2013-12-22T22:31:30.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<formal-languages><computability><turing-machines><automata><finite-automata>', 'CreationDate': '2013-10-23T13:09:59.097', 'Id': '16362'},47187:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I would have a brief question about how to construct a Turing machine that is accepting <em>only</em> this language:</p>\n\n<p>$\\qquad\\displaystyle L_2 = \\{a^i b^j \\mid i \\geq j \\}$.</p>\n\n<p>I can't come up with any mechanism that would preserve that there are greater or equal number of 'a's than 'b's. Could you suggest me something?</p>\n", 'ViewCount': '406', 'Title': 'Turing machine for $a^i b^j$ with $i \\geq j$', 'LastEditorUserId': '630', 'LastActivityDate': '2014-02-03T11:19:19.737', 'LastEditDate': '2013-11-05T03:58:44.963', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11176', 'Tags': '<formal-languages><turing-machines><automata>', 'CreationDate': '2013-11-04T17:05:54.830', 'FavoriteCount': '0', 'Id': '16713'},47188:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an assignment where i need to create a Turing machine that decides an infinite language $L\\subset \\{0,1\\}^*$ for which all $L'\\subseteq L$, if $|L'|=\\infty$, then $L'$ is not a regular language.</p>\n\n<p>I think this is not possible due to Rice's Theorem. It's not possible to tell for a Turing Machine if a language is regular or not.</p>\n\n<p>Moreover, on any given input, the machine can loop so it cannot decide an infinite language $L$.</p>\n\n<p>Is this the right answer? It seems too easy to be the answer... Any input would be appreciable. Thanks in advance.</p>\n", 'ViewCount': '311', 'Title': 'Can a Turing Machine decide only non-regular languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T11:27:53.427', 'LastEditDate': '2013-11-08T11:27:53.427', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '16786', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<formal-languages><regular-languages><turing-machines><automata>', 'CreationDate': '2013-11-05T17:52:50.853', 'Id': '16745'},47189:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '173', 'Title': 'Convert a non-deterministic Turing machine into a deterministic Turing machine', 'LastEditDate': '2013-11-08T13:11:03.730', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10685', 'FavoriteCount': '1', 'Body': '<p>How can we systematically convert a non-deterministic Turing machine into a deterministic Turing machine that recognizes the same language?</p>\n', 'Tags': '<turing-machines><simulation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T13:11:03.730', 'CommentCount': '8', 'AcceptedAnswerId': '16797', 'CreationDate': '2013-11-07T17:20:27.847', 'Id': '16796'},47190:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm struggling to understand this question:</p>\n\n<blockquote>\n  <p>Give an encoding of the Turing machine with lowest index that accepts anything but the empty set.</p>\n</blockquote>\n\n<p>I know what an encoding of a Turing Machine is. But my professor didn't explain what the index of a Turing machine is and how I know that it is lower or higher? Can someone explain what lowest index is and how would I go about this problem?</p>\n", 'ViewCount': '55', 'Title': 'How to I get a TM with lowest index?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T13:41:37.467', 'LastEditDate': '2013-11-10T10:19:33.097', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '17863', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2013-11-10T02:03:49.400', 'Id': '17862'},47191:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been thinking about this one for a while:</p>\n\n<blockquote>\n  <p>Consider the language of TMs which do not recognize themselves: $L_{s}=\\{ \\langle M\\rangle ~|~ M \\text{ does not accept } \\langle M\\rangle \\}$. If $N$ is a TM where $L(N) \\subseteq L_s$, then is $\\langle N\\rangle \\in L_s$?</p>\n</blockquote>\n\n<p>Intuitively, I'm pretty sure it is true. I pictured $N$ as a compiler, and imagined some machine $P$ that $N$ compiled. It seemed that if $P$ was not able to bootstrap, then $N$ wouldn't be able to either. But I'm having trouble thinking about this problem more formally. </p>\n\n<p>Am I on the right track? A hint would be really helpful.</p>\n", 'ViewCount': '37', 'Title': 'If the language of a TM is TMs which cannot self recognize, can the original TM?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T10:23:15.397', 'LastEditDate': '2013-11-10T10:23:15.397', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17868', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10410', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-11-10T06:20:57.600', 'Id': '17867'},47192:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '187', 'Title': 'On the language of Turing machines not accepting their own encoding', 'LastEditDate': '2013-11-10T23:56:29.573', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11300', 'FavoriteCount': '1', 'Body': '<p>Let $\\text{NOT-SELF} = \\{\\langle M \\rangle : M \\text{ is a TM that does not accept } \\langle M \\rangle \\}$. How do you prove the following claim?</p>\n\n<blockquote>\n  <p>If $Q$ is a TM so that $L(Q) \\subseteq \\text{NOT-SELF}$, prove that $\\langle Q \\rangle \\in \\text{NOT-SELF}$.</p>\n</blockquote>\n', 'Tags': '<turing-machines>', 'LastEditorUserId': '683', 'LastActivityDate': '2013-11-10T23:56:29.573', 'CommentCount': '0', 'AcceptedAnswerId': '17886', 'CreationDate': '2013-11-10T21:18:50.380', 'Id': '17882'},47193:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove that the following language is undecidable:$$\n   \\{ \\langle M, w \\rangle ~|~ M \\text{ is a TM where its head moves left a finite number of times on } w \\}\n$$</p>\n\n<p>But I'm having a bit of trouble. I know I have to do some type of reduction, but I'm not really sure what. Can a Turing Machine be simulated by one which only moves left? if so, then I think I could show $A_{TM}$ reduces to it. Any hints would be appreciated.</p>\n", 'ViewCount': '122', 'Title': 'Proving that the language of TMs which only moves left is undecideable', 'LastActivityDate': '2013-11-10T23:50:37.143', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17896', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11304', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-11-10T23:13:53.543', 'FavoriteCount': '1', 'Id': '17892'},47194:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '227', 'Title': 'Complements of Linear Bounded Automata?', 'LastEditDate': '2013-11-11T02:08:06.417', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11306', 'FavoriteCount': '1', 'Body': "<p>Would switching the accept and reject states of an LBA A create a new LBA we'll say A' in which the language of A' is the complement of the language of A? I believe the answer is yes just by working out an example...but I'm not sure on a solid proof...nor am I sure if the fact that I am working with an LBA vs a regular turing machine makes a difference in this case. </p>\n", 'Tags': '<formal-languages><turing-machines><linear-bounded-automata>', 'LastEditorUserId': '11306', 'LastActivityDate': '2013-11-20T21:18:16.770', 'CommentCount': '3', 'AcceptedAnswerId': '18208', 'CreationDate': '2013-11-11T00:39:57.630', 'Id': '17898'},47195:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I understand how a the language of turing machines which do not accept themselves is not recognizable but I'm not sure if the same proof could be used to describe a DFA... i.e a proof by contradiction in which a recognizer M recognizes a TM which does not accept itself on input ...creates a contradiction in which if M accepts then M does not accept itself. </p>\n", 'ViewCount': '113', 'Title': 'Is the language of DFAs which do not accept themselves recognizable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:46.427', 'LastEditDate': '2013-11-13T22:08:46.427', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11306', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-11-11T20:08:51.590', 'FavoriteCount': '1', 'Id': '17925'},47196:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In trying to understand how Turing Machine encoding works, there is a question that I have come across that goes something like this:</p>\n\n<p>Given that the diagonal language, $L_d = \\{ w_i \\mid w_i \\space is \\space not \\space accepted \\space by \\space M_i \\}$, what is the first string of the encoding of the complement of $L_d$ which is $\\bar{L_d}$?</p>\n\n<p>I am assuming also that this is operating with the alphabet of $\\Sigma = \\{0, 1\\}$. Is there any way that it is even possible? I am confused also since $L_d$ is an undecidable language how this is possible?</p>\n\n<p>Also by encoding I think that the question is referring to binary encoding with a tape alphabet $\\{0, 1, B\\}$ with Turing machine $M$ defined as:</p>\n\n<p>$M = &lt; Q, \\{0, 1\\}, \\{0, 1, B\\},\\delta,q_1,B,\\{q_2\\} &gt;$</p>\n\n<p>with moves defined by:</p>\n\n<p>$\\delta(q_i,X_j) = (q_k,X_n,D_m) \\rightarrow 0^i10^j10^k10^n10^m $</p>\n\n<p>where $X_1 = 0, X_2 = 1, X_3 = B$\nand Direction is given by: $D_1 = L, D_2 = R$,</p>\n\n<p>and the Binary encoding of $M$ as $&lt;M&gt;$: $111 \\space move_1 \\space 11 \\space move_2 \\space 11 \\space ... \\space 11 \\space move_{last} \\space 111$</p>\n\n<p><strong>Update:</strong> If my understanding is correct, the correct encoding should represent a Turing machine which accepts every string since originally we do not accept any string? How would one go about formulating an encoding for such a Turing machine? Does it have to be a unique encoding, or does it just imply that any Turing machine that accepts every string is valid?</p>\n', 'ViewCount': '372', 'Title': 'Turing Machine Encoding and Complement of the Diagonal Language', 'LastEditorUserId': '9912', 'LastActivityDate': '2014-04-12T02:09:59.257', 'LastEditDate': '2013-11-12T23:49:58.173', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-11-11T22:57:07.680', 'Id': '17931'},47197:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I know this has been a question but based on a past experience, i thought i would rewrite it so i can get input and ask questions faster.</p>\n\n<p>Suppose we have \n$$\\text{NOT-SELF}=\\{\\langle M\\rangle \\mid  M \\text{ is a Turing machine that does not accept }\\langle M\\rangle\\}$$\nthe set of all machines that don't accept their own coding.</p>\n\n<p>Let $Z$ be a TM such that $L(Z)$ is a subset of $\\text{NOT-SELF}$. Prove that $\\langle Z\\rangle$ is an element of $\\text{NOT-SELF}$.</p>\n\n<p>My answer so far is very broad and I'm trying to improve it.</p>\n\n<p>If $\\langle Z\\rangle$ is not an element of $\\text{NOT-SELF}$, than $\\langle Z\\rangle$ can\u2019t be an element in $L(Z)$. Since there\u2019s a condition that $L(Z)$ is a subset of $\\text{NOT-SELF}$,  this contradicts so $\\langle Z\\rangle$ must be an element of $\\text{NOT-SELF}$.</p>\n", 'ViewCount': '86', 'Title': 'Prove that <Z> is not a element of NOT-SELF', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-14T09:29:43.787', 'LastEditDate': '2014-01-15T08:30:51.607', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<computability><turing-machines><decision-problem>', 'CreationDate': '2013-11-12T22:19:09.830', 'Id': '17973'},47198:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been thinking about how to show this but I'm stuck.</p>\n\n<p>I'm required to prove this:</p>\n\n<blockquote>\n  <p>Show that the language $$\\mathrm{TOT}= \\{\\langle M \\rangle : M\\text{ is a Turing Machine that halts with all inputs} \\}$$ is not recursively enumerable nor its complement. ($\\langle M \\rangle$ is an encoded Turing Machine with only zeros and ones).</p>\n</blockquote>\n\n<p>I think we have to proceed by contradiction, assuming that $\\mathrm{TOT}$ is recursively enumerable, so there must be a Turing Machine that we will call $T$ such that it can process any possible encoding $\\langle M \\rangle$ of a TM $M$ and only accept those machines that halt with all inputs.</p>\n\n<p>So in order to confirm that $\\mathrm{TOT}$ is r.e., $T$ should be able to do this for every $M$ that halts with all inputs. My idea is to show that this is not possible because the set $\\mathrm{TOT}$ is not countable, so maybe I can show this using the diagonalization argument, but I'm not sure.</p>\n\n<p>So what is the correct way to prove this?</p>\n\n<p>Thanks</p>\n", 'ViewCount': '28', 'ClosedDate': '2013-11-13T22:14:17.077', 'Title': 'Show that the language of all total Turing machines is neither r.e. nor co-r.e', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:13:18.120', 'LastEditDate': '2013-11-13T22:13:18.120', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11349', 'Tags': '<formal-languages><computability><turing-machines>', 'CreationDate': '2013-11-13T02:20:56.380', 'Id': '17977'},47199:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that for every $k$-tape DTM that runs in time $O(t(n))$, there exists a 1-tape DTM that runs in $O(t^2(n))$, no matter how large the $k$ (the $k$-part is a formulation from Wikipedia). But what if $k=\\infty$?</p>\n\n<p>If I understand it right, if $k=\\infty$, then the alphabet of the $\\infty$-tape DTM is infinite and therefore the transition function will be infinite as well. That is why it is not NTM by definition, however it should be much more powerful than a DTM (based on the argument that we can encode a countable infinitely long input into one symbol of countable infinitely large alphabet).</p>\n\n<p>So, it is known if a NTM can be simulated by $\\infty$-tape DTM (with preserving polynomially-same accepting times)?</p>\n', 'ViewCount': '71', 'Title': 'Can be non-deterministic Turing machine simulated by $k$-tape deterministic TM where $k=\\infty$ with preserving polynomially-same accepting times?', 'LastActivityDate': '2013-11-14T15:19:57.320', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18016', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11380', 'Tags': '<turing-machines><time-complexity>', 'CreationDate': '2013-11-14T15:07:17.447', 'Id': '18015'},47200:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We know that deterministic TMs are countable (enumeration). Does the same hold for NTMs? Are TMs and NTMS equinumerous?</p>\n', 'ViewCount': '81', 'Title': 'Is the set of non-deterministic Turing machines countable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-19T08:15:24.767', 'LastEditDate': '2013-11-18T21:14:57.643', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18149', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11440', 'Tags': '<turing-machines><enumeration>', 'CreationDate': '2013-11-17T15:42:47.290', 'Id': '18099'},47201:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can I think this way:</p>\n\n<p>We can convert a NFA to a RE using GFA.</p>\n\n<p>We build a series of GFAs. At each step, one state (other than start or accept) is removed and replaced by transitions that have the same effect.</p>\n\n<p>So, if we can convert k REs which have different forms but accept same language, then there must exists a string that the NFA accepts along k paths.</p>\n\n<p>Does that sound right?</p>\n\n<p>How to prove it properly?</p>\n', 'ViewCount': '131', 'Title': 'Can it be decided whether there exists a string accepted by a given NFA at least k ways?', 'LastEditorUserId': '10617', 'LastActivityDate': '2013-11-18T21:45:16.193', 'LastEditDate': '2013-11-18T21:45:16.193', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10617', 'Tags': '<turing-machines><finite-automata><undecidability>', 'CreationDate': '2013-11-18T02:51:27.257', 'Id': '18109'},47202:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question is a follow up to the question: <a href="http://cs.stackexchange.com/questions/16321/proving-equivalence-of-1-dimensional-cellular-automaton-and-turing-machines">Proving Equivalence of 1-dimensional Cellular Automaton and Turing Machines</a>.</p>\n\n<p>To simulate a CA with a TM, I used a construction which placed a marker on the ends of the input, and modeled each "step" with the transition function. Assuming that $\\rho(\\text{\'\'blank\'\'}, \\text{\'\'blank\'\'}, \\text{\'\'blank\'\'}) = \\text{\'\'blank\'\'}$, what is the time complexity of simulating a CA? I\'m only concerned with the upper bound. </p>\n\n<p>I\'m really stuck, any hints would be really appreciated.</p>\n\n<p>Edit: As recommended, I am adding a better description of the algorithm:</p>\n\n<p>On input $w = w_1 w_2 \\dots w_n$, have the TM place unique begin and end characters on each side of the input. We model a single timestamp in the CA by multiple steps of the TM. The head sweeps through the taps, replacing its contents with the contents of the CA tape in the next timestamp. We write each character one place to teh right of where it would have been in the CA. Formally, this is: </p>\n\n<blockquote>\n  <p>there are states $q_{a,b}$ for all pairs of CA states, with transitions in the form:\n  $$ q_{a,b} \\to^{c \\to \\rho(a, b, c), R} q_{b,c}$$</p>\n</blockquote>\n\n<p>after completing a single sweep, return the head to the start of the tape and repeat. Continue unless an accept character is written, in which case, enter the TM accept state.</p>\n', 'ViewCount': '77', 'Title': 'Time Complexity of Simulating CA with TM', 'LastEditorUserId': '10448', 'LastActivityDate': '2013-11-20T04:00:24.680', 'LastEditDate': '2013-11-20T04:00:24.680', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10448', 'Tags': '<complexity-theory><turing-machines><cellular-automata>', 'CreationDate': '2013-11-19T19:37:42.877', 'FavoriteCount': '1', 'Id': '18168'},47203:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am wondering this statement above [the title] is true or not.</p>\n\n<p>Here is what I've already had : non-recursive means undecidable.</p>\n\n<p>I've read this Are all infinite languages undecidable?</p>\n\n<p>which says:</p>\n\n<p>If a Language is undecidable(non-recursive), there must be some strings make the TM fail to halt.SO IT MUST HAVE INFINITE OF THEM WHICH MAKE THE TM FAILS TO HALT.</p>\n\n<p>How could this prove my statement[title]? Can anyone explain it to me a bit more clearly?</p>\n\n<p>Thanks</p>\n\n<p>TM means Turing machine. And too be clear My question is : Does ALL non-recursive languages are Infinite?</p>\n", 'ViewCount': '120', 'Title': 'Prove that all non-recursive languages are infinite', 'LastActivityDate': '2013-11-20T18:37:22.500', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18205', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11506', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-11-20T18:22:01.607', 'Id': '18203'},47204:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>First I apologize if I confused therms DFA and FSM, to me it seems that is the same thing. The question is simple: Are the flowcharts (sequence, branching and jumping) equivalent to DFA resp. FSM? I am a bit confused about this. There are classes where using logical synthesis, Karunaugh maps, state encodings, flip flops etc. one is able to construct hardware consisting of logic gates and flip-flops which realizes the desired DFA. Basically all processes that runs on the computer (no matter if is written in C# or Assembler), are at the lowest level realized through logical gates, zeros and ones. So it seems that programs firstly needs to be converted (by compiler I suppose) to some form as I've described. This might imply that every problem that is solvable using C# is solvable using FSM. But this is in contradiction to Chomsky hierarchy and all this theory related stuff, which says that you cannot do the same magic with regular expressions (which are based on FSM) that you can do on Turing machine (which is equivalent of any programming language, if I am wrong correct me please). Moreover, if flowcharts (or even C#, Java ... source codes) were equivalent to FSM why we do not have all software formally verified so far? There is mathematical apparatus for FSM and related stuff, so why do not formally verify everything and ensure the correctness? What I am missing here?</p>\n", 'ViewCount': '59', 'Title': 'Flowcharts vs DFA resp FSM equivalency', 'LastActivityDate': '2013-11-20T23:19:14.123', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11513', 'Tags': '<formal-languages><turing-machines><finite-automata><computer-architecture>', 'CreationDate': '2013-11-20T23:19:14.123', 'FavoriteCount': '1', 'Id': '18210'},47205:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $U$ be a universal Turing machine that on input $&lt;M,w&gt;$ simulates a Turing machine $M$ on input $w$. I have a question about what would happen if $U$ "operated" on itself.</p>\n\n<p>That is, what happens when we consider the input $&lt;U, &lt;M,w&gt;&gt;$?</p>\n\n<p>Or what about the input $&lt;U, &lt;U, &lt;M,w&gt;&gt;&gt;$?</p>\n', 'ViewCount': '91', 'Title': 'Recursive Universal Turing Machines', 'LastActivityDate': '2013-11-24T20:12:28.790', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11597', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-11-24T18:55:14.703', 'Id': '18305'},47206:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How do I precisely define the function which is a mapping reduction of A to B for the following examples?</p>\n\n<p>What is the process of figuring this out?</p>\n\n<p>Given: A and B are languages over the alphabet {0,1}.</p>\n\n<p>Examples:</p>\n\n<ul>\n<li>A is the language described by 1*0*, B is the language described by 01*0*</li>\n<li>A={w | the length of w is even}, B={w | the length of w is odd}</li>\n<li>A=B={w | the length of w is even}</li>\n<li>A={0,1}*, B={00,1,101}</li>\n</ul>\n\n<p>I am studying this material and I am not sure of how to 'precisely' define these functions. Could somebody provide me with solutions and a methodology to finding the solution?</p>\n", 'ViewCount': '53', 'Title': 'Finding a function which is a mapping reduction of A to B', 'LastEditorUserId': '11622', 'LastActivityDate': '2013-11-29T00:25:26.853', 'LastEditDate': '2013-11-29T00:22:45.743', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18458', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11622', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-11-25T23:31:44.567', 'Id': '18339'},47207:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '188', 'Title': 'Is there a TM that halts on all inputs but that property is not provable?', 'LastEditDate': '2013-11-27T22:07:04.507', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '2', 'Body': '<blockquote>\n  <p>Does there exist a Turing machine that halts on all inputs but that property is not provable for some reason?</p>\n</blockquote>\n\n<p>I am wondering if this question has been studied. Note, "unprovable" could mean a "limited" proof system (which in the weak sense think the answer must be yes). I am of course interested in the strongest possible answer, i.e. one that is not provable to halt on all inputs in say <a href="http://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory">ZFC set theory</a> or whatever.</p>\n\n<p>It occurred to me this could be true of the <a href="http://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a> but I am hazy on the details. It doesn\'t seem like Wikipedia describes this aspect clearly.</p>\n', 'Tags': '<computability><reference-request><turing-machines><halting-problem>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-03T19:03:16.420', 'CommentCount': '3', 'AcceptedAnswerId': '18425', 'CreationDate': '2013-11-27T21:44:59.707', 'Id': '18424'},47208:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'Turing machine with possible transitions to the final state', 'LastEditDate': '2013-11-29T02:15:18.813', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': '<p><img src="http://i.stack.imgur.com/aRAVI.png" alt="enter image description here"></p>\n\n<p>Let\'s say we want to draw the transition graph of a Turing Machine that accepts that language L and then write the sequence of moves done by the TM when the input sequence is $w = abbcbba$ so I had some thoughts on how this could be built.</p>\n\n<p>$q0 - q1: a,a,R$</p>\n\n<p>$q1-q2: b,b,R$</p>\n\n<p>$q2 (loop): b,b,R$</p>\n\n<p>$q2-q3: c,c,R$</p>\n\n<p>$q3-q4: b,b,R$</p>\n\n<p>But then I\'m getting stuck here, I could see $b,b,R$ to the final state and then add a separate node to account for the case $m=3$, but I\'m teaching this to myself so maybe someone can step in here and get me back on track.</p>\n\n<p>EDIT:</p>\n\n<p>This might work:</p>\n\n<p><img src="http://i.stack.imgur.com/qqxDM.jpg" alt="enter image description here"></p>\n', 'ClosedDate': '2014-01-23T18:49:36.310', 'Tags': '<formal-languages><turing-machines><automata>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-11-29T02:15:18.813', 'CommentCount': '1', 'AcceptedAnswerId': '18456', 'CreationDate': '2013-11-28T19:46:19.570', 'Id': '18452'},47209:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is the language $L_{universal} = \\{ \\left \\langle M \\right \\rangle | M \\textrm{is a universal turing machine} \\}$ decidable? </p>\n\n<p>I'm guessing it is decidable according to the definition of a UTM, that a UTM must be able to calculate every recursive function. Since the set of recursive languages and the set of all input words are both enumerable, we are theoretically able to determine if the given $\\left \\langle M \\right \\rangle$ is a UTM. Is my logic somewhat correct?</p>\n", 'ViewCount': '81', 'Title': 'Decidability of the language that accepts a universal turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-02T12:19:54.130', 'LastEditDate': '2013-12-02T12:19:54.130', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '18508', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11738', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-12-01T18:21:44.070', 'Id': '18506'},47210:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m currently learning about Rice\'s Theorem, and I\'m having a bit of trouble understanding when I can and cannot use it. It\'s my understanding that Rice\'s Theorem can only be applied to something if it is a property of the language (i.e. $L(M)$) and not if it is a property of the machine (i.e $M$). Is this correct, or am I missing some detail?</p>\n\n<p>If the above is the case, then am I correct in thinking that I can apply Rice\'s Theorem to, say "$L(M)$ is infinite" or "$L(M)$ is not context-free", but not something like "$M$ is the only machine accepting $L(M)$"?</p>\n', 'ViewCount': '44', 'ClosedDate': '2013-12-02T16:55:33.870', 'Title': "Using Rice's Theorem Correctly", 'LastActivityDate': '2013-12-02T05:09:35.690', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11597', 'Tags': '<formal-languages><turing-machines><undecidability>', 'CreationDate': '2013-12-02T05:09:35.690', 'Id': '18526'},47211:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to describing a Turing machine that computes $\\lceil\\log_{2}(n)\\rceil$ I know that:</p>\n\n<p>n = 1, 2, 3, 4, 5, 6, 7, 8, ... <br>\nf(n) = 0, 1, 2, 2, 3, 3, 3, 3, ...</p>\n\n<p>So I'm thinking of putting $n$ on the tape. Then keeping a count of how many times I multiply 2*2 until it is greater than than $n$. For example for n=5, 2*2*2=8, number of two's is 3 so then $f(n)$ is 3. I don't know how to translate this to the ticker tape of the Turing machine.</p>\n\n<p>But would something like this work? Put $n$ 1's on the tape followed by a 0. Compute 1^(2^1), then check if 1's on the left of the 0 on the tape is less than or equal to the 1's on the right of the 0. If its not then repeat it for 1^(2^(1)). It keeps doing this until the left side has less than or equal number of 1's.</p>\n", 'ViewCount': '98', 'Title': 'Describing a Turing machine that computes $\\lceil\\log_{2}(n)\\rceil$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-02T19:09:53.377', 'LastEditDate': '2013-12-02T19:09:53.377', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18541', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<complexity-theory><turing-machines><automata>', 'CreationDate': '2013-12-02T17:04:15.713', 'Id': '18537'},47212:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $X = \\{\\langle M \\rangle\\ |\\ M\\text{ is a finite state machine and }L(M) = \\emptyset\\}$ where $\\langle M \\rangle$ is an encoding of the\nmachine $M$.  Is $X$ Turing decidable?  Why or why not?</p>\n', 'ViewCount': '148', 'Title': 'Decide whether a DFA accepts the empty language', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-20T07:31:54.950', 'LastEditDate': '2013-12-19T18:20:56.877', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11809', 'Tags': '<turing-machines><automata><pushdown-automata>', 'CreationDate': '2013-12-04T17:33:25.773', 'Id': '18616'},47213:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am interested in simulating any turing machine with a turing machine that is allowed only to move right. I guess that it should be pretty standard material and likely it is trivial (or known to be false). Does anyone have a pointer to a reference?</p>\n', 'ViewCount': '103', 'Title': 'Right moving turing machine', 'LastActivityDate': '2013-12-05T10:46:40.527', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18640', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10931', 'Tags': '<turing-machines><simulation><turing-completeness>', 'CreationDate': '2013-12-05T10:21:15.477', 'Id': '18639'},47214:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am currently working on the following task:</p>\n\n<p>A language L = {&lt; M> | M(x) = x^2} is given. Now I need to show, that this language is not decidable.\n<br> By the way, &lt; M> is the G\xf6del number</p>\n\n<p>But right now, I don't know how to deal with that task. Honestly, this is the first time that I am working with this kind of task.</p>\n\n<p>I would appreciate if you could give me some hints, because I don't know how to proceed with the task.</p>\n", 'ViewCount': '29', 'ClosedDate': '2013-12-08T23:35:00.803', 'Title': 'Recursive set - How to show a language is undecidable', 'LastActivityDate': '2013-12-08T23:29:39.940', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11941', 'Tags': '<turing-machines><undecidability><computation-models><proof-assistants>', 'CreationDate': '2013-12-08T23:29:39.940', 'Id': '18764'},47215:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Today I\'ve heard about fascinating metagame paradox. I tried to come up with an explanation via Turing Machines formalization (below). Do you know what is the solution to the paradox? (the post content: definition - proposed solution - conclusion)</p>\n\n<p>Something is a game iff:</p>\n\n<pre><code>G1. Two players\nG2. Players alternate\nG3. The game finally ends.\n</code></pre>\n\n<p>The metagame is:</p>\n\n<pre><code>M1. First player picks a game\nM2. Second player starts the game\nM3. The winner is the winner of the game at step 2.\n</code></pre>\n\n<p>Example of a metagame:</p>\n\n<pre><code>1) I pick tic-tac-toe\n2) OK, I put X here ..\n.. so they play ..\n3) .. and let player 2 wins in the tic-tac-toe =&gt; player 2 wins the metagame.\n</code></pre>\n\n<p><strong>Paradox: Is metagame a game?</strong></p>\n\n<p>If metagame is a game, then at point (M1) both players can always pick a metagame, so the metagame will never end => (G3) is violated => metagame is not a game => contradiction.</p>\n\n<p>(also contradiction for case "metagame is not a game" -- metagame will satisfy the definition of a game)</p>\n\n<p>(see also <a href="http://www.math.cornell.edu/~mec/2006-2007/Games/hypergame.html" rel="nofollow">http://www.math.cornell.edu/~mec/2006-2007/Games/hypergame.html</a>)</p>\n\n<p><strong>What is the solution to the paradox?</strong></p>\n\n<p><em>UPDATE:</em> You may want to skip this explanation and go directly to D.W. answer.</p>\n\n<p>I came up with the following explanation:</p>\n\n<p>Lets formalize the problem using Turing Machines notations.\nLet a game be a finite binary string that describes "somehow" game rules. Let a game simulator be a non-deterministic TM that reads a description from the input (without any sanity checks, so the TM doesn\'t know if the game finally ends), and then makes non-deterministic moves for the first and second player. Here we assume (A1) that the game-simulator can decide valid next moves.</p>\n\n<p>Now have a look at the description of a meta-game:</p>\n\n<pre><code>M1. First player picks a game\n</code></pre>\n\n<p>This sentence means that we can "pick a game", i.e. in the definition we assume (A2) that whether an arbitrarily binary string is a game (satisfies G1,G2,G3) is decidable. (see also note (n1) )</p>\n\n<p>M2 and M3 look decidable.</p>\n\n<p>So, <strong>my suggestion is that metagame is not "defined properly"</strong>, since its definition assumes the existence of a decider "if a given binary string is a game". And then we derive a contradiction, so this assumption is wrong.</p>\n\n<p><strong>Does it make sense? Is this related with other explanations of the paradox?</strong>\n(intuitive answers would be great!)</p>\n\n<p>Notes:</p>\n\n<ol>\n<li>Assuming "whether an arbitrarily binary string is a game" may be too much. But we need some computable procedure "pick a game" and one that came into mind is "generate random string, check if it is a game".</li>\n<li>I don\'t know what is a formal word for "not defined properly"</li>\n<li>Assumption A1 may also be undecidable, but I believe it should not change the argument..</li>\n</ol>\n', 'ViewCount': '115', 'Title': 'Metagame Paradox: what is wrong with this explanation?', 'LastEditorUserId': '2260', 'LastActivityDate': '2013-12-11T08:56:46.867', 'LastEditDate': '2013-12-11T08:23:57.650', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18821', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2260', 'Tags': '<computability><turing-machines><game-theory>', 'CreationDate': '2013-12-09T20:00:39.473', 'Id': '18786'},47216:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I been reading a bit about <a href="https://en.wikipedia.org/wiki/Turing_machine" rel="nofollow">Turing\'s machine</a> and I do not understand what are the commands limitation?</p>\n\n<ol>\n<li>What consider to be legal and what consider to be illegal command?</li>\n<li>What are states?</li>\n</ol>\n', 'ViewCount': '69', 'ClosedDate': '2013-12-13T08:29:15.723', 'Title': 'Turing machine commands', 'LastEditorUserId': '268', 'LastActivityDate': '2013-12-10T16:11:13.817', 'LastEditDate': '2013-12-10T13:39:37.597', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<turing-machines>', 'CreationDate': '2013-12-10T12:51:18.567', 'Id': '18829'},47217:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Show that the set $K^{c}$ = $\\lbrace M \\mid M(M) \\text{ diverges} \\rbrace$ is not recursively enumerable.</p>\n</blockquote>\n\n<p>This question is essentially asking to show that the set of turing machines which diverge when run on their own code is not RE.</p>\n\n<p>My idea is to attempt to reduce this problem to something which is the complement of the halting problem.  Thus, the idea is to take a machine M and a word w, and construct a new machine which diverges on it's own code when M diverges on w, but haven't had much luck with that.</p>\n\n<p>This is from a practise exam, but please treat it as a homework question so I can attempt to work through a solution.</p>\n", 'ViewCount': '76', 'Title': 'Turing machine which diverges on its own code', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-10T18:32:40.683', 'LastEditDate': '2014-01-10T18:32:40.683', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11999', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-12-10T21:36:02.977', 'Id': '18840'},47218:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '30', 'Title': 'How can a Turing machine run another machine for an infinite amount of strings?', 'LastEditDate': '2013-12-11T19:01:19.183', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12032', 'FavoriteCount': '0', 'Body': "<p>The proof in my textbook, that $E_{TM}$ can be decided by oracle machine $O^{A_{TM}}$, uses a Turing machine $P$ such that for an input $w$:</p>\n\n<ul>\n<li>$P$ runs the Turing machine $M$ on all strings of $\\Sigma^*$</li>\n<li>If $M$ accepts the string, $P$ accepts</li>\n</ul>\n\n<p>$O^{A_{TM}}$ then asks the oracle if $&lt;P,w&gt; \\in A_{TM}$</p>\n\n<p>I can't seem to understand why $P$ can run $M$ for all strings of $\\Sigma^*$ because this is an infinite amount of strings. I do, however, understand that $P$ actually never has to run and is purely constructed to ask the oracle if it accepts.</p>\n", 'Tags': '<turing-machines><strings>', 'LastEditorUserId': '12032', 'LastActivityDate': '2013-12-11T19:06:05.330', 'CommentCount': '0', 'AcceptedAnswerId': '18888', 'CreationDate': '2013-12-11T18:48:35.790', 'Id': '18887'},47219:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm trying to understand reduction, this is from my textbook and is not a homework problem or even any exercise, just trying to understand an example they present.</p>\n\n<p>This is the reduction they give: </p>\n\n<p>PROOF We let R be a TM that decides REGULARTM and construct TM S to\ndecide ATM . Then S works in the following manner.</p>\n\n<p>S = \u201cOn input $M$, $w$ , where M is a TM and w is a string:</p>\n\n<ol>\n<li><p>Construct the following TM $M_{2}$ .</p>\n\n<p>$M_{2}$ = \u201cOn input x:</p>\n\n<ol>\n<li><p>If x has the form $0^{n} 1^{n}$ , accept .</p></li>\n<li><p>If x does not have this form, run M on input w and\naccept if M accepts w.\u201d</p></li>\n</ol></li>\n<li><p>Run R on input $M_{2}$ .</p></li>\n<li><p>If R accepts, accept ; if R rejects, reject .\u201d</p></li>\n</ol>\n\n<p>So, we start with a machine that decides whether a language of a TM is regular. And we want to use that to decide if a TM halts on a given input.</p>\n\n<p>My question: What if $w$ does have the form $0^{n} 1^{n}$? Well, $M_{2}$ accepts that string just cause of the form. But we never actually run $M$ on $w$. So how can we say that it will accept or reject it? We have no idea what it does because we never ran it on $w$.</p>\n", 'ViewCount': '61', 'Title': 'Reducing from a Turing machine that recognizes is regular to the halting problem', 'LastActivityDate': '2013-12-11T21:54:13.870', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '18898', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12039', 'Tags': '<turing-machines><reductions><undecidability>', 'CreationDate': '2013-12-11T20:13:17.863', 'Id': '18894'},47220:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '184', 'Title': 'Decidability of Turing Machines with input of fixed length', 'LastEditDate': '2013-12-16T13:54:56.020', 'AnswerCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12094', 'Body': "<p>I'm learning about undecidability, and found this question:</p>\n\n<pre><code>Is this language decidable, make a proof:\n    L = { M : machine M halts for every input of length not exceeding 100 }\n</code></pre>\n\n<p>Update: This is translated from an exam paper some years ago, and I'm quite sure it means that machine M should halt for every input with length from 0 to 100, and that it is no constraints on the tape size.</p>\n\n<p>Update2: The solution given below, and hence the origin of this post, is for an variant of this question with fixed number of steps and input. Sorry for the confusion.</p>\n\n<p>I came to the conclusion that this is an undecidable language. </p>\n\n<p>My logic is as follows: Lets say for the sake of contradiction that it is possible to construct a machine $M_R$, that takes as input an arbitrary input $(M,x)$, and reduces this to $M'$. $M'$ has the property so that $(M,x) \\in M_{HALT}$ iff $M' \\in L$, this means that $M$ halts on all $x$ of input with maximum length of 100. </p>\n\n<p>Then run $M$ on $x$, if it halts then accept. </p>\n\n<p>And shows that $M_R$ decides the halting problem, and in hence a contradiction and proves that his is not decidable.</p>\n\n<p>But in the solution it is written that this question is decidable:</p>\n\n<blockquote>\n  <p>You can simulate $M$ on all inputs of length 100 or less (you can\n  generate such input in a loop and use the universal Turing machine to\n  simulate M on x), it is only $|\\Sigma|^{100}$ possible inputs of\n  length 100, that is finite.</p>\n</blockquote>\n", 'ClosedDate': '2013-12-16T20:32:42.270', 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '12094', 'LastActivityDate': '2013-12-16T20:33:05.603', 'CommentCount': '9', 'AcceptedAnswerId': '18971', 'CreationDate': '2013-12-13T18:19:55.973', 'Id': '18959'},47221:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the set $S$ = $\\lbrace M \\mid M \\text{ is a Turing machine and }L(M)=\\lbrace \\langle M\\rangle\\rbrace\\rbrace$ empty?</p>\n\n<p>In other words is there a Turing machine $M$ that only accepts its own encoding? What about a Turing machine that rejects only its own encoding? </p>\n', 'ViewCount': '192', 'Title': 'Can I construct a Turing machine that accepts only its own encoding?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-14T22:00:05.450', 'LastEditDate': '2013-12-14T19:12:30.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18990', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12115', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-12-14T18:36:38.220', 'Id': '18989'},47222:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>You probably know this one (or at least a version of it).<br>\nLet $P$ be a program code, and $w$ be an input string.<br>\nDefine $A_{TM}=\\left\\{(P,w)| P(w)=1\\right\\}$.<br>\nMeaning: $A_{TM}$ is the set of all ordered pairs $(P,w)$ s.t. $P$ accepts $w$.<br>\n$A_{TM}$ is undecidable.</p>\n\n<p>I just read the proof for it, that made me wonder about something.<br>\nThe brief of the proof (by contradiction) looks something like this:<br>\nSuppose there exist $D_{A_{TM}}$ - a computer program that answers 'yes' if $(P,w)\\in A_{TM}$, and 'no' if $(P,w)\\notin A_{TM}$.<br>\nLet us consider the following program:</p>\n\n<p>$Q(w):$<br>\n1. run $D_{A_{TM}}$ on $(w,w)$<br>\n2. if $D_{A_{TM}}$ returned 'yes', then return 'no'.\nif $D_{A_{TM}}$ returned 'no', return 'yes'.</p>\n\n<p>Now running $Q(w);$ with the input $Q$, contradicts the existence of such $D_{A_{TM}}$</p>\n\n<p>This is a brief, since I assume most of you already know this problem (and its proof).  </p>\n\n<p>Now what makes me wonder is this: when I looked at $A_{TM}$, and needed to determine if it's decidable or not, the first thing that came to my mind when I tried to imagine a machine that accepts $A_{TM}$, is how can machine like that handle inputs $(P,w)$ s.t. $P$ doesn't halt on $w$?  How can it 'predicts', beforehand, that $P(w)$ goes to an infinite loop, without actually running $P$ on $w$?<br>\nThat intuition, as it turns out, wasn't wrong.<br>\nThe thing is: How come the proof, as clever as it is, has nothing to do with that fact?<br>\nYou'd expect it to lean - and even in the slightest way - on that leverage, but instead, the proof looks like something that was taken from the realm of paradoxes.</p>\n\n<p>Basically, what I'm asking is: why does this proof work?</p>\n", 'ViewCount': '41', 'Title': 'Question about the undecidability of $A_{TM}$', 'LastActivityDate': '2013-12-19T15:25:33.670', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-12-19T14:24:23.117', 'Id': '19120'},47223:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I tried, but I could not design a turing machine for the following problem:</p>\n\n<p>Turing machine that takes as input a tape containing a series of n 1s,\nwhere n >= 0, terminated by an = sign. The Turing machine head is initially positioned on\nthe leftmost 1. The end state should be a tape containing the input, followed by the reverse of the sequence of 0s and 1s that represents n in binary.</p>\n', 'ViewCount': '32', 'Title': 'Can anyone provide me answer/guide on how to design a turing machine for this case?', 'LastEditorUserId': '268', 'LastActivityDate': '2013-12-19T17:35:31.380', 'LastEditDate': '2013-12-19T17:35:31.380', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8889', 'Tags': '<turing-machines>', 'CreationDate': '2013-12-19T16:02:45.593', 'FavoriteCount': '0', 'Id': '19124'},47224:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to describe a TM that decides the language $A=\\{0^{5^n} \\mid n\\ge0\\}$.<br>\n<br>I know how to do this for $0^{2^n}$, marking off every other 0 in each pass. In my case would it work marking off every fifth 0 in each pass? It would reject if there are an even number of 0s. Every pass reduces the number of 0's by a fifth until there are no more 0s.</p>\n", 'ViewCount': '135', 'Title': 'TM for $0^{5^n}$. Describing a turing machine that decides the language consisting of all strings of zeroes whose length is a power of 5', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-03-23T18:51:24.853', 'LastEditDate': '2013-12-20T07:20:36.557', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2013-12-20T03:39:23.743', 'Id': '19139'},47225:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The proofs that the halting problem is undecidable seem to make very few assumptions about the kind of program/machine under consideration: just that the programs take one input and either loop or produce an output. Not just Turing machines have these characteristics: for example, a linear-bounded automaton can also loop.</p>\n\n<p>So, as well as a proof that you can't use a Turing machine to decide whether a Turing machine will halt, is it not also a proof that you can't use a pushdown automaton to decide whether a pushdown automaton will halt, and so on, for any automaton/language that has the ability to loop?</p>\n", 'ViewCount': '91', 'Title': 'Is the halting problem specific to Turing machines?', 'LastActivityDate': '2013-12-24T11:05:36.670', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '19242', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12332', 'Tags': '<turing-machines><halting-problem>', 'CreationDate': '2013-12-24T05:00:55.947', 'Id': '19231'},47226:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What would the repercussions on computer science theory as we know it today be if the proof for the incomputability of the halting problem was shown to be wrong?</p>\n\n<p>What would change in terms of the direction of research?</p>\n\n<p>Which doors would open, which would close?</p>\n\n<p>Put another way: why is the halting problem significant to computing science theory as we know it today?</p>\n\n<p>EDIT: I\'d like to point out that in this what-if universe, Godel\'s incompleteness theory still holds. The supposed problem with the incomputability of the halting problem proof in this alternate-universe: <a href="http://www.cs.toronto.edu/~hehner/RHP.pdf" rel="nofollow">http://www.cs.toronto.edu/~hehner/RHP.pdf</a></p>\n', 'ViewCount': '82', 'LastEditorDisplayName': 'user12330', 'ClosedDate': '2013-12-26T01:18:03.290', 'Title': 'What if the proof for the halting problem was wrong?', 'LastActivityDate': '2013-12-25T00:22:15.477', 'LastEditDate': '2013-12-25T00:22:15.477', 'AnswerCount': '0', 'CommentCount': '13', 'Score': '1', 'OwnerDisplayName': 'user12330', 'PostTypeId': '1', 'Tags': '<turing-machines><halting-problem>', 'CreationDate': '2013-12-24T23:45:29.370', 'Id': '19264'},47227:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>An exercise that was in a past session is the following:</p>\n\n<blockquote>\n  <p>Prove that there exists an undecidable subset of $\\{1\\}^*$</p>\n</blockquote>\n\n<p>This exercise looks very strange to me, because I think that all subsets are decidable.</p>\n\n<p>Is there a topic that I should read to find a possible answer?</p>\n', 'ViewCount': '545', 'Title': 'Undecidable unary languages (also known as Tally languages)', 'LastEditorUserId': '851', 'LastActivityDate': '2013-12-28T13:47:57.850', 'LastEditDate': '2013-12-28T13:47:57.850', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '19331', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<reference-request><turing-machines><undecidability>', 'CreationDate': '2013-12-27T18:20:42.287', 'Id': '19329'},47228:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As in, I have to design a determenistic (one-taped) turing machine that accepts that language (All strings made up of 0 and 1, where the j-th character from the end is a 0, and $j$ is a constant that we know what it is before running the machine) in less steps than the trivial steps. </p>\n\n<p>In the trivial solution, I would first check if the starting point is a blank, if so the machine denies. If not, go to the last bit (first blank) then move $j$ steps to the left and check if it is $0$.\nAll of that takes $1 + n + j$ steps, but my professor says there is a better runtime that I should come up with.</p>\n\n<p>Any hints would help!</p>\n', 'ViewCount': '54', 'Title': "Enhancing this turing machine's runtime", 'LastEditorUserId': '11424', 'LastActivityDate': '2013-12-29T19:07:41.260', 'LastEditDate': '2013-12-29T19:07:41.260', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19356', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<turing-machines>', 'CreationDate': '2013-12-29T07:18:37.050', 'Id': '19355'},47229:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Every nontrivial property of the recursively enumerable languages is undecidable.</p>\n\n<p>What exactly is nontrivial property?</p>\n', 'ViewCount': '260', 'ClosedDate': '2014-01-07T07:58:15.090', 'Title': 'Rice Theorem - What is non-trivial property?', 'LastActivityDate': '2014-01-06T18:03:53.550', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19538', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12629', 'Tags': '<turing-machines><formal-grammars>', 'CreationDate': '2014-01-06T14:44:41.333', 'Id': '19536'},47230:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <h3>Sipser theorem 4.4*</h3>\n  \n  <p>$E_{DFA} = \\{ \\langle A \\rangle \\mid \\text{A is a DFA and } L(A)=\\emptyset\\}$ is decidable.</p>\n</blockquote>\n\n<p>I could not quite understand the solution, I'll quote it:</p>\n\n<blockquote>\n  <p>On input $\\langle A \\rangle$ where $A$ is a DFA:</p>\n  \n  <ol>\n  <li><p>Mark the start state of A</p></li>\n  <li><p>Repeat until no new states get marked:</p></li>\n  <li><p>Mark any state that has a transition coming into it from any state that is already marked.</p></li>\n  <li><p>If no accept state is marked, accept; otherwise, reject.</p></li>\n  </ol>\n</blockquote>\n\n<p>My question is, what does it mean to even 'mark' something in the encoding? how do we do this? The encoding is merely a word from $\\{A,c\\}$, how would you 'mark' states?</p>\n", 'ViewCount': '37', 'ClosedDate': '2014-01-23T18:46:52.047', 'Title': 'How to mark things in the input?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-08T08:50:21.273', 'LastEditDate': '2014-01-08T08:47:21.370', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-01-08T07:09:06.683', 'Id': '19574'},47231:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given is the definition of a general problem: $\\{ \\langle M,  S\\rangle \\mid M \\text{ is a } TM, L_M \\in S\\}$. In words: Given a TM M, does M decide a language that is an element of the given set of languages S?</p>\n\n<p>I'm stuck with the following instance of that problem: $L = \\{ \\langle M \\rangle \\mid M \\text{ is a } TM, L_M \\in \\mathrm{REG}\\}$. I have found proof that it is undecidable, however I'm stuck at finding if it's recognizable (synonyms: Turing-acceptable, semidecidable, ...) or not.</p>\n\n<p>The problem in words means: Given a TM M, does the TM decide a language that is an element of REG (the set of regular languages)?</p>\n\n<p>To prove a language is not semi-decidable, I would try to prove that it's complement is semi-decidable and that the language is not decidable (which I did by reduction from the Halting-problem).</p>\n\n<p>To prove it is semi-decidable, I would prove it by reduction to the $A_{TM}$, which is semi-decidable.</p>\n\n<p>I have tried both for this problem, but I get stuck / lose my way of thinking at every try ... Some directions would be greatly appreciated!</p>\n", 'ViewCount': '134', 'Title': 'Is regularity of the language accepted by a given Turing machine a semi-decidable property?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:22.317', 'LastEditDate': '2014-01-18T20:20:22.317', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<formal-languages><computability><turing-machines><semi-decidability>', 'CreationDate': '2014-01-16T18:10:49.223', 'Id': '19769'},47232:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '70', 'Title': 'Understanding a proof for the existance of a non-computable function', 'LastEditDate': '2014-01-18T10:06:25.117', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12924', 'FavoriteCount': '1', 'Body': "<p>For school, we have a proof that some functions are not Turing computable.\nThe example is:\n$$ G(k) = \\begin{cases} f_k(k) + 1 &amp; \\text{ if $f_k(k)$ is defined}, \\\\ 1 &amp; \\text{ otherwise}.\\end{cases} $$</p>\n\n<p>Claim: $G$ is non computable.</p>\n\n<p>Proof: In view of obtaining a contradiction, let's say $G$ is computable, say by the $k$th Turing machine.\nGive the encoding of this $k$th Turing machine as an argument for $G$.\nThis leads to a contradiction: if $f_k(k)$ is defined, then $f_k(k)$ is not equal to $g(k) = f_k(k) + 1$. Else $f_k(k)$ is undefined and not equal to $g(k) = 1$.</p>\n\n<p>I don't understand the contradiction, help please...</p>\n", 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-18T10:06:25.117', 'CommentCount': '4', 'AcceptedAnswerId': '19793', 'CreationDate': '2014-01-17T18:17:02.093', 'Id': '19788'},47233:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read a proof on the closure of decidable languages under kleene star. It begins by saying that the turing machine we want to find would non-determistically split the input string and then use the original decider of the language to approve the partition of each branch.</p>\n\n<p>My question is, I can\'t understand how we can do this non-deterministic split on a word whose length we do not yet know. if the word is very big then there exist more partitions, thus more branches are needed.</p>\n\n<p>So, i don\'t understand how this "non-deterministic split" can be materialized. </p>\n\n<p>Also, if someone has another proof of this closure via turing machines it will be more than welcome!</p>\n', 'ViewCount': '194', 'Title': 'Decidable languages kleene star closure - question on a proof', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T13:59:37.270', 'LastEditDate': '2014-01-18T19:29:21.573', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19813', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12948', 'Tags': '<computability><turing-machines><closure-properties><nondeterminism>', 'CreationDate': '2014-01-18T18:43:45.827', 'Id': '19811'},47234:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the problem $EQ_{TM} = \\{ \\langle M_1,  M_2\\rangle \\mid M_1 \\text{ and } M_2 \\text{ are } TM, L_{M_1} = L_{M_2}\\}$, is it possible to prove that this is undecidable by using (a variant of) Rice theorem?</p>\n\n<p>I have proven this problem by reduction to $E_{TM}$, but was wondering if it was easier to do with Rice.</p>\n', 'ViewCount': '65', 'Title': 'Is it possible to prove EQTM is undecidable by the Rice theorem?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-21T22:47:38.397', 'LastEditDate': '2014-01-21T22:47:38.397', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19877', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2014-01-21T19:17:43.390', 'Id': '19876'},47235:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>When defining a Turing Machine formally, you enumerate its states. But I don't understand what states a TM can be in. Reading, Writing, and moving the head are the only ones that come to mind.</p>\n\n<p>Specifically, the turing I am trying to describe behaves like this:</p>\n\n<pre><code>    WHILE the symbol under the FH head is not $ DO\n        IF this symbol is not marked 0 THEN write it on the tape\n        ELSE write the symbol 1 on the tape\n            Read the next symbol (which is a 0) and write a marked 0 on the tape\n    Write $ on the tape\n</code></pre>\n\n<p>Where FH is the reading head which begins on the far left of the tape, and BH is the writing head which begins on the blank space after the last symbol on the tape. Once a cell is read or written into, the head in question moves one cell to the right. </p>\n\n<p>The starting configuration for the TM is this: 100!0110\\$ where the 0! indicates that the 0 is a marked symbol. The FH head begins on the first 1, and the BH head begins on the blank cell after the \\$. The ending configuration for that TM with that input is then 100!0110\\$1010!110\\$</p>\n\n<p>So, when describing this TM, what would its states be? Thanks!</p>\n", 'ViewCount': '54', 'Title': 'Turing Machine states', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-22T19:34:21.213', 'LastEditDate': '2014-01-22T09:29:57.980', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19900', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2014-01-21T20:23:17.490', 'Id': '19880'},47236:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is it possible to simulate a regular Turing Machine with a TM with the following specs?</p>\n\n<ol>\n<li>There are two heads, one of which can read, one of which can write</li>\n<li>Both heads can only move right</li>\n<li>When a head reads (or it writes) it moves right</li>\n</ol>\n\n<p>I know it's possible to simulate a TM that only moves right. But, is it possible to simulate the left moves as well?</p>\n", 'ViewCount': '85', 'Title': 'Simulating a TM with a 2-head, right moving TM', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-22T13:52:53.880', 'LastEditDate': '2014-01-22T09:25:11.160', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19889', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<turing-machines><turing-completeness><simulation>', 'CreationDate': '2014-01-22T01:08:02.397', 'Id': '19885'},47237:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is the point of non-binary printed letters on a turing machine? I understand that these need to be omitted to get a computable number, but why are they used in the first place?</p>\n', 'ViewCount': '75', 'Title': 'Why have additional symbols on a Turing machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T20:43:54.103', 'LastEditDate': '2014-01-23T18:10:25.883', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '19918', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-01-23T16:19:54.903', 'Id': '19916'},47238:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The following article <a href="http://www.academia.edu/1998899/COMPUTING_WITH_TILES" rel="nofollow">Computing with Tiles</a> contains a description of a Turing machine equivalent program in the form of a computable tiling that adds 5 and 9 to 14. What would be the representation of this program as a state diagram or in code such that I can run it with this <a href="http://db.ing.puc.cl/turingmachine/" rel="nofollow">Turing Machine simulator</a> ?</p>\n', 'ViewCount': '11', 'ClosedDate': '2014-02-01T15:46:02.960', 'Title': 'How to transform given computable tile to a Turing Machine program?', 'LastActivityDate': '2014-02-01T13:30:30.337', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'ndroock1', 'PostTypeId': '1', 'OwnerUserId': '13315', 'Tags': '<turing-machines>', 'CreationDate': '2014-01-31T12:26:53.250', 'Id': '20184'},47239:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><sup>This is a cross-post from a post on <a href="http://math.stackexchange.com/posts/655746/edit">MathSE</a> due to lack of answers.</sup></p>\n\n<p>To illustrate my question I provide the following example.</p>\n\n<p>The website <a href="http://db.ing.puc.cl/turingmachine/" rel="nofollow">Online Turing Machine</a> provides a Turing Machine simulator. The following program adds 1 to any binary number.</p>\n\n<pre><code>q0,1  =&gt;  q0,1,&gt;\nq0,0  =&gt;  q0,0,&gt;\nq0,_  =&gt;  q1,_,&lt;\nq1,0  =&gt;  q3,1,&gt;\nq1,1  =&gt;  q1,0,&lt;\nq1,_  =&gt;  q3,1,&gt;\n</code></pre>\n\n<p>A program line has the following format:</p>\n\n<pre><code>state, character read =&gt; new state, character written, direction tape\n</code></pre>\n\n<p>In the program above q0 is the initial state and q3 is the accepting state.</p>\n\n<p>In Tilings and Patterns by Gruenbaum and Shephard, 11.4 "Computing By Tiles" I read that it is possible to convert any turing machine program to a tiling of the plane using Wang tiles. The book contains an example tiling which calculates the Fibonacci numbers. The procedure, recipe, to convert a Turing machine program to a set of Wang tiles is not entirely clear to me.</p>\n\n<p><strong>Question: What is the algorithm to convert a Turing Machine program line by line to a set of tiling of the plane using Wang Tiles?</strong> And how does it work on the Turing machine in the given example?</p>\n\n<p>Update:</p>\n\n<p>Image is that of a Wang tile that adds 1 to a binary: 111 + 1 = 1000 where 1 is red, 0 is cyan. Aiming to generate tiles like this from any Turing Machine. First row 111, last row 1000.</p>\n\n<p><img src="http://i.stack.imgur.com/w6dl0.png" alt="Wang Tile"></p>\n', 'ViewCount': '81', 'Title': 'How to convert a Turing Machine program to a tiling using Wang Tiles?', 'LastEditorUserId': '13315', 'LastActivityDate': '2014-02-11T04:14:35.720', 'LastEditDate': '2014-02-05T11:13:19.857', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13315', 'Tags': '<turing-machines><simulation><computation-models><tiling>', 'CreationDate': '2014-02-02T10:11:46.570', 'Id': '20207'},47240:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My professor has been going over Turing machines, and I really don\'t understand how this example of a Turing machine for binary addition has to be read:</p>\n\n<p><img src="http://i.stack.imgur.com/p25i0.png" alt="enter image description here"></p>\n\n<p>I love working with finite state machines; if I knew how to read this Turing machine description I would use FSA\'s.</p>\n\n<p>Could someone give me a few examples of how binary addition could be computed with this Turing machine, and possibly a conversion to an FSA?</p>\n', 'ViewCount': '66', 'Title': 'Understanding a Turing machine description', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T19:14:11.197', 'LastEditDate': '2014-02-02T19:14:11.197', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2014-02-02T18:21:07.953', 'Id': '20225'},47241:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reducing a given Turing Machine to the complement of the known undecidable problem, \n$$ Complement(A_{TM}) = \\{ \\langle M,w \\rangle \\mid M  \\text{ is TM}, w \\not\\in L(M) \\}$$</p>\n\n<p>To this Turing Machine, known as SPARSE TM:\n$$\nSPARSE_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is 1-tape TM}, |L(M)| \\leq 1000\\} \n$$</p>\n\n<p>Here is what I have so far, but I think I need help because one of the statements I make seems fishy.</p>\n\n<p>Assume there is a TM <code>S</code> that decides the complement of the accept TM and a TM <code>R</code> that decides SPARSE. Then <code>S</code> looks like:</p>\n\n<pre><code>S = "On input `&lt;M,w&gt;`:\n    Construct M\':\n        M\' = "On input x:\n            if x in L(M):  #Fishy statement\n                accept\n            else: reject\n     Run R on &lt;M\'&gt;\n     if R accepts: accept; if R rejects: reject\n</code></pre>\n\n<p>This (if right) would then reduce the SPARSE TM and prove that it is undeciable, right? Any help would be appreciated.</p>\n', 'ViewCount': '89', 'Title': 'Reduction to complement of Accept Problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T00:25:49.743', 'LastEditDate': '2014-02-06T21:17:23.187', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21410', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<computability><turing-machines><reductions><undecidability>', 'CreationDate': '2014-02-06T20:30:09.477', 'Id': '21400'},47242:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a statement I am trying to prove, and I'm very close, but I think I'm missing a couple of key concepts about regular and context-free languages.</p>\n\n<p><strong>Question:</strong> Let\n$\nA = \\{ ww \\ | \\ w \\ \\epsilon \\ \\Sigma^{*} \\}\n$.</p>\n\n<p>Show that any language $L$ is Turing-decidable if and only if $L$ is many-one reducible to $A$.</p>\n\n<p>Where I am so far:</p>\n\n<ol>\n<li><p>Language $A$ is not context-free, but the complement of $A$ is context-free.</p></li>\n<li><p>Both $A$ and the complement of $A$ are decidable.</p></li>\n</ol>\n\n<p>So, that means I can prove one direction of the <em>iff</em> statement fairly easily: </p>\n\n<p>If $L$ is many-one reducible to $A$ then since $A$ is decidable from statement (2) above, also $L$ is decidable.</p>\n\n<p>The other direction is giving me problems. This is all I have  gleaned so far:</p>\n\n<p>If $L$ is Turing-decidable, then $L$ is a regular language.</p>\n\n<p>Is there some relation between regular and context-free languages with respect to reductions that I am missing? Or should I be making a different logic jump in this part of the proof?</p>\n", 'ViewCount': '116', 'Title': 'Proving iff statement with reductions', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-07T01:46:54.643', 'LastEditDate': '2014-02-07T00:14:22.467', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<turing-machines><reductions>', 'CreationDate': '2014-02-06T21:29:05.920', 'Id': '21405'},47243:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A deterministic queue automaton (DQA) is like a PDA except the stack is replaced by a queue. A queue is a tape allowing symbols to be written (push) on the left-end and read (pull) on the right-end. </p>\n\n<p>Actually I've proved that a 2-tape Turing Machine can simulate the DQA. Now I'm proving the DQA can simulate Turing Machine TM. Let the queue store all the input and the right-end symbol is the one being read. Suppose $a$ is the right-end symbol in the queue. </p>\n\n<p>For the transition $\\delta(q,a)=(r,b,L)$ in TM, it's easy to simulate. Just pull $a$ and push $b$. Now the right-end symbol would be the symbol on the left of $a$. It's like move the head in TM to the left. </p>\n\n<p>My problem is I cannot find a way to simulate the transition $\\delta(q,a)=(r,b,R)$. Since the symbol on the right of $a$ is actually the left-end symbol, how can I let this symbol move to the right-end? I spend several hours on this and I think answers on Internet are not very clear. Could anyone give me some hint? </p>\n", 'ViewCount': '48', 'Title': 'Prove Queue Automaton is equivalent to Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T23:27:53.420', 'LastEditDate': '2014-02-09T22:51:54.143', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21465', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<turing-machines><automata><simulation>', 'CreationDate': '2014-02-09T03:01:35.187', 'Id': '21460'},47244:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>given a turing machine M over the input alphabet $\\Sigma $ , any state q of M and a word w $\\epsilon\\Sigma $* , does the computation of M on w visit the state q ?</p>\n\n<p>Is this problem decidable ?</p>\n', 'ViewCount': '55', 'ClosedDate': '2014-02-16T18:36:16.933', 'Title': 'Decidability Problem', 'LastEditorUserId': '12805', 'LastActivityDate': '2014-02-13T17:09:23.360', 'LastEditDate': '2014-02-13T16:56:15.337', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12805', 'Tags': '<turing-machines><automata>', 'CreationDate': '2014-02-13T16:50:35.013', 'Id': '21602'},47245:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I read several times that it is not possible to flip the answer of a NDTM efficiently. However, I don\u2019t understand why. For instance, given a NDTM $M$ that runs in $O(n)$, <a href="http://www.cs.princeton.edu/theory/complexity/diagchap.pdf" rel="nofollow">this text</a> (section 3.3) states that it is unclear how another NDTM $T$ can determine in $O(n^{100})$ time how to flip $M$\u2019s answer.</p>\n\n<p>My Problem is as follows: A NDTM outputs $1$ iff there exists a sequence of non-deterministic choices that leads to the accepting state. Furthermore, there exists a universal NDTM $NU$ that can simulate every NDTM with only a small (logarithmic) overhead. So why can\u2019t we construct T as follows: First, simulate M with the universal NDTM which should be possible in time $O(n\\log n)$. Then output 1 \u2013 M\u2019s answer. This would mean that we can flip the answer of any linear NDTM in time $O(n\\log n)$.</p>\n', 'ViewCount': '233', 'Title': "Why can't we flip the answer of a NDTM efficiently?", 'LastActivityDate': '2014-02-14T05:39:42.170', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '21618', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '14654', 'Tags': '<complexity-theory><turing-machines>', 'CreationDate': '2014-02-13T22:06:33.487', 'FavoriteCount': '1', 'Id': '21613'},47246:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It makes me wonder that despite of (CFL) being a subset of Turing Decidable languages, Turing Decidable is closed under intersection while CFL is not.</p>\n\n<p>Does not Turing Decidable engulf all CFLs?</p>\n', 'ViewCount': '44', 'Title': 'CFL not closed under intersection while Turing Decidable are', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T23:03:12.623', 'LastEditDate': '2014-02-19T23:03:12.623', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9576', 'Tags': '<formal-languages><context-free><turing-machines><closure-properties><decision-problem>', 'CreationDate': '2014-02-19T19:14:27.437', 'Id': '21821'},47247:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is known that a nondeterministic universal turing machine (UTM) can simulate another nondeterministic TM with running time $t(n)$ in time $c t(n)$, where $c$ is a constant. It is also known that a deterministic UTM can simulate another deterministic TM with running time $t(n)$ in time $ t(n)\\log(t(n))$. </p>\n\n<p>My question is: why is there a $\\log(t(n))$ slowdown in the simulation of a deterministic TM by a UTM, as opposed to a constant factor slowdown in the nondeterministic case?</p>\n', 'ViewCount': '164', 'Title': 'Difference between deterministic and nondeterministic universal turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-23T20:36:58.043', 'LastEditDate': '2014-02-23T20:36:58.043', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14961', 'Tags': '<complexity-theory><turing-machines><time-complexity><simulation>', 'CreationDate': '2014-02-23T17:58:30.433', 'Id': '21949'},47248:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that a logspace transducer is a deterministic Turing machine that enables us to use log-space complexity. I do not understand though why that is correct. Whatever algorithms can be implemented in that machine are automatically of log-space complexity? Why is that?</p>\n', 'ViewCount': '33', 'Title': 'Logspace Transducer', 'LastActivityDate': '2014-02-23T20:28:34.030', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14957', 'Tags': '<turing-machines><space-complexity>', 'CreationDate': '2014-02-23T20:08:30.823', 'Id': '21954'},47249:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Writing a proof by contradiction is fairly formulaic--first you assume the opposite, then derive a contradiction.  I would like to know the steps and conventions for writing a many-one reduction proof.  <a href="http://cs.stackexchange.com/a/4582/14650">This answer</a> was somewhat helpful, but like other explanations I\'ve heard, it sounds too similar to a proof by contradiction for me to understand the difference.</p>\n\n<p>My specific points of confusion:</p>\n\n<ul>\n<li>The exact meaning of $A \\leq _{m} B$</li>\n<li>Do we reduce an unknown problem to a known problem, or the opposite</li>\n<li>Does the reduction function transform a known problem into an unknown problem, or the opposite</li>\n<li>How a many-one reduction is different from a proof by contradiction.  It seems like a simpler version of the same logic; if so, how is the simplification justified</li>\n</ul>\n\n<p>I am only interested in many-one reductions of language/Turing machine problems (in case the term has meaning in other contexts as well).  Any help is appreciated, including links and illustrative examples.  Thanks.</p>\n', 'ViewCount': '45', 'Title': 'How to write a many-one reduction proof', 'LastEditorUserId': '14650', 'LastActivityDate': '2014-02-26T15:04:25.143', 'LastEditDate': '2014-02-26T03:32:52.807', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22021', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14650', 'Tags': '<turing-machines><reductions>', 'CreationDate': '2014-02-25T03:35:11.147', 'Id': '22011'},47250:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We may not have a determinate answer to this question. But is there any evidence for or against this question? Or is there any study on it?</p>\n', 'ViewCount': '76', 'Title': 'Is human being a Turing Machine?', 'LastActivityDate': '2014-02-25T14:28:45.557', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '22024', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '15022', 'Tags': '<turing-machines><artificial-intelligence>', 'CreationDate': '2014-02-25T10:14:21.390', 'Id': '22020'},47251:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a set S is infinite and recognizable, how can I prove that, if any, some subsets K is infinite and decidable? how about infinite and recognizable? </p>\n', 'ViewCount': '99', 'Title': 'If a set S is infinite and recognizable, is there an infinite subset of S that is decidable?', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-26T06:17:08.517', 'LastEditDate': '2014-02-26T03:12:43.210', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22041', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15045', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-02-26T01:43:35.303', 'Id': '22039'},47252:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Here is the problem:</p>\n\n<p>Prove the single-tape TM that cannot write on the portion of the tape containing the input string recognize only regular language. </p>\n\n<p>My idea is to prove that this particular TM is equivalent to DFA. </p>\n\n<p>Using this TM to simulate DFA is very straightforward. </p>\n\n<p>However, when I want to use this DFA to simulate TM, I encounter the problem. For the TM transition $\\delta(q,a)=(q',a,R)$, DFA can simulate definitely by reading tape to the right and doing the same state transition. </p>\n\n<p>For $\\delta(q,a)=(q',a,L)$, I cannot figure out how to use this DFA or NFA to simulate the left move because the DFA only reads to left and has no stack or something to store.</p>\n\n<p>Should I consider another way? Could anyone give me some hints? Thanks. </p>\n", 'ViewCount': '56', 'Title': 'Prove Single-Tape and Non-write Turing Machine can Only Recognize Regular Language?', 'LastActivityDate': '2014-02-27T06:41:33.020', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><computability><regular-languages><turing-machines><automata>', 'CreationDate': '2014-02-27T06:41:33.020', 'Id': '22082'},47253:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I understand what Rice's theorem states and what Trivial and Non-trivial properties mean. However, when given some property, I am having a hard time seeing if it is Trivial or Non-trivial. Can someone help me understand this better, maybe with some good examples? </p>\n", 'ViewCount': '47', 'ClosedDate': '2014-02-28T08:43:26.950', 'Title': 'How do you classify properties as Trivial and Non-trivial?', 'LastActivityDate': '2014-02-27T20:25:49.257', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22108', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13077', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-02-27T20:16:14.457', 'Id': '22106'},47254:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The set of all Turing machines is said to be countable. The central idea of the proof of this fact is that every Turing machine can be written as a finite string of characters. I am having trouble seeing how this could be true.</p>\n\n<p>If we formally define a Turing machine as having a tape language $\\{0, 1, \\sqcup, x\\}$ and input language $\\{0, 1\\}$, then I can sort of see how any Turing machine could be encoded.</p>\n\n<p>However, many books allow other symbols, such as $a$ or $3$, etc., to be part of the input language. I've heard people say that this is okay because we could represent such characters as a string like $0101$ or $1011$ or whatever, much like how Unicode represents code points consisting of multiple code units, or just how any computer represents anything at all!</p>\n\n<p>But here is my problem with this. If we are trying to construct an actual function $f$ from the set of all Turing machines $\\mathscr{M}$ to $\\mathbb{N}$, then every Turing machine must be encoded in the same way. That is, we can't have encodings of different lengths, so that 01 represents $01$ for one Turing machine and represents $3$ for another. That is, unless we have some encoding at the beginning of each Turing machine which explains how the machine is to be decoded. But even then, this encoding itself must be universal.</p>\n\n<p>The problem is much like the charset problem for HTML pages. That is, that a web browser must know the encoding of the page before it can decipher a command in the HTML to encode the page a certain way. This was solved for web pages by having the encoding command characters (<code>meta charset=utf-8</code> for example) be the same in all encodings. But then the encoding itself is stored elsewhere. </p>\n\n<p>Anyway, my question is how we resolve this apparent conundrum. How does one encode a Turing machine with a finite input language of any length so that one can make <strong>one</strong> function from $\\mathscr{M}$ to $\\mathbb{N}$?</p>\n", 'ViewCount': '42', 'Title': 'A string representation of any Turing machine', 'LastActivityDate': '2014-03-01T23:29:09.370', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '22175', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<turing-machines><encoding-scheme>', 'CreationDate': '2014-03-01T22:28:33.390', 'Id': '22169'},47255:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am a high school student in the twelfth grade. I study high-level programming, and a little bit of basic computer science.</p>\n\n<p>I have recently started to understand what a Turing Machine is. I wanted to ask:</p>\n\n<p>I understand that a Turing Machine is a hypothetical device used to <em>explain</em> the mechanisms of computing.</p>\n\n<p>But is a Turing Machine conceptually the actual very basis of computers? (In the most basic level). Or do real world computing mechanisms and the Turing Machine mechanism (way of calculating things) have very little in common?</p>\n', 'ViewCount': '71', 'Title': 'Regarding the Turing Machine', 'LastActivityDate': '2014-03-06T03:57:25.333', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15319', 'Tags': '<turing-machines>', 'CreationDate': '2014-03-05T19:32:24.693', 'FavoriteCount': '1', 'Id': '22312'},47256:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Sorry this is a basic question to understand decidability. It is the first time I see it in my undergrad course.</p>\n\n<p><strong>1)</strong>\nI am reading why the language <code>AFDA</code> is decidable and why <code>ATM</code> (halting problem) is not. The explanation says that the emulated <code>TM</code> in <code>ATM</code> might loop forever. I agree, because a specific input string might make the <code>TM</code> going forever, always able to apply rules and never halting.</p>\n\n<p>However, why is <code>AFDA</code> decidable? What if the automaton never reaches any of its final states and keeps looping? There might be a specific input that makes the <code>FDA</code> never reach such states. I understand that once the input string finishes, it will be either accepted or rejected, but what if it does not finish? I'm assuming the input string in the <code>TM</code> can be infinite.</p>\n\n<p><strong>2)</strong>\nThe same problem I have here:</p>\n\n<pre><code>A = { 0^k 1^k | k &gt;= 0}\n</code></pre>\n\n<p>This language is decidable, and it will halt in strings like <code>10</code>, <code>010101</code>, etc but what if the input string is infinite <code>01010101......</code> it will never end.</p>\n\n<p>What am I missing?</p>\n", 'ViewCount': '50', 'Title': 'Understanding decidability', 'LastActivityDate': '2014-03-06T15:02:21.243', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'Bea', 'PostTypeId': '1', 'Tags': '<turing-machines>', 'CreationDate': '2014-03-05T17:34:21.227', 'Id': '22318'},47257:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Currently I am studying Turing machines and I understand that a Turing machine can produce all the strings of the language accepted by that particular Turing machine. We call such a Turing machine an <em>enumerator</em>. I have studied the formal definition of enumerators that have no input. But I am unable to realize how a Turing machine can work as an enumerator for the language $L=\\{a^nb^n:n\\geq0\\}$. Any help would be greatly appreciated.</p>\n', 'ViewCount': '142', 'Title': 'How turing machine can be used as enumerator', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-09T00:53:06.260', 'LastEditDate': '2014-03-09T00:48:45.823', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13053', 'Tags': '<turing-machines><automata>', 'CreationDate': '2014-03-08T20:35:14.753', 'Id': '22410'},47258:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In case of algorithm analysis we assume a generic one processor Random Access Machine(RAM). As I know RAM is machine which is no more efficient than the Turing machine.All algorithms can be implemented in the Turing machine.So my question is if Turing machine is equally efficient as RAM, then why we are not assuming Turing machine for algorithm analysis.What is the difference between RAM and TM. </p>\n', 'ViewCount': '55', 'Title': 'What is the difference between RAM and TM', 'LastActivityDate': '2014-03-09T05:55:07.097', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22419', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13053', 'Tags': '<complexity-theory><turing-machines><automata>', 'CreationDate': '2014-03-09T05:42:40.073', 'FavoriteCount': '2', 'Id': '22418'},47259:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '54', 'Title': 'Regarding Turing Machine Halting Problem', 'LastEditDate': '2014-03-09T19:51:40.390', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13053', 'FavoriteCount': '1', 'Body': "<p>All problems solved by standard today's general purpose computer can be solved by standard Turing machine.As general purpose computer can't do more than Turing machine so The Turing machine halting problem must also be  unsolved by today's general purpose computer.How can I realize the fact that halting problem can't be solved by todays general purpose computers.</p>\n", 'ClosedDate': '2014-03-09T22:12:51.443', 'Tags': '<computability><turing-machines><halting-problem>', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-09T19:54:26.980', 'CommentCount': '5', 'CreationDate': '2014-03-09T06:34:28.180', 'Id': '22420'},47260:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$ALL_{REGEX}$ is the computational problem of determining for regular expression x if $L(x) = \\Sigma^*$.  In a proof for $ALL_{REGEX} \\in PSPACE$, the following non-deterministic turing machine $M(R)$ on regular expression $R$ is given</p>\n\n<p>Convert R to an NFA $N = (Q,\\Sigma,\\delta,S,F)$;   $K = S$;  </p>\n\n<p>While $K \\cap F \\neq \\emptyset$</p>\n\n<ol>\n<li>Non-deterministically guess a character $a \\in \\Sigma$</li>\n<li>S' = Compute the new set of states from character $a$ and states $K$</li>\n<li>K = S'</li>\n</ol>\n\n<p>The proof states that iff $M$ does not halt, then $L(R) = \\Sigma^*$.  Suppose we have $\\Sigma = \\{a,b\\}$ and R = a*. Why doesn't this machine halt?  Won't there be a single path of guesses (namely, a*) that goes on forever, implying the whole machine does as well?</p>\n\n<p>The algorithm goes prove that after $2^{|Q|}$ steps, we know the language must be $\\Sigma^*$, so we accept instead of looping.  I understand the intuition of the algorithm and how it would be implemented deterministically  , but I'm confused as to how the algorithm above works when the NTM formalism accepts if any path accepts and it is making me question my understanding of NTMs.</p>\n", 'ViewCount': '29', 'Title': 'ALL_{REGEX} in PSPACE algorithm', 'LastEditorUserId': '1784', 'LastActivityDate': '2014-03-12T17:56:18.223', 'LastEditDate': '2014-03-12T17:49:36.407', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1784', 'Tags': '<turing-machines><space-complexity>', 'CreationDate': '2014-03-12T17:34:32.667', 'Id': '22549'},47261:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a proof I need to use the fact that every word in the language of an enumerator occur on the output paper in finite time. Is it true?\nFor example, the language of the natural numbers in decimal representation. Can the enumerator print the odd numbers first and then the even numbers? (if yes, I am wrong)</p>\n\n<p>$1, 3, 5, 7, ..., 2, 4, 6 ,8, ...$</p>\n\n<p>As I know, we get to the even numbers but not in finite time (maybe transfinite induction based on this)</p>\n', 'ViewCount': '48', 'Title': 'Does an enumerator print the first occurrence of a word in finite time?', 'LastActivityDate': '2014-03-13T17:35:15.507', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22560', 'Score': '4', 'OwnerDisplayName': 'labuwx', 'PostTypeId': '1', 'OwnerUserId': '15620', 'Tags': '<turing-machines>', 'CreationDate': '2014-03-12T21:38:29.133', 'Id': '22558'},47262:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '74', 'Title': 'Can Turing Machines decide on computability?', 'LastEditDate': '2014-03-13T09:35:34.547', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15625', 'FavoriteCount': '1', 'Body': '<p>Can a Turing Machine decide whether an arbitrary real number is computable or not? Does this even follow from the solution of the Halting problem? If not, who proved it?</p>\n', 'ClosedDate': '2014-04-02T13:17:36.307', 'Tags': '<computability><turing-machines><real-numbers>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-13T09:35:34.547', 'CommentCount': '2', 'CreationDate': '2014-03-13T02:49:08.490', 'Id': '22570'},47263:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Say I plugged in a <a href="http://en.wikipedia.org/wiki/Hardware_random_number_generator" rel="nofollow">hardware true-random number generator (TRNG)</a> to my computer, then wrote programs with output that depends on the TRNG\'s output. Can it do anything non-trivial that a Turing machine with a psuedo-random number generator can\'t do? (a trivial thing it can do would be generating truly random numbers)</p>\n', 'ViewCount': '37', 'Title': 'Are there any practical differences between a Turing machine with a PRNG and a probabilistic Turing machine?', 'LastActivityDate': '2014-03-17T20:49:58.900', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15790', 'Tags': '<turing-machines><randomness><probabilistic-algorithms>', 'CreationDate': '2014-03-17T19:39:13.557', 'Id': '22720'},47264:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am working through Sipser, and I am trying to understand some of the algorithms described in Space Complexity, but I am having a hard time understanding the presentation of the material (especially Savitch\'s theorem). I have a very strong intuition for time complexity, but I don\'t understand how space complexity fits into a heirarchy of time complexity, and I think it has to do with the fact that it is all discussed in terms of Turing machines. It is hard to see how space and time are related when I\'m wasting time untangling convoluted algorithms described in terms of Turing machines.</p>\n\n<p><strike>Does anyone have any advice on how to think about Turing machines vis-a-vis contemporary computation in general? It is unintuitive to think about algorithms in terms of input strings, tapes, and machines simulating machines. I don\'t feel like I am leveraging my existing knowledge of computers and programming to more deeply understand the proofs and algorithms being presented.</strike></p>\n\n<p>I think I just need help understanding how space varies based on the data structure of the input. For some input of size $n$, are the bits required to represent each entity of the input negligible? Say our language is a set of objects that are all of a certain type, and each object is massive. How does space usage vary vs. a similar language with very small objects?</p>\n\n<p>Edit: I understand now that space complexity fits in with time complexity because they are both <em>resources</em> used to determine whether some string is a member of a language; Or in other words, whether some element belongs to a particular problem (<a href="http://cs.stackexchange.com/q/22742/15660">see here</a>).</p>\n', 'ViewCount': '58', 'Title': 'How to Study Space Complexity', 'LastEditorUserId': '15660', 'LastActivityDate': '2014-03-18T04:12:44.430', 'LastEditDate': '2014-03-18T04:12:44.430', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<turing-machines><space-complexity>', 'CreationDate': '2014-03-18T01:56:41.580', 'Id': '22741'},47265:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given that Let S = {a | |a| is odd}. I know that since S is decidable, but does there exist a subset within S that is undecidable?</p>\n', 'ViewCount': '74', 'ClosedDate': '2014-03-21T00:04:46.543', 'Title': "how do I find a undecidable subset of a set that's decidable?", 'LastActivityDate': '2014-03-20T01:59:19.380', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22841', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15045', 'Tags': '<turing-machines><undecidability>', 'CreationDate': '2014-03-20T01:41:32.803', 'Id': '22839'},47266:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have seen turing machines beeing represented with tapes infinite in one, and in two directions. Is there any difference in the power of such turing machines, or are they basically equivalent? In my head I think they are equivalent, since I guess that there must be some way to represent the two-way infinite tape as a one-way infinite tape, but I can't seem to find a proof or example. </p>\n", 'ViewCount': '94', 'Title': 'Turing machine - infinite tape in one or two directions', 'LastActivityDate': '2014-03-21T07:54:52.320', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22876', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<turing-machines>', 'CreationDate': '2014-03-20T14:19:36.920', 'Id': '22863'},47267:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>what would the Turing machine state diagram be for this language: \n$A=\\{ (0 \\cup 1)^a(1 \\cup 2)^b(2\\cup 3)^c \\mid a \\geq  b\\} $ ?</p>\n\n<p>how would the turing machine design know the size of $(1 \\cup 2)^b$ ? since this contains elements from the first and last parts, would it be impossible to determine? </p>\n', 'ViewCount': '72', 'Title': 'Tricky Turing Machine state diagram', 'LastActivityDate': '2014-03-22T00:50:55.423', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '22918', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<turing-machines><computation-models>', 'CreationDate': '2014-03-21T18:38:17.700', 'Id': '22909'},47268:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read that linear bounded automaton is a Non deterministic Turing machine. Why is it so?</p>\n', 'ViewCount': '25', 'Title': 'Why it is said that LBA is a non deterministic Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:35:08.413', 'LastEditDate': '2014-03-22T11:35:08.413', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22922', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<terminology><turing-machines><automata><nondeterminism><linear-bounded-automata>', 'CreationDate': '2014-03-22T01:05:54.747', 'Id': '22919'},47269:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read in <a href="https://en.wikipedia.org/wiki/Halting_problem#Common_pitfalls" rel="nofollow">Wikipedia</a> and some other texts that</p>\n\n<blockquote>\n  <p>The halting problem is [...] decidable for <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" rel="nofollow">linear bounded\n  automata</a> (LBAs) [and] deterministic machines with finite memory.</p>\n</blockquote>\n\n<p>But earlier it is written that the halting problem is an undecidable problem and thus TM can\'t solve it! Since LBA are defined as a type of TM, should the same not hold for them?</p>\n', 'ViewCount': '192', 'Title': 'Why is the halting problem decidable for LBA?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-22T13:15:09.093', 'LastEditDate': '2014-03-22T13:15:09.093', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<turing-machines><automata><undecidability><halting-problem><linear-bounded-automata>', 'CreationDate': '2014-03-22T02:06:19.990', 'Id': '22925'},47270:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to show that the following language is recognizable:\n$$L:= \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on some string}\\}.$$</p>\n\n<p>How do I go about showing that this language is recognizable? I know that all recognizable languages are reducible to $HALT_\\epsilon$, so I figure if I can show that this language reduces to $HALT_\\epsilon$, then I am all set. I am defining $HALT_\\epsilon$ as follows:</p>\n\n<p>$$HALT_\\epsilon:= \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on } \\epsilon \\},$$</p>\n\n<p>where $\\epsilon$ is the empty string. We can reduce $HALT$ on $x$ to $HALT_\\epsilon$ by a reduction $F(\\langle M, x\\rangle) = \\langle M\' \\rangle $, where $M\'(y) = M(x)$. For this reduction, we just ignore the input string $y$, which we know will be $\\epsilon$ and just run $M$ on $x$ instead. Here, $HALT$ is defined as</p>\n\n<p>$$HALT:= \\{ \\langle M,x \\rangle \\mid M \\text{ is a TM that halts on } x \\}.$$</p>\n\n<p>I tried leveraging a similar technique to show that $L$ is recognizable, but I could not come up with anything better than this (somewhat crazy) TM that has a $HALT_\\epsilon$ oracle:</p>\n\n<p>$ D^{HALT_\\epsilon} =$ On input $\\langle M \\rangle:$</p>\n\n<ol>\n<li>Construct $N = $ "On input $x:$\n<ol>\n<li>Run $M$ in parallel on all inputs $y\\in \\Sigma^*$.</li>\n<li>If $M$ halts on any $y$ then <em>accept</em>, otherwise <em>loop.</em>"</li>\n</ol></li>\n<li>Query the oracle to determine whether $\\langle N \\rangle \\in HALT_\\epsilon$.</li>\n<li>If the oracle answers YES, <em>accept</em>; if NO, <em>reject</em>.</li>\n</ol>\n\n<p><em>Note: My notation for TM algorithms is based on "Theory of Computation" by Sipser.</em> Step 2 for the definition of $N$ is a bit redundant, but in this type of context, is it okay to say something like "If $M$ halts on any $y$, then halt?"</p>\n\n<p>I think all I have shown here is that $L$ is decidable relative to $HALT_\\epsilon$. I don\'t know if this implies that $L$ is recognizable. Can a Turing reduction be used in this manner to show that a language is recognizable? I\'m confused as to what it means for a language to be recognizable. The task seems obvious if we go back to the definition: If some TM $R$ accepts strings in $L$, then $R$ recognizes $L$. So what if $R=D^{HALT_\\epsilon}$, and in the body of $D^{HALT_\\epsilon}$ we use some crazy reduction like $N$?</p>\n\n<p>In general, to show recognizability, can we just come up with a reduction like $N$ that may or may not halt? Is it a problem that $N$ will never halt if $\\langle M \\rangle \\notin L$?</p>\n', 'ViewCount': '48', 'Title': 'Is the language of TMs that halt on some string recognizable?', 'LastEditorUserId': '15660', 'LastActivityDate': '2014-03-22T17:05:52.690', 'LastEditDate': '2014-03-22T17:05:52.690', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22935', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-03-22T06:02:02.640', 'Id': '22929'},47271:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In class last week, my professor commented and said that Turing machines are used as a standard measure/model of what is computable and are a helpful basis of discussion for that subject. She also said that all variants of Turing machines are proven to be computationally equivalent -- read, just as powerful -- as one another. W</p>\n\n<p>I commented and said yesterday that, regarding computability power, I noticed that some turing machines can take incredibly large amounts of time to compute something very simple, while a turing machine with more tapes can compute something in a lower asymptotic complexity with respect to the number of steps needed.</p>\n\n<p>She said that with respect to class discourse, the runtime of a particular algorithm on a turing machine does not change the definition of computability, or the power with which we measure computability. "We\'re concerned about what is computable, not what is efficiently computable at this point." So, it doesn\'t matter if the turing machines has more and more tapes, and more and more tapes implies that it can compute in lesser steps. Okay, I get that we\'re really focusing on what IS computable, not the speed at which we can compute it. </p>\n\n<p>Something about that just bothers me, because up to this point, algorithms with abnormally large asymptotic time and space complexity really define the limits of what is, maybe I should say, practically, computable. </p>\n\n<p>So, I have a couple of questions:</p>\n\n<ol>\n<li>Suppose we have a model for <a href="http://cs.stackexchange.com/questions/125/how-to-define-quantum-turing-machines">a quantum turing machine</a>, this must be equivalent to a "regular" turing machine, right? </li>\n</ol>\n\n<p>So, the answer to that question I think really is going towards my reason for writing this post. Does quantum computing technology antiquate the classical definitions of what is computable via a turing machine?</p>\n\n<ol>\n<li>Is this something above my head and should I delete this post? I don\'t mean to be precocious, I just didn\'t see a question similar to mine. </li>\n</ol>\n', 'ViewCount': '860', 'Title': 'Quantum Computing and Turing Machines: Are Turing Machines still an Accurate Measure?', 'LastActivityDate': '2014-03-28T04:10:44.753', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23164', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '12863', 'Tags': '<turing-machines><quantum-computing>', 'CreationDate': '2014-03-28T03:34:32.470', 'FavoriteCount': '1', 'Id': '23162'},47272:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For an assignment in my university, we have to answer multiple choice questions about theoretical computer science. This particular one I find very hard to understand. I wonder if some of you could explain it to me.</p>\n\n<pre><code>In this question, L1, L2, L3, L4 refer to languages and M, M1, M2 refer to Turing machines.  \n</code></pre>\n\n<p>Let  </p>\n\n<pre><code>L1 = {(M1,M2) | L(M1) is a subset of L(M2)},\nL2 = {M | There exists an input on which TM M halts within 100 steps},\nL3 = {M | There exists an input w of size less than 100, such that M accepts w},\nL4 = {M | L(M) contains at least 2 strings}.\n</code></pre>\n\n<p>Decide whether each of L1, L2, L3 and L4 are recursive, RE or neither. Then identify the true statement below.</p>\n\n<pre><code>     a)      The complement of L3 is recursively enumerable.\n     b)      The complement of L2 is recursive.\n     c)      The complement of L2 is not recursively enumerable.\n     d)      L1 is recursively enumerable.\n</code></pre>\n\n<p><strong>What I do not understand is, how the definitions of L1, L2, L3, L4 can tell me whether or not they are recursive (enumerable).</strong> </p>\n\n<p>My guesses (probably wrong) are:</p>\n\n<p>L1: ?</p>\n\n<p>L2: recursive enumerable (I thought this since obviously there are inputs on which the TM halts but we can not say if it halts every time &ndash; therefore only recursive enumerable and not recursive)</p>\n\n<p>L3: recursive enumerable (Same explanation as for L2)</p>\n\n<p>L4: not recursive (This is only a guess, I don't get how the number of minimum strings of the language can imply any type of recursiveness.)  </p>\n", 'ViewCount': '42', 'Title': 'Turing machines and languages -- recursive (enumerable) or not', 'LastEditorUserId': '16286', 'LastActivityDate': '2014-03-30T12:46:48.657', 'LastEditDate': '2014-03-30T12:38:55.190', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16286', 'Tags': '<formal-languages><turing-machines><halting-problem>', 'CreationDate': '2014-03-30T09:58:27.093', 'FavoriteCount': '1', 'Id': '23250'},47273:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a homework question about the properties (decidability, Turing-recognizability, etc.) of the language </p>\n\n<p>$$ L = \\{ \\langle M \\rangle | \\text{$M$ is a TM and $M$ accepts some string $w$ which has 101 as a prefix} \\}. $$</p>\n\n<p>I have made an attempt at showing decidability of $L$:</p>\n\n<p>On input $\\langle M, w\\rangle$ (where $M$ is a TM and $w \\in \\sigma^*$):</p>\n\n<ol>\n<li>Simulate $M$ on $w$.</li>\n<li>If $M$ rejects and halts, reject. If $M$ accepts and halts, accept.</li>\n</ol>\n\n<p>However, I'm not sure about moving forward after this. I do not want a solution, but I want some ideas/techniques as to what else I can prove about $L$. </p>\n", 'ViewCount': '85', 'Title': 'The language of TMs accepting some word starting with 101', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-31T23:14:21.683', 'LastEditDate': '2014-03-31T22:38:24.807', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16332', 'Tags': '<complexity-theory><formal-languages><turing-machines><automata>', 'CreationDate': '2014-03-31T21:27:37.883', 'Id': '23300'},47274:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '385', 'Title': 'how to draw a complement of a Turing Machine?', 'LastEditDate': '2014-04-03T06:35:15.050', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '14495', 'FavoriteCount': '1', 'Body': '<p>I am now pretty confident on how I would turn something into a Turing Machine. Now my question is how do you convert TM into a complement of a Turing Machine. From what I can remember in Finite Automata, complementing it you would just turn a start state into a ending state, also if you have an ending state you would make it into a start state..How would you do complement of a Turing Machine ? </p>\n\n<p>For example here I have a simple TM of a Palindrome and I want a Palindrome\'</p>\n\n<p><img src="http://i.stack.imgur.com/x3TEH.png" alt="enter image description here"></p>\n', 'Tags': '<turing-machines><automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-03T17:05:24.023', 'CommentCount': '5', 'AcceptedAnswerId': '23378', 'CreationDate': '2014-04-02T23:50:40.633', 'Id': '23375'},47275:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am currently learning about Turing Machines, I am curious if a Turing Machine can have fewer states ?  Can it be done like a Transition Graph where you can have multiple states at once ? </p>\n\n<p>I got this TM off of a youtube video sorry for bad hand writing, but could I just merge some of the states like you would do in Transition Graph, so instead of having 5 states it would have 4 states ? TM are more advanced so I don\'t know if you are even able to do this...thanks! </p>\n\n<p><img src="http://i.stack.imgur.com/PaQ1r.jpg" alt="enter image description here"></p>\n\n<p>how could I make this into 4 states TM instead of 5 states ? in TG if would take 5 seconds do it...</p>\n', 'ViewCount': '120', 'Title': 'Can a Turing Machine have fewer states?', 'LastActivityDate': '2014-04-07T10:51:55.300', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16430', 'Tags': '<turing-machines>', 'CreationDate': '2014-04-03T21:17:37.680', 'Id': '23404'},47276:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Have a question that requires me to write the rules for parsing a turing machine </p>\n\n<p>This is the question</p>\n\n<p>The PROBLEM involves writing a set of Turing Machine rules that will read and determine whether or not an input corresponds to the rules of a Turing Machine. This is the \ufb01rst step of a Universal Turing Machine. For example, if the input is a legal set of rules, then the machine shall accept this input (and any other legal input that describes a Turing Machine).</p>\n\n<p>The input would be \nIO = current state with the number of  I's indicating what state\nI = would be the current symbol being true with O being false\nIIO  = next state \nI = next symbol with O being false\nI or O = direction with I being left and O being right</p>\n\n<p>so a legal input would be </p>\n\n<p>IOOIIOOI     which would be state 1 = current state false = next state 2 = next state false = left</p>\n\n<p>How would I write the rule so that if I ran it through and it detected that the rules did not conform to the legal input it would place II at the beginning of the input and if its correct put OO at the beginning.</p>\n", 'ViewCount': '38', 'Title': 'Parsing Turing Machine', 'LastActivityDate': '2014-04-06T11:12:59.550', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16493', 'Tags': '<turing-machines><parsing>', 'CreationDate': '2014-04-06T11:12:59.550', 'Id': '23474'},47277:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In Sipser's Introduction to the Theory of Computation, there is an exercise that asks to prove $T$ decides $A_{TM}$, which is the language </p>\n\n<p>$$A_{TM} = \\{ \\langle M,w \\rangle | M \\text{ is a TM and $w \\in L(M)$}\\}.$$</p>\n\n<p>$T$ is a TM defined as follows. On input $\\langle M,w \\rangle$,</p>\n\n<ol>\n<li>Write the description of a TM $R$ that works as follows. On input $x$,\n<ul>\n<li>Run $T_A$ on $x$.</li>\n<li>If $T_A$ accepts $x$ then accept.</li>\n<li>If $T_A$ rejects $x$ then run $M$ on input $w$ and accept if $M$ does.</li>\n</ul></li>\n<li>Run $P$ on input $\\langle R \\rangle$, accept if $P$ rejects and reject if $P$ accepts.</li>\n</ol>\n\n<p>Here:</p>\n\n<ul>\n<li>$T_A$ is a TM that decides the language $A$.</li>\n<li>$P$ is a TM that can decide the language\n$$  Z = \\{\\langle M\\rangle | M\\text{ is a TM and } L(M) = A\\}. $$   </li>\n<li>$ A = \\{(0 \\cup 1)^a(1 \\cup 2)^b(2 \\cup 3)^c | a \\geq b\\} $.</li>\n</ul>\n\n<p>How can you prove that $T$ decides $A_{TM}$ ?</p>\n", 'ViewCount': '23', 'ClosedDate': '2014-04-14T07:50:11.927', 'Title': 'How do you prove that this TM decides a language that is undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-14T07:49:33.580', 'LastEditDate': '2014-04-14T07:49:33.580', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2014-04-14T02:08:14.150', 'Id': '23770'},47278:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was asked to give a formal description of a Turing machine I have no experience with this, and was wondering what "formal description" entails.</p>\n', 'ViewCount': '77', 'Title': 'What is the formal description of a Turing machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-15T10:09:11.737', 'LastEditDate': '2014-04-15T10:09:11.737', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23795', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16769', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2014-04-14T18:44:51.683', 'Id': '23792'},47279:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m having trouble grasping this the concept of reductions. I found the solution and it looks like this:</p>\n\n<p><img src="http://i.stack.imgur.com/eqv7G.png" alt="enter image description here"></p>\n\n<p>Assume that $M_5$ is a Turing Machine that can decide if a given Turing Machine $M$\naccepts any string of length $5$, i.e., $L(M)$ contains a string of length $5$. The above figure shows how we can use this to construct a Turing Machine that can solve the Halting\nproblem.</p>\n\n<p>The output $M\u2032$ of our translator behaves as follows:</p>\n\n<ol>\n<li>$M\u2032$ erases its own input and replaces it with the string w.</li>\n<li>It them simulates $M$ on $w$.</li>\n<li>If $M$ halts on $w$, then it goes into a final state (accepts its input).\nIt is clear that if $M$ halts on $w$, $M\u2032$ accepts all its inputs. So it accepts a string of length 5 as well.\nIf $M$ does not halt on $w$, $M\u2032$ does not accept any string at all. So it does not accept any\nstring of length 5 either.\nSo $L(M\u2032)$ includes a string of length $5$ if and only of $M$ accepts $w$. So by running $M_5$ on $M\u2032$, we can decide if $M$ halts on $w$ or not. But we know that this is not possible since the halting problem is undecidable. Hence $M_5$ does not exist and the given problem is undecidable.</li>\n</ol>\n\n<p>What I am confused about is: "if $M$ halts on $w$, $M\u2032$ accepts all its inputs" and "If $M$ does not halt on $w$, $M\u2032$ does not accept any string at all". Can someone clarify why this is the case? I\'ve been trying to work out the logic for so long. If any of you guys could help this would be great!</p>\n\n<p><a href="http://web.engr.oregonstate.edu/~tadepall/cs321/09/assigns/sol-a7.pdf" rel="nofollow">Source</a></p>\n', 'ViewCount': '55', 'Title': 'Showing that deciding whether a given TM accepts a word of length 5 is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-15T10:42:26.763', 'LastEditDate': '2014-04-15T10:14:36.127', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23808', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2014-04-15T05:22:14.183', 'Id': '23804'},47280:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For $L_1, L_2 $ and $L_1 \\in RE $ and  $ L_1\\notin R$ and $L_2 \\in RE $ and  $ L_2\\notin R$</p>\n\n<p>I was asked to prove/disprove if the following can occur:</p>\n\n<ol>\n<li>$L_1 \\cap L_2 \\in R$</li>\n<li>$L_1 \\cup L_2 \\in R$</li>\n<li>$L_1 \\cap L_2 \\in R$ and $L_1 \\cup L_2 \\in R$</li>\n</ol>\n\n<p>For 1., I think any two disjoint langauges will suffice (because the empty set is decideable).</p>\n\n<p>For 2., I think something along the lines of a language and its complement but I'm struggling to think of an example.</p>\n\n<p>For 3,. it seems impossible but I have no idea how to prove it.</p>\n\n<p>Any help/further insight would be welcomed!</p>\n", 'ViewCount': '95', 'Title': "Intersection/Union of recursively enumerable languages that aren't decidable?", 'LastActivityDate': '2014-04-15T21:19:17.917', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23832', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16769', 'Tags': '<formal-languages><turing-machines>', 'CreationDate': '2014-04-15T18:58:29.003', 'Id': '23826'},47281:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $L = \\{ &lt;M&gt; | M$ halts on every input $x$ in at most $200 * |x|$ steps $\\}$. </p>\n\n<p>Is $L$ decidable? Recognizable?</p>\n\n<p>Given that membership in $L$ asserts something about $M$'s behavior on an infinite set of strings, it seems extremely unlikely to me that $L$ could be either. I have shown that co-$L$ is Turing-recognizable (I think): you can make an enumerator that tests each $M_1, M_2, \\dots, $ for each $s_1, s_2, \\dots$ and emits $M$ if it does not accept some $s$ in at most $200|x|$ steps.</p>\n\n<p>Since co-$L$ is recognizable, either $L$ is not recognizable, or it is decidable. I can't imagine that $L$ is decidable. However, it definitely cannot be reduced to the halting problem, nor can Rice's theorem be applied to it (since the quality in question is the quality of halting in a particular number of steps, being able to decide it doesn't let us decide other arbitrary properties).</p>\n\n<p>It seems to me that the best way to go will be to show that $L$ lets me recognize something that is unrecognizable, since the only problems it solves are ones which require me to run over infinite sets of strings. But I can't think of what this could be. I thought that maybe co-HALT would work, but I can't ever prove that a TM will never halt on some input.</p>\n\n<p>I'm stuck. What direction should I go in?</p>\n", 'ViewCount': '38', 'Title': 'Deciding the set of all Turing machines that halt in at most $k|x|$ steps $\\forall x \\in \\Sigma^*$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-16T12:31:22.373', 'LastEditDate': '2014-04-16T12:31:22.373', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16612', 'Tags': '<computability><turing-machines><undecidability><decision-problem>', 'CreationDate': '2014-04-16T09:25:10.423', 'Id': '23849'},47282:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to find out accept, loop and reject in this Turing Machine because it doesnt have any...I am not sure if I completely understand it but this is the turing machine I am talking about...</p>\n\n<p><img src="http://i.stack.imgur.com/UADRo.png" alt="enter image description here"></p>\n\n<p>so accept state would be --> <code>Accept(T2) - all words with a a</code><br>\n                      loop state would be --> <code>Loop (T2) - /\\</code></p>\n\n<p>reject state would be --> <code>Reject(T2) - Strings with b</code></p>\n\n<p>am I on a right track ? how could I do find accept, loop and reject on this TM? thanks!</p>\n', 'ViewCount': '49', 'ClosedDate': '2014-04-29T23:37:40.617', 'Title': 'How to find out what are accept, loop and reject in this Turing Machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-17T08:21:46.130', 'LastEditDate': '2014-04-17T08:21:46.130', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<terminology><turing-machines>', 'CreationDate': '2014-04-16T17:40:29.290', 'Id': '23861'},47283:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was searching through google and I couldn't find anything</p>\n\n<p>Can a post machine have more than one accepting state ?</p>\n\n<p>Yes or No ? </p>\n", 'ViewCount': '19', 'Title': 'can a post machine have more than one accepting state?', 'LastActivityDate': '2014-04-17T22:38:09.460', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23899', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15179', 'Tags': '<turing-machines>', 'CreationDate': '2014-04-17T21:04:03.517', 'Id': '23895'},47284:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to construct a deterministic multi-tape turing machine for the following language in order to show that $L$ is in $DTIME(n)$:</p>\n\n<p>$$L = \\{ www \\mid w \\in \\{a,b\\}^+ \\}$$</p>\n\n<p>I'm not sure how to get started. Any hints would be appreciated.</p>\n", 'ViewCount': '24', 'Title': 'Deterministic Multi-tape Turing Machine construction', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-19T06:59:45.943', 'LastEditDate': '2014-04-19T06:59:45.943', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23929', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10423', 'Tags': '<turing-machines><complexity-classes>', 'CreationDate': '2014-04-19T04:35:44.833', 'Id': '23928'},47285:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '123', 'Title': 'Can a Multi-Tape Turing Machine have an infinite number of tapes?', 'LastEditDate': '2014-04-23T05:59:30.583', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16915', 'FavoriteCount': '1', 'Body': u"<p>So if k is the number of tapes, is a multi-tape Turing machine allowed to have k = \u221e tapes.</p>\n\n<p>I'd assume not since this would give an infinite transition function?</p>\n", 'Tags': '<turing-machines><machine-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-23T05:59:30.583', 'CommentCount': '2', 'AcceptedAnswerId': '23948', 'CreationDate': '2014-04-19T17:43:23.410', 'Id': '23936'},47286:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In my textbook, enumeration machines are defined as possessing a special write-only output tape, which they can write characters to, but not move the head of. When they hit the print state, the string on the output tape is enumerated and reset to a blank tape.</p>\n\n<p>Is this equivalent to the model of enumeration machines where they have just one tape, the contents of which is enumerated (but not cleared) whenever they hit the print state? One direction seems easy, but I'm not sure how to prove you wouldn't need the extra tape.</p>\n", 'ViewCount': '17', 'Title': 'Alternate definitions of enumeration machines', 'LastActivityDate': '2014-04-21T15:02:52.847', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23991', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15627', 'Tags': '<turing-machines><enumeration>', 'CreationDate': '2014-04-20T23:37:23.767', 'Id': '23971'},47287:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider a Turing Machine $M$ that decides the following language: $$A_{\\text{NFA}} = \\{ \\langle N,w \\rangle  | N\\text{ is an NFA and }N\\text{ accepts }w \\}.$$\nBased on its input size, if $M$ wants to accept a string, it should accept it within a limited number of steps else it would reject it. What is this bound/limit? </p>\n', 'ViewCount': '28', 'ClosedDate': '2014-04-23T16:49:56.880', 'Title': 'Maximum number of configurations on a TM that decides the language $A_\\text{NFA}$', 'LastActivityDate': '2014-04-22T14:01:44.283', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'user292139', 'PostTypeId': '1', 'OwnerUserId': '14412', 'Tags': '<complexity-theory><turing-machines>', 'CreationDate': '2014-04-22T00:30:56.160', 'Id': '24024'},47288:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>You have a Turing machine that only processes input on the form $0^*$. If it is given an input without 0's, it will simply halt without accepting or do anything else. Is it Turing Complete?</p>\n\n<p>The set $0^*$ is countably infinite, since you can make the bijective function $f(x) : 0^* \u2192 \\mathbb{N} $:</p>\n\n<p>$f(x) = length(x)$</p>\n\n<p>Where $length(x)$ is the length of the string (so you treat them as Peano Numbers). </p>\n\n<p>I understand that the set of all programs (the programs that a Turing machine can run) are countable, and that the set of a Turing machines are also countable. But, can the set of string that the Turing machine can process (with no guarantees of halting) only be countably infinite (as in this case), or does it have to be uncountable? </p>\n\n<p>My understanding of undecidable problems with regards to Turing machines is that they arise because there are languages that have a cardinality strictly greater than the natural numbers, e.g. $B^*$, where $B = \\{0,1\\}$, which has a cardinality equal to the real numbers. It seems to me that, although you can encode any integer with the language $0^*$, you can't encode an arbitrary language. The problem is: how can you encode recursively enumerable languages when all you have is unary notation? If this is indeed impossible (though I have a feeling it is possible; I can't see how the representation of numbers should be a fundamental hindrance), then it turns out that this particular Turing machine is <em>not</em> Turing Complete (or maybe you would say that it is not really a Turing machine). </p>\n", 'ViewCount': '71', 'Title': 'Is a Turing Machine that only takes strings of the form $0^*$ Turing Complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-26T16:01:25.943', 'LastEditDate': '2014-04-26T16:01:25.943', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24128', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11089', 'Tags': '<turing-machines><turing-completeness><machine-models>', 'CreationDate': '2014-04-26T11:11:45.313', 'Id': '24125'},47289:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The question is whether this is recursive or not. I first thought that it wasn\'t but then I read this question which seems similar and is recursive.</p>\n\n<p><a href="http://cs.stackexchange.com/questions/3119/is-it-decidable-whether-a-tm-reaches-some-position-on-the-tape">Is it decidable whether a TM reaches some position on the tape?</a></p>\n\n<p>I think it\'s a slightly different question though (?) and so I have tried to show that it isn\'t recursive by reduction from the halting problem. </p>\n\n<p>Ignore the below if it is recursive!</p>\n\n<p>So for an instance  of the Halting problem we can use 2 tape TM M\' as follows:</p>\n\n<p>on input (code(M)code(x)) to M\'</p>\n\n<ul>\n<li>M\' copies code(x) to tape 2 </li>\n<li>M\' simulates M on tape 2</li>\n<li>If M halts on the input x then......</li>\n</ul>\n\n<p>I am not really sure what to do now. I thought that I could get M\' to only enter a certain cell if M halts on x and then use this to show that if we could decide the problem above then we could decide the Halting problem (by seeing if M\' enters that particular cell)</p>\n\n<p>But I am not sure what cell I can use to guarantee that it won\'t have already been entered? The two tape thing is kind of confusing me -do I need to pick a cell that won\'t be entered on either tape 1 or tape 2?</p>\n\n<p>Any help appreciated!</p>\n', 'ViewCount': '14', 'Title': 'Does the head of TM M ever move into cell x when processing Input I?', 'LastActivityDate': '2014-04-27T21:17:58.543', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17058', 'Tags': '<turing-machines><decision-problem><halting-problem>', 'CreationDate': '2014-04-27T21:17:58.543', 'Id': '24157'},47290:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How would I go about making a Turing machine to accept the following language L?</p>\n\n<p>$$L = \\{ www \\mid w = \\{0,1\\}^* \\text{ and } w &gt; 0\\}$$</p>\n\n<p>I was thinking counting the number of symbols in the input string and then dividing by three to find the beginning of each instance of <em>w</em> and then testing if each instance is the same, but this seems a bit roundabout. </p>\n\n<p>I feel like there is a way by marking the first three symbols and then moving the 2nd and 3rd markers until the strings in between them are the same but I'm having a hard time articulating this into an algorithm.</p>\n\n<p>Can anyone point me in the right direction?</p>\n", 'ViewCount': '45', 'Title': 'Turing machine with repeated strings', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T10:19:18.573', 'LastEditDate': '2014-04-29T10:19:18.573', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24214', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14950', 'Tags': '<formal-languages><turing-machines><automata><strings>', 'CreationDate': '2014-04-28T13:35:58.237', 'Id': '24184'},47291:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I can't understand what my professor wrote about these inclusions concerning deterministic classes:</p>\n\n<p>$$\nDTIME(f) \\subseteq DSPACE(f) \\subseteq \\sum_{c\\in\\Bbb N}DTIME(2^{c(log+f)})  \n$$</p>\n\n<p>I understood the first inclusion:</p>\n\n<blockquote>\n  <p>The Turing Machine needs to do at least one step in order to check the\n  next cell on tape</p>\n</blockquote>\n\n<p>I didn't get the second one:</p>\n\n<blockquote>\n  <p>The number of configurations of the Turing Machine with fixed space is finite, and the computation must stop within a maximum number of steps equal to these settings, otherwise wewould have a cycle.</p>\n</blockquote>\n\n<p>I don't understand the argument of the summation: why that $2$ and that $c(log+f)$?\nWhy is it written like that?</p>\n", 'ViewCount': '78', 'Title': 'Inclusion of complexity classes (Deterministic Turing Machine)', 'LastActivityDate': '2014-04-28T17:47:37.320', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '24192', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17046', 'Tags': '<turing-machines><time-complexity><space-complexity><complexity-classes>', 'CreationDate': '2014-04-28T15:51:17.557', 'Id': '24185'},47292:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In computer science it is often assumed that a human mind can be reduced to a Turing machine.  This is the assumption that underlies the field of artificial intelligence.</p>\n\n<p>However, it is an assumption, one that has neither been proven or disproven.</p>\n\n<p>Is there any kind of test within our current capabilities where we can prove/disprove this assumption?</p>\n\n<p>If not, is there any evidence that would suggest one way or another?</p>\n\n<p>Here is a similar question I asked awhile back on theoretical computer science:</p>\n\n<p><a href="http://cstheory.stackexchange.com/questions/3170/human-intelligence-and-algorithms">http://cstheory.stackexchange.com/questions/3170/human-intelligence-and-algorithms</a></p>\n', 'ViewCount': '91', 'Title': 'What would show a human mind is/is not reducible to a Turing machine?', 'LastEditorUserId': '17264', 'LastActivityDate': '2014-05-02T00:42:43.470', 'LastEditDate': '2014-05-02T00:12:58.680', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17264', 'Tags': '<turing-machines><artificial-intelligence><computer-vs-human>', 'CreationDate': '2014-05-01T23:52:31.677', 'FavoriteCount': '1', 'Id': '24312'}