{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '893', 'Title': 'Universality of the Toffoli gate', 'LastEditDate': '2012-04-15T18:16:37.757', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '1', 'Body': '<p>Regarding the quantum <a href="https://en.wikipedia.org/wiki/Toffoli_gate" rel="nofollow">Toffoli gate</a>:</p>\n\n<ol>\n<li>is it <em>classicaly</em> universal, and if so, why?</li>\n<li>is it <em>quantumly</em> universal, and why?</li>\n</ol>\n', 'Tags': '<quantum-computing><circuits><turing-completeness>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-15T18:16:37.757', 'CommentCount': '8', 'AcceptedAnswerId': '345', 'CreationDate': '2012-03-13T06:22:59.583', 'Id': '289'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1652', 'Title': 'Are there minimum criteria for a programming language being Turing complete?', 'LastEditDate': '2012-04-15T18:17:23.073', 'AnswerCount': '5', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '385', 'FavoriteCount': '6', 'Body': '<p>Does there exist a set of programming language constructs in a programming language in order for it to be considered Turing Complete?</p>\n\n<p>From what I can tell from <a href="http://en.wikipedia.org/wiki/Turing_completeness">wikipedia</a>, the language needs to support recursion, or, seemingly, must be able to run without halting. Is this all there is to it?</p>\n', 'Tags': '<computability><programming-languages><turing-machines><turing-completeness>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-19T19:43:12.440', 'CommentCount': '3', 'AcceptedAnswerId': '995', 'CreationDate': '2012-04-02T13:40:03.487', 'Id': '991'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '321', 'Title': 'What is required for universal analogue computation?', 'LastEditDate': '2012-04-15T22:27:58.790', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1101', 'FavoriteCount': '1', 'Body': '<p>What operations need to be performed in order to do any arbitrary <a href="http://en.wikipedia.org/wiki/Analog_computer" rel="nofollow">analogue computation</a>? Would addition, subtraction, multiplication and division be sufficient?</p>\n\n<p>Also, does anyone know exactly what problems are tractable using analogue computation, but not with digital?</p>\n', 'Tags': '<computability><computation-models><turing-completeness>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-25T12:25:53.527', 'CommentCount': '10', 'AcceptedAnswerId': '1293', 'CreationDate': '2012-04-15T15:04:06.820', 'Id': '1292'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '219', 'Title': 'Does High Order Functions provide more power to Functional Programming?', 'LastEditDate': '2012-06-06T12:46:42.487', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1763', 'FavoriteCount': '1', 'Body': '<p><em>I\'ve asked a similar question <a href="http://cstheory.stackexchange.com/questions/11652/does-high-order-functions-provide-more-power-to-functional-programming">on cstheory.SE</a>.</em></p>\n\n<p>According to <a href="http://stackoverflow.com/a/1990580/209629">this answer on Stackoverflow</a> there is an algorithm that on a non-lazy pure functional programming language has an $\\Omega(n \\log n)$ complexity, while the same algorithm in imperative programming is $\\Omega(n)$. Adding lazyness to the FP language would make the algorithm $\\Omega(n)$.</p>\n\n<p>Is there any equivalent relationship comparing a FP language with and without High Order Functions? Is it still Turing Complete? If it is, does the lack of High Order on FP makes the language less "powerful" or efficient? </p>\n', 'Tags': '<complexity-theory><lambda-calculus><functional-programming><turing-completeness>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-06T12:56:27.090', 'CommentCount': '2', 'AcceptedAnswerId': '2241', 'CreationDate': '2012-06-06T01:10:04.083', 'Id': '2240'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are devices that do not allow users to load any application they want on it, only run a limited class of applications approved by the device vendor.</p>\n\n<p>Take an iPhone as an example where new applications are loaded (solely) from app-store and programs that would allow execution of arbitrary code by user (without permission of Apple) are not permitted (e.g. Flash).</p>\n\n<p>Are such machines where users cannot execute arbitrary code on themselves still Turing-complete computers? Can they still be considered as <em>universal Turing machines</em>?</p>\n', 'ViewCount': '247', 'Title': 'Is a device with restrictive execution policies Turing-complete?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-06-08T08:29:20.493', 'LastEditDate': '2012-06-07T21:42:34.033', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1770', 'Tags': '<computability><turing-completeness>', 'CreationDate': '2012-06-06T20:06:25.773', 'FavoriteCount': '1', 'Id': '2243'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '183', 'Title': 'What are the minimum requirements for a language to be considered Turing Complete?', 'LastEditDate': '2012-06-25T01:54:29.010', 'AnswerCount': '3', 'Score': '3', 'OwnerDisplayName': 'Dabloons', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/991/are-there-minimum-criteria-for-a-programming-language-being-turing-complete">Are there minimum criteria for a programming language being Turing complete?</a>  </p>\n</blockquote>\n\n\n\n<p>I overheard a conversation on the topic and the conclusion that one gent came to was that in order to be Turing complete, given one has infinite storage, all one needs is a conditional control structure and a jump instruction. </p>\n\n<p>Is this true? </p>\n\n<p>If it is true, and Turing completeness requires that the language that is Turing complete be able to simulate every instruction available in another Turing complete language, how do those two simple elements achieve that?</p>\n', 'ClosedDate': '2012-06-25T03:19:29.510', 'Tags': '<computability><programming-languages><turing-completeness>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-25T01:54:29.010', 'CommentCount': '6', 'CreationDate': '2012-06-21T13:40:11.397', 'Id': '2476'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '717', 'Title': 'How is the rule 110 Turing complete?', 'LastEditDate': '2012-09-30T00:59:44.817', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Pureferret', 'PostTypeId': '1', 'OwnerUserId': '2952', 'FavoriteCount': '3', 'Body': '<p>I\'ve read the wikipedia page for <a href="http://en.wikipedia.org/wiki/Rule_110" rel="nofollow">rule 110</a> in cellular automata, and I more or less know how they work (a set of rules decides where to draw the next 1 or 0).</p>\n\n<p>I\'ve just read they\'re Turing complete, but I can\'t even fathom how would you  \'program\' in \'rule 110\'? </p>\n', 'Tags': '<computability><automata><turing-completeness><cellular-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-09-30T00:59:44.817', 'CommentCount': '11', 'CreationDate': '2012-09-21T23:44:56.810', 'Id': '4779'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Turing completness is being typically proved via reduction to already proved Turing-complete machine.</p>\n\n<p>Can the same be obtained by showing, that the machine in question is capable of generating arbitrary output \u2013 if proper input is given?</p>\n', 'ViewCount': '60', 'Title': 'To prove Turing-completeness, is it enough to prove capability of producing arbitrary output?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T14:19:01.157', 'LastEditDate': '2012-11-01T14:19:01.157', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6416', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4418', 'Tags': '<simulation><turing-completeness>', 'CreationDate': '2012-11-01T03:53:49.950', 'Id': '6414'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '122', 'Title': 'Looking for some more details on "Turing" devices', 'LastEditDate': '2012-12-20T05:57:30.353', 'AnswerCount': '3', 'Score': '0', 'OwnerDisplayName': 'Steel City Hacker', 'PostTypeId': '1', 'OwnerUserId': '5132', 'Body': "<p>I've been reading a lot of computer science literature in the recent past but haven't ran across an explanation of Turing machines, the different types, and why they seem to come up so often (I understand they are a sort of a basis for CS topics).  </p>\n\n<p>I've also seen comments by some members mentioning turing-completeness (Particularly when dealing with programming languages) and was just looking for some clarification.  </p>\n\n<p>I did search around before posting this and haven't been able to find a similar post or a website that describes this in terms that I have been able to understand or decipher.  Thanks.  </p>\n", 'Tags': '<terminology><turing-machines><computation-models><turing-completeness>', 'LastEditorUserId': '3094', 'LastActivityDate': '2012-12-20T05:57:30.353', 'CommentCount': '3', 'AcceptedAnswerId': '7520', 'CreationDate': '2012-12-19T15:33:23.660', 'Id': '7512'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The Halting problem is a natural undecidable language which is complete for the set of recursivly enumrable sets. I am interested in undecidable but not Turing-complete language such that we can not reduce the Halting problem to it.</p>\n\n<p>What is the most <strong>natural</strong> undecidable RE problem which is not Turing-complete?</p>\n', 'ViewCount': '112', 'Title': 'Natural RE undecidable problems but not Turing-complete', 'LastEditorUserId': '96', 'LastActivityDate': '2013-03-23T13:31:59.690', 'LastEditDate': '2013-03-23T13:31:59.690', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<computability><turing-completeness>', 'CreationDate': '2013-02-14T14:45:21.160', 'FavoriteCount': '1', 'Id': '9772'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I encountered the brainfuck programming language which I know is turing complete. However I then decided to create a high level language that gets compiled to brainfuck code.</p>\n\n<p>There is only one data type in it (integer, since that's the only data type brainfuck supports). It supports functions and subroutines (to which you can pass integers by value, but not arrays, though you can access an array in the global scope from within a function/subroutine) but it does not support recursion (all function and subroutine calls are inlined). It supports statically allocated arrays (size known at compile time) and has just one unbounded stack. You can store as many items as you like in the stack, unlike with arrays, but you only have one stack for your entire program.</p>\n\n<p>I have these limitations to achieve a balance between ease of use, and fast generated code.</p>\n\n<p>However, I never studied any of this stuff and I actually started this project to learn about compilers (by making one), therefore my question is:</p>\n\n<p>From the above description, is this language turing complete?</p>\n", 'ViewCount': '75', 'Title': 'Turing completeness', 'LastActivityDate': '2013-04-18T20:49:41.243', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '11381', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7438', 'Tags': '<programming-languages><turing-completeness>', 'CreationDate': '2013-04-18T13:21:44.780', 'Id': '11380'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Is it possible to write a universal loop program for if-then &amp; loop programs and it is possible to write a universal while program for while programs?</p>\n\n<p><hr>\nLong version and some background:</p>\n\n<p>Before anyone asks, YES, it is a homework and I am not here to find an answer, but only clues to help me get this question right !</p>\n\n<p>I\'ll translate the question from French :</p>\n\n<blockquote>\n  <p>We call a <strong>universal program</strong> (also called interpreter) a program that\n  accepts, as an input, another program and simulates it to produce the\n  output of this simulated program. A universal program can also be used\n  to simulate programs written in this very same language or in another\n  language.</p>\n  \n  <p>You can suppose, using G\xf6del\'s coding, that the program to be\n  simulated is given to the universal program in the register r1, and\n  the input on which this program but be simulated in the register r2.\n  The coding of the program could simply give out the characters of the\n  program to be simulated in a table as well as its input registers in\n  another table.</p>\n  \n  <p>Answer the following questions:</p>\n  \n  <p>a. It is possible to write a universal <strong>loop program</strong> for <strong>if-then\n  programs</strong>?</p>\n  \n  <p>b. Is it possible to write a universal <strong>loop program</strong> for <strong>loop\n  programs</strong>?</p>\n  \n  <p>c. Is it possible to write a universal <strong>while program</strong> for <strong>while\n  programs</strong>? To reach a satisfying answer/proof lever, you could use\n  the Church-Turing thesis.</p>\n</blockquote>\n\n<p>Now the question, is where do I start with this ? My head\'s going in every direction at the same time, I\'m just going crazy.</p>\n\n<p>NOTES :</p>\n\n<p><strong>if-then programs</strong> are defined like this :</p>\n\n<p>We consider a if-then program to be defined like a loop program, excepted that there are no loops, but an instruction "if rj then []" (rj is the register "rj", the j\'th register)</p>\n\n<p>I know for sure this has something to do with imbricated loops...</p>\n\n<p>Any clues would be greatly appreciated !</p>\n\n<p>Thanks a lot</p>\n', 'ViewCount': '62', 'Title': 'Is it possible to write a universal loop program for if-then & loop programs and it is possible to write a universal while program for while progra', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-18T20:31:25.733', 'LastEditDate': '2013-06-18T20:31:25.733', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8737', 'Tags': '<turing-completeness><loops>', 'CreationDate': '2013-06-18T18:00:34.487', 'Id': '12744'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://en.wikipedia.org/wiki/Tag_system" rel="nofollow">Tag systems</a> are Turing-complete. I was wondering if there is any easy way to create tag systems that simulate finite automata. So create tag systems that recognize languages, e.g. by having at the end just one output symbol "A" for accepting the initial input or "R" for rejecting it.</p>\n\n<p>I guess a solution would be to make a Tag system simulate a specific Turing machine that simulates a finite automaton but that seems too much and too complicated. Is there perhaps a direct way from tag systems to finite automata?</p>\n', 'ViewCount': '67', 'Title': 'Make a tag system simulate a finite automaton?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:35:42.117', 'LastEditDate': '2013-08-22T14:35:42.117', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '927', 'Tags': '<computability><finite-automata><simulation><computation-models><turing-completeness>', 'CreationDate': '2013-08-19T03:42:11.630', 'FavoriteCount': '1', 'Id': '13808'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a language is decidable, we can write a method that always halts and returns <code>true</code> for each string that is an element of the language and <code>false</code> otherwise.</p>\n\n<p>If a language is undecidable, what does that mean? Does it mean:</p>\n\n<p>a.) We cannot write a method; we cannot even conceive of a method.</p>\n\n<p>b.) We can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely.</p>\n\n<p>c.) Other (what?)</p>\n', 'ViewCount': '111', 'Title': 'Can a method be written if the language is undecidable?', 'LastActivityDate': '2013-09-21T17:08:19.787', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '14501', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<formal-grammars><undecidability><decision-problem><halting-problem><turing-completeness>', 'CreationDate': '2013-09-21T16:43:09.593', 'Id': '14499'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$L = \\{ \\langle M \\rangle \\mid \\text{there is at least one input string on which the \\(M\\) does not halt} \\}$</p>\n\n<p>Here, for a Turing machine $M$, the notation $\\langle M \\rangle$ denotes an encoding, over some alphabet, of the code of the Turing machine. To which of the following language classes does $L$ belong?</p>\n\n<ol>\n<li>Regular.</li>\n<li>Context-free but not Regular.</li>\n<li>Recursive but not Context-free.</li>\n<li>Recursively enumerable but not recursive.</li>\n<li>Not recursively enumerable.</li>\n</ol>\n', 'ViewCount': '145', 'Title': 'Class of the language of Turing machines that loop on at least one input', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-26T10:10:34.713', 'LastEditDate': '2013-09-26T10:10:34.713', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<regular-languages><turing-machines><turing-completeness>', 'CreationDate': '2013-09-26T02:21:15.667', 'FavoriteCount': '1', 'Id': '14615'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm a bit confused about these concepts. As far as I understand, something is Turing complete when it can simulate a Turing machine. And there is this thing called a Universal Turing machine which is universal because it can simulate a Turing machine. Which to me, implies there are Turing machines that are not universal and cannot simulate a Turing machine. Does this mean non-universal Turing machines are not Turing complete?</p>\n\n<p>Could anyone clarify this concepts for me?</p>\n", 'ViewCount': '352', 'Title': 'Does a Universal Turing Machine have more computational power than a non-universal one?', 'LastActivityDate': '2013-10-02T23:56:29.753', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '14692', 'Score': '3', 'OwnerDisplayName': 'jsoldi', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<turing-completeness>', 'CreationDate': '2013-09-30T03:49:59.717', 'FavoriteCount': '1', 'Id': '14691'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m thinking this should be just one or two things, since lambda calculus is so tiny and still Turing complete.</p>\n\n<p>Probably just recursion (something like "MY_QUERY(param) = select * from param UNION MY_QUERY(DO_SOMETHING_WITH(param))"). But I don\'t see how I could define aggregate functions with this.</p>\n\n<p>Any idea?</p>\n', 'ViewCount': '59', 'Title': 'Smallest set of features that would make relational algebra Turing complete', 'LastActivityDate': '2013-09-30T05:24:28.267', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<turing-completeness><relational-algebra>', 'CreationDate': '2013-09-30T05:24:28.267', 'Id': '14694'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have seen web sites that purport to "prove" that HTML5+CSS is Turing Complete.</p>\n\n<p>I have seen web sites that purport to "prove" that SQL is Turing Complete.</p>\n\n<p>I have seen a bunch of web sites that purport to "explain" what it means to be Turing Complete.</p>\n\n<p>Enough!</p>\n\n<p>Where can I find a book (written by an expert in computability theory) or a peer-reviewed article (in a reputable journal) that shows a proof of, "This language XYZ is capable of describing a computational machine which has the same computational power as a Turing Machine"?</p>\n', 'ViewCount': '315', 'Title': 'Clear, complete, proof that a language is Turing Compete?', 'LastActivityDate': '2013-09-30T17:12:59.010', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><automata><turing-completeness><church-turing-thesis>', 'CreationDate': '2013-09-30T11:35:37.607', 'FavoriteCount': '1', 'Id': '14697'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I didn\'t know how to ask this question before but now that I\'m reading about typed lambda calculus I think I\'ve got a better idea. </p>\n\n<p>There is <a href="http://stackoverflow.com/a/5239256/1219414">this answer</a> to a question asking whether CSS is Turing complete or not (note that this question is NOT about CSS at all), which I consider is not (at least in certain way, and this "certain" is what my question below is about), even if you can simulate <a href="http://en.wikipedia.org/wiki/Rule_110" rel="nofollow">Rule 110</a> with it, which is proven to be Turing complete. My intuition behind it is that only an insignificant subset of what CSS can output can be the result of a calculation. You cannot perform any calculation on colors or sizes to be set to element\'s styles.</p>\n\n<p>Now I found an even simpler example while reading about typed lambda calculus. <a href="http://www.cis.upenn.edu/~bcpierce/sf/Stlc.html#lab565" rel="nofollow">This article\'s overview</a> describes a lambda calculus that can use booleans. I noticed that, in addition to the untyped lambda calculus operations, there is the conditional operation (<code>if t1 then t2 else t3</code>), which makes perfect sense. Without this, you wouldn\'t be able to do anything with booleans, and I would go ahead and say is really not Turing complete, or at least that is Turing complete but only in a trivial way. </p>\n\n<p>So my question is, if this typed lambda calculus with booleans wouldn\'t have that conditional operator, would you say is Turing complete? If not, why not, and if yes, how would you express the fact that you cannot do any operation at all on it\'s main type of data which is what you\'d expect from any Turing complete language in a categorical, technical way such that is clear that the Turing completeness of the language is really meaningless? </p>\n\n<p>The reason why I\'m giving so much importance to this is because I was recently trying to create a small Turing complete language myself and while doing it, got to a point in which my language was Turing complete but only in this trivial way (wasn\'t as obvious as the boolean lambda calculus without conditionals above, though). If I would have asked "Is this language Turing complete?" I would have probably got "Yes" as an answer and I would\'ve think I\'m done creating my language. But I really was not. And when asking myself why am I still working on my language, I\'d like to be able to state exactly what is that my language is missing.</p>\n', 'ViewCount': '120', 'Title': 'How do you say when a language is Turing-complete only in a trivial way?', 'LastEditorUserId': '10401', 'LastActivityDate': '2013-10-05T00:52:29.057', 'LastEditDate': '2013-10-04T16:04:29.620', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14820', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><turing-completeness>', 'CreationDate': '2013-10-04T15:59:18.787', 'Id': '14814'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a bit of a weird question, but I was wondering earlier if <a href="http://en.wikipedia.org/wiki/QR_code" rel="nofollow">QR codes</a> are Turing-complete when interpreted as initial states for Conway\'s Game of Life.</p>\n\n<p>My intuition is "yes", as there are infinitely many QR codes (they just get bigger as you add more information), and the Game of Life itself is Turing-complete. However, it\'s not inconceivable that the restrictions imposed by the QR code format mean that <em>no</em> QR codes are Turing-complete.</p>\n\n<p>Another way to phrase the question would be <strong>"can all Turing machines be encoded as a string which, when converted into a QR code and used as the initial state for Conway\'s Game of Life, produces equivalent output to the original Turing machine"</strong></p>\n', 'ViewCount': '63', 'Title': "Are QR codes Turing-complete under the rules of Conway's Game of Life?", 'LastEditorUserId': '140', 'LastActivityDate': '2013-10-05T00:30:42.537', 'LastEditDate': '2013-10-05T00:30:42.537', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10512', 'Tags': '<turing-completeness>', 'CreationDate': '2013-10-05T00:16:11.657', 'Id': '14819'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is well known that in Descriptive Complexity Theory FO is equivalent to AC0.</p>\n\n<p>However, this accepts a couple of a theory and a string <code>&lt;T,s&gt;</code> iff the interpretation of s as a query is satisfied by the theory T.</p>\n\n<p>My question now is if there is an interpretation of which is stronger than AC0. For example, is there an interpretation of s as a theory so that the formalism accepts if s is a theory that is logically entailed by T. This problem is undecidable, but maybe it is possible to express problems in it which are stronger than AC0. (Reachability would be an interesting example if anyone could make this work)</p>\n', 'ViewCount': '61', 'Title': 'On the Turing Completeness of First Order Logic', 'LastActivityDate': '2013-11-20T11:53:17.923', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '11502', 'Tags': '<complexity-theory><logic><turing-completeness><first-order-logic>', 'CreationDate': '2013-11-20T11:53:17.923', 'FavoriteCount': '1', 'Id': '18197'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am interested in simulating any turing machine with a turing machine that is allowed only to move right. I guess that it should be pretty standard material and likely it is trivial (or known to be false). Does anyone have a pointer to a reference?</p>\n', 'ViewCount': '103', 'Title': 'Right moving turing machine', 'LastActivityDate': '2013-12-05T10:46:40.527', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18640', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10931', 'Tags': '<turing-machines><simulation><turing-completeness>', 'CreationDate': '2013-12-05T10:21:15.477', 'Id': '18639'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Say I have Simply typed lambda calculus, and add an assignment rule:</p>\n\n<pre><code>&lt;identifier&gt; : &lt;type&gt; = &lt;abstraction&gt;\n</code></pre>\n\n<p>Where <code>&lt;identifier&gt;</code> is the name of the function, <code>&lt;type&gt;</code> is the function type and <code>&lt;abstraction&gt;</code> is the abstraction to be assigned to the identifier. </p>\n\n<p>Then I add a typing rule that says that when you see an assignment such as the above, you use a temporary type context, in which the declared type (the one in <code>&lt;identifier&gt; : &lt;type&gt;</code>) is associated with the identifier, to type check <code>&lt;abstraction&gt;</code> and then make sure the declared type equals the abstraction\'s type.</p>\n\n<p>And finally I add another rule that would let me have a list of assignments on top of a lambda term which is the one I\'d evaluate, such that all these assignments would be added to the global scope before the term is evaluated.</p>\n\n<p>Seems to me that this alone would make it Turing complete since I\'d be able to do stuff like:</p>\n\n<pre><code>stackoverflow: NUM -&gt; NUM = \u03bbn:NUM.(stackoverflow n)\n(stackoverflow 0)\n</code></pre>\n\n<p>And at the same time, everything I can define in this language would be "well typed" in the sense that it wouldn\'t be able to define infinite types (I wouldn\'t be able to define the Y combinator).</p>\n\n<p>So my questions are, is this really Turing complete? And, am I missing something when I say everything would be "well typed" (like for instance, I could define the Y combinator in a way I haven\'t yet realized or is there any gotcha in this type system)?</p>\n', 'ViewCount': '63', 'Title': 'Would adding recursive named functions to Simply typed lambda calculus make it Turing complete?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-22T17:08:16.207', 'LastEditDate': '2013-12-22T17:08:16.207', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19193', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><recursion><type-theory><turing-completeness><typing>', 'CreationDate': '2013-12-22T05:19:44.457', 'Id': '19187'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '126', 'Title': 'What makes PROLOG Turing-complete?', 'LastEditDate': '2014-01-09T09:14:38.860', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8415', 'FavoriteCount': '0', 'Body': u'<p>I know that it can be proven PROLOG is Turing-complete by constructing a program that simulates a Turing machine like this:</p>\n\n<pre><code>turing(Tape0, Tape) :-\n    perform(q0, [], Ls, Tape0, Rs),\n    reverse(Ls, Ls1),\n    append(Ls1, Rs, Tape).\n\nperform(qf, Ls, Ls, Rs, Rs) :- !.\nperform(Q0, Ls0, Ls, Rs0, Rs) :-\n    symbol(Rs0, Sym, RsRest),\n    once(rule(Q0, Sym, Q1, NewSym, Action)),\n    action(Action, Ls0, Ls1, [NewSym|RsRest], Rs1),\n    perform(Q1, Ls1, Ls, Rs1, Rs).\n\nsymbol([], b, []).\nsymbol([Sym|Rs], Sym, Rs).\n\naction(left, Ls0, Ls, Rs0, Rs) :- left(Ls0, Ls, Rs0, Rs).\naction(stay, Ls, Ls, Rs, Rs).\naction(right, Ls0, [Sym|Ls0], [Sym|Rs], Rs).\n\nleft([], [], Rs0, [b|Rs0]).\nleft([L|Ls], Ls, Rs, [L|Rs]).\n</code></pre>\n\n<p><a href="http://en.wikipedia.org/wiki/Prolog#Turing_completeness" rel="nofollow">Source</a></p>\n\n<p>However, I\u2019m wondering which parts of the PROLOG language one could strip away (esp. function symbols, clause overloading, recursion, unification) without losing Turing completeness. Are function symbols themselves Turing complete?</p>\n', 'Tags': '<programming-languages><turing-completeness><logic-programming><prolog>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-09T09:14:38.860', 'CommentCount': '3', 'AcceptedAnswerId': '19593', 'CreationDate': '2014-01-09T01:16:39.903', 'Id': '19591'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://tex.stackexchange.com/questions/128454/are-there-any-open-research-problems-in-the-world-of-tex/153131?noredirect=1#comment289410_128464">A comment over on tex.SE</a> made me wonder. The statement is essentially:</p>\n\n<blockquote>\n  <p>If I can write a compiler for language X in language X, then X is Turing-complete.</p>\n</blockquote>\n\n<p>In computability and formal languages terms, this is:</p>\n\n<blockquote>\n  <p>If $M$ decides $L \\subseteq L_{\\mathrm{TM}}$ and $\\langle M \\rangle \\in L$, then $F_L = \\mathrm{RE}$.</p>\n</blockquote>\n\n<p>Here $L_{\\mathrm{TM}}$ denotes the language of all Turing machine encodings and $F_L$ denotes the set of functions computed by machines in $L$.</p>\n\n<p>Is this true?</p>\n', 'ViewCount': '502', 'Title': 'Is any language that can express its own compiler Turing-complete?', 'LastActivityDate': '2014-01-12T14:57:59.980', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19669', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<computability><turing-completeness>', 'CreationDate': '2014-01-12T14:00:59.437', 'Id': '19667'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The term "Turing completeness" has been discussed in several of the Computer Science classes that I\'ve taken. However, I\'ve never gotten an intuitive feel for what Turing completeness actually requires. I found <a href="http://cs.stackexchange.com/questions/991/are-there-minimum-criteria-for-a-programming-language-being-turing-complete">this</a> question, but the answers are a bit more mathematical than what I am looking for.</p>\n\n<p>Take a common programming language, such as C++, Python, Java or Lisp. How close are these languages to being not Turing complete? Do these languages have elementary features that if removed would make the language not Turing complete? Or could you change a property of the language (for example, making something random) and by doing that make the language not Turing complete?</p>\n', 'ViewCount': '104', 'Title': 'How close are common programming languages to not being Turing complete?', 'LastActivityDate': '2014-01-13T01:39:02.397', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19679', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12780', 'Tags': '<programming-languages><turing-completeness>', 'CreationDate': '2014-01-12T18:33:07.127', 'Id': '19676'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is it possible to simulate a regular Turing Machine with a TM with the following specs?</p>\n\n<ol>\n<li>There are two heads, one of which can read, one of which can write</li>\n<li>Both heads can only move right</li>\n<li>When a head reads (or it writes) it moves right</li>\n</ol>\n\n<p>I know it's possible to simulate a TM that only moves right. But, is it possible to simulate the left moves as well?</p>\n", 'ViewCount': '85', 'Title': 'Simulating a TM with a 2-head, right moving TM', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-22T13:52:53.880', 'LastEditDate': '2014-01-22T09:25:11.160', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19889', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<turing-machines><turing-completeness><simulation>', 'CreationDate': '2014-01-22T01:08:02.397', 'Id': '19885'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In proofs of decidability, we often want to simulate another model of computation by a Turing machine. But if I can simulate a $\\mathsf{DFA}$ by, say, a C program, then is there some result which says that the $\\mathsf{DFA}$ can be simulated by some $\\mathsf{TM}$? Could a program be used in place of a $\\mathsf{TM}$ in a proof of decidability?</p>\n\n<p>I know that Java being Turing-complete would mean that it can simulate any $\\mathsf{TM}$, so this is sort of the reverse of Turing-completeness I guess.</p>\n', 'ViewCount': '117', 'Title': 'If a DFA can be simulated by a real program, can it be simulated by a TM', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-30T11:36:35.010', 'LastEditDate': '2014-03-29T21:15:13.643', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '23230', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<computability><simulation><turing-completeness>', 'CreationDate': '2014-03-29T19:26:11.393', 'Id': '23228'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>You have a Turing machine that only processes input on the form $0^*$. If it is given an input without 0's, it will simply halt without accepting or do anything else. Is it Turing Complete?</p>\n\n<p>The set $0^*$ is countably infinite, since you can make the bijective function $f(x) : 0^* \u2192 \\mathbb{N} $:</p>\n\n<p>$f(x) = length(x)$</p>\n\n<p>Where $length(x)$ is the length of the string (so you treat them as Peano Numbers). </p>\n\n<p>I understand that the set of all programs (the programs that a Turing machine can run) are countable, and that the set of a Turing machines are also countable. But, can the set of string that the Turing machine can process (with no guarantees of halting) only be countably infinite (as in this case), or does it have to be uncountable? </p>\n\n<p>My understanding of undecidable problems with regards to Turing machines is that they arise because there are languages that have a cardinality strictly greater than the natural numbers, e.g. $B^*$, where $B = \\{0,1\\}$, which has a cardinality equal to the real numbers. It seems to me that, although you can encode any integer with the language $0^*$, you can't encode an arbitrary language. The problem is: how can you encode recursively enumerable languages when all you have is unary notation? If this is indeed impossible (though I have a feeling it is possible; I can't see how the representation of numbers should be a fundamental hindrance), then it turns out that this particular Turing machine is <em>not</em> Turing Complete (or maybe you would say that it is not really a Turing machine). </p>\n", 'ViewCount': '71', 'Title': 'Is a Turing Machine that only takes strings of the form $0^*$ Turing Complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-26T16:01:25.943', 'LastEditDate': '2014-04-26T16:01:25.943', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24128', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11089', 'Tags': '<turing-machines><turing-completeness><machine-models>', 'CreationDate': '2014-04-26T11:11:45.313', 'Id': '24125'}