{'ViewCount': '461', 'Title': 'Solving the recurrence relation $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$', 'LastEditDate': '2012-07-31T20:30:24.733', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '778', 'FavoriteCount': '1', 'Body': '<p>Solving the recurrence relation $T(n) = 2T(\\lfloor n/2 \\rfloor) + n$.<br>\nThe book from which this example is, falsely claims that $T(n) = O(n)$ by guessing $T(n) \\leq cn$ and then arguing  </p>\n\n<p>$\\qquad \\begin{align*} T(n) &amp; \\leq 2(c \\lfloor n/2 \\rfloor ) + n \\\\ &amp;\\leq cn +n \\\\ &amp;=O(n) \\quad \\quad \\quad \\longleftarrow \\text{ wrong!!} \\end{align*}$  </p>\n\n<p>since $c$ is constant.The error is that we have not proved the <em>exact</em> form of the inductive hypothesis.</p>\n\n<p>Above I have exactly quoted what the book says. Now my question is why cannot we write $cn+n=dn$ where $d=c+1$ and now we have $T(n) \\leq dn$ and hence $T(n) = O(n)$?</p>\n\n<p>Note: </p>\n\n<ol>\n<li>The correct answer is $T(n) =O(n \\log n).$  </li>\n<li>The book I am referring here is <em>Introduction to algorithms</em> by Cormen et al., page 86, 3rd edition.</li>\n</ol>\n', 'Tags': '<proof-techniques><asymptotics><recurrence-relation><landau-notation><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-01T07:09:01.457', 'CommentCount': '1', 'AcceptedAnswerId': '2972', 'CreationDate': '2012-07-31T18:15:32.510', 'Id': '2971''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I see <strong>structural induction</strong> the usual way for proving an algorithm's <strong>termination</strong> property, but it's not that easy to prove by means of induction on a <strong>tree</strong> algorithm. Now I am struggling on proving that the pre-order tree traversal algorithm is terminable:</p>\n\n<pre><code>preorder(node)\n  if node == null then return\n  visit(node)\n  preorder(node.left) \n  preorder(node.right)\n</code></pre>\n\n<p>How should I prove?</p>\n", 'ViewCount': '220', 'Title': 'How to prove that the pre-order tree traversal algorithm terminates?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-26T20:14:24.327', 'LastEditDate': '2012-09-26T20:14:24.327', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4726', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2954', 'Tags': '<algorithms><data-structures><algorithm-analysis><correctness-proof><induction>', 'CreationDate': '2012-09-24T15:52:44.860', 'Id': '4719''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>In my Computing Theory course, a lot of our problems involve using induction on the length of the input string to prove statements about finite automata.  I understand mathematical induction, however when strings come into play I get real tripped up.  I\'d really appreciate it if someone would go through the process of making such a proof step by step.</p>\n\n<p>Here\'s an example problem (Exercise 2.2.10 from Hopcroft and Ullman 3rd Edition):</p>\n\n<blockquote>\n  <p>Consider the DFA with the following transition table:</p>\n\n<pre>\n        0    1\n       ________\n-> A |  A    B\n  *B |  B    A\n</pre>\n  \n  <p>Informally describe the language accepted by this DFA, and prove by induction on the length of an input string that your description is correct.</p>\n</blockquote>\n\n<p>This is an answered problem in the book, so I\'m not looking for someone to do my homework.  I just need someone to explain it to me straight.</p>\n\n<p><strong>Book\'s Answer:</strong>\n(taken from <a href="http://infolab.stanford.edu/~ullman/ialcsols/sol2.html" rel="nofollow">here</a>)</p>\n\n<blockquote>\n  <p>The automaton tells whether the number of 1\'s seen is even (state A) or odd (state B), accepting in the latter case. It is an easy induction on |w| to show that dh(A,w) = A if and only if w has an even number of 1\'s.\n  Basis: |w| = 0. Then w, the empty string surely has an even number of 1\'s, namely zero 1\'s, and \u03b4-hat(A,w) = A.</p>\n  \n  <p>Induction: Assume the statement for strings shorter than w. Then w = za, where a is either 0 or 1.</p>\n  \n  <ul>\n  <li><p><strong>Case 1:</strong> a = 0. If w has an even number of 1\'s, so does z. By the inductive hypothesis, \u03b4-hat(A,z) = A. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then so does z. By the inductive hypothesis, \u03b4-hat(A,z) = B, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  <li><p><strong>Case 2:</strong> a = 1. If w has an even number of 1\'s, then z has an odd number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = B. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then z has an even number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = A, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case as well, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  </ul>\n</blockquote>\n\n<p>I understand how to prove things like $\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}$ using induction.  I\'m just confused by how this works with building strings.  I\'m confused by the bolded parts.  I don\'t understand how they are come up with/how it actually proves what is accepted/how it is inductive.</p>\n\n<p>\u03b4-hat is the extended transition function, by the way.</p>\n', 'ViewCount': '1544', 'Title': 'How do I write a proof using induction on the length of the input string?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T17:30:34.120', 'LastEditDate': '2014-02-02T17:30:34.120', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4907', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3082', 'Tags': '<automata><finite-automata><proof-techniques><reference-question><induction>', 'CreationDate': '2012-10-06T19:00:18.360', 'Id': '4905''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '335', 'Title': 'Do "inductively" and "recursively" have very similar meanings?', 'LastEditDate': '2012-10-23T12:39:08.900', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '336', 'FavoriteCount': '1', 'Body': '<p>Do "inductively" and "recursively" mean very similar?</p>\n\n<p>For example, if there is an algorithm that determines a n-dim vector by determine its first k+1 components based on its first k components having been determined, and is initialized with the first component, would you call it works recursively or inductively? I have been using "recursively", but today someone said it "inductively".</p>\n', 'Tags': '<algorithms><terminology><recursion><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T15:56:33.453', 'CommentCount': '7', 'AcceptedAnswerId': '6551', 'CreationDate': '2012-10-23T02:13:50.443', 'Id': '6247''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm in a first year discrete math course and we started algorithms. I created a recursive algorithm to multiply two numbers together:</p>\n\n<pre><code>function multiply($n, $r) {\n    if($n == 1)\n return $r;\n    else if($r == 1)\n return $n;\n    else\n        return $r + multiply($n - 1, $r);\n}\n</code></pre>\n\n<p>How do I prove my algorithm is correct?</p>\n\n<p>A quick google search tells me I have to prove that it works for $n + 1$ and I have to prove that it terminates. Unfortunately I'm still incredibly new to this and haven't the faintest clue as to where to start for proving my algorithm correct, so I would really appreciate some help here. I think maybe I have to do some sort of proof by induction but as this is an algorithm, I wouldn't know where to start.</p>\n", 'ViewCount': '643', 'Title': 'Prove correctness of recursive multiplication algorithm', 'LastEditorUserId': '755', 'LastActivityDate': '2013-08-31T05:56:55.600', 'LastEditDate': '2013-08-31T05:56:55.600', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4359', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><induction>', 'CreationDate': '2012-10-25T15:37:15.703', 'Id': '6311''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>The intervals are represented as two numbers, e.g. $(4.3, 5.6)$. The intervals are unique. </p>\n\n<p>If for $(x,y)$ and $(u,v)$, $x\u2264u$ and $v\u2264y$, $(u,v)$ is nested in $(x,y)$</p>\n\n<p>How do I find out which intervals are nested in others efficiently?</p>\n\n<p>The hint is to use two induction hypotheses: one to assume you can solve the problem for $n-1$ intervals, another that you can find the largest right endpoint for the $n-1$ intervals.</p>\n\n<p>How do I use this information to do the inductive step in constant time?</p>\n', 'ViewCount': '507', 'Title': 'Finding nested intervals efficiently', 'LastEditorUserId': '2826', 'LastActivityDate': '2012-12-24T18:41:15.210', 'LastEditDate': '2012-12-02T06:12:43.807', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '7104', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2826', 'Tags': '<algorithms><induction>', 'CreationDate': '2012-12-01T09:02:33.200', 'Id': '7073''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '44', 'Title': 'How i can use Mathematical induction to prove CFG production?', 'LastEditDate': '2013-01-28T10:23:01.200', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'M.B', 'PostTypeId': '1', 'OwnerUserId': '6594', 'Body': '<p>If I have production $G_n$</p>\n\n<blockquote>\n  <p>$S \\rightarrow A_i b_i \\quad$ for $1 \\le i \\le n$</p>\n  \n  <p>$A_i \\rightarrow a_j A_i \\mid a_j\\quad$   for $1 \\le i$ and $i \\ne j$</p>\n</blockquote>\n\n<ol>\n<li>Prove $G_n$ is sub-productions from $2n^2 - n$</li>\n<li>Prove $G_n$ is $LR(0)$ production from $2^n + n^2 + n$</li>\n</ol>\n', 'ClosedDate': '2013-04-14T19:11:20.580', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T10:23:01.200', 'CommentCount': '5', 'CreationDate': '2013-01-27T17:06:45.810', 'Id': '9230''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I am reading Algorithm design manual by Skiena. It gives proof of Insertion sort by Induction. I am giving the proof described in the below.</p>\n\n<blockquote>\n  <p>Consider the correctness of insertion sort, which we introduced at the beginning of this chapter. The reason it is correct can be shown inductively:</p>\n  \n  <ol>\n  <li>The basis case consists of a single element, and by definition a\n  one-element array is completely sorted.</li>\n  <li>In general, we can assume that the first n \u2212 1 elements of array A\n  are completely sorted after n \u2212 1 iterations of insertion sort.</li>\n  <li>To insert one last element x to A, we find where it goes, namely the\n  unique spot between the biggest element less than or equal to x and\n  the smallest element greater than x. This is done by moving all the\n  greater elements back by one position, creating room for x in the\n  desired location.</li>\n  </ol>\n</blockquote>\n\n<p>I do not understand paragraph #3. Could someone please explain it to me with an example?</p>\n', 'ViewCount': '368', 'Title': 'Insertion sort Proof by Induction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-02T22:48:42.980', 'LastEditDate': '2013-06-02T22:48:42.980', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8496', 'Tags': '<algorithms><algorithm-analysis><sorting><correctness-proof><induction>', 'CreationDate': '2013-06-02T16:03:58.043', 'Id': '12434''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am trying to prove by induction  the following theorem:\nUse Induction to prove the following fact: for every integer, $N\\ge  1$ , a BST with $N$ nodes must have at least $\\log( N + 1)$ levels.\nI've proved the base case but I am struggling to figure out how to apply induction to prove for the $K+1$ case. Any suggestions would be wonderful.</p>\n", 'ViewCount': '49', 'Title': 'Proving that a BST with N>=1 nodes will have log(N+1) levels', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-11T16:27:11.647', 'LastEditDate': '2013-06-11T16:27:11.647', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8624', 'Tags': '<graph-theory><data-structures><binary-trees><induction>', 'CreationDate': '2013-06-11T16:18:32.680', 'Id': '12622''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I met the problem </p>\n\n<blockquote>\n  <p>Show that the solution to $T(n) = 2T(\\lfloor n/2\\rfloor + 17) + n$ is $O(n \\log n)$</p>\n</blockquote>\n\n<p>while reading Introduction to Algorithm. It's a question about the substitution method for solving recurrences.</p>\n\n<p>Should I just assume $T(n/2 + 17) \\leq O((n/2 + 17) \\log(n/2 + 17))$ and then prove $T(n) \\leq O(n \\log n)$? Is this inductive assumption enough to solve it?</p>\n", 'ViewCount': '122', 'ClosedDate': '2013-09-16T08:55:38.767', 'Title': 'How to prove the asymptotic upper bound for $T(n) = 2T(\\lfloor n/2\\rfloor + 17) + n$ is $O(n \\log n)$?', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-06-27T18:45:56.293', 'LastEditDate': '2013-06-27T18:45:56.293', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8838', 'Tags': '<asymptotics><recurrence-relation><induction><divide-and-conquer>', 'CreationDate': '2013-06-24T14:43:28.910', 'Id': '12865''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm studying for the computer science GRE, and as an exercise I need to provide a recursive algorithm to compute Fibonacci numbers and show its correctness by mathematical induction.</p>\n\n<p>Here is my recursive version of an algorithm to compute Fibonacci numbers:</p>\n\n<pre><code>Fibonacci(n):\n    if n = 0 then     // base case\n        return 0\n    elseif n = 1 then // base case\n        return 1\n    else\n        return Fibonacci(n - 1) + Fibonacci(n - 2)\n    endif\n</code></pre>\n\n<p>How can I prove the correctness of this algorithm by induction?</p>\n", 'ViewCount': '1036', 'Title': 'Prove correctness of recursive Fibonacci algorithm, using proof by induction', 'LastEditorUserId': '755', 'LastActivityDate': '2013-08-31T10:28:41.523', 'LastEditDate': '2013-08-31T05:55:13.280', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9744', 'Tags': '<algorithms><algorithm-analysis><correctness-proof><induction>', 'CreationDate': '2013-08-29T18:27:55.383', 'FavoriteCount': '1', 'Id': '14025''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>Let L be language of balanced parentheses.</p>\n\n<p>(a) Prove If there are equal number of ('s and )'s and every prefix of w contains at least as many ('s as )'s, then w is in L.</p>\n\n<p>(b) Prove If w is in L, then there are equal number of ('s and )'s and every prefix of w contains at least as many ('s as )'s.</p>\n\n<p>After much thought, I don't seek what I'm supposed to be doing. All I know is that I'm supposed to be using induction.</p>\n\n<p>Here is the grammar that generates L: $S\\to SS|(S)|\\epsilon$</p>\n", 'ViewCount': '320', 'Title': 'Language of balanced parentheses; Biconditional proof about parentheses', 'LastEditorUserId': '9819', 'LastActivityDate': '2013-09-23T20:10:26.890', 'LastEditDate': '2013-09-23T20:10:26.890', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<formal-languages><context-free><induction>', 'CreationDate': '2013-09-23T16:09:40.090', 'Id': '14557''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I recently was introduced to solving recurrence bounds by substitution but there's something i don't understand about it.</p>\n\n<p>In standard induction proofs you prove a base case, assume it holds for n then show it holds for n+1 and therefore show it applies to integers larger than the base case.</p>\n\n<p>For when you solve recurrences like T(n) = T(n/2) the proof has a base, assumes T(n/2) then proves it holds for T(n). Does this proof not only hold for the numbers that are multiples of two of the base cases? Would this not require an infinitely large number of base cases to show what it holds for?</p>\n\n<p>Could someone please explain this to me?</p>\n", 'ViewCount': '108', 'Title': 'How to apply the substitution method to n/2?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T09:04:11.990', 'LastEditDate': '2014-01-20T08:51:55.257', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Shawn', 'PostTypeId': '1', 'Tags': '<proof-techniques><recurrence-relation><induction>', 'CreationDate': '2014-01-20T03:23:36.953', 'Id': '19840''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '61', 'Title': 'Induction proof, base case not working but induction step works?', 'LastEditDate': '2014-02-13T05:24:32.683', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Body': '<p>$1+3+5+...+(2n+3)=n^2+4n$</p>\n\n<p>For this series using induction proof. </p>\n\n<p>Base case 1,2,3,.. not working. But induction step works well. </p>\n\n<p>Base case is not given in question.</p>\n', 'ClosedDate': '2014-02-17T09:15:23.240', 'Tags': '<proof-techniques><induction>', 'LastEditorUserId': '947', 'LastActivityDate': '2014-02-13T10:01:41.927', 'CommentCount': '5', 'AcceptedAnswerId': '21595', 'CreationDate': '2014-02-13T05:11:15.257', 'Id': '21593''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>This is a problem from 'Concrete Abstractions' which is available free on the web[1]. It's a book similar to SICP. The problem:</p>\n\n<blockquote>\n  <p>Exercise 2.16\n     Consider the following procedure foo:</p>\n</blockquote>\n\n<pre><code>(define foo\n  (lambda (x n)\n    (if (= n 0)\n        1\n        (+ (expt x n) (foo x (- n 1))))))\n</code></pre>\n\n<blockquote>\n  <p>Use induction to prove that <code>(foo x n)</code> terminates with the value\n          $$\\frac{x^{n + 1} - 1 } {x - 1}$$</p>\n  \n  <p>for all values of x != 1 and for all integers n >= 0. You may assume that <code>expt</code> works\n     correctly, (i.e., <code>(expt b m)</code> returns $b^m$). Hint: The inductive step will involve some algebra.</p>\n</blockquote>\n\n<p>I've watched a video on induction on Khan Academy and read the induction material in the book, but I can't connect the dots to solve this problem.</p>\n\n<p>Edit:\nI am stuck at the Inductive step. My work:\nBase Case:</p>\n\n<pre><code>(foo x 0)\n(if (= n 0)\n    1)\n</code></pre>\n\n<p>returns $1$ and</p>\n\n<p>$\\frac{x^{0+1} - 1} {x - 1} = \\frac{x - 1}{x - 1} = 1$</p>\n\n<p>So for the inductive hypothesis: Assume <code>(foo x k)</code> terminates in $\\frac{x^{k+1} - 1}{x - 1}$ for all $k \\geq 0$. Then for $k+1$:\nI essentially add $k+1$ for the assumed formula above, so:\n$\\frac{x^{k+1} - 1}{x - 1} + k+1$. What I get is a long equation that I have no idea what to do with. </p>\n", 'ViewCount': '42', 'Title': 'Mathematical Induction Problem from Concrete Abstractions', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-14T00:05:59.630', 'LastEditDate': '2014-03-14T00:05:50.737', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22597', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15659', 'Tags': '<induction><lisp>', 'CreationDate': '2014-03-13T19:50:23.880', 'Id': '22596''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I have a few small questions about section 2.4 ("Rule induction") in <a href="https://www.cs.cmu.edu/~rwh/plbook/book.pdf" rel="nofollow">Practical Foundations for Programming Languages</a> (p. 19).</p>\n\n<p>(1) In the rule induction principles for <code>nat</code>,</p>\n\n<blockquote>\n  <p>To show P(a nat) whenever a nat, it is enough to show:\n  (1) P(zero nat).\n  (2) for every a, if (a nat and) P(a nat), then P(succ(a) nat).</p>\n</blockquote>\n\n<p>why is the bracketed "(<em>a</em> <code>nat</code> and)" clause necessary (and similarly for <code>tree</code>)?  This seems "natural" - we shouldn\'t need to prove things about syntactic entities that don\'t define <code>nat</code>s - but doesn\'t appear in the definition given of property <em>P</em> "respecting the rules" defining <code>nat</code>/<code>tree</code> (also on p. 19), which is how the rule induction principle is defined.  In the proof of Lemma 2.1, the extra "<em>a</em> nat and" part has become part of the definition of the property <em>P</em> - what\'s going on here?</p>\n\n<p>(2) I don\'t understand the induction step of Lemma 2.1 (<code>succ(a) nat</code> implies <code>a nat</code>).  If I were doing this proof, I\'d just invert the rules for <code>nat</code> right away, or, using Harper\'s property <em>P</em>, say: If <code>succ(a)</code> is of form <code>succ(b)</code>, then by injectivity, <code>a</code> equals <code>b</code>, hence <code>b nat</code> as <code>a nat</code>, but injectivity hasn\'t been proven yet.  It seems instead that Harper applies the induction hypothesis about <code>a</code> directly to <code>succ(a)</code> - I must be missing something.</p>\n\n<p>(3) In a more naive framework, Lemma 2.3 would just follow from sufficiency of the <code>= nat</code> relation rules ("inversion"), but I don\'t know how to write down a proof in this style.  Why is induction even needed?</p>\n\n<p>I\'m sorry if these questions seem like nitpicking, but Martin-L\xf6f/LF feels very foreign to me.  If I squint and pretend I\'m doing everything in a more "traditional" operational semantics, I can read other parts of the book (with slightly different proofs), but I feel I\'m missing the point in doing so.</p>\n\n<p>If these questions are too tedious to answer individually, are there other references on doing semantics in this style?</p>\n', 'ViewCount': '47', 'Title': "Rule induction principles in Harper's PFPL", 'LastEditorUserId': '15757', 'LastActivityDate': '2014-03-21T16:34:29.187', 'LastEditDate': '2014-03-21T16:34:29.187', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15757', 'Tags': '<type-theory><semantics><induction><operational-semantics>', 'CreationDate': '2014-03-17T03:10:30.117', 'Id': '22690''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have this context-free grammar and I want to find out whether its language is finite or infinite.</p>\n\n<pre><code>S -&gt; XY|bb  Step 1\nX -&gt; XY|SS  Step 2\nY -&gt; XY|SS  Step 3\n</code></pre>\n\n<p>So I would do</p>\n\n<pre><code>S -&gt; XY            From step 1\nS -&gt; YYY           From step 2\nS -&gt; SSYY          From step 3\nS -&gt; SSSSY         From step 3\nS -&gt; SSSSSS        From step 3\nS -&gt; bbSSSSS       From step 1\nS -&gt; bbbbSSS       From step 1\nS -&gt; bbbbbbSSS     From step 1\nS -&gt; bbbbbbbbSS    From step 1\nS -&gt; bbbbbbbbbbS   From step 1\nS -&gt; bbbbbbbbbbbb  From step 1\n\nbbbbbbbbbbbb \n</code></pre>\n\n<p>So I know how to generate words like this but how to find out whether the language is finite or infinite?</p>\n', 'ViewCount': '159', 'Title': "How to find whether a grammar's language is finite or infinite?", 'LastEditorUserId': '8321', 'LastActivityDate': '2014-04-03T14:05:21.387', 'LastEditDate': '2014-04-03T09:22:59.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23368', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><induction>', 'CreationDate': '2014-04-02T20:30:27.960', 'Id': '23367''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>i posted this on mathematics stack exchange <a href="http://math.stackexchange.com/questions/772617/induction-proof-for-kleene-star">here</a> before i realised this one existed.</p>\n\n<p>i am going through some past exam paper questions on regular languages for some revision, and i am having a bit of trouble with converting general ideas into formal mathematical proofs.</p>\n\n<p>the question is: <strong>given regular expression $S$, prove formally that $S^* = (S^*)^*$</strong></p>\n\n<p><strike>intuitively i can tell that because $S^*$ is an infinite set, then concatenating any number of elements from that infinite set, to that same infinite set, still yields an infinite set of the same size; ie. anything that is in $(S^*)^*)$ must also be in $S^*$.</strike></p>\n\n<p>(EDIT: thanks to David Richerby for pointing out this is wrong)</p>\n\n<p>my problem is expressing this in a formal proof. here is what i have worked through so far (it is a bit all over the place and just a collection of ways to express the problem mostly)</p>\n\n<p>$S^* = (S^*)^*$</p>\n\n<p>this implies:</p>\n\n<p>$S^* \\subseteq (S^*)^*$ <strong>and</strong> $S^* \\supseteq (S^*)^*$</p>\n\n<p>if we assume that there exists $w_k$ such that $w_k \\in S^*$</p>\n\n<p>then the base case for the proof is:</p>\n\n<p>$k = 0$   $(w_k = \\epsilon)$ (empty word, always in $S^*$ and $(S^*)^*$ by definition)</p>\n\n<p>$k = 1$   $(w_k \\in S^*)$</p>\n\n<p>and that\'s kind of where my ability to reason ends.</p>\n\n<p>i think the rest of it will be something like:</p>\n\n<p>$w_{k+1} = w_kx$</p>\n\n<p>ie. $w_k$ concatenated with $x$ where $x \\in S^*$</p>\n\n<p>but how can i show that $w_{k+1} \\in (S^*)^*$</p>\n\n<p>any help to push me in the right direction would be greatly appreciated..</p>\n', 'ViewCount': '52', 'Title': 'induction proof for kleene star', 'LastEditorUserId': '17142', 'LastActivityDate': '2014-04-29T06:05:16.453', 'LastEditDate': '2014-04-29T06:05:16.453', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17142', 'Tags': '<regular-languages><proof-techniques><induction>', 'CreationDate': '2014-04-28T11:28:50.607', 'Id': '24182''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}