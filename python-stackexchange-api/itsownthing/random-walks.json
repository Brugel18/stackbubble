{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I prove that the cover time for a directed graph G can be exponential in the size of G?</p>\n', 'ViewCount': '161', 'Title': 'Prove: cover time for directed graph is exponential', 'LastEditorUserId': '472', 'LastActivityDate': '2013-01-27T02:51:16.120', 'LastEditDate': '2013-01-27T02:51:16.120', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1402', 'Tags': '<algorithms><graph-theory><random-walks>', 'CreationDate': '2012-06-22T12:29:32.200', 'Id': '2449'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to derive the <a href="http://alexandria.tue.nl/repository/freearticles/597601.pdf">classic paper</a> in the title only by elementary means (no generating functions, no complex analysis, no Fourier analysis) although with much less precision. In short, I "only" want to prove that the average height $h_n$ of a tree with $n$ nodes (that is, the maximum number of nodes from the root to a leaf) satisfies $h_n \\sim \\sqrt{\\pi n}$.</p>\n\n<p>The outline is as follows. Let $A_{nh}$ be the number of trees with height less than or equal to $h$ (with the convention $A_{nh} = A_{nn}$ for all $h \\geqslant n$) and $B_{nh}$ the number of trees of $n$ nodes with height greater than or equal to $h+1$ (that is, $B_{nh} = A_{nn} - A_{nh}$). Then $h_n = S_n/A_{nn}$, where $S_n$ is the finite sum\n$$\nS_n = \\sum_{h \\geqslant 1} h(A_{nh} - A_{n,h-1}) = \\sum_{h \\geqslant 1} h(B_{n,h-1} - B_{nh}) = \\sum_{h \\geqslant 0} B_{nh}.\n$$\nIt is well known that $A_{nn} = \\frac{1}{n}\\binom{2n-2}{n-1}$, for the set of general trees with $n$ nodes is in bijection with the set of binary trees with $n-1$ nodes, counted by the Catalan numbers.</p>\n\n<p>Therefore, the first step is to find $B_{nh}$ and then the main term in the asymptotic expansion of $S_n$.</p>\n\n<p>At this point the authors use analytical combinatorics (three pages) to derive\n$$\nB_{n+1,h-1} = \\sum_{k \\geqslant 1} \\left[\\binom{2n}{n+1-kh} - 2\\binom{2n}{n-kh} + \\binom{2n}{n-1-kh}\\right].\n$$</p>\n\n<blockquote>\n  <p>My own attempt is as follows. I consider the bijection between trees with $n$ nodes\n  and monotonic paths on a square grid $(n-1) \\times (n-1)$ from $(0,0)$ to $(n-1,n-1)$ which do not cross the diagonal (and are made of two kinds of steps: $\\uparrow$ and $\\rightarrow$). These paths are sometimes called <em>Dyck paths</em> or <em>excursions</em>. I can express now $B_{nh}$ in terms of lattice paths: it is the number of Dyck paths of length 2(n-1) and height greater than or equal to $h$. (Note: a tree of height $h$ is in bijection with a Dyck path of height $h-1$.)</p>\n  \n  <p>Without loss of generality, I assume that they start with $\\uparrow$ (hence stay above the diagonal). For each path, I consider the first step crossing the line $y = x + h - 1$, if any. From the point above, all the way back to the origin, I change $\\uparrow$ into $\\rightarrow$ and vice versa (this is a <em>reflection</em> wrt the line $y=x+h$). It becomes apparent that the paths I want to count ($B_{nh}$) are in bijection with the monotonic paths from $(-h,h)$ to $(n-1,n-1)$ which avoid the boundaries $y=x+2h+1$ and $y=x-1$. (See <a href="http://www.filedropper.com/lattice">figure</a>.)</p>\n</blockquote>\n\n<p>In the classic book <em>Lattice Path Counting and Applications</em> by Mohanty (1979, page 6) the formula\n$$\n\\sum_{k \\in \\mathbb{Z}} \\left[\\binom{m+n}{m-k(t+s)} - \\binom{m+n}{n+k(t+s)+t}\\right],\n$$\ncounts the number of monotonic paths in a lattice from $(0,0)$ to $(m,n)$, which avoid the boundaries $y = x - t$ and $y = x + s$, with $t &gt; 0$ and $s &gt; 0$. (This result was first established by Russian statisticians in the 50s.) Therefore, by considering a new origin at $(-h,h)$, we satisfy the conditions of the formula: $s=1$, $t=2h+1$ and the destination point (the upper right corner) is now $(n+h-1,n-h-1)$. Then\n$$\nB_{nh} = \\sum_{k \\in \\mathbb{Z}} \\left[\\binom{2n-2}{n+h-1-k(2h+2)} - \\binom{2n-2}{n-h-1+k(2h+2) + 2h+1}\\right].\n$$\nThis can be simplified in\n$$\nB_{n+1,h-1} = \\sum_{k \\in \\mathbb{Z}} \\left[\\binom{2n}{n+1-(2k+1)h} - \\binom{2n}{n-(2k+1)h}\\right],\n$$\nwhich, in turn, is equivalent to\n$$\nB_{n+1,h-1} = \\sum_{k \\geqslant 0} \\left[\\binom{2n}{n+1-(2k+1)h} - 2\\binom{2n}{n-(2k+1)h} + \\binom{2n}{n-1-(2k+1)h}\\right].\n$$\nThe difference with the expected formula is that I sum over the odd numbers ($2k+1$), instead of all positive integers ($k$).</p>\n\n<p>Any idea where the problem is?</p>\n', 'ViewCount': '202', 'Title': 'On "The Average Height of Planted Plane Trees" by Knuth, de Bruijn and Rice (1972)', 'LastEditorUserId': '2993', 'LastActivityDate': '2012-09-30T09:32:05.513', 'LastEditDate': '2012-09-30T09:32:05.513', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2993', 'Tags': '<combinatorics><discrete-mathematics><trees><average-case><random-walks>', 'CreationDate': '2012-09-28T12:20:51.920', 'Id': '4777'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assume that we are given a real life graph, DBLP network in my case, where degree distribution of nodes follows a power law (many nodes have 1, 2 neighbors, and only a few nodes have hundreds of neighbors).</p>\n\n<p>A random walk ends when it returns to the initial node or when the walk takes 3 steps.\nIf we start random walks from each node on this graph, should we start equal number of walks from each node? If so, nodes with small degrees will often return to where they started, and we will not learn big portions of the network. This is because small degree nodes are neighbors of small degree nodes more often, so there will not be many paths to walk on.</p>\n\n<p>I believe there should be a way to decide on the number of walks to minimize computational costs. </p>\n', 'ViewCount': '174', 'Title': 'How many random walks to start from each node?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-22T03:31:55.453', 'LastEditDate': '2012-11-22T03:31:55.453', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4649', 'Tags': '<graph-theory><graphs><probability-theory><random-walks>', 'CreationDate': '2012-11-19T06:40:05.413', 'FavoriteCount': '1', 'Id': '6758'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $P$ be a transition matrix of a random walk in an undirected <strong>(may not regular)</strong> graph $G$. Let $\\pi$ be a distribution on $V(G)$. The Shannon entropy of $\\pi$ is defined by </p>\n\n<p>$$H(\\pi)=-\\sum_{v \\in V(G)}\\pi_v\\cdot\\log(\\pi_v).$$</p>\n\n<p>How do we prove that $H(P\\pi)\\ge H(\\pi)$ ?</p>\n', 'ViewCount': '79', 'Title': 'Increasing entropy of random walk', 'LastEditorUserId': '4706', 'LastActivityDate': '2012-11-24T10:17:50.253', 'LastEditDate': '2012-11-24T10:17:50.253', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6862', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4706', 'Tags': '<entropy><random-walks>', 'CreationDate': '2012-11-23T17:39:47.947', 'Id': '6859'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Technical question: is there any open source program/code/library which can compute (minimal) conductance of a given graph, probably by some simulated annealing?</p>\n\n<p>Think it is quite well-known problem, but I cannot find anything like I mentioned above, but maybe you guys know? I know that it is a NP-hard task, but anyway, probably someone has written some programs.</p>\n', 'ViewCount': '82', 'Title': 'Graph conductance - program/code/library', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-03T22:28:30.283', 'LastEditDate': '2013-06-03T22:28:30.283', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Wojtek', 'PostTypeId': '1', 'Tags': '<graph-theory><random-walks>', 'CreationDate': '2012-12-08T16:29:39.240', 'Id': '7268'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G$ be a $d$-regular expander graph. What is the electrical resistance of $G$? Is it a constant independent of the number of nodes $n$ once $d$ is large enough? If not, can we give matching upper and lower bounds in terms of $n,d$?</p>\n', 'ViewCount': '63', 'Title': 'Electrical resistance of expander graphs', 'LastActivityDate': '2013-07-08T04:58:52.567', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '13155', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9070', 'Tags': '<graph-theory><random-walks><expanders>', 'CreationDate': '2013-07-07T17:14:21.943', 'FavoriteCount': '1', 'Id': '13137'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>consider a program that generates a <a href="http://en.wikipedia.org/wiki/Random_walk" rel="nofollow">random walk</a> using a <a href="http://en.wikipedia.org/wiki/Pseudorandom_number_generator" rel="nofollow">PRNG</a>, as in following pseudocode. it uses <a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" rel="nofollow">arbitrary precision arithmetic</a> such that there is no limit on variable values (ie no overflow).</p>\n\n<pre><code>srand(x)\nz = 0\nwhile (z &gt;= 0)\n{\n  r = rand(100)\n  if (r &lt;= 50) z -= 1\n  else z += 1\n}\n</code></pre>\n\n<p>the PRNG is inited with seed <code>x</code> <em>(also arbitrary precision).</em> the PRNG <code>rand(100)</code> generates a value between <code>0..99</code>. hence for 51 values the accumulator var <code>z</code> is decremented, for 49 values it is incremented.</p>\n\n<p>it is expected due to the <a href="http://en.wikipedia.org/wiki/Law_of_large_numbers" rel="nofollow">law of large numbers</a> that this program will halt for all initial seeds <code>x</code>. however, </p>\n\n<blockquote>\n  <p>how does one prove it will halt for all initial seeds <code>x</code>?</p>\n</blockquote>\n\n<p>it seems such a proof must depend on the details of the construction of the PRNG. am assuming there exist PRNGs such that a different random sequence is generated for every initial seed <code>x</code> (ie the infinite set of naturals). that in itself may be up for question. are such PRNGs known? where are they used? etc.. so an answer may come up with an arbitrary PRNG for the purposes of the question. a single example fulfilling the criteria would be an acceptable answer.</p>\n\n<p>looking for related literature, similar problems/proof considered, etc.</p>\n', 'ViewCount': '58', 'Title': 'proof of convergence in arbitrary precision PRNGs', 'LastActivityDate': '2013-11-19T00:38:41.127', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '699', 'Tags': '<algorithms><reference-request><probability-theory><pseudo-random-generators><random-walks>', 'CreationDate': '2013-11-18T21:52:05.343', 'FavoriteCount': '1', 'Id': '18132'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '137', 'Title': 'Quantum algorithms and quantum computation', 'LastEditDate': '2014-04-04T12:48:55.663', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16266', 'FavoriteCount': '3', 'Body': "<p>Is my (very high-level) understanding correct here regarding quantum algorithms &mdash;</p>\n\n<p>Quantum computers can process a massive amount of operations in parallel to the nature of qubits and their ability to have states that are superpositions of $|0\\rangle$ and $|1\\rangle$.</p>\n\n<p>Yet when we measure the qubits all the possible states collapse into a single state of either $|0\\rangle$ or $|1\\rangle$, which seems to negate the potential benefits of parallel operations. All we really know are the probabilities that the states will end up as.</p>\n\n<p>However, we can exploit quantum properties to increase the probability that we end up with a certain result. I believe Shor's algorithm is based on exploiting quantum properties too, although I'm not sure in what way?</p>\n\n<p><em>e.g.</em> in a quantum walk, quantum interference means the walk spreads faster than a classical random walk and hence can out-perform classical walks.</p>\n\n<p>That is my very high level understanding of what is going on with quantum algorithms. Am I correct, 'sort-of' correct, or way-off? Can someone clarify my understanding?</p>\n", 'Tags': '<quantum-computing><random-walks>', 'LastEditorUserId': '2152', 'LastActivityDate': '2014-04-04T13:08:09.397', 'CommentCount': '0', 'AcceptedAnswerId': '23418', 'CreationDate': '2014-04-04T12:43:38.880', 'Id': '23417'}