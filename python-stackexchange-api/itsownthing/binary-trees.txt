{'ViewCount': '303', 'Title': 'Efficient compression of unlabeled trees', 'LastEditDate': '2012-03-20T20:21:39.787', 'AnswerCount': '5', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '2', 'Body': '<p>Consider unlabeled, rooted binary trees. We can <em>compress</em> such trees: whenever there are pointers to subtrees $T$ and $T&#39;$ with $T = T&#39;$ (interpreting $=$ as structural equality), we store (w.l.o.g.) $T$ and replace all pointers to $T&#39;$ with pointers to $T$. See <a href="http://cs.stackexchange.com/a/177/98">uli\'s answer</a> for an example.</p>\n\n<p>Give an algorithm that takes a tree in the above sense as input and computes the (minimal) number of nodes that remain after compression. The algorithm should run in time $\\cal{O}(n\\log n)$ (in the uniform cost model) with $n$ the number of nodes in the input.</p>\n\n<p>This has been an exam question and I have not been able to come up with a nice solution, nor have I seen one.</p>\n', 'Tags': '<algorithms><data-structures><trees><binary-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-20T20:21:39.787', 'CommentCount': '11', 'AcceptedAnswerId': '174', 'CreationDate': '2012-03-09T17:54:38.383', 'Id': '168'}{'Body': "<p>When implementing a dictionary ('I want to look up customer data by their customer IDs'), the typical data structures used are hash tables and binary search trees. I know for instance that the C++ STL library implements dictionaries (they call them maps) using (balanced) binary search trees, and the .NET framework uses hash tables under the hood.</p>\n\n<blockquote>\n  <p>What are the advantages and disadvantages of these data structures? Is there some other option that is reasonable in certain situations?</p>\n</blockquote>\n\n<p>Note that I'm not particularly interested in cases where the keys have a strong underlying structure, say, they are all integers between 1 and n or something.</p>\n", 'ViewCount': '4628', 'Title': 'Hash tables versus binary trees', 'LastActivityDate': '2012-03-13T01:43:44.703', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '278', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<algorithms><data-structures><binary-trees><hash-tables>', 'CreationDate': '2012-03-13T00:30:42.750', 'FavoriteCount': '2', 'Id': '270'}{'ViewCount': '1205', 'Title': 'Not all Red-Black trees are balanced?', 'LastEditDate': '2012-04-12T05:55:31.997', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '2', 'Body': '<p>Intuitively, "balanced trees" should be trees where left and right sub-trees at each node must have "approximately the same" number of nodes.</p>\n\n<p>Of course, when we talk about red-black trees*(see definition at the end) being balanced, we actually mean that they are <em>height</em> balanced and in that sense, they are balanced. </p>\n\n<p>Suppose we try to formalize the above intuition as follows:</p>\n\n<blockquote>\n  <p><strong>Definition:</strong> A Binary Tree is called $\\mu$-balanced, with $0 \\le \\mu \\leq \\frac{1}{2}$, if for every node $N$, the inequality</p>\n  \n  <p>$$ \\mu \\le \\frac{|N_L| + 1}{|N| + 1} \\le 1 - \\mu$$</p>\n  \n  <p>holds and for every $\\mu&#39; \\gt \\mu$, there is some node for which the above statement fails. $|N_L|$ is the number of nodes in the left sub-tree of $N$ and $|N|$ is the number of nodes under the tree with $N$ as root (including the root).</p>\n</blockquote>\n\n<p>I believe, these are called <em>weight-balanced</em> trees in some of the literature on this topic. </p>\n\n<p>One can show that if a binary tree with $n$ nodes is $\\mu$-balanced (for a constant $\\mu \\gt 0$), then the height of the tree is $\\mathcal{O}(\\log n)$, thus maintaining the nice search properties.</p>\n\n<p>So the question is:</p>\n\n<blockquote>\n  <p>Is there some $\\mu \\gt 0$ such that every big enough red-black tree is $\\mu$-balanced?</p>\n</blockquote>\n\n<hr>\n\n<p>The definition of Red-Black trees we use (from Introduction to Algorithms by Cormen et al):</p>\n\n<p>A binary search tree, where each node is coloured either red or black and</p>\n\n<ul>\n<li>The root is black</li>\n<li>All NULL nodes are black</li>\n<li>If a node is red, then both its children are black.</li>\n<li>For each node, all paths from that node to descendant NULL nodes have the same number of black nodes.</li>\n</ul>\n\n<p>Note: we don\'t count the NULL nodes in the definition of $\\mu$-balanced above. (Though I believe it does not matter if we do).</p>\n', 'Tags': '<data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:55:44.147', 'CommentCount': '19', 'AcceptedAnswerId': '375', 'CreationDate': '2012-03-14T00:15:10.127', 'Id': '342'}{'ViewCount': '2403', 'Title': 'Counting binary trees', 'LastEditDate': '2012-03-14T16:35:41.583', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '68', 'FavoriteCount': '6', 'Body': '<p>(I\'m a student with some mathematical background and I\'d like to know how to count the number of a specific kind of binary trees.)</p>\n\n<p>Looking at Wikipedia page for <a href="http://en.wikipedia.org/wiki/Binary_tree">Binary Trees</a>, I\'ve noticed this assertion that the number of rooted binary trees of size $n$ would be this <a href="http://en.wikipedia.org/wiki/Catalan_number">Catalan Number</a>:\n$$C_n = \\dfrac{1}{n+1}{2n \\choose n}$$</p>\n\n<p>But I don\'t understand how I could come up with such a result by myself? Is there a method to find this result?</p>\n\n<p>Now, what if the order of sub-trees (which is left, which is right) is not considered? For example, from my point of view, I consider that these two trees are the same:</p>\n\n<pre><code>   /\\   /\\\n  /\\     /\\\n</code></pre>\n\n<p>Would it be possible to apply a similar method to count how many of these objects have exactly $n$ nodes?</p>\n', 'Tags': '<combinatorics><binary-trees><discrete-mathematics>', 'LastEditorUserId': '5', 'LastActivityDate': '2013-02-24T10:49:26.230', 'CommentCount': '2', 'AcceptedAnswerId': '372', 'CreationDate': '2012-03-14T13:57:03.527', 'Id': '368'}{'ViewCount': '1248', 'Title': 'AVL trees are not weight-balanced?', 'LastEditDate': '2012-04-12T05:55:19.533', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '1', 'Body': '<p>In a previous <a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">question</a> there was a definition of weight balanced trees and a question regarding red-black trees. </p>\n\n<p>This question is to ask the same question, but for <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL trees</a>. </p>\n\n<p>The question is, given the definition of $\\mu$-balanced trees as in the other question,</p>\n\n<blockquote>\n  <p>Is there some $\\mu \\gt 0$ such that all big enough AVL trees are $\\mu$-balanced?</p>\n</blockquote>\n\n<p>I presume there is only one definition of AVL trees and there is no ambiguity.</p>\n', 'Tags': '<data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:56:47.213', 'CommentCount': '0', 'AcceptedAnswerId': '424', 'CreationDate': '2012-03-15T16:56:32.180', 'Id': '421'}{'ViewCount': '2234', 'Title': 'Which combinations of pre-, post- and in-order sequentialisation are unique?', 'LastEditDate': '2012-03-17T09:20:08.613', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '5', 'Body': '<p>We know post-order,</p>\n\n<pre><code>post L(x)     =&gt; [x]\npost N(x,l,r) =&gt; (post l) ++ (post r) ++ [x]\n</code></pre>\n\n<p>and pre-order</p>\n\n<pre><code>pre L(x)     =&gt; [x]\npre N(x,l,r) =&gt; [x] ++ (pre l) ++ (pre r)\n</code></pre>\n\n<p>and in-order traversal resp. sequentialisation.</p>\n\n<pre><code>in L(x)     =&gt; [x]\nin N(x,l,r) =&gt; (in l) ++ [x] ++ (in r)\n</code></pre>\n\n<p>One can easily see that neither describes a given tree uniquely, even if we assume pairwise distinct keys/labels.</p>\n\n<p>Which combinations of the three can be used to that end and which can not?</p>\n\n<p>Positive answers should include an (efficient) algorithm to reconstruct the tree and a proof (idea) why it is correct. Negative answers should provide counter examples, i.e. different trees that have the same representation. </p>\n', 'Tags': '<algorithms><binary-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-20T19:49:58.823', 'CommentCount': '0', 'AcceptedAnswerId': '441', 'CreationDate': '2012-03-16T21:11:12.777', 'Id': '439'}{'ViewCount': '472', 'Title': 'Creating a Self Ordering Binary Tree', 'LastEditDate': '2012-04-12T05:55:04.773', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '79', 'FavoriteCount': '1', 'Body': "<p>I have an assignment where I need to make use a binary search tree and alter it to self order itself such that items that are accessed the most (have a higher priority) are at the top of the tree, the root being the most accessed node.</p>\n\n<p>The professor gave me the BST and node struct to work with, but trying to get my head around the algorithm to update the tree as things are being inserted is confusing me.</p>\n\n<p>I know that as the insert is happening, it checks if the current node's data is less or greater than the current node, then recursively goes in the correct direction until it finds a null pointer and inserts itself there. and after it is inserted it increases the priority by 1.</p>\n\n<pre><code>template &lt;class Type&gt;\nvoid BinarySearchTree&lt;Type&gt; ::  insert( const Type &amp; x, BinaryNode&lt;Type&gt; * &amp; t )\n{\n    if( t == NULL )\n        t = new BinaryNode&lt;Type&gt;( x, NULL, NULL );\n    else if( x &lt; t-&gt;element )\n        insert( x, t-&gt;left );\n    else if( t-&gt;element &lt; x )\n        insert( x, t-&gt;right );\n    else\n        t-&gt;priority++;  // Duplicate; do nothing for right now\n}\n</code></pre>\n\n<p>Now I need to figure out when the node is equal, how to re-order the tree so that the current node (who is equal to an already existing node) finds the existing node, increases that node's priority, then shifts it up if the root is a lower priority.</p>\n\n<p>I think I have the idea down that the AVL logic would work, and when a shift would take place, it would be a single rotation right or a single rotation left.</p>\n\n<p>Here's where I'm confused,  don't really know where to start with creating an algorithm to solve the problem. Since the AVL algorithm works with keeping track of the balance of a tree, then rotating nodes left or right accordingly, this tree doesn't need to worry about being balanced, just that the nodes with the highest priority not have children with a higher priority.</p>\n", 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-12T05:55:04.773', 'CommentCount': '0', 'AcceptedAnswerId': '610', 'CreationDate': '2012-03-21T00:05:18.697', 'Id': '559'}{'Body': '<p>Suppose we have a balanced binary tree, which represents a recursive partitioning of a set of $N$ points into nested subsets.  Each node of the tree represents a subset, with the following properties: subsets represented by two children nodes of the same parent are disjoint, and their union is equal to the subset represented by the parent.  The root represents the full set of points, and each leaf represents a single distinct point.  So there are $\\log N$ levels to the tree, and each level of the tree represents a partitioning of the points into increasingly fine levels of granularity.</p>\n\n<p>Now suppose we have two algorithms, each of which operates on all of the subsets of the tree.  The first does $O(D^2)$ operations at each node, where $D$ is the size of the subset represented by the node.  The second does $O(D \\log D)$ operations at each node.  What is the worst case runtime of these two algorithms?</p>\n\n<p>We can easily bound the first algorithm as $O(N^2 \\log N)$, because it does $O(N^2)$ work at each of $\\log N$ levels of the tree.  Similarly, we can bound the second algorithm as $O(N \\log ^2 N)$, by similar reasoning.</p>\n\n<p>The question is, are these bounds tight, or can we do better?  How do we prove it?</p>\n', 'ViewCount': '394', 'Title': 'What is the complexity of these tree-based algorithms?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-21T15:26:40.690', 'LastEditDate': '2012-03-21T06:35:12.333', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '579', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '363', 'Tags': '<algorithms><time-complexity><binary-trees>', 'CreationDate': '2012-03-21T04:43:41.727', 'Id': '578'}{'ViewCount': '893', 'Title': 'Logarithmic vs double logarithmic time complexity', 'LastEditDate': '2012-04-12T05:54:48.283', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '652', 'FavoriteCount': '2', 'Body': '<p>In real world applications is there a concrete benefit when using $\\mathcal{O}(\\log(\\log(n))$ instead of $\\mathcal{O}(\\log(n))$ algorithms ?</p>\n\n<p>This is the case when one use for instance van Emde Boas trees instead of more conventional binary search tree implementations. \nBut for example, if we take $n &lt; 10^6$ then in the best case the double logarithmic algorithm outperforms the logarithmic one by (approximately) a factor of $5$. And also in general the implementation is more tricky and complex. </p>\n\n<p>Given that I personally prefer BST over VEB-trees, what do you think ?</p>\n\n<p><em>One could easily demonstrate that :</em></p>\n\n<p>$\\qquad \\displaystyle \\forall n &lt; 10^6.\\ \\frac{\\log n}{\\log(\\log(n))} &lt; 5.26146$</p>\n', 'Tags': '<algorithms><complexity-theory><binary-trees><algorithm-analysis><search-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T03:54:23.937', 'CommentCount': '3', 'AcceptedAnswerId': '661', 'CreationDate': '2012-03-22T14:23:03.533', 'Id': '654'}{'ViewCount': '1315', 'Title': 'Proving a binary tree has at most $\\lceil n/2 \\rceil$ leaves', 'LastEditDate': '2012-03-30T02:27:43.967', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '756', 'FavoriteCount': '3', 'Body': '<p>I\'m trying to prove that a <a href="http://en.wikipedia.org/wiki/Binary_tree">binary tree</a> with $n$ nodes has at most $\\left\\lceil \\frac{n}{2} \\right\\rceil$ leaves. How would I go about doing this with induction?</p>\n\n<p><em>For people who were following in the original question about heaps, it has been moved <a href="http://cs.stackexchange.com/questions/841/proving-a-binary-heap-has-lceil-n-2-rceil-leaves">here</a>.</em></p>\n', 'Tags': '<data-structures><binary-trees><combinatorics><graph-theory><proof-techniques>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-10-01T04:35:17.907', 'CommentCount': '7', 'AcceptedAnswerId': '810', 'CreationDate': '2012-03-26T21:51:56.127', 'Id': '805'}{'Body': '<p>I\'m trying to prove that a <a href="http://en.wikipedia.org/wiki/Binary_heap">binary heap</a> with $n$ nodes has exactly $\\left\\lceil \\frac{n}{2} \\right\\rceil$ leaves, given that the heap is built in the following way:</p>\n\n<p>Each new node is inserted via <a href="http://en.wikipedia.org/wiki/Binary_heap#Insert">percolate up</a>. This means that each new node must be created at the next available child. What I mean by this is that children are filled level-down, and left to right. For example, the following heap:</p>\n\n<pre><code>    0\n   / \\\n  1   2\n</code></pre>\n\n<p>would <b>have</b> to have been built in this order: 0, 1, 2. (The numbers are just indexes, they give no indication of the actual data held in that node.) </p>\n\n<p>This has two important implications:</p>\n\n<ol>\n<li><p>There can exist no node on level $k+1$ without level $k$ being completely filled</p></li>\n<li><p>Because children are built left to right, there can be no "empty spaces" between the nodes on level $k+1$, or situations like the following:  </p>\n\n<pre><code>    0\n   / \\\n  1   2\n / \\   \\\n3  4    6\n</code></pre></li>\n</ol>\n\n<p>(This would be an illegal heap by my definition.) Thus, a good way to think of this heap is an <a href="http://en.wikipedia.org/wiki/Binary_heap#Heap_implementation">array implementation</a> of a heap, where there can\'t be any "jumps" in indeces of the array.</p>\n\n<p>So, I was thinking induction would probably be a good way to do this... Perhaps something having to deal with even an odd cases for n. For example, some induction using the fact that even heaps built in this fashion must have an internal node with one child for an even n, and no such nodes for an odd n. Ideas?</p>\n', 'ViewCount': '853', 'Title': 'Proving a binary heap has $\\lceil n/2 \\rceil$ leaves', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-09T16:12:24.240', 'LastEditDate': '2012-03-28T06:42:55.933', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '843', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '756', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-03-28T00:56:55.877', 'Id': '841'}{'ViewCount': '855', 'Title': 'Why does the splay tree rotation algorithm take into account both the parent and grandparent node?', 'LastEditDate': '2012-08-10T11:00:07.597', 'AnswerCount': '1', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '1056', 'FavoriteCount': '2', 'Body': '<p>I don\'t quite understand why the rotation in the splay tree data structure is taking into account not only the parent of the rating node, but also the grandparent (zig-zag and zig-zig operation). Why would the following not work:</p>\n\n<p>As we insert, for instance, a new node to the tree, we check whether we insert into the left or right subtree. If we insert into the left, we rotate the result RIGHT, and vice versa for right subtree. Recursively it would be sth like this</p>\n\n<pre><code>Tree insert(Tree root, Key k){\n    if(k &lt; root.key){\n        root.setLeft(insert(root.getLeft(), key);\n        return rotateRight(root);\n    }\n    //vice versa for right subtree\n}\n</code></pre>\n\n<p>That should avoid the whole "splay" procedure, don\'t you think?</p>\n', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '187', 'LastActivityDate': '2012-08-10T11:00:07.597', 'CommentCount': '0', 'AcceptedAnswerId': '1230', 'CreationDate': '2012-04-11T21:37:01.123', 'Id': '1229'}{'Body': u"<p>There are some documents to be indexed, that means I need to read the docs and extract the words and index them by storing at which document they appear and at which position.</p>\n\n<p>For each word initially I am creating a separate file. Consider 2 documents:</p>\n\n<ul>\n<li>document 1: \u201cThe Problem of Programming Communication with\u201d</li>\n<li>document 2: \u201cProgramming of Arithmetic Operations\u201d</li>\n</ul>\n\n<p>Here, there are 10 words, 8 unique. So I create 8 files (<code>the</code>, <code>problem</code>, <code>of</code>, <code>programming</code>, <code>communications</code>, <code>with</code>, <code>arithmetic</code>, <code>operations</code>).</p>\n\n<p>In each file, I will store at which document they appear and at what position. The actual structure I am implementing has lot more information but this basic structure will serve the purpose.</p>\n\n<pre><code>file name        file content\nthe              1 1\nproblem          1 2\nof               1 3 2 2\nprogramming      1 4 2 1\ncommunications   1 5\nwith             1 6\narithmetic       2 3\noperations       2 4\n</code></pre>\n\n<p>Meaning. the word is located at document 1, position 3 and at document 2, position 2.</p>\n\n<p>After the initial index is done I will concatenate all the files into a single index file and in another file I store the offset where a particular word will be found.</p>\n\n<p>index file: <code>1 1 1 2 1 3 2 2 1 4 2 1 1 5 1 6 2 3 2 4</code><br>\noffset file: <code>the 1 problem 3 of 5 programming 9 communications 13  with 15 arithmetic 17 operations 19</code></p>\n\n<p>So if I need the index information for <code>communications</code>, I will go to position 13 of the file and read up to position 15 excluded, in other words the offset of the next word.</p>\n\n<p>This is all fine for static indexing. But if I change a single index the whole file will need to be rewritten. Can I use a binary tree as the index file's structure, so that I can dynamically change the file content and update the offset somehow ? </p>\n", 'ViewCount': '188', 'Title': 'Maintaining search indices with binary trees', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T11:42:40.107', 'LastEditDate': '2012-04-22T11:42:40.107', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '173', 'Tags': '<data-structures><binary-trees><data-mining>', 'CreationDate': '2012-04-20T19:32:58.920', 'Id': '1398'}{'Body': '<p>As a follow up to this <a href="http://cs.stackexchange.com/questions/368/counting-binary-trees">question</a> (the number of rooted binary trees of size n), how many possible binary trees can you have if the nodes are now labeled, so that abc is different than bac cab etc ? In other words, order matters. Certainly it will be much more than the Catalan number.</p>\n\n<p>What would the problem be if you have n-ary trees instead of binary ?  </p>\n\n<p>Are these known problems?  reference ?  </p>\n', 'ViewCount': '268', 'Title': 'Counting trees (order matters)', 'LastActivityDate': '2012-05-16T23:10:20.257', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '1876', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1419', 'Tags': '<binary-trees><combinatorics><trees>', 'CreationDate': '2012-05-09T21:20:54.163', 'Id': '1762'}{'ViewCount': '535', 'Title': 'How can I prove that a complete binary tree has $\\lceil n/2 \\rceil$ leaves?', 'LastEditDate': '2012-06-02T00:54:30.613', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Luc Peetersen', 'PostTypeId': '1', 'OwnerUserId': '1722', 'FavoriteCount': '2', 'Body': "<p>Given a complete binary tree with $n$ nodes. I'm trying to prove that a complete binary tree has exactly $\\lceil n/2 \\rceil$ leaves.\nI think I can do this by induction.</p>\n\n<p>For $h(t)=0$, the tree is empty. So there are no leaves and the claim holds for an empty tree.</p>\n\n<p>For $h(t)=1$, the tree has 1 node, that also is a leaf, so the claim holds.\nHere I'm stuck, I don't know what to choose as induction hypothesis and how to do the induction step.</p>\n", 'Tags': '<data-structures><graph-theory><proof-techniques><combinatorics><binary-trees>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-06-02T05:41:15.503', 'CommentCount': '6', 'AcceptedAnswerId': '2196', 'CreationDate': '2012-06-01T21:08:05.543', 'Id': '2193'}{'Body': u"<p>I've been given the following problem:</p>\n\n<p>Given a data structure $M$ that is based on comparisons and supports the following methods on a group of numbers $S$:</p>\n\n<ul>\n<li>$\\text{Insert}(x)$ \u2013 add $x$ to $S$</li>\n<li>$\\text{Extract_min}()$ \u2013 remove the minimal element in $S$ and return it </li>\n</ul>\n\n<p>We can implement with a heap the above methods in $O(\\log n)$, however, we're looking at \na bigger picture, a general case that we have no guarantee that $M$ is indeed a heap. Prove that \nno matter what kind of data structure $M$ is, that <strong>at least one</strong> of the methods that $M$ supports must take $\\Omega(\\log n )$.</p>\n\n<p><strong>My solution:</strong></p>\n\n<p>Each sorting algorithm that is based on comparisons must take at the worst case at least $\\Omega(n\\log n)$ \u2013 we'll prove that using a decision tree: if we look at any given algorithm that is based on comparisons, as a binary tree where each vertex is a <em>compare-method</em> between 2 elements: </p>\n\n<ul>\n<li>if the first is bigger than the second element \u2013 we'll go to the left child</li>\n<li>if the second is bigger than the first element \u2013 we'll go to the right child</li>\n</ul>\n\n<p>At the end, we'll have $n!$ leaves that are the options for sorting the elements.</p>\n\n<p>The height of the tree is $h$, then:</p>\n\n<p>$$2^h \\ge n! \\quad\\Longrightarrow\\quad \\log(2^h) &gt;= \\log(n!) \\quad\\Longrightarrow\\quad h \\ge \\log(n!) \\quad\\Longrightarrow\\quad h = \\Omega(n \\log n)$$</p>\n\n<p>Then, if we have a $\\Omega(n \\log n)$ worst case for $n$ elements, then we have a $\\Omega(\\log n)$ for a single element. </p>\n\n<p>I'm not sure regarding this solution, so I'd appreciate for corrections or anything else \nyou can come up with. </p>\n", 'ViewCount': '311', 'Title': 'Prove that for a general data structure - operations Extract_min() and Insert(x) cost $\\Omega(\\log n)$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-26T12:42:03.597', 'LastEditDate': '2012-06-26T12:42:03.597', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '776', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'CreationDate': '2012-06-23T13:38:12.030', 'FavoriteCount': '0', 'Id': '2459'}{'Body': "<p>Is there any formal definition about the average height of a binary tree?</p>\n\n<p>I have a tutorial question about finding the average height of a binary tree using the following two methods:</p>\n\n<ol>\n<li><p>The natural solution might be to take the average length of all possible\npaths from the root to a leaf, that is</p>\n\n<p>$\\qquad \\displaystyle \\operatorname{avh}_1(T) = \\frac{1}{\\text{# leaves in } T} \\cdot \\sum_{v \\text{ leaf of } T} \\operatorname{depth}(v)$.</p></li>\n<li><p>Another option is to define it recursively, that is the average height for a node is the average over the average heights of the subtrees plus\none, that is </p>\n\n<p>$\\qquad \\displaystyle \\operatorname{avh}_2(N(l,r)) = \\frac{\\operatorname{avh}_2(l) + \\operatorname{avh}_2(r)}{2} + 1$</p>\n\n<p>with $\\operatorname{avh}_2(l) = 1$ for leafs $l$ and $\\operatorname{avh}_2(\\_) = 0$ for empty slots.</p></li>\n</ol>\n\n<p>Based on my current understanding, for example the average height of the tree $T$</p>\n\n<pre><code>    1    \n   / \\\n  2   3\n /\n4\n</code></pre>\n\n<p>is $\\operatorname{avh}_2(T) = 1.25$ by the second method, that is using recursion.</p>\n\n<p>However, I still don't quite understand how to do the first one. $\\operatorname{avh}_1(T) = (1+2)/2=1.5$ is not correct.</p>\n", 'ViewCount': '825', 'Title': 'What is the average height of a binary tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-22T09:42:41.200', 'LastEditDate': '2012-07-22T09:42:37.330', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '2859', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1895', 'Tags': '<graph-theory><terminology><combinatorics><binary-trees>', 'CreationDate': '2012-07-16T13:55:13.860', 'Id': '2762'}{'Body': "<p>Is there a way to reconstruct a binary tree just from its in-order representation?</p>\n\n<p>I've searched the internet, but I could only find solutions for reconstructing a binary tree from inorder and preorder representations, but none for only inorder.</p>\n", 'ViewCount': '316', 'Title': 'From in-order representation to binary tree', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-19T21:10:44.540', 'LastEditDate': '2012-07-19T08:49:01.357', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'papen', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><binary-trees>', 'CreationDate': '2012-07-18T19:23:00.627', 'Id': '2817'}{'Body': "<p>In the book 'Introduction to Algorithms 3/e', I have found the following definition of Binary Search Tree property:</p>\n\n<blockquote>\n  <p>Let $x$ be a node in a binary search tree. If $y$ is a node in the left subtree\n  of $x$, then $y.key \\leq x.key$. If $y$ is a node in the right subtree of $x$, then $y.key \\geq x.key$.</p>\n</blockquote>\n\n<p>My confusion is that while implementing binary search trees we either consider that the keys of left-subtree of a node $x$ would be $\\leq x.key$ <strong>or</strong> the keys of right-subtree of a node $x$ would be $\\geq x.key$ but <strong>not both</strong>. That is we follow one of the two convention. But in the property they have included $=$ in both the cases. Where am I wrong?</p>\n\n<p>I would appreciate any idea on this issue.</p>\n", 'ViewCount': '274', 'Title': 'Binary Search Tree Property', 'LastEditorUserId': '29', 'LastActivityDate': '2012-08-29T00:50:34.147', 'LastEditDate': '2012-08-28T11:38:51.780', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2556', 'Tags': '<terminology><data-structures><binary-trees><search-trees>', 'CreationDate': '2012-08-28T05:54:20.237', 'Id': '3345'}{'Body': '<p>I have seen two definitions of balanced binary trees, which look different to me.</p>\n\n<ol>\n<li><p>A binary tree is balanced if for each node it holds that the number of inner nodes in the left subtree and the number of inner nodes in the right subtree differ by at most 1.</p></li>\n<li><p>A binary tree is balanced if for any two leaves the difference of the depth is at most 1.</p></li>\n</ol>\n\n<p>Does every tree that satisfies def. 1 also satisfy def. 2? What about the other way round?</p>\n', 'ViewCount': '1138', 'Title': 'Two definitions of balanced binary trees', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-12T22:31:04.060', 'LastEditDate': '2012-09-12T20:24:51.237', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-09-12T17:37:24.510', 'FavoriteCount': '1', 'Id': '3515'}{'Body': '<p>The notion of best-case running time is kind of ambiguous for me. According to wikipedia, the definition of best case running time is:</p>\n\n<blockquote>\n  <p>The term best-case performance is used in computer science to describe the way of an algorithm behaves under optimal conditions. For example, the best case for a simple linear search on a list occurs when the desired element is the first element of the list.</p>\n</blockquote>\n\n<p>According to this definition, the best case running time for BST insertion should be $O(1)$ [consider that we are inserting to the root node]. But different resources says different things, some claim that it is $O(\\log n)$ [perfect balanced tree] and some others claim that it is $O(1)$ which one should I believe?</p>\n', 'ViewCount': '1986', 'Title': 'Best-Case Running Time For Binary Search Tree Insertion', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-24T22:16:37.427', 'LastEditDate': '2012-09-24T22:12:54.513', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4725', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2956', 'Tags': '<terminology><data-structures><runtime-analysis><binary-trees>', 'CreationDate': '2012-09-24T21:48:27.473', 'Id': '4723'}{'Body': "<p>I have a formula $ \\neg((q \\implies \\neg q) \\vee p \\vee (\\neg q \\implies (r \\wedge p))) $.</p>\n\n<p>As it contains 3 subformulas between the $\\vee$'s, how can i put it into a parse tree, as a parse tree contains 2 branches from each node.</p>\n", 'ViewCount': '242', 'Title': 'How to make a parse tree for the following propositional logic formula?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T09:21:21.817', 'LastEditDate': '2012-10-07T16:22:33.433', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '4921', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3088', 'Tags': '<formal-languages><logic><binary-trees><parsing>', 'CreationDate': '2012-10-07T12:33:25.243', 'Id': '4918'}{'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/439/which-combinations-of-pre-post-and-in-order-sequentialisation-are-unique">Which combinations of pre-, post- and in-order sequentialisation are unique?</a>  </p>\n</blockquote>\n\n\n\n<p>I have three different tree traversal of a binary tree Inorder, Preorder and Postorder. I want to identify the tree back from these traversal. I found that a single traversal cant not identify the tree.<br>\n So if I\'ll take in pair then can I identiy the tree?</p>\n', 'ViewCount': '40', 'ClosedDate': '2012-10-13T23:11:23.750', 'Title': 'How to identify a binary tree uniquely if its Inorder, Preorder and Postorder traversal is given?', 'LastActivityDate': '2012-10-13T04:52:21.040', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3075', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-10-13T04:52:21.040', 'Id': '5039'}{'Body': '<p>This is a GRE practice question. </p>\n\n<p><img src="http://i.stack.imgur.com/dUavw.png" alt="BST n=8"></p>\n\n<p>If a node in the binary search tree above is to be located by binary tree search, what is the expected number of comparisons required to locate one of the items (nodes) in the tree chosen at random?</p>\n\n<p>(A) 1.75 </p>\n\n<p>(B) 2 </p>\n\n<p>(C) 2.75 </p>\n\n<p>(D) 3 </p>\n\n<p>(E) 3.25</p>\n\n<p>My answer was 3 because $n=8$ and $\\lg(n)$ comparisons should be made, and $\\lg(8) = 3$. But the correct answer is 2.75. Can someone explain the correct answer? Thanks!</p>\n', 'ViewCount': '1385', 'Title': 'Average number of comparisons to locate item in BST', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-16T15:02:35.267', 'LastEditDate': '2012-10-15T08:13:09.373', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6089', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4198', 'Tags': '<binary-trees><probability-theory><search-trees><average-case>', 'CreationDate': '2012-10-15T06:49:28.390', 'Id': '6085'}{'Body': u'<p>This question assumes the definition of a complete binary tree to be<sup>\u2020</sup>:</p>\n\n<blockquote>\n  <p>A binary tree $T$ with $N$ levels is complete if all levels except possibly the last are completely full, and the last level has all its nodes to the left side.</p>\n</blockquote>\n\n<p>The following is an excerpt from <em><a href="http://www.amazon.ca/Algorithms-Sanjoy-Dasgupta/dp/0073523402" rel="nofollow">Algorithms</a></em>:</p>\n\n<blockquote>\n  <p>It ($\\log N$) is also the depth of a complete binary tree with $N$ nodes. (More precisely: $\u230a\\log N\u230b$.)</p>\n</blockquote>\n\n<p>Why is the above excerpt valid?</p>\n\n<p><sup>\u2020</sup> Originally defined <a href="http://courses.cs.vt.edu/~cs3114/Summer11/Notes/T03a.BinaryTreeTheorems.pdf" rel="nofollow">here</a>  </p>\n', 'ViewCount': '1528', 'Title': 'What is the depth of a complete binary tree with $N$ nodes?', 'LastActivityDate': '2012-10-19T06:27:37.757', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6162', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4267', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-10-19T03:19:21.177', 'Id': '6161'}{'Body': u"<blockquote>\n  <p>Let $f(N)$ be the average number of full nodes (nodes with two children) in an $N$-node binary search tree.</p>\n  \n  <ol>\n  <li>Determine the values of $f(0)$ and $f(1)$. </li>\n  <li><p>Given that for $N &gt; 1$, </p>\n  \n  <p>$\\qquad \\displaystyle f(N) = \\frac{N-2}{N} + \\frac{1}{N} \\sum_{i=0}^{N-1} [f(i) + f(N - i - 1)]$,</p>\n  \n  <p>show that $f(N) = \\frac{N - 2}{3}$.</p></li>\n  <li>Using this information, show that the average number of nodes with one child in a binary search tree is $\\frac{N + 1}{3}$.</li>\n  </ol>\n</blockquote>\n\n<p>I know that for (1) both values are $0$. I mainly need help proving (2).\nI also found some hints for (2) and (3) but I can't figure it out:</p>\n\n<p>(2) The root contributes $\\frac{N \u2212 2}{N}$ full nodes on average, because the root is full as long as it does not contain the largest or smallest item. The remainder of the equation is the expected contribution of the subtrees.</p>\n\n<p>(3) The average number of leaves is $\\frac{N + 1}{3}$.</p>\n\n<p>Any help would be appreciated, even just pointing me in the right direction. Thanks!</p>\n", 'ViewCount': '517', 'Title': 'Average number of full nodes in a binary search tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T16:49:13.143', 'LastEditDate': '2012-10-22T15:51:25.087', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user1758064', 'PostTypeId': '1', 'Tags': '<data-structures><combinatorics><recurrence-relation><binary-trees>', 'CreationDate': '2012-10-19T02:17:50.273', 'Id': '6179'}{'Body': '<p>In order to achieve the time complexity of $O(\\log \\log u)$ for van Emde Boas trees I read in <a href="http://fileadmin.cs.lth.se/cs/Personal/Rolf_Karlsson/lect12.pdf" rel="nofollow">this lecture</a> that the the universe size  $u$  is chosen as $u = 2^{2^k}$ for some integer $k$ for van Emde Boas trees. Why choose $u$ to be of this specific form ?</p>\n', 'ViewCount': '116', 'Title': 'Size of the universe for van Emde Boas Trees', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-20T14:34:19.040', 'LastEditDate': '2012-10-20T14:34:19.040', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6195', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><data-structures><algorithm-analysis><binary-trees><trees>', 'CreationDate': '2012-10-20T14:22:39.857', 'Id': '6193'}{'ViewCount': '3499', 'Title': 'Why is the minimum height of a binary tree $\\log_2(n+1) - 1$?', 'LastEditDate': '2012-10-24T22:18:38.927', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Imray', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '0', 'Body': "<p>In my Java class, we are learning about complexity of different types of collections.</p>\n\n<p>Soon we will be discussing binary trees, which I have been reading up on. The book states that the minimum height of a binary tree is $\\log_2(n+1) - 1$, but doesn't offer further explanation.</p>\n\n<p>Can someone explain why?</p>\n", 'Tags': '<data-structures><binary-trees><discrete-mathematics><trees>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-10-24T22:18:38.927', 'CommentCount': '1', 'AcceptedAnswerId': '6282', 'CreationDate': '2012-10-23T22:12:56.283', 'Id': '6277'}{'ViewCount': '1759', 'Title': 'Proof that a randomly built binary search tree has logarithmic height', 'LastEditDate': '2012-10-28T11:16:30.370', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '1', 'Body': '<p>How do you prove that the expected height of a randomly built <a href="http://en.wikipedia.org/wiki/Binary_search_tree" rel="nofollow">binary search tree</a> with $n$ nodes is $O(\\log n)$? There is a proof in CLRS <em>Introduction to Algorithms</em> (chapter 12.4), but I don\'t understand it.</p>\n', 'Tags': '<data-structures><algorithm-analysis><binary-trees><search-trees><average-case>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T12:56:45.620', 'CommentCount': '4', 'AcceptedAnswerId': '6356', 'CreationDate': '2012-10-27T19:37:43.787', 'Id': '6342'}{'Body': '<p>Suppose I am making a red-black search tree, and in my right subtree, I have a black node, then a red node, and it has two black children, the black children further black childrens. As such a lemma has been made that red-black trees with $n$ internal nodes have height at most $2\\log(n+1)$, would this proof still hold for such a black tree?</p>\n', 'ViewCount': '64', 'Title': 'Can you have three consecutive black nodes in red-black search tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T10:55:19.397', 'LastEditDate': '2012-10-28T10:55:19.397', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6344', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2012-10-27T23:52:30.187', 'Id': '6343'}{'Body': '<p>Let $n$ be the number of strings which are sorted in lexicographical order and stored in a balanced binary search tree. You are provided with a prefix $x$ of which $M$ strings have the prefix $x$. I have devised the following algorithm, where I search until I find the first occurence of the prefix $x$ in one of the nodes. After that I run an inorder traversal on it, such that I print only the ones, that have prefix $x$ and are in order. </p>\n\n<p>For example of sorted strings: $[ACT,BAT,CAT,CAB]$ and the prefix $x = CA$, I would print $CAT$ and $CAB$. </p>\n', 'ViewCount': '170', 'Title': 'Can you have a binary search tree with O(logn + M) property for the following case', 'LastEditorUserId': '31', 'LastActivityDate': '2012-10-30T07:32:51.260', 'LastEditDate': '2012-10-29T08:36:24.140', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '6381', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<binary-trees><search-trees>', 'CreationDate': '2012-10-29T05:32:13.887', 'Id': '6368'}{'ViewCount': '748', 'Title': 'What is the time complexity of calling successor $n$ times during tree traversal?', 'LastEditDate': '2012-10-30T10:28:52.880', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '2', 'Body': '<p>According to some <a href="http://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/binarySearchTree.htm" rel="nofollow">sources</a>, the time complexity of finding the successor of a node in a tree is $O(h)$. So, if the tree is well balanced, the height $h=\\log n$, and the successor function takes time $O(\\log n)$. \nYet, according to this <a href="http://stackoverflow.com/questions/12447499/time-complexity-of-bst-inorder-traversal-if-implemented-this-way">stackoverflow post on the time complexity of an inorder traversal of a binary search tree</a>, if you call the successor function $n$ times, the time complexity is $O(n)$.</p>\n\n<p>What resolves the apparent contradiction between:</p>\n\n<blockquote>\n  <p>If I call the sucessor function once, the time complexity is $O(h)$, which could be $O(n)$ or $O(\\log n)$, depending on the kind of tree.</p>\n</blockquote>\n\n<p>AND</p>\n\n<blockquote>\n  <p>If I call the successor $n$ times, the time complexity is $O(n)$ in a balanced tree.</p>\n</blockquote>\n\n<p>Shouldn\'t tree traversal take $O(n^2)$ or $O(n\\log n)$ time?</p>\n', 'Tags': '<binary-trees><search-trees>', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-10-30T15:34:30.833', 'CommentCount': '3', 'AcceptedAnswerId': '6383', 'CreationDate': '2012-10-30T03:10:00.910', 'Id': '6378'}{'Body': "<p>How is $\\frac{n}{2^{h+1}}$ the maximum possible number of nodes at height $h$ for a binary search tree or heap tree? I saw this as proof to asymptotically bound the <code>build_heap</code> function in the book, but I don't get it.</p>\n", 'ViewCount': '1750', 'Title': 'Maximum number of nodes with height h', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T08:17:25.400', 'LastEditDate': '2012-10-31T23:12:27.867', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '6412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2012-10-31T21:24:01.887', 'Id': '6405'}{'Body': '<p>How many different max-heaps can I form using a list of $n$ integers. </p>\n\n<p>Example: \nlist [1,2,3,4]</p>\n\n<p>and max-heap is <code>4 3 2 1</code>  or </p>\n\n<pre><code>    4\n   / \\\n  3   2\n /\n1\n</code></pre>\n\n<p>other possible max-heap is <code>4 2 3 1</code></p>\n\n<pre><code>    4 \n   / \\\n  2   3 \n /\n1\n</code></pre>\n', 'ViewCount': '569', 'Title': 'How many max heaps are there?', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-01-27T20:52:32.243', 'LastEditDate': '2012-11-20T08:21:15.937', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6458', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '244', 'Tags': '<graph-theory><data-structures><combinatorics><binary-trees><heaps>', 'CreationDate': '2012-11-02T18:19:35.187', 'Id': '6456'}{'Body': "<p>I'd like to know if there is a function $f$ from n-bit numbers to n-bit numbers that has the following characteristics:</p>\n\n<ul>\n<li>$f$ should be bijective</li>\n<li>Both $f$ and $f^{-1}$ should be calculable pretty fast</li>\n<li>$f$ should return a number that has no significant correlation to its input.</li>\n</ul>\n\n<p>The rationale is this:</p>\n\n<p>I want to write a  program that operates on data. Some information of the data is stored in a binary search tree where the search key is a symbol of an alphabet. With time, I add further symbols to the alphabet. New symbols simply get the next free number available. Hence, the tree will always have a small bias to smaller keys which causes more rebalancing than I think should be needed.</p>\n\n<p>My idea is to mangle the symbol numbers with $f$ such that they are widely spread over the whole range of $[0,2^{64}-1]$. Since the symbol numbers only matter during input and output which happens only once, applying such a function should not be too expensive.</p>\n\n<p>I thought about one iteration of the Xorshift random number generator, but I don't really know a way to undo it, although it should theoretically be possible.</p>\n\n<p>Does anybody know such a function?<br>\nIs this a good idea?</p>\n", 'ViewCount': '151', 'Title': 'Function that spreads input', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-07T02:34:50.327', 'LastEditDate': '2013-01-31T06:57:46.533', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<binary-trees><hash><binary-arithmetic>', 'CreationDate': '2012-11-14T20:53:55.090', 'FavoriteCount': '2', 'Id': '6668'}{'Body': '<p>Given a <a href="http://en.wikipedia.org/wiki/Binary_expression_tree" rel="nofollow">binary expresion tree</a>, with addition and multiplication operations, how can we optimize it\'s evaluation?</p>\n\n<p>Can we learn from <a href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication" rel="nofollow">matrix chain multiplication</a>? A <a href="http://en.wikipedia.org/wiki/Matrix_chain_multiplication#Generalizations" rel="nofollow">generalization</a> of matrix chain multiplication is defined as:</p>\n\n<blockquote>\n  <p>Given a linear sequence of objects, an associative binary operation on those objects, and a way to compute the cost of performing that operation on any two given objects (as well as all partial results), compute the minimum cost way to group the objects to apply the operation over the sequence.</p>\n</blockquote>\n\n<p>What happens if we put <em>two</em> binary operators? <strong>Can the algorithm for <em>Matrix chain multiplication</em> be further generalized (or how can we otherwise solve this problem) to <em>two</em> binary operators in a <em>binary expresion tree</em>, given the cost functions of these operations?</strong> In particular, <strong>multiplication and addition, which complicates things further by allowing distribution</strong>. Also, does it matter that mind that some of the numbers can be negative, allowing reduction in size of intermediate results (see <a href="http://cs.stackexchange.com/q/1424/2755">Overflow safe summation</a>)?</p>\n\n<p><strong>Also, how does this relate to  <a href="http://en.wikipedia.org/wiki/Graph_reduction" rel="nofollow">Graph Reduction</a>?</strong></p>\n\n<p>I also remember learning about database <a href="http://en.wikipedia.org/wiki/Query_optimization" rel="nofollow">query optimization</a> which seemed to do something similar to determine how early to execute particular joins to keep the intermediate values smaller.</p>\n', 'ViewCount': '422', 'Title': 'Chained operations on sequences with two operators', 'LastEditorUserId': '2755', 'LastActivityDate': '2012-11-28T22:31:40.290', 'LastEditDate': '2012-11-28T22:31:40.290', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<optimization><binary-trees><dynamic-programming><efficiency><arithmetic>', 'CreationDate': '2012-11-20T18:58:03.297', 'FavoriteCount': '1', 'Id': '6790'}{'Body': '<blockquote>\n  <p><strong>Problem:</strong> Suppose $V$ is an <a href="http://en.wikipedia.org/wiki/AVL_tree" rel="nofollow">AVL tree</a> (a self-balancing binary search tree) of $n$\n  elements. After the insertion of $n^2$ elements, what would be its\n  height?</p>\n</blockquote>\n\n<p><strong>My idea:</strong> the height of an AVL tree is originally $O(\\log(n))$ where $n$ is the number of elements. After insertion of $n^2$ elements, its height will be:$$O(\\log(n+n^2))=O(\\log(n^2))=O(2\\log(n))=O(\\log(n))$$</p>\n\n<p>My answer would be $O(\\log(n))$ but I\'m having doubts.</p>\n\n<p>Why is the asymptotic complexity of the result the same despite the fact that there are more elements?</p>\n', 'ViewCount': '82', 'Title': 'Height of AVL after entries', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-11-29T07:36:40.940', 'LastEditDate': '2012-11-29T06:08:02.270', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7007', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<algorithms><asymptotics><binary-trees><search-trees>', 'CreationDate': '2012-11-28T15:22:50.797', 'Id': '6995'}{'Body': '<p>Given a path down a <em>full</em> binary tree to a node (for example, a sequence of $1$s and $0$s, $0$ representing "go left" and $1$ representing "go right"), how would one find the position of the node in the preorder traversal. In other words the $i$th node in the preorder traversal will end up with at this node.</p>\n\n<p>Obviously something better than brute force would be nice.</p>\n', 'ViewCount': '311', 'Title': 'Calculating traversal position of a node in a full binary tree, given its path', 'LastActivityDate': '2013-02-10T05:11:58.387', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7348', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<binary-trees><trees><graph-traversal>', 'CreationDate': '2012-12-12T00:34:37.243', 'Id': '7346'}{'Body': '<p>On Facebook HackerCup 2013, they asked the following question:</p>\n\n<blockquote>\n  <p>Your friend John uses a lot of emoticons when you talk to him on\n  Messenger. In addition to being a person who likes to express himself\n  through emoticons, he hates unbalanced parenthesis so much that it\n  makes him go :(</p>\n  \n  <p>Sometimes he puts emoticons within parentheses, and you find it hard\n  to tell if a parenthesis really is a parenthesis or part of an\n  emoticon.</p>\n  \n  <p>A message has balanced parentheses if it consists of one of the\n  following:</p>\n  \n  <ul>\n  <li>An empty string "" </li>\n  <li>One or more of the following characters: \'a\' to\n  \'z\', \' \' (a space) or \':\' (a colon) </li>\n  <li>An open parenthesis \'(\', followed\n  by a message with balanced parentheses, followed by a close\n  parenthesis \')\'. </li>\n  <li>A message with balanced parentheses followed by\n  another message with balanced parentheses. </li>\n  <li>A smiley face ":)" or a\n  frowny face ":(" </li>\n  </ul>\n  \n  <p>Write a program that determines if there is a way to\n  interpret his message while leaving the parentheses balanced.</p>\n</blockquote>\n\n<p><a href="http://stackoverflow.com/questions/6447289/how-to-print-all-possible-balanced-parentheses-for-an-expression">Balancing parentheses</a> is talked about in a lot of places.  E.g. <code>(()) vs ()()</code>.  You can count</p>\n\n<ul>\n<li><code>\'(\' = +1 </code> </li>\n<li><code>\')\' = -1 </code></li>\n</ul>\n\n<p>Then you have to make sure your sum never falls below <strong>0</strong>. </p>\n\n<p>In this question they consider <code>:)</code> and <code>:(</code> as balanced and I wonder how much it changes things. One <a href="https://gist.github.com/4660602" rel="nofollow">solution</a> says that you can replace <code>r\'[^a-z:() ], \'\'</code>, <code>\':)\' -> \'}\'</code> and <code>\':(\' -> \'{\'</code>.  </p>\n\n<p>While I agree with the first sub, why are the last two substitutions valid?</p>\n', 'ViewCount': '177', 'Title': 'Facebook Hackercup 2013: Balanced Smileys', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-30T12:46:36.447', 'LastEditDate': '2013-01-30T12:46:36.447', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3131', 'Tags': '<algorithms><context-free><binary-trees><parsing>', 'CreationDate': '2013-01-29T22:41:19.300', 'Id': '9285'}{'Body': "<p>I'm trying to prove/disprove two statements. I just want to make sure with you I'm on the right line.</p>\n\n<p>These are the following statements:</p>\n\n<p><strong>Preface :</strong> Let A[n] be an array of min-heap (a min-heap represented by an array], whereas all the elements in the heap are different from each other. \nLet i and j be two indexes in the range : $0 \\le i, j \\le n-1$.</p>\n\n<p><em><strong>Prove or disprove :</em></strong> </p>\n\n<ol>\n<li>If $i &lt; j $ then $A[i] &lt; A[j]$</li>\n<li>If $A[i] &lt; A[j] $ then $i &lt; j$</li>\n</ol>\n\n<p>I believe I managed to disprove both of them using the following heap:</p>\n\n<p>$\\qquad [2, 6, 7, 11, 14, 13, 12, 12, 13,15, 16, 71, 72, 13, 81]$</p>\n\n<p>For:</p>\n\n<ol>\n<li><p>Simply plug in the following indexes: $i = 4$ and $j = 13$. </p>\n\n<p>So $i &lt; j$ but $A[i] &gt; A[j]$.</p></li>\n<li><p>Simply plug in the following indexes: $i = 13$ and $j = 4$.</p>\n\n<p>So $A[i] &lt; A[j]$ but $i &gt; j$.</p></li>\n</ol>\n\n<p>Am I missing something here? Or It is really that easy?</p>\n", 'ViewCount': '209', 'Title': 'MinHeap represented by an array - two simple statements', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-03T10:26:59.710', 'LastEditDate': '2013-02-03T10:26:59.710', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9445', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<data-structures><binary-trees><arrays><heaps>', 'CreationDate': '2013-02-03T08:44:32.337', 'Id': '9444'}{'Body': u'<p>I have this confusion. What is the local minimum of a complete binary tree?</p>\n\n<p>Consider an $n$-node complete binary tree $T$, where $n = 2^d \u2212 1$ for some $d$. Each node $v \\in V(T)$ is labeled with a real number $x_v$.  You may assume that the real numbers labeling the nodes are all distinct.  A node $v \\in V(T)$ is a local minimum if the label $x_v$ is less than the label $x_w$ for all nodes $w$ that are joined to $v$ by an edge.</p>\n', 'ViewCount': '377', 'Title': 'What is the local minimum of a complete binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-26T06:13:57.493', 'LastEditDate': '2013-02-25T07:15:14.690', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6999', 'Tags': '<terminology><graphs><binary-trees>', 'CreationDate': '2013-02-24T21:49:00.743', 'Id': '10071'}{'Body': '<p>A full binary tree seems to be a binary tree in which every node is either a leaf or has 2 children.\nI have been trying to prove that its height is O(logn) unsuccessfully.\nHere is my work so far:</p>\n\n<p>I am considering the worst case of a full binary tree in which each right node has a subtree, and each left node is a leaf.\nIn this case:<br>\n$N = 2x - 1$<br>\n$H = x - 1$<br>\nI am going nowhere trying to prove that $H = O(\\log(N))$</p>\n\n<p>Furthermore, we know that leaves l is bounded by $h+1 &lt;l&lt;2^h$.<br>\nInternal nodes is bounded by $h&lt;i&lt;2^{h-1}$.<br>\nAll this proves is that number of nodes $n=i+e$ is $&lt;= 2^{h+1} - 1$ i.e. $\\log(n) &lt;= h$. But this does not take me anywhere closer to prove that $H = O(\\log(n))$</p>\n', 'ViewCount': '364', 'Title': 'Height of a full binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-13T14:40:59.037', 'LastEditDate': '2013-03-13T14:40:59.037', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10508', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7260', 'Tags': '<graph-theory><combinatorics><binary-trees><trees>', 'CreationDate': '2013-03-13T06:53:28.090', 'Id': '10507'}{'ViewCount': '2573', 'Title': 'BIT: What is the intuition behind a binary indexed tree and how was it thought about?', 'LastEditDate': '2013-03-16T19:33:32.607', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '6823', 'FavoriteCount': '22', 'Body': '<p>A binary indexed tree has very less or relatively no literature as compared to other data structures. The only place where it is taught is <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=binaryIndexedTrees">the topcoder tutorial</a>. Although the tutorial is complete in all the explanations, I cannot understand the intuition behind such a tree? How was it invented? What is the actual proof of its correctness?</p>\n', 'Tags': '<algorithms><binary-trees><trees>', 'LastEditorUserId': '7304', 'LastActivityDate': '2013-12-17T10:36:55.957', 'CommentCount': '2', 'AcceptedAnswerId': '10541', 'CreationDate': '2013-03-15T17:56:58.113', 'Id': '10538'}{'ViewCount': '1020', 'Title': 'Colour a binary tree to be a red-black tree', 'LastEditDate': '2013-04-03T16:56:13.100', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '139', 'FavoriteCount': '2', 'Body': '<p>A common interview question is to give an algorithm to determine if a given binary tree is height balanced (AVL tree definition).</p>\n\n<p>I was wondering if we can do something similar with Red-Black trees.</p>\n\n<blockquote>\n  <p>Given an arbitrary uncoloured binary tree (with NULL nodes), is there a "fast" algorithm which can determine if we can colour (and find a colouring) the\n  nodes Red/Black so that they satisfy all the properties of a Red-Black\n  tree (definition as in this <a href="http://cs.stackexchange.com/questions/342/not-all-red-black-trees-are-balanced">question</a>)?</p>\n</blockquote>\n\n<p>An initial thought was that we can just remove the NULL nodes and try to recursively verify if the resulting tree can be a red-black tree, but that didn\'t seem to go anywhere.</p>\n\n<p>I did (a brief) web search for papers, but could not seem to find any which seem to deal with this problem.</p>\n\n<p>It is possible that I am missing something simple.</p>\n', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'LastEditorUserId': '139', 'LastActivityDate': '2013-04-20T17:57:19.710', 'CommentCount': '1', 'AcceptedAnswerId': '10999', 'CreationDate': '2013-04-03T08:02:32.960', 'Id': '10990'}{'ViewCount': '1416', 'Title': 'Constructing a binary tree with given traversals', 'LastEditDate': '2013-04-04T10:52:27.670', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Body': '<p>I have given a post order &amp; in order traversal a BST &amp; I need to construct it. I want to know how to do this. </p>\n\n<p>for eg.</p>\n\n<p>Post Order : DCBGFEA</p>\n\n<p>In Order : BDCAFGE </p>\n\n<p>This is how I am trying to do : </p>\n\n<ul>\n<li><p>From POST order it is clear that A is root. So in IN order, I consider everything right to A is at it\'s right sub tree &amp; so for left.</p>\n\n<p><img src="http://i.stack.imgur.com/PVFn9.jpg" alt="image1"></p></li>\n<li><p>Now, I consider A\'s left sub tree. It has BDC. Again from POST order, I conclude that B is root. </p>\n\n<p><img src="http://i.stack.imgur.com/EiAQ7.jpg" alt="image2"></p></li>\n<li><p>Now, again consider B\'s sub tree. It has contents DC &amp; POST order, C has to be at root. So now I get C at root. But where to place C, at B\'s left or right ? It\'s where I am getting stuck now. </p></li>\n</ul>\n\n<p>Same happening with A\'s right sub tree also. I place E as root of A\'s right sub tree. Then I conclude element below should be F, but does it come at right or left of E ? </p>\n\n<p>I want to know how to tackle this problem &amp; also is there any better approach for this to do. </p>\n', 'ClosedDate': '2013-04-04T12:05:00.787', 'Tags': '<binary-trees>', 'LastEditorUserId': '6665', 'LastActivityDate': '2013-04-04T11:22:31.740', 'CommentCount': '0', 'AcceptedAnswerId': '11016', 'CreationDate': '2013-04-04T10:47:15.770', 'Id': '11015'}{'ViewCount': '183', 'Title': 'Number of possible search paths when searching in BST', 'LastEditDate': '2013-04-11T23:41:46.050', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'FavoriteCount': '1', 'Body': "<p>I have the following question, but don't have answer for this. I would appreciate if my method is correct :</p>\n\n<p>Q. When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70, 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root node containing the value 60? </p>\n\n<p>(A) 35 (B) 64 (C) 128 (D) 5040 </p>\n\n<p>From the question, I understand that all nodes given have to be included in traversal and ultimately we have to reach the key, 60. For example, one such combination would be : </p>\n\n<p>10, 20, 40, 50, 90, 80, 70, 60. </p>\n\n<p>Since we have to traverse all nodes given above, we have to start either with 10 or 90. If we start with 20, we will not reach 10 (since 60 > 20 and we will traverse right subtree of 20)</p>\n\n<p>Similarly, we cannot start with 80, because we will not be able to reach 90, since 80>60, we will traverse in left sub tree of 80 &amp; thus not reaching 90. </p>\n\n<p>Lets take 10. The remaining nodes are 20, 40, 50, 70, 80, 90. Next node could be either 20 or 90. We cannot take other nodes for same earlier mentioned reason.</p>\n\n<p>If we consider similarly, at each level we are having two choices. Since there are 7 nodes, two choices for first 6 &amp; no choice for last one. So there are totally </p>\n\n<p>$2*2*2*2*2*2*1$ permutations = $2^6$ = $64$</p>\n\n<ol>\n<li><p>Is this a correct answer?</p></li>\n<li><p>If not, whats the better approach?</p></li>\n<li><p>I would like to generalize. If $n$ nodes are given then total possible search paths would be $2^{n-1}$</p></li>\n</ol>\n", 'Tags': '<data-structures><combinatorics><binary-trees><search-trees><graph-traversal>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T23:41:46.050', 'CommentCount': '0', 'AcceptedAnswerId': '11048', 'CreationDate': '2013-04-05T07:42:32.627', 'Id': '11043'}{'Body': '<p>I have been reading about AVL trees, at the moment I\'m trying to figure out how to determine the height of a tree and how to draw an AVL tree of some height with minimum number of elements.  </p>\n\n<p>In a tutorial I found that this: would be a AVL tree of height 7<br>\n<img src="http://i.stack.imgur.com/xc90l.jpg" alt="enter image description here"></p>\n\n<p>And this AVL tree with the height 4<br>\n<img src="http://i.stack.imgur.com/ZseOY.jpg" alt="enter image description here"></p>\n\n<p>This is really confusing by the look I would guess that both of them are of height 4. I\'m fairly new to data structures, I could not find a simple documentation/tutorial regarding this most of what i found was about Insertion/Deletion with AVL trees.  </p>\n\n<p>So is the top tree of height 7 if not how would I draw it with the minimal number of elements. I understand the each sub tree would have to be balanced.</p>\n', 'ViewCount': '362', 'Title': 'AVL tree with fixed height and as few elements as possible', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:57:27.700', 'LastEditDate': '2013-04-07T12:57:27.700', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7619', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-04-07T01:48:44.733', 'Id': '11086'}{'Body': '<p>A program takes as input a balanced binary search tree with $n$ leaf nodes and computes the value of a function $g(x)$ for each node $x$. If the cost of computing $g(x)$ is </p>\n\n<p>$\\qquad \\min(\\#\\text{leaves in } L(x), \\#\\text{leaves in } R(x))$</p>\n\n<p>for $L(x), R(x)$ the left resp. right subtree of $x$, then the worst-case time complexity of the program is</p>\n\n<ol>\n<li>$\\Theta(n)$</li>\n<li>$\\Theta(n \\log n)$</li>\n<li>$\\Theta(n^2)$ </li>\n<li>$\\Theta(n^2 \\log n)$</li>\n</ol>\n\n<p>I am actually looking for a subtle hint. </p>\n', 'ViewCount': '492', 'Title': 'Finding no. of leaf nodes for each node in a BST', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-22T14:55:46.203', 'LastEditDate': '2013-04-12T10:03:59.117', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11254', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><binary-trees><search-trees>', 'CreationDate': '2013-04-12T08:03:52.183', 'Id': '11252'}{'Body': '<p>The idea of <a href="http://en.wikipedia.org/wiki/Splay_tree">splay trees</a> is very nice as they move frequently accessed elements to the top, which can gain a considerable speed up in many applications. The drawback is that in the worst case an operation can have $O(n)$ complexity. \n(Although amortized bounds are $O(n\\log n)$ <a href="http://en.wikipedia.org/wiki/Splay_tree#Performance_theorems">if we perform at least $n$ operations</a>.)</p>\n\n<p>Is there a self-adjusting search tree structure that has both? Favoring recently accessed elements and with worst $O(\\log n)$ complexity for a single operation?</p>\n', 'ViewCount': '286', 'Title': 'Is there a binary tree structure with fast access to recently accessed elements and worst $O \\left( \\log n \\right )$ complexity?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-09-24T06:09:43.897', 'LastEditDate': '2013-05-07T07:14:06.917', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2448', 'Tags': '<data-structures><binary-trees><search-trees><splay-trees>', 'CreationDate': '2013-05-04T09:54:49.780', 'FavoriteCount': '2', 'Id': '11772'}{'Body': "<p>We're asked to prove the above mentioned lemma but I having a hard time proving this rigorously.</p>\n\n<p>We did prove that given $n$ values AVL's height is $\\Theta\\left (\\log \\left ( n \\right ) \\right )$ So I thought that after inserting a $\\frac{n}{2}$ values the height of the tree will be at least $\\Theta\\left (\\log \\left ( \\frac{n}{2} \\right ) \\right )$ which and because each isertion we make is now on a tree with at least $\\frac{n}{2}$ and insertion is $\\log \\left (h \\right ) $ where $h$ is the height of the tree.</p>\n\n<p>So for a function $F$ using the previous logic:</p>\n\n<p>$\\begin{align}  F &amp;= \\frac{n}{2} \\times \\log \\left (h \\right ) \n\\\\&amp; \\geq \\frac{n}{2} \\times \\log \\left (\\frac{n}{2} \\right ) \n\\\\&amp;=\\Omega\\left( n\\log \\left (n \\right )  \\right)\n\\end{align}$</p>\n\n<p>But I have a few issues with this </p>\n\n<ul>\n<li>This does feel fishy to me don't know why but it doesn't feel like a good well defined calculus proof :)</li>\n<li>I'm not sure which way to take it in order to prove the upper boud i.e $\\mathcal{O}$</li>\n</ul>\n\n<p>If I haven't given all the required information I'd be glad to.</p>\n", 'ViewCount': '78', 'Title': 'Prove that inserting $n$ sorted values in to an AVL using AVL insertion is $\\Theta\\left (n \\log \\left ( n \\right ) \\right )$', 'LastEditorUserId': '31', 'LastActivityDate': '2013-05-05T16:35:06.797', 'LastEditDate': '2013-05-05T16:35:06.797', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11808', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8004', 'Tags': '<algorithms><data-structures><binary-trees><search-trees>', 'CreationDate': '2013-05-05T15:30:17.330', 'Id': '11807'}{'Body': "<p>Given we change the rule to: </p>\n\n<blockquote>\n  <p>$-s \\ \\ \\leq$ height(left-subtree) - height(right-subtree) $\\leq \\ \\ s$</p>\n</blockquote>\n\n<p>I was wandering whether it's possible and how would it affect the trees' height, would it still be logarithmic? </p>\n\n<p>Would the exact same balancing techniques work? (if we took those methods from a normal AVL and try to convert our modified AVL to a normal AVL running from down to top or to down).</p>\n\n<p>I've tired drawing some schematics in order to find out what would be the minimal number of nodes $m$ for some tree $T$ with height $h$ like we did with a regular AVL but I had a real hard time formalizing it.</p>\n", 'ViewCount': '54', 'Title': "Changing AVL's balance factor to some other $s>2 \\in \\mathbb{N}$", 'LastEditorUserId': '8004', 'LastActivityDate': '2013-05-06T17:15:16.980', 'LastEditDate': '2013-05-06T17:15:16.980', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11834', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8004', 'Tags': '<algorithms><data-structures><binary-trees><trees>', 'CreationDate': '2013-05-06T14:22:34.710', 'Id': '11832'}{'Body': u'<p>You\u2019re doing some stress-testing on various models of glass jars to determine the height from which they can be dropped and still not break. The setup for this experiment, on a particular type of jar, is as follows. You have a ladder with $n$ rungs, and you want to find the highest rung from which you can drop a copy of the jar and not have it break. We call this the highest safe rung.\nIt might be natural to try binary search: drop a jar from the middle rung, see if it breaks, and then recursively try from rung $n/4$ or $3n/4$ depending on the outcome. But this has the drawback that you could break a lot of jars in finding the answer.</p>\n\n<p>If your primary goal were to conserve jars, on the other hand, you could try the following strategy. Start by dropping a jar from the first rung, then the second rung, and so forth, climbing one higher each time until the jar breaks. In this way, you only need a single jar\u2014at the moment it breaks, you have the correct answer\u2014but you may have to drop it $n$ times (rather than $\\log n$ as in the binary search solution).</p>\n\n<p>So here is the trade-off: it seems you can perform fewer drops if you\u2019re willing to break more jars. To understand better how this trade- off works at a quantitative level, let\u2019s consider how to run this experiment given a fixed \u201cbudget\u201d of $k \\ge 1$ jars. In other words, you have to determine the correct answer\u2014the highest safe rung\u2014and can use at most $k$ jars in doing so.</p>\n\n<p>Suppose you are given a budget of $k = 2$ jars. Describe a strategy for finding the highest safe rung that requires you to drop a jar at most $f (n)$ times, for some function $f (n)$ that grows slower than linearly. (In other words, it should be the case that $\\lim_{n\\to\\infty} f (n)/n = 0$.)</p>\n\n<p>Anyone any insights how to solve this problem?</p>\n\n<p>I know that the answer is $h = \\sqrt n$. I know  that it solves the problem. But I want to know how you got that answer, there must be a general way to do it?</p>\n', 'ViewCount': '672', 'Title': 'Balancing subproblems in resilience testing', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-11T01:48:19.290', 'LastEditDate': '2013-08-01T07:17:26.863', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'user75300', 'PostTypeId': '1', 'OwnerUserId': '8086', 'Tags': '<algorithms><binary-trees><decision-problem><divide-and-conquer>', 'CreationDate': '2013-05-07T21:28:25.053', 'Id': '11981'}{'Body': '<p>So, Google Code Jam round 1C has just wrapped up, and one of its problems seems rather elusive to me:  <a href="https://code.google.com/codejam/contest/2437488/dashboard#s=p2" rel="nofollow">https://code.google.com/codejam/contest/2437488/dashboard#s=p2</a></p>\n\n<p>A quick summary of the problem is thus:</p>\n\n<p>The Great Wall of China starts out as an infinite line, where the height at all locations is $0$.</p>\n\n<p>Some number of tribes $N$, $N \\le 1000$, will attack the wall the wall according to the following parameters - a start day, $D$, a start strength $S$, a start west-coordinate, $W$, and a start east-coordinate, $E$.  This first attack occurs on day $D$, on range $[W,E]$, at strength $S$.  If there is any portion of the Great Wall within $[W,E]$ that has height $&lt; S$, the attack is successful, and at the end of the day, the wall will be built up such that any segment of it within $[W,E]$ of height $&lt; S$ would then be at height $S$ (or greater, if some other attack that day hit upon the same segment with strength $S\' &gt; S$)</p>\n\n<p>Each tribe will perform up to $1000$ attacks before retreating, and each attack will be determined iteratively from the one before it.  Every tribe has some $\\delta_D$, $\\delta_X$, and $\\delta_S$ that determines their sequence of attacks:  The will wait $\\delta_D \\ge 1$ days between attacks, they will move their attack range $\\delta_X$ units for each attack (negative = west, positive = east), though the size of the range will stay the same, and their strength will also increase/decrease by a constant value after each attack.</p>\n\n<p>The goal of the problem is, given a complete description of the attacking tribes, determine how many of their attacks will be successful.</p>\n\n<p>I managed to code a solution that does work, running in about 20 seconds:  I believe the solution I implemented takes $O(A\\log A + (A+X)\\log X)$ time, where $A =$ the total number of attacks in a simulation (max $1000000$), and $X =$ the total number of unique edge points on attack ranges (max $2000000$).</p>\n\n<p>At a high level, my solution:</p>\n\n<ul>\n<li>Reads in all the Tribe information</li>\n<li>Calculates all the unique $X$-coordinates for attack ranges - $O(A)$</li>\n<li>Represents the Wall as a lazily-updated binary tree over the $X$ ranges that tracks minimum height values.  A leaf is the span of two $X$ coordinates with nothing in-between, and all parent nodes represent the continuous interval covered by their children. - $O(X \\log X)$</li>\n<li>Generates all the Attacks every Tribe will perform, and sorts them by day - $O(A \\log A)$</li>\n<li>For each attack, see if it would be successful ($\\log X$ query time).  When the day changes, loop through all unprocessed successful attacks and update the wall accordingly ($\\log X$ update time for each attack). - $O(A\\log X)$</li>\n</ul>\n\n<p>My question is this:  Is there a way to do better than $O(A\\log A + (A+X)\\log X)$?  Perhaps, is there some strategic way to take advantage of the linear nature of Tribes\' successive attacks?  20 seconds feels too long for an intended solution (Although Java might be to blame for that)</p>\n\n<p>-- Edit --</p>\n\n<p>Looking over other discussions and successful solutions seems to indicate that the solution I\'ve described is pretty much the expected algorithm.  The slow-down in my solution is possibly just due to lazy use of auto-boxing and a pointer-based tree structure, rather than an array-based one - so I suspect that, if a solution does exist, it\'s probably not a whole lot better than what\'s here.  We shall see if anything crops up though</p>\n\n<p>-- Edit2 --</p>\n\n<p>The solution has been posted at last: <a href="https://code.google.com/codejam/contest/2437488/dashboard#s=a&amp;a=2" rel="nofollow">https://code.google.com/codejam/contest/2437488/dashboard#s=a&amp;a=2</a><br>\nIt\'s very much the same as what I have posted here; so I am much more inclined to believe that a more efficient solution does not exist.</p>\n', 'ViewCount': '344', 'Title': 'Google Code Jam Great Wall Problem', 'LastEditorUserId': '7678', 'LastActivityDate': '2013-07-14T05:43:02.910', 'LastEditDate': '2013-07-14T05:43:02.910', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7614', 'Tags': '<complexity-theory><data-structures><binary-trees>', 'CreationDate': '2013-05-15T15:26:19.040', 'FavoriteCount': '2', 'Id': '12040'}{'Body': "<p>I am trying to prove by induction  the following theorem:\nUse Induction to prove the following fact: for every integer, $N\\ge  1$ , a BST with $N$ nodes must have at least $\\log( N + 1)$ levels.\nI've proved the base case but I am struggling to figure out how to apply induction to prove for the $K+1$ case. Any suggestions would be wonderful.</p>\n", 'ViewCount': '49', 'Title': 'Proving that a BST with N>=1 nodes will have log(N+1) levels', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-11T16:27:11.647', 'LastEditDate': '2013-06-11T16:27:11.647', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8624', 'Tags': '<graph-theory><data-structures><binary-trees><induction>', 'CreationDate': '2013-06-11T16:18:32.680', 'Id': '12622'}{'Body': '<p>Working on a project for my Data Structures class. </p>\n\n<p>I\'ve implemented a Red/Black tree in Java. One of the operations required of the data structure is "find a node which has a key of at least n". The leaves of the tree are the sentinel node.</p>\n\n<p>My initial thought was using the regular search with modifications:</p>\n\n<ol><li>Search for a node with key == n</li><li>If result == sentinel, call getSuccessor on parent until a node with key > n is found</li></ol>\n\n<p>I -think- this is $O(m*lgm)$ ($m$ being number of nodes in the tree) at the worst case. </p>\n\n<p>Inspired by the getSuccessor code - if right subtree of target node is empty, find smallest ancestor which has a left child also an ancestor - was wondering if there is a better way to do this.</p>\n\n<p>Would appreciate any advice; thanks. </p>\n', 'ViewCount': '84', 'Title': 'Find node with key of at least n in a binary search tree', 'LastActivityDate': '2013-06-30T08:45:47.077', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12975', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8929', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-06-29T21:31:49.023', 'Id': '12971'}{'Body': '<p>A <em>binary sequence</em> of length $n$ is just an ordered sequence $x_1,\\ldots,x_n$ so that each $x_j$ is either $0$ or $1$. In order to generate all such binary sequences, one can use the obvious binary tree structure in the following way: the root is "empty", but each left child corresponds to the addition of $0$ to the existing string and each right child to a $1$. Now, each binary sequence is simply a path of length $n+1$ starting at the root and terminating at a leaf. </p>\n\n<p>Here\'s my question:</p>\n\n<blockquote>\n  <p>Can we do better if we only want to generate all binary strings of length $2n$ which have precisely $n$ zeros and $n$ ones?</p>\n</blockquote>\n\n<p>By "can we do better", I mean we should have lower complexity than the silly algorithm which first builds the entire tree above and then tries to find those paths with an equal number of "left" and "right" edges.</p>\n', 'ViewCount': '257', 'Title': "How does one efficiently produce all binary sequences with an equal number of 0's and 1's?", 'LastActivityDate': '2013-07-01T08:25:02.287', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12994', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8940', 'Tags': '<algorithms><graphs><binary-trees>', 'CreationDate': '2013-06-30T14:02:49.333', 'Id': '12992'}{'ViewCount': '280', 'Title': 'What linked list data structure adjustments would give me fast random lookup?', 'LastEditDate': '2013-08-07T13:56:23.087', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7284', 'FavoriteCount': '1', 'Body': "<p>I am presently using an doubly linked list (C++ <code>std::list</code>) to hold a bunch of records that each have a unique integer identifier.  The linked list is created in sorted order such that in the list, the next item always has a larger unique identifier than its predecessor.</p>\n\n<p>The issue I'm facing is that occasionally I need to be able to insert an item quickly into its  relative sorted position and using a plain linked list means this operation is $O(n)$ which is causing performance issues for me.  Generally, this would mean I want to use something like a binary tree (C++ <code>std::map</code>), however, I am also depending upon the following feature of a doubly linked list for good performance:</p>\n\n<ul>\n<li>Ability to splice a contiguous section out of one linked list into another in $O(1)$ time. (Amortized $O(1)$ or $O(\\log \\log n)$ would be good enough.)</li>\n</ul>\n\n<p>One feature of my data that I would like to leverage is that I often have long ranges of contiguous records where each one's unique integer is exactly one more than its predecessor.  When searching for an item's relative sorted position, it would always be outside such contiguous records since there are no duplicate identifiers.</p>\n\n<p>I'd like to find a replacement data structure or augmentation to a doubly linked list that will allow me to continue to splice whole sections from one list to another in constant time but allow me to locate the sorted position in which to insert a new record in better than $O(n)$ time.</p>\n\n<p>Other operations include forward and backward iteration across the items. The record indexes begin at zero and grow upwards towards 64 bits, generally sequentially, and the code works well in such cases. Occasionally some records are not available before subsequent ones, it is the insertion of these missing records that causes the performance issues now. </p>\n\n<p>One possible approach that occurs to me is to cache the location of several indexes.  The cache would get invalidated whenever a splice removes items that might overlap the cached entries.  With this cache, instead of doing a linear search, the search could instead begin from the cache point iterator whose unique index is closest to the one whose position is being  searched for.  However, I'd like to more fully utilize the feature of the contiguous records.  I also thought about a hierarchical linked list where I have a top level linked list of contiguous regions, where each region is a linked list of records that are consecutive, but I didn't see a clean way to adapt a linked list to provide this functionality.  Perhaps something like this has been done before?  I find skip lists to be close, but do not see the splice() functionality, plus a generic skip list would not leverage the fact that insertion never occurs within contiguous records.</p>\n", 'Tags': '<data-structures><time-complexity><binary-trees><linked-lists>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-08T10:37:59.160', 'CommentCount': '3', 'AcceptedAnswerId': '13646', 'CreationDate': '2013-08-05T23:00:36.700', 'Id': '13620'}{'Body': '<p>I want to know how to calculate total number of nodes in a perfect balanced binary tree with $n$ nodes in the last level. I know the answer is $2\\cdot 2^{\\log n} - 1$. Just curious how this can be calculated</p>\n', 'ViewCount': '564', 'Title': 'What is the size of the Perfect binary tree with n nodes in last level', 'LastEditorUserId': '157', 'LastActivityDate': '2013-08-06T00:48:19.433', 'LastEditDate': '2013-08-06T00:48:19.433', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9536', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2013-08-05T23:48:11.370', 'Id': '13621'}{'Body': u"<p>I am trying to figure out difference between fully- and quasi-reduced BDDs. I have read a lot of material but still it is not very clear. As I am trying to figure out the quasi reduced version for union between two BDDs.\nThe algorithm for union between two fully-reduced BDDs is </p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n   //fully-reduced version\n   local bdd r;\n1  if p=0 or q=1 then return q;\n2  if q=0 or p=1 then return p;\n3  if p=q then return p;\n4  if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n5  if p.lvl = q.lvl then\n6    r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n7  else if p.lvl &gt; q.lvl then\n8    r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q), Union(p[1], q));\n9  else since p.lvl &lt; q.lvl then\n10   r \u2190 UniqueTableInsert(q.lvl, Union(p, q[0]), Union(p, q[1]));\n11 enter\u27e8UnionCODE,{p,q}:r\u27e9inCache;\n12 return r;\n</code></pre>\n\n<p>I have read the paper <em>Binary decision diagrams in theory and practice</em> by Rolf Drechsler, Detlef Sieling for basics of BDD, and <em>Data Representation and Efficient Solution: A Decision Diagram Approach</em> by Gianfranco Ciardo for quasi-reduced and fully reduced definitions. Then I read more papers with more or less same description of quasi- and fully-reduced BDDs. In the former paper I mentioned the authors talk about reduced BDDs, I am not clear whether these BDDs are fully reduced. Quasi-reduced BDDs has no variable skipping so how come they are reduced when they have redundant nodes. I am pretty confused between BDD, quasi-reduced BDD and fully-reduced BDD. Yes, I am trying to find the difference between union algorithm for quasi-reduced and fully-reduced, for this I need to look at the quasi-reduced version of union algorithm.</p>\n\n<p>I figured out an algorithm for union of two quasi reduced BDDs <code>p</code> and <code>q</code> resulting in <code>r</code>.</p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n  local bdd r;\n1 if p=0 or q=1 then return q;\n2 if q=0 or p=1 then return p;\n3 if p=q then return p;\n4 if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n  //p.lvl = q.lvl in case of quasi reduced BDDs\n5 r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n6 enter\u27e8UnionCODE,{p,q}:r\u27e9 in Cache;\n7 return r;\n</code></pre>\n\n<p>Since there is no variable skipping, <code>p.lvl</code> is always equal to <code>q.lvl</code>. I have a question about this algorithm.</p>\n\n<p>If I want to implement Xor or Xnor for quasi-reduced BDDs, can it be done the same way as union or should I implement the expression <code>pq' + p'q</code> where <code>q' = !q</code>.</p>\n", 'ViewCount': '86', 'Title': 'Difference between fully-reduced BDD and quasi-reduced BDD', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:56:46.307', 'LastEditDate': '2013-08-13T08:56:46.307', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9556', 'Tags': '<algorithms><terminology><logic><binary-trees><bdd>', 'CreationDate': '2013-08-06T23:35:14.983', 'Id': '13637'}{'Body': u"<p>Below is an algorithm for union of two quasi reduced BDDs <code>p</code> and <code>q</code> resulting in <code>r</code>.</p>\n\n<pre><code>bdd Union(bdd p, bdd q) \n  local bdd r;\n1 if p=0 or q=1 then return q;\n2 if q=0 or p=1 then return p;\n3 if p=q then return p;\n4 if Cachecontainsentry\u27e8UnionCODE,{p,q}:r\u27e9 then return r;\n  //p.lvl = q.lvl in case of quasi reduced BDDs\n5 r \u2190 UniqueTableInsert(p.lvl, Union(p[0], q[0]), Union(p[1], q[1]));\n6 enter\u27e8UnionCODE,{p,q}:r\u27e9 in Cache;\n7 return r;\n</code></pre>\n\n<p>Since there is no variable skipping, <code>p.lvl</code> is always equal to <code>q.lvl</code>. I have a question about this algorithm.</p>\n\n<p>If I want to implement Xor or Xnor for quasi-reduced BDDs, can it be done the same way as union or should I implement the expression <code>pq' + p'q</code> where <code>q' = !q</code>.</p>\n", 'ViewCount': '21', 'ClosedDate': '2013-08-13T08:54:25.437', 'Title': 'Can xor and xnor for quasi-reduced BDDs be implemented just like union?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:19:40.103', 'LastEditDate': '2013-08-13T08:19:40.103', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9598', 'Tags': '<algorithms><logic><binary-trees>', 'CreationDate': '2013-08-13T02:32:32.443', 'Id': '13722'}{'Body': u'<p>How can I write an algorithm which inverts a 2-level BDD? It should take as input a 2L-level quasi-reduced BDD rooted at $r$ encoding a relation $R : B^L \u2192 2^{B^L}$ and returns the 2L-level quasi-reduced BDD rooted at $s$ encoding the relation $R^{\u22121} : B^L \u21922^{B^L}$, that is, $j \\in R(i) \\iff i \\in R^{\u22121}(j)$.</p>\n', 'ViewCount': '39', 'Title': 'Inversion of BDD', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T08:20:09.527', 'LastEditDate': '2013-08-13T08:20:09.527', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9598', 'Tags': '<algorithms><logic><binary-trees>', 'CreationDate': '2013-08-13T03:47:07.090', 'Id': '13723'}{'Body': '<p>When inserting an item into a splay tree, rotations are performed in pairs based on either a zig-zag or zig-zig pattern. When there is an odd number of rotations to be performed, one could either do the extra rotation beginning at the leaf or save the extra rotation and do it at the root. Does it matter?</p>\n\n<p>For example, in the attached image I insert a 4 into a BST, and "splay it"\nit to the root. On the top of the figure, I first locate the zig-zig pair \nat the leaf node and perform the zig-zag splay from the bottom leaving a final right rotation at the root. At the bottom of the figure, I first do the odd rotation starting from the leaf, and the then do a zig-zig splay to the root.</p>\n\n<p>Which is correct? Or  will both lead to the usual splay-tree performance?</p>\n\n<p><img src="http://i.stack.imgur.com/CNSAZ.png" alt="two ways to splay for odd number of rotations"></p>\n', 'ViewCount': '186', 'Title': 'Splay tree with odd number of rotations', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-03-01T08:50:13.433', 'LastEditDate': '2013-09-08T10:02:30.483', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '10033', 'Tags': '<data-structures><binary-trees><splay-trees>', 'CreationDate': '2013-09-07T20:35:21.943', 'FavoriteCount': '1', 'Id': '14200'}{'Body': '<p>Could somebody explain to me why the height of a  weight balanced  binary tree in $O(\\log n)$ in the worst case?</p>\n', 'ViewCount': '109', 'Title': 'Why the height of the weight balanced tree is logarithmic', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-09-23T06:26:36.727', 'LastEditDate': '2013-09-22T19:10:46.167', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10275', 'Tags': '<binary-trees><trees>', 'CreationDate': '2013-09-22T17:22:27.090', 'FavoriteCount': '1', 'Id': '14520'}{'Body': "<p>I am stumped as to how to print the longest path from the root of a binary tree to a leaf, essentially traversing the height of the tree. I've got the following for finding the height of a binary tree:</p>\n\n<pre><code>if (root == null) {\n    return -1;\n}\n\nreturn 1 + (Math.max(heightOfTree(root.leftNode), heightOfTree(root.rightNode)));\n</code></pre>\n\n<p>This easily finds the height of the tree but doesn't lend itself to actually figuring out which nodes should be printed out. I could go about finding the nodes's value that is at the leaf, and then do a find for that particular node, but that seems inefficient. </p>\n\n<pre><code>        A\n      B   C\n    D  E F  G\n             H\n</code></pre>\n\n<p>For example, the height of this binary tree is 3, and I would ideally like to know the path to take, in this case it would be A, C, G, H. I know that I most likely need to keep an array for the path, but I just can't seem to find a solution that isn't terribly inefficient. </p>\n", 'ViewCount': '955', 'ClosedDate': '2013-10-28T20:58:32.103', 'Title': 'Printing The Longest Path from Root to Leaf in Binary Tree', 'LastActivityDate': '2013-10-02T20:46:24.137', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10399', 'Tags': '<binary-trees><recursion>', 'CreationDate': '2013-09-29T23:35:34.197', 'Id': '14687'}{'Body': '<p>I have the following problem:</p>\n\n<blockquote>\n  <p>Does inserting a node into a red-black tree and then immediately deleting it always result in the original tree? Prove that it does or give a counter-example if it does not. Does deleting a leaf node from a red-black tree, then reinserting the same node always result in the original tree? Prove that it does or give a counter-example if it does not.</p>\n</blockquote>\n\n<p>I have used several demos, but none of them have made much sense to answer this question. I havent been sure as to yes or no, I am still new to binary trees.</p>\n', 'ViewCount': '141', 'Title': 'Does inserting and immediately removing a node change a red-black tree?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T15:26:08.840', 'LastEditDate': '2013-10-04T07:00:36.170', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10497', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2013-10-04T05:02:22.753', 'Id': '14804'}{'Body': "<p>Does anybody know how would I approach calculating the maximum number of 1 child nodes (nodes that have exactly 1 child) in a binary tree with n nodes. Please don't give me the actual answer as this is one of the homework problems, I would like to solve it by myself, but I simply don't know where to start. Any help is apreciated.</p>\n", 'ViewCount': '150', 'Title': 'Number of 1 child nodes in a binary tree', 'LastEditorUserId': '10511', 'LastActivityDate': '2013-10-05T00:07:11.277', 'LastEditDate': '2013-10-05T00:00:32.300', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '14818', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<binary-trees>', 'CreationDate': '2013-10-04T23:53:38.153', 'Id': '14817'}{'Body': '<p>I want to flatten a binary tree into a linear array, and I wonder if there are specific algorithms to improve locality in the linearized representation (for instance, ensuring that all data from the left child of the root node appears before the data from the right child is an easy optimization.) What is the recommended approach to maintain high locality?</p>\n', 'ViewCount': '78', 'Title': 'Tree flattening with layout guarantees', 'LastActivityDate': '2013-10-16T14:15:15.257', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '16136', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10792', 'Tags': '<binary-trees><performance>', 'CreationDate': '2013-10-16T12:44:44.580', 'Id': '16134'}{'Body': '<p>I\'m looking at the lecture review for one of my computer science classes and I\'m having trouble coming up with an answer. Could someone help me work through it?</p>\n\n<p>Background: </p>\n\n<p>Let the balance factor of a node be defined by $\\left| height(\\text{right sub tree}) - height(\\text{left sub tree}) \\right|$.</p>\n\n<p>Questions:</p>\n\n<ol>\n<li><strong>Give the balance factor for the nodes in slides 27-30 (given below)</strong></li>\n<li><strong>Instead of storing the heights of the nodes, can we store the balance factors of the nodes and update an AVL tree (for insertion and deletion) based on this information?</strong></li>\n</ol>\n\n<p>Here are the relevant slides: </p>\n\n<p><img src="http://i.stack.imgur.com/LusSW.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/wuUdi.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/47jDV.png" alt="enter image description here">\n<img src="http://i.stack.imgur.com/P8w2s.png" alt="enter image description here"></p>\n', 'ViewCount': '118', 'Title': 'Updating an AVL Tree Based On Balance Factors', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-21T19:44:13.303', 'LastEditDate': '2013-10-21T19:44:13.303', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<binary-trees><trees><search-trees>', 'CreationDate': '2013-10-21T19:14:25.870', 'Id': '16313'}{'Body': '<p>I know how a BIT works. But I was wondering if a BIT can be used to find the minimum/maximum element in the complete range, or more specifically, to find the minimum (or maximum) value after all the update processes have been completed. Now, I know that this can very well be achieved using Segment Trees, but is it possible to do the same using a BIT?</p>\n\n<p>I know the obvious way of traversing the complete BIT and calculating the value at each index. I am looking for a more efficient/optimized way.</p>\n', 'ViewCount': '178', 'Title': 'Finding minimum/maximum value in a Binary Indexed Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T10:12:11.680', 'LastEditDate': '2013-11-02T10:12:11.680', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11119', 'Tags': '<data-structures><binary-trees>', 'CreationDate': '2013-11-01T14:37:26.980', 'FavoriteCount': '2', 'Id': '16620'}{'Body': "<p>I'm studying for my CS final and I can't seem to get the anywhere with one of the questions.</p>\n\n<p>This is the question:</p>\n\n<p>Prove that if a node in a BST has a successor, but has no right child, then its successor must be an ancestor. (We will consider only BSTs with distinct elements.)</p>\n\n<p>I know that a successor is the node that replaces the deleted node, and that we only need to worry about this case when the node being deleted has two children, but I can't seem to start this proof.</p>\n\n<p>Any help?</p>\n", 'ViewCount': '51', 'Title': 'BST Successor Proof', 'LastActivityDate': '2013-12-02T17:27:33.667', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<proof-techniques><binary-trees><binary-search>', 'CreationDate': '2013-12-01T22:36:10.517', 'FavoriteCount': '1', 'Id': '18512'}{'Body': '<p>Consider this tree:</p>\n\n<p><img src="http://i.stack.imgur.com/cMslZ.png" alt="Simple binary tree"></p>\n\n<p>If I traverse it using post-order, I\'d start at <em>B</em> (as it is the leftmost leaf) and that\'s where my misunderstanding begins. I know <em>B</em> is the first and <em>A</em> will be the last node in post order, as the rule is left-right-root. One of my university professors said the correct answer for the post-order traversal of a tree similar to the one above would be <strong><em>B</em>, <em>C</em>, <em>D</em>, <em>E</em>, <em>A</em></strong>, but in my understanding, it should be <strong><em>B</em>, <em>D</em>, <em>E</em>, <em>C</em>, <em>A</em></strong>.  </p>\n\n<p>Am I getting it wrong? Shouldn\'t I evaluate <em>(C,D),(C,E)</em> as a subtree and then go back to the parent tree?</p>\n', 'ViewCount': '40', 'Title': "Doesn't post-order traversal require subtrees to be evaluated separately?", 'LastEditorUserId': '12111', 'LastActivityDate': '2013-12-14T19:07:44.407', 'LastEditDate': '2013-12-14T19:07:44.407', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18988', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12111', 'Tags': '<data-structures><binary-trees><search-algorithms><trees><search-trees>', 'CreationDate': '2013-12-14T17:40:35.087', 'Id': '18987'}{'Body': '<p>Im learning the delete operation on <a href="http://www.cs.princeton.edu/~rs/talks/LLRB/08Dagstuhl/RedBlack.pdf" rel="nofollow">Left-leaning Red Black Tree</a> invented by Prof. Sedgewick. In delete operation, a node could be only deleted from a 3-node or a 4-node but 2-node. In order to ensure we dont end up at 2-node, we push the red link down when both the left and left of left of this node are black (if the cmp &lt; 0) by the code below</p>\n\n<pre><code>// Assuming that h is red and both h.left and h.left.left\n// are black, make h.left or one of its children red.\nprivate Node moveRedLeft(Node h) {\n    assert (h != null);\n    assert isRed(h) &amp;&amp; !isRed(h.left) &amp;&amp; !isRed(h.left.left);\n\n    flipColors(h);\n    if (isRed(h.right.left)) { \n        h.right = rotateRight(h.right);\n        h = rotateLeft(h);\n    }\n    return h;\n}\n</code></pre>\n\n<p>The fact is before we invoke this function, there is not any check if this node is red. So, This must be one of the characters of LLRB. Actually the image below just show this.</p>\n\n<p><img src="http://i.stack.imgur.com/FazCz.png" alt="one possible llrb tree"></p>\n\n<p>But how to prove this?</p>\n', 'ViewCount': '35', 'Title': 'LLRB Tree How to prove if left and left of left node are black, then this node must be a red node?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-13T19:09:14.983', 'LastEditDate': '2014-01-13T19:09:14.983', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12804', 'Tags': '<data-structures><binary-trees><search-trees>', 'CreationDate': '2014-01-13T16:07:25.153', 'Id': '19696'}{'Body': "<p>For a binary tree we define horizontal distance as follows:</p>\n\n<pre><code>    Horizontal distance(hd) of root = 0\n    If you go left then hd = hd(of its parent)-1, and \n    if you go right then hd = hd(of its parent)+1.\n</code></pre>\n\n<p>The bottom view of a tree then consists of all the nodes of the tree, where there is no node with the same <code>hd</code> and a greater level. (There may be multiple such nodes for a given value of <code>hd</code>. In this case all of them belong to the bottom view.) I'm looking for an algorithm that outputs the bottom view of a tree.</p>\n\n<hr>\n\n<p>Examples:</p>\n\n<p>Suppose the binary tree is:</p>\n\n<pre><code>         1\n        /  \\\n       2    3\n      / \\  / \\\n     4   5 6  7\n            \\\n             8\n</code></pre>\n\n<p>Bottom view of the tree is: 4 2 5 6 8 7</p>\n\n<pre><code>    Ok so for the first example,\n    Horizontal distance of node with value 1: 0, level = 1\n    Horizontal distance of node with value 2: 0 - 1 = -1, level = 2\n    Horizontal distance of node with value 3: 0 + 1 = 1, level = 2\n    Horizontal distance of node with value 4: -1 - 1 = -2, level = 3\n    Horizontal distance of node with value 5: -1 + 1 = 0, level = 3\n    Horizontal distance of node with value 6: 1 - 1 = 0, level = 3\n    Horizontal distance of node with value 7: 1 + 1 = 2, level = 3\n    Horizontal distance of node with value 8: 0 + 1 = 1, level = 4\n\n    So for each vertical line that is for hd=0, print those nodes which appear in the last level of that line.\n    So for hd = -2, print 4\n    for hd = -1, print 2\n    for hd = 0, print 5 and 6 because they both appear in the last level of that vertical line\n    for hd = 1, print 8\n    for hd = 2, print 7\n</code></pre>\n\n<p>One more example for reference :</p>\n\n<pre><code>         1\n      /     \\\n    2         3\n   / \\       / \\\n  4   5     6     7 \n / \\ / \\   / \\    / \\\n8  9 10 11 12 13 14 15     \n</code></pre>\n\n<p>So the output for this will be :\n8 4 9 10 12 5 6 11 13 14 7 15</p>\n\n<pre><code>Similarly for this example\nhd of node with value 1: 0, , level = 1\nhd of node with value 2: -1, level = 2\nhd of node with value 3: 1, level = 2\nhd of node with value 4: -2, level = 3\nhd of node with value 5: 0, , level = 3\nhd of node with value 6: 0, level = 3\nhd of node with value 7: 2, level = 3\nhd of node with value 8: -3, level = 4\nhd of node with value 9: -1, level = 4\nhd of node with value 10: -1, level = 4\nhd of node with value 11: 1, level = 4\nhd of node with value 12: -1, level = 4\nhd of node with value 13: 1, level = 4\nhd of node with value 14: 1, level = 4\nhd of node with value 15: 3, level = 4\n\nSo, the output will be:\nhd = -3, print 8\nhd = -2, print 4\nhd = -1, print 9 10 12\nhd = 0, print 5 6\nhd = 1, print 11 13 14\nhd = 2, print 7\nhd = 3, print 15 \n\nSo the ouput will be:\n8 4 9 10 12 5 6 11 13 14 7 15\n</code></pre>\n\n<hr>\n\n<p>I already know a method in which I can do it using a lot of extra space (a map, and a 1-D array for storing the level of the last element in that vertical line) and with time complexity of $O(N \\log N)$.\nAnd this is the implementation of this method:</p>\n\n<pre><code>void printBottom(Node *node, int level, int hd, int min, map&lt; int, vector&lt;int&gt; &gt;&amp; visited, int lev[], int l)\n{\n     if(node == NULL)\n             return;\n     if(level == 1){\n              if(lev[hd-min] == 0 || lev[hd-min] == l){\n                      lev[hd-min] = l;\n                      visited[hd-min].push_back(node-&gt;data);\n              }\n     }\n     else if(level &gt; 1)\n     {\n          printBottom(node-&gt;left, level-1, hd-1, min, visited, lev, l);\n          printBottom(node-&gt;right, level-1, hd+1, min, visited, lev, l);\n     }\n}\n\n\nint main()\n{\n    find the minimum and maximum values for hd via DFS\n\n    int lev[max-min+1]; //lev[hd] contains the maximum level for which we have found nodes with this value of hd; initialized with 0's\n\n    map &lt; int, vector&lt;int&gt; &gt; visited; //the nodes in the bottom view\n\n    int h = height(root);\n\n    for (int i=h; i&gt;0; i--){\n        printBottom(root, i, 0, min, visited, lev, i);\n    }\n\n    output visited\n}\n</code></pre>\n\n<p>I am seeking help to do this in more optimized way, which used less space or time. Is there any other efficient method for this problem?</p>\n", 'ViewCount': '279', 'Title': 'Print bottom view of a binary tree', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-21T11:07:00.120', 'LastEditDate': '2014-03-20T11:18:18.890', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22899', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15862', 'Tags': '<algorithms><binary-trees>', 'CreationDate': '2014-03-19T10:10:45.850', 'Id': '22801'}{'Body': u"<p>This is a Discrete Math/Combinatorics Question from my hw\u2026but I don't really understand the question.</p>\n\n<blockquote>\n  <p>Find largest chromatic number of a full binary tree given the following depths: (Check all that apply)</p>\n  \n  <p>T2 T3 T7 T12 T200</p>\n</blockquote>\n\n<p>I understand that the chromatic number refers to the minimum color that you can color a graph or tree with the adjacent nodes or vertices being different colors.</p>\n\n<p>So knowing this fact... I'm sure that the chromatic number for all full binary trees should be 2 since you can use two different color nodes to completely color the tree? But they want me to find the largest chromatic number. I'm just confused.</p>\n", 'ViewCount': '94', 'ClosedDate': '2014-04-01T22:00:40.957', 'Title': 'Find largest chromatic number of a full binary tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T05:10:33.807', 'LastEditDate': '2014-03-21T21:11:42.240', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'Ace', 'PostTypeId': '1', 'Tags': '<graph-theory><binary-trees><trees><discrete-mathematics><colorings>', 'CreationDate': '2014-03-21T03:15:36.973', 'Id': '22906'}{'Body': '<p>I was trying to understand the concept of Max-Heap. And to my understanding its a complete binary tree and each parent has a value greater than its children.The example I was going though had the following array which it said was a Max-Heap.</p>\n\n<pre><code>BookArray [] = {45,10,11,3,2,7,9,1,0}\n</code></pre>\n\n<p>I then decided to shuffle the elements (so they are no longer in binary heap) and got this.</p>\n\n<pre><code>Shuffled[] = {11,1,0,7,9,3,2,10,45}\n</code></pre>\n\n<p>I then decided to write a program that would sort the elements in the array in Min-Heap\nso I got this array</p>\n\n<pre><code>Sorted[] = {45,11,3,10,7,0,2,1,9}\n</code></pre>\n\n<p>My question is if my sorted array is also a valid max-heap ? since my array does not match the bookArray</p>\n', 'ViewCount': '34', 'Title': 'Is this a proper Max Heap Data Structure', 'LastEditorUserId': '2421', 'LastActivityDate': '2014-03-22T19:19:23.603', 'LastEditDate': '2014-03-22T18:30:06.260', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22943', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2421', 'Tags': '<data-structures><binary-trees><heaps>', 'CreationDate': '2014-03-22T17:50:21.793', 'Id': '22941'}{'Body': '<p>I am having trouble in understanding <a href="http://en.wikipedia.org/wiki/Order_statistic_tree" rel="nofollow">order-statistics tree</a> .   </p>\n\n<p><strong>Definition :</strong><br>\nEvery node in tree stores the number of descendants of itself .<br>\nCan you please explain the Algorithm or pseudocode how to <strong>Insert</strong> and <strong>Delete</strong> a node in the tree <strong>when tree is to be balanced</strong> .  </p>\n\n<p>Basically i want to find the rank of an element in the tree in <strong>O(log N)</strong> time complexity and nodes can be inserted and deleted in between querries .  </p>\n\n<p>P.S. I am able to understand the <strong>rank(x)</strong> operation .</p>\n', 'ViewCount': '36', 'Title': 'insert and delete in order statistic tree', 'LastEditorUserId': '635', 'LastActivityDate': '2014-03-27T03:22:10.707', 'LastEditDate': '2014-03-27T03:22:10.707', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '16107', 'Tags': '<algorithms><data-structures><binary-trees>', 'CreationDate': '2014-03-26T13:08:12.103', 'Id': '23073'}{'Body': '<p>I\'m studying for my finals and I can across this statement.</p>\n\n<p>"For a fixed set of (unique) keys, any binary search tree containing those keys can\nbe converted to any other BST on the same set of keys via a sequence of left- and/or right-\nrotations."</p>\n\n<p>I\'m interested in a proof. Does anyone know any references?</p>\n', 'ViewCount': '78', 'Title': 'Unique keys in a binary search tree', 'LastActivityDate': '2014-04-10T16:49:59.190', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15826', 'Tags': '<algorithms><algorithm-analysis><binary-trees>', 'CreationDate': '2014-04-06T18:43:38.257', 'Id': '23481'}