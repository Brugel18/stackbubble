176_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have written a program to sort Linked Lists and I noticed that my insertion sort works much better than my quicksort algorithm. \nDoes anyone have any idea why this is?\nInsertion sort has a complexity of $\\Theta(n^2)$ and quicksort $O(n\\log n)$ so therefore quicksort should be faster. I tried for random input size and it shows me the contrary. Strange...</p>\n\n<p>Here the code in Java:</p>\n\n\n\n<pre><code>public static LinkedList qSort(LinkedList list) {\n\n    LinkedList x, y;\n    Node currentNode;\n    int size = list.getSize();\n\n    //Create new lists x smaller equal and y greater\n    x = new LinkedList();\n    y = new LinkedList();\n\n    if (size &lt;= 1)\n        return list;\n    else {\n\n        Node pivot = getPivot(list);\n        // System.out.println("Pivot: " + pivot.value);     \n        //We start from the head\n        currentNode = list.head;\n\n        for (int i = 0; i &lt;= size - 1; i++) {\n            //Check that the currentNode is not our pivot\n            if (currentNode != pivot) {\n                //Nodes with values smaller equal than the pivot goes in x\n                if (currentNode.value &lt;= pivot.value) {\n                    {\n                        x.addNode(currentNode.value);\n                        // System.out.print("Elements in x:");\n                        // x.printList();\n                    }\n\n                } \n                //Nodes with values greater than the pivot goes in y\n                else if (currentNode.value &gt; pivot.value) {\n                    if (currentNode != pivot) {\n                        y.addNode(currentNode.value);\n                        // System.out.print("Elements in y:");\n                        // y.printList();\n                    }\n                }\n            }\n            //Set the pointer to the next node\n            currentNode = currentNode.next;\n        }\n\n        //Recursive calls and concatenation of the Lists and pivot\n        return concatenateList(qSort(x), pivot, qSort(y));\n\n    }\n}\n</code></pre>\n', 'ViewCount': '3274', 'Title': 'Quicksort vs. insertion sort on linked list: performance', 'LastEditorUserId': '1011', 'LastActivityDate': '2013-02-01T13:07:24.713', 'LastEditDate': '2012-04-20T07:08:17.467', 'AnswerCount': '3', 'CommentCount': '6', 'AcceptedAnswerId': '1386', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<algorithms><algorithm-analysis><sorting><lists>', 'CreationDate': '2012-04-19T12:05:13.983', 'Id': '1354'},176_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m trying to find the best algorithm for converting an \u201cordinary\u201d linked list into an \u201cideal" skip list. </p>\n\n<p>The definition of an \u201cideal skip list\u201d is that in the first level we\'ll have all the elements, half of them in the next level, a quarter of them in the level after that, and so on.</p>\n\n<p>I\'m thinking about a $\\mathcal{O}(n)$ run-time algorithm involving throwing a coin for each node in the original linked-list, to determine for any given node whether it should be placed in a higher or lower level, and create a duplicate node for the current node at a higher level. This algorithm should work in $\\mathcal{O}(n)$; is there any better algorithm? </p>\n', 'ViewCount': '302', 'Title': 'Building ideal skip lists', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-16T14:45:04.503', 'LastEditDate': '2012-05-09T10:47:32.457', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '776', 'Tags': '<algorithms><data-structures><randomized-algorithms><lists>', 'CreationDate': '2012-04-30T13:03:01.867', 'FavoriteCount': '1', 'Id': '1589'},176_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>For a given planar graph $G(V,E)$ embedded in the plane, defined by list of segments $E= \\left \\{ e_1,...,e_m \\right \\} $, each segment $e_i$ is represented by its endpoints $\\left \\{ L_i,R_i \\right \\}$. Construct a DCEL data structure for the planar subdivision, describe an algorithm, prove it\'s  correctness and show the complexity.</p>\n</blockquote>\n\n<p>More information about DCEL (double connected edge list) you can find on <a href="http://en.wikipedia.org/wiki/DCEL" rel="nofollow">wikipedia - DCEL</a>.</p>\n\n<p>According to description of DCEL and connections between different objects of DCEL (vertices, edges and faces) the required data structure must be complicated.</p>\n\n<p>I found that <em>doubly-linked lists</em> can be used as data structure for DCEL, I am not sure how to build and maintain connections between vertices - edges and edges - faces.</p>\n\n<p>I tried to find any hint in textbook, but the construction of DCEL wasn\'t described, map overlay is more popular topic.</p>\n\n<p>Regarding the algorithm, plane sweep algorithm with $O((n+l)\\log n)$ should do the job, but it seems to be overkill, because segments are intersected not in arbitrary points, but only in endpoints, therefore $O(n\\log n)$ seems more reasonable.</p>\n\n<p>The main problem is the data structure, so far I haven\'t seen any good example with at least similar complexity.</p>\n\n<p>Please, if you have any idea about a data structure for DCEL or about algorithm for constructing DCEL, share it with us.</p>\n', 'ViewCount': '1495', 'Title': 'Constructing of Double Connected Edge List (DCEL)', 'LastEditorUserId': '1379', 'LastActivityDate': '2013-09-22T03:25:45.343', 'LastEditDate': '2012-06-22T15:37:35.383', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2516', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1379', 'Tags': '<algorithms><data-structures><computational-geometry><lists>', 'CreationDate': '2012-06-22T12:58:26.957', 'Id': '2450'},176_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The <a href="http://en.wikipedia.org/wiki/XOR_linked_list" rel="nofollow">XOR linked list</a> is perhaps the most prominent example of storing a reversible hash of two values and using a known value and the stored hash value to derive the other value.  Is there a term for the general mechanism (or a way to describe it very concisely)?</p>\n\n<p>As a related question, are there other somewhat recognized examples of using this mechanism?</p>\n\n<p>In informally studying computer architecture, I have encountered what I think are two or three examples.  One was a suggestion for a MRU-based cache way predictor by XORing the MRU bit with a bit derived from the address; the derived bit is the "known" value.  The other was a similar, XORing the hysteresis bit of a branch predictor with a bit derived from branch information.  A possible third example might be the agree branch predictor which uses a (possibly static) per-branch prediction to bias entries in a dynamic predictor so that aliasing tends to be non-destructive.  A confirmation that these actually should be recognized as the same general mechanism as used by the XOR linked list would also be helpful.</p>\n', 'ViewCount': '63', 'Title': 'Is there a term for the general method used in XORed linked list?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-30T19:21:20.813', 'LastEditDate': '2013-01-30T12:44:52.830', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4577', 'Tags': '<terminology><reference-request><data-structures><lists>', 'CreationDate': '2013-01-29T19:59:22.903', 'FavoriteCount': '3', 'Id': '9284'},176_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<h3>Background:</h3>\n\n<p>In this question we care only about worst-case running-time.</p>\n\n<p>Array and (doubly) linked lists can be used to keep a list of items and implement the <strong><a href="http://en.wikipedia.org/wiki/Vector_data_structure#Efficiency_comparison_with_other_data_structures">vector</a></strong> abstract data type. Consider the following three operations:</p>\n\n<ul>\n<li>$Location(i)$: returns a pointer to the $i$th item in the list of items in the array.</li>\n<li>$Insert(k,x)$: insert the item $k$ in the list after the item pointed to by $x$.</li>\n<li>$Delete(x)$: remove the item in the list pointed to by $x$.</li>\n</ul>\n\n<p>The main operation that an <strong>array</strong> provides is location which can be computed in constant time. However delete and insert are inefficient.</p>\n\n<p>On the other hand, in a <strong>doubly linked list</strong>, it is easy to perform insert and delete in constant time, but location is inefficient.</p>\n\n<h3>Questions:</h3>\n\n<p>Can there be a data structure to store a list of items where all three operations are $O(1)$? If not, what is the best worst-case running-time that we can achieve for all operations simultaneously? </p>\n\n<p>Note that a balanced binary search tree like red-black trees augmented with size of subtrees would give $O(\\lg n)$, is it possible to do better? Do we know a non-trivial lower-bound for this problem?</p>\n', 'ViewCount': '136', 'ClosedDate': '2013-03-01T18:52:59.140', 'Title': 'Is there a data-structure which is more efficient than both arrays and linked lists?', 'LastActivityDate': '2013-02-26T01:06:49.737', 'AnswerCount': '0', 'CommentCount': '17', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<data-structures><arrays><lower-bounds><linked-lists>', 'CreationDate': '2013-02-26T01:06:49.737', 'Id': '10111'},176_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am seeking help understanding Floyd\'s cycle detection algorithm. I have gone through the explanation on wikipedia (<a href="http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare" rel="nofollow">http://en.wikipedia.org/wiki/Cycle_detection#Tortoise_and_hare</a>)</p>\n\n<p>I can see how the algorithm detects cycle in O(n) time. However, I am unable to visualise the fact that once the tortoise and hare pointers meet for the first time, the start of the cycle can be determined by moving tortoise pointer back to start and then moving both tortoise and hare one step at a time. The point where they first meet is the start of the cycle.</p>\n\n<p>Can someone help by providing an explanation, hopefully different from the one on wikipedia, as I am unable to understand/visualise it?</p>\n', 'ViewCount': '3398', 'Title': "Floyd's Cycle detection algorithm | Determining the starting point of cycle", 'LastActivityDate': '2013-03-07T12:24:41.433', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7183', 'Tags': '<algorithms><linked-lists>', 'CreationDate': '2013-03-07T12:24:41.433', 'Id': '10360'},176_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1073', 'Title': 'Implement queue with a linked list; why would it be bad to insert at the head and remove at the tail?', 'LastEditDate': '2013-03-10T19:51:55.500', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '1', 'Body': '<p>In my textbook, Data Structures and Algorithms in Java, the author says when implementing a queue using a linked list you choose the front of the queue to be at the head of the list, and the rear of the queue to be at the tail of the list. In this way, you remove from the head and insert at the tail.</p>\n\n<p>The author then asks cryptically, "Why would it be bad to insert at the head and remove at the tail?" without providing an answer.</p>\n\n<p>I can\'t see what the difference really is. In effect, "Head" and "Tail" are just arbitrary names we define. What would be so bad if to enqueue() we add a head and create a reference to the old head, and to dequeue() we take from the tail and move the tail over?</p>\n\n<p>What is the answer to the author\'s question?</p>\n', 'Tags': '<time-complexity><linked-lists><abstract-data-types>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-10T19:51:55.500', 'CommentCount': '0', 'AcceptedAnswerId': '10435', 'CreationDate': '2013-03-10T19:10:25.620', 'Id': '10434'},176_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In a circular linked list, if an elements needs to be inserted at front [just before the node pointed by head], can be done in O(1) (see the answer <a href="http://stackoverflow.com/questions/1096505/implement-an-algorithm-to-insert-a-node-into-a-circular-linked-list-without-trav">here</a>)</p>\n\n<p>But in a book currently, I have, it is mentioned that it is done in O(n) (the usual method). I also saw few lecture ppts, they all mention the usual method of traversing the list &amp; adding an element.</p>\n\n<p>My question is :</p>\n\n<ol>\n<li><p>In practical scenarios which method is used ?</p></li>\n<li><p>I am about to attend an exam, which consists of MCQs, if above question is asked shall I mark O(n), since that is the standard answer ?</p></li>\n</ol>\n', 'ViewCount': '452', 'Title': 'Complexity of algorithm inserting an element in a circular linked list at the front end', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-23T16:37:13.557', 'LastEditDate': '2013-03-23T15:58:50.753', 'AnswerCount': '1', 'CommentCount': '12', 'AcceptedAnswerId': '10704', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Tags': '<data-structures><efficiency><linked-lists>', 'CreationDate': '2013-03-23T09:26:46.557', 'Id': '10701'},176_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an issue for which I am looking for an algorithm (if it exists)</p>\n\n<p>What I have:\nAn array of items which have certain properties, e.g. item $A$ has properties $x$ and $y$.</p>\n\n<p>Example: $[ A(x,y), B(x,y), C(x,y), D(x,y), E(x,y) ]$</p>\n\n<p>What I want:\nA result list consisting of elements of the original list, such as $[ A(x,y), C(x,y), E(x,y) ]$, for which the following properties are true:</p>\n\n<ul>\n<li>No reordering of elements, they are in the same order as the original list</li>\n<li>The result has the maximum number of elements, i.e. the longest 'path' possible</li>\n<li>For each pair of consecutive items $(A(x,y), B(x,y))$ in the result, $A.x \\lt B.y$. In other words, an item's $x$ must be less than the next item's $y$.</li>\n</ul>\n\n<p>Complexity: The list in the case I have is about 35 items long, so an algorithm which is $O(n!)$ might not work.</p>\n\n<p>Does such an algorithm exist?</p>\n", 'ViewCount': '102', 'Title': 'Longest subsequence such that A[i].x < A[i+1].y', 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-27T11:03:43.220', 'LastEditDate': '2013-06-20T09:33:57.090', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8755', 'Tags': '<algorithms><sorting><subsequences><lists>', 'CreationDate': '2013-06-19T15:27:23.673', 'FavoriteCount': '1', 'Id': '12764'},176_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><strong>The Question:</strong> You are given a singly-linked list with <em>n</em> nodes that you can only iterate through once at most. You are given additional space to store one node (i.e. a pointer to it).  Devise an algorithm that can operate under these conditions, choose/select one node from the list such that the the probability of each node being selected/chosen is equal.</p>\n\n<p><strong>My Friend\'s Solution:</strong> </p>\n\n<ol>\n<li>Store the first node in the additional space. </li>\n<li>Move to the next node.</li>\n<li>Randomly select one node between the one in the additional space and the current node. </li>\n<li>Store this "winner" in the additional space.</li>\n<li>Repeat steps 2-4 until the last node in the list is processed.</li>\n<li>The node stored in the additional space at the end is the one that the algorithm selects.</li>\n</ol>\n\n<p><strong>My Issue With My Friend\'s Solution:</strong> Consider the case <em>n</em> = 3. There are 2^*(n-1) = 2^2 = 4 possible ways to go through the list in terms of which node is selected during each iteration of the algorithm:</p>\n\n<ol>\n<li>Select 1 -> from (1, 2) select 1 -> from (1, 3) select 1 -> 1 is finally selected</li>\n<li>Select 1 -> from (1, 2) select 1 -> from (1, 3) select 3 -> 3 is finally selected</li>\n<li>Select 1 -> from (1, 2) select 2 -> from (2, 3) select 3 -> 3 is finally selected</li>\n<li>Select 1 -> from (1, 2) select 2 -> from (2, 3) select 2 -> 2 is finally selected</li>\n</ol>\n\n<p>Then, node 3 has a 50% chance of being selected, whereas nodes 1 and 2 each have a 25% chance of being selected. </p>\n\n<p>Intuitively, this makes sense to me; if the first node is not selected while the beginning of the list is being processed, it can never be the one that is finally selected. However, the last node still has a chance of being selected no matter what happens while processing the the rest of the list that comes before the last node.</p>\n\n<p>However, my friend says that my issue with his solution is inconsequential because I didn\'t model the situation correctly. Can someone tell me where I went wrong?</p>\n', 'ViewCount': '147', 'Title': 'Selecting a node of a singly-linked list such that the probability of each node being selected is equal', 'LastActivityDate': '2013-08-09T19:02:48.780', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9116', 'Tags': '<linked-lists>', 'CreationDate': '2013-07-10T16:46:03.893', 'Id': '13205'},176_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assume that we have an operation $f$ such that\n$$\nf([a_0,\\ldots, a_n])= [f(a_0),\\ldots,f(a_n)]\n$$</p>\n\n<p>Do we say that $f$ distributes over lits or do we say it commutes with lists?\nWhich one is the correct way of expressing this property?</p>\n\n<p>How about the following? \nWhat do we say for the relation between $f$ and $\\vec{a} = a_0,\\ldots,a_n$?\n$$\nf(g(\\vec{a})) = g(f(\\vec{a})) = g(f(a_0),\\ldots,f(a_n))\n$$</p>\n', 'ViewCount': '73', 'Title': 'Does a function distribute over lists or does it commute with them?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-07-11T12:42:11.520', 'LastEditDate': '2013-07-11T12:42:11.520', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<terminology><programming-languages><lists>', 'CreationDate': '2013-07-11T09:22:04.607', 'Id': '13226'},176_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '280', 'Title': 'What linked list data structure adjustments would give me fast random lookup?', 'LastEditDate': '2013-08-07T13:56:23.087', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7284', 'FavoriteCount': '1', 'Body': "<p>I am presently using an doubly linked list (C++ <code>std::list</code>) to hold a bunch of records that each have a unique integer identifier.  The linked list is created in sorted order such that in the list, the next item always has a larger unique identifier than its predecessor.</p>\n\n<p>The issue I'm facing is that occasionally I need to be able to insert an item quickly into its  relative sorted position and using a plain linked list means this operation is $O(n)$ which is causing performance issues for me.  Generally, this would mean I want to use something like a binary tree (C++ <code>std::map</code>), however, I am also depending upon the following feature of a doubly linked list for good performance:</p>\n\n<ul>\n<li>Ability to splice a contiguous section out of one linked list into another in $O(1)$ time. (Amortized $O(1)$ or $O(\\log \\log n)$ would be good enough.)</li>\n</ul>\n\n<p>One feature of my data that I would like to leverage is that I often have long ranges of contiguous records where each one's unique integer is exactly one more than its predecessor.  When searching for an item's relative sorted position, it would always be outside such contiguous records since there are no duplicate identifiers.</p>\n\n<p>I'd like to find a replacement data structure or augmentation to a doubly linked list that will allow me to continue to splice whole sections from one list to another in constant time but allow me to locate the sorted position in which to insert a new record in better than $O(n)$ time.</p>\n\n<p>Other operations include forward and backward iteration across the items. The record indexes begin at zero and grow upwards towards 64 bits, generally sequentially, and the code works well in such cases. Occasionally some records are not available before subsequent ones, it is the insertion of these missing records that causes the performance issues now. </p>\n\n<p>One possible approach that occurs to me is to cache the location of several indexes.  The cache would get invalidated whenever a splice removes items that might overlap the cached entries.  With this cache, instead of doing a linear search, the search could instead begin from the cache point iterator whose unique index is closest to the one whose position is being  searched for.  However, I'd like to more fully utilize the feature of the contiguous records.  I also thought about a hierarchical linked list where I have a top level linked list of contiguous regions, where each region is a linked list of records that are consecutive, but I didn't see a clean way to adapt a linked list to provide this functionality.  Perhaps something like this has been done before?  I find skip lists to be close, but do not see the splice() functionality, plus a generic skip list would not leverage the fact that insertion never occurs within contiguous records.</p>\n", 'Tags': '<data-structures><time-complexity><binary-trees><linked-lists>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-08T10:37:59.160', 'CommentCount': '3', 'AcceptedAnswerId': '13646', 'CreationDate': '2013-08-05T23:00:36.700', 'Id': '13620'},176_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Imagine I have an ordering on a bunch of elements like so:</p>\n\n<p><img src="http://i.imgur.com/Sl2kUC0.png" alt="enter image description here"></p>\n\n<p>Where an arrow $X \\leftarrow Y$ means $X &lt; Y$. It is also transitive: $\\left(X &lt; Y\\right) \\wedge \\left(Y &lt; Z\\right) \\implies \\left(X &lt; Z\\right)$.</p>\n\n<p>In order efficiently answer queries like $A \\stackrel {?}{&lt;} D$, some sort of labeling or data structure is required. For example, you could number the nodes from left to right, and thus you can simply do integer comparison to answer the query: $A \\stackrel {?}{&lt;} D \\implies 1 &lt; 4 \\implies T$. It would look something like this:</p>\n\n<p><img src="http://i.imgur.com/YQ28co3.png" alt="enter image description here"></p>\n\n<p>Where the number is the ordering, and the letter is just a name.</p>\n\n<p>But what if you needed to insert elements "in between" two other elements in the ordering, like so:</p>\n\n<p><img src="http://i.imgur.com/aLuLJRH.png" alt="enter image description here"></p>\n\n<p><img src="http://i.imgur.com/HTSllkZ.png" alt="enter image description here"></p>\n\n<p><img src="http://i.imgur.com/DaytZtk.png" alt="enter image description here"></p>\n\n<p>How can you maintain such an ordering? With simple numbering, you run into the problem that there are no integers "in between" $2,3$ to use.</p>\n', 'ViewCount': '881', 'Title': 'Maintaining an efficient ordering where you can insert elements "in between" any two other elements in the ordering?', 'LastActivityDate': '2013-10-01T13:49:11.323', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14728', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<data-structures><graphs><linked-lists><partial-order><order-theory>', 'CreationDate': '2013-09-30T17:58:23.563', 'FavoriteCount': '2', 'Id': '14708'},176_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a doubly link-list like this</p>\n\n<pre><code>typedef struct Record\n{\n   int i;\n   Record* next;\n   Record* prev;\n}Record;\n</code></pre>\n\n<p>I have over 5 trillions of records that I need to handle, now that I need to retrieve all of them and sort them out.\nIf its size was small, I could borrow stl's vector or list to do the job but now that it is too huge, I have no idea how to save the object data before sorting is performed</p>\n\n<p>my function prototype</p>\n\n<pre><code>void sortRec(Record**recToSort,bool bASC){}\n</code></pre>\n", 'ViewCount': '71', 'ClosedDate': '2013-10-15T10:05:09.320', 'Title': 'linklist and memory issues', 'LastActivityDate': '2013-10-03T19:11:33.200', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10450', 'Tags': '<algorithms><data-structures><data-mining><linked-lists>', 'CreationDate': '2013-10-02T03:53:31.060', 'Id': '14744'},176_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was wondering how to remove duplicate values from a linked list in $\\mathcal{O}(n\\lg n)$ time. I have an idea that by using merge sort when we want to compare elements for choosing the small one, if they are equal advance on pointer and just consider one element. Any alternatives?</p>\n', 'ViewCount': '111', 'Title': 'How to purge a linked list in $\\mathcal{O}(n\\log n)$ time?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T21:13:42.090', 'LastEditDate': '2013-10-18T21:13:42.090', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '16162', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10030', 'Tags': '<sorting><linked-lists>', 'CreationDate': '2013-10-17T14:11:34.833', 'Id': '16160'},176_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is homework, so please only hints. I didn't want to put this on StackOverflow since this is mostly about theory, and SO gets inundated with too many questions.</p>\n\n<p>I am asked to find a method of arranging items in a skiplist, with height limited to 3 and unlimited number of elements, in such a way such that searching takes <em>worst-case</em> $\\Theta (n^{1/3})$. No restriction on how expensive the arranging part is; just describe what subset of the keys go into which level.</p>\n\n<p>I am somewhat confused. How can a skiplist with a limited number of items have search complexity anything other than $\\Theta(n)$? Clearly, with any clever algorithm, I can just fill the skiplist with a horrendous amount of elements, and as the number of elements goes up, surely the handicapped skiplist can't do any better than a linked list asymptotically? I think I can prove this for the simple set of rearranging algorithms that put a random proportion $q$ of the items into the second layer, and another random proportion $p$ of items within these items to the top layer.</p>\n\n<p>Am I missing anything obvious? Is the question faulty?</p>\n", 'ViewCount': '68', 'Title': 'Skip lists with limited height', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T00:15:57.107', 'LastEditDate': '2013-11-11T13:54:11.880', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6778', 'Tags': '<data-structures><lists>', 'CreationDate': '2013-11-11T01:40:36.807', 'Id': '17901'},176_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am asked to check if a vector contains another vector as a subvector. For example:</p>\n\n<p>$$v_1 = (4, \\underline{3, 4}, 9, 10, 28, 5, 12, \\underline{3, 4})$$\n$$v_2 = (3, 4)$$</p>\n\n<p>The answer here will be two, since there are two instances of $v_2$ in $v_1$.</p>\n\n<p>I know I have to use "if" but I dont really know how to write it down (I have tried).</p>\n', 'ViewCount': '61', 'Title': 'Counting occurrences of one vector inside another', 'LastEditorUserId': '69', 'LastActivityDate': '2013-11-15T10:06:52.937', 'LastEditDate': '2013-11-14T17:13:13.220', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11377', 'Tags': '<algorithms><data-structures><lists>', 'CreationDate': '2013-11-14T13:54:23.277', 'Id': '18014'},176_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '120', 'Title': 'More efficient algorithm for determining if one list is a sublist of another list', 'LastEditDate': '2013-11-26T01:14:57.783', 'AnswerCount': '2', 'Score': '4', 'OwnerDisplayName': 'Panarit', 'PostTypeId': '1', 'OwnerUserId': '11640', 'FavoriteCount': '1', 'Body': "<p>I'm trying to build an algorithm which takes two lists of natural numbers and finds if every element of the first list is displayed at least once in the second list.</p>\n\n<p>What if the list is sorted? </p>\n\n<p>An algorithm that can do this is by comparing every element of the first list with every element from the second list. I think there is an algorithm with a better complexity. Can anyone give me any idea?</p>\n", 'Tags': '<algorithms><data-structures><sorting><lists><comparison>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-26T21:23:38.760', 'CommentCount': '1', 'AcceptedAnswerId': '18350', 'CreationDate': '2013-11-24T14:49:37.500', 'Id': '18346'},176_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following homework question that I am struggling with. I have read the corresponding chapter from the book, but no guidance there.</p>\n\n<p>Consider a linked list $X: X_1 \\to X_2 \\to X_3 \\ldots$.\nAssume that the cost of examining a particular element $X_i$ is $C_i$. Note that to examine $X_i$, \none needs to scan through all elements in front of $X_i$. Let $P_i$ be the probability of \nsearching for element $X_i$, so the total cost for all searches is \n$$\n\\sum_{j=1}^{n} \\left( P_j \\cdot \\sum_{i=1}^{j} C_i \\right)\n$$</p>\n\n<ol>\n<li><p>Show that storing elements in non-increasing order of $P_i/C_i$ does not necessarily minimize the total cost. </p></li>\n<li><p>Show that storing elements in non-decreasing order of $P_i$ does not necessarily minimize the total cost. </p></li>\n</ol>\n\n<p>Any help and direction how to approach the problem will be highly appreciated.</p>\n', 'ViewCount': '127', 'Title': 'Impact on the order of elements on the cost of searching in a linked list', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-07T03:59:28.483', 'LastEditDate': '2014-03-04T11:09:47.673', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '22365', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15266', 'Tags': '<algorithm-analysis><data-structures><linked-lists>', 'CreationDate': '2014-03-04T09:44:59.877', 'Id': '22264'},176_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>To prevent collisions in Hash table , <a href="http://en.wikipedia.org/wiki/Hash_table#Collision_resolution" rel="nofollow">seperate chaining with linked list</a> is used . Hash table works by hashing the key and storing the value in the bucket. </p>\n\n<p>Assuming 4 keys hash to the same bucket , and the bucket has a linked list which has 4 nodes , how would we know which value belong to the key when we try to search for the value of the key .</p>\n\n<p>For eg : These 4 key-value :<strong>a:4</strong>  , <strong>b:3</strong> , <strong>c:2</strong> , <strong>d:1</strong> ,  hash to bucket 23. At bucket 23 , there is a linked list of values : <strong>4 , 3 , 2 , 1</strong>  , how would we know which values belong to which key</p>\n', 'ViewCount': '20', 'Title': 'How to tell which value belongs to the key during hashing', 'LastActivityDate': '2014-03-15T16:54:11.963', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22654', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12448', 'Tags': '<hash-tables><linked-lists>', 'CreationDate': '2014-03-15T16:45:33.213', 'Id': '22652'}