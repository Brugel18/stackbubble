3420:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to create a bloom filter of 208 million URLs. What would be a good choice of bit vector size and number of hash functions? I tried a bit vector of size 1 GB and 4 hash functions, but it resulted in too many false positives while reading.</p>\n\n<p>I have a huge web corpus containing web content of billions of URLs. I need to process the web content of URLs satisfying certain criteria: the URL should have appeared in web search results in the past 7 days at least 5 times. This is represented by a list of 208 million URLs. Joining the list directly with the web corpus is not feasible because of volume. So I am considering creation of a bloom filter out of the list and then using the bloom filter to prune out unnecessary URLs from the web corpus.</p>\n', 'ViewCount': '387', 'Title': 'Bloom Filter for 208 million URLs', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-26T13:17:46.310', 'LastEditDate': '2013-06-26T13:17:46.310', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2881', 'Tags': '<data-structures><probabilistic-algorithms><searching><big-data><bloom-filters>', 'CreationDate': '2012-09-19T15:58:11.313', 'Id': '4616'},3421:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Bloom filter use a hash function to test membership for S by checking if an item is present of not at the specified position. To mitigate the effect of hash collision, multiple functions are used, yielding probabilistic bound if using universal hash.\nWe can use 10 bits per elements to have 'reasonable' error rate.</p>\n\n<p>If we could build directly a perfect hashing function for the set  S + $\\infty$, where last the element is one not present in S, we could use only 1 bit per element and have perfect recovery.</p>\n\n<p>What are the fundamental reasons why this reasonning is wrong ?</p>\n", 'ViewCount': '182', 'Title': 'Bloom filter and perfect hashing', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T11:35:07.190', 'LastEditDate': '2014-04-29T11:35:07.190', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4469', 'Tags': '<data-structures><hash><probabilistic-algorithms><bloom-filters><dictionaries>', 'CreationDate': '2013-06-03T15:20:55.557', 'Id': '12444'},3422:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '254', 'Title': 'Why do Bloom filters work?', 'LastEditDate': '2014-04-29T11:35:41.260', 'AnswerCount': '3', 'Score': '4', 'OwnerDisplayName': 'user220201', 'PostTypeId': '1', 'OwnerUserId': '8842', 'Body': "<p>Let's say I am using Bloom filters to create a function to check if a word exists in a document or not.  If I pick a hash function to fill out a bit bucket for all words in my document. Then if for a given number of words, wouldn't the whole bit bucket be all 1s? If so then checking for any word will return true? What am I missing here? </p>\n", 'Tags': '<data-structures><probabilistic-algorithms><bloom-filters><dictionaries>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T11:35:41.260', 'CommentCount': '0', 'AcceptedAnswerId': '12838', 'CreationDate': '2013-06-22T13:12:57.470', 'Id': '12834'},3423:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know that standard Bloom Filters only have operations like inserting elements and checking if an element belongs to filter, but are also some modification of Bloom filters which enable a delete operation--for example: counting Bloom filters. I heard also about another method, which uses a second filter. If I want to remove an element I have to 'insert' it into this second filter. I can't find how this proposed structure operates, any article about it, or even the name of the originator. Maybe someone can share with me with a link to any interesting articles about this method? I found a lot of articles about counting Bloom filters and other methods, but I can't find any description of this one.</p>\n", 'ViewCount': '101', 'Title': 'Deleting in Bloom Filters', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T11:35:49.423', 'LastEditDate': '2014-04-29T11:35:49.423', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '12038', 'Tags': '<reference-request><data-structures><probabilistic-algorithms><bloom-filters><dictionaries>', 'CreationDate': '2013-12-25T22:52:19.973', 'Id': '19292'},3424:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Bloom filters are a variant of hash tables except it is much more space efficient at the cost of a low probability of false positives .</p>\n\n<p>How it works : Assume there are 10000 bits , 3 hash functions and an object Foo is to be inserted into the Bloom Filter .</p>\n\n<p>Insertions : Foo will be hashed by the 1st hash function and the 3405 bit index is set to 1 , Foo is hashed by the second hash function and the 1001 bit index is set to 1 , Foo is hashed by the third hash function and the 5555 bit index is set to 1 .</p>\n\n<p>Check exist : Foo will be hashed to the three different hash function and if all the bits at the respective index is set to 1 , the object is said to exist with a small chance of false positive else the object cant be found .</p>\n\n<p>My question is : Why do we use more than 1 (in this case 3 bits ) to determine if a objects exist in the Bloom Filter , doesnt it increase the chances of collision with other objects which may also set the same bit to 1 . To me , it seems best to use a single hash function as it saves the most space (1 bit only) and least chances of collision with other objects in the Bloom Filter</p>\n', 'ViewCount': '41', 'Title': 'Why do we use several bits instead of a single bit for storage of objects in Bloom Filters', 'LastActivityDate': '2014-03-16T15:25:29.777', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12448', 'Tags': '<data-structures><bloom-filters>', 'CreationDate': '2014-03-14T14:05:39.153', 'Id': '22621'},3425:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '871', 'Title': 'Is there an anti-Bloom filter?', 'LastEditDate': '2014-04-29T11:35:57.480', 'AnswerCount': '4', 'Score': '17', 'PostTypeId': '1', 'OwnerUserId': '5323', 'FavoriteCount': '4', 'Body': '<p>A <a href="https://en.wikipedia.org/wiki/Bloom_filter" rel="nofollow">Bloom filter</a> makes it possible to efficiently keep track of whether various values have already been encountered during processing.  When there are many data items then a Bloom filter can result in a significant memory saving over a hash table.  The main feature of a Bloom filter, which it shares with a hash table, is that it always says "not new" if an item is not new, but there is a non-zero probability that an item will be flagged as "not new" even when it is new.</p>\n\n<blockquote>\n  <p>Is there an "anti-Bloom filter", which has the opposite behaviour?</p>\n</blockquote>\n\n<p>In other words: is there an efficient data structure which says "new" if an item is new, but which might also say "new" for some items which are not new?</p>\n\n<p>Keeping all the previously seen items (for instance, in a sorted linked list) satisfies the first requirement but may use a lot of memory.  I am hoping it is also unnecessary, given the relaxed second requirement.</p>\n\n<hr>\n\n<p>For those who prefer a more formal treatment, write $b(x) = 1$ if the Bloom filter thinks $x$ is new, $b(x) = 0$ otherwise, and write $n(x) = 1$ if $x$ really is new and $n(x) = 0$ otherwise.</p>\n\n<p>Then $Pr[b(x) = 0 | n(x) = 0] = 1$; $Pr[b(x) = 0 | n(x) = 1] = \\alpha$; $Pr[b(x) = 1 | n(x) = 0] = 0$; $Pr[b(x) = 1 | n(x) = 1] = 1 - \\alpha$, for some $0 &lt; \\alpha &lt; 1$.</p>\n\n<p>I am asking: does an efficient data structure exist, implementing a function $b\'$ with some $0 &lt; \\beta &lt; 1$, such that $Pr[b\'(x) = 0 | n(x) = 0] = \\beta$; $Pr[b\'(x) = 0 | n(x) = 1] = 0$; $Pr[b\'(x) = 1 | n(x) = 0] = 1 - \\beta$; $Pr[b\'(x) = 1 | n(x) = 1] = 1$?</p>\n\n<hr>\n\n<p><strong>Edit:</strong> It seems this question has been asked before on StackExchange, as <a href="http://stackoverflow.com/questions/635728">http://stackoverflow.com/questions/635728</a> and <a href="http://cstheory.stackexchange.com/questions/6596">http://cstheory.stackexchange.com/questions/6596</a> with a range of answers from "can\'t be done" through "can be done, at some cost" to "it is trivial to do, by reversing the values of $b$".  It is not yet clear to me what the "right" answer is.  What <em>is</em> clear is that an LRU caching scheme of some sort (such as the one suggested by Ilmari Karonen) works rather well, is easy to implement, and resulted in a 50% reduction in the time taken to run my code.</p>\n', 'Tags': '<reference-request><data-structures><hash><bloom-filters><dictionaries>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T11:35:57.480', 'CommentCount': '3', 'AcceptedAnswerId': '24122', 'CreationDate': '2014-04-25T21:08:54.120', 'Id': '24118'},3426:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been playing around with a simple probabilistic data structure which is very similar to a Bloom filter. Where a Bloom filter would use $k$ independent hash functions to choose $k$ of the $m$ bits to set, this structure uses $m$ hash functions, and sets each bit with probability $p$.</p>\n\n<p>This structure doesn't produce as low a false-positive rate as Bloom filters, but it seems to be extremely fast to compute, particularly if $m$ is some multiple of the machine word size and $p = 2^{-b}$ for some integer $b$: The hash functions can be computed in parallel by AND-ing $b$ independent $m$-bit hashes, and no dependent indexing or variable bitshifts are required.</p>\n\n<p>I'm certain someone's come up with this idea before me, and done a lot more advanced analysis and comparison of it than I'm qualified to do. Is there a particular name for this type of structure?</p>\n", 'ViewCount': '33', 'Title': 'Bloom filter variant', 'LastEditorUserId': '8410', 'LastActivityDate': '2014-04-29T17:07:58.197', 'LastEditDate': '2014-04-29T13:27:12.427', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24230', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8410', 'Tags': '<reference-request><data-structures><probabilistic-algorithms><bloom-filters><dictionaries>', 'CreationDate': '2014-04-29T10:55:19.287', 'Id': '24217'}