306_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there an algorithm which decides whether a regular tree grammar $G$ is ambiguous, i.g. there exists a tree $t\\in L(G)$ which can be parsed by the grammar in more than one ways, using only leftmost derivations?</p>\n\n<p>Is there a proof available about the decidability, or a cite to a paper which proposes such an algorithm?</p>\n', 'ViewCount': '241', 'Title': 'Is the ambiguity of a regular tree grammar decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:40:05.507', 'LastEditDate': '2013-02-14T06:40:05.507', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6866', 'Tags': '<formal-languages><computability><formal-grammars><ambiguity><tree-grammars>', 'CreationDate': '2013-02-13T15:29:34.530', 'Id': '9745'},306_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m looking for an algorithm to construct a grammar which, given a set of words which can have multiple identical symbols, represents a compressed version of this set, that is, I can generate only the words of the set but the grammar will take less memory than the set himself.</p>\n\n<p>Besides, I\'m looking for an algorithm which can update the grammar when I want to remove a word of the set.</p>\n\n<p>What type of algorithm is able to do that ?</p>\n\n<p>I give a concrete example:</p>\n\n<p>Consider a string S="abcdefghij", and then consider the finite set of words "cdhij", acdef", "fghi", "bcfgij", "defi".</p>\n\n<p>I would like to construct a grammar which generates only this set of words (words which can be viewed as concatenation of various substrings of any length from the original string S).</p>\n\n<p>Finally I would like to remove a word in the set and update subsequently the grammar.</p>\n\n<p>Thank you.</p>\n', 'ViewCount': '62', 'Title': "I'm lookin for a method to construct a particular grammar?", 'LastEditorUserId': '8767', 'LastActivityDate': '2013-07-21T22:29:26.490', 'LastEditDate': '2013-06-21T08:44:21.090', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8767', 'Tags': '<context-free><formal-grammars><tree-grammars>', 'CreationDate': '2013-06-20T08:04:48.473', 'Id': '12782'},306_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am having challenges (in two phases) with creating a CFG.</p>\n\n<ol>\n<li>Derive the CFG for the following language </li>\n<li>Show parse trees for the strings <em>cacab</em> and <em>aacabbb</em> obtained from the grammar designed above.</li>\n</ol>\n\n<p>I am getting a bit mixed up by the exercise especially because my CFG appears not to produce a parse tree.</p>\n\n<p>Here is the language:</p>\n\n<p>$$\n    L = \\{a^n (ca)^m b^{n+1} \\mid m \\ge 0 , n \\ge 0 \\}\n$$</p>\n\n<p>So far my grammar looks as follows:</p>\n\n<p>$$ \\begin{align}\n    S &amp;\\to Ab \\mid Bb \\mid Cb \\mid b \\\\\n    A &amp;\\to aA \\mid \\epsilon \\\\\n    B &amp;\\to caB \\mid \\epsilon \\\\\n    C &amp;\\to bC \\mid \\epsilon \\\\\n\\end{align} $$</p>\n', 'ViewCount': '158', 'Title': 'Derive a Context Free Grammar from a language', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-08T11:10:34.703', 'LastEditDate': '2013-10-08T11:10:34.703', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14903', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10569', 'Tags': '<context-free><formal-grammars><tree-grammars>', 'CreationDate': '2013-10-08T09:15:40.340', 'Id': '14900'},306_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We define a <em>regular tree language</em> as in the book <a href="http://tata.gforge.inria.fr/" rel="nofollow">TATA</a>: It is the set of trees accepted by a non-deterministic finite tree automaton (Chapter 1) or, equivalently, the set of trees generated by a regular tree grammar (Chapter 2). Both formalisms hold close resemblances to the well-known string analogues.</p>\n\n<blockquote>\n  <p>Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?</p>\n</blockquote>\n\n<p>Obviously there are tree languages such that the height of a tree is linear in its size; and in the book <a href="http://algo.inria.fr/flajolet/Publications/books.html" rel="nofollow">Analytic Combinatorics</a> it is shown e.g. that binary trees of size $n$ have average height $2\\sqrt{ \\pi n}$. If I understand Proposition VII.16 (p.537) of the mentioned book correctly, then there is a wide subset of regular tree languages that have average height of $\\Theta(\\sqrt{n})$, namely those in which the tree language is also a <em>simple variety of trees</em> fulfilling some extra conditions.</p>\n\n<p>So I was wondering whether there is a regular tree language showing a different average height or if there is a true dichotomy for regular tree languages.</p>\n', 'ViewCount': '316', 'Title': 'Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T08:11:24.593', 'LastEditDate': '2013-10-18T08:11:24.593', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '10734', 'Tags': '<formal-languages><regular-languages><combinatorics><trees><tree-grammars>', 'CreationDate': '2013-10-14T14:19:09.910', 'FavoriteCount': '4', 'Id': '16073'},306_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Others have studied the following question: given a set of words $w_1,w_2,\\dots \\in \\Sigma^*$, find a regular grammar (or a context-free grammar) that generates all of those words, is "natural" in some sense, and is as small as possible.  In the special case where we have a single word $w \\in \\Sigma^*$, if the grammar generates exactly the word $w$, we can think of this as a compression algorithm that compresses the word $w$ to the grammar produced by this inference algorithm.  Of course, each word is a one-dimensional sequence of symbols.</p>\n\n<p>Now consider a two-dimensional array of symbols, say an array $A[1\\ldots m, 1\\ldots n]$ where each $A[i,j] \\in \\Sigma$.  Is there any corresponding algorithm that could be used to find a grammar of some sort that generates $A$?  Could this be used as a compression algorithm for compressing images, i.e., one that compresses a two-dimensional image to its corresponding grammar?</p>\n\n<p>I\'m not even sure what kind of grammar would be suitable.  Is there an analog of regular or context-free grammars that generates a two-dimensional output instead of a one-dimensional output?  I\'ve done some searching, and haven\'t found anything obvious.</p>\n\n<ul>\n<li><p>Of course we could linearize the image, by concatenating the rows of the array, to get a one-dimensional sequence, and then apply any of the above techniques -- but this does not preserve locality.  In other words, elements that are vertically adjacent will no longer be near each other after this transformation.  So this transformation does not seem useful.</p></li>\n<li><p>Perhaps we could build a quad-tree over the array and then consider tree automata over that quad-tree?  Is there a grammar inference algorithm for such tree automata over quad-trees?</p></li>\n<li><p>Alternatively, it seems like there might be a natural extension of context-free grammars to two-dimensional output: just make the right-hand side of each rule be a two-dimensional array of terminals and non-terminals of arbitrary size, and then apply the obvious generation algorithm.  Do such grammars have a standard name?  Is there a grammar inference algorithm for such grammars?</p></li>\n</ul>\n', 'ViewCount': '42', 'Title': '"Grammar inference" for 2-D images', 'LastActivityDate': '2014-04-08T09:34:06.440', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><formal-grammars><tree-grammars>', 'CreationDate': '2013-12-10T07:46:27.600', 'Id': '18823'}