192_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working through Simon Peyton Jones\' "The Implementation of Functional Programming Languages" and on page 20 I see:</p>\n\n<pre>\nIF TRUE ((&#955;p.p) 3) &#8596; IF TRUE 3         (per &#946; red)   (1)\n                   &#8596; (&#955;x.IF TRUE 3 x)  (per &#951; red)   (2)\n                   &#8596; (&#955;x.3)                          (3)\n</pre>\n\n<p>Step 1 to 2 is explained as &#951;-conversion. But from 2 to 3 it says "The final step is the reduction rule for IF." I\'m not sure what this reduction rule is. </p>\n', 'ViewCount': '213', 'Title': 'Reduction rule for IF?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-10T03:26:39.087', 'LastEditDate': '2012-05-10T03:26:39.087', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'OwnerDisplayName': 'galaxybeing', 'PostTypeId': '1', 'OwnerUserId': '1335', 'Tags': '<logic><programming-languages><lambda-calculus><term-rewriting><operational-semantics>', 'CreationDate': '2012-05-01T03:47:18.940', 'Id': '1607'},192_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m defining an intermediate language for a multi-backend code generator that I\'m writing.  I want to document the operational semantics for this intermediate language in a way that is readable both from within the source code and generated documentation (ocamldoc).  The notation introduced used in "Types and Programming" languages is great for a book, but I don\'t want to try to do the prerequisite over conclusion style notation via ASCII art.</p>\n\n<p>Is there a widely recognized notation for operational semantics that doesn\'t require non-ASCII characters?  I looked through various RFCs but can\'t find any that use a non-natural language way of specifying semantics.</p>\n', 'ViewCount': '89', 'Title': 'Notation for operational semantics that can be used in code comments', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-24T08:06:36.720', 'LastEditDate': '2012-07-24T06:07:21.987', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '2894', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<programming-languages><semantics><operational-semantics>', 'CreationDate': '2012-07-23T21:37:12.833', 'Id': '2886'},192_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question arises from my reading of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">"Types and Programming Languages"</a> (<a href="http://www.worldcat.org/oclc/47705787" rel="nofollow">WoldCat</a>) by Benjamin C. Pierce.</p>\n\n<p>For the small step operational semantic evaluation rules for the arithmetic expressions (NB) in Figure 3-2 on page 41, there is the rule </p>\n\n<blockquote>\n  <p>$pred\\;(succ\\;nv_1)\\rightarrow\\;nv_1$</p>\n</blockquote>\n\n<p>My understanding is that it is to keep out invalid input like </p>\n\n<blockquote>\n  <p>$pred\\;(false)$</p>\n</blockquote>\n\n<p>but how did he come to that exact syntax for the rule? Is there some algorithm that is used to massage the rules into the necessary form? Is there some book or paper that explains how to formulate rules for small step operational semantics?</p>\n\n<p>Note: I am aware that there is a forum dedicated to questions for the book <a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list" rel="nofollow">here</a>. </p>\n', 'ViewCount': '76', 'Title': 'How does one deduce small step operational semantics?', 'LastActivityDate': '2013-03-08T01:26:40.747', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10348', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<semantics><operational-semantics><small-step>', 'CreationDate': '2013-03-07T00:29:07.013', 'Id': '10347'},192_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question arises from my reading of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">"Types and Programming Languages"</a> (<a href="http://www.worldcat.org/oclc/47705787" rel="nofollow">WorldCat</a>) by Benjamin C. Pierce.</p>\n\n<p>On page 36 is the definition for <em>satisfied</em></p>\n\n<blockquote>\n  <p>A rule is <em>satisfied</em> by a relation if, for each instance of the rule,\n  either the conclusion is in the relation or one of the premises is\n  not.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>instance</em></p>\n\n<blockquote>\n  <p>An <em>instance</em> of an inference rule is obtained by consistently replacing\n  each metavariable by the same term in the rule\'s conclusion and all its\n  premises (if any).</p>\n  \n  <p>For example </p>\n  \n  <p><code>if true then true else (if false then false else false) -&gt; true</code></p>\n  \n  <p>is an instance of <strong>E-IFTRUE</strong>, where both occurrences of $t_2$ have been\n  replaced by <code>true</code> and $t_3$ has been replaced by <code>if false then false else\n  false</code>.</p>\n</blockquote>\n\n<p>On page 15 is the definition for <em>relataion</em></p>\n\n<blockquote>\n  <p>An n-place <em>relation</em> on a collection of sets $S_1, S_2,..., S_n$ is a\n  set $R\\subseteq  S_1\\times\\;S_2\\;\\times\\;...\\;\\times\\;S_n$ of tuples\n  of elements from $S_1$ through $S_n$. We say that the elements $s_1\\in\n&gt; S_1$ thorugh $s_n\\in S_n$ are related by $R$ if $(s_1,...,s_n)$ is an\n  element or $R$.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>one-step evaluation relation ($\\rightarrow $)</em> </p>\n\n<blockquote>\n  <p>The <em>one-step evaluation relation $\\rightarrow $</em> is the smallest\n  binary relation on terms satisfying the three rules of Figure 3-1.\n  When the pair $(t,t\')$ is in the evaluation relation,  we say that "the\n  evaluation statement (or judgment) $t \\rightarrow t\'$ is derivable."</p>\n</blockquote>\n\n<p>On page 34 are the three rules from Figure 3-1</p>\n\n<p><strong>E-IFTRUE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;true\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IFFALSE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;false\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IF</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}\\frac{t_1\\rightarrow\\;t_1\'}{if\\;t_1\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;if\\;t_1\'\\;then\\;t_2\\;else\\;t_3}\\end{equation}</p>\n</blockquote>\n\n<p>Can someone explain this definition and give an example for parts of the defintion.<br>\n1. The conclusion is in the relation.<br>\n2. One of the premises is not.  </p>\n\n<p>Note: I am aware that there is a forum dedicated to questions for the book <a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list" rel="nofollow">here</a>.</p>\n\n<p>Note: You can use <a href="http://scholar.google.com/" rel="nofollow">Google Scholar</a> to see more of the details to this question in context.</p>\n\n<p>EDIT</p>\n\n<p>To connect some of the dots about my comment regarding unification and term rewriting.</p>\n\n<p>When I saw</p>\n\n<p>$$(A\\rightarrow B)\\equiv (\\neg A \\vee B)$$</p>\n\n<p>it reminded me of <a href="http://en.wikipedia.org/wiki/Horn_clause" rel="nofollow">Horn claues</a> from <a href="http://en.wikipedia.org/wiki/Prolog" rel="nofollow">Prolog</a>, that along with the example then connected with my understanding of <a href="http://en.wikipedia.org/wiki/Rewriting" rel="nofollow">term rewriting</a>. Having the book "<a href="http://www.cambridge.org/gb/knowledge/isbn/item1166682/?site_locale=en_GB" rel="nofollow">Term Rewriting and All That</a>" (<a href="http://www.worldcat.org/title/term-rewriting-and-all-that/oclc/37315354&amp;referer=brief_results" rel="nofollow">WorldCat</a>) by Franz Baader and Tobias Nipkow, I quickly looked up satisfiability and found satisfiable on page 58. This is actually the start of whole chapter on Equational Problems; but it also covers <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29" rel="nofollow">unification</a>. At that point I realized that the definition was dealing with <a href="http://en.wikipedia.org/wiki/Satisfiability" rel="nofollow">Satisfiability</a> and from there is was a topic I was already familiar. What threw me was the way Benjamin defined it. He used a very precise definition right up front in a manner I didn\'t associate with my knowledge.  </p>\n\n<p>If you work through the code as I am and understand logic programming, then the definition makes perfect sense.</p>\n', 'ViewCount': '107', 'Title': 'TAPL: Explanation and example(s) for satisfied', 'LastEditorUserId': '268', 'LastActivityDate': '2013-03-11T01:59:40.410', 'LastEditDate': '2013-03-11T01:59:40.410', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10403', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<satisfiability><operational-semantics><small-step><term-rewriting>', 'CreationDate': '2013-03-08T14:05:18.400', 'Id': '10386'},192_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What is the meaning of the double, down facing arrow $\\Downarrow$ in the context of operational semantics? Here's the example formula that uses it:</p>\n\n<p>$$\\frac{s_0 \\vdash M_1 \\Downarrow P_1, s_1 \\; ... \\; s_{n-1} \\vdash M_n \\Downarrow P_n, s_n}{s_0 \\vdash M \\Downarrow P, s_n}$$</p>\n\n<p>It would be also beyond priceless if you could explain in words what do other pictograms of this formula mean. I feel that $\\vdash$ here doesn't mean what it usually means in logic (is provable from). However the general form of this formula is the derivation rule (I can understand it from the context). It is a rather general derivation rule though (it is followed by few other more specific examples which use all the same pictograms).</p>\n\n<p>The source of the formula: On Exceptions versus Continuation in the Presence of State by Hayo Thielecke. It cites several other sources, but I couldn't find the explanation of the symbols used.</p>\n", 'ViewCount': '110', 'Title': 'Double, down facing arrow in operational semantics', 'LastActivityDate': '2013-10-18T18:27:27.837', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16209', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10314', 'Tags': '<terminology><semantics><operational-semantics>', 'CreationDate': '2013-10-18T17:06:53.357', 'Id': '16201'},192_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As big-step operational semantics is about evaluating an expression to a final value, can we state that for defining a concurrent language one needs small-step semantics, as concurrent programs need not result in a value?</p>\n', 'ViewCount': '19', 'Title': 'defining the operational semantics of a concurrent language', 'LastActivityDate': '2013-12-28T21:01:38.003', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12426', 'Tags': '<concurrency><operational-semantics>', 'CreationDate': '2013-12-28T21:01:38.003', 'Id': '19349'},192_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a few small questions about section 2.4 ("Rule induction") in <a href="https://www.cs.cmu.edu/~rwh/plbook/book.pdf" rel="nofollow">Practical Foundations for Programming Languages</a> (p. 19).</p>\n\n<p>(1) In the rule induction principles for <code>nat</code>,</p>\n\n<blockquote>\n  <p>To show P(a nat) whenever a nat, it is enough to show:\n  (1) P(zero nat).\n  (2) for every a, if (a nat and) P(a nat), then P(succ(a) nat).</p>\n</blockquote>\n\n<p>why is the bracketed "(<em>a</em> <code>nat</code> and)" clause necessary (and similarly for <code>tree</code>)?  This seems "natural" - we shouldn\'t need to prove things about syntactic entities that don\'t define <code>nat</code>s - but doesn\'t appear in the definition given of property <em>P</em> "respecting the rules" defining <code>nat</code>/<code>tree</code> (also on p. 19), which is how the rule induction principle is defined.  In the proof of Lemma 2.1, the extra "<em>a</em> nat and" part has become part of the definition of the property <em>P</em> - what\'s going on here?</p>\n\n<p>(2) I don\'t understand the induction step of Lemma 2.1 (<code>succ(a) nat</code> implies <code>a nat</code>).  If I were doing this proof, I\'d just invert the rules for <code>nat</code> right away, or, using Harper\'s property <em>P</em>, say: If <code>succ(a)</code> is of form <code>succ(b)</code>, then by injectivity, <code>a</code> equals <code>b</code>, hence <code>b nat</code> as <code>a nat</code>, but injectivity hasn\'t been proven yet.  It seems instead that Harper applies the induction hypothesis about <code>a</code> directly to <code>succ(a)</code> - I must be missing something.</p>\n\n<p>(3) In a more naive framework, Lemma 2.3 would just follow from sufficiency of the <code>= nat</code> relation rules ("inversion"), but I don\'t know how to write down a proof in this style.  Why is induction even needed?</p>\n\n<p>I\'m sorry if these questions seem like nitpicking, but Martin-L\xf6f/LF feels very foreign to me.  If I squint and pretend I\'m doing everything in a more "traditional" operational semantics, I can read other parts of the book (with slightly different proofs), but I feel I\'m missing the point in doing so.</p>\n\n<p>If these questions are too tedious to answer individually, are there other references on doing semantics in this style?</p>\n', 'ViewCount': '47', 'Title': "Rule induction principles in Harper's PFPL", 'LastEditorUserId': '15757', 'LastActivityDate': '2014-03-21T16:34:29.187', 'LastEditDate': '2014-03-21T16:34:29.187', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15757', 'Tags': '<type-theory><semantics><induction><operational-semantics>', 'CreationDate': '2014-03-17T03:10:30.117', 'Id': '22690'},192_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to prove the following 2 properties of the Small-step semantics of the WHILE programming language:</p>\n\n<ul>\n<li>If $\\langle C_1; C_2, s\\rangle \\rightarrow^k s'$ then there is a\nstate $s''$ and natural numbers $k_1$ and $k_2$ such that $\\langle C_1;s\n   \\rangle \\rightarrow^{k_1} s''$ and $\\langle C_2; s'' \\rangle\n   \\rightarrow^{k_2} s'$ where $k_1 + k_2 = k$.</li>\n<li>If $\\langle C_1, s \\rangle \\rightarrow^k s'$ then $\\langle C_1; C_2,\n   s \\rangle \\rightarrow^k \\langle C_2, s'\\rangle$.</li>\n</ul>\n\n<p>I am not quite sure which kind of induction I should use. I am not asking for a full proof, I would rather appreciate some hints on which kind of induction I should use in this case. Thanks in advance!</p>\n", 'ViewCount': '13', 'Title': 'How to prove the following properties of Small-step semantics?', 'LastEditorUserId': '15669', 'LastActivityDate': '2014-04-04T16:47:11.947', 'LastEditDate': '2014-04-04T16:47:11.947', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23415', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15669', 'Tags': '<proof-techniques><operational-semantics>', 'CreationDate': '2014-04-04T00:28:36.010', 'Id': '23406'},192_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to construct the small-step semantic rules involving the for-loops, but I can't find anything about it in the literature (only about while-loops).</p>\n\n<p>I was wondering if anyone could help me out with this? This is a first attempt, where $s$ represents a statement and $e$ an expression:</p>\n\n<p>$\\quad \\displaystyle\\sigma, \\text{for } s_1 \\, e_1 \\, e_2 \\, s_2 \\, \\rightarrow \\, \\sigma, \\text{if } e_1 \\text{ then (} s_2 ; \\, e_2; \\, \\text{for } s_1 \\, e_1 \\, e_2 \\, s_2 \\text{ ) else } skip$</p>\n\n<p>Where $\\sigma$ is a local value store, $s_1$ is for example $i = 0$, $e_1$ could equal $i &lt; 4$ and $e_2$ $i=i+1$. </p>\n", 'ViewCount': '27', 'Title': 'Small-step semantics: for-loops', 'LastEditorUserId': '16897', 'LastActivityDate': '2014-04-21T10:32:24.130', 'LastEditDate': '2014-04-21T10:32:24.130', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23983', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16897', 'Tags': '<formal-languages><programming-languages><semantics><operational-semantics><small-step>', 'CreationDate': '2014-04-21T10:18:48.197', 'Id': '23981'},192_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am given the following command $C$:</p>\n\n<p>$y:=1;$\nwhile $\\neg (x=1)$ do\n$y:= y*x;$\n$x:= x - 1$.</p>\n\n<p>I have to show that $[\\![ C ]\\!]_s(s) = \\{x \\mapsto 1, y \\mapsto s(x)!\\}$ if $s(x) \\geq 1$ and undefined otherwise. Where $[\\![ C ]\\!]_s(s) = s'$ if $\\langle C, s \\rangle \\rightarrow^* s'$ and undefined otherwise.</p>\n\n<p>The proof is by induction on $s(x)$. My problem is to figure out the last step in the induction step. The induction hypothesis is that $[\\![ C ]\\!]_s(s) = \\{x \\mapsto 1, y \\mapsto s(x)!\\}$ for $s(x) \\leq k$. For the induction step I assume that $s(x)=k+1$. Using the small step semantics rules I obtain a state $s''' = \\{x \\mapsto k, y \\mapsto (k+1)\\}$. Then I can apply the induction hypothesis and obtain $[\\![ C ]\\!]_s(s) = \\{x \\mapsto 1, y \\mapsto k!\\}$. Now I am stuck - can anybody give me a hint on how to arrive at $[\\![ C ]\\!]_s(s) = \\{x \\mapsto 1, y \\mapsto (k+1)!\\}$?</p>\n", 'ViewCount': '36', 'Title': 'Proving the small-step semantics of factorial program', 'LastEditorUserId': '15669', 'LastActivityDate': '2014-04-27T13:50:47.293', 'LastEditDate': '2014-04-27T13:50:47.293', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15669', 'Tags': '<programming-languages><semantics><operational-semantics>', 'CreationDate': '2014-04-26T21:58:20.370', 'Id': '24142'}