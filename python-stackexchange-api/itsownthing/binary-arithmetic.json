2580:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a function to count upper bits of a 32 bit value. So if a number is 11100011111..., the result is 3 as there are 3 ones in the most significant place before a 0 is hit.</p>\n\n<p>I need to convert the function to use only bitwise operations (no if statements or while loops) and the total number of operations should be lesser than 50.</p>\n\n<p>Question: How can this be converted to bitwise operations only while keeping less than 50 ops?</p>\n\n<p>Here is the Code:</p>\n\n<pre><code>  int count = 0;\n  int i = 28;\n\n  while(i &gt;= 0) {\n    int temp = (x&gt;&gt;i) &amp; 0xF;\n    i-=4;\n    if(temp == 0xF) count+=4;\n    else {\n      int mask = 0x1;\n      int a = (temp&gt;&gt;3) &amp; mask;\n      int b = (temp&gt;&gt;2) &amp; mask;\n      int c = (temp&gt;&gt;1) &amp; mask;\n      int d = temp &amp; mask;\n\n      if (a != 1) break;\n        count+=1;\n      if (b != 1) break;\n        count+=1;\n      if (c != 1) break;\n        count+=1;\n      if (d != 1) break;\n        count+=1;\n    }\n</code></pre>\n', 'ViewCount': '441', 'Title': 'Converting function to bitwise only?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-12T12:11:10.530', 'LastEditDate': '2012-09-11T11:43:56.560', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2771', 'Tags': '<algorithms><integers><binary-arithmetic>', 'CreationDate': '2012-09-10T02:05:39.293', 'FavoriteCount': '2', 'Id': '3484'},2581:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am performing an addition operation on two large binary numbers that have an equal number of bits. Both numbers are stored in an array of length $N$, which is rather large.</p>\n\n<p>At first I tried running a loop over them and keeping track of carry bits. This wasted time, because the aim is to get the bit at a specific position in this sum.</p>\n\n<p>So I modified my approach in following way. Starting from the specified index, I am looping until I find a 0 bit in same position on both numbers; I add only those parts to each other and return the bit at the specified position.</p>\n\n<p>This seems okay, but is this the best I can do? Recall that I want to get the value of one specific bit of the sum, given by its position.</p>\n', 'ViewCount': '384', 'Title': 'Get specified bit in addition of two large binary numbers', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-20T20:40:41.733', 'LastEditDate': '2012-09-20T20:40:41.733', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'Ravi Joshi', 'PostTypeId': '1', 'OwnerUserId': '2908', 'Tags': '<arrays><integers><binary-arithmetic>', 'CreationDate': '2012-09-20T14:01:20.360', 'Id': '4643'},2582:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this little exercise:</p>\n\n<pre><code>for ( i = 0; i &lt; 2 * n; i += 2 )\n  for ( j = 1; j &lt;= n; j &lt;&lt;= 1 )\n    if ( j &amp; i )\n      foo ();\n</code></pre>\n\n<p>(<code>j &lt;&lt;= 1</code> means <code>j = (j &lt;&lt; 1)</code>, where <code>&lt;&lt;</code> is the bitwise left shift operator. <code>&amp;</code> is the bitwise and operator.)</p>\n\n<p>I am supposed to determine how many times will the <em>foo</em> function be called for some <em>n</em>. The result should be both an exact number (or the most accurate approximation possible) and asymptotic (like O(n)).</p>\n', 'ViewCount': '195', 'Title': 'Double-nested loop with bitwise operation', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-13T02:07:02.597', 'LastEditDate': '2012-09-22T23:09:47.477', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'Machta', 'PostTypeId': '1', 'OwnerUserId': '12141', 'Tags': '<time-complexity><imperative-programming><binary-arithmetic>', 'CreationDate': '2012-01-12T17:25:30.387', 'Id': '4681'},2583:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is the procedure for computing the rank of a <a href="http://mathworld.wolfram.com/Multiset.html" rel="nofollow">multiset</a> after inserting an element?</p>\n\n<p>For instance, lets say we have a set $S = (0,1)$ containing $n = 2$ distinct elements.</p>\n\n<p>The multiset $M = (1,1)$ has rank $5$ because there are $4$ multisets less than it based on lexicographic ordering: $(0), (1), (0,0), (0,1)$.</p>\n\n<p>If we insert $0$, we get $(0,1,1)$ which has rank $8$. If $1$ were inserted instead we\'d have $(1,1,1)$ with rank $9$.</p>\n\n<p>Is there a function $f(r,x,n)$ which takes a rank $r$, an element $x$, and $n$, and returns the new rank after inserting $x$?</p>\n', 'ViewCount': '93', 'Title': 'Computing the rank of a multiset after inserting another element', 'LastEditorUserId': '4223', 'LastActivityDate': '2012-10-27T15:58:34.620', 'LastEditDate': '2012-10-27T07:27:16.467', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '6339', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4223', 'Tags': '<algorithms><combinatorics><sets><binary-arithmetic>', 'CreationDate': '2012-10-27T01:53:27.787', 'Id': '6325'},2584:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd like to know if there is a function $f$ from n-bit numbers to n-bit numbers that has the following characteristics:</p>\n\n<ul>\n<li>$f$ should be bijective</li>\n<li>Both $f$ and $f^{-1}$ should be calculable pretty fast</li>\n<li>$f$ should return a number that has no significant correlation to its input.</li>\n</ul>\n\n<p>The rationale is this:</p>\n\n<p>I want to write a  program that operates on data. Some information of the data is stored in a binary search tree where the search key is a symbol of an alphabet. With time, I add further symbols to the alphabet. New symbols simply get the next free number available. Hence, the tree will always have a small bias to smaller keys which causes more rebalancing than I think should be needed.</p>\n\n<p>My idea is to mangle the symbol numbers with $f$ such that they are widely spread over the whole range of $[0,2^{64}-1]$. Since the symbol numbers only matter during input and output which happens only once, applying such a function should not be too expensive.</p>\n\n<p>I thought about one iteration of the Xorshift random number generator, but I don't really know a way to undo it, although it should theoretically be possible.</p>\n\n<p>Does anybody know such a function?<br>\nIs this a good idea?</p>\n", 'ViewCount': '151', 'Title': 'Function that spreads input', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-07T02:34:50.327', 'LastEditDate': '2013-01-31T06:57:46.533', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<binary-trees><hash><binary-arithmetic>', 'CreationDate': '2012-11-14T20:53:55.090', 'FavoriteCount': '2', 'Id': '6668'},2585:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having difficulty with the following question:</p>\n\n<blockquote>\n  <p>Given a bit pattern with mantissa $10110000$ and exponent $0111$, what\n  does the bit pattern represent in denary (i.e decimal / base 10)?</p>\n</blockquote>\n\n<p>I got the right answer(!) but the wrong (or alternative) work:</p>\n\n<ol>\n<li>Convert the exponent to denary: $0111$ is $7$</li>\n<li>Apply this exponent to the mantissa: $10110000\\rightarrow1011000$ after shifting $7$ places</li>\n<li>Convert the mantissa to denary: $1011000$ is $88$</li>\n<li>Set the sign: $-88$ (which is correct!)</li>\n</ol>\n\n<p>Using a different method, the mantissa $1.0110000$ is somehow deteremined to be $-11/16$ and then $-11/16 \\times 2^7 = - 88$ (I understand this shift with the exponent). However, what I don't understand is:</p>\n\n<blockquote>\n  <p><strong>How do you convert 1.0101 (mantissa) to -11/16?</strong> Is this a standard way to do it?</p>\n</blockquote>\n", 'ViewCount': '140', 'Title': 'Floating-Point Binary to Decimal', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T18:09:03.697', 'LastEditDate': '2012-11-19T18:09:03.697', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4614', 'Tags': '<terminology><binary-arithmetic>', 'CreationDate': '2012-11-16T12:02:13.513', 'Id': '6694'},2586:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '356', 'Title': 'Finding maximum and minimum of consecutive XOR values', 'LastEditDate': '2012-12-28T21:15:49.023', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '5218', 'FavoriteCount': '1', 'Body': '<p>Given an integer array (maximum size 50000), I have to find the minimum and maximum $X$ such that $X = a_p \\oplus a_{p+1} \\oplus \\dots \\oplus a_q$ for some $p$, $q$ with $p \\leq q$.</p>\n\n<p>I have tried this process: $\\text{sum}_i = a_0 \\oplus a_1 \\oplus  \\dots \\oplus a_i$ for all $i$. I pre-calculated it in $O(n)$ and then the value of $X$ for some $p$, $q$ such that $(p\\leq q)$ is: $X = \\text{sum}_q \\oplus \\text{sum}_{p-1}$. Thus:</p>\n\n<p>$$\n\\mathrm{MinAns} = \\min_{(p,q) \\text{ s.t. } p\\le q}{\\text{sum}_q \\oplus \\text{sum}_{p-1}} \\\\\n\\mathrm{MaxAns} = \\max_{(p,q) \\text{ s.t. } p\\le q}{\\text{sum}_q \\oplus \\text{sum}_{p-1}} \\\\\n$$</p>\n\n<p>But this process is of $O(n^2)$. How can I do that more efficiently?</p>\n', 'Tags': '<algorithms><algorithm-analysis><performance><binary-arithmetic><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-29T05:03:58.663', 'CommentCount': '1', 'AcceptedAnswerId': '7640', 'CreationDate': '2012-12-28T03:12:04.687', 'Id': '7622'},2587:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2499', 'Title': 'Normalizing the mantissa in floating point representation', 'LastEditDate': '2013-01-09T11:44:45.023', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4422', 'FavoriteCount': '0', 'Body': "<p>How to represent $0.148 * 2^{14}$ in normalized floating point arithmetic with the format</p>\n\n<pre><code>1 - Sign bit\n7 - Exponent in Excess-64 form\n8 - Mantissa\n</code></pre>\n\n<p>$(0.148)_{10} = (0.00100101\\;111...)_2$</p>\n\n<p>We shift it 3 bits to left to make it normalized $(1.00101\\;111)_2 * 2^{11}$. </p>\n\n<p>Exponent = $11+64 = (75)_{10} = (1001011)_2$ and Mantissa = $(01001\\;111)_2$.</p>\n\n<p>So floating point representation is $(0\\;1001011\\;00101111)_2 = (4B2F)_{16}$ <strong>Representation A</strong></p>\n\n<p>But if we store the denormalized mantissa into 8 bit register, then it won't have stored the last three $1$s and then the mantissa would have normalized from $(0.00100101)_2$ to $(1.00101\\;000)_2$ by inserting 3 $0$s instead of $1$s.</p>\n\n<p>The representation would have been $(0\\;1001011\\;00101000)_2 = (4B28)_{16}$ <strong>Representation B</strong></p>\n\n<p>So while normalizing, does the processor takes into account the denormalized mantissa bits beyond 8 bits too? Or just rounds it off? Which one is correct: <strong>A</strong> or <strong>B</strong>?</p>\n\n<p>Does it store the mantissa in fixed point representation? How does it all work?</p>\n", 'Tags': '<binary-arithmetic><floating-point><rounding>', 'LastEditorUserId': '4422', 'LastActivityDate': '2013-01-09T11:44:45.023', 'CommentCount': '0', 'AcceptedAnswerId': '7847', 'CreationDate': '2013-01-08T06:59:08.923', 'Id': '7828'},2588:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On a PC I am implementing an algorithm in which a number from a look table will be chosen randomly, and will be multiplied by 1000 or 10000. Instead of multiplying by 1000 or 10000 I am thinking of simply padding the numbers with the required 0s. This padding will be nothing but some write operations (though random writes) in memory. </p>\n\n<p>Which is more computationally efficient: multiplication or 0 padding?      </p>\n', 'ViewCount': '92', 'Title': 'Which is more computationally efficient: multiplication or 0 padding?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-01T10:45:11.737', 'LastEditDate': '2013-02-01T10:45:11.737', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9352', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<efficiency><binary-arithmetic>', 'CreationDate': '2013-01-31T11:45:12.727', 'Id': '9350'},2589:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Theoretically, if I were to subtract the number 10 from the ASCII character 10 (which is really 00110001 00110000), what would I get?</p>\n\n<p>Does the computer add both ASCII characters and subtract?  </p>\n', 'ViewCount': '286', 'Title': 'Subtracting an integer from an ASCII number', 'LastActivityDate': '2013-02-01T17:52:29.260', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '9402', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-02-01T04:05:36.380', 'Id': '9377'},25810:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm being asked this question for my computer conceptes class, can't find anything about this in my text book, and have only been able to find half-baked answers googling it.</p>\n\n<p>Why is binary subtraction referred to as the invert-add-shift-add method?</p>\n", 'ViewCount': '108', 'Title': 'Why is binary subtraction referred to as the invert-add-shift-add method?', 'LastActivityDate': '2013-02-04T05:13:12.510', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9460', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6694', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-02-03T23:53:52.910', 'Id': '9457'},25811:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '135', 'Title': 'Minimizing the full adder - where did this XOR come from?', 'LastEditDate': '2013-02-17T20:00:31.630', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6921', 'FavoriteCount': '1', 'Body': "<p>When minimizing the full adder, I don't understand why $A(\\bar{B}\\bar{C} + BC)$ reduces to $A\\overline{(B\\oplus{C})}.$</p>\n\n<p>$(\\bar{B}\\bar{C} + BC)\\to (B\\oplus{C})$ is partially decipherable, but why is $(B\\oplus{C})$ inverted to $\\overline{(B\\oplus{C})}?$</p>\n\n<hr>\n\n<p>Full adder simplification:</p>\n\n<p>$\n\\bar{A}\\bar{B}C + \\bar{A}B\\bar{C} + A\\bar{B}\\bar{C} + ABC \\\\\n= \\bar{A}(\\bar{B}C + B\\bar{C}) + A(\\bar{B}\\bar{C} + BC) \\\\\n= \\bar{A}(B\\oplus{C}) + A(\\overline{B\\oplus{C}}) \\\\\n= A\\oplus{(B\\oplus{C})}\n$</p>\n\n<hr>\n\n<h3>Could you help me out?</h3>\n\n<p>PS: I hope that this is the correct subforum of StackExchange to ask this (perhaps <em>Electrical Engineering</em> is the proper venue). I couldn't find appropriate tags on <em>either</em> site.</p>\n", 'Tags': '<binary-arithmetic><xor>', 'LastEditorUserId': '6921', 'LastActivityDate': '2013-02-17T20:11:58.480', 'CommentCount': '6', 'AcceptedAnswerId': '9869', 'CreationDate': '2013-02-17T19:43:33.377', 'Id': '9866'},25812:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to solve the following problem: </p>\n\n<p>$$ 6AD3 - AF20 $$</p>\n\n<p>Both of these are hex values in two's complement.</p>\n\n<p>I keep getting one answer but it's turning out worng. What I tried to do, was take the complement of AF20, which I got as 50D1, and instead of subtracting, I added it to 6AD3, and I got BBA4, however, I am being told this is the wrong answer.</p>\n\n<p>Where am I going wrong?</p>\n", 'ViewCount': '42', 'Title': "Subtracting a two's complement value from another two's complement value", 'LastActivityDate': '2013-03-06T06:54:06.033', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-03-06T00:57:40.247', 'Id': '10308'},25813:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to perform some interval-operations, and for addition, subtraction, and logic-/shift-operators, that works very well.</p>\n\n<p>The only problem I have is the multiplication.</p>\n\n<p>An interval $[a, b]$ denotes all two\'s complement numbers $x$ with the property $a \\leq x \\leq b$.</p>\n\n<p>An interval-operation means that if i have a binary operation $\\circ$ and two intervals $[a, b]$ and $[c, d]$, then $[a, b] \\circ [c, d] = [e, f]$ means that for for an arbitrary $x \\in [a, b]$ and $y \\in [c, d]$: $$x \\circ y \\in [e, f].$$</p>\n\n<p>But additionally, I want to have the most precise or a very precise interval.</p>\n\n<p>"The most precise" means that there are the values $w,x \\in [a, b]$ and $y,z \\in [c, d]$ for which holds that $w \\circ y = e$ and $x \\circ z = f$</p>\n\n<p>An example of an interval-operation:</p>\n\n<ul>\n<li>$A = [7,14]$</li>\n<li>$B = [-6, 77]$</li>\n<li>$A + B = [1, 91]$</li>\n</ul>\n\n<p>It\'s correct, because there is no value outside of $[1, 91]$ that can be reached, when adding numbers out of $A$ and $B$.</p>\n\n<p>Also it\'s precise, because $7+(-6) = 1$ and $14+77 = 91$</p>\n\n<p>It seems impossible to find an efficient algorithm that handles all the overflows correctly and finds the precise (or at least a good) interval.</p>\n\n<p>Is there a good algorithm?</p>\n', 'ViewCount': '103', 'Title': "Multiplying intervals in Two's complement", 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-06T14:53:16.570', 'LastEditDate': '2013-06-06T14:53:16.570', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '3133', 'Tags': '<binary-arithmetic><arithmetic><intervals>', 'CreationDate': '2013-05-29T15:43:49.867', 'Id': '12360'},25814:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve got the following theoretical problem which puzzles me a bit:</p>\n\n<p>I can obtain a string of <em>n</em> bytes (as octets, one byte = one octet = eight bits) of random data. I need to preserve the randomness <em>while</em> reducing the base from 256 to <em>x</em> where <em>x</em> is below 256 (and not 0, 1, 2, 4, 8, 16, 32, 64 or 128).</p>\n\n<p>As I want to preserve the randomness, I don\'t want to cut-off (waste) any information from this string <em>until</em> I\'ve obtained the number of chunks I need. This is for reason of randomness which can be a limited resource on the computer.</p>\n\n<p>I had the idea to do this for base64 which is simple because I can just create 4 numbers out of a single byte (by shifting bits for example: <a href="http://cvsweb.openwall.com/cgi/cvsweb.cgi/projects/phpass/PasswordHash.php?rev=1.8" rel="nofollow">encode64()</a>). But how to do with a base like 254 for example? I can not cut off at bit-boundaries here, can I?</p>\n\n<p>Do I probably need to create a number large enough out of base 2 based bits that can contain both bases? (This is one of the ideas I have so far).</p>\n\n<p>Would be great to get some feedback, I normally paint pictures with such problems, however, just discovered this website here yesterday and I normally use Stackoverflow so I thought I give it a try :D</p>\n\n<p>If you\'re interested in some non-theoretical background to my question, see <a href="http://security.stackexchange.com/q/39417/17473"><em>"What is the meaning of the term \u201csimple string\u201d for the SALT string in Unix crypt using SHA-256 and SHA-512?"</em></a>, you might get an idea why I don\'t want to loose any information bits from the random source.</p>\n', 'ViewCount': '71', 'Title': 'Bitarithmetrics to Base X', 'LastEditorUserId': '9321', 'LastActivityDate': '2013-07-25T07:53:02.513', 'LastEditDate': '2013-07-25T07:53:02.513', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '13419', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9321', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-07-24T10:39:21.783', 'Id': '13415'},25815:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>C++11 has a convenient Bernoulli RNG, illustrated at \n<a href="http://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution" rel="nofollow">http://en.cppreference.com/w/cpp/numeric/random/bernoulli_distribution</a> .\nHowever, distilling an entire random integer into a single random bit seems inefficient when the expectation parameter $p$ is rational with a small or power-of-two denominator.\nIs there a reasonably fast way to generate 32 random Bernoulli bits at once in such cases? My application uses long streams of bits, so I can keep track of statistics if needed (but this would consume runtime).</p>\n', 'ViewCount': '78', 'Title': "Isn't std::bernoulli_distribution inefficient? Designing a bit-parallel Bernoulli generator", 'LastEditorUserId': '5189', 'LastActivityDate': '2013-09-25T04:26:33.097', 'LastEditDate': '2013-09-25T04:26:33.097', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5189', 'Tags': '<randomized-algorithms><integers><randomness><binary-arithmetic>', 'CreationDate': '2013-09-22T21:10:38.360', 'Id': '14525'},25816:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Reading the Appendix A (<em>Binary numbers</em>) of <em>Structured Computer organization</em> by Tanenbaum I've found this exercise:</p>\n\n<blockquote>\n  <p>Signed decimal numbers consisting of $n$ digits can be represented in $n + 1$ digits without a sign. Positive numbers have $0$ as the leftmost digit. Negative numbers are formed by subtracting each digit from $9$. Thus the negative of $014725$ is $985274$. Such numbers are called <strong>nine</strong>\u2019s complement numbers and are analogous to one\u2019s complement binary numbers. Express the following as three-digit <strong>nine</strong>'s complement numbers: $6$. $-2$, $100$, $-14$, [etc].</p>\n</blockquote>\n\n<p>Ok, it all works fine with $6$ for instance: using the given rule it is $006 \\mapsto 993$. That makes sense: as Tanenbaum says this system for negative-value representation is similar to <strong>one</strong>'s complement: it has two different <em>zero</em> representation ($000$ and $999$) and it has negative possible value as much as the positive ones.</p>\n\n<p>What I don't understand is how can $100$ fit in this scenario. To me, with 3 digits I ca only represent value in range $[-900, 099]$; moreover $100$ is <em>not</em> considered a <em>positive</em> number --it shoudl have a $0$ as leftmost digit.</p>\n\n<p>Is there an error in Tanenbaum-exercise?, if not, where I'm wrong?</p>\n", 'ViewCount': '179', 'Title': "Can I express 100 as a three-digit 9's complement number?", 'LastActivityDate': '2013-11-04T20:09:53.287', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10482', 'Tags': '<binary-arithmetic>', 'CreationDate': '2013-10-05T14:19:28.047', 'Id': '14828'},25817:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given three numbers $m$, $n$ and $p$ in interleaved binary encoding<sup>1</sup>, it\'s obviously possible to check in $O(1)$ space whether $m+n=p$. It\'s less obvious<sup>2</sup> that it isn\'t possible  to check in $O(1)$ space whether $m\\cdot n=p$. I wonder whether one can prove that it isn\'t possible to check in $O(\\log N)$ space<sup>3</sup> whether $m\\cdot n=p$. On the other hand, are there any known non-trivial upper bounds on the space complexity of this problem, like $O(N/\\log N)$? </p>\n\n<p>The problem described above is a simplified version of the "Multiplication decision problem: Is the $k$th bit of the product of $m$ and $n$ a one?" Since this problem is more "powerful" (and also better known), I wonder whether one can show that this problem can\'t be decided in $O((\\log N)^2)$ space.</p>\n\n<hr>\n\n<p><sub>\n1. The interleaved binary encoding starts with the lowest significant bit, and allows "leading" zeros for the most significant bits.\n</sub></p>\n\n<p><sub>\n2. The proof idea I have in mind would use such an algorithm as building block for a decision procedure of Robinson arithmetic. I call this less obvious, because the fact that Robinson arithmetic is undecidable may be well known, but still remains non-trivial.\n</sub></p>\n\n<p><sub>\n3. Here $N$ is the length of the input $m$, $n$ and $p$ in binary encoding.\n</sub></p>\n', 'ViewCount': '82', 'Title': 'Known bounds on space complexity of multiplication decision problem', 'LastEditorUserId': '1557', 'LastActivityDate': '2013-10-27T19:35:21.797', 'LastEditDate': '2013-10-27T14:32:42.443', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1557', 'Tags': '<space-complexity><binary-arithmetic>', 'CreationDate': '2013-10-27T12:32:23.403', 'Id': '16469'},25818:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to subtract these two binary numbers:</p>\n\n<p>$  1110\n- 1011$</p>\n\n<p>First I convert 1011 to two's complement by doing 1011 to 0100 and then adding 1 to get 0101. Then I add the first number to the converted two's complement number:</p>\n\n<p>$1110$</p>\n\n<p>$+$ $0101$</p>\n\n<p>$-----$</p>\n\n<p>$0011$</p>\n\n<p>0 + 1 = 1</p>\n\n<p>1 + 0 = 1</p>\n\n<p>1 + 1 = 0 carry 1</p>\n\n<p>carry 1 + 1 + 0 = 0</p>\n\n<p>For a final answer of $0011$ which is 3 in decimal, however, the answer in my book says it should be 2 or 0010...?</p>\n", 'ViewCount': '57', 'Title': "Subtracting binaries using two's complement", 'LastActivityDate': '2013-11-12T03:52:34.110', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '17943', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11322', 'Tags': '<computer-architecture><binary-arithmetic>', 'CreationDate': '2013-11-12T01:20:50.483', 'Id': '17939'},25819:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If we suppose that we are given two numbers $a$ and $b$ to add, what circuit depth do we require to add them?</p>\n\n<p>I'm wondering if $a$ and $b$ are $O(n)$, and thus the amount of bits required to store $a$ and $b$ are $O(\\log_2(n))$, how much time and/or space we must require to add them.  </p>\n\n<p>I'm interested in the general case.  However, I am wondering if there is anything else to be said about the case of adding $a+2a+1$.  It would be spectacular if we could do this addition in constant circuit depth.</p>\n", 'ViewCount': '33', 'Title': 'What circuit depth is required to add?', 'LastActivityDate': '2014-01-03T01:45:41.977', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19472', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1667', 'Tags': '<circuits><binary-arithmetic>', 'CreationDate': '2014-01-03T00:44:01.267', 'Id': '19468'},25820:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m studying about Local Binary Pattern and I\'m having trouble understanding the following part about the number of output labels for binary patterns from <em>Computer Vision using Local Binary Patterns</em>, by Pietik\xe4inen et al. (2011):</p>\n\n<blockquote>\n  <p>Another extension to the original operator uses so called <em>uniform patterns</em>&nbsp;[53]. For this, a uniformity measure of a pattern is used: $U$ ("pattern") is the number of bitwise transitions from 0 to&nbsp;1 or vice versa when the bit pattern is considered circular. A local binary pattern is called uniform if its uniformity measure is at most&nbsp;2. For example, the patterns 00000000 (0&nbsp;transitions), 01110000 (2&nbsp;transitions) and 11001111 (2&nbsp;transitions) are uniform whereas the patterns 11001001 (4&nbsp;transitions) and 01010011 (6&nbsp;transitions) are not. In uniform LBP mapping there is a separate output label for each uniform pattern and all the non-uniform patterns are assigned to a single label. Thus, the number of different output labels for mapping for patterns of $P$&nbsp;bits is $P(P-1)+3$. For instance, the uniform mapping produces 59 output labels for neighborhoods of 8 sampling points and 243 labels for neighborhoods of 16 sampling points.</p>\n</blockquote>\n\n<p>I don\'t understand why the number of different LBP output labels is $P(P-1) + 3$. Could someone explain why?....</p>\n\n<p>Thnx for any help =) </p>\n\n<p>Update: I think I have some idea already :) I included an example from my book:</p>\n\n<p><img src="http://i.stack.imgur.com/AMLGu.png" alt="LBP example"></p>\n', 'ViewCount': '54', 'Title': 'Number of different output labels in Local Binary Pattern', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-01-20T12:40:12.363', 'LastEditDate': '2014-01-20T12:16:14.070', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19849', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12977', 'Tags': '<image-processing><binary-arithmetic>', 'CreationDate': '2014-01-20T07:10:14.723', 'Id': '19844'},25821:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the Hexadecimal value 98C2417D. I've converted this into non-signed decimal by multiplying each value with it's corresponding power and added them together. This gave me 2562867581. I'm having trouble obtaining the signed value for this number. I converted the number to binary and took the 2's compliment, but this didn't give me the correct answer. </p>\n", 'ViewCount': '37', 'Title': 'Converting from Hex to Signed number', 'LastActivityDate': '2014-04-05T14:47:18.853', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13366', 'Tags': '<binary-arithmetic>', 'CreationDate': '2014-02-03T20:39:48.020', 'Id': '20262'},25822:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><strong>EDIT</strong></p>\n\n<p>As requested, a single question </p>\n\n<p><strong>Why can\'t arbitrary base conversion be done as fast as converting from base $b$ to base $b^k$ ?</strong> </p>\n\n<p>There is a big time complexity difference, so I am also interested in <em>further reading material about it</em>.</p>\n\n<hr>\n\n<p><strong>Old. Original question</strong></p>\n\n<p>Conversion between power-2-radix can be done faster than between non-power-of-2 radix, they can be even done in parallel, as every digit (or some groups of them) can be decoded independently of the rest.</p>\n\n<p>For example the binary number <code>00101001</code> can be converted to hexadecimal <code>0x29</code> nibble by nibble (<code>0010</code> and <code>1001</code>), and vice versa (i.e. every hex-digit can be parsed to 4 bits independently of the rest), but doing that conversion from to decimal (or any other non-power-of-2 radix) it\'s not so easy because digits affects each other.</p>\n\n<p>I\'ve seen time complexity of math operations in <a href="http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations#Arithmetic_functions" rel="nofollow">wikipedia</a>, and there is also a related question in <a href="http://stackoverflow.com/questions/17649524/time-complexity-to-convert-a-decimal-to-another-base">stackoverflow</a> saying time complexity of conversions of arbitrary digit length to be $\\mathcal{O}(M(n) log(n))$</p>\n\n<p>I\'m not interested in a "general time complexity bounds for any base conversion" but I would like to know more about the big differences in time complexity between power-of-2 conversions vs any other base conversions. </p>\n\n<p>It\'s could be a general fact about conversions that can be done faster if they are done between numbers where its bases are power among themselves, not only for 2, but the same to a base 10 to base 100.</p>\n\n<p>Is there any known proof or materials around this ?</p>\n', 'ViewCount': '185', 'Title': 'Time complexity of base conversion', 'LastEditorUserId': '1396', 'LastActivityDate': '2014-04-18T19:19:26.113', 'LastEditDate': '2014-02-21T12:31:12.923', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<complexity-theory><reference-request><time-complexity><binary-arithmetic>', 'CreationDate': '2014-02-17T13:58:42.143', 'FavoriteCount': '1', 'Id': '21736'},25823:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '267', 'Title': 'How does binary addition work?', 'LastEditDate': '2014-03-09T04:55:53.763', 'AnswerCount': '1', 'Score': '6', 'OwnerDisplayName': 'Link TheProgrammer', 'PostTypeId': '1', 'OwnerUserId': '15435', 'FavoriteCount': '3', 'Body': '<p>I find <strong>binary</strong> confusing. I have watched minecraft redstone videos on binary adders, real binary adders, diagrams, etc and yet I have not learned much at all. <em>How does electrons flowing through wires made of gold "add/subtract" to make numbers through some logic gates?!</em></p>\n', 'Tags': '<logic><binary-arithmetic>', 'LastEditorUserId': '15202', 'LastActivityDate': '2014-03-09T23:34:17.203', 'CommentCount': '6', 'AcceptedAnswerId': '22415', 'CreationDate': '2014-03-09T00:06:51.107', 'Id': '22413'},25824:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What are the best arithmetic algorithms out there (addition, subtraction, multiplication, division, power, root)?</p>\n\n<p>I am looking for algorithms that could be easily extended to multiprecision and arbitrary precision settings.</p>\n', 'ViewCount': '26', 'Title': 'Best (Fastest) Arithmetic Algorithms', 'LastActivityDate': '2014-05-03T17:24:56.497', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17001', 'Tags': '<binary-arithmetic><arithmetic>', 'CreationDate': '2014-05-03T14:10:19.847', 'Id': '24353'}