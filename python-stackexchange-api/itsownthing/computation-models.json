143_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1567', 'Title': 'How to define quantum Turing machines?', 'LastEditDate': '2012-12-13T02:14:16.660', 'AnswerCount': '2', 'Score': '30', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '3', 'Body': '<p>In quantum computation, what is the equivalent model of a Turing machine? \nIt is quite clear to me how quantum <strong>circuits</strong> can be constructed out of quantum gates, but how can we define a quantum Turing machine (QTM) that can actually benefit from quantum effects, namely, perform on high-dimensional systems?</p>\n', 'Tags': '<quantum-computing><turing-machines><computation-models>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:14:16.660', 'CommentCount': '4', 'AcceptedAnswerId': '230', 'CreationDate': '2012-03-08T04:51:08.750', 'Id': '125'},143_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '574', 'Title': 'Is interaction more powerful than algorithms?', 'LastEditDate': '2013-03-20T20:57:17.867', 'AnswerCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '3', 'Body': '<p>I\'ve heard the motto <a href="http://www.cs.brown.edu/people/pw/papers/ficacm.ps"><strong>interaction is more powerful than algorithms</strong></a> from <a href="http://www.cs.brown.edu/~pw/">Peter Wegner</a>. The basis of the idea is that a (classical) Turing Machine cannot handle interaction, that is, communication (input/output) with the outside world/environment.</p>\n\n<blockquote>\n  <p>How can this be so? How can something be more powerful than a Turing Machine? What is the essence of this story? Why is it not more well known?</p>\n</blockquote>\n', 'Tags': '<computability><computation-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T20:57:17.867', 'CommentCount': '8', 'AcceptedAnswerId': '488', 'CreationDate': '2012-03-16T20:33:26.857', 'Id': '438'},143_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A polynomial-time Turing machine algorithm is considered efficient if its run-time, in the worst-case, is bounded by a polynomial function in the input size. I'm aware of the strong Church-Turing thesis:</p>\n\n<blockquote>\n  <p>Any reasonable model of computation can be efficiently simulated on Turing machines</p>\n</blockquote>\n\n<p>However, I'm not aware of solid theory for analyzing the computational complexity of algorithms of $\\lambda$-calculus.</p>\n\n<p>Do we have a notion of computational efficiency for every known model of computation? Are there any models that are only useful for computability questions but useless for computational complexity questions?</p>\n", 'ViewCount': '301', 'Title': 'Notions of efficient computation', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-02T03:50:01.950', 'LastEditDate': '2012-04-02T03:50:01.950', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><efficiency><computation-models>', 'CreationDate': '2012-03-20T15:52:42.367', 'FavoriteCount': '1', 'Id': '540'},143_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '430', 'Title': 'Quantum lambda calculus', 'LastEditDate': '2012-04-02T03:49:36.880', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '55', 'FavoriteCount': '5', 'Body': '<p>Classically, there are 3 popular ways to think about computation: Turing machine, circuits, and lambda-calculus (I use this as a catch all for most functional views). All 3 have been fruitful ways to think about different types of problems, and different fields use different formulation for this reason. </p>\n\n<p>When I work with quantum computing, however, I only ever think about the circuit model. Originally, QC was defined in terms of <a href="http://cs.stackexchange.com/q/125/55">quantum Turing machines</a> but as far as I understand, this definition (although equivalent to quantum circuits if both are formulated carefully) has not been nearly as fruitful. The 3rd formulation (in terms of lambda-calculus or similar functional settings) I am completely unfamiliar with. Hence my questions:</p>\n\n<ul>\n<li><p><strong>What are useful definitions of quantum lambda-calculus (or other functional paradigms)?</strong></p></li>\n<li><p><strong>What subfields of QIP gain deeper insight from using this formulation instead of the circuit model?</strong></p></li>\n</ul>\n\n<hr>\n\n<h3>Notes</h3>\n\n<p>I am aware that I am ignoring many other popular formalisms like cellular automata, RAM-models, etc. I exclude these mostly because I don\'t have experience with thinking in terms of these models classically, let alone <a href="http://cstheory.stackexchange.com/q/6932/1037">quantumly</a>. </p>\n\n<p>I am also aware that there are popular alternatives in the quantum setting, such as measurement-based, topological, and adiabatic. I do not discuss them because I am not familiar with the classical counterparts.</p>\n', 'Tags': '<lambda-calculus><quantum-computing><reference-request><computation-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-20T22:51:58.170', 'CommentCount': '3', 'AcceptedAnswerId': '1400', 'CreationDate': '2012-04-02T00:30:46.053', 'Id': '971'},143_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '321', 'Title': 'What is required for universal analogue computation?', 'LastEditDate': '2012-04-15T22:27:58.790', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1101', 'FavoriteCount': '1', 'Body': '<p>What operations need to be performed in order to do any arbitrary <a href="http://en.wikipedia.org/wiki/Analog_computer" rel="nofollow">analogue computation</a>? Would addition, subtraction, multiplication and division be sufficient?</p>\n\n<p>Also, does anyone know exactly what problems are tractable using analogue computation, but not with digital?</p>\n', 'Tags': '<computability><computation-models><turing-completeness>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-25T12:25:53.527', 'CommentCount': '10', 'AcceptedAnswerId': '1293', 'CreationDate': '2012-04-15T15:04:06.820', 'Id': '1292'},143_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am studying different approaches for the definition of computation with continuous dynamical systems. I have been trying to find a nice introduction to the theory of <a href="http://en.wikipedia.org/wiki/State_transition_system">"State transition systems"</a> but failed to do so.</p>\n\n<p>Does anybody know a modern introduction to the topic? \nOf particular interest would be something dealing with computability.</p>\n', 'ViewCount': '186', 'Title': 'What is a good reference to learn about state transition systems?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T18:45:31.160', 'LastEditDate': '2012-04-18T18:45:31.160', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '715', 'Tags': '<computability><automata><reference-request><computation-models>', 'CreationDate': '2012-04-18T09:13:20.920', 'FavoriteCount': '1', 'Id': '1335'},143_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '542', 'Title': 'Please explain this formal definition of computation', 'LastEditDate': '2012-05-05T20:24:28.687', 'AnswerCount': '3', 'Score': '5', 'OwnerDisplayName': 'Stefano Borini', 'PostTypeId': '1', 'OwnerUserId': '1377', 'FavoriteCount': '2', 'Body': "<p>I am trying to attack TAOCP once again, given the sheer literal heaviness of the volumes I have trouble committing to it seriously. In TAOCP 1 Knuth writes, page 8, basic concepts::</p>\n\n<blockquote>\n  <p>Let $A$ be a finite set of letters. Let $A^*$ be the set of all strings in $A$ (the set of all ordered sequences $x_1$ $x_2$ ... $x_n$ where $n \\ge 0$ and $x_j$ is in $A$ for $1 \\le j \\le n$). The idea is to encode the states of the computation so that they are represented by strings of $A^*$ . Now let $N$ be a non-negative integer and Q (the state) be the set of all $(\\sigma, j)$, where $\\sigma$ is in $A^*$ and j is an integer $0 \\le j \\le N$; let $I$ (the input) be the subset of Q with $j=0$ and let $\\Omega$ (the output) be the subset with $j = N$. If $\\theta$ and $\\sigma$ are strings in $A^*$, we say that $\\theta$ occurs in $\\sigma$ if $\\sigma$ has the form $\\alpha \\theta \\omega$ for strings $\\alpha$ and $\\omega$. To complete our definition, let $f$ be a function of the following type, defined by the strings $\\theta_j$, $\\phi_j$ and the integers $a_j$, $b_j$ for $0 \\le j \\le N$:</p>\n  \n  <ul>\n  <li>$f((\\sigma, j)) = (\\sigma, a_j)$ if $\\theta_j$ does not occur in $\\sigma$</li>\n  <li>$f((\\sigma, j)) = (\\alpha \\psi_j \\omega, b_j)$ if $\\alpha$ is the shortest possible string for which $\\sigma = \\alpha \\theta_j \\omega$</li>\n  <li>$f((\\sigma,N)) = (\\sigma, N)$</li>\n  </ul>\n</blockquote>\n\n<p>Not being a computer scientist, I have trouble grasping the whole passage. I kind of get the idea that is behind a system of opcodes, but I haven't progressed effectively in understanding. I think that the main problem is tat I don't know how to read it effectively. </p>\n\n<p>Would it be possible to explain the passage above so that I can understand it, and give me a strategy in order to get in the logic in interpreting these statements?</p>\n", 'Tags': '<formal-languages><turing-machines><computation-models>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-10T13:45:00.413', 'CommentCount': '8', 'CreationDate': '2012-05-04T22:03:23.210', 'Id': '1666'},143_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a question I have stumbled upon in my exam revision and I find it intriguing:</p>\n\n<p><strong>My computer is blue and it has a massive graphics card and a DVD and every-\nthing so which is more powerful: my computer or a Pushdown Automaton?</strong></p>\n\n<hr>\n\n<h2>My Thoughts</h2>\n\n<p>When we talk about power I have assumed this to be computational power. I believe that a PDA has the computational power to equal the computational power of a CPU (cpu in this case is the core elements of a computer ie memory and processor). This is because a PDA utilises a stack which is memory(RAM) in a computer. The PDA has states as does a CPU and also the PDA calculates simple logic at each state. I realise that the PDA itself would be a complex series of states to emulate the computational power of the cpu and there would have to be a series of PDAs to compute different functions.  </p>\n\n<p>My Question:  I know that Turing machines are best used to simulate the logic of a CPU but <strong>am I right in saying that a PDA (Or PDA's) can be designed to be as powerful as a cpu?</strong></p>\n", 'ViewCount': '516', 'Title': 'Is a PDA as powerful as a CPU?', 'LastEditorUserId': '55', 'LastActivityDate': '2012-05-16T13:59:34.493', 'LastEditDate': '2012-05-16T12:48:10.083', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'OwnerDisplayName': 'Mike Howard', 'PostTypeId': '1', 'Tags': '<computability><computation-models><computable-analysis>', 'CreationDate': '2012-05-16T10:47:59.193', 'Id': '1868'},143_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Turing machines have a <a href="https://en.wikipedia.org/wiki/Turing_machine#Formal_definition">formal</a> symbol alphabet, state and transition-rules based description of how a computation is done.   </p>\n\n<p><a href="https://en.wikipedia.org/wiki/Actor_model">The Actor Model</a> is sometimes mentioned as a more powerful computational-model than Turing machines (not in what it can compute, but in other aspects).  </p>\n\n<ol>\n<li>Is The Actor Model a full fledged Turning machine alternative as a computational model?  </li>\n<li>Does The Actor Model also have such a symbol-based formal computation description akin to the Turing machine?</li>\n<li>Are the actors assumed to be Turing machine equivalent - since each message is processed sequentially (and atomically)?</li>\n</ol>\n\n<p>There are many theoretical results based on Turing machines, e.g. the halting problem, decidability, relation to G\xf6del\'s incompleteness theorem etc.  </p>\n\n<p>Can these proofs be formally generalize to the Actor Model? Has this been done?</p>\n', 'ViewCount': '233', 'Title': 'Turing Machine-Like Formalism for The Actor Model', 'LastEditorUserId': '41', 'LastActivityDate': '2013-07-20T09:20:54.697', 'LastEditDate': '2013-07-20T09:20:54.697', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1813', 'Tags': '<terminology><computability><reference-request><programming-languages><computation-models>', 'CreationDate': '2012-06-10T05:42:02.043', 'Id': '2311'},143_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '389', 'Title': 'How to show two models of computation are equivalent?', 'LastEditDate': '2012-08-13T22:04:59.613', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'FavoriteCount': '1', 'Body': "<p>I'm seeking explanation on how one could prove that two models of computation are equivalent. I have been reading books on the subject except that equivalence proofs are omitted. I have a basic idea about what it means for two models of computation to be equivalent (the automata view: if they accept the same languages). Are there other ways of thinking about equivalence? If you could help me understand how to prove that the Turing-machine model is equivalent to lambda calculus, that would be sufficient.</p>\n", 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><machine-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:00.330', 'CommentCount': '5', 'AcceptedAnswerId': '3162', 'CreationDate': '2012-08-13T21:03:50.690', 'Id': '3154'},143_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>As far as I understand, you receive an output from a quantum computer for an algorithm in the form of an amplitude, which is one of the many states your qubits may be in, however this amplitude is a complex number.</p>\n\n<p>I understand that you have to square the amplitude to find the probability of finding that amplitude, but how do you convert that original amplitude into something relevant to the problem (i.e. that 3*5=15)? Is there coding within the algorithm to change the amplitude into a malleable answer?</p>\n', 'ViewCount': '131', 'Title': "Quantum computing 'amplitudes'", 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-02T00:30:20.283', 'LastEditDate': '2012-10-31T21:58:26.033', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4415', 'Tags': '<quantum-computing><computation-models>', 'CreationDate': '2012-10-31T21:53:05.420', 'Id': '6408'},143_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<ol>\n<li><p>How is an arithmetic model defined? </p>\n\n<p>What relations are between it and Turing machine? Are they equivalent in some sense?</p>\n\n<p>Is it true that </p>\n\n<ul>\n<li><p>in the arithmetic model of computation, the basic arithmetic operations (addition, subtraction, multiplication, division, and\ncomparison) take a constant unit time step to perform, regardless of\nthe sizes of the operands.</p></li>\n<li><p>in the Turing machine, the time each operation takes will depends on the storage size of the operands?</p></li>\n</ul>\n\n<p>What is the point of having these two different computational models?</p></li>\n<li><p>Are there other models of computation distinct from the Turing\nmachine and the arithmetic model?</p></li>\n<li><p>There are algorithms which run in polynomial time in the Turing machine model, but not in the arithmetic\nmodel. The\nEuclidean algorithm for computing the greatest common divisor of two\nintegers is one example.</p>\n\n<p>If an algorithm runs in polynomial time in the Turing machine, will\nit run in polynomial time in the arithmetic model?</p></li>\n<li><p>Is an algorithm running in polynomial storage space defined the same under the Turing machine and the arithmetic model?</p></li>\n</ol>\n\n<p>Thanks and regards!</p>\n', 'ViewCount': '458', 'Title': 'Models of computation: the arithmetic model, Turing machine (and ...)', 'LastEditorUserId': '336', 'LastActivityDate': '2012-12-22T00:46:44.670', 'LastEditDate': '2012-12-17T15:39:04.030', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '336', 'Tags': '<complexity-theory><computation-models>', 'CreationDate': '2012-12-17T15:08:46.770', 'FavoriteCount': '2', 'Id': '7463'},143_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '122', 'Title': 'Looking for some more details on "Turing" devices', 'LastEditDate': '2012-12-20T05:57:30.353', 'AnswerCount': '3', 'Score': '0', 'OwnerDisplayName': 'Steel City Hacker', 'PostTypeId': '1', 'OwnerUserId': '5132', 'Body': "<p>I've been reading a lot of computer science literature in the recent past but haven't ran across an explanation of Turing machines, the different types, and why they seem to come up so often (I understand they are a sort of a basis for CS topics).  </p>\n\n<p>I've also seen comments by some members mentioning turing-completeness (Particularly when dealing with programming languages) and was just looking for some clarification.  </p>\n\n<p>I did search around before posting this and haven't been able to find a similar post or a website that describes this in terms that I have been able to understand or decipher.  Thanks.  </p>\n", 'Tags': '<terminology><turing-machines><computation-models><turing-completeness>', 'LastEditorUserId': '3094', 'LastActivityDate': '2012-12-20T05:57:30.353', 'CommentCount': '3', 'AcceptedAnswerId': '7520', 'CreationDate': '2012-12-19T15:33:23.660', 'Id': '7512'},143_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>When working with \u03bb-Calculus I see lots of extensions that use other symbols such as \n\u2200 &lt;:Top {} \u2190, which are from "<a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">Types and Programming Languages</a>" (<a href="http://www.worldcat.org/title/types-and-programming-languages/oclc/51958338&amp;referer=brief_results" rel="nofollow">WorldCat</a>) by Benjamin C. Pierce.</p>\n\n<pre><code>Name                   Extends/Based on Figure                          Figure                                                   Page\nB unyped                                                                3-1 Booleans (B)                                         34\nB \u2115 (untyped)          Extends 3-1 B                                    3-2 Arithmetic expressions (\u2115B)                          41\n\u2192 (untyped)                                                             5-3 Unyped lambda-calculus (\u03bb)                           72\nB (typed)              Extends 3-1 B                                    8-1 Typing rules for booleans (B)                        93\nB \u2115 (typed)            Extends 3-1, 8-1 B                               8-2 Typing rules for numbers (\u2115B)                        93\n\u2192 (typed)              Based on5-3 \u03bb                                    9-1 Pure simply typed lambda-calculus (\u03bb\u2192)               103\n\u2192 Unit                 Extends 9-1 \u03bb\u2192                                   11-2 Unit type                                           119\n\u2192 as                   Extends 9-1 \u03bb\u2192                                   11-3 Ascription                                          122\n\u2192 let                  Extends 9-1 \u03bb\u2192                                   11-4 let binding                                         124\n\u2192 x                    Extends 9-1 \u03bb\u2192                                   11-5 Pairs                                               126\n\u2192 {}                   Extends 9-1 \u03bb\u2192                                   11-6 Tuples                                              128\n\u2192 {}                   Extends 9-1 \u03bb\u2192                                   11-7 Records                                             129\n\u2192 {} let p (untyped)   Extends 11-7, 11-4                               11-8 (Untyped) record patterns                           131\n\u2192 +                    Extends 9-1 \u03bb\u2192                                   11-9 Sums                                                132\n\u2192 +                    Extends 9-1 \u03bb\u2192                                   11-10 Sums (with unique typing)                          135\n\u2192 &lt;&gt;                   Extends 9-1 \u03bb\u2192                                   11-11 Variants                                           136\n\u2192 fix                  Extends 9-1 \u03bb\u2192                                   11-12 General recursion                                  144\n\u2192 B List               Extends 9-1 \u03bb\u2192 with 8-1 booleans                 11-13 Lists                                              147\n\u2192 Unit Ref             Extends 9-1 \u03bb\u2192 with 11-2 Unit                    13-1 References                                          166\n\u2192 error                Extends 9-1 \u03bb\u2192                                   14-1 Errors                                              172\n\u2192 error try            Extends 9-1 \u03bb\u2192 with 14-1 Errors                  14-2 Error handling                                      174\n\u2192 exceptions           Extends 9-1 \u03bb\u2192                                   14-3 Exceptions carrying values                          175\n\u2192 &lt;: Top               Extends 9-1 \u03bb\u2192                                   15-1 Simply typed lambda-calculus with subtyping (\u03bb&lt;:)   186\n\u2192 {} &lt;:                Extends 15-1 \u03bb&lt;: and 11-7 Records                15-3 Records and subtyping                               187\n\u2192 &lt;: Bot               Extends 15-1 \u03bb&lt;:                                 15-4 Bottom type                                         192\n\u2192 &lt;&gt; &lt;:                Extends 15-1 \u03bb&lt;: and 11-11 Simple variant rules  15-5 Variants and subtyping                              197\n\u2192 {} &lt;:                Extends 15-1 \u03bb&lt;: and 15-3 Records and subtyping  16-1 Subtype relataion with records (compact version)    211\n\u2192 {} &lt;:                                                                 16-2 Algorithmic subtyping                               212\n\u2192 {} &lt;:                                                                 16-3 Algorithmic typing                                  217\n\u2192 u                    Extends 9-1 \u03bb\u2192                                   20-1 Iso-recursive types (\u03bbu)                            276\n\u2192\u2200                     Based on 9-1 \u03bb\u2192                                  23-1 Polymorphic lambda-calculus (System F)              343\n\u2192\u2200\u2203                    Extends 23-1 System F                            24-1 Exestential types                                   366\n\u2192\u2200\u2203 Top                Based on 23-1 System F and 15-1 simple subtyping 26-1 Bounded quantification (kernel F&lt;:)                 392\n\u2192\u2200\u2203 Top full           Extends 26-1 F&lt;:                                 26-2 "Full" bounded quantification                       395\n\u2192\u2200&lt;: Top \u2203             Extends 26-1 F&lt;: and 24-1 unbounded existentials 26-3 Bounded existential quantification (kernel variant) 406 \n\u2192\u2200&lt;: Top                                                                28-1 Exposure Algorithm for F&lt;:                          418\n\u2192\u2200&lt;: Top               Extends 16-3 \u03bb&lt;:                                 28-2 Algorithmic typing for F&lt;:                          419\n\u2192\u2200&lt;: Top               Extends 16-2 \u03bb&lt;:                                 28-3 Algorithmic subtyping for kernel F&lt;:                422\n\u2192\u2200&lt;: Top full          Extends 28-3                                     28-4 Algorithmic subtyping for full F&lt;:                  424\n-\u21d2                     Extends 9-1 \u03bb\u2192                                   29-1 Type operators and kinding (\u03bb\u03c9)                     466\n-\u2200\u21d2                    Extends 29-1 \u03bb\u03c9 and 23-1 System F                30-1 Higher-order polymorphic lambda-calculus (F\u03c9)       450\n-\u2200\u2203\u21d2                   Extends 30-1 F\u03c9 and 24-1                         30-2 Higher-order existential types                      452\n-\u2200\u21d2&lt;: Top              Based on 30-1 F\u03c9 and 16-1 kernel F&lt;:             31-1 Higher-order bounded quantification (F\u03c9&lt;:)          470\n-\u2200&lt;: Top {}\u2190           Based on 26-1 F&lt;: with 11-7 records              32-1 Polymorphic update                                  485  \n</code></pre>\n\n<p>or use of \u03c3 and \u03bd as in</p>\n\n<p>"<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8716" rel="nofollow">From \u03bb\u03c3 to \u03bb\u03bd-a Journey through Calculi of Explicit Substitutions</a>" by Pierre Lescanne.</p>\n\n<p>and of course <a href="http://www.rbjones.com/rbjpub/logic/cl/tlc001.htm" rel="nofollow">Barendregt\'s Lambda Cube</a>  </p>\n\n<p>Note: For the Weak systems \u03c9 should be underlined.  </p>\n\n<pre><code>\u03bb\u2192   The Simply Typed Lambda Calculus  \n\u03bb\u03c9   Weak Lambda Omega  \n\u03bb2   Polymorphic or Second Order, Typed Lambda Calculus  \n\u03bb\u03c9   The System F\u03c9  \n\u03bbP   LF  \n\u03bbP\u03c9  Weak Lambda P omega   \n\u03bbP2  Lambda P2   \n\u03bbP\u03c9  The Calculus of Constructions  \n</code></pre>\n\n<p>Is there any standard or commonality to the use of these symbols? Where can I find a listing of their meaning.</p>\n\n<p>Also, as I have shown with the extenstions using TAPL, is there any list of the most noteworthy calculi with there symbols, defnition and what they extend? </p>\n\n<p>I am really after a DAG of related \u03bb-Calculi that gives a brief explaination of each one.</p>\n', 'ViewCount': '242', 'Title': u'\u03bb-Calculus extensions: meaning of extension symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:32:58.173', 'LastEditDate': '2013-02-14T06:32:58.173', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<terminology><lambda-calculus><computation-models>', 'CreationDate': '2013-02-06T15:28:33.213', 'Id': '9548'},143_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '511', 'Title': 'What is the exact relation between programming languages and Turing machines?', 'LastEditDate': '2013-03-11T07:22:24.840', 'AnswerCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2529', 'FavoriteCount': '1', 'Body': '<p>I don\'t know much about yacc, bison, flex or lex and please correct me if I\'m wrong but a programming language is also a Turing machine and a Turing machine is defined as the tuple $(Q, \\Gamma, b, \\Sigma, \\delta, q_0, F)$ where $Q$, $\\Gamma$, $b \\in \\Gamma$, $\\Sigma \\subseteq \\Gamma \\smallsetminus \\{ b \\}$ as input, $\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{ L, R, N \\}$ as transition function where $L$ = number of steps to the left, $R$ = number of steps to the right, $N$ = "standby", $q_0 \\in Q$ is the initial state and $F \\subseteq Q$ is the set of end states.</p>\n\n<p>How similar is implementing a programming language to implementing a Turing machine? Can it be said that what is done when a programming language is implemented is that a Turing machine like the above is defined? If yes, how come we can\'t just use a model that looks like the definition of a Turing machine when a programming language is defined? Instead something else like BNF seems to be the standard.</p>\n', 'Tags': '<turing-machines><formal-grammars><programming-languages><computation-models>', 'LastEditorUserId': '2980', 'LastActivityDate': '2013-03-11T07:22:24.840', 'CommentCount': '5', 'AcceptedAnswerId': '10344', 'CreationDate': '2013-03-06T23:06:28.763', 'Id': '10338'},143_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '116', 'Title': 'Is there an always-halting, limited model of computation accepting $R$ but not $RE$?', 'LastEditDate': '2013-05-10T21:42:07.617', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '0', 'Body': '<p>So, I know that the halting problem is undecidable for Turing machines. The trick is that TMs can decide recursive languages, and can accept Recursively Enumerable (RE) languages.</p>\n\n<p>I\'m wondering, is there a more limited model of computation which accepts only recursive languages, and not RE? And if so, is there such a model which is always guaranteed to halt?</p>\n\n<p>Obviously this model would be strictly less powerful than TMs and strictly more powerful than PDAs.</p>\n\n<p>I\'m open to a machine-style model, or a lambda-calculus style model.</p>\n\n<p>As an example of what I\'m thinking: the Coq language has a restriction that for any self-recursive calls, the first argument must be strictly decreasing in "size" i.e. if it is a natural number, it must be smaller, if it is a list, it must be shorter, etc. This guarantees that it always halts, but I have no idea if you can compute all of R this way.</p>\n', 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><halting-problem>', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-11T07:39:41.863', 'CommentCount': '1', 'AcceptedAnswerId': '11943', 'CreationDate': '2013-05-10T15:58:41.437', 'Id': '11936'},143_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If ${A}{ \\le _M} {{B}} $ then $\\overline A { \\le _M}\\overline B$ since the mapping reduction function is computable. </p>\n\n<p>So, if ${A_{TM}}{ \\le _M}\\overline {{A_{TM}}} $ then $\\overline{A_{TM}}{ \\le _M} {{A_{TM}}} $, hence $A{}_{TM} \\notin RE$. However, $A{}_{TM} \\in RE$.</p>\n\n<p>So is the claim above is true?</p>\n', 'ViewCount': '87', 'Title': 'The complement of the acceptance problem reduces to the acceptance problem: ${A_{TM}}{ \\le _M}\\overline {{A_{TM}}} $ is this claim true?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-05-31T13:04:46.543', 'LastEditDate': '2013-05-31T13:04:46.543', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8462', 'Tags': '<computability><reductions><computation-models>', 'CreationDate': '2013-05-31T11:54:45.417', 'Id': '12396'},143_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Within the field of cache-oblivious algorithms the ideal cache model is used for determining the cache complexity of an algorithm.  One of the assumptions of the ideal cache model is that it models a "tall cache".  This is given by the statement $Z = \\Omega(L^2)$.  Where $Z$ is the size of the cache and $L$ is the size of the cache line.  What does $\\Omega$ represent?</p>\n', 'ViewCount': '69', 'Title': 'In the "tall cache assumption" what does $\\Omega$ represent?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-03T13:21:34.633', 'LastEditDate': '2013-07-03T13:21:34.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13053', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8986', 'Tags': '<asymptotics><landau-notation><computation-models><cpu-cache>', 'CreationDate': '2013-07-03T08:32:00.390', 'Id': '13052'},143_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://en.wikipedia.org/wiki/Tag_system" rel="nofollow">Tag systems</a> are Turing-complete. I was wondering if there is any easy way to create tag systems that simulate finite automata. So create tag systems that recognize languages, e.g. by having at the end just one output symbol "A" for accepting the initial input or "R" for rejecting it.</p>\n\n<p>I guess a solution would be to make a Tag system simulate a specific Turing machine that simulates a finite automaton but that seems too much and too complicated. Is there perhaps a direct way from tag systems to finite automata?</p>\n', 'ViewCount': '67', 'Title': 'Make a tag system simulate a finite automaton?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:35:42.117', 'LastEditDate': '2013-08-22T14:35:42.117', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '927', 'Tags': '<computability><finite-automata><simulation><computation-models><turing-completeness>', 'CreationDate': '2013-08-19T03:42:11.630', 'FavoriteCount': '1', 'Id': '13808'},143_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there an "official" name for this slight variant of the well known <a href="http://en.wikipedia.org/wiki/Tag_system">Tag System</a> model of computation, and/or has it been used somewhere?</p>\n\n<ul>\n<li>a finite alphabet of symbols $\\Sigma$</li>\n<li>a halt symbol $H$</li>\n<li>an ordered set of production rules: \n$$P_i: \\alpha_i \\rightarrow \\beta_i, \\quad \\alpha_i \\in \\Sigma^+, \\beta_i \\in \\Sigma^* \\cup \\{H\\}$$</li>\n<li>the input $w$ is a string in $\\Sigma^+$</li>\n</ul>\n\n<p>The computation is:</p>\n\n<ol>\n<li>find the first production rule $P_i$ for which $w = \\alpha_i v$; </li>\n<li>replace $w = \\alpha_i v$ with $v\\beta_i$ (i.e. delete the prefix $\\alpha_i$ and append $\\beta_i$)</li>\n<li>halt when no production is found or $\\beta_i = H$</li>\n</ol>\n\n<p>This model differs from a tag system because 1) $\\alpha_i$ is a string and not a single symbol, 2) the number of characters deleted from the prefix is not fixed.</p>\n\n<p>It can easily simulate a $m$-tag system in "real-time" (for every rule $x \\rightarrow P(x)$ of the m-tag system add production rules $xv \\rightarrow P(x)$, $v \\in |\\Sigma|^{m-1}$) and therefore it can efficiently simulate a Turing machine.</p>\n', 'ViewCount': '50', 'Title': 'Tag system variant', 'LastActivityDate': '2013-10-30T04:01:57.713', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14051', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '140', 'Tags': '<reference-request><computation-models>', 'CreationDate': '2013-08-30T09:50:16.547', 'Id': '14034'},143_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The theorem of structured programming says that any algorithm can be expressed by those three control structures:</p>\n\n<ol>\n<li>Sequence</li>\n<li>Selection</li>\n<li>Iteration</li>\n</ol>\n\n<p>Isn't it possible to rewrite any loop using a finite sequence of statements and choice between statements? Isn't this what compilers do? Can't we thus omit the third structure and stay equally expressive?</p>\n", 'ViewCount': '27', 'Title': 'Can a loop be expressed by only the sequence of statements and the choice of statements?', 'LastActivityDate': '2013-09-23T14:57:06.717', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8623', 'Tags': '<programming-languages><computation-models><programming-paradigms>', 'CreationDate': '2013-09-23T14:05:04.723', 'Id': '14553'},143_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p><a href="http://en.wikipedia.org/wiki/Structured_program_theorem" rel="nofollow">Wikipedia</a>:</p>\n\n<blockquote>\n  <p>The structured program theorem [...] states that [...] any algorithm\n  can be expressed using only three control structures. They are</p>\n  \n  <ul>\n  <li>Executing one subprogram, and then another subprogram (sequence)</li>\n  <li>Executing one of two subprograms according to the value of a boolean expression (selection)</li>\n  <li>Executing a subprogram until a boolean expression is true (iteration)</li>\n  </ul>\n</blockquote>\n\n<p>This theorem is developed in the following papers:</p>\n\n<ul>\n<li>C. B\xf6hm, "On a family of Turing machines and the related programming language", ICC Bull., 3, 185\u2013194, July 1964. </li>\n<li>C. B\xf6hm, G. Jacopini, "Flow diagrams, Turing Machines and Languages with only Two Formation Rules", Comm. of the ACM, 9(5): 366\u2013371,1966.</li>\n</ul>\n\n<p>Unfortunately, the first one is practically unavailable, and the second one, in addition to being a bit cryptic (at least for me), refers to the first, so I have problems to understand the proof. Can anyone help me? Is there a modern paper or book which presents the proof? Thanks.</p>\n\n<hr>\n\n<p><strong>UPDATE</strong> </p>\n\n<p>To be exact, I would like to understand the <em>second part of the CACM paper</em> (section 3). The authors write in section 1 the following:</p>\n\n<blockquote>\n  <p>In the second part of the paper (by C. B\xf6hm), some results of a\n  previous paper are reported [8] and the results of the first part of\n  this paper are then used to prove that every Turing machine is\n  reducible into, or in a determined sense is equivalent to, a program\n  written in a language which admits as formation rules only composition\n  and iteration.</p>\n</blockquote>\n\n<p>Here [8] refers to the unavailable ICC Bulletin paper. It is easy to see that the above quote from Wikipedia refers to this second part of the CACM paper (the Turing machine serves as a precise definition of algorithms; "composition" means sequence; an iteration can replace a selection).</p>\n', 'ViewCount': '198', 'Title': 'How to prove the structured program theorem?', 'LastEditorUserId': '9571', 'LastActivityDate': '2013-10-11T18:34:04.180', 'LastEditDate': '2013-10-10T19:44:45.940', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '14988', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<computability><programming-languages><computation-models>', 'CreationDate': '2013-10-10T11:42:54.877', 'Id': '14983'},143_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>The following is a homework assignment. I am looking for criticism / feedback on my solution, and I have a specific question.</p>\n\n<blockquote>\n  <p>Suppose $L$ is a language over $\\Sigma$, and $x_1, x_2, ... , x_n$ are\n  strings that are pairwise $L$-distinguishable. How many distinct\n  strings are necessary in order to distinguish between the $x_i$'s? In\n  other words, what is the smallest number $k$ such that for some set\n  $\\{z_1, z_2, ...,z_k\\}$, any two distinct $x_i$'s are distinguished,\n  relative to $L$, by some $z_l$? Prove your answer.</p>\n</blockquote>\n\n<p>The book gives a hint, which reads as follows:</p>\n\n<blockquote>\n  <p>Here is a way of thinking about the question that may make it easier. Think of the $x_i$\u2019s as points on a piece of paper, and think of the $z_l$\u2019s as cans of paint, each $z_l$ representing a different primary color. Saying that $z_l$ distinguishes $x_i$ and $x_j$ means that one of those two points is colored with that primary color and the other isn\u2019t. We allow a single point to have more than one primary color applied to it, and we assume that two distinct combinations of primary colors produce different resulting colors. Then the question is, how many different primary colors are needed in order to color the points so that no two points end up the same color?</p>\n</blockquote>\n\n<p>I have surely addressed this question Here is my answer.</p>\n\n<blockquote>\n  <p><strong>Solution</strong>: Coloring $n$ points so that no two points end up the same color requires $\\lceil \\log_2 n \\rceil$ primary colors.</p>\n  \n  <p>First enumerate the points using binary representations, and let each digit correspond to a primary color. Then we identify the combination of colors for a given point as all primary colors whose corresponding digit is 1. Each of the points has a unique representation, so each combination of primary colors will be unique. </p>\n</blockquote>\n\n<p>What do you think of this response? Do you think it needs further explanation? </p>\n\n<p>Also, I am having trouble translating this argument into the context of the original question. How can I better see that the problems are the same?</p>\n", 'ViewCount': '76', 'ClosedDate': '2014-01-28T22:49:25.240', 'Title': 'Smallest Number of Strings to Distinguish $n$ Pairwise $L$-distinguishable Strings', 'LastActivityDate': '2014-01-28T21:15:17.440', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11000', 'Tags': '<formal-languages><computation-models>', 'CreationDate': '2013-10-30T16:59:24.170', 'Id': '16580'},143_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am currently working on the following task:</p>\n\n<p>A language L = {&lt; M> | M(x) = x^2} is given. Now I need to show, that this language is not decidable.\n<br> By the way, &lt; M> is the G\xf6del number</p>\n\n<p>But right now, I don't know how to deal with that task. Honestly, this is the first time that I am working with this kind of task.</p>\n\n<p>I would appreciate if you could give me some hints, because I don't know how to proceed with the task.</p>\n", 'ViewCount': '29', 'ClosedDate': '2013-12-08T23:35:00.803', 'Title': 'Recursive set - How to show a language is undecidable', 'LastActivityDate': '2013-12-08T23:29:39.940', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11941', 'Tags': '<turing-machines><undecidability><computation-models><proof-assistants>', 'CreationDate': '2013-12-08T23:29:39.940', 'Id': '18764'},143_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><sup>This is a cross-post from a post on <a href="http://math.stackexchange.com/posts/655746/edit">MathSE</a> due to lack of answers.</sup></p>\n\n<p>To illustrate my question I provide the following example.</p>\n\n<p>The website <a href="http://db.ing.puc.cl/turingmachine/" rel="nofollow">Online Turing Machine</a> provides a Turing Machine simulator. The following program adds 1 to any binary number.</p>\n\n<pre><code>q0,1  =&gt;  q0,1,&gt;\nq0,0  =&gt;  q0,0,&gt;\nq0,_  =&gt;  q1,_,&lt;\nq1,0  =&gt;  q3,1,&gt;\nq1,1  =&gt;  q1,0,&lt;\nq1,_  =&gt;  q3,1,&gt;\n</code></pre>\n\n<p>A program line has the following format:</p>\n\n<pre><code>state, character read =&gt; new state, character written, direction tape\n</code></pre>\n\n<p>In the program above q0 is the initial state and q3 is the accepting state.</p>\n\n<p>In Tilings and Patterns by Gruenbaum and Shephard, 11.4 "Computing By Tiles" I read that it is possible to convert any turing machine program to a tiling of the plane using Wang tiles. The book contains an example tiling which calculates the Fibonacci numbers. The procedure, recipe, to convert a Turing machine program to a set of Wang tiles is not entirely clear to me.</p>\n\n<p><strong>Question: What is the algorithm to convert a Turing Machine program line by line to a set of tiling of the plane using Wang Tiles?</strong> And how does it work on the Turing machine in the given example?</p>\n\n<p>Update:</p>\n\n<p>Image is that of a Wang tile that adds 1 to a binary: 111 + 1 = 1000 where 1 is red, 0 is cyan. Aiming to generate tiles like this from any Turing Machine. First row 111, last row 1000.</p>\n\n<p><img src="http://i.stack.imgur.com/w6dl0.png" alt="Wang Tile"></p>\n', 'ViewCount': '81', 'Title': 'How to convert a Turing Machine program to a tiling using Wang Tiles?', 'LastEditorUserId': '13315', 'LastActivityDate': '2014-02-11T04:14:35.720', 'LastEditDate': '2014-02-05T11:13:19.857', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13315', 'Tags': '<turing-machines><simulation><computation-models><tiling>', 'CreationDate': '2014-02-02T10:11:46.570', 'Id': '20207'},143_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a follow-up question regarding Knuth\'s one formulation of the concept of an algorithm <a href="http://cs.stackexchange.com/questions/1666/please-explain-this-formal-definition-of-computation">here</a>. I am asking it here because I do not have enough reputation to post a comment to that question. To make my question self-contained, here it goes.</p>\n\n<p>Knuth introduces the following formulation which "restrict the notion of algorithm so that only elementary operations are involved", (copied from the above mentioned <a href="http://cs.stackexchange.com/questions/1666/please-explain-this-formal-definition-of-computation">question</a>):</p>\n\n<blockquote>\n  <p>Let $A$ be a finite set of letters. Let $A^*$ be the set of all strings in $A$ (the set of all ordered sequences $x_1$ $x_2$ ... $x_n$ where $n \\ge 0$ and $x_j$ is in $A$ for $1 \\le j \\le n$). The idea is to encode the states of the computation so that they are represented by strings of $A^*$ . Now let $N$ be a non-negative integer and Q (the state) be the set of all $(\\sigma, j)$, where $\\sigma$ is in $A^*$ and j is an integer $0 \\le j \\le N$; let $I$ (the input) be the subset of Q with $j=0$ and let $\\Omega$ (the output) be the subset with $j = N$. If $\\theta$ and $\\sigma$ are strings in $A^*$, we say that $\\theta$ occurs in $\\sigma$ if $\\sigma$ has the form $\\alpha \\theta \\omega$ for strings $\\alpha$ and $\\omega$. To complete our definition, let $f$ be a function of the following type, defined by the strings $\\theta_j$, $\\phi_j$ and the integers $a_j$, $b_j$ for $0 \\le j \\le N$:</p>\n  \n  <ul>\n  <li>$f((\\sigma, j)) = (\\sigma, a_j)$ if $\\theta_j$ does not occur in $\\sigma$</li>\n  <li>$f((\\sigma, j)) = (\\alpha \\phi_j \\omega, b_j)$ if $\\alpha$ is the shortest possible string for which $\\sigma = \\alpha \\theta_j \\omega$</li>\n  <li>$f((\\sigma,N)) = (\\sigma, N)$</li>\n  </ul>\n</blockquote>\n\n<p>He describes this formulation as effective and powerful.</p>\n\n<p>My questions are:</p>\n\n<ol>\n<li><p>What is the purpose of $\\alpha$ being the "shortest possible string for which $\\sigma = \\alpha \\theta_j \\omega$? </p></li>\n<li><p>Why is it so powerful? For example, if we are doing repeated multiplication (say compute $x^{10}$ given some $x \\in I$), the string replacement values $\\phi_j$ have to be predefined without knowing the value of $x$; but it seems that $\\phi_j$ would have to depend on the specific value of $x$. So how does it really work?</p></li>\n</ol>\n\n<p>Clearly I am missing something. Any help would be appreciated!</p>\n', 'ViewCount': '141', 'Title': 'why is this computational method by Knuth "effective" and "powerful"?', 'LastEditorUserId': '14586', 'LastActivityDate': '2014-02-20T16:47:27.663', 'LastEditDate': '2014-02-17T00:16:58.673', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '21691', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14586', 'Tags': '<computation-models>', 'CreationDate': '2014-02-12T08:58:59.970', 'Id': '21564'},143_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '59', 'Title': 'Proving a language is context free by coming up with a context free grammar for the language', 'LastEditDate': '2014-03-21T01:46:43.790', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Body': '<p>Let A and B be languages over $\\sum$ = {0, 1, 2, 3}</p>\n\n<p>Language A = {$(0U1)^a(1U2)^b(2U3)^c | a \\geq  b$}</p>\n\n<p>Language B = {$(0U1)^a(1U2)^b(2U3)^c | a = c$}</p>\n\n<p>Question: prove that A and B are context free</p>\n', 'ClosedDate': '2014-03-22T00:00:48.390', 'Tags': '<computation-models>', 'LastEditorUserId': '14864', 'LastActivityDate': '2014-03-21T01:46:43.790', 'CommentCount': '2', 'AcceptedAnswerId': '22887', 'CreationDate': '2014-03-20T21:40:56.227', 'Id': '22884'},143_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>what would the Turing machine state diagram be for this language: \n$A=\\{ (0 \\cup 1)^a(1 \\cup 2)^b(2\\cup 3)^c \\mid a \\geq  b\\} $ ?</p>\n\n<p>how would the turing machine design know the size of $(1 \\cup 2)^b$ ? since this contains elements from the first and last parts, would it be impossible to determine? </p>\n', 'ViewCount': '72', 'Title': 'Tricky Turing Machine state diagram', 'LastActivityDate': '2014-03-22T00:50:55.423', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '22918', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<turing-machines><computation-models>', 'CreationDate': '2014-03-21T18:38:17.700', 'Id': '22909'},143_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Say I want to compute a covnex hull of given points on the plane. I would like to write an algorithm, that only compares the points and doesn't do any arithmetic operations. Wikipedia states, that:</p>\n\n<blockquote>\n  <p>The standard $\\Omega(n \\log n)$ lower bound for sorting is proven in the decision tree model of computing, in which only numerical comparisons but not arithmetic operations can be performed; however, in this model, convex hulls cannot be computed at all. </p>\n</blockquote>\n\n<p>Why is it so? I can't find any justification for it anywhere, I know it to be intuitively true, but how come it's a necessity?</p>\n", 'ViewCount': '331', 'Title': "Convex Hull algorithm - why it can't be computed using only comparisons", 'LastEditorUserId': '657', 'LastActivityDate': '2014-04-18T14:32:41.873', 'LastEditDate': '2014-04-18T14:15:34.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23911', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16876', 'Tags': '<algorithms><computational-geometry><computation-models>', 'CreationDate': '2014-04-18T11:55:18.920', 'Id': '23910'},143_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Denote $D$ a set of finite sequences of integers. In Papadimitriou\'s "Computational Complexity" in theorem 2.5 it is proved that if a RAM program $\\Pi$ computes a function $\\phi$ from $D$ to integers in time $f(n)$, then there is a $7$-string Turing machine $M$, which computes $\\phi$ in time $O(f(n)^3)$.</p>\n\n<p>Consider the following example: $\\phi(S)$ is a sum of first two numbers of a finite sequence $S$, or $0$, if $|S| &lt; 2$. It seems to me that a RAM, defined in Papadimitriou\'s book computes $\\phi$ in time $O(1)$. Thought, any Turing machine, computing $\\phi$, should work for at least linear time (we can take an input of length $n$ with only two numbers in sequence). I don\'t see how to cope with this contradiction.</p>\n\n<p>Could you please describe me, where I am wrong? Thanks a lot.</p>\n', 'ViewCount': '12', 'Title': 'Relation between RAM and Turing machine', 'LastActivityDate': '2014-05-03T19:16:35.420', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17302', 'Tags': '<time-complexity><computation-models>', 'CreationDate': '2014-05-03T19:16:35.420', 'Id': '24361'}