690:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '544', 'Title': 'Implementing the GSAT algorithm - How to select which literal to flip?', 'LastEditDate': '2012-04-19T05:46:33.270', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '174', 'FavoriteCount': '1', 'Body': "<p>The GSAT algorithm is, for the most part, straight forward: You get a formula in conjunctive normal form and flip the literals of the clauses until you find a solution that satisfies the formula or you reach the max_tries/max_flips limit and find no solution.</p>\n\n<p>I'm implementing the following algorithm:</p>\n\n<pre><code>procedure GSAT(A,Max_Tries,Max_Flips)\n  A: is a CNF formula\n  for i:=1 to Max_Tries do\n    S &lt;- instantiation of variables\n    for j:=1 to Max_Iter do\n      if A satisfiable by S then\n        return S\n      endif\n      V &lt;- the variable whose flip yield the most important raise in the number of satisfied clauses;\n      S &lt;- S with V flipped;\n    endfor\n  endfor\n  return the best instantiation found\nend GSAT\n</code></pre>\n\n<p>I'm having trouble interpreting the following line:  </p>\n\n<pre><code>V &lt;- the variable whose flip yield the most important raise in the number of satisfied clauses;\n</code></pre>\n\n<p>Isn't the maximum number of satisfied clauses what we're looking for? It seems to me that we're trying to use the solution or approximations to it to find the solution. </p>\n\n<p>I've thought of some ways to do this but It'd be good to hear other points of view (The assumption is that once the variable is flipped once it is selected.):</p>\n\n<ul>\n<li>Generate a state space with all possible flips and search the space for a literal that results in the best approximation to the goal state.</li>\n<li>Randomly select the variable that I will flip starting with the literals that are more common.</li>\n<li>Pick a random literal.</li>\n</ul>\n", 'Tags': '<algorithms><satisfiability><3-sat>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-19T05:46:33.270', 'CommentCount': '0', 'AcceptedAnswerId': '220', 'CreationDate': '2012-03-11T15:48:43.030', 'Id': '219'},691:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given an instance of SAT, I would like to be able to estimate how difficult it will be to solve the instance.</p>\n\n<p>One way is to run existing solvers, but that kind of defeats the purpose of estimating difficulty. A second way might be looking a the ratio of clauses to variables, as is done for phase transitions in random-SAT, but I am sure better methods exist.</p>\n\n<p>Given an instance of SAT, are there some fast heuristics to measure the difficulty? The only condition is that these heuristics be faster than actually running existing SAT solvers on the instance.</p>\n\n<hr>\n\n<h3>Related question</h3>\n\n<p><a href="http://cstheory.stackexchange.com/q/4375/1037">Which SAT problems are easy?</a> on cstheory.SE. This questions asks about tractable sets of instances. This is a similar question, but not exactly the same. I am really interested in a heuristic that given a single instance, makes some sort of semi-intelligent guess of if the instance will be a hard one to solve.</p>\n', 'ViewCount': '287', 'Title': 'Measuring the difficulty of SAT instances', 'LastActivityDate': '2012-11-27T06:24:05.617', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '917', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<complexity-theory><satisfiability><heuristics>', 'CreationDate': '2012-03-15T05:00:23.853', 'FavoriteCount': '4', 'Id': '407'},692:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '245', 'Title': 'Supporting data structures for SAT local search', 'LastEditDate': '2012-04-05T17:15:02.153', 'AnswerCount': '1', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '472', 'FavoriteCount': '1', 'Body': '<p><a href="http://en.wikipedia.org/wiki/WalkSAT">WalkSAT and GSAT</a> are well-known and simple local search algorithms for solving the Boolean satisfiability problem. The pseudocode for the GSAT algorithm is copied from the question <a href="http://cs.stackexchange.com/questions/219/implementing-the-gsat-algorithm-how-to-select-which-literal-to-flip">Implementing the GSAT algorithm - How to select which literal to flip?</a> and presented below.</p>\n\n<pre><code>procedure GSAT(A,Max_Tries,Max_Flips)\n  A: is a CNF formula\n  for i:=1 to Max_Tries do\n    S &lt;- instantiation of variables\n    for j:=1 to Max_Iter do\n      if A satisfiable by S then\n        return S\n      endif\n      V &lt;- the variable whose flip yield the most important raise in the number of satisfied clauses;\n      S &lt;- S with V flipped;\n    endfor\n  endfor\n  return the best instantiation found\nend GSAT\n</code></pre>\n\n<p>Here we flip the variable that maximizes the number of satisfied clauses. How is this done efficiently? The naive method is to flip every variable, and for each step through all clauses and calculate how many of them get satisfied. Even if a clause could be queried for satisfiability in constant time, the naive method would still run in $O(VC)$ time, where $V$ is the number of variables and $C$ the number of clauses. I\'m sure we can do better, hence the question:</p>\n\n<blockquote>\n  <p>Many local search algorithms flip the variable\'s assignment that maximizes the number of satisfied clauses. In practice, with what data structures is this operation supported efficiently?</p>\n</blockquote>\n\n<p>This is something I feel like textbooks often omit. One example is even the famous <a href="http://aima.cs.berkeley.edu/">Russell &amp; Norvig book</a>.</p>\n', 'Tags': '<algorithms><data-structures><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-15T16:21:12.517', 'CommentCount': '4', 'AcceptedAnswerId': '1262', 'CreationDate': '2012-04-05T16:08:17.820', 'Id': '1058'},693:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '509', 'Title': 'Classification of intractable/tractable satisfiability problem variants', 'LastEditDate': '2012-04-14T10:19:29.120', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '2', 'Body': '<p>Recently I found in a paper [1] a special symmetric version of SAT called the <strong>2/2/4-SAT</strong>. But there are many $\\text{NP}$-complete variants out there, for example: <strong>MONOTONE NAE-3SAT</strong>, <strong>MONOTONE 1-IN-3-SAT</strong>, ...</p>\n\n<p>Some other variants are tractable: $2$-$\\text{SAT}$, Planar-NAE-$\\text{SAT}$, ...</p>\n\n<p>Are there survey papers (or web pages) that classify all the (weird) $\\text{SAT}$ variants that have been proved to be $\\text{NP}$-complete (or in $\\text{P}$) ?</p>\n\n<hr>\n\n<ol>\n<li><a href="https://www.aaai.org/Papers/AAAI/1986/AAAI86-027.pdf">Finding a shortest solution for the $N$x$N$ extension of the 15-Puzzle is intractable</a> by D. Ratner and M. Warmuth (1986)</li>\n</ol>\n', 'Tags': '<complexity-theory><reference-request><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-14T10:19:29.120', 'CommentCount': '2', 'AcceptedAnswerId': '1235', 'CreationDate': '2012-04-12T17:59:00.553', 'Id': '1234'},694:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question is motivated by my <a href="http://cs.stackexchange.com/a/1328/96">answer</a> to another question in which I stated the fact that both Betweeness and Non-Betweeness problems are $NP$-complete. In the former problem there is a total order such that the betweeness constraint of each triple is enforced while in the later problem there is a total order such that the betweeness constraint of each triple is violated.</p>\n\n<p>What is the complexity of the following 3SAT variants?:</p>\n\n<p>3SAT_1={($\\phi$): $\\phi$ has an assignment that makes every clause false}</p>\n\n<p>3SAT_2={($\\phi$): $\\phi$ has an assignment such that exactly half of the clauses are true and the other half is false}</p>\n', 'ViewCount': '241', 'Title': 'Complexity of 3SAT variants', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-19T06:29:04.077', 'LastEditDate': '2012-04-19T05:46:18.327', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1348', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><satisfiability>', 'CreationDate': '2012-04-18T23:45:16.777', 'Id': '1347'},695:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1965', 'Title': 'how do you prove that SAT is NP-complete?', 'LastEditDate': '2012-05-10T15:12:40.890', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1412', 'FavoriteCount': '2', 'Body': '<p>As it is, how do you prove that SAT is NP-complete?</p>\n\n<p>I know what it means by NP-complete, so I do not need an explanation on that.</p>\n\n<p>What I want to know is how do you know that one problem, such as SAT, is NP-complete without resorting to reduction to other problems such as hamiltonian problem or whatever.</p>\n', 'Tags': '<complexity-theory><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T15:12:40.890', 'CommentCount': '5', 'AcceptedAnswerId': '1728', 'CreationDate': '2012-05-08T06:58:32.797', 'Id': '1726'},696:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '982', 'Title': 'How to prove that a constrained version of 3SAT in which no literal can occur more than once, is solvable in polynomial time?', 'LastEditDate': '2012-05-15T16:10:48.783', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '476', 'FavoriteCount': '4', 'Body': '<p>I\'m trying to work out an assignment (taken from the book <a href="http://www.cs.berkeley.edu/~vazirani/algorithms.html">Algorithms - by S. Dasgupta, C.H. Papadimitriou, and U.V. Vazirani</a>, Chap 8, problem 8.6a), and I\'m paraphrasing what it states:</p>\n\n<blockquote>\n  <p>Given that 3SAT remains NP-complete even when restricted to formulas in which\n  each literal appears at most twice, show that if each literal appears at most once, then the problem is solvable in polynomial time.</p>\n</blockquote>\n\n<p>I attempted to solve this by separating the clauses into multiple groups: </p>\n\n<ol>\n<li>Clauses which did not have any variable in common with the rest of the clauses</li>\n<li>Clauses which had only 1 variable in common</li>\n<li>Clauses which had 2 variables in common</li>\n<li>Clauses which had all 3 variables in common</li>\n</ol>\n\n<p>My reasoning was attempted along the lines that the # of such groups is finite (due to the imposed restriction of no literal being present more than once), and we could try to satisfy the most restricted group first (group 4) and then substitute the result in the lesser restricted groups (3, 2 and then 1), but I realized that this wasn\'t quite getting me anywhere, as this doesn\'t differ much from the case for the constrained version of 3SAT in which each literal can appear at most twice, which has been proven to be NP-complete. </p>\n\n<p>I tried searching online for any hints/solutions, but all I could get was <a href="http://www.cs.rpi.edu/~moorthy/Courses/CSCI2300/lab2011-9.html">this link</a>, in which the stated hint didn\'t make sufficient sense to me, which I\'m reproducing verbatim here:</p>\n\n<blockquote>\n  <p>Hint: Since each literal appears at most once, convert this problem to 2SAT problem - hence polynomial time, if a literal $x_i$ appears in clause $C_j$ and complement of $x_i$ (i.e., $\\overline{x_i}$) in clause $C_k$, construct a new clause clause $C_j \\lor \\overline{C_k}$.</p>\n</blockquote>\n\n<p>Both $C_j$ and $C_k$ have three literals each - I didn\'t get how I should go about converting it into 2SAT by doing $C_j \\lor \\overline{C_k}$ (or $\\overline{C_j \\lor C_k}$ if I read it incorrectly).</p>\n\n<p>Any help in either decrypting the hint, or providing a path I can explore would be really appreciated.</p>\n', 'Tags': '<complexity-theory><satisfiability><3-sat>', 'LastEditorUserId': '476', 'LastActivityDate': '2013-07-15T03:36:16.567', 'CommentCount': '0', 'AcceptedAnswerId': '1858', 'CreationDate': '2012-05-15T15:26:22.270', 'Id': '1852'},697:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If I were to let the variables be the propositions and, constraint be all clauses being satisfied, which technique would be more effective in solving 3-SAT? <a href="http://en.wikipedia.org/wiki/Look-ahead_%28backtracking%29#Look_ahead_techniques" rel="nofollow">Forward checking</a> or <a href="http://en.wikipedia.org/wiki/Arc_consistency#Arc_consistency" rel="nofollow">arc consistency</a>? From what I gathered forward-checking is $O(n)$, while Arc consistency is about $O(8c)$ where c is the number of constraints (According to this <a href="http://www.cs.ubc.ca/~kevinlb/teaching/cs322%20-%202006-7/Lectures/lect11.pdf" rel="nofollow">page</a>). So perhaps forward -checking is faster somehow? How should I determine which to use?</p>\n', 'ViewCount': '591', 'Title': 'Forward checking vs arc consistency on 3-SAT', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-28T18:01:07.223', 'LastEditDate': '2012-05-28T18:01:07.223', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1556', 'Tags': '<algorithms><satisfiability><heuristics><3-sat><sat-solvers>', 'CreationDate': '2012-05-28T07:03:31.467', 'Id': '2120'},698:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>EDIT: ad hoc speed-ups are excluded.</p>\n\n<p>We have the result that <a href="http://homepages.cwi.nl/~rdewolf/resolutionlowerbound.pdf" rel="nofollow">propositional resolution requires exponential time</a>. The resolution result uses the proof of the pigeonhole principle as an example of a proof that takes exponential time. </p>\n\n<p>Let\'s also say we have a hypothetical algorithm M for SAT that runs in polynomial time. \n<strong>EDIT : M is correct, complete, sound, and general-purpose; it contains no ad hoc speed-up rules for the pigeonhole principle or any other theorem that requires exponential length in resolution.</strong> M takes its input in clausal form; we\'ll set up the input like a resolution proof where the consequent is negated to lead to unsatisfiability if the theorem is true. Now let\'s consider how the proof of the pigeonhole principle works in algorithm M with a strong condition C added:</p>\n\n<p>C. We are given that M simply transforms one clause (or set of clauses) to another clause (or set of clauses). Every such transformation is logically sound.</p>\n\n<p>Some questions; please point out the most fatal flaws:</p>\n\n<ol>\n<li>Given condition C above, and since M\'s rule system must be finite, correct, and complete, can we conclude that there is a translation from M\'s rule system to an equivalent set of expansions based on resolution?</li>\n<li>Are we now in a place where we can conclude that M would produce a computation that could be mapped by the translation in point 1 above into an impossible polynomial-time resolution proof of the pigeonhole principle?</li>\n</ol>\n', 'ViewCount': '178', 'Title': 'Resolution complexity versus a constrained SAT algorithm', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-05T20:21:32.660', 'LastEditDate': '2012-06-05T20:21:32.660', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1295', 'Tags': '<complexity-theory><logic><satisfiability><sat-solvers>', 'CreationDate': '2012-06-05T04:12:51.750', 'FavoriteCount': '1', 'Id': '2230'},699:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '225', 'Title': 'Is SAT in P if there are exponentially many clauses in the number of variables?', 'LastEditDate': '2012-07-21T18:44:49.583', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'FavoriteCount': '1', 'Body': "<p>I define a <em>long CNF</em> to contain at least $2^\\frac{n}{2}$ clauses, where $n$ is the number of its variables. Let $\\text{Long-SAT}=\\{\\phi: \\phi$ is a satisfiable long CNF formula$\\}$. </p>\n\n<p>I'd like to know why $\\text{Long-SAT} \\in P$. First I thought it is $\\text{NPC}$ since I can do a polynomial-time reduction from $\\text{SAT}$ to $\\text{Long-SAT}$, no?</p>\n\n<p>But maybe I can reduce $\\text{2-SAT}$ to $\\text{Long-SAT}$? How do I do that?</p>\n", 'Tags': '<complexity-theory><np-complete><reductions><satisfiability><polynomial-time>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-21T19:06:47.027', 'CommentCount': '7', 'AcceptedAnswerId': '2705', 'CreationDate': '2012-07-12T08:19:40.860', 'Id': '2704'},6910:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Modern SAT-solvers are very good at solving many real-world examples of SAT instances. However, we know how to generate hard ones: for instance use a <a href="http://cstheory.stackexchange.com/q/6755/1037">reduction from factoring to SAT</a> and give the RSA numbers as input.</p>\n\n<p>This raises the question: what if I take an easy example of factoring. Instead of taking two large primes on $n/2$ bits, what if I take a prime $p$ on $\\log n$ bits and a prime q on $n/\\log n$ bits, let $N = pq$ and the encode $\\mathrm{FACTOR}(N)$ as a SAT instance. $N$ would be an easy number to factor by brute-force search or sieve methods since one of the factors in so small; does a modern SAT-solver with some standard reduction from factoring to SAT also pick up on this structure?</p>\n\n<p><strong>Can top SAT-solvers factor $N = pq$ where $|p| = \\log n$ quickly?</strong></p>\n', 'ViewCount': '190', 'Title': 'Can top SAT-solvers factor easy numbers?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-22T05:29:43.467', 'LastEditDate': '2012-07-22T05:14:29.103', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '55', 'Tags': '<complexity-theory><satisfiability><sat-solvers><factoring>', 'CreationDate': '2012-07-22T00:41:51.747', 'FavoriteCount': '4', 'Id': '2857'},6911:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What's the complexity of Conflict-Driven Clause Learning SAT solvers, compared to DPLL solvers? Was it proven that CDCL is faster in general? Are there instances of SAT that are hard for CDCL but easy for DPLL?</p>\n", 'ViewCount': '138', 'Title': 'Running time of CDCL compared to DPLL', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-25T21:52:35.260', 'LastEditDate': '2012-11-25T21:52:35.260', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3015', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2345', 'Tags': '<complexity-theory><time-complexity><efficiency><satisfiability><sat-solvers>', 'CreationDate': '2012-08-03T07:31:02.560', 'Id': '3014'},6912:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am self studying discrete math and I am going through MIT Mathematics for CS lecture notes but they do not have solutions available. I got stuck at <a href="http://www.scribd.com/doc/101941032/3cf" rel="nofollow">Problem 3.14</a> (pages 64-65 of <a href="http://courses.csail.mit.edu/6.042/spring12/part1.pdf" rel="nofollow">this document</a>). The problem is about the construction, given an arbitrary propositional formula $F$, of a proposition $C(F)$ such that:</p>\n\n<ul>\n<li>$C(F)$ is in 3-conjunctive form (3CF), i.e. it is a conjunction of disjunctions of at most literals (a literal is a variable or a negation of a variable);</li>\n<li>$C(F)$ has at most 24 times as many occurrences of variables as $F$;</li>\n<li>$C(F)$ is satisfiable iff $F$ is.</li>\n</ul>\n\n<p>The idea is to introduce a new variable for each operator that occurs in $F$. For example, given\n$$ F_1 = ((P \\oplus Q) \\oplus R) \\vee (\\neg P \\wedge S)) $$\nassign $X_1, X_2, O, A$ to the 4 operators in $F_1$, and define four <em>constraining formulas</em>:\n$$ \\begin{align*}\n C_1^1 &amp;= X_1 \\Leftrightarrow (P \\oplus Q) \\\\\n C_1^2 &amp;= X_2 \\Leftrightarrow (X_1 \\oplus R) \\\\\n C_1^3 &amp;= A \\Leftrightarrow (\\neg P \\wedge S) \\\\\n C_1^4 &amp;= O \\Leftrightarrow (X_2 \\oplus A) \\\\\n\\end{align*} $$\nand $C_1 = C_1^1 \\wedge C_1^2 \\wedge C_1^3 \\wedge C_1^4 \\wedge O$.</p>\n\n<p>The questions are:</p>\n\n<ol>\n<li>Why is $C_1$ satisfiable iff $F_1$ is satisfiable?</li>\n<li>Why is each constraining formula equivalent to a 3CF formula with at most 24 occurrences of variables?</li>\n<li>Generalize from the example to construct $C(F)$ for an arbitrary formula $F$.</li>\n</ol>\n\n<p>For question 1, I don\'t see why $X_1$ is satisfiable.</p>\n\n<p>I think question 2 is wrong, beacuse you can form a 3CF formula with at most 24 occurrences of variables, only if you have a 3-conjunctive <strong>normal</strong> form but here the author only says 3 conjunctive form. </p>\n\n<p>(For 3CNF, 8 different triple terms can be formed using 3 variables with a total of 24 variables, For 3CF, 26 different single,double and triple terms can be formed with a total of ? variables.)</p>\n\n<p>No idea about question 3.</p>\n', 'ViewCount': '201', 'Title': '3CF 3-conjunctive form satisfiability', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T12:04:52.527', 'LastEditDate': '2012-08-04T15:49:17.937', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2348', 'Tags': '<logic><satisfiability><3-sat><normal-forms>', 'CreationDate': '2012-08-03T15:14:38.117', 'Id': '3021'},6913:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If we suppose that we start with an instance of $k$-SAT, and try converting the problem to an instance of $(k+m)$-SAT, where there are $(k+m)$ literals per clause, can we guarantee a reduction in the total amount of clauses?</p>\n\n<p><em>I realized after posting that we can\'t guarantee that the number of clauses can be reduced.  However, I wonder if we have $n$ clauses, could we get something like $n/k + O(1)$ clauses by some "reduction" technique?</em></p>\n\n<p>If so, how much can we guarantee the total number of clauses can be reduced by? For instance, if we start with $k$-SAT with $n_k$ clauses, what is the smallest guaranteed $n_{k+m}$, the new amount of clauses, that will result if we convert this instance to $(k+m)$-SAT?</p>\n\n<p>More importantly, how do we carry out this conversion?</p>\n', 'ViewCount': '179', 'Title': 'How much can we reduce the number of clauses by converting from $k$-SAT to $(k+m)$-SAT?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-20T21:25:20.007', 'LastEditDate': '2012-08-21T21:28:54.100', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1667', 'Tags': '<complexity-theory><logic><satisfiability>', 'CreationDate': '2012-08-21T10:18:09.717', 'FavoriteCount': '4', 'Id': '3270'},6914:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can i prove that the conversion from CNF to DNF is NP-Hard. I'm not asking for an answer, just some suggestions about how to go about proving it.</p>\n", 'ViewCount': '646', 'Title': u'CNF to DNF \u2014 conversion is NP Hard', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-12T22:32:03.810', 'LastEditDate': '2012-09-12T22:32:03.810', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '7', 'OwnerDisplayName': 'jkjk', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-hard><satisfiability><sat-solvers>', 'CreationDate': '2011-12-14T15:46:55.587', 'FavoriteCount': '4', 'Id': '3513'},6915:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>General satisfiability (with a few exceptions such as Horn Clauses) is not believed to have an algorithmic solution. However, the following algorithm appears to be a solution for general satisfiability. What exactly is the flaw with the following algorithm?      </p>\n\n<ol>\n<li>Let $W$ be an empty set which will contain all variables that necessarily have to be true or false.</li>\n<li>Let $L$ be the set of clauses.</li>\n<li>Loop through $L$.</li>\n<li>Every time a non-conditional variable<sup>\u2020</sup> is found, remove it from $L$ and insert it into $W$.</li>\n<li>If this leaves an empty AND implication<sup>\u2021</sup>, remove all variables in that empty implication from $L$ and insert into $W$.</li>\n<li>If this leaves an empty OR implication<sup>\u2021</sup>, create new instances of the algorithm, where each instance deals with one variable in the implication (i.e. if the implication is: $x V \\implies y$, create one instance where $x$ is inserted into $W$, one where $y$ is inserted into $W$ and one where $x$ and $y$ are inserted into $W$).</li>\n<li>Set all variables in $W$ to the value they necessarily have to be.</li>\n<li>Reinsert the variables in $W$ in $L$ with their changed values and check if all clauses  are satisfied.</li>\n<li>If satisfiability is met, then return $L$, else return "Not Satisfiable".</li>\n</ol>\n\n<p><sup>\u2020</sup> A non conditional variable is defined as a variable that is necessary true or false, e.g. $\\implies x$ or $\\implies \\neg y$.</p>\n\n<p><sup>\u2021</sup> An empty implication is defined as an implication where one side is empty (e.g. $\\implies x \\wedge y$) or the other side is necessarily true (e.g. $\\mathrm{true} \\vee a \\implies b$.</p>\n\n<p>To get a more intuitive understanding of the algorithm consider the following set of clauses $L$:</p>\n\n<p>$$\\begin{align}\n  a \\wedge b &amp;\\implies c &amp; \\text{(i)} \\\\\n  &amp;\\implies f \\wedge g &amp; \\text{(ii)} \\\\\n  f &amp;\\implies \\neg a &amp; \\text{(iii)} \\\\\n  f \\vee a &amp;\\implies b &amp; \\text{(iv)} \\\\\n  &amp;\\implies c &amp; \\text{(v)} \\\\\n\\end{align}$$</p>\n\n<p>The algorithm will do the following:</p>\n\n<p>1) Since $c$, $f$, $g$ are non-conditional variables, the algorithm will insert them into $W$. $W = \\{c, f, g\\}$.</p>\n\n<p>2) Removing $c$, $f$ and $g$ will leave the empty clauses: $\\implies \\neg a, a \\wedge b, b$. These will be added to $W$. $W = \\{c, f, g, b, \\neg a\\}$.</p>\n\n<p>3) Reinserting the variables into $L$ will result in the first clauses being violated: $a \\wedge b \\implies c$. Since $a$ is false, $c$ is false, meaning clause (v) is violated. The algorithm will return "Not Satisfiable"</p>\n\n<p>I am aware that the algorithm appears confusing. Please feel free to ask for clarification.</p>\n\n<hr>\n\n<p>From comments I now realize that there is no known <em>efficient</em> general satisfiability algorithm. I\'m still interested in feedback about my algorithm. Does it work? How does it compare with common algorithms?</p>\n', 'ViewCount': '238', 'Title': 'A tentative satisfiability algorithm', 'LastEditorUserId': '39', 'LastActivityDate': '2012-09-19T00:28:48.400', 'LastEditDate': '2012-09-12T19:31:09.140', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '7', 'OwnerDisplayName': 'user1422', 'PostTypeId': '1', 'Tags': '<algorithms><logic><satisfiability><constraint-programming>', 'CreationDate': '2012-08-15T02:42:26.293', 'FavoriteCount': '1', 'Id': '3516'},6916:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it possible to reduce MaxUNSAT to <a href="http://en.wikipedia.org/wiki/Maximum_satisfiability_problem" rel="nofollow">MaxSAT</a> in a polynomial way ?</p>\n\n<p>When considering the MaxSAT problem, one often considers also the <code>MinUNSAT</code> problem, which is almost the same. And for a propositional formula <code>f</code> in <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form" rel="nofollow">CNF</a> it holds:</p>\n\n<pre><code>|f| = MaxSAT(f) + MinUNSAT(f)\n</code></pre>\n\n<p>where <code>|f|</code> is the number of clauses of f.</p>\n\n<p>When considering <code>MaxUNSAT</code> and the corresponding <code>MinSAT</code> problem, the same relationship holds:</p>\n\n<pre><code>|f| = MaxUNSAT(f) + MinSAT(f)\n</code></pre>\n\n<p>Now, I was wondering if there is also a relationship between those two pairs, e.g. to reduce <code>MaxSAT</code> to <code>MaxUNSAT</code> or <code>MinSAT</code> (or the other way round) ?</p>\n\n<p>Unfortunately, I could not figure out one by myself. And maybe there is none ?</p>\n\n<p><strong>Update 1:</strong> Inspired by Yuval Filmus\'s answer, I will give a reduction for my question.</p>\n\n<p><strong>Reduction from MaxUNSAT to its corresponding decision problem:</strong></p>\n\n<p>Let $\\phi = {C_1, ..., C_m}$ a set of clauses over the variables $x_1, ..., x_n$, then it holds:\n$$MaxUNSAT(\\phi) = BinarySearch(0, |\\phi|, MaxUNSAT(\\phi, k) )$$\nwith \n$$\nBinarySearch(start, end, CompareProcedure(k))\n:= \\\\\\text{Searches for the element $e$ between $start$ and $end$ with help of the $CompareProcedure(k)$, so that holds $CompareProcedure(e) = true$ and $CompareProcedures(e+1) = false$ }$$\nand\n$$MaxUNSAT(\\phi, k) := \\exists v\\in\\{0, 1\\}^n:\\sum_{i=1}^m 1 - I_v(C_i) \\geq k$$\nwhere $I_v$ is the interpretation of a propositional formula under assignment $v$.</p>\n\n<p><strong>Reduction from decision problem $MaxUNSAT(\\phi, k)$ to SAT:</strong></p>\n\n<p>One can reduce the devision problem $MaxUNSAT(\\phi, k)$ to the SAT problem by adding blocking variables to each clause and adding a cardinality constraint as propositional formula to limit the number of used clauses with help of the blocking variables.</p>\n\n<p>I can describe this in more detail, if needed.</p>\n\n<p><strong>Conculsion:</strong></p>\n\n<p>One can reduce the MaxUNSAT problem to the SAT problem and then solve the SAT problem with the MaxSAT problem. This is a reduction that works in polynomial time.</p>\n', 'ViewCount': '127', 'Title': 'How to reduce MaxUNSAT to MaxSAT?', 'LastEditorUserId': '2313', 'LastActivityDate': '2012-09-24T21:55:55.063', 'LastEditDate': '2012-09-24T21:55:55.063', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2313', 'Tags': '<complexity-theory><optimization><reductions><satisfiability>', 'CreationDate': '2012-09-20T08:42:23.210', 'Id': '4625'},6917:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In question <a href="http://cs.stackexchange.com/questions/4625/how-to-reduce-maxunsat-to-maxsat">How to reduce MaxUNSAT to MaxSAT?</a> I was asking, how to reduce the MaxUNSAT problem to MaxSAT. With help of the given answer I could give a polynomial reduction : $MaxUNSAT \\leq decisionProblemMaxUNSAT \\leq SAT \\leq MaxSAT$.</p>\n\n<p><strong>Question:</strong> Is there a more direct reduction without much overhead from MaxUNSAT to MaxSAT (or to minUNSAT)?</p>\n\n<p>Because the two problems are very similiar, it seems there is a more direct reduction, but I could not figure out one.</p>\n\n<p>Something like $MaxUNSAT(\\phi) = MaxSAT(\\neg\\phi)$ (which does not work).</p>\n', 'ViewCount': '61', 'Title': 'How to reduce MaxUNSAT to MaxSAT in a (almost) direct way?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-03T21:41:01.693', 'LastEditDate': '2012-09-24T22:21:34.283', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2313', 'Tags': '<complexity-theory><optimization><reductions><satisfiability>', 'CreationDate': '2012-09-24T21:59:46.447', 'Id': '4724'},6918:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '122', 'Title': 'How many possible assignments does  a CNF sentence have?', 'LastEditDate': '2012-09-25T15:58:33.800', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2962', 'FavoriteCount': '0', 'Body': u"<p>I'm having some trouble understanding the following:</p>\n\n<p>When we look at satisfiability problems in conjunctive normal form, an underconstrained problem is one with relatively few clauses constraining the variables. For eg. here is a randomly generated 3-CNF sentence with five symbols and five clauses. (Each clause contains 3 randomly selected distinct symbols, each of which is negated with 50% probability.)</p>\n\n<pre><code>(\xacD \u2228 \xacB \u2228 C) \u2227 (B \u2228 \xacA \u2228 \xacC) \u2227 (\xacC \u2228 \xacB \u2228 E) \u2227 (E \u2228 \xacD \u2228 B) \u2227 (B \u2228 E \u2228 \xacC)\n</code></pre>\n\n<p>16 of the 32 possible assignments are models of this sentence, so, on an average, it would take just 2 random guesses to find the model.</p>\n\n<p>I don't understand the last line- saying that there are 32 possible assignments. How is it 32? And how are only 16 of them models of the sentence? Thanks.</p>\n", 'Tags': '<logic><combinatorics><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-25T15:58:33.800', 'CommentCount': '0', 'AcceptedAnswerId': '4730', 'CreationDate': '2012-09-25T13:27:01.757', 'Id': '4729'},6919:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '634', 'Title': 'Planarity conditions for Planar 1-in-3 SAT', 'LastEditDate': '2012-10-01T18:24:10.170', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '2', 'Body': '<p><strong>Planar 3SAT</strong> is NP-complete. A planar 3SAT instance is a 3SAT instance for which the graph built using the following rules is planar:</p>\n\n<ol>\n<li>add a vertex for every $x_i$ and $\\bar{x_i}$</li>\n<li>add a vertex for every clause $C_j$</li>\n<li>add an edge for every $(x_i,\\bar{x_i})$ pair</li>\n<li>add an edge from vertex $x_i$ (or $\\bar{x_i}$) to each vertex that represent a clause that contains it</li>\n<li>add edges between two consecutive variables  $(x_1,x_2),(x_2,x_3),...,(x_n,x_1)$</li>\n</ol>\n\n<p>In particular, rule 5 builds a "backbone" that splits the clauses in two distinct regions.</p>\n\n<p><strong><a href="http://en.wikipedia.org/wiki/One-in-three_3SAT">Planar 1-in-3 SAT</a></strong> is NP-complete, too.</p>\n\n<blockquote>\nBut for planar 1-in-3 SAT are the planarity conditions defined in the same way as in Planar 3SAT ? In particular, can we assume that there is a backbone that links the variables $(x_i,x_{i+1})$  ?\n</blockquote>\n', 'Tags': '<np-complete><reductions><satisfiability><3-sat>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-10-01T18:24:10.170', 'CommentCount': '0', 'AcceptedAnswerId': '4832', 'CreationDate': '2012-10-01T10:44:10.560', 'Id': '4826'},6920:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If we suppose that we\'d like to convert an instance of 3-SAT to an instance of 4-SAT, by how much can we reduce the amount of variables?</p>\n\n<p><strong>CONVERSION METHODS FOR PRODUCTS OF SUMS</strong></p>\n\n<p>If we are given a 3-SAT clause $(A \\lor B \\lor C)$, we can readily convert this to 4-SAT by rewriting it as $(A \\lor B \\lor C \\lor x) \\land (A \\lor B \\lor C \\lor \\overline{x})$, where $x$ is a free variable.  In other words, $x$ can be any one of the existing variables, or a completely new variable.  This entails that we can gaurantee that 3-SAT can be converted to 4-SAT without adding any new variables.</p>\n\n<p>Additionally, we can convert 3-SAT into 4-SAT and eliminate one variable, given a special set of clauses.  The 3-SAT clauses</p>\n\n<p>$$(x \\lor B \\lor D) \\land (\\overline{A} \\lor \\overline{C} \\lor x) \\land (A \\lor C \\lor \\overline{x}) \\land (A \\lor \\overline{C} \\lor x) \\land (\\overline{A} \\lor C \\lor x)$$</p>\n\n<p>readily "reduce" to $(A \\lor B \\lor C \\lor D)$.  This eliminates the free variable $x$, assuming it only appears in these clauses, and also greatly reduces the number of clauses.  The significance of this is that we may be able to eliminate some variables using this technique.</p>\n\n<p><strong>THE MAIN QUESTION</strong></p>\n\n<p>What are some other techniques for reducing the number of variables when converting from 3-SAT to 4-SAT?  </p>\n\n<p>Note that converting from product-of-sums to sum-of-products form may also be useful.</p>\n', 'ViewCount': '590', 'Title': 'How can we reduce variables when converting from 3-SAT to 4-SAT?', 'LastActivityDate': '2012-10-22T19:18:42.620', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1667', 'Tags': '<satisfiability><3-sat>', 'CreationDate': '2012-10-22T17:54:55.177', 'Id': '6235'},6921:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2657', 'Title': 'Proving DOUBLE-SAT is NP-complete', 'LastEditDate': '2012-10-29T11:12:42.877', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4190', 'FavoriteCount': '0', 'Body': '<p>The well known SAT problem is defined <a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem">here</a> for reference sake. </p>\n\n<p>The DOUBLE-SAT problem is defined as</p>\n\n<p>$\\qquad \\mathsf{DOUBLE\\text{-}SAT} = \\{\\langle\\phi\\rangle \\mid \\phi \\text{ has at least two satisfying assignments}\\}$</p>\n\n<p>How do we prove it to be NP-complete? </p>\n\n<p>More than one way to prove will be appreciated. </p>\n', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-29T11:16:44.353', 'CommentCount': '0', 'AcceptedAnswerId': '6373', 'CreationDate': '2012-10-29T09:04:33.973', 'Id': '6371'},6922:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've read first-order logic is in general undecidable, and that could be decidable only when working with unary operators. (I think that's propositional logic, correct me if I am wrong)</p>\n\n<p>The question is <strong>why arity leads to undecidable problems?</strong></p>\n\n<p>I would like to see some reference material, or at least some simple <em>example</em> of it, as a way to think in this passage from unary to n-ary and why it leads to undecidable problems. </p>\n", 'ViewCount': '157', 'Title': 'First-order logic arity defines decidability?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T10:58:10.357', 'LastEditDate': '2012-11-05T17:16:52.103', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6489', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<reference-request><logic><undecidability><satisfiability><first-order-logic>', 'CreationDate': '2012-11-05T15:10:08.337', 'Id': '6488'},6923:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to sketch an IP proof for the minSAT problem. The minSAT problem is define in this way:</p>\n\n<ul>\n<li>For a given formulae find a satisfying assignment with a min subset of variables assigned to True;</li>\n</ul>\n\n<p>My sketched IP protocol is:</p>\n\n<ol>\n<li><p>Prover and Verifier share the input formula</p></li>\n<li><p>Prover sends to the Verifier a set of variables assigned to True, which should be the minimum</p></li>\n<li><p>Verifier checks if the given set indeed satisfies the formula. If it is the case, it chooses one variable, re-computes the formula and sends the new formula to the Prover</p></li>\n</ol>\n\n<p>I would iterate this process untill the Prover gives an empty set or I reach a contradiction.</p>\n\n<p>My questions are:</p>\n\n<ul>\n<li><p>Is this a right protocol? If not, how can I exploit the cases in which the protocol doesn't work?</p></li>\n<li><p>How can I evaluate the probability of completness and soundness for this protocol?</p></li>\n</ul>\n", 'ViewCount': '188', 'Title': 'Sketch an IP proof for minSAT', 'LastActivityDate': '2013-02-18T02:27:58.833', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4221', 'Tags': '<satisfiability><interactive-proof-systems>', 'CreationDate': '2012-11-20T15:22:19.130', 'FavoriteCount': '1', 'Id': '6788'},6924:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$\\newcommand{\\np}{\\mathsf{NP}}\\newcommand{\\cc}{\\textrm{Circuit-SAT}}$I am having difficulty understanding the $\\np$-hardness proof for $\\cc$ in <a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">CLRS</a>.</p>\n\n<blockquote>\n  <p>$\\cc = \\{\\langle C \\rangle : C \\text{ is a satisfiable combinatorial boolean circuit} \\}$</p>\n  \n  <p><strong>Lemma:</strong> The $\\cc$ problem is $\\mathsf{NP}$-hard.</p>\n</blockquote>\n\n<p>Can anyone provide an easy-to-understand proof?</p>\n', 'ViewCount': '265', 'Title': 'Circuit Satisfiability problem is NP-Hard?', 'LastEditorUserId': '19', 'LastActivityDate': '2012-12-01T05:56:51.550', 'LastEditDate': '2012-12-01T05:56:51.550', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7034', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<complexity-theory><np-hard><satisfiability><circuits>', 'CreationDate': '2012-11-30T02:16:14.930', 'Id': '7032'},6925:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '105', 'Title': 'How is verifying whether an assignment satisfies a boolean formula possible in polynomial time?', 'LastEditDate': '2012-12-03T21:32:10.107', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2860', 'FavoriteCount': '1', 'Body': '<p>How can I prove that I can verify whether a boolean assignment of variables $a$ satisfies some boolean formmula $\\phi$ in polynomial time?</p>\n\n<p>I know that we can just plug the boolean assignment into the formula, but this seems to be a very high-level description, and I am not sure that it is a reliable one since we must simplify the formula.</p>\n', 'Tags': '<complexity-theory><logic><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-03T21:38:26.133', 'CommentCount': '0', 'AcceptedAnswerId': '7135', 'CreationDate': '2012-12-03T21:03:03.350', 'Id': '7134'},6926:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read some research that analyzes the hardness of SAT solving in the average case.\nIn fact, for a 3CNF formula if you compute the ratio of clause to variables there is an interval (more or less between 4 and 5) in which solving the formula is hard. But it is easy (between 0 and 4) high probability of satisfiable assignment and high probability of unsatisfiable assignment after ratio 5.</p>\n\n<p>My question is, what about a generic formula that is not in normal form. We can say something about its hardness?</p>\n', 'ViewCount': '121', 'Title': 'Hardness of finding a true or a false assignment into a generic boolean formula?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-06T00:32:56.353', 'LastEditDate': '2013-02-06T00:32:56.353', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4887', 'Tags': '<complexity-theory><satisfiability><average-case>', 'CreationDate': '2012-12-05T18:54:17.610', 'Id': '7193'},6927:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $L_\\epsilon$ be the language of all $2$-CNF formulas $\\varphi$, such that at least $(\\frac{1}{2}+\\epsilon)$ of $\\varphi$'s clauses can be satisfied.</p>\n\n<p>I need to prove that there exists $\\epsilon'$ s.t $L_\\epsilon$ is $\\mathsf{NP}$-hard for any $\\epsilon&lt;\\epsilon'$.</p>\n\n<p>We know that $\\text{Max}2\\text{Sat}$ can be approximate to $\\frac{55}{56}$ precent of the clauses from a $\\text{Max}3\\text{Sat}$ reduction. How should I solve this one?</p>\n", 'ViewCount': '124', 'Title': "Find $\\epsilon'$ s.t $L_\\epsilon$ is $\\mathsf{NP}$-hard for any $\\epsilon<\\epsilon'$", 'LastEditorUserId': '41', 'LastActivityDate': '2012-12-23T09:24:26.913', 'LastEditDate': '2012-12-23T09:24:26.913', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7528', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<complexity-theory><satisfiability><approximation>', 'CreationDate': '2012-12-20T13:11:14.170', 'Id': '7523'},6928:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I received the following assignment:</p>\n\n<p>$\\text{EXACT-TRIPLE} = \\{ \\phi \\mid \\phi \\text{ is a boolean formula that has exactly 3 satisfying assignments} \\}$.</p>\n\n<p>I need to decide whether this problem belongs to NP or not. I assume it does not. How do I prove that?</p>\n', 'ViewCount': '160', 'Title': 'Prove that $\\text{EXACT-TRIPLE}$ is not in NP', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-25T21:52:14.667', 'LastEditDate': '2012-12-25T21:52:14.667', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5187', 'Tags': '<complexity-theory><np-complete><satisfiability><np>', 'CreationDate': '2012-12-25T18:00:43.690', 'FavoriteCount': '1', 'Id': '7595'},6929:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '259', 'Title': 'Is there a sometimes-efficient algorithm to solve #SAT?', 'LastEditDate': '2013-01-16T01:27:21.360', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1786', 'FavoriteCount': '2', 'Body': '<p>Let $B$ be a boolean formula consisting of the usual AND, OR, and NOT operators and some variables.  I would like to count the number of satisfying assignments for $B$. That is, I want to find the number of different assignments of truth values to the variables of $B$ for which $B$ assumes a true value. For example, the formula $a\\lor b$ has three satisfying assignments; $(a\\lor b)\\land(c\\lor\\lnot b)$ has four. This is the <a href="https://en.wikipedia.org/wiki/Sharp-SAT">#SAT problem</a>.</p>\n\n<p>Obviously an efficient solution to this problem would imply an efficient solution to SAT, which is unlikely, and in fact this problem is #P-complete, and so may well be strictly harder than SAT. So I am not expecting a guaranteed-efficient solution.</p>\n\n<p>But it is well-known that there are relatively few really difficult instances of SAT itself. (See for example <a href="http://www.dcs.gla.ac.uk/~pat/cpM/papers/cheeseman91where.pdf">Cheeseman 1991, "Where the <em>really</em> hard problems are"</a>.) Ordinary pruned search, although exponential in the worst case, can solve many instances efficiently; resolution methods, although exponential in the worst case, are even more efficient in practice.  </p>\n\n<p>My question is:</p>\n\n<blockquote>\n  <p>Are any algorithms known which can quickly count the number of satisfying assignments of a typical boolean formula, even if such algorithms require exponential time in the general instance? Is there anything noticeably better than enumerating every possible assignment?</p>\n</blockquote>\n', 'Tags': '<complexity-theory><reference-request><satisfiability>', 'LastEditorUserId': '1786', 'LastActivityDate': '2013-06-25T05:37:04.663', 'CommentCount': '4', 'AcceptedAnswerId': '8953', 'CreationDate': '2013-01-16T00:21:03.510', 'Id': '8952'},6930:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We say that the language $J \\subseteq \\Sigma^{*}$ is <em>dense</em> if there exists a polynomial $p$ such that $$ |J^c \\cap \\Sigma^n| \\leq p(n)$$ for all $n \\in \\mathbb{N}.$ In other words, for any given lenght $n$ there exist only polynomially many words of length $n$ that are not in $J.$</p>\n\n<p>The problem I am currently studying asks to show the following</p>\n\n<blockquote>\n  <p>If there exist a dense $NP$-complete language then $P = NP$</p>\n</blockquote>\n\n<p>What the text suggest is to consider the polynomial reduction to $3$-$SAT$ and then construct an algorithm that tries to satisfy the given $CNF$ formula while also generating elements in $J^c.$</p>\n\n<p>What I am wondering is</p>\n\n<blockquote>\n  <p>Is there a more direct proof? Is this notion known in a more general setting?</p>\n</blockquote>\n', 'ViewCount': '262', 'Title': 'A dense NP complete language implies P=NP', 'LastActivityDate': '2013-02-05T23:51:20.210', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9529', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<complexity-theory><time-complexity><np-complete><satisfiability>', 'CreationDate': '2013-01-30T20:07:13.607', 'FavoriteCount': '1', 'Id': '9327'},6931:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am interested to know the complexity of the NAE-HORN-SAT problem\n(not all equal).  We know that HORNSAT is $\\mathsf{P}$-complete, but\non the other hand, NAE-SAT is $\\mathsf{NP}$-complete.  I want to know\nwhat can we say about NAE-HORN-SAT problem.  Let me define the problem\nformally:</p>\n\n<blockquote>\n  <p>Given: One Boolean formula $\\phi$ is given to us in CNF where each\n  clause has at most one positive literal (HORN-property).<br>\n  Question: Is there any assignment for the input variables of\n  $\\phi$ such that any clause has at least one False and at least one\n  True literal (NAE-property) ?</p>\n</blockquote>\n\n<p>N.B.:</p>\n\n<ul>\n<li>Positive literal: any variable directly,</li>\n<li>Negative literal: negation of any variable.</li>\n<li>True literal: literal is assigned to Boolean True by any assignment,</li>\n<li>False literal: literal is assigned to Boolean False by any assignment.</li>\n</ul>\n\n<p>According to <a href="http://en.wikipedia.org/wiki/Schaefer%27s_dichotomy_theorem" rel="nofollow">Schaefer\'s dichotomy theorem</a>, this problem must be either\nin $\\mathsf{P}$ or $\\mathsf{NP}$-complete.  I can just find one\npolynomial reduction from HORNSAT to this problem, which proves\nactually nothing.  Is there a polynomial time algorithm to solve this\nproblem?</p>\n\n<p>Or, is there any way to prove this problem to be $\\mathsf{NP}$-hard?\nAny thoughts about this ?</p>\n', 'ViewCount': '263', 'Title': 'Is NAE-HORN-SAT in P or NP-hard?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-05T13:20:20.817', 'LastEditDate': '2013-02-05T12:57:19.910', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '6', 'OwnerDisplayName': 'David', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'CreationDate': '2013-02-04T16:04:39.273', 'FavoriteCount': '1', 'Id': '9484'},6932:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to know whether the 2-DNF problem is NP-complete or not? If it is NP-complete, can anyone provide a proof?</p>\n', 'ViewCount': '256', 'Title': 'Is 2-DNF NP-complete?', 'LastEditorUserId': '10228', 'LastActivityDate': '2013-11-07T13:27:21.760', 'LastEditDate': '2013-11-07T13:27:21.760', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'user13821', 'PostTypeId': '1', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'CreationDate': '2013-02-19T07:28:39.307', 'Id': '9927'},6933:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '157', 'Title': 'Why is MAX-2SAT in NP?', 'LastEditDate': '2013-02-26T07:47:05.793', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'simplicity', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': "<blockquote>\n  <p>Max-2-SAT is defined as follows. We are given a 2-CNF formula and a\n  bound k, and asked to find an assignment to the variables that\n  satisfies at least k of the clauses.</p>\n</blockquote>\n\n<p>I can understand the trick used to prove 2-SAT is in P. You use get a contradiction by using unit propagation. But, I was wondering why does MAX 2-SAT escape this.</p>\n\n<p>Also, I find it hard to believe this is NP-complete. Certainly, what is the problem that causes it to blow up.</p>\n\n<p>Why wouldn't an algorithm like this work. Given a 2-SAT expression. Find it's length, which we can do in P. Need to check if there is at least k of the clauses.</p>\n\n<p>So we just check $\\binom n k$ posibilities and run like Horn algorithm on each sub expression of the n 2-SAT expression. Surely, where is the problem as we are just running a P algorithm a polynomial amount of time. </p>\n\n<p>So I'm very confused. Sort of similar problem I have factorization and if that is in P or NP. </p>\n", 'Tags': '<complexity-theory><np-complete><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-26T07:47:05.793', 'CommentCount': '2', 'AcceptedAnswerId': '10099', 'CreationDate': '2013-02-23T11:09:50.640', 'Id': '10098'},6934:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This question arises from my reading of <a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">"Types and Programming Languages"</a> (<a href="http://www.worldcat.org/oclc/47705787" rel="nofollow">WorldCat</a>) by Benjamin C. Pierce.</p>\n\n<p>On page 36 is the definition for <em>satisfied</em></p>\n\n<blockquote>\n  <p>A rule is <em>satisfied</em> by a relation if, for each instance of the rule,\n  either the conclusion is in the relation or one of the premises is\n  not.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>instance</em></p>\n\n<blockquote>\n  <p>An <em>instance</em> of an inference rule is obtained by consistently replacing\n  each metavariable by the same term in the rule\'s conclusion and all its\n  premises (if any).</p>\n  \n  <p>For example </p>\n  \n  <p><code>if true then true else (if false then false else false) -&gt; true</code></p>\n  \n  <p>is an instance of <strong>E-IFTRUE</strong>, where both occurrences of $t_2$ have been\n  replaced by <code>true</code> and $t_3$ has been replaced by <code>if false then false else\n  false</code>.</p>\n</blockquote>\n\n<p>On page 15 is the definition for <em>relataion</em></p>\n\n<blockquote>\n  <p>An n-place <em>relation</em> on a collection of sets $S_1, S_2,..., S_n$ is a\n  set $R\\subseteq  S_1\\times\\;S_2\\;\\times\\;...\\;\\times\\;S_n$ of tuples\n  of elements from $S_1$ through $S_n$. We say that the elements $s_1\\in\n&gt; S_1$ thorugh $s_n\\in S_n$ are related by $R$ if $(s_1,...,s_n)$ is an\n  element or $R$.</p>\n</blockquote>\n\n<p>On page 36 is the definition for <em>one-step evaluation relation ($\\rightarrow $)</em> </p>\n\n<blockquote>\n  <p>The <em>one-step evaluation relation $\\rightarrow $</em> is the smallest\n  binary relation on terms satisfying the three rules of Figure 3-1.\n  When the pair $(t,t\')$ is in the evaluation relation,  we say that "the\n  evaluation statement (or judgment) $t \\rightarrow t\'$ is derivable."</p>\n</blockquote>\n\n<p>On page 34 are the three rules from Figure 3-1</p>\n\n<p><strong>E-IFTRUE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;true\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IFFALSE</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}if\\;false\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;t_2\\end{equation}</p>\n</blockquote>\n\n<p><strong>E-IF</strong></p>\n\n<blockquote>\n  <p>\\begin{equation}\\frac{t_1\\rightarrow\\;t_1\'}{if\\;t_1\\;then\\;t_2\\;else\\;t_3\\;\\rightarrow\\;if\\;t_1\'\\;then\\;t_2\\;else\\;t_3}\\end{equation}</p>\n</blockquote>\n\n<p>Can someone explain this definition and give an example for parts of the defintion.<br>\n1. The conclusion is in the relation.<br>\n2. One of the premises is not.  </p>\n\n<p>Note: I am aware that there is a forum dedicated to questions for the book <a href="http://lists.seas.upenn.edu/mailman/listinfo/types-list" rel="nofollow">here</a>.</p>\n\n<p>Note: You can use <a href="http://scholar.google.com/" rel="nofollow">Google Scholar</a> to see more of the details to this question in context.</p>\n\n<p>EDIT</p>\n\n<p>To connect some of the dots about my comment regarding unification and term rewriting.</p>\n\n<p>When I saw</p>\n\n<p>$$(A\\rightarrow B)\\equiv (\\neg A \\vee B)$$</p>\n\n<p>it reminded me of <a href="http://en.wikipedia.org/wiki/Horn_clause" rel="nofollow">Horn claues</a> from <a href="http://en.wikipedia.org/wiki/Prolog" rel="nofollow">Prolog</a>, that along with the example then connected with my understanding of <a href="http://en.wikipedia.org/wiki/Rewriting" rel="nofollow">term rewriting</a>. Having the book "<a href="http://www.cambridge.org/gb/knowledge/isbn/item1166682/?site_locale=en_GB" rel="nofollow">Term Rewriting and All That</a>" (<a href="http://www.worldcat.org/title/term-rewriting-and-all-that/oclc/37315354&amp;referer=brief_results" rel="nofollow">WorldCat</a>) by Franz Baader and Tobias Nipkow, I quickly looked up satisfiability and found satisfiable on page 58. This is actually the start of whole chapter on Equational Problems; but it also covers <a href="http://en.wikipedia.org/wiki/Unification_%28computer_science%29" rel="nofollow">unification</a>. At that point I realized that the definition was dealing with <a href="http://en.wikipedia.org/wiki/Satisfiability" rel="nofollow">Satisfiability</a> and from there is was a topic I was already familiar. What threw me was the way Benjamin defined it. He used a very precise definition right up front in a manner I didn\'t associate with my knowledge.  </p>\n\n<p>If you work through the code as I am and understand logic programming, then the definition makes perfect sense.</p>\n', 'ViewCount': '107', 'Title': 'TAPL: Explanation and example(s) for satisfied', 'LastEditorUserId': '268', 'LastActivityDate': '2013-03-11T01:59:40.410', 'LastEditDate': '2013-03-11T01:59:40.410', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10403', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<satisfiability><operational-semantics><small-step><term-rewriting>', 'CreationDate': '2013-03-08T14:05:18.400', 'Id': '10386'},6935:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '521', 'Title': 'Understanding DPLL algorithm', 'LastEditDate': '2013-03-31T14:44:46.170', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7509', 'FavoriteCount': '1', 'Body': u'<p>I\'m trying to understand <a href="http://en.wikipedia.org/wiki/DPLL_algorithm" rel="nofollow">DPLL algorithm</a> for solving SAT problem. And here it is:</p>\n\n<pre><code>Algorithm DPLL\n  Input: A set of clauses \u03a6.\n  Output: A Truth Value.\nfunction DPLL(\u03a6)\n   if \u03a6 is a consistent set of literals\n       then return true;\n   if \u03a6 contains an empty clause\n       then return false;\n   for every unit clause l in \u03a6\n      \u03a6 \u2190 unit-propagate(l, \u03a6);\n   for every literal l that occurs pure in \u03a6\n      \u03a6 \u2190 pure-literal-assign(l, \u03a6);\n   l \u2190 choose-literal(\u03a6);\n   return DPLL(\u03a6 \u2227 l) or DPLL(\u03a6 \u2227 not(l));\n</code></pre>\n\n<p>At first, I don\'t clearly understand how <code>unit-propagate(l, \u03a6)</code>, <code>pure-literal-assign(l, \u03a6)</code> and <code>choose-literal(\u03a6)</code> work. I\'ll try to guess on particular examples. Correct me please if I do something wrong. </p>\n\n<ul>\n<li><p>For the first one </p>\n\n<p><code>unit-propagate(a, (0 v -a) \u2227 (a v b) \u2227 (b v d) \u2227 (f v g) v ...)</code> </p>\n\n<p>we will have </p>\n\n<p><code>((0 v -0) \u2227 (0 or 1) \u2227 (1 v d) \u2227 (f v g) \u2227 ... = (f v g) v ...</code>,</p>\n\n<p>having <code>a = 0</code>, <code>b = 1</code>.</p></li>\n<li><p>For second procedure</p>\n\n<p><code>pure-literal-assign(a, (a v b v c) \u2227 (d v -b v a) \u2227 (-d v b))</code></p>\n\n<p>result is </p>\n\n<p><code>(b v c) \u2227 (d v -b) \u2227 (-d v b)</code>,</p>\n\n<p>assigning <code>a = 1</code>.</p></li>\n<li><p>And finally <code>choose-literal(\u03a6)</code> just returns some random (in common case) unassigned literal for further computations.</p></li>\n</ul>\n\n<p>Now, I don\'t understand why algorithm has such strange conditions for finishing? Why does it work?</p>\n\n<p>Thanks!</p>\n', 'Tags': '<algorithms><logic><satisfiability><sat-solvers>', 'LastEditorUserId': '7509', 'LastActivityDate': '2013-03-31T17:36:48.023', 'CommentCount': '0', 'AcceptedAnswerId': '10933', 'CreationDate': '2013-03-31T08:26:51.050', 'Id': '10932'},6936:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A set is sparse if it contains polynomially bounded number of strings of any given string length $n$ otherwise it is dense. All known NP-complete sets are dense. It was proven that P=NP if and only if there is a sparse NP-complete set (under Karp reduction).</p>\n\n<p>I would like to find the density of uniquely satisfiable 3SAT formulas. Is it super-polynomially dense or exponentially dense? What is known about the asymptotic lower bound on the number of 3SAT formulas with unique solutions?</p>\n', 'ViewCount': '84', 'Title': 'Asymptotic bounds on number of 3SAT formulas with unique solutions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-01T23:30:50.850', 'LastEditDate': '2013-04-21T14:12:11.020', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11745', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<complexity-theory><reference-request><np-complete><satisfiability>', 'CreationDate': '2013-04-19T12:56:38.680', 'Id': '11408'},6937:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '451', 'Title': 'Prove NP-completeness of deciding satisfiability of monotone boolean formula', 'LastEditDate': '2013-04-26T09:54:06.637', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7901', 'FavoriteCount': '1', 'Body': "<p>I am trying to solve this problem and I am really struggling.</p>\n\n<p>A <em>monotone boolean formula</em> is a formula in propositional logic where all the literals are positive. For example, </p>\n\n<p>$\\qquad (x_1 \\lor x_2) \\land (x_1 \\lor x_3) \\land (x_3 \\lor x_4 \\lor x_5)$ </p>\n\n<p>is a monotone boolean function. On the other hand, something like</p>\n\n<p>$\\qquad (x_1 \\lor x_2 \\lor x_3) \\land (\\neg x_1 \\lor x_3) \\land (\\neg x_1 \\lor x_5)$ </p>\n\n<p>is not a monotone boolean function.</p>\n\n<p>How can I prove NP-completeness for this problem: </p>\n\n<blockquote>\n  <p>Determine whether a monotone boolean function is satisfiable if $k$ variables or fewer are set to $1$? </p>\n</blockquote>\n\n<p>Clearly, all the variables could just be set to be positive, and that's trivial, so that is why there is the restraint of $k$ positively set variables.</p>\n\n<p>I have tried a reduction from SAT to monotone boolean formula. One thing I have tried is to substitute a dummy variable in for every negative literal. For example, I tried replacing $\\neg x_1$ with $z_1$, and then I tried forcing $x_1$ and $z_1$ to be different values. I haven't quite been able to get this to work though.</p>\n", 'Tags': '<complexity-theory><np-complete><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-26T09:54:06.637', 'CommentCount': '1', 'AcceptedAnswerId': '11559', 'CreationDate': '2013-04-25T23:58:57.687', 'Id': '11558'},6938:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '406', 'Title': 'Converting (math) problems to SAT instances', 'LastEditDate': '2013-09-17T08:05:55.883', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7443', 'FavoriteCount': '1', 'Body': '<p>What I want to do is turn a math problem I have into a boolean satisfiability problem (SAT) and then solve it using a SAT Solver.  I wonder if someone knows a manual, guide or anything that will help me convert my problem to a SAT instance.</p>\n\n<p>Also, I want to solve this in a better than exponential time. I hope a SAT Solver will help me.</p>\n', 'Tags': '<algorithms><satisfiability>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-17T08:05:55.883', 'CommentCount': '13', 'AcceptedAnswerId': '12123', 'CreationDate': '2013-05-17T16:39:55.210', 'Id': '12087'},6939:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '189', 'Title': 'Modeling the problem of finding all stable sets of an argumentation framework as SAT', 'LastEditDate': '2013-05-20T14:48:10.623', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7443', 'FavoriteCount': '2', 'Body': '<p>As a continuation of my previous <a href="http://cs.stackexchange.com/questions/12087/converting-math-problems-to-sat-instances?noredirect=1#comment25370_12087">question</a> i will try to explain my problem and how i am trying to convert my algorithm to a problem that can be expressed in a CNF form.</p>\n\n<p>Problem: Find all stable sets of an <a href="http://en.wikipedia.org/wiki/Argumentation_framework" rel="nofollow">argumentation framework</a> according to <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.4129" rel="nofollow">Dung\'s proposed framework</a>.</p>\n\n<p>Brief theory: Having an argumentation framework AF, with A the set of all arguments and R the set of the relations, a stable set is a set which attacks all arguments not in their set and there is no attack relation between arguments in the stable set.\nExample:</p>\n\n<p>Let\'s say we have an argumentation framework AF ,A={1,2,3,4}(arguments of AF) and attack relations R{1,3} and R{2,4}.\nIt\'s obvious that the set {1,2} is a stable extension of the framework because:</p>\n\n<p>a)it attacks all arguments not in their set (3 and 4)</p>\n\n<p>b)it\'s conflict free(no attacks between arguments in the set) because argument 1 does not attack argument 2 and the opposite </p>\n\n<p>My exhaustive abstract algorithm:</p>\n\n<pre><code>argnum=number of arguments;\n\nAi[argnum-1]=relation "attacks" ,where 1&lt;=i&lt;=argnum\n\nP[2^argnum-1]=all possible relations that can be generated from all the arguments\n\nS[2^argnum-1]=empty; where S are all the stable sets\n\nj=0; //counter for while\nk=1; //counter for counting stable sets\nwhile j&lt;2^argnum-1\n    if P[j] attacks all arguments not in P[j](check using Ai[])\n        if all arguments in P[j] are conlfict-free\n            S[k++]=P[j];\n        end if\n    end if \n    j++;\nend while\n</code></pre>\n\n<p>I want to solve the above problem either by transforming the above algorithm to CNF or by using a different algorithm and finally use a SAT Solver(or anything similar if exists) give CNF as input and get stable sets as output.</p>\n\n<p>I wonder if someone can give me any feedback of how i can transform any algorithm like the above to CNF in order to be used into a SAT Solver.</p>\n\n<p>I decided to use <a href="http://fmv.jku.at/precosat/" rel="nofollow">precosat</a>.</p>\n', 'Tags': '<algorithms><complexity-theory><time-complexity><np-complete><satisfiability>', 'LastEditorUserId': '7443', 'LastActivityDate': '2013-05-26T00:33:46.807', 'CommentCount': '7', 'AcceptedAnswerId': '12176', 'CreationDate': '2013-05-19T15:50:58.177', 'Id': '12135'},6940:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Assuming $P \\neq NP$ Is the following langauge in $P$ or $NPC$:<br>\n$L=\\{\\langle\\phi\\rangle\\mid\\phi$ is a 3CNF formula with an assignment satisfying at least half of the clauses$\\}$</p>\n\n<p>The first thing I tried to do is to find a 3CNF formula $\\phi$ such that  $\\phi \\notin L$ and I haven't managed to do so. Is it possible that simply all 3CNF formulas have such an assignment (and so the problem is in $P$) or am I missing something ?</p>\n", 'ViewCount': '55', 'Title': 'Is the following langauge in $P$ or $NPC$', 'LastActivityDate': '2013-06-14T23:01:55.957', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12680', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<complexity-theory><time-complexity><np-complete><satisfiability><3-sat>', 'CreationDate': '2013-06-14T22:05:23.980', 'Id': '12678'},6941:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m using a SAT solver to encode a problem, and as part of the SAT instance, I have boolean variables $x_1,x_2,\\dots,x_n$ where it is intended that exactly one of these should be true and the rest should be false.    (I\'ve sometimes seen this  described as a "one-hot" encoding.)</p>\n\n<p>I want to encode the constraint "exactly one out of $x_1,\\dots,x_n$ must be true" in SAT.  What is the best way to encode this constraint, to make the SAT solver run as efficiently as possible?</p>\n\n<p>I can see many ways to encode this constraint:</p>\n\n<ul>\n<li><p><em>Pairwise constraints.</em> I could add pairwise constraints $\\neg x_i \\lor \\neg x_j$ for all $i,j$ to ensure that at most one $x_i$ is true, and then add $x_1 \\lor x_2 \\lor \\cdots \\lor x_n$ to ensure that at least one is true.</p>\n\n<p>This adds $\\Theta(n^2)$ clauses and no extra boolean variables.</p></li>\n<li><p><em>Binary encoding.</em>  I could introduce $\\lg n$ new boolean variables $i_1,i_2,\\dots,i_{\\lg n}$ to represent (in binary) an integer $i$ such that $1 \\le i \\le n$ (adding a few boolean constraints to ensure that $i$ is in the desired range).  Then, I can add constraints enforcing that $x_i$ is tree and that all other $x_j$\'s are false.  In other words, for each $j$, we add clauses enforcing that $i=j \\Leftrightarrow x_j$.</p>\n\n<p>This adds $\\Theta(n \\lg n)$ clauses and I don\'t know how many extra boolean variables.</p></li>\n<li><p><em>Count the number of true values.</em>  I could implement a tree of boolean adder circuits and require that $x_1+x_2+\\dots+x_n=1$, treating each $x_i$ as 0 or 1 instead of false or true, and use the Tseitin transform to convert the circuit to SAT clauses.  A tree of half-adders suffices: constrain the carry output of each half-adder to be 0, and constrain the final output of the final half-adder in the tree to be 1.  The tree can be chosen to be of any shape (balanced binary tree, or unbalanced, or whatever).</p>\n\n<p>This can be done in $\\Theta(n)$ gates and thus adds $\\Theta(n)$ clauses and $\\Theta(n)$ new boolean variables.</p>\n\n<p>A special case of this approach is to introduce boolean variables $y_1,\\dots,y_n$, with the idea that $y_i$ should contain the value of $x_1 \\lor x_2 \\lor \\cdots \\lor x_i$.  This intent can be enforced by adding the clauses $y_i \\lor \\neg x_i$, $y_i \\lor \\neg y_{i-1}$, and $\\neg y_i \\lor x_i \\lor y_{i-1}$ (where we treat $y_0$ as a synonym for false) for $i=1,\\dots,n$.  Next, we can add the restrictions $\\neg y_i \\lor \\neg x_{i+1}$ for $i=1,2,\\dots,n-1$.  This is basically equivalent to the Tseitin transform of a half-adder tree, where the tree has a maximally unbalanced shape.</p></li>\n<li><p><em>Butterfly network.</em> I could build a <a href="https://en.wikipedia.org/wiki/File%3aButterfly_multitree.svg">butterfly network</a> on $n$ bits, constrain the $n$-bit input to be $000\\cdots 01$, constrain the $n$-bit output to be $x_1 x_2 \\cdots x_n$, and treat each 2-bit butterfly gate as an independent gate that either swaps or does not swap its input with the decision of which to do based upon a fresh new boolean variable that is left unconstrained.  Then, I can apply the Tseitin transform to convert the circuit to SAT clauses.</p>\n\n<p>This requires $\\Theta(n \\lg n)$ gates and thus adds $\\Theta(n \\lg n)$ clauses and $\\Theta(n \\lg n)$ new boolean variables.</p></li>\n</ul>\n\n<p>Are there any other methods I have overlooked?  Which one should I use?  Has anyone tested this or tried them experimentally, or does anyone have any experience with any of these?  Is the number of clauses and/or the number of new boolean variables a good stand-in metric for estimating the impact of this on SAT solver performance, or if not, what metric would you use?</p>\n\n<hr>\n\n<p>I just noticed that <a href="http://cs.stackexchange.com/a/6522/755">this answer</a> has some references on enforcing cardinality constraints for SAT, i.e., enforcing the constraint that exactly $k$ out of the $n$ variables are true.  So, my question comes down to a special case where $k=1$.  Maybe the literature on cardinality constraints will help shed light on my question.</p>\n', 'ViewCount': '301', 'Title': 'Encoding 1-out-of-n constraint for SAT solvers', 'LastEditorUserId': '755', 'LastActivityDate': '2013-07-10T16:31:28.367', 'LastEditDate': '2013-07-10T16:31:28.367', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<satisfiability><sat-solvers><applied-theory>', 'CreationDate': '2013-07-09T20:56:13.173', 'FavoriteCount': '1', 'Id': '13188'},6942:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '176', 'Title': 'Complexity of deciding if a formula has exactly 1 satisfying assignment', 'LastEditDate': '2013-08-23T23:03:31.500', 'AnswerCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '667', 'FavoriteCount': '4', 'Body': '<p>The decision problem</p>\n\n<blockquote>\n  <p>Given a Boolean formula $\\phi$, does $\\phi$ have exactly one satisfying assignment?</p>\n</blockquote>\n\n<p>can be seen to be in $\\Delta_2$, $\\mathsf{UP}$-hard and $\\mathsf{coNP}$-hard. Is anything more known about its complexity?</p>\n', 'Tags': '<complexity-theory><complexity-classes><satisfiability>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-08-25T18:38:59.147', 'CommentCount': '0', 'AcceptedAnswerId': '13888', 'CreationDate': '2013-08-23T13:09:52.587', 'Id': '13887'},6943:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<ol>\n<li><p>Apart from $2SAT$, what versions of SAT problem is complete for the class NL?</p></li>\n<li><p>Is there dynamic programming algorithm to solve the $2SAT$ Problem?</p></li>\n</ol>\n', 'ViewCount': '120', 'Title': 'Are there more easy SAT Problems?', 'LastEditorUserId': '9736', 'LastActivityDate': '2013-09-09T12:13:05.067', 'LastEditDate': '2013-09-09T10:54:07.480', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<complexity-theory><satisfiability>', 'CreationDate': '2013-09-06T23:11:12.620', 'Id': '14179'},6944:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '122', 'Title': 'Convert $\\sum x_i = y$ to 3-sat', 'LastEditDate': '2013-09-27T16:42:08.333', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10359', 'FavoriteCount': '1', 'Body': '<p>I have a simple looking question. What is the most efficient conversion of  $\\sum_{i=1}^n x_i = y$ to 3-sat?  Here $x_i$ is either $1$ or $0$ and $y$ is some positive integer.</p>\n\n<p>Can you do better than making a SATISFIABILITY instance with $\\binom{n}{y}$ clauses, each of which is the conjunction of $y$ positive literals and $n-y$ negative literals and then just feeding the whole thing into the <a href="http://en.wikipedia.org/wiki/Tseitin-Transformation" rel="nofollow">Tseitin transform</a>?</p>\n', 'Tags': '<satisfiability><sat-solvers>', 'LastEditorUserId': '10359', 'LastActivityDate': '2013-10-02T04:31:49.637', 'CommentCount': '4', 'AcceptedAnswerId': '14667', 'CreationDate': '2013-09-27T11:40:14.670', 'Id': '14640'},6945:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $x=(x_1,\\dots,x_n)$ and $y=(y_1,\\dots,y_n)$ be $n$-vectors of boolean variables.  I have a boolean predicate $Q(x,y)$ on $x,y$.  I give my friend Priscilla $Q(x,y)$.  In response, she gives me $P(x)$, a boolean predicate on $x$, and she claims that</p>\n\n<p>$$P(x) \\equiv \\exists y . Q(x,y),$$</p>\n\n<p>or in other words, that</p>\n\n<p>$$\\forall x . [P(x) \\Leftrightarrow \\exists y . Q(x,y)].$$</p>\n\n<p>I would like to verify her claim somehow.  How can Priscilla help me verify this claim?</p>\n\n<p>You can assume that both $P$ and $Q$ are represented as CNF formulas, and that they\'re not too large (polynomial size, or something).</p>\n\n<p>In an ideal world, it\'d be awesome if I could reduce the problem of verifying this claim to SAT: I have a SAT solver, and it\'d be great if I can use the SAT solver to verify this claim.  However, I\'m pretty sure that it\'s not going to be possible to formulate the problem of verifying this claim directly as a SAT instance; <a href="http://cstheory.stackexchange.com/q/11022/5038">testing the validity of a 2QBF formula</a> is almost certainly harder than SAT.  (The $\\Leftarrow$ direction is easy to formulate as a SAT instance, but the $\\Rightarrow$ direction is hard because it inherently involves two alternating quantifiers.)</p>\n\n<p>But suppose Priscilla could give me some additional evidence to support her claim.  Is there some additional evidence or witness Priscilla could give me, which would make it easy for me to verify her claim?  In particular, is there some additional evidence or witness she could give me, which would make it easy for me to formulate the problem of verifying her claim as an instance of SAT (which I can then apply my SAT solver to)?</p>\n\n<p>One unusual aspect of my setting is that I\'m assuming (heuristically) that I have an oracle for SAT.  If you like complexity theory, you can think about it this way: I am taking the role of a machine that can compute things in $P^{NP}$ (i.e., in $\\Delta^P_2$), and I\'m looking to verify Priscilla\'s claim using an algorithm in $P^{NP}$.  My thanks to mdx for this way of thinking about things.</p>\n\n<hr>\n\n<p>My motivation/application: I\'m looking to do formal verification of a system (e.g., symbolic model checking), and a key step in the reasoning involves quantifier elimination (i.e., starting from $Q$, obtain $P$).  I\'m hoping for some clean way to verify that the quantifier elimination was done correctly.</p>\n\n<p>If there\'s no solution that works for all possible $P,Q$, feel free to suggest a solution that is "sound but not complete", i.e., a technique that for many $P,Q$ lets me verify the claimed equivalence. (Even if it fails to verify the claim on some $P,Q$ that do satisfy the claim, I can still try this as a heuristic, as long as it never inappropriately claims to have verified a false claim.  On any given $P,Q$, it might work, or it might not; if it doesn\'t work, I\'m no worse off than where I started.)</p>\n', 'ViewCount': '109', 'Title': 'Verify correctness of quantifier elimination, using SAT', 'LastEditorUserId': '755', 'LastActivityDate': '2013-10-09T00:35:46.483', 'LastEditDate': '2013-10-07T02:09:21.303', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<logic><satisfiability><first-order-logic><software-verification><model-checking>', 'CreationDate': '2013-10-04T20:40:24.817', 'FavoriteCount': '2', 'Id': '14816'},6946:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There is a long-standing and seemingly ever-growing trend to reduce various (even undecidable) problems to SAT to get practically useful solvers, like for instance [1].</p>\n\n<p>I'm looking for some kind of survey or list of papers/projects that fall into this category.</p>\n\n<p>[1] Chad E. Brown: Satallax: An Automatic Higher-Order Prover. IJCAR 2012: 111-117</p>\n", 'ViewCount': '52', 'Title': 'Reductions to SAT', 'LastActivityDate': '2013-10-06T18:03:32.497', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5405', 'Tags': '<reference-request><satisfiability>', 'CreationDate': '2013-10-06T18:03:32.497', 'Id': '14859'},6947:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So, as is known, ILP's 0-1 decision problem is NP-complete. Showing it's in NP is easy, and the original reduction was from SAT; since then, many other NP-Complete problems have been shown to have ILP formulations (which function as reductions from those problems to ILP), because ILP is very usefully general.</p>\n\n<p>Reductions <strong>from</strong> ILP seem much harder to either do myself or track down.</p>\n\n<p>Thus, my question is, does anyone know a poly-time reduction from ILP to SAT, that is, demonstrating how to solve any 0-1 ILP decision problem using SAT?</p>\n", 'ViewCount': '278', 'Title': 'Poly-time reduction from ILP to SAT?', 'LastActivityDate': '2013-10-15T04:46:34.827', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16090', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '10743', 'Tags': '<np-complete><satisfiability><integer-programming>', 'CreationDate': '2013-10-14T21:26:54.377', 'FavoriteCount': '2', 'Id': '16088'},6948:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Both <a href="http://en.wikipedia.org/wiki/2-satisfiability" rel="nofollow" title="this text appears when you mouse over">wikipedia</a> and my lecturer explained how the 2 satisfiability problem work. However, I am finding it really hard understanding how this formula:</p>\n\n<pre><code>xvy\u2261 \xacx--&gt;y \u2261 \xacy --&gt;x\n</code></pre>\n\n<p>Then breaks down the following conjectures :</p>\n\n<pre><code>(\xacx v y) &amp; (\xacy v z) &amp; (\xacz v w) &amp; (\xacw v \xacx) &amp; \n(x v \xacy) &amp; (y v \xacz) &amp; (z v \xacw) &amp; (w v x)\n</code></pre>\n\n<p>is converted to an implcation graph.</p>\n\n<p>Heres my attempt:</p>\n\n<pre><code> (\xacx v y) = (\xacy--&gt;x)\n\n          = (\xacx--&gt;y)\n</code></pre>\n\n<p>but this cannot be right, as they have diffrent truth tables:</p>\n\n<pre><code>(\xacy--&gt;x)\n</code></pre>\n\n<p>1 0 <strong>0</strong> 0</p>\n\n<p>1 0   <strong>1</strong>  1</p>\n\n<p>0 1   <strong>1</strong>   0</p>\n\n<p>0 1   <strong>1</strong>   1</p>\n\n<pre><code>(\xac x--&gt;y)\n</code></pre>\n\n<p>1 0 <strong>0</strong> 0</p>\n\n<p>0 1 <strong>1</strong> 1</p>\n\n<p>1 0 <strong>0</strong> 0</p>\n\n<p>0 1 <strong>1</strong> 1</p>\n\n<p>I understand once you have the conjectures converted to implication, how to construct the implication graph and find out if its not satisfiable (bad loops).</p>\n\n<p>Could someone please explain clearly how to break down the conjectures to implications?</p>\n', 'ViewCount': '219', 'Title': 'Converting a 2-SAT formula into an implication graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-21T12:57:30.320', 'LastEditDate': '2013-10-18T21:04:10.513', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16200', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<complexity-theory><satisfiability>', 'CreationDate': '2013-10-17T14:06:14.303', 'Id': '16159'},6949:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am trying to convert the following 2-sat clauses to implications and then draw the implication graph.</p>\n\n<p>The clauses are: <code>{\xacxvy}, {\xacyvz}, {\xaczvw} ,{\xacwvu},{\xacuv\xacx},{xvw},{\xacwvx}</code></p>\n\n<p>I converted the boolean literals into implications so I could construct the implication graph:</p>\n\n<p><code>{\xacxvy}</code>: I have <code>x--&gt;y</code> and <code>\xacx --&gt;\xacy</code></p>\n\n<p><code>{\xacyvz}</code> : I have <code>y--&gt;z</code> and <code>\xacy--&gt;\xacz</code></p>\n\n<p><code>{\xaczvw}</code> : I have <code>z--&gt;w</code> and <code>\xacz--&gt;\xacw</code></p>\n\n<p><code>{\xacwvu}</code> : I have <code>w--&gt;u</code> and <code>\xacw---&gt;\xacu</code></p>\n\n<p><code>{\xacuv\xacx}</code> : I have <code>u--&gt;\xacx</code> and <code>\xacx--&gt;\xacu</code> </p>\n\n<p><code>{xvw}</code> : I have <code>\xacx--&gt;w</code> and <code>\xacw--&gt;x</code></p>\n\n<p><code>{\xacwvx}</code> : I have <code>w--&gt;x</code> and <code>\xacw--&gt;\xacx</code></p>\n\n<p>Am I doing this right? If so, I have constructed this implication graph to prove it is not satisfiable.</p>\n\n<p><img src="http://i.stack.imgur.com/tdXrm.png" alt="enter image description here"></p>\n\n<p>I would argue that these literals are not satisfiable because of the infinite loops you can have from \xacw \xacx \xacy \xacz \xacw and w x y z w. Is this a sufficient enough explanation?</p>\n\n<p>Thanks in advance!</p>\n', 'ViewCount': '190', 'Title': 'Drawing an implication graph for 2-SAT clauses', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-22T10:01:51.437', 'LastEditDate': '2013-10-22T10:01:51.437', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '16318', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<complexity-theory><logic><satisfiability>', 'CreationDate': '2013-10-21T18:35:42.693', 'Id': '16311'},6950:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '111', 'Title': 'Complexity of deciding the satisfiability of a quasi-monotone CNF formula', 'LastEditDate': '2013-11-01T22:52:30.737', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10228', 'FavoriteCount': '2', 'Body': '<p>A <em>quasi-monotone CNF formula</em> is a formula where each variable appears at most once as a positive literal (and any number of times as a negative literal). </p>\n\n<p>What is the complexity of deciding its satisfiability?</p>\n', 'Tags': '<complexity-theory><np-complete><satisfiability><decision-problem>', 'LastEditorUserId': '10228', 'LastActivityDate': '2013-11-01T22:52:30.737', 'CommentCount': '0', 'AcceptedAnswerId': '16492', 'CreationDate': '2013-10-28T00:04:09.943', 'Id': '16483'},6951:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The TWICE-3SAT is defined as \n$$TWICE-3SAT=\\{(\\varphi) | \\varphi \\text{ has at least two different satisfying assignments } \\}$$ \nHow do we prove it is in NP-complete?</p>\n', 'ViewCount': '134', 'ClosedDate': '2013-11-11T13:48:09.013', 'Title': 'Proving TWICE-3SAT is NP-complete', 'LastActivityDate': '2013-10-28T14:15:23.030', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'CreationDate': '2013-10-28T10:45:48.040', 'Id': '16493'},6952:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $\\phi$ be a 3-CNF formula over variables $x_1,x_2,\\ldots,x_n$. Every variable $x_i$, $i \\in [n]$, occurs equally many times as a positive literal and as a negative literal in $\\phi$. </p>\n\n<p>Is it NP-complete to decide the satisfiability of such a formula? Assuming it is, I would be interested in knowing if it has a special name. Has it perhaps also been investigated somewhere?</p>\n', 'ViewCount': '182', 'Title': '3-SAT where variables occur equally many times as a positive literal and as a negative literal', 'LastActivityDate': '2013-11-06T11:50:13.120', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16765', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<complexity-theory><np-complete><satisfiability><decision-problem>', 'CreationDate': '2013-11-03T14:27:40.600', 'Id': '16672'},6953:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '82', 'Title': 'Is MIN or MAX-True-2-XOR-SAT NP-hard?', 'LastEditDate': '2013-11-04T19:22:00.093', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '1', 'Body': '<p><strong>Is there a proof or reference that $\\left\\{\\text{MAX},\\text{MIN}\\right\\}\\text{-True-2-XOR-SAT}$ is $NP$-hard, or that it (the decision version) is in $P$?</strong></p>\n\n<p>Let:</p>\n\n<p>$$\\Phi\\left(\\mathbf x\\right)={\\huge\\wedge}_{i}^{n}C_i,\\\\\n\\forall_{C_i} \\left.C_i=(p \\oplus q)\\right|_{\\left(p\\in \\mathbf x \\vee\\neg p\\in\\mathbf x\\right),\\left(q\\in \\mathbf x \\vee\\neg q\\in\\mathbf x\\right)}\n$$</p>\n\n<p>The $\\text{2-XOR-SAT}$ problem is to find a satisfying assignment of $\\mathbf x$ that would make $\\Phi\\left(\\mathbf x\\right)=T$. This is in $P$, as it can be encoded in a set of linear equations mod $2$.</p>\n\n<p>The $\\left\\{\\text{MAX},\\text{MIN}\\right\\}\\text{-True-2-XOR-SAT}$ problems are to maximize or minimize the number of true values in $\\mathbf x$, respectively, subject to the constraint that $\\Phi\\left(\\mathbf x\\right)=T$.</p>\n', 'Tags': '<complexity-theory><np-hard><satisfiability>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-04T19:22:00.093', 'CommentCount': '5', 'AcceptedAnswerId': '16689', 'CreationDate': '2013-11-03T23:08:22.110', 'Id': '16682'},6954:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What is the complexity of MIN-2-XOR-SAT and MAX_2-XOR-SAT?  Are they in P?  Are they NP-hard?</p>\n\n<p>To formalize this more precisely, let</p>\n\n<p>$$\\Phi\\left(\\mathbf x\\right)={\\huge\\wedge}_{i}^{n}C_i,$$</p>\n\n<p>where $\\mathbf{x} = (x_1,\\dots,x_m)$ and each clause $C_i$ is of the form $(x_i \\oplus x_j)$ or $(x_i \\oplus \\neg x_j)$.</p>\n\n<p>The $\\text{2-XOR-SAT}$ problem is to find an assignment to $\\mathbf{x}$ that satisfies $\\Phi$.  This problem is in $P$, as it corresponds to a system of linear equations mod $2$.</p>\n\n<p>The $\\text{MAX-2-XOR-SAT}$ problem is to find an assignment to $\\mathbf{x}$ that maximizes the number of clauses that are satisfied.  The $\\text{MIN-2-XOR-SAT}$ problem is to find an assignment to $\\mathbf{x}$ that minimizes the number of clauses that are satisfied.  What are the complexities of these problems?</p>\n\n<p>Inspired by <a href="http://cs.stackexchange.com/q/16682/755">Is MIN or MAX-True-2-XOR-SAT NP-hard?</a></p>\n', 'ViewCount': '108', 'Title': 'MIN-2-XOR-SAT and MAX-2-XOR-SAT: are they NP-hard?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-04T19:19:55.910', 'LastEditDate': '2013-11-04T19:19:55.910', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<complexity-theory><optimization><np-hard><satisfiability>', 'CreationDate': '2013-11-04T03:28:01.333', 'Id': '16691'},6955:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is well known that any CNF formula can be transform in polynomial time into a 3-CNF formula  by using new variables (<a href="http://en.wikipedia.org/wiki/Boolean_satisfiability_problem#3-satisfiability" rel="nofollow">see here</a>). If using new variables is not allowed, it is not always possible (take for instance the single clause formula : $(x_1 \\lor x_2 \\lor x_3 \\lor x_4)$). </p>\n\n<p>Let define the (SAT to 3-SAT) problem : Given $F$, a CNF formula. Is it possible to transform $F$ into an equivalent 3-CNF defined <em>on the same variables</em> as $F$ ? - where "equivalent" means with the same set of models.</p>\n\n<p>What is the complexity of this problem ?</p>\n\n<p><strong>Edit</strong> : It has been shown <a href="http://cstheory.stackexchange.com/questions/19821/transform-a-cnf-into-an-equivalent-3-cnf-defined-on-the-same-variables">on cstheory</a> that the problem is co-NP hard.</p>\n', 'ViewCount': '184', 'Title': 'Complexity of (SAT to 3-SAT) Problem?', 'LastEditorUserId': '10228', 'LastActivityDate': '2013-12-24T00:47:22.790', 'LastEditDate': '2013-12-23T22:53:00.603', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '10228', 'Tags': '<complexity-theory><satisfiability><decision-problem><complexity-classes>', 'CreationDate': '2013-11-05T15:46:40.127', 'FavoriteCount': '1', 'Id': '16741'},6956:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm studing P and NP complexity classes. I like know, why is SAT not in P? Is it because I can not determine if any Boolean expression is satisfiable?</p>\n", 'ViewCount': '54', 'ClosedDate': '2013-11-08T13:17:52.880', 'Title': 'Why is SAT not in P?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T13:16:31.463', 'LastEditDate': '2013-11-08T13:16:31.463', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11241', 'Tags': '<complexity-theory><satisfiability><p-vs-np>', 'CreationDate': '2013-11-07T23:50:44.720', 'Id': '16807'},6957:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Consider the following 3-SAT variant defined over the variables $x_1,\\ldots,x_n$. In the $k$P$k$N-3SAT problem each variable $x_j$, $j \\in [n]$, occurs exactly $k$ times as a positive literal in $\\phi$, and exactly $k$ times as a negative literal in $\\phi$, where $\\phi$\xa0is a 3-CNF formula. The problem is then to decide if such a formula has a satisfying assignment.</p>\n\n<blockquote>\n  <p>Is the $k$P$k$N-3SAT problem NP-complete?</p>\n</blockquote>\n\n<p>In the $m$P$n$N-SAT problem each positive literal occurs exactly $m$ times in $\\phi$, and each negative literal occurs exactly $m$ times in $\\phi$, where $\\phi$ is a CNF formula. It was shown in [1] that $2$P$1$N-SAT is NP-complete. This hints that the $k$P$k$N-3SAT problem is hard as well. </p>\n\n<p>The $1$P$1$N-SAT is apparently easy, see a related question and answer <a href="http://cs.stackexchange.com/a/16765/472">here</a>. Is $k$P$k$N-3SAT perhaps hard already for $k \\geq 2$?</p>\n\n<hr>\n\n<p>[1] Yoshinaka, Ryo. "Higher-order matching in the linear lambda calculus in the absence of constants is NP-complete." Term Rewriting and Applications. Springer Berlin Heidelberg, 2005. 235-249.</p>\n', 'ViewCount': '138', 'Title': 'Is the $k$P$k$N-3SAT problem NP-complete?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-13T13:37:40.000', 'LastEditDate': '2013-11-08T11:27:14.390', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16822', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<complexity-theory><np-complete><satisfiability><decision-problem>', 'CreationDate': '2013-11-08T11:13:22.193', 'Id': '16817'},6958:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>When using <a href="http://en.wikipedia.org/wiki/Resolution_%28logic%29" rel="nofollow">resolution</a>, if the empty set {\xd8} is derived from a formula like {\xacx,\xacy} {x,y}, does that mean the formula is unsatisfiable? </p>\n\n<p>If this is the case, why <strong>is</strong> <code>{x,y},{\xacx,\xacy},{x,\xacy}</code> satisfiable, and </p>\n\n<p><code>{x},{\xacx},{x,y,z,w}</code> <strong>is not</strong> satisfiable? </p>\n', 'ViewCount': '92', 'Title': 'Resolution and what it means to derive the empty set', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-31T07:53:18.520', 'LastEditDate': '2014-03-31T07:53:18.520', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<algorithms><logic><satisfiability><propositional-logic>', 'CreationDate': '2013-11-16T21:19:46.557', 'Id': '18083'},6959:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have been solving a "hard" boolean formula today and found a nice shortcut. So just wanted to share.</p>\n\n<p>When given the next formula how would you convert it to <a href="http://en.wikipedia.org/wiki/Conjunctive_normal_form" rel="nofollow">CNF</a>?</p>\n\n<blockquote>\n  <p>$\\lnot(x \\oplus y \\oplus z\\oplus a)$</p>\n</blockquote>\n', 'ViewCount': '66', 'Title': 'Boolean algebra fast CNF convertion', 'LastActivityDate': '2013-11-20T08:17:32.873', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<satisfiability>', 'CreationDate': '2013-11-20T08:17:32.873', 'Id': '18190'},6960:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '128', 'Title': 'Formulas for which any equivalent CNF formula has exponential length', 'LastEditDate': '2013-11-27T12:25:59.180', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10572', 'FavoriteCount': '1', 'Body': '<p>I read a claim that</p>\n\n<blockquote>\n  <p>there are formulas for which any equivalent CNF has exponential length.</p>\n</blockquote>\n\n<p>Can you show me an example for such a boolean formula? I have been trying to build it myself and failed.</p>\n', 'Tags': '<satisfiability>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-06T20:37:40.223', 'CommentCount': '1', 'AcceptedAnswerId': '18416', 'CreationDate': '2013-11-27T07:09:14.343', 'Id': '18409'},6961:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>All of the solutions for <a href="http://en.wikipedia.org/wiki/Zebra_Puzzle" rel="nofollow">the zebra puzzle</a> have a variable for each of the properties and a domain with the possible values. For instance A for Nationalities, B for pets, ...</p>\n\n<p>Ai with i = 1..5 and the domain for example {Dutch, Spanish, Italian, French, English}</p>\n\n<p>As I\'ve seen in the n-queens puzzle, there can always be multiple representations for a constraint problem. What could be alternative representations for the zebra puzzle?</p>\n\n<p>For example, I was thinking about following representation:</p>\n\n<ul>\n<li>HouseOne indices 1..4 with domain {1,2,3,4,5}</li>\n<li>HouseTwo indices 1..4 with domain {1,2,3,4,5}</li>\n<li>HouseThree indices 1..4 with domain {1,2,3,4,5}</li>\n<li>HouseFour indices 1..4 with domain {1,2,3,4,5}</li>\n<li>HouseFive indices 1..4 with domain {1,2,3,4,5}</li>\n</ul>\n\n<p>Could this work?</p>\n', 'ViewCount': '65', 'Title': 'Alternative representations for the zebra puzzle?', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-04T00:14:06.723', 'LastEditDate': '2013-12-04T00:14:06.723', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10575', 'Tags': '<logic><satisfiability><constraint-programming>', 'CreationDate': '2013-12-03T16:09:56.193', 'Id': '18574'},6962:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On one hand, <a href="http://en.wikipedia.org/wiki/Horn-satisfiability" rel="nofollow">Horn-SAT</a> is known to be tractable in linear time - where Horn-SAT is the problem of deciding whether a given set of propositional Horn clauses (with at most one positive literal) is satisfiable or not.\nOn the other hand, Double-SAT is NP-complete (see this post : <a href="http://cs.stackexchange.com/questions/6371/proving-double-sat-is-np-complete">Proving Double-SAT is NP-complete</a>) - where Double-SAT is the problem of deciding whether a given set of propositionnal clauses has at least two models.</p>\n\n<p>Let Double-Horn-SAT be the problem of deciding whether a given set of propositional Horn clauses has at least two models.</p>\n\n<p>What is the complexity of Double-Horn-SAT ?</p>\n', 'ViewCount': '41', 'Title': 'Complexity of Double-Horn-SAT?', 'LastActivityDate': '2013-12-03T22:13:38.727', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '18585', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10228', 'Tags': '<complexity-theory><np-complete><satisfiability><complexity-classes>', 'CreationDate': '2013-12-03T20:28:43.277', 'Id': '18581'},6963:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is known that <a href="http://en.wikipedia.org/wiki/3-satisfiability#3-satisfiability" rel="nofollow">3-SAT</a> belong to - <a href="http://en.wikipedia.org/wiki/NP-complete" rel="nofollow">NP-Complete</a> complexity problems, while <a href="http://en.wikipedia.org/wiki/2-satisfiability" rel="nofollow">2-SAT</a> belong to <a href="http://en.wikipedia.org/wiki/P_%28complexity%29" rel="nofollow">P</a> as there is known polynomial solution to it.</p>\n\n<p>So you can state that there is no such reduction from <strong>3-SAT</strong> to <strong>2-SAT</strong> unless $P=NP$.</p>\n\n<p>I am looking for strong proof for this state, regardless NP belong to P or not.</p>\n', 'ViewCount': '381', 'Title': '3-sat to 2-sat reduction', 'LastActivityDate': '2013-12-05T19:52:06.330', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-3', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<complexity-theory><np-complete><satisfiability><np>', 'CreationDate': '2013-12-05T14:55:37.870', 'FavoriteCount': '3', 'Id': '18643'},6964:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to reduce 3-sat to 2-sat. I found an assignment that make 3-ast satisfy, so it is satisfy, and same assignment is satisfy my 2-sat, so my reduction is valid.</p>\n\n<p>How ever there is more than one assignment that satisfy my 3-sat. And it happens to be that before I found an assignment that satisfy both of my formulas I found assignment that satisfy 3-sat but not 2-sat.</p>\n\n<p>Does it make my reduction invalid if I can find assignment that makes 3-sat satisfied and 2-sat not even if there is an assignment that satisfy them both? Or in other words does 3-sat have to be equal-satisfiable to 2-sat to make this reduction valid?</p>\n\n<p>Also consider this scenario, where there are exponential number of assignments that satisfy only one side, and there is just one assignment that satisfy both of the sides.</p>\n', 'ViewCount': '78', 'Title': 'Reduction validity', 'LastActivityDate': '2013-12-07T01:58:48.280', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '-4', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<satisfiability><3-sat>', 'CreationDate': '2013-12-06T11:05:19.020', 'Id': '18677'},6965:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '61', 'Title': 'CNF SAT conversions', 'LastEditDate': '2013-12-10T00:58:52.430', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8508', 'FavoriteCount': '1', 'Body': '<p>I am interested in reductions from 3-CNF boolean expressions to similar restricted forms. For example, I am interested in knowing how to reduce a 3-CNF formula to another 3-CNF formula where each variable appears in at most $b$ clauses. I observed this is used in MAX-SAT so I am interested in knowing such reductions. Is there a paper/book that contains descriptions of such forms and their properties?</p>\n', 'Tags': '<complexity-theory><reductions><satisfiability>', 'LastEditorUserId': '8508', 'LastActivityDate': '2013-12-10T01:07:49.217', 'CommentCount': '0', 'AcceptedAnswerId': '18805', 'CreationDate': '2013-12-09T22:05:24.017', 'Id': '18793'},6966:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Recently, I am reading papers about <em>dichotomy</em>. I do not understant what condition can be called as a <em>dichotomy</em>? What is the meaning of "a question is either in <strong>P</strong> or in <strong>NP</strong>-<em>complete</em>"? (assume <strong>P</strong> $\\neq$ <strong>NP</strong>)</p>\n\n<p>For example, I\'ve known the Schaefer\'s dichotomy theorem, in which a dichotomy about "whether a class of SAT is in <strong>P</strong>" is given. In this theorem, the dichotomy contains six conditions, one of them is "2-SAT". </p>\n\n<p>So my question is that, whether "2-SAT" itself can be called as a <em>dichotomy</em> or a trivial <em>dichotomy</em>, because 2-SAT is in <strong>P</strong> but 3-SAT is <strong>NP</strong>-<em>complete</em>? In another words, I wonder that "if a special class of an <strong>NP</strong>-<em>complete</em> problem is in <strong>P</strong>, then this class is a dichotomy? or a trivial dichotomy?"</p>\n', 'ViewCount': '123', 'Title': 'What is a dichotomy? Whether 2-SAT itself is a dichotomy of SAT?', 'LastActivityDate': '2013-12-11T11:02:42.043', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '18868', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12018', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'CreationDate': '2013-12-11T07:52:17.700', 'Id': '18865'},6967:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have little background with SAT sovers and theoretical computer science.</p>\n\n<p>How can I describe the complexity of calculating all models of a propositional formula versus just the usual SAT problem of finding just one model?</p>\n\n<p>I am writing a paper, in an area where finding a single of a model of a type of propositional formula is considered "easy", but for my reasearch I need to calculated all models. (I am using Picosat that can calculate all models of a logic formula.) Is there a way to describe how "hard" or "complex" finding all models is compared to finding a single model?</p>\n', 'ViewCount': '20', 'Title': 'Complexity of calculating a single model versus all models of a propositional formula with a SAT solver', 'LastActivityDate': '2013-12-12T09:02:45.050', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18918', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1829', 'Tags': '<complexity-theory><np-complete><satisfiability><sat>', 'CreationDate': '2013-12-12T07:19:46.190', 'FavoriteCount': '1', 'Id': '18912'},6968:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the 3-SAT problem where the formula is in conjunctive normal form and we restrict the Boolean formulas such that the number of clauses in the formula is equal to the number of variables. Is this problem still NP-hard?</p>\n\n<p>For example, this formula has $3$ variables and has $3$ clauses $(\\lnot x_1 \\vee \\lnot x_2 \\vee \\lnot x_3 ) \\wedge (\\lnot x_1 \\vee \\lnot x_3) \\wedge (\\lnot x_2 \\vee \\lnot x_3)$,</p>\n\n<p>and the following formula has three variables but has only two clauses $(\\lnot x_1 \\vee \\lnot x_2 \\vee \\lnot x_3  ) \\wedge (\\lnot x_2 \\vee \\lnot x_3)$.</p>\n', 'ViewCount': '96', 'Title': '3-SAT problem with number of clauses equal to number of variables', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-09T09:28:49.803', 'LastEditDate': '2014-01-08T19:18:32.590', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19584', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12321', 'Tags': '<complexity-theory><np-hard><satisfiability>', 'CreationDate': '2014-01-08T16:54:27.993', 'Id': '19582'},6969:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is there a lower bound on the running time for solving 3-SAT if P = NP.  For instance, is it known that 3-SAT can't be solved in linear time?  What about quadratic?</p>\n", 'ViewCount': '112', 'Title': 'Lower bound on running time for solving 3-SAT if P = NP', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T13:38:40.363', 'LastEditDate': '2014-01-15T23:06:52.207', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19759', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8526', 'Tags': '<complexity-theory><satisfiability><lower-bounds>', 'CreationDate': '2014-01-15T21:59:30.103', 'Id': '19756'},6970:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to wrap my head around an NP-completeness proof which seem to revolve around SAT/3CNF-SAT.</p>\n\n<p>Maybe it's the late hour but I'm afraid I can't think of a 3CNF formula that cannot be satisfied (I'm probably missing something obvious).</p>\n\n<p>Can you give me an example for such formula?</p>\n", 'ViewCount': '76', 'Title': "What's an example of an unsatisfiable 3-CNF formula?", 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-30T17:39:23.717', 'LastEditDate': '2014-01-30T17:33:53.110', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '20118', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11171', 'Tags': '<logic><satisfiability><3-sat>', 'CreationDate': '2014-01-30T16:18:49.413', 'Id': '20117'},6971:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've seen a lot of text concerning the first NP-Complete problem, Boolean Satisfiability. I guess I'm confused concerning the language. </p>\n\n<p>It sounds to me as though the problem could be difficult to compute (hence the NP-complete), however it still might be satisfiable. As in, there <em>exists</em> a satisfying mapping of literals. We can't necessarily compute it easily, but it's out there.</p>\n\n<p>In fact, I would guess that the two adjectives really have no relation to each other. But, when working with problems, I am often asked to see whether a set of clauses is satisfiable. Does that mean, <em>Can we compute a satisfying mapping?</em> And by extension, does NP-complete imply that a given CNF setup is unsatisfiable?</p>\n", 'ViewCount': '103', 'Title': 'Does NP-Complete imply non-satisfiability?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T10:30:36.100', 'LastEditDate': '2014-02-21T10:30:36.100', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21874', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<complexity-theory><terminology><np-complete><satisfiability>', 'CreationDate': '2014-02-21T01:53:02.537', 'Id': '21871'},6972:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I hope I named this CNF Boolean sentence the correct way. The way I see it, a 2P2N is where each literal appears twice (or at most twice, but we can say twice without loss of generality). </p>\n\n<p>I am trying to prove it is Satisfiable. How do I do this? Do I need to try to reduce it to 3-SAT (might need some help doing that as well). Or is there another method of proving satisfiability?</p>\n', 'ViewCount': '62', 'Title': 'Proving 2P2N SAT is NP-Complete', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T20:38:37.950', 'LastEditDate': '2014-02-21T11:52:24.113', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '21907', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'CreationDate': '2014-02-21T02:34:05.097', 'Id': '21873'},6973:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Reading this <a href="http://classes.soe.ucsc.edu/cmps102/Spring10/lect/17/SAT-3SAT-and-other-red.pdf" rel="nofollow">http://classes.soe.ucsc.edu/cmps102/Spring10/lect/17/SAT-3SAT-and-other-red.pdf</a>, I came to know that reducing a clause $C_i$ from a $SAT$ instance containing more than 3 literals to a $3-SAT$ instance is done this way,</p>\n\n<p>Suppose $C_1$ is $\\{x_1, x_2, x_3, x_4\\}$. It\'s equivalent representation in 3-literal clauses is,</p>\n\n<p>$C_{3-SAT} = \\{\\{x_1, x_2, y_1\\},\\{\\bar{y_1}, x_3,x_4\\}\\}$</p>\n\n<p>The issue lies here. Assume for $C_1$, all the literals are $False$ except for $x_2$.\nFor $C_{3-SAT}$, the first clause would indeed be $True$, but the boolean value for the second clause depends on the choice of $y_1$. What if we chose $y_1 = True$? then, $C_{3-SAT}$ will be $False$, yet $C_1$ is $True$, realizing a false reduction.</p>\n', 'ViewCount': '185', 'Title': 'Issue understanding the reduction of SAT to 3-SAT in poly time', 'LastActivityDate': '2014-02-26T13:45:34.337', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22053', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<algorithms><np-complete><satisfiability><3-sat><boolean-algebra>', 'CreationDate': '2014-02-26T13:28:05.573', 'FavoriteCount': '1', 'Id': '22052'},6974:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I assume the size of an instance of the SAT problem is measured by its number of (Boolean) variables.  What is total number of instances of SAT problems of size N?</p>\n\n<p>I guess that amounts to counting the number of "distinct" formulas that can be formed by N boolean variables, using a normal form such as CNF or DNF.  Is this number finite?  If not, countable?</p>\n', 'ViewCount': '75', 'Title': 'Number of instances of SAT (boolean satisfiability) problems of size N?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-19T08:24:55.797', 'LastEditDate': '2014-03-19T08:24:55.797', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '5', 'OwnerDisplayName': 'Yan King Yin', 'PostTypeId': '1', 'Tags': '<logic><satisfiability>', 'CreationDate': '2014-02-26T06:58:11.250', 'FavoriteCount': '1', 'Id': '22054'},6975:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>The GSAT (Greedy Satisfiability) algorithm can be used to find a solution to a search problem encoded in CNF. I\'m aware that since GSAT is greedy, it is incomplete (which means there would be cases where a solution might exist, but GSAT cannot find it). From the following link, I learned that this can happen when flipping variables greedily traps us in a cycle such as I \u2192 I\' \u2192 I\'\' \u2192 I. </p>\n\n<p><a href="http://www.dis.uniroma1.it/~liberato/ar/incomplete/incomplete.html" rel="nofollow">http://www.dis.uniroma1.it/~liberato/ar/incomplete/incomplete.html</a></p>\n\n<p>I\'ve been trying quite hard to come up with an actual instance that can show this, but have not been able to (and could not find examples elsewhere). Any help would be much appreciated. Thanks :)</p>\n\n<p>P.S. I\'m not talking about "hard" k-SAT problems in which the ratio of variables to clauses approaches 4.3. I\'m just looking for a simple example, possibly involving the least number of variables and/or clauses required.</p>\n', 'ViewCount': '76', 'Title': 'GSAT incompleteness example', 'LastActivityDate': '2014-02-27T05:59:46.950', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15094', 'Tags': '<algorithms><satisfiability><greedy-algorithms><3-sat>', 'CreationDate': '2014-02-27T05:07:36.670', 'Id': '22079'},6976:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to prove that a problem $P_1$ is NP-complete. Let say that I want to do a reduction from SAT problem.</p>\n\n<p>If the instance of problem $P_1$ depends on $M$ and $N$, can I specify the sturcture of the instance of the SAT problem? </p>\n\n<p>More precisely, can I say that, for example, the instance of SAT problem is composed of $M\\times N +1$ clauses and every clause has $M+N$ literals ? </p>\n\n<p>Based on this structure of the instance of SAT problem, I construct an instance of $P_1$. Is this proof correct?</p>\n', 'ViewCount': '87', 'Title': 'Is this NP-completeness proof correct?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-04T19:45:18.393', 'LastEditDate': '2014-03-04T19:45:18.393', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22105', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12683', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'CreationDate': '2014-02-27T17:04:17.090', 'Id': '22097'},6977:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '90', 'Title': 'Hardness of mixed 3-SAT and 2-SAT formula', 'LastEditDate': '2014-03-04T09:12:17.513', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Paramar', 'PostTypeId': '1', 'OwnerUserId': '12201', 'Body': '<p>It is well known that 3-SAT is $\\sf NP$-complete , but 2-SAT is in $\\sf P$. Let there be a formula with $n-1$ clauses with 2 literals each and only 1 clause with 3 literals.    </p>\n\n<p>We can solve this case in polynomial time, separating and solving in a brute force manner the 3 literal clause and then for each satisfying assignment try to solve the rest $n-1$ 2-literal clauses. This method can work till $O(\\log n)$ clauses with 3 literals. \nIf we consider a more general case with e.g $\\frac{n}{2}$ clauses with 2 literals and  $\\frac{n}{2}$ clauses with 3 literals does the problem remain $\\sf NP$-complete? </p>\n\n<p>It is a bit confusing because we have a subproblem approximately the same size, implying it is difficult and another one roughly the same size implying it is easy. Is there probably a better method than the one I proposed?</p>\n', 'Tags': '<complexity-theory><np-complete><satisfiability>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-04T09:12:17.513', 'CommentCount': '0', 'AcceptedAnswerId': '22235', 'CreationDate': '2014-03-03T16:23:28.160', 'Id': '22233'},6978:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read in these two papers <a href="http://www.ccs.neu.edu/home/lieber/courses/csg260/f06/materials/papers/max-sat/p216-schaefer.pdf" rel="nofollow">http://www.ccs.neu.edu/home/lieber/courses/csg260/f06/materials/papers/max-sat/p216-schaefer.pdf</a> and <a href="http://people.csail.mit.edu/madhu/papers/noneed/fullbook.ps" rel="nofollow">http://people.csail.mit.edu/madhu/papers/noneed/fullbook.ps</a> that if we have a boolean formula that is $0-valid$ then (of course) SAT problem is in $\\mathcal{P}$ but finding a solution with maximum true literals is $\\mathcal{NP}-$hard. </p>\n\n<p>N.B. As defined in the previous papers, a $0-valid$ boolean formula $f$ is a boolean formula $f: \\{0, 1\\}^n\\rightarrow\\{0, 1\\}$ that satisfies $f(0, \\dotsc, 0)=1$.</p>\n\n<p>My question is:</p>\n\n<p>Can I represent a general $0-valid$ boolean formula on the variables $x=\\left(x_1, \\dotsc, x_n\\right)$ by the following one:</p>\n\n<p>$f(x)=\\bigwedge\\limits_{i=1}^{L}\\bigvee\\limits_{i\\in\\mathcal{S}_l}\\neg\\;x_i$?</p>\n\n<p>Where $L$ is the number of clauses and $\\mathcal{S}_l\\;\\forall\\;l\\in\\{1,\\dotsc, L\\}$ is a subset of $\\{1, \\dotsc, n\\}$.</p>\n', 'ViewCount': '44', 'Title': 'How to represent a 0-valid boolean formula?', 'LastEditorUserId': '12683', 'LastActivityDate': '2014-03-06T01:26:33.697', 'LastEditDate': '2014-03-05T18:34:01.957', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '22308', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12683', 'Tags': '<complexity-theory><satisfiability>', 'CreationDate': '2014-03-05T17:06:49.690', 'Id': '22307'},6979:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can any Constraint satisfaction problem be converted to an instance of Satisfiability? I have a CSP and i know its NP hard to solve it, but i would like to convert to an instance of k-SAT, but im not sure of any algorithm for transformation</p>\n', 'ViewCount': '39', 'Title': 'transformation of constraint satisfaction to SAT', 'LastActivityDate': '2014-03-28T03:26:26.230', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16220', 'Tags': '<satisfiability><constraint-programming>', 'CreationDate': '2014-03-28T02:09:37.007', 'Id': '23157'},6980:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '69', 'Title': 'Why is SAT in NP?', 'LastEditDate': '2014-04-02T20:50:53.243', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14436', 'FavoriteCount': '1', 'Body': "<p>I know that CNF SAT is in NP (and also NP-complete), because SAT is in NP and NP-complete. But what I don't understand is why? Is there anyone that can explain this?</p>\n", 'Tags': '<complexity-theory><satisfiability><decision-problem><np>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T20:50:53.243', 'CommentCount': '1', 'AcceptedAnswerId': '23362', 'CreationDate': '2014-04-02T17:25:08.017', 'Id': '23353'},6981:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to prove that 3SAT is polynome time reducable to CNF-SAT, but I don't know how to do this. A formula F is in 3SAT iff f(F) is in KNFSAT, but since 3SAT is a part of KNFSAT, every formula that is in 3SAT will automatically be in CNF-SAT. Is my conclusion correct? And how do I actually show this in a correct manner? </p>\n", 'ViewCount': '26', 'Title': '3SAT to CNF-SAT reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T14:09:36.477', 'LastEditDate': '2014-04-07T14:09:36.477', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23514', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<complexity-theory><reductions><satisfiability><3-sat>', 'CreationDate': '2014-04-07T13:16:48.117', 'Id': '23513'},6982:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '52', 'Title': 'Application of Combinatorics, Logic and computability theory in physical science: Tiling of Wang Tile with proportionality', 'LastEditDate': '2014-04-11T12:23:29.707', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14553', 'FavoriteCount': '1', 'Body': '<p>The original problem of Domino Tiling and Wang Tile has great theoretical interest on computability theory... However, the great emerging problem on application of Wang Tile in material science and physics requires the tiling to satisfy one more condition:</p>\n\n<p>The tiling should satisfy some proportionality, say, Tile 1 should appear with frequency 1/16, Tile 2 with frequency 9/16, Tile 3 with 6/16, Tile 4 with frequency 0...</p>\n\n<p>The most important decision problem is the following:\nCould a given set of Tile tile a grid of size NxN satisfying the frequency constraint within a error of +-epsilon.</p>\n\n<p>For example: could the set {Tile 1, Tile 2, Tile 3, Tile 4} tile the NxN grid with frequency 1/16+-0.01, 9/16+-0.01, 6/16+-0.01, 0+-0.01 respectively....</p>\n\n<p>From one of my previous post:</p>\n\n<p><a href="http://mathoverflow.net/questions/161731/practical-algorithms-for-np-complete-problems">Algorithms for NP complete problem</a></p>\n\n<p>I realize the decision problem of tiling without such constraint could be modeled by SAT... With this constraint the problem becomes ridiculously difficult and I eagerly seek for solutions towards this finite decidable problem.... (we could forget epsilon for a moment if the problem with epsilon is too hard)...</p>\n\n<p>So here is the question: how do we model this problem in MIP or SAT or any other optimization algorithm?</p>\n\n<p>For more detail why this problem is practical in material science and physics, see my previous post:</p>\n\n<p><a href="http://mathoverflow.net/questions/147374/coloring-in-lattice">coloring in lattice</a></p>\n\n<p><a href="http://mathoverflow.net/questions/149565/reference-for-wang-tile">reference for wang tile</a></p>\n\n<p><a href="http://mathoverflow.net/questions/157239/computational-approach-deciding-whether-a-set-of-wang-tile-could-tile-the-space">Computational approach deciding whether a set of Wang Tile could tile the space up to some size</a></p>\n\n<p>P.S. this is a bounty question from mathoverflow without yet a applicable solution...</p>\n\n<p><a href="http://mathoverflow.net/questions/162248/application-of-combinatorics-logic-and-computability-theory-in-physical-science">Application of Combinatorics, Logic and computability theory in physical science: Tiling of Wang Tile with proportionality</a></p>\n', 'ClosedDate': '2014-04-11T06:41:13.197', 'Tags': '<complexity-theory><optimization><logic><satisfiability>', 'LastEditorUserId': '14553', 'LastActivityDate': '2014-04-11T12:23:29.707', 'CommentCount': '6', 'AcceptedAnswerId': '23664', 'CreationDate': '2014-04-10T23:23:56.653', 'Id': '23662'},6983:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to find reduction from 3-SAT to Max-2-SAT, so far no luck.<br>\nLet me first describe it.  </p>\n\n<blockquote>\n  <p><strong>3-SAT</strong>: Given a CNF formula $\\varphi$, where every clause in $\\varphi$ has <em>exactly</em> 3 literals in it, one should determine if there exist an assignment that satisfies it.  </p>\n  \n  <p><strong>Max-2-SAT</strong>: Given a CNF formula, where every clause in $\\phi$ has <em>exactly</em> 2 literals in it, and a positive number $k$, one should determine if there exist an assignment that satisfies <em>at least</em> $k$ clauses.</p>\n</blockquote>\n\n<p>Let me first show what I have tried so far.<br>\nGiven $\\varphi=\\wedge _{i=1}^{n}C_i$ where: $C_i=(l_{i_1}\\vee l_{i_2} \\vee l_{i_3})$,<br>\nI set: $\\phi=\\wedge _{j=1}^{3n}D_i$, where: $D_i=(l_{i_1}\\vee l_{i_2})\\wedge(l_{i_1}\\vee l_{i_3})\\wedge(l_{i_2}\\vee l_{i_3})$ and $k=2n$.<br>\nIt\'s quite easy to see that this will not work...<br>\nAlthough, if there exist an assignment which satisfies $\\varphi$ it means there exist an assignment that satisfies $k=2n$ clauses in $\\phi$, the second direction is not true.<br>\nI found several reductions online (such as <a href="http://www.stanford.edu/~rrwill/williams-max2sat-encyc.pdf" rel="nofollow">this</a>, for example), but none of them were useful since in my problem, each clause in $\\phi$ must have <strong>exactly</strong> two literals, where in the link above, the formula can also contain 1-length clause in it.</p>\n\n<p>I could really use some help here.</p>\n', 'ViewCount': '68', 'Title': '3-SAT to Max-2-SAT Reduction', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-13T23:39:21.800', 'LastEditDate': '2014-04-12T13:39:18.530', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<complexity-theory><reductions><np-hard><satisfiability>', 'CreationDate': '2014-04-12T11:58:23.407', 'FavoriteCount': '0', 'Id': '23702'},6984:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>While I was studying SAT problem and its different instances, in Algorithms for the Satisfiability (SAT) Problem: A Survey by J. Gu et. al <a href="http://www.dtic.mil/dtic/tr/fulltext/u2/a326042.pdf" rel="nofollow">PDF</a>, I came up with this variant (not mentioned there, but I though of it) and searched, but could not find anything useful.</p>\n\n<p>Consider this variant:</p>\n\n<blockquote>\n  <p>Suppose $f$ is a boolean function in $n$ boolean variables, but with this extra property, that $f$ is increasing. I have thought of $n$ boolean variables, $X_1, \\ldots, x_n$ as representation of subsets of a set with $n$ elements, and if some  subset like $X$ satisfies $f$, then all $Y$ s.t. $X \\subseteq Y$ satisfy $f$, too. <em>What I want is finding the <strong>collection</strong> of all minimal $X$ where $f$ satisfies each of them, but not any $Z$ where $Z \\subsetneq X$?</em></p>\n</blockquote>\n\n<p>Is this problem still hard?</p>\n\n<p>If I consider the $x_1, \\ldots, x_n$ as a number, then increasing property of $f$ helps solving it in polynomial time, just a binary search suffices! So, I made it a little bit harder.</p>\n\n<p>Any help, even offers of search terms is appreciated.</p>\n', 'ViewCount': '48', 'Title': 'How can I identify that a restricted variant of Boolean SAT remains hard or not?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-27T19:21:15.063', 'LastEditDate': '2014-04-27T13:42:27.983', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '24155', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4425', 'Tags': '<complexity-theory><np-hard><satisfiability>', 'CreationDate': '2014-04-27T04:42:23.223', 'Id': '24149'},6985:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Im trying to work out whether the following clause is satisfiable:</p>\n\n<pre><code>{x, y},{x,\xacy},{\xacx, y},{\xacx,\xacy},{x, z},{x,\xacz},{y, z},{y,\xacz}\n</code></pre>\n\n<p>My basic understanding is to work this out, you must give each literal a true or false assignment to work out if each clause is satisfiable so:</p>\n\n<p>x=1,\ny=1,\nz=1,</p>\n\n<pre><code>{1,1}, {x,0}, {0,1}, {0,0}, {1,1}, {1,0}, {1,1}, {1,0}\n</code></pre>\n\n<p>Therefore the clause <code>{x,y}</code> and <code>{x,z}</code> are satisfiable?  </p>\n\n<p>I also heard you can switch the statement so:</p>\n\n<p>x=1,\ny=0,\nz=1,</p>\n\n<p>This means <code>{x,y}</code> is not satisfiable. </p>\n\n<p>If we changed z to 0 as well <code>{x,z}</code> would not be satisfiable. What really confuses me here is when the truth assignments are changed, neither clauses are satisfiable. </p>\n\n<p>Where am I going wrong? </p>\n', 'ViewCount': '23', 'Title': 'Satisfiabilty 2-sat', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-05-03T08:58:56.843', 'LastEditDate': '2014-05-03T08:49:43.897', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<satisfiability>', 'CreationDate': '2014-05-03T06:14:31.377', 'Id': '24342'}