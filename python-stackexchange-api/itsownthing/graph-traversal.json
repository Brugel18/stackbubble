{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>When searching graphs, there are two easy algorithms: <strong>breadth-first</strong> and <strong>depth-first</strong> (Usually done by adding all adjactent graph nodes to a queue (breadth-first) or stack (depth-first)).</p>\n\n<p>Now, are there any advantages of one over another?</p>\n\n<p>The ones I could think of:</p>\n\n<ul>\n<li>If you expect your data to be pretty far down inside the graph, <em>depth-first</em> might find it earlier, as you are going down into the deeper parts of the graph very fast.</li>\n<li>Conversely, if you expect your data to be pretty far up in the graph, <em>breadth-first</em> might give the result earlier.</li>\n</ul>\n\n<p>Is there anything I have missed or does it mostly come down to personal preference?</p>\n', 'ViewCount': '10527', 'Title': 'Graph searching: Breadth-first vs. depth-first', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-24T23:35:26.743', 'LastEditDate': '2013-09-09T01:44:33.060', 'AnswerCount': '6', 'CommentCount': '1', 'Score': '31', 'PostTypeId': '1', 'OwnerUserId': '101', 'Tags': '<algorithms><graph-theory><search-algorithms><graph-traversal>', 'CreationDate': '2012-03-13T10:05:58.093', 'FavoriteCount': '14', 'Id': '298'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>How to improve the worst case scenario for a depth first search on an Euler graph, starting at some point and ending at that same point?</p>\n\n<p>I need to do the whole search but it is not fast enough for large amounts of data. I have tried <a href="https://en.wikipedia.org/wiki/Bidirectional_search" rel="nofollow">bidirectional search</a> but I can not keep the result numerically ordered. Therefore I wonder if there is any other good method to smooth the worst case scenario for the depth first search.</p>\n', 'ViewCount': '251', 'Title': 'Improve worst case time of depth first search on Euler graphs', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-20T20:09:11.067', 'LastEditDate': '2013-03-20T20:09:11.067', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '591', 'Tags': '<algorithms><graphs><graph-traversal><eulerian-paths>', 'CreationDate': '2012-03-21T16:04:53.030', 'Id': '615'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>For some graphs, DFS and BFS search algorithms process nodes in the exact same order provided that they both start at the same node. Two examples are graphs that are paths and graphs that are star-shaped (trees of depth $1$ with an arbitrary number of children). Is there some way for categorizing graphs that satisfy this property?</p>\n', 'ViewCount': '478', 'Title': 'Graphs that cause DFS and BFS to process nodes in the exact same order', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-28T11:36:04.370', 'LastEditDate': '2012-09-24T11:25:55.257', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<algorithms><graphs><graph-traversal>', 'CreationDate': '2012-08-20T04:22:07.603', 'FavoriteCount': '2', 'Id': '3263'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In an undirected graph, can two nodes at an identical distance n from the root of a <a href="http://en.wikipedia.org/wiki/Depth-first_search" rel="nofollow">DFS</a> tree be neighbors in the original graph? I\'m thinking no, but I\'m not sure (because of back edges)</p>\n', 'ViewCount': '58', 'Title': 'Can two neighbors in a graph be at the same depth in a DFS tree?', 'LastActivityDate': '2012-09-24T13:48:52.410', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '4708', 'Score': '3', 'OwnerDisplayName': 'el diablo', 'PostTypeId': '1', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2008-11-28T20:38:14.300', 'Id': '4707'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm designing an algorithm for a class that will determine if a directed graph is unique with respect to a vertex $v$ such that for any $u \\ne v$ there is at most one path from $v$ to $u$. I've started by using BFS (breadth-first search) to find the shortest path from v to another vertex u, and then running BFS again to see if an alternate path can be found from v to u. I think this is too time consuming however. Does anyone have any hints as to how the solution can be found with a shorter execution time?</p>\n", 'ViewCount': '221', 'Title': 'Unique path in a directed graph', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:10:52.957', 'LastEditDate': '2012-12-13T02:10:52.957', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '4713', 'Score': '6', 'OwnerDisplayName': 'el diablo', 'PostTypeId': '1', 'Tags': '<graph-theory><shortest-path><graph-traversal>', 'CreationDate': '2008-12-08T22:07:40.493', 'Id': '4711'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This is a question from my homework and I need some help.</p>\n\n<p>We are trying to run <a href="https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm" rel="nofollow">Kosaraju-Sharir</a> algorithm over $G$, adirectional graph  with arcs $(u,v)$. In the first DFS pass we inserted vertex $u$ into tree $T$. Can $V$ appear in the same tree $T$, or $T$ is a tree created earlier?</p>\n\n<p>I think it can appear in both cases but I really don\'t know how I can prove it. Will be happy with some guidance.</p>\n', 'ViewCount': '262', 'Title': 'Kosaraju-Sharir algorithm and the inserted vertex', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-09-24T17:56:13.873', 'LastEditDate': '2012-09-24T17:56:13.873', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '5', 'OwnerDisplayName': 'Nusha', 'PostTypeId': '1', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2012-04-07T18:15:28.373', 'Id': '4715'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>My homework is implementing algorithms BFS, DFS, depth-limited and IDS for the map as a 2D grid with 8 directions of movement. \nI read that the IDS algorithm is optimal, but in my case is not optimal paths.</p>\n\n<p>Is the IDS algorithm optimal for graphs (e.g. map as a grid), or does optimality only apply to searching trees?</p>\n', 'ViewCount': '55', 'Title': 'IDS algorithm optimality for grid?', 'LastActivityDate': '2012-09-24T18:39:36.757', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'kamil', 'PostTypeId': '1', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2012-06-11T10:36:30.690', 'Id': '4721'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a forest, i.e., nodes with directed edges and no cycles (directed or undirected). I define the height of a vertex $v$ as 0 if it does not have any incoming edges, or the maximum number of edges to traverse in reverse to reach a vertex of height 0. \n<img src="http://i.stack.imgur.com/WzfAx.png" alt="enter image description here"></p>\n\n<p>I also know that the average degree of a node is a small constant, say 2 or so. To find the height of all vertices, I can think of two algorithms:</p>\n\n<p>Walking Algorithm</p>\n\n<ol>\n<li>Go through and mark $h=0$ for vertices with no incoming edges.</li>\n<li>For each vertex with $h=0$, follow the outgoing edges, updating the height of each encountered vertex if it\'s previous height is smaller.</li>\n</ol>\n\n<p>Frontier Algorithm</p>\n\n<ol>\n<li>Go through and mark $h=0$ for vertices with no incoming edges, and mark these as the frontier.</li>\n<li>For every frontier vertex, see if it\'s parent has children at or below the frontier, If it does, mark the parent as having $1$ plus the largest height among its children. Mark the parent as being on the frontier.</li>\n<li>Repeat 2 until there is nothing beyond the frontier.</li>\n</ol>\n\n<p>My questions:</p>\n\n<ol>\n<li>Is there a name for this problem, and a well known fastest solution?</li>\n<li>I tend to think simply walking up from all the $h=0$ vertices is the fastest solution. Am I right?</li>\n</ol>\n', 'ViewCount': '206', 'Title': 'Finding the height of all nodes in a forest', 'LastEditorUserId': '3159', 'LastActivityDate': '2012-10-12T17:47:57.643', 'LastEditDate': '2012-10-11T22:03:43.253', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '8', 'OwnerDisplayName': 'highBandWidth', 'PostTypeId': '1', 'OwnerUserId': '3159', 'Tags': '<algorithms><trees><graph-traversal>', 'CreationDate': '2012-10-11T18:13:18.083', 'Id': '5027'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am building a program that uses branching-and-bounding to find an optimal path in a complete graph (the heuristic, faster algorithm is the second part). I have to begin and end at node 0. I was given a large hint that eliminating "hopeless" branches early in the algorithm will lead to an overall much faster runtime. I have tried several things: greedily selecting the smallest edge as either the first or last edge in the tour, branching into two subsets of solutions with one branch being solutions including the smallest available edge and the other being solutions that exclude the largest available edge. Neither have proved to be worth any salt, and I was wondering if there were any clever optimizations to branch-and-bound I could implement to help speed up my program. Any help will be appreciated!</p>\n\n<p>Edit: any advice on computing better bounds and how to use them effectively is also welcomed.</p>\n', 'ViewCount': '27', 'Title': 'Inferences about Branching in TSP algorithm', 'LastEditorUserId': '4771', 'LastActivityDate': '2012-11-30T04:06:20.010', 'LastEditDate': '2012-11-30T04:06:20.010', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4771', 'Tags': '<optimization><graph-traversal>', 'CreationDate': '2012-11-30T03:37:03.467', 'Id': '7033'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><img src="http://i.stack.imgur.com/XeuwO.gif" alt="hexagon coordinates"></p>\n\n<p>In my program, it draws them by offsetting every other row by half of the width, as pictured above. Each tile can be referenced by coordinates, also shown above.</p>\n\n<p><img src="http://i.stack.imgur.com/DKyZq.gif" alt="hexagon roads"></p>\n\n<p>I want to know how many blue tiles are accessible from a certain starting tile and a series of "roads." In this example, three blue tiles can be reached. </p>\n\n<p>How would I represent roads? This is what I would need to know about it:</p>\n\n<ul>\n<li>how it is rotated (for drawing)</li>\n<li>which hexagons it borders</li>\n<li>which other roads it touches, if any</li>\n<li>where it should be drawn</li>\n</ul>\n\n<p>I assume I could use recursion to to count the accessible blue squares if the above conditions are met.</p>\n', 'ViewCount': '313', 'Title': 'How do I structure hexagon edge data?', 'LastActivityDate': '2012-12-13T04:27:27.487', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '7368', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '246', 'Tags': '<data-structures><graph-traversal>', 'CreationDate': '2012-12-09T02:41:43.050', 'FavoriteCount': '4', 'Id': '7261'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given a path down a <em>full</em> binary tree to a node (for example, a sequence of $1$s and $0$s, $0$ representing "go left" and $1$ representing "go right"), how would one find the position of the node in the preorder traversal. In other words the $i$th node in the preorder traversal will end up with at this node.</p>\n\n<p>Obviously something better than brute force would be nice.</p>\n', 'ViewCount': '311', 'Title': 'Calculating traversal position of a node in a full binary tree, given its path', 'LastActivityDate': '2013-02-10T05:11:58.387', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7348', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<binary-trees><trees><graph-traversal>', 'CreationDate': '2012-12-12T00:34:37.243', 'Id': '7346'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to create an <a href="http://en.wikipedia.org/wiki/Isochrone_map" rel="nofollow">isochrone</a> based on the OpenStreetMap data set. Everything works fine, I extracted data, processed it into a DAG, ran a Dijkstra algorithm over it. The result is a subset of the complete graph. This is an impression of the covered parts of the subset displayed over Google Maps:</p>\n\n<p><img src="http://i.stack.imgur.com/EwERW.png" alt="all vertices of graph"></p>\n\n<p>However, when the area gets larger, the number of reached vertices gets very large and displaying like this gets slow. What I would like to do is convert the set of edges and vertices into a polygon. Basically, this should be posible by removing all of the inner edges, leaving just the edges around the boundary of the area and the edges pointing out from it. I know coordinates for all vertices and approximating each edge as a line would be fine. Larger inner areas should become holes inside the polygon.</p>\n\n<p>My first attempt was to use an geospatial library (in my case the SqlServer spatial extensions), create a multiline from all of the edges and doing an ST_Buffer on it. Turns out to be very slow and memory consuming for large numbers of edges (> 1000)</p>\n\n<p>I was thinking along the lines of finding small polygons in the set (turning left at every turn?) and removing every edge that is part of 2 of these polygons. </p>\n\n<p>Extra image to use in comment below:\n<img src="http://i.stack.imgur.com/M2SWO.png" alt="sample graph"></p>\n', 'ViewCount': '526', 'Title': 'Algorithm for getting the outer boundary of a large graph', 'LastEditorUserId': '5116', 'LastActivityDate': '2013-01-09T12:18:08.840', 'LastEditDate': '2013-01-09T12:18:08.840', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '7498', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5116', 'Tags': '<algorithms><computational-geometry><graph-traversal>', 'CreationDate': '2012-12-18T17:46:49.200', 'Id': '7491'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Do we need to use BFS or DFS algorithm to find the k shortest loopless paths in a graph between any two nodes? \nIf so where can it be useful?</p>\n', 'ViewCount': '148', 'Title': 'BFS in K shortest paths', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-28T13:31:19.390', 'LastEditDate': '2013-01-28T10:05:21.847', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '5328', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal>', 'CreationDate': '2013-01-27T16:54:04.673', 'FavoriteCount': '1', 'Id': '9208'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is it true or false that for running a dfs on an undirected graph G with a simple cycle than this cycle will have exactly one back edge?</p>\n\n<p>Looks to me likes its true ,is it?</p>\n', 'ViewCount': '122', 'Title': 'Dfs algorithm and cycles question', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-04T12:13:14.260', 'LastEditDate': '2013-02-04T12:13:14.260', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Nusha', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><search-algorithms><graph-traversal>', 'CreationDate': '2013-02-03T11:26:50.813', 'Id': '9458'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '641', 'Title': 'The purpose of grey node in graph depth-first search', 'LastEditDate': '2013-02-11T17:33:21.087', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6805', 'FavoriteCount': '1', 'Body': '<p>In many implementations of depth-first search that I saw (for example: <a href="http://ramos.elo.utfsm.cl/~lsb/elo320/aplicaciones/aplicaciones/CS460AlgorithmsandComplexity/lecture9/COMP460%20Algorithms%20and%20Complexity%20Lecture%209.htm" rel="nofollow">here</a>), the code distinguish between a grey vertex (discovered, but not all of its neighbours was visited) and a black vertex (discovered and all its neighbours was visited). What is the purpose of this distinction? It seems that DFS algorithm will never visit a visited vertex regardless of whether it\'s grey or black.</p>\n', 'Tags': '<algorithms><graphs><search-algorithms><graph-traversal>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-12T00:43:33.593', 'CommentCount': '0', 'AcceptedAnswerId': '9681', 'CreationDate': '2013-02-11T13:10:44.110', 'Id': '9676'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is there an explanation Christofides\'s Heuristic for solving TSP which does not simply state the algorithm and go ahead to prove the bound?</p>\n\n<p>To be specific:\n(Disclaimer : I am an engineer who knows very little about graph theory but need this for a logistics course)</p>\n\n<ul>\n<li>I understand that I first create an MST. So far, so good.</li>\n<li>Now, I need to find a perfect minimum weight matching on all odd degree nodes. I have no clue what this is; googling this tells me this is a set of edges containing maximum $n/2$ edges such that no node is shared by 2 sets. I don\'t see why I am doing this..... I am not even sure I understand what this statement means.</li>\n<li>Now, I need to merge the MST and the matchings to create a "multigraph" and then find an Eulerian tour on this. No clue what I am doing here.</li>\n<li>Run the shortcut algorithm exploiting the triangle inequality. (No clue what happened till now and this obviously then makes no sense either)</li>\n</ul>\n\n<p>Can someone point me to a good resource with possible examples and illustrations for why Christofides works in a language that isn\'t full of graph theory terms (or alternately, provide me an answer here)?</p>\n\n<p>I have already looked at :</p>\n\n<ul>\n<li><a href="http://ieor.berkeley.edu/~kaminsky/ieor251/notes/2-16-05.pdf" rel="nofollow">A Berkeley PDF</a></li>\n<li>Wikipedia</li>\n</ul>\n', 'ViewCount': '507', 'Title': "A Good Resource for Christofides' Heuristic", 'LastEditorUserId': '39', 'LastActivityDate': '2013-02-19T23:46:33.413', 'LastEditDate': '2013-02-19T23:46:33.413', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9924', 'Score': '4', 'OwnerDisplayName': 'user6422', 'PostTypeId': '1', 'Tags': '<algorithms><heuristics><graph-traversal>', 'CreationDate': '2013-02-19T06:37:03.837', 'Id': '9923'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '183', 'Title': 'Number of possible search paths when searching in BST', 'LastEditDate': '2013-04-11T23:41:46.050', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6665', 'FavoriteCount': '1', 'Body': "<p>I have the following question, but don't have answer for this. I would appreciate if my method is correct :</p>\n\n<p>Q. When searching for the key value 60 in a binary search tree, nodes containing the key values 10, 20, 40, 50, 70, 80, 90 are traversed, not necessarily in the order given. How many different orders are possible in which these key values can occur on the search path from the root node containing the value 60? </p>\n\n<p>(A) 35 (B) 64 (C) 128 (D) 5040 </p>\n\n<p>From the question, I understand that all nodes given have to be included in traversal and ultimately we have to reach the key, 60. For example, one such combination would be : </p>\n\n<p>10, 20, 40, 50, 90, 80, 70, 60. </p>\n\n<p>Since we have to traverse all nodes given above, we have to start either with 10 or 90. If we start with 20, we will not reach 10 (since 60 > 20 and we will traverse right subtree of 20)</p>\n\n<p>Similarly, we cannot start with 80, because we will not be able to reach 90, since 80>60, we will traverse in left sub tree of 80 &amp; thus not reaching 90. </p>\n\n<p>Lets take 10. The remaining nodes are 20, 40, 50, 70, 80, 90. Next node could be either 20 or 90. We cannot take other nodes for same earlier mentioned reason.</p>\n\n<p>If we consider similarly, at each level we are having two choices. Since there are 7 nodes, two choices for first 6 &amp; no choice for last one. So there are totally </p>\n\n<p>$2*2*2*2*2*2*1$ permutations = $2^6$ = $64$</p>\n\n<ol>\n<li><p>Is this a correct answer?</p></li>\n<li><p>If not, whats the better approach?</p></li>\n<li><p>I would like to generalize. If $n$ nodes are given then total possible search paths would be $2^{n-1}$</p></li>\n</ol>\n", 'Tags': '<data-structures><combinatorics><binary-trees><search-trees><graph-traversal>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T23:41:46.050', 'CommentCount': '0', 'AcceptedAnswerId': '11048', 'CreationDate': '2013-04-05T07:42:32.627', 'Id': '11043'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm looking for an algorithm which would find a minimal spanning tree given certain constraints (CSP) about importance of some nodes, e.g. consider a graph with next distance matrix:\n$$\n\\left[ \\begin{array}{c}\n- &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F \\\\\nA &amp; 0 &amp; 120 &amp; 100 &amp; inf &amp; inf &amp; 30 \\\\\nB &amp; 120 &amp; 0 &amp; 70 &amp; inf &amp; 150 &amp; inf \\\\\nC &amp; 100 &amp; 70 &amp; 0 &amp; 60 &amp; 60 &amp; inf \\\\\nD &amp; inf &amp; inf &amp; 60 &amp; 0 &amp; inf &amp; 50 \\\\\nE &amp; inf &amp; 150 &amp; 60 &amp; inf &amp; 0 &amp; inf \\\\\nF &amp; 30 &amp; inf &amp; inf &amp; 50 &amp; inf &amp; 0 \\\\\n\\end{array} \\right]\n$$\nPrim's algorithm will result in something like this:\n$$\n\\left[ \\begin{array}{c}\n- &amp; A &amp; B &amp; C &amp; D &amp; E &amp; F \\\\\nA &amp; 0 &amp; inf &amp; inf &amp; inf &amp; inf &amp; 30 \\\\\nB &amp; inf &amp; 0 &amp; 70 &amp; inf &amp; inf &amp; inf \\\\\nC &amp; inf &amp; 70 &amp; 0 &amp; 60 &amp; 60 &amp; inf \\\\\nD &amp; inf &amp; inf &amp; 60 &amp; 0 &amp; inf &amp; 50 \\\\\nE &amp; inf &amp; inf &amp; 60 &amp; inf &amp; 0 &amp; inf \\\\\nF &amp; 30 &amp; inf &amp; inf &amp; 50 &amp; inf &amp; 0 \\\\\n\\end{array} \\right]\n$$</p>\n\n<p>However, node A is now zoned and it will take at least 3 transitions from $A$ to get to $C$ and for my specific CSP I need at most 2 transitions. It is fairly easy to incorporate such CSP into Prim's algorithm. <strong>The question is: are there any generic algorithms which deal with finding a minimal spanning tree given a set of constraints ?</strong></p>\n", 'ViewCount': '62', 'Title': "Node-weighted CSP in Prim's algorithm?", 'LastEditorUserId': '6793', 'LastActivityDate': '2013-04-07T14:44:13.350', 'LastEditDate': '2013-04-07T14:44:13.350', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6793', 'Tags': '<algorithms><graphs><graph-traversal><constraint-programming>', 'CreationDate': '2013-04-07T13:37:16.603', 'Id': '11100'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>In a depth first tree, there are the edges define the tree (i.e the edges that were used in the traversal).</p>\n\n<p>There are some leftover edges connecting some of the other nodes. What is the difference between a cross edge and a forward edge?</p>\n\n<p>From wikipedia:</p>\n\n<blockquote>\n  <p>Based on this spanning tree, the edges of the original graph can be divided into three classes: forward edges, which point from a node of the tree to one of its descendants, back edges, which point from a node to one of its ancestors, and cross edges, which do neither. Sometimes tree edges, edges which belong to the spanning tree itself, are classified separately from forward edges. If the original graph is undirected then all of its edges are tree edges or back edges.</p>\n</blockquote>\n\n<p>Doesn't an edge that is not used in the traversal that points from one node to another establish a parent-child relationship? </p>\n", 'ViewCount': '1017', 'Title': 'Difference between cross edges and forward edges in a DFT', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-08T14:37:35.677', 'LastEditDate': '2013-04-08T14:37:35.677', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11125', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '863', 'Tags': '<algorithms><terminology><graphs><graph-traversal>', 'CreationDate': '2013-04-07T22:57:20.517', 'Id': '11116'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>A bridge (critical edge) in an undirected graph is an edge whose removal increases the number of connected components.</p>\n\n<p>I need to determine all critical edges in an undirected graph, in $O(V+E)$ time. From what I found out, I need to use a modified DF search, but all pseudo-code algorithms I found have <code>low[v]</code> and <code>d[v]</code> which I don't understand.</p>\n\n<p>Can someone please explain to me the $O(V+E)$ bridge determination algorithm?</p>\n", 'ViewCount': '257', 'Title': 'Bridge determination in undirected graphs', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-11T14:22:16.190', 'LastEditDate': '2013-04-11T14:22:16.190', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'user7681', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal>', 'CreationDate': '2013-04-11T13:18:37.097', 'Id': '11229'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I have been reading up on algorithm for finding the strongly connected components in a directed graph $G=(V,E)$. It considers two DFS search and the second step is transposing the original graph $G^T$. </p>\n\n<p>The algorithm is the following :</p>\n\n<ol>\n<li>Execute DFS on $G$ (starting at an arbitrary starting vertex), keeping track of the \ufb01nishing times of all vertices.</li>\n<li>Compute the transpose, </li>\n<li>Execute DFS on $G^T$, starting at the vertex with the latest \ufb01nishing time, forming a tree rooted at that vertex. Once a tree is completed, move on to the unvisited vertex with the next latest \ufb01nishing time and form another tree using DFS and repeat until all the vertices in $G^T$ are visited.</li>\n<li>Output the vertices in each tree formed by the second DFS as a separate strongly connected component.</li>\n</ol>\n\n<p>My question is :</p>\n\n<ol>\n<li>What is the intuition behind this middle step of computing a transpose?</li>\n</ol>\n', 'ViewCount': '460', 'Title': 'Correctness of Strongly Connected Components algorithm for a directed graph', 'LastEditorUserId': '2223', 'LastActivityDate': '2013-04-12T11:29:20.083', 'LastEditDate': '2013-04-11T15:32:00.840', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11257', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graphs><graph-traversal>', 'CreationDate': '2013-04-11T15:08:51.047', 'Id': '11232'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Prove that if G is an undirected connected graph, then each of its edges is either in the depth-first search tree or is a back edge.</p>\n\n<p>Now, from intuition and in class lectures by Steven Skiena, I know that the above holds true, since it dives all the way down, and then throw a rope back to a previous vertex. I also know that DFS is great in finding cycles.</p>\n\n<p>However, my problem here is that I don't know how to <em>prove</em> that the edge is either a tree edge or a back edge.</p>\n", 'ViewCount': '1467', 'Title': 'Why does DFS only yield tree and back edges on undirected, connected graphs?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-25T09:39:45.153', 'LastEditDate': '2013-04-21T14:32:57.923', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><graphs><algorithm-analysis><graph-traversal>', 'CreationDate': '2013-04-20T19:03:21.160', 'FavoriteCount': '1', 'Id': '11438'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>A lot of articles say that hash tree traversal cost to any <em>randomly</em> chosen leaf is $\\mathcal{O}(\\log_2 N)$ ($N$ is a number of leafs) and that is right. If we have a tree of 8 leafs it will take us at most 3 operations to get to any leaf, if we have a tree of 64 leafs it will take us at most 5 operations etc.</p>\n\n<p>But lets say I need to check <strong><em>every</em></strong> leaf sequentially to check if <strong><em>all blocks</em></strong> of a file are correct, then I would need $\\mathcal{O}(N \\log_2 N)$ operations. Or if I would check every second leaf (just left leaf of every pair) I would need $\\mathcal{O}((\\frac{N\\log_2 N}{2}))$ operations. That is, I will need $\\mathcal{O}(\\log_2 N)$ operations for every leaf? Which leads to exponentially growing evaluations curve and it would be better to use simple hash list or hash chain? Am I right?</p>\n\n<p>Or I just don\'t see/know something?</p>\n\n<p><img src="http://i.stack.imgur.com/Mnvvt.jpg" alt=""></p>\n\n<p>*Note, chart has logarithmic scale</p>\n', 'ViewCount': '102', 'Title': 'Sequential hash tree traversal', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-06-14T18:11:32.220', 'LastEditDate': '2013-05-14T10:59:03.967', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8111', 'Tags': '<data-structures><search-trees><graph-traversal><hash-tables>', 'CreationDate': '2013-05-10T07:16:57.917', 'Id': '11927'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>A sink in a directed graph is a node with no outgoing edges. If I perform a depth first search, why is it that the node with the least post-order number (and thus the highest pre-order number) not necessarily a sink - isn't this node found last?</p>\n\n<p>Also, intuitively, the node with the greatest post-order number should be a source - a node with no incoming edges.</p>\n", 'ViewCount': '270', 'LastEditorDisplayName': 'user742', 'Title': 'Why is the node with the greatest DFS post-order number not necessarily a sink?', 'LastActivityDate': '2013-09-20T09:33:07.620', 'LastEditDate': '2013-09-20T09:33:07.620', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12570', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2013-06-09T09:55:02.757', 'Id': '12559'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In Don Knuth\'s famous series of books, <em>The Art of Computer Programming</em>, section 2.3.1, he describes an algorithm to traverse binary tree in inorder, making use of an auxiliary stack:</p>\n\n<blockquote>\n  <p><strong>T1</strong> [Initialize.] Set stack $\\rm A$ empty and set the link variable $\\rm P\\gets T$</p>\n  \n  <p><strong>T2</strong> [$\\rm P=\\Lambda$?] If $\\rm P=\\Lambda$, go to step T4.</p>\n  \n  <p><strong>T3</strong> [Stack$\\rm \\;\\Leftarrow P$] (Now $\\rm P$ points to a nonempty binary tree that is to be traversed.) push the value of $\\rm P$ onto stack $\\rm A$, then set $\\rm P\\gets LLINK(P)$</p>\n  \n  <p><strong>T4</strong> [$\\rm P\\Leftarrow Stack$] If stack $\\rm A$ is empty, the algorithm terminates; otherwise pop the top of $\\rm A$ to $\\rm P$.</p>\n  \n  <p><strong>T5</strong> [Visit $\\rm P$] Visit $\\rm NODE(P)$. Then set $\\rm P\\gets RLINK(P)$ and return to step T2.</p>\n</blockquote>\n\n<p>We can plot a flow chart of the algorithm. In the succeeding paragraph, he gives a <em>formal proof</em> of the algorithm:</p>\n\n<blockquote>\n  <p>Starting at step T2 with $\\rm P$ a pointer to a binary tree of $n$ nodes and with the stack $\\rm A$ containing $\\rm A[1]\\dotsc A[m]$ for some $m\\ge 0$, the procedure of steps T2-T5 will traverse the binary tree in question, in inorder, and will then arrive at step T4 with stack $\\rm A$ returned to its original value $\\rm A[1]\\dotsc A[m]$.</p>\n</blockquote>\n\n<p>However, as far as I know, such a formal proof is quite different from the general method described in section 1.2.1:</p>\n\n<blockquote>\n  <p>for each box in the flow chart, that if an assertion attached to any arrow leading into the box is true before the operation in that box is performed, then all of the assertions on relevant arrows leading away from the box are true after the operation.</p>\n</blockquote>\n\n<p>In fact, such a method is somewhat equivalent to <a href="http://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>, which is used to formally check the validity of algorithms.</p>\n\n<p>Can we turn the statement mentioned to prove the traversing algorithm into a schema of Hoare logic, or the assertion-attachment of a flow chart?</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '122', 'Title': 'Question about the formal proof of the inorder traversing', 'LastActivityDate': '2013-06-11T20:17:23.337', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1715', 'Tags': '<algorithms><correctness-proof><graph-traversal><hoare-logic>', 'CreationDate': '2013-06-11T08:47:50.447', 'Id': '12610'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is there an efficient algorithm which gives the minimum cost closed walk in an undirected graph, which visits all vertices?</p>\n\n<p>Does this problem have a name? I tried to reduce this to similar problems (in particular the traveling salesman problem) to see if it was NP-hard, but was unsuccessful.</p>\n\n<p>Here\'s an example:</p>\n\n<p><img src="http://i.stack.imgur.com/3dxzt.png" alt="enter image description here"></p>\n\n<p>Then a possible closed walk is: A,B,C,D,C,B,A, with a cost of 6.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '203', 'Title': 'Minimum cost closed walk in a graph', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-15T11:10:55.033', 'LastEditDate': '2013-07-14T09:51:41.813', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '13283', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9173', 'Tags': '<algorithms><graphs><np-hard><graph-traversal><traveling-salesman>', 'CreationDate': '2013-07-14T05:04:52.683', 'Id': '13267'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have a finite automaton with these properties:</p>\n\n<ul>\n<li>Contains cycles</li>\n<li>It's a directed graph</li>\n<li>All the states/nodes are initialy reachable from the initial state</li>\n<li>It has final states but I guess it isn't relevant for my issue</li>\n<li>It's a random generated automaton, and the generation isn't meant to satisfy properties like strongly connected components or connected components </li>\n</ul>\n\n<p>Let's suppose I have to delete an edge. </p>\n\n<p>I need to know if there's a way to prove that the reached state by this edge is still reachable from the initial state without using a classical search (DFS or BFS); obviously, if there is any.</p>\n", 'ViewCount': '57', 'Title': 'What is the optimal solution to prove the reachbility of a node from the root?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T17:36:35.740', 'LastEditDate': '2013-09-17T17:36:35.740', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10118', 'Tags': '<graph-theory><finite-automata><graph-traversal>', 'CreationDate': '2013-09-17T15:48:06.797', 'FavoriteCount': '1', 'Id': '14381'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '708', 'Title': 'Shortest non intersecting path for a graph embedded in a euclidean plane (2D)', 'LastEditDate': '2013-12-10T03:44:41.487', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '7', 'Body': '<p>What algorithm would you use to find the shortest path of a graph, which is embedded in an euclidean plane, such that the path should not contain any self-intersections (in the embedding)?</p>\n\n<p>For example, in the graph below, you want to go from $(0,0) \\rightarrow (-3,2)$. Normally, an algorithm like Dijkstra\'s algorithm would produce a sequence like:</p>\n\n<p>$$\\left[ (0,0) \\stackrel {3}{\\rightarrow} (0,3) \\stackrel{\\sqrt{2}}{\\rightarrow} (1,2) \\stackrel{4}{\\rightarrow} (-3,2) \\right] = 7+\\sqrt{2}.$$</p>\n\n<p>Full graph:</p>\n\n<p><img src="http://i.stack.imgur.com/l3OkDm.jpg" alt="enter image description here"></p>\n\n<p>Shortest path:</p>\n\n<p><img src="http://i.stack.imgur.com/HwDQtm.jpg" alt="enter image description here"></p>\n\n<p>Shortest non-intersecting path:</p>\n\n<p><img src="http://i.stack.imgur.com/sIj1wm.jpg" alt="enter image description here"></p>\n\n<p>However, this path intersects itself on the euclidean plane, therefore I <em>want</em> an algorithm that would give me the shortest non-intersecting sequence, in this case:</p>\n\n<p>$$\\left[(0,0) \\stackrel{3}{\\rightarrow} (0,3) \\stackrel{3}{\\rightarrow} (0,6) \\stackrel{5}{\\rightarrow} (-3,2) \\right] = 11.$$</p>\n\n<p>This path is longer than the shortest path, but it is the shortest non-intersecting path.</p>\n\n<p><strong>Is there an (efficient) algorithm that can do this?</strong></p>\n\n<h2>TikZ sources</h2>\n\n<ul>\n<li><a href="https://www.writelatex.com/read/jzkhmqgmqcnj" rel="nofollow">Full graph</a>.</li>\n<li><a href="https://www.writelatex.com/read/kwpwzzcfyjcy" rel="nofollow">Shortest path</a>.</li>\n<li><a href="https://www.writelatex.com/read/qzrbvwxgpbtp" rel="nofollow">Shortest non-intersecting path</a>.</li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal><weighted-graphs>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T03:44:41.487', 'CommentCount': '20', 'AcceptedAnswerId': '16281', 'CreationDate': '2013-10-20T23:27:17.370', 'Id': '16269'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have an Euclidean, undirected graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.</p>\n\n<ul>\n<li>The number of vertices with no edges is small in comparison to the total number of vertices. </li>\n<li>No vertex has more than two edges connected to it.</li>\n</ul>\n\n<p>How can I convert this graph to a closed shape, so each vertex will have exactly two edges connected to it and there will be a path between any two vertices? I want to do it with minimum change in the total weight of all the edges.</p>\n', 'ViewCount': '126', 'Title': 'Converting graphs to sets of paths', 'LastEditorUserId': '917', 'LastActivityDate': '2013-12-10T03:14:40.417', 'LastEditDate': '2013-12-10T03:14:40.417', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><weighted-graphs>', 'CreationDate': '2013-10-23T07:11:44.910', 'Id': '16351'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices, also all the vertices are connected with edges.</p>\n\n<p>I want to change the vertices values, so that the average ratio between the length of two edges (taken over all pairs of edges), will be as small as possible, I want to keep just one rule. For any vertex on the graph, it's neighbors sorted by Euclidean distance from that vertex, must remind in the same order.</p>\n\n<p>The idea behind this, if solution could be provided, that it will be possible to treat groups of vertices as one. It will reduce the difficulty of solving TSP.</p>\n", 'ViewCount': '64', 'Title': 'Trim graph to minimum', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-10-23T13:50:52.117', 'LastEditDate': '2013-10-23T13:50:52.117', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-23T12:39:35.833', 'Id': '16361'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>So I have the question:</p>\n\n<p>Prove that any directed cycle in the graph of a partial order must only involve one node.</p>\n\n<p>So I know that a partial order must be transitive, antisymmetric, and reflective, but from there I am pretty lost. I also know that any path of one or more edges from a node to itself is a directed cycle, but from there I am having trouble connecting everything.</p>\n\n<p>I kind of need help as to where to start thinking, and the first step as to how to answer this question.</p>\n', 'ViewCount': '99', 'Title': 'Prove that any directed cycle in the graph of a partial order must only involve one node', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-24T13:28:57.787', 'LastEditDate': '2013-10-24T02:09:46.897', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10282', 'Tags': '<graphs><graph-traversal><partial-order><order-theory>', 'CreationDate': '2013-10-24T01:39:01.753', 'Id': '16389'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.</p>\n\n<p>I am randomly creating a path thru all the vertices and I want to know if there is any efficient way to find all the intersections on my path.</p>\n', 'ViewCount': '124', 'Title': 'Efficient way to find intersections', 'LastActivityDate': '2013-10-25T07:39:59.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '16422', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><weighted-graphs>', 'CreationDate': '2013-10-25T06:16:51.257', 'Id': '16418'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have an Euclidean graph: each vertex is a point on the 2D plane, so the weight of each edge is the Euclidean distance between the vertices.  I found a <a href="http://tsp-vs-world.blogspot.co.il/2013/10/intersections-optimal-tsp-route.html" rel="nofollow">geometric proof</a> that every optimal TSP solution contains no intersections.</p>\n\n<p>How many non-intersecting routes could be there? Or in other words: what is the probability to guess an optimal solution to a TSP problem if we just enumerate or sample non-intersecting routes?</p>\n\n<p><strong>Edit:</strong> I want to ignore the case that D.W. mentioned. For every path that you can swap between two neighbors vertices(If we represent the path as an array of vertices so neighbors will be two vertices with consecutive indexes) without changing its non-intersecting quality, all of those paths will be considered as one.</p>\n\n<p><strong>Edit</strong> I found that this kind of removing crossings from the graph also know as <a href="http://en.wikipedia.org/wiki/2-opt" rel="nofollow">2-OPT</a> </p>\n', 'ViewCount': '236', 'Title': 'Calculating the number of non-intersecting routes in an Euclidean graph', 'LastEditorUserId': '10572', 'LastActivityDate': '2013-11-03T12:37:57.193', 'LastEditDate': '2013-11-03T12:37:57.193', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10572', 'Tags': '<algorithms><graphs><graph-traversal><traveling-salesman><weighted-graphs>', 'CreationDate': '2013-10-26T09:50:01.253', 'FavoriteCount': '1', 'Id': '16439'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to come up with a good algorithm to merge a set of Trails. I have described what is meant by a Trail and the conditions which\ndetermine if the merge is good or bad.</p>\n\n<p><strong>Trail - Linear sequence of n nodes obtained by traversing a graph.</strong></p>\n\n<p>E.g., </p>\n\n<pre><code>A--B--C--D--E--F\nB--C--D--E\nP--Q--R--S--T\nD--E--F--G--H\n</code></pre>\n\n<p>Each Trail has a maximum capacity of 500. There is a cost of 2 associated with each Trail.</p>\n\n<p>2 Trails can be merged if they overlap and their combined capacity is &lt; 500</p>\n\n<hr>\n\n<p>Examples of merging</p>\n\n<p>Format below is Trail followed by capacity and cost in brackets.</p>\n\n<p>Example 1</p>\n\n<pre><code>A--B--C--D--E--F : 200(2)\nA--B--C : 200(2)\nD--E--F : 200(2)\n</code></pre>\n\n<p>Total cost = 6</p>\n\n<p>We can merge A--B--C--D--E--F and A--B--C because they overlap and their combined capacity 400 &lt; 500. </p>\n\n<p>Similarly we can merge A--B--C--D--E--F and D--E--F. We end up with</p>\n\n<pre><code>A--B--C : 400(2)\nD--E--F : 400(2)\n</code></pre>\n\n<p>Total cost  = 4\nThis is a good merge and we have reduced total cost.</p>\n\n<hr>\n\n<p>Example 2</p>\n\n<pre><code>A--B--C--D--E--F : 200(2)\nB--C--D--E : 200(2)\n</code></pre>\n\n<p>Total cost = 4</p>\n\n<p>Merging the Trails we have</p>\n\n<pre><code>A--B : 200(2)\nB--C--D--E : 400(2)\nE--F : 200(2)\n</code></pre>\n\n<p>Total cost = 6\nThis merge is not good because it increase the cost.</p>\n\n<p>We can have merges that keep the cost the same. They are also acceptable</p>\n\n<p>Currently I have a simple 2 loop solution. The loops iterate over a sorted(in decreasing Trail length) list and check one by one if merges can be done.</p>\n\n<p>I am not aware if this falls into any known algorithm category. If anyone can point me to them or give an idea for a better solution, that will be great.</p>\n', 'ViewCount': '34', 'Title': 'Efficient way to merge a set of Trails (sequence of nodes in a Graph)', 'LastActivityDate': '2013-11-26T10:38:05.267', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'OwnerDisplayName': 'user3030022', 'PostTypeId': '1', 'Tags': '<algorithms><graphs><graph-traversal>', 'CreationDate': '2013-11-25T14:39:45.633', 'Id': '18374'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given is the following graph which is logically divided into layers (with Dijkstra's shortest paths algorithm):</p>\n\n<pre><code> Vertices   Layer\n\n    Root      0\n   /   \\\n  A     B     1\n / \\    |\nC   D   E     2\n \\  |  /\n  \\ | /\n    F         3\n</code></pre>\n\n<p>Now I'm looking for an algorithm which groups vertices when they have a (single) common ancestor in the previous layer, e.g. for the graph in the example the groups would be:</p>\n\n<pre><code>0: A, B\n1: C, D\n2: E\n3: F\n</code></pre>\n\n<p>I know that this is doable by visiting vertices and comparing ancestors but I was wondering whether there is a well known algorithm for it.</p>\n\n<p><strong>Update:</strong> My question is really only related to find groups. I'm aware of the fact, that I can traverse vertices and test for incoming edges and group those vertices. Furthermore, the graph is fully constructed.</p>\n\n<p>One (now deleted) answer mentioned DFS, which creates a search forest (as BFS creates a search tree which I basically used for levels, though I mentioned Dijkstra). So, I assume that combining BFS and DFS could give me the desired result.</p>\n", 'ViewCount': '140', 'Title': 'Algorithm to Group Vertices of Graph', 'LastEditorUserId': '11734', 'LastActivityDate': '2014-03-07T23:10:15.287', 'LastEditDate': '2013-12-07T20:39:47.837', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11734', 'Tags': '<algorithms><graph-theory><graph-traversal>', 'CreationDate': '2013-12-01T16:02:07.553', 'Id': '18504'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given a weighted digraph $G=V,E$, and a weight function, $d(u,v)$, one can normally use Dijkstra's algorithm to obtain the shortest path. What I am interested in, is how to obtain the $2^{nd}$-shortest path, the $3^{rd}$-shortest, and so on.</p>\n\n<p>Questions:</p>\n\n<blockquote>\n  <p>Is there an efficient algorithm to get the i-th-most-shortest-path between two nodes in a weighted graph?</p>\n  \n  <p>Is there an efficient algorithm to get the k-most-shortest-paths between two nodes in a weighted graph?</p>\n</blockquote>\n\n<p>An answer to either one is OK, though I wonder if an answer to the second question can be done more efficiently than $k$ calls to an answer to the first question.</p>\n", 'ViewCount': '67', 'Title': 'k-shortest paths', 'LastActivityDate': '2013-12-11T00:25:44.833', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal>', 'CreationDate': '2013-12-11T00:25:44.833', 'FavoriteCount': '1', 'Id': '18849'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to understand how IDDFS works by reading a <a href="http://en.wikipedia.org/wiki/Iterative_deepening_depth-first_search" rel="nofollow">wikipedia article</a> on it.\n(If someone has a better literature on the subject, don\'t hesitate to post).\nPseudocode is as follows:</p>\n\n<pre><code>IDDFS(root, goal)\n{\n  depth = 0\n  for(i=1, i&lt;10, i++)\n  {\n    DFS(limit=i)\n  }\n}\n</code></pre>\n\n<p>First of all, what is 10 here? Is it an arbitray number we choose?\nWhat is the connection between depth and "10"?</p>\n\n<p>In the graph given as an example in that wikipedia article, in step 2 vistied nodes are:<br>\n2: A, B, D, F, C, G, E, F</p>\n\n<p>Why is node F visited twice? Doesn\'t a DFS keep track of already visited nodes?</p>\n\n<p>I am totally confused on this issue and any help is greatly appreciated.</p>\n', 'ViewCount': '89', 'Title': 'IDDFS explained', 'LastActivityDate': '2013-12-16T09:55:09.557', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19033', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12153', 'Tags': '<graph-theory><graph-traversal>', 'CreationDate': '2013-12-16T09:06:14.077', 'Id': '19032'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>In the last 2 paragraphs of the paper about Hopcroft\u2013Karp algorithm to find the maximum cardinality matching in bipartite graph:</p>\n\n<blockquote>\n  <p><a href="https://dl.dropboxusercontent.com/u/64823035/04569670.pdf" rel="nofollow">https://dl.dropboxusercontent.com/u/64823035/04569670.pdf</a></p>\n  \n  <p>The execution time of a phase is O(m+n), where m is the number of\n  edges in G, and n is the number of vertices. Hence the execution time\n  of the entire algorithm is O((m+n)s), where s is the cardinality of a\n  maximum matching.</p>\n  \n  <p>If G has n vertices then m &lt;= n^2 / 4 and s &lt; n / 2 so that the\n  execution time is bounded by O(n^(5/2)).</p>\n</blockquote>\n\n<p>I don\'t understand given:</p>\n\n<pre><code>m &lt;= n^2 / 4\ns &lt;= n / 2\n</code></pre>\n\n<p>why they concluded:</p>\n\n<pre><code>O((m+n)s) = O(n^(5/2))\n</code></pre>\n\n<p>Shouldn\'t it be:</p>\n\n<pre><code>O((m+n)s) = O(n^3)\n</code></pre>\n\n<p>Any idea?</p>\n', 'ViewCount': '78', 'Title': u'Hopcroft\u2013Karp algorithm time complexity', 'LastEditorUserId': '12572', 'LastActivityDate': '2014-01-03T14:30:49.710', 'LastEditDate': '2014-01-03T14:30:49.710', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12572', 'Tags': '<algorithms><graph-theory><graphs><graph-traversal><bipartite-matching>', 'CreationDate': '2014-01-03T13:58:38.513', 'Id': '19486'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '88', 'Title': 'What is the order of the Pancake graph in Given example & what are the properties of Pancake graph?', 'LastEditDate': '2014-05-03T21:04:17.810', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9665', 'FavoriteCount': '2', 'Body': '<p>Pancake graph have least diameter &amp; degree (log n/ log log n)</p>\n\n<p>pancake Graph with order-2 will be one single line with two nodes, labeled with permutation of node {12, 21}.</p>\n\n<p>pancake Graph with order-3 will be one single line with one hexagonal, labeled with permutation of node {123, 132, 213, 231, 312, 321}.</p>\n\n<p>Similarly for order-4 graph will be with 4-hexagonal.\n<img src="http://i.stack.imgur.com/RFsZY.png" alt="enter image description here"></p>\n\n<p><strong>This graph is in three dimension or four dimension?\nif this graph is in four dimension, then how graph will look like in three dimension?</strong></p>\n', 'ClosedDate': '2014-01-09T23:26:42.547', 'Tags': '<graph-theory><graphs><graph-traversal>', 'LastEditorUserId': '9665', 'LastActivityDate': '2014-05-03T21:04:17.810', 'CommentCount': '1', 'AcceptedAnswerId': '19579', 'CreationDate': '2014-01-08T11:26:51.350', 'Id': '19578'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '54', 'Title': 'Simple path in a graph, within a given range of lengths', 'LastEditDate': '2014-02-03T08:54:42.827', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13327', 'FavoriteCount': '1', 'Body': '<p>Given an undirected graph $G(V,E)$ and two nodes $s$ and $t$, $s,t\\in V$, find a path whose length $L$ is bounded by a lower bound $N$ and an upper bound $M$, $N\\leq L\\leq M$.</p>\n\n<p>So, for example, $N=4, M=7$, I want to confirm that there is at least one simple path of 4,5,6 and 7 between two nodes in a graph? Nodes of the graph may appear in more than one path.</p>\n\n<p>Typical problem size:  </p>\n\n<ul>\n<li>10,000 nodes   </li>\n<li>Mean of 20 edges per node   </li>\n<li>Cycles in graph  </li>\n<li>Unweighted edges</li>\n</ul>\n', 'ClosedDate': '2014-02-03T09:54:06.393', 'Tags': '<graph-theory><graphs><graph-traversal>', 'LastEditorUserId': '1337', 'LastActivityDate': '2014-02-03T08:54:42.827', 'CommentCount': '2', 'CreationDate': '2014-02-02T14:17:32.063', 'Id': '20217'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I know that depth-first search can be used to produce a depth-first spanning tree, which classifies all edges as tree edges, forward edges, backward edges or cross edges. Are there any algorithms that make use of the depth-first spanning tree?</p>\n', 'ViewCount': '78', 'Title': 'Applications of Depth-First Spanning Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-20T15:01:48.333', 'LastEditDate': '2014-02-20T11:08:14.503', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14872', 'Tags': '<algorithms><graphs><graph-traversal><spanning-trees>', 'CreationDate': '2014-02-20T07:12:38.657', 'Id': '21839'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to find a minimal vertex in a tree from which we can traverse some edges exactly twice then come back to that vertex then do it with the rest of edges. By minimal, I mean that the difference of numbers of two subsets of edges have to be minimum.</p>\n', 'ViewCount': '84', 'ClosedDate': '2014-03-12T13:16:04.857', 'Title': 'Edge traversals of trees', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-14T00:52:01.190', 'LastEditDate': '2014-03-10T07:13:30.620', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12820', 'Tags': '<graph-theory><trees><graph-traversal>', 'CreationDate': '2014-03-09T09:43:04.420', 'Id': '22421'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><a href="http://cs.stackexchange.com/q/11263/8660">This</a> link provides an algorithm for finding the diameter of an undirected tree <strong>using BFS/DFS</strong>. Summarizing:</p>\n\n<blockquote>\n  <p>Run BFS on any node s in the graph, remembering the node u discovered last. Run BFS from u remembering the node v discovered last. d(u,v) is the diameter of the tree. </p>\n</blockquote>\n\n<p>Why does it work ?</p>\n\n<p>Page 2 of <a href="http://courses.csail.mit.edu/6.046/fall01/handouts/ps9sol.pdf" rel="nofollow">this</a> provides a reasoning, but it is confusing. I am quoting the initial portion of the proof:</p>\n\n<blockquote>\n  <p>Run BFS on any node s in the graph, remembering the node u discovered last. Run BFS from u remembering the node v discovered last. d(u,v) is the diameter of the tree.</p>\n  \n  <p>Correctness: Let a and b be any two nodes such that d(a,b) is the diameter of the tree. There is a unique path from a to b. Let t be the first node on that path discovered by BFS. If the paths $p_1$ from s to u and $p_2$ from a to b do not share edges, then the path from t to u includes s. So</p>\n  \n  <p>$d(t,u) \\ge d(s,u)$</p>\n  \n  <p>$d(t,u) \\ge d(s,a)$</p>\n  \n  <p>....(more inequalities follow ..)</p>\n</blockquote>\n\n<p><img src="http://i61.tinypic.com/rji9uq.png" alt=""> </p>\n\n<p>The inequalities do not make sense to me.</p>\n', 'ViewCount': '232', 'Title': 'Algorithm to find diameter of a tree using BFS/DFS. Why does it work?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-20T23:37:16.420', 'LastEditDate': '2014-03-20T13:30:18.160', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8660', 'Tags': '<algorithms><graphs><search-algorithms><graph-traversal>', 'CreationDate': '2014-03-20T07:09:10.287', 'Id': '22855'}},