{'Body': "<p>Consider an array $X$ of $n$ cells, each containing a number from $\\{1,..., n\\}$. There is at least\none duplicate number, i.e., a number that appears at least twice. I want output <em>some</em> duplicate number. When streaming we may pass over $X$ more than once. The inspection of a cell generates cost $1$. The cost of a run of an algorithm is the sum of all individual costs. I can at most store $\\log_2n$ bit numbers.\nI tried to do that with a streaming algorithm that uses additional memory $O(1)$ with costs $O(n^2)$. Is it possible to state a ramdom access algorithm that uses additional memory $O(\\log_2n)$ with costs $O(n)$?.</p>\n\n<p>Which algorithm solves the problem by using additional memory $O(1)$ with costs $O(n^2)$?.\nWhich algorithm solves the problem by using additional memory $O(\\log_2n)$ with costs $O(n)$?.</p>\n\n<p>My problem is similar to the cycle detection problem, but I don't know how to use the cycle detection problem to solve mine. Is there maybe a simpler way that I can't see now?</p>\n", 'ViewCount': '115', 'Title': 'Streaming algorithm and random access', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-03T22:21:04.637', 'LastEditDate': '2012-06-02T18:27:50.347', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1393', 'Tags': '<algorithms><randomized-algorithms><random><streaming-algorithm>', 'CreationDate': '2012-06-02T14:46:56.317', 'FavoriteCount': '2', 'Id': '2199''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>We are given a set of objects, say integers, $S$. In addition, we are given a predicate $P$, for example $P(i): \\Leftrightarrow i \\geq 0$. We don't know in advance how many elements of $S$ satisfy the predicate $P$, but we would like to sample or choose an element uniformly at random from $S' = \\{ i \\mid i \\in S \\wedge P(i) \\}$.</p>\n\n<p>The naive approach is to scan $S$ and for example record all the integers or indices for which $P$ holds, then choose one of them uniformly at random. The downside is that in the worst-case, we need $|S|$ space.</p>\n\n<p>For large sets or in say a streaming environment the naive approach is not acceptable. Is there an in-place algorithm for the problem?</p>\n", 'ViewCount': '112', 'Title': 'Choosing an element from a set satisfying a predicate uniformly at random in $O(1)$ space', 'LastActivityDate': '2012-07-21T21:45:31.217', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '2856', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<algorithms><randomized-algorithms><streaming-algorithm><in-place>', 'CreationDate': '2012-07-21T21:45:31.217', 'Id': '2855''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>The problem, coming from an interview question, is:</p>\n\n<blockquote>\n  <p>You have a stream of incoming numbers in range 0 to 60000 and you have\n  a function which will take a number from that range and return the\n  count of occurrence of that number till that moment. Give a suitable\n  Data structure/algorithm to implement this system.</p>\n</blockquote>\n\n<p>The stream is infinite, so if fixed size data structures re used, i.e. primitive types in Java or C, they will overflow. So there is the need to use data structures that have a size that grows over time. As pointed by the interviewer, the memory occupied by those data structures will diverge.</p>\n\n<p>The model of computation is a Turing machine with three tapes:</p>\n\n<ul>\n<li>infinite read-only one-way input tape;</li>\n<li>constant space bounded read-write two way work tape;</li>\n<li>infinite write-only one-way output tape.</li>\n</ul>\n\n<p>The main reason to choose the model above is that in the real world there is virtually no limit to the quantity of input that can be acquired using a keyboard or a network connection. Also, there is virtually no limit to the quantity of information that can be displayed on amonitor over time. But memory is limited and expensive.</p>\n\n<p>I modeled the problem as the problem to recognize the language L of all couples (number,number of occurrences so far).</p>\n\n<p>As a corollary of the Theorem 3.13 in Hopcroft-Ullman I know that every language recognized by a constant space bounded machine is regular.</p>\n\n<p>But, in any given moment, the language L is a finite language, because the number of couples to be recognized is finite: 60001. So I can\'t use the pumping lemma for regular languages to prove that such language is not regular.</p>\n\n<p>Is there a way I can complete my proof?</p>\n\n<p>The original question is <a href="http://stackoverflow.com/questions/11708957/find-the-count-of-a-particular-number-in-an-infinite-stream-of-numbers-at-a-part">here</a>.</p>\n', 'ViewCount': '198', 'Title': 'Counting with constant space bounded TMs', 'LastEditorUserId': '851', 'LastActivityDate': '2012-07-30T11:41:01.430', 'LastEditDate': '2012-07-30T11:41:01.430', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '2951', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<regular-languages><turing-machines><finite-automata><space-complexity><streaming-algorithm>', 'CreationDate': '2012-07-29T16:44:46.170', 'Id': '2948''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Over at <a href="http://cs.stackexchange.com/questions/3200/counting-inversion-pairs">this question about inversion counting</a>, I <a href="http://cs.stackexchange.com/questions/3200/counting-inversion-pairs#comment8724_3200">found a paper</a> that proves a lower bound on space complexity for all (exact) <a href="https://en.wikipedia.org/wiki/Streaming_algorithm">streaming algorithms</a>. I have claimed that this bound extends to all linear time algorithms. This is a bit bold as in general, a linear time algorithm can jump around at will (random access) which a streaming algorithm can not; it has to investigate the elements in order. I may perform multiple passes, but only constantly many (for linear runtime).</p>\n\n<p>Therefore my question:</p>\n\n<blockquote>\n  <p>Can every linear-time algorithm be expressed as a streaming algorithm with constantly many passes?</p>\n</blockquote>\n\n<p>Random access seems to prevent a (simple) construction proving a positive answer, but I have not been able to come up with a counter example either.</p>\n\n<p>Depending on the machine model, random access may not even be an issue, runtime-wise. I would be interested in answers for these models:</p>\n\n<ul>\n<li>Turing machine, flat input</li>\n<li>RAM, input as array</li>\n<li>RAM, input as linked list</li>\n</ul>\n', 'ViewCount': '469', 'Title': 'Is every linear-time algorithm a streaming algorithm?', 'LastActivityDate': '2012-08-16T18:15:02.147', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '3221', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<algorithms><streaming-algorithm><simulation><lower-bounds>', 'CreationDate': '2012-08-16T08:26:31.460', 'FavoriteCount': '1', 'Id': '3214''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '494', 'Title': 'Minimum space needed to sort a stream of integers', 'LastEditDate': '2012-10-22T19:53:01.833', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4315', 'FavoriteCount': '1', 'Body': '<p>This question has gotten a lot of attention on SO:<br>\n<a href="http://stackoverflow.com/questions/12748246/sorting-1-million-8-digit-numbers-in-1mb-of-ram">Sorting 1 million 8-digit numbers in 1MB of RAM</a></p>\n\n<p>The problem is to sort a stream of 1 million 8-digit numbers (integers in the range $[0,\\: 99\\mathord{,}999\\mathord{,}999]$) using only 1 MB of memory ($2^{20}$ bytes = $2^{23}$ bits) and no external storage. The program must read values from an input stream and write the sorted result to an output stream.</p>\n\n<p>Obviously the entire input can\'t fit into memory, but clearly the result can be represented in under 1 MB since $2^{23} \\geq \\log_2 \\binom{10^8}{10^6} \\approx 8079302$ (it\'s a tight fit).</p>\n\n<p>So, what is the minimum amount of space needed to sort n integers with duplicates in this streaming manner, and is there an algorithm to accomplish the specified task?</p>\n', 'Tags': '<algorithms><sorting><space-complexity><data-compression><streaming-algorithm>', 'LastEditorUserId': '4315', 'LastActivityDate': '2012-10-23T10:13:54.180', 'CommentCount': '5', 'AcceptedAnswerId': '6246', 'CreationDate': '2012-10-22T18:13:46.890', 'Id': '6236''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I want to implement efficiently "streaming Knapsack" problem in java.</p>\n\n<p>The problem is I have a stream input of integer data coming continuously for example -1, 2, 9, 5, 5, 11, 1 -3,...</p>\n\n<p>The question is to find the first "k" elements in which their sum is "n>0". for example k=3 and n=12, \nthen the solution is: ...,2,...,5, 5.</p>\n\n<p>I found an answer in <a href="http://programmingpraxis.com/2012/05/15/streaming-knapsack/2/" rel="nofollow">http://programmingpraxis.com/2012/05/15/streaming-knapsack/2/</a> \nas: (It is mainly for positive Integer Values)</p>\n\n<p>But looking for simpler one! Any Ideas?</p>\n', 'ViewCount': '200', 'Title': 'Streaming Knapsack Problem', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-07T11:30:04.040', 'LastEditDate': '2013-01-26T17:50:18.787', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6550', 'Tags': '<algorithms><optimization><streaming-algorithm><online-algorithms>', 'CreationDate': '2013-01-25T18:37:58.193', 'FavoriteCount': '1', 'Id': '9155''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>We are given an (unsorted) list $L=(a_1,\\dots,a_n)$ of numbers of size $n$, where $a_i\\in \\{ 1,\\dots,B\\}$. </p>\n\n<p>We want to find the minimum number $x$ from $\\{ 1,\\dots,B\\} \\backslash L$. </p>\n\n<blockquote>\n  <p>What is the space complexity of this problem ? (The space to store the input, $L$, does not count.) What if the input $L$ is in a stream which you can only read from left to right for at most constant number of passes ?</p>\n</blockquote>\n\n<p>The obvious way to solve this is just to copy $L$ into the working memory and then (in-place) sort $L$, and find $x$ in the obvious way. This algorithm uses space of size $n$.</p>\n\n<p>Can we do better ?</p>\n', 'ViewCount': '283', 'Title': 'Space complexity for finding the minimum number outside the list of numbers', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T17:29:27.610', 'LastEditDate': '2013-04-10T08:52:21.597', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4706', 'Tags': '<algorithms><space-complexity><streaming-algorithm>', 'CreationDate': '2013-04-09T22:56:11.750', 'FavoriteCount': '1', 'Id': '11174''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I am very familiar with error correcting codes. However, it is not obvious how to apply them to adaptive streaming data. There also doesn't seem to be much literature on the problem.</p>\n\n<p>The naive approach might be to take small codewords of data and use forward error correction until there is a statistically significant chance that the client has received them. Then, move to the next codeword.</p>\n\n<p>My question is whether there are known pitfalls with the naive approach and whether there exists a more comprehensive or performant solution (let's ignore the use of locally decodeable codes for now).</p>\n", 'ViewCount': '25', 'Title': 'Forward Error Correction for streaming data', 'LastActivityDate': '2013-07-11T06:48:18.127', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9125', 'Tags': '<streaming-algorithm><error-correcting-codes>', 'CreationDate': '2013-07-11T06:48:18.127', 'Id': '13222''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Consider an unknown function $f(x,y)$, where $x$ and $y$ are just two scalar numbers in $[0,1]$. $f(x,y)$ is an increasing function of $y$ and is between $0$ and $1$ but is unknown.</p>\n\n<p>At each time I pick a value $y$ and process a value in a stream of $x$ numbers $x_i$, $i=1, 2, ...$ and need to find the minimum $y$ such that $f(x,y)&gt;0.8$.</p>\n\n<p>Is there any principled way to optimize the choices of $y$ assuming $x_i$s does not change fast?</p>\n\n<p>It may be related more to the control theory, but I thought a solution similar to binary search may work:</p>\n\n<p>Increase $y$ if $f(x,y)&lt;0.8$ and decrease it if $f(x,y)&gt;0.8$ using a step size.\nNow to ensure fast convergence double the step size if $f(A,B)$ does not change status and halve it if it passes $0.8$.\nThe difference with <a href="http://www8.cs.umu.se/kurser/TDBAfl/VT06/algorithms/BOOK/BOOK2/NODE55.HTM" rel="nofollow">one-sided binary search</a> is that binary search will always halve the step after it passes the bound once, but here we don\'t do that as the $x$ values might change.</p>\n', 'ViewCount': '35', 'Title': 'Binary search transition point of a function on stream', 'LastActivityDate': '2014-01-21T00:06:05.153', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7133', 'Tags': '<streaming-algorithm><binary-search>', 'CreationDate': '2014-01-21T00:06:05.153', 'Id': '19858''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}