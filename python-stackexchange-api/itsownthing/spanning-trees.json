{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Why cannot I find any information about spanning tree for DAG ?  I must be wrong somewhere.</p>\n', 'ViewCount': '427', 'Title': 'Does spanning tree make sense for DAG?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-31T07:20:13.363', 'LastEditDate': '2012-03-30T10:44:36.073', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '906', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '694', 'Tags': '<graphs><graph-theory><spanning-trees>', 'CreationDate': '2012-03-30T10:43:07.210', 'Id': '897'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '638', 'Title': 'NP-completeness of a spanning tree problem', 'LastEditDate': '2012-05-18T16:16:57.077', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1108', 'FavoriteCount': '0', 'Body': '<p>I was reviewing some NP-complete problems on this site, and I meet one interesting problem from </p>\n\n<p><a href="http://cs.stackexchange.com/questions/808/np-completeness-proof-of-a-spanning-tree-problem">NP completeness proof of a spanning tree problem</a></p>\n\n<p>In this problem, I am interested in the original problem, which the leaf set is precisely $S$. The author said that he can prove this by reducing it to the Hamiltonian path. However, I still cannot figure it out. Could anybody help me with this in details?</p>\n', 'Tags': '<complexity-theory><np-complete><graph-theory><spanning-trees>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-18T16:49:04.167', 'CommentCount': '3', 'AcceptedAnswerId': '1912', 'CreationDate': '2012-04-16T03:30:50.807', 'Id': '1299'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a weighted graph $G$ has two different minimum spanning trees $T_1 = (V_1, E_1)$ and $T_2 = (V_2, E_2)$, then is it true that for any edge $e$ in $E_1$, the number of edges in $E_1$ with the same weight as $e$ (including $e$ itself) is the same as the number of edges in $E_2$ with the same weight as $e$? If the statement is true, then how can we prove it?</p>\n', 'ViewCount': '1156', 'Title': 'Do the minimum spanning trees of a weighted graph have the same number of edges with a given weight?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-14T20:29:01.367', 'LastEditDate': '2012-06-02T23:23:48.057', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2211', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<graph-theory><spanning-trees><weighted-graphs>', 'CreationDate': '2012-06-02T22:25:00.557', 'Id': '2204'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p><a href="http://en.wikipedia.org/wiki/Bor%C5%AFvka%27s_algorithm">Bor\u016fvka\'s algorithm</a> is one of the standard algorithms for calculating the minimum spanning tree for a graph $G = (V,E)$, with $|V| = n, |E| = m$.</p>\n\n<p>The pseudo-code is:</p>\n\n<pre><code>MST T = empty tree\nBegin with each vertex as a component\nWhile number of components &gt; 1\n    For each component c\n       let e = minimum edge out of component c\n       if e is not in T\n           add e to T  //merging the two components connected by e\n</code></pre>\n\n<p>We call each iteration of the outer loop a round. In each round, the inner loop cuts the number of components at least in half. Therefore there are at most $O(\\log n)$ rounds. In each round, the inner loop looks at each edge at most twice (once from each component). Therefore the running time is at most $O(m \\log n)$.</p>\n\n<p>Now suppose after each round, we remove all the edges which only connect vertices within the same component and also remove duplicate edges between components, so that the inner loop only looks at some number of edges m\' &lt; m which are the minimum weight edges which connect two previously disconnected components. </p>\n\n<p><strong>How does this optimization affect the running time?</strong></p>\n\n<p>If we somehow knew that in each round, it would cut the number of edges in half, then the running time would be significantly improved:\n$T(m) = T(m /2) + O(m) = O(m)$.</p>\n\n<p>However, while the optimization will dramatically reduce the number of edges examined, (only 1 edge by the final round, and at most # of components choose 2 in general), it\'s not clear how/if we can use this fact to tighten the analysis of the run-time. </p>\n', 'ViewCount': '374', 'Title': u"Tighter analysis of modified Bor\u016fvka's algorithm", 'LastActivityDate': '2012-07-20T08:15:16.420', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2829', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '71', 'Tags': '<algorithms><algorithm-analysis><spanning-trees>', 'CreationDate': '2012-07-18T18:53:31.420', 'FavoriteCount': '3', 'Id': '2816'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a directed graph $G=(V,E)$ and a node $r\\in V$, I need to grow a tree $T$ rooted at $r$ that has a minimum weight and spans all reachable nodes in $G$.</p>\n\n<p>The weight function assigns a non-negative weight to each node, which depends on the node's ancestors in $T$.  Specifically, for some fixed sets of nodes $S_1, S_2, \\dots, S_k \\subseteq V$, the weight of node $v$ is the number of sets $S_i$ that contain $v$ and all its ancestors in $T$.</p>\n\n<p>Any suggestion how to approach this problem?</p>\n", 'ViewCount': '141', 'Title': 'Minimum vertex-weight directed spanning tree where the weight function depends on the tree', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-13T06:27:26.233', 'LastEditDate': '2012-09-13T06:27:26.233', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2774', 'Tags': '<algorithms><graph-theory><optimization><spanning-trees>', 'CreationDate': '2012-09-10T07:57:07.253', 'FavoriteCount': '1', 'Id': '3486'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was watching the <a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-046j-introduction-to-algorithms-sma-5503-fall-2005/video-lectures/lecture-16-greedy-algorithms-minimum-spanning-trees/" rel="nofollow">video lecture from MIT on Prim\'s algorithm for minimum spanning trees</a>.\nWhy do we need to do the swap step for proving the theorem that if we choose a set of vertices  in minimum spanning tree of $G(V,E)$and let us call that $A$ such  $A\\subset B$,  the edge with the least weight connecting $A$ to $V-A$ will always be in the minimum spanning tree ?  The professor has done the swap step at point 59:07 seconds in the video.</p>\n', 'ViewCount': '179', 'Title': "Why do the swap step in Prim's algorithm for minimum spanning trees?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-20T06:52:26.807', 'LastEditDate': '2012-09-19T21:19:36.247', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4624', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2223', 'Tags': '<algorithms><graph-theory><algorithm-analysis><greedy-algorithms><spanning-trees>', 'CreationDate': '2012-09-19T13:11:11.090', 'Id': '4614'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider a graph $G(V,E)$. Each edge $e$ has two weights $A_e$ and $B_e$. Find a spanning tree that minimizes the product $\\left(\\sum_{e \\in T}{A_e}\\right)\\left(\\sum_{e \\in T}{B_e}\\right)$. The algorithm should run in polynomial time with respect to $|V|, |E|$.</p>\n\n<p>I find it difficult to adapt any of the traditional algorithms on spanning trees(Kruskal, Prim, Edge-Deletion). How to solve it? Any hints?</p>\n', 'ViewCount': '250', 'Title': 'Minimal Spanning Tree With Double Weight Parameters', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-14T05:06:23.300', 'LastEditDate': '2012-09-21T13:05:45.600', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '848', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2012-09-20T14:50:02.843', 'FavoriteCount': '6', 'Id': '4635'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A depth first search produces a spanning tree. If you perform DFS using all possible orderings of the adjacency list, wouldn't you find the minimum spanning tree? In other words, there is no example of a graph where a DFS won't find the minimum spanning tree regardless of how the adjacency list is ordered. Is this correct or not? I can't come up with a counter example and intuitively it seems correct...</p>\n", 'ViewCount': '703', 'Title': 'Depth First Search to find Minimum spanning tree', 'LastActivityDate': '2012-11-19T09:40:43.430', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4645', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2012-11-19T00:37:02.580', 'FavoriteCount': '1', 'Id': '6749'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a homework question. I do not want the solution - I'm offering the solution I've been thinking of and wish to know whether is it good or why is it flawed.</p>\n\n<p>My motivation is to find what edges of an weighted, undirected graph are not a part of any MST. This problem only makes sense when several edges have the same weight, otherwise the MST is unique.</p>\n\n<p>My idea comes from Prim's Algorithm with a slight change - instead of adding the minimum edge from S to T on every step (where S and T being the two sets of vertex) - instead look for the minimum edge and more edges of the same value going from S to the vertex the minimum edge goes to. By doing that, (so I suppose) we will receive a graph containing all the edges which appear in any MST. If this is right, I can simply XOR the edges list with the original graph edges list to find what edges are not in any MST.</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '130', 'Title': 'What edges are not in any MST', 'LastEditorUserId': '5026', 'LastActivityDate': '2012-12-11T05:49:35.473', 'LastEditDate': '2012-12-11T05:49:35.473', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5026', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-10T22:51:01.253', 'Id': '7318'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I came across a couple of solutions to one of the problems that is in the CLRS textbook (pg. 637 23.2-5 edition 3).  I am wondering if anyone can make a clarification as to the stated running time of the solution.</p>\n\n<p>Q:  Given that we know the edge weights on a graph are between $1$ and some constant $W$, how fast can we make Prim's algorithm run?</p>\n\n<p>Solution:</p>\n\n<ul>\n<li>Uses an array of linked lists where each index corresponds to a given weight [$1\\dots W + 1$]</li>\n<li>Each link linked lists contains a series of vertices with the weight of the index as their key</li>\n</ul>\n\n<p>The run time given is $O(E)$</p>\n\n<p>They break it down as follows:</p>\n\n<p>$O(1)$ to find the vertex with smallest weight\n       - I understand this part since we scan at most $W$ array slots to find a non-empty list and $W$ is constant.</p>\n\n<p>$O(1)$ for decrease key\n     - This makes sense as far as the actual removing of a link from one list and inserting it into another</p>\n\n<p>My question is about the decrease key step.  Say for example we pull the node $A$ from the 3rd slot, that is the next node to be processed.  We look at $A$'s adjacency matrix and see that it has edges to $B, C, F$.  Since we are using linked lists we have no choice other than to look at all array slots from $4$ to $W$ and see if we can find the vertices listed in the linked list for that particular index. Then delete the vertex from its current list and add it to the correct list if we find it. Possible search time = $O(V)$ [since we store vertices in the linked lists and could search all before finding our desired vertex] not $O(1)$.</p>\n\n<p>Since each decrease key takes $O(V)$ and we process all vertices running time = $O(V^2)$.  </p>\n\n<p>If anyone could let me know where I am going astray in my analysis I would greatly appreciate it.</p>\n", 'ViewCount': '489', 'Title': 'Question about Prims algorithm where weights are between 1 and some constant W', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-14T22:17:34.860', 'LastEditDate': '2013-01-14T22:17:34.860', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'cpowel2', 'PostTypeId': '1', 'OwnerUserId': '5050', 'Tags': '<algorithms><graph-theory><runtime-analysis><spanning-trees>', 'CreationDate': '2012-12-11T18:43:12.797', 'Id': '7345'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given an undirected weighted graph $G$ with two edges of minimum weight and all other edges are distinct. Does G have a unique minimum spanning tree?</p>\n\n<p>I know the proof for if all edge weights are distinct (it does give a unique MST) and I am thinking that if two edges of minimum weight are in $G$ then I should be able to show a counter example. But so far I have not been able to produce one.</p>\n\n<p>So my question is does it give a unique MST if the graph $G$ contains two minimum weight edges?</p>\n', 'ViewCount': '1396', 'Title': 'Minimum spanning tree with two minimum edge weights', 'LastActivityDate': '2013-04-17T10:28:33.490', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '512', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2012-12-15T18:14:13.453', 'FavoriteCount': '1', 'Id': '7414'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Just a quick question,</p>\n\n<p>If i were to alter the general DFS algorithm to do this:</p>\n\n<pre><code>minDFS(Vertex v)\n{\n   if (!v.getVisted())\n   {\n       v.setVisited();\n       Vertex temp = findClosestVertex();\n       graph.addEdge(v, temp);\n       minDFS(temp);\n   }\n}\n</code></pre>\n\n<p>Would I eventually (at the end of DFS) get  minimum spanning tree? I know there are other ways of getting the MST (Kruskal's, Prim's etc..),but I was just wondering if this would work.</p>\n", 'ViewCount': '88', 'Title': 'DFS miniumum spanning tree', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T10:04:43.703', 'LastEditDate': '2013-03-25T10:04:43.703', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10721', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7381', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2013-03-23T19:28:16.987', 'Id': '10717'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose all costs on edges are distinct. How many minimal spanning trees are possible?</p>\n\n<p>I dont know if this question is supposed to be easy or hard, but all I can come up with is one, because Kruskal's, and any other greedy algorithm should choose all the smallest weighted edges first. Then, if all weights on all edges are distinct, then there are no two equivalently weighted minimum spanning trees if a greedy algorithm is used.</p>\n", 'ViewCount': '1057', 'Title': 'How many minimal spanning trees are there when all edge costs are distinct?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-27T16:47:34.527', 'LastEditDate': '2013-03-25T10:19:10.033', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '10731', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2013-03-24T02:05:51.303', 'Id': '10728'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1087', 'Title': 'Graph Has Two / Three Different Minimal Spanning Trees?', 'LastEditDate': '2013-05-15T20:00:02.037', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8202', 'FavoriteCount': '0', 'Body': "<p>I'm trying to find an efficient method of detecting whether a given graph G has two different minimal spanning trees. I'm also trying to find a method to check whether it has 3 different minimal spanning trees. The naive solution that I've though about is running Kruskal's algorithm once and finding the total weight of the minimal spanning tree. Later , removing an edge from the graph and running Kruskal's algorithm again and checking if the weight of the new tree is the weight of the original minimal spanning tree , and so for each edge in the graph. The runtime is O(|V||E|log|V|) which is not good at all, and I think there's a better way to do it.</p>\n\n<p>Any suggestion would be helpful, thanks in advance</p>\n", 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-17T21:55:27.857', 'CommentCount': '5', 'AcceptedAnswerId': '12058', 'CreationDate': '2013-05-15T18:45:13.007', 'Id': '12048'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $T$ be a depth-first search tree of a connected undirected graph $G$ and $h$ be the height of $T$. How do you show that $G$ has no more than $h \\times |V|$ edges where $|V|$ is the number of vertices in $G$? </p>\n', 'ViewCount': '75', 'Title': 'Upper bound on the number of edges relative to the height of a DFS tree', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-26T12:42:38.160', 'LastEditDate': '2013-06-26T12:42:38.160', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12852', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2013-06-23T22:54:36.937', 'Id': '12851'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>According to CLRS, the Prim's algorithms is implemented as below -- </p>\n\n<blockquote>\n  <p>$\\mathtt{\\text{MST-PRIM}}(G,w,r)$  </p>\n  \n  <ul>\n  <li>for each $u \\in V[G]$ do<br>\n  <ul>\n  <li>$\\mathtt{\\text{key}}[u] \\leftarrow \\infty$  </li>\n  <li>$\\pi[u] \\leftarrow \\mathtt{\\text{NIL}}$ </li>\n  </ul></li>\n  <li>$\\mathtt{\\text{key}}[r] \\leftarrow 0$  </li>\n  <li>$Q \\leftarrow V[G]$  </li>\n  <li>while $Q \\ne \\emptyset$ do // ... $O(V)$\n  <ul>\n  <li>$u$ $\\leftarrow$ $\\mathtt{\\text{EXTRACT-MIN}}(u)$ // ... $O(\\lg V)$<br>\n  <ul>\n  <li>for each $v \\in \\mathtt{\\text{adj}}[u]$ do // ... $O(E)$<br>\n  <ul>\n  <li>if $v \\in Q$ and $w(u,v) \\gt \\mathtt{\\text{key}}[v]$\n  <ul>\n  <li>then $\\pi[v] \\leftarrow u$\n  <ul>\n  <li>$\\mathtt{\\text{key}} \\leftarrow w(u,v)$ // $\\mathtt{\\text{DECREASE-KEY}}$ ... $O(\\lg V)$</li>\n  </ul></li>\n  </ul></li>\n  </ul></li>\n  </ul></li>\n  </ul></li>\n  </ul>\n</blockquote>\n\n<p>The book says the total complexity is $O(V \\lg V + E \\lg V) \\approx O(E \\lg V)$. However, what I understood is that the inner <code>for</code> loop with the <code>DECREASE-KEY</code> operation will cost $O(E \\lg V)$, and the outer <code>while</code> loop encloses both the <code>EXTRACT-MIN</code> and the inner <code>for</code> loop, so the total complexity should be $O(V (\\lg V + E \\lg V)) = O(V \\lg V + EV \\lg V) \\approx O(EV \\lg V)$. </p>\n\n<p>Why the complexity analysis is not performed as such? and What is wrong with my formulation?</p>\n", 'ViewCount': '534', 'Title': "MST: Prim's algorithm complexity, why not $O(EV \\lg V)$?", 'LastActivityDate': '2013-08-05T06:45:45.717', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13609', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7678', 'Tags': '<algorithms><algorithm-analysis><spanning-trees>', 'CreationDate': '2013-08-05T05:59:33.073', 'FavoriteCount': '1', 'Id': '13608'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm given this problem:</p>\n\n<p>Consider the following closest-point heuristic for building an approximate traveling-salesman  tour. Begin with a trivial cycle consisting of a single arbitrarily chosen vertex. At each step, identify the vertex u that is not on the cycle but whose distance to any vertex on the cycle is minimum. Suppose that the vertex on the cycle that is nearest u is vertex v. Extend the cycle to include u by inserting u just after v. Repeat until all vertices are on the cycle. Prove that this heuristic returns a tour whose total cost is not more than twice the cost of an optimal tour. </p>\n\n<p>This is the same as Prim's algorithm.  Unless I'm missing something, this is not an approximate traveling salesman tour since the traveling salesman requires a Hamiltonian path where we don't revisit any nodes, but on many graphs this algorithm seems to require revisiting nodes to get back to the source node.  Am I wrong or is this problem unclearly worded?</p>\n", 'ViewCount': '120', 'Title': "Traveling Salesman's Tour Approx Algorithm: is this really a Hamiltonian Path?", 'LastActivityDate': '2013-11-19T10:58:35.200', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18152', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11474', 'Tags': '<traveling-salesman><spanning-trees><approximation-algorithms>', 'CreationDate': '2013-11-19T06:43:05.060', 'Id': '18147'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose we have a graph $H$, where each vertex represents a spanning tree of another graph $G$.</p>\n\n<p>We create an edge between 2 vertices in $H$ if $ST_1$ (spanning tree) contains exactly one edge not in $ST_2$ (and vice versa).</p>\n\n<p>How do we show that $H$ is connected?</p>\n', 'ViewCount': '60', 'Title': 'Showing that graph of spanning trees are connected', 'LastEditorUserId': '9863', 'LastActivityDate': '2013-11-25T14:57:33.637', 'LastEditDate': '2013-11-25T14:36:00.353', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11608', 'Tags': '<graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-11-25T13:29:31.623', 'Id': '18325'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What is the difference between minimum spanning tree algorithm and a shortest path algorithm?</p>\n\n<p>In my data structures class we covered two minimum spanning tree algorithms (Prim's and Kruskal's) and one shortest path algorithm (Dijkstra's). </p>\n\n<p>Minimum spanning tree is a tree in a graph that spans all the vertices and total weight of a tree is minimal. Shortest path is quite obvious, it is a shortest path from one vertex to another. </p>\n\n<p>What I don't understand is since minimum spanning tree has a minimal total weight, wouldn't the paths in the tree be the shortest paths? Can anybody explain what I'm missing?</p>\n\n<p>Any help is appreciated.</p>\n", 'ViewCount': '530', 'Title': 'Minimum spanning tree vs Shortest path', 'LastActivityDate': '2013-12-10T10:12:43.997', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<shortest-path><spanning-trees>', 'CreationDate': '2013-12-09T22:57:57.720', 'Id': '18797'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This problem is from the book <a href="http://cseweb.ucsd.edu/users/dasgupta/book/index.html" rel="nofollow">Algorithms, Chapter 5: Greedy algorithms</a>. In case of being closed as a duplication to that in <a href="http://stackoverflow.com/questions/13127446/minimum-spanning-tree-subgraph">Minimum Spanning tree subgraph</a>, I will first make a defense:</p>\n\n<ul>\n<li>The accepted solution at <a href="http://stackoverflow.com/questions/13127446/minimum-spanning-tree-subgraph">Minimum Spanning tree subgraph</a> <strong>is</strong> still in dispute.</li>\n<li>The solution given by <code>eh9</code> seems to be related with the Kruskal MST algorithm.</li>\n<li>I am seeking for a general (and easy) solution.</li>\n</ul>\n\n<p>The problem is as follows:</p>\n\n<blockquote>\n  <p>Let $T$ be an MST of graph $G$. Given a connected subgraph $H$ of $G$, show that $T \\cap H$ is contained in some MST of $H$.</p>\n</blockquote>\n\n<p>My partial trial is <em>by contradiction</em>:</p>\n\n<blockquote>\n  <p>Suppose that $T \\cap H$ is not contained in any MST of $H$. That is to say, for any MST of $H$ (denoted $MST_{H}$), there exists an edge $e$ such that $e \\in T \\cap H$, and however, $e \\notin MST_{H}$.<br>\n  Now we can add $e$ to $MST_{H}$ to get $MST_{H} + {e}$ which contains a cycle (denoted $C$). </p>\n  \n  <ul>\n  <li>Because $MST_{H}$ is a minimum spanning tree of $H$ and $e$ is not in $MST_{H}$, we have that every other edge $e\'$ than $e$ in the cycle $C$ has weight no greater than that of $e$ (i.e., $\\forall e\' \\in C, e\' \\neq e. w(e\') \\le w(e)$).</li>\n  <li>There exists at lease one edge (denoted $e\'\'$) in $C$ other than $e$ which is not in $T$. Otherwise, $T$ contains the cycle $C$. </li>\n  </ul>\n  \n  <p>Now we have $w(e\'\') \\le w(e)$ and $e \\in T \\land e\'\' \\notin T$, $\\ldots$</p>\n</blockquote>\n\n<p>As you see, I failed to continue with the above argument. Therefore, my problem here is:</p>\n\n<blockquote>\n  <ul>\n  <li>Is my argument by contradiction feasible so far? </li>\n  <li>And, how to draw the contradiction to complete the argument?</li>\n  </ul>\n</blockquote>\n', 'ViewCount': '178', 'Title': 'Minimum spanning tree and its connected subgraph', 'LastEditorUserId': '4911', 'LastActivityDate': '2013-12-12T23:34:15.087', 'LastEditDate': '2013-12-11T15:25:56.723', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2013-12-11T08:02:14.180', 'Id': '18867'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For my homework I have a problem that I can't solve and it makes me wonder about 2 different MST:</p>\n\n<blockquote>\n  <p>Let $G=(V,E)$ be a graph that has a minimum spanning tree $T$.</p>\n  \n  <p>I want to find another minimum spanning tree $T'$ that has at least 1 different edge $e'$\n  such that the weight of $e'$ is differ from any weight of edges in $T$.</p>\n</blockquote>\n\n<p>If $T'$ doesn't exist I can claim that every 2 different MST must have the same weight for each edge. </p>\n\n<p>My intuition says that this claim is wrong but on the other hand I can't find example of $T'$ to contradict this claim.</p>\n", 'ViewCount': '72', 'Title': 'Find a diffrent minimal spanning tree for a graph', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-19T10:57:54.237', 'LastEditDate': '2013-12-19T10:57:54.237', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19116', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9292', 'Tags': '<algorithms><graph-theory><graphs><spanning-trees>', 'CreationDate': '2013-12-16T17:31:17.433', 'Id': '19049'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let G be a weighted undirected graph and e be an edge with maximum weight in G.Suppose there is a minimum weight spanning tree in G containing the edge e.Which of the following statements is always TRUE?</p>\n\n<p>1.There exists a cut in g having all edges if maximum weight</p>\n\n<p>2.There exists a cycle in G having all edges of maximum weight</p>\n\n<p>3.Edge e can not be contained in a cycle </p>\n\n<p>4.All edges in G have the same weight </p>\n\n<p>i think Option 4 and 1 is correct but which is always true .and what is the meaning of option 3.Can any body remove my confusion ??</p>\n', 'ViewCount': '46', 'Title': 'Satisfying condition to be in minimum spanning tree of an edge (maximum weight)', 'LastActivityDate': '2013-12-24T10:44:53.143', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19241', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12340', 'Tags': '<algorithms><graph-theory><trees><spanning-trees>', 'CreationDate': '2013-12-24T10:26:51.827', 'Id': '19239'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is there any example that anybody could come up  with that shows Prim's algorithm does not always give the correct result when it comes knowing the minimal spanning tree.</p>\n", 'ViewCount': '137', 'Title': "Minimal Spanning tree and Prim's Algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-05T17:28:24.357', 'LastEditDate': '2014-01-05T17:28:24.357', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '19309', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<algorithms><greedy-algorithms><spanning-trees>', 'CreationDate': '2013-12-26T17:49:25.153', 'Id': '19306'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>what is the reason for the correctness proof of Prim's Algorithm for the undirected case cannot carry over to the directed case?</p>\n\n<p>Is it because of after any number of steps, $S$ might not be in a sub tree of an MST since it depends upon the direction of the edge of the directed graph, unlike the undirected one?</p>\n", 'ViewCount': '111', 'ClosedDate': '2014-01-05T17:29:58.513', 'Title': "Proof of Correctness of Prim's algorithm", 'LastEditorUserId': '7269', 'LastActivityDate': '2013-12-31T16:22:53.543', 'LastEditDate': '2013-12-31T13:52:39.337', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7269', 'Tags': '<graph-theory><correctness-proof><greedy-algorithms><spanning-trees>', 'CreationDate': '2013-12-31T12:55:44.063', 'Id': '19405'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am working on the following problem:</p>\n\n<blockquote>\n  <p>Suppose that $T$ is a spanning tree of a graph $G$, with an edge cost function $c$.  Let $T$ have the <em>cycle property</em> if for any edge $e\' \\not \\in T, c(e\') \\geq c(e)$ for all $e$ in the cycle generated by adding $e\'$ to $T$.  Let  $T$ have the <em>cut property</em> if for any edge $e \\in T$, $c(e) \\leq c(e\')$ for all $e\'$ in the cut defined by $e$.</p>\n  \n  <p>Show that the following three properties are equivalent </p>\n  \n  <ol>\n  <li>T has the cycle property, </li>\n  <li>T has the cut property, and </li>\n  <li>T is a minimum cost spanning tree.</li>\n  </ol>\n</blockquote>\n\n<p>I believe that to show that 3. implies 1., we suppose otherwise, and then show that this would give a cycle with an edge that can replace another edge in T and that is cheaper, whence we have a contradiction.  Similarly, I believe to show that 3. implies 2., we similarly suppose otherwise, and then show that this would give a cut with an edge that can replace another edge in T and that is cheaper, whence a contradiction.</p>\n\n<p>However, I am not sure how to prove the other implications needed for this problem.  My feeling is to somehow use a similar argument to what I listed, but "in reverse".</p>\n\n<p>Any help with this problem would be greatly appreciated.</p>\n', 'ViewCount': '96', 'Title': 'Spanning Tree - Equivalent Properties', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T11:47:57.600', 'LastEditDate': '2014-01-21T08:21:15.430', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12985', 'Tags': '<graph-theory><spanning-trees>', 'CreationDate': '2014-01-20T22:19:12.643', 'Id': '19855'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we were using a priority queue(PQ) to implement Prim's algorithm. My understanding is that initially the weight of all vertices is set to $\\infty$. The weight of the starting vertex is then set to 0. All of the vertices are then inserted into the PQ. </p>\n\n<p>1) Does that mean that we can insert the vertices in any order into the PQ? </p>\n\n<p>2) Given that we can insert the vertices in any order, suppose we have a graph with the<br>\n$\\quad$following vertices a, b and c and the following weights w(a,$\\,$b) = 1, w(a,$\\,$c ) = 2. Once we set a.key = 0 $\\quad$and then extract a from PQ, we have b.key = 1 and c.key = 2. Given the answer to (1) was yes,my<br>\n$\\quad$understanding would be that in a binary tree representation of the heap, b would now be the root and c<br>\n$\\quad$would be a child of b. However, depending on the order in which the a, b and<br>\n$\\quad$c were added to the heap, c could be either the left or right child of b, right?</p>\n\n<p>3) Suppose now that the graph has vertices a, b, c, d and edges (a, b), (a, c), (a, d). Suppose they were<br>\n$\\quad$inserted into the heap in the order a, b, c, d. The binary tree representation of the heap should then be:       </p>\n\n<p>$\\quad\\quad$ a is the root, left(a) = b, right(a) = c, left(b) = d    </p>\n\n<p>$\\quad$ So, that would mean that the parent-child relationships do not correspond to the parent-child<br>\n$\\quad$ relationships in the original graph and they don't have to, right? </p>\n", 'ViewCount': '98', 'Title': "Prim's Algorithm - Building the Priority Queue", 'LastEditorUserId': '8639', 'LastActivityDate': '2014-02-19T15:22:41.730', 'LastEditDate': '2014-02-19T15:22:41.730', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8639', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2014-02-19T05:32:02.400', 'FavoriteCount': '1', 'Id': '21801'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that depth-first search can be used to produce a depth-first spanning tree, which classifies all edges as tree edges, forward edges, backward edges or cross edges. Are there any algorithms that make use of the depth-first spanning tree?</p>\n', 'ViewCount': '78', 'Title': 'Applications of Depth-First Spanning Tree', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-20T15:01:48.333', 'LastEditDate': '2014-02-20T11:08:14.503', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14872', 'Tags': '<algorithms><graphs><graph-traversal><spanning-trees>', 'CreationDate': '2014-02-20T07:12:38.657', 'Id': '21839'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to solve this problem: We have weighted $n$-node undirected graph $G = (V,E)$ and a positive integer $k$. We can reach all vertices from vertex 1 (the root). We need to find the weight of minimal spanning tree in which the degree of vertex 1 is at most $k$ (we don\'t care about other vertices\' degrees). We can assume that such a tree exists.</p>\n\n<p>Can someone give an idea how to approach the solution?</p>\n\n<p>What I\'ve already tried:</p>\n\n<p>1) I know how to find essential edges from vertex 1. We can use dfs and start from a random edge of vertex 1. When we return to vertex 1 we can check if this edge (another vertex 1 edge) has lower weight than the previous one. If yes, than the previous one is not essential.</p>\n\n<p>2) After that I wanted to use Kruskal\'s algorithm (adding in the beginning of the algorithm all essential edges). But the problem is that sometimes we should not take an edge with minimal weight to construct the required tree. </p>\n\n<p>For example: 9-node undirected graph, $k = 3$</p>\n\n<pre><code>(vertex1 vertex2 weight)\n1 2 1\n2 3 5\n3 4 6\n4 5 7\n5 1 1\n1 6 1\n6 7 8\n7 8 9\n8 9 10\n9 1 2\n</code></pre>\n\n<p>So essentials will be (1,2) and (1, 6) (or (1, 5) and (1,6)). Kruskal will take (1,5) (or (1,2)) anyway. And the weight will be 41, but the correct answer is 39.\nSo I don\'t know how to use Kruskal\'s algorithm here. </p>\n\n<p>(The same example visualized, vertex 1 = vertex A)</p>\n\n<p><img src="http://i.stack.imgur.com/ud2Xc.png" alt="The same example visualized"></p>\n\n<p>I thought that we may construct a minimal spanning tree without constraints and after that try to transform it to the required one, but I don\'t know how to do this (how to transform without brute force).</p>\n', 'ViewCount': '146', 'Title': 'Minimal spanning tree with degree constraint', 'LastEditorUserId': '15839', 'LastActivityDate': '2014-03-19T20:17:49.750', 'LastEditDate': '2014-03-19T11:20:15.890', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15839', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2014-03-18T21:45:52.923', 'FavoriteCount': '2', 'Id': '22775'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The question is as follows:\nTrue or False: For every non-directed connected non-weighted graph and for every spanning tree T of the graph there exists a vertex v such that T is a DFS tree with the root v.</p>\n\n<p>What about if instead of DFS I used BFS?</p>\n\n<p>I have no clue where to begin with this one. I feel like I'm overlooking some basic characteristic of the algorithm or the tree that it produces. Any help would be appreciated!</p>\n", 'ViewCount': '28', 'Title': 'Question about spanning trees and creating them through BFS and/or DFS algorithms', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-26T23:45:56.843', 'LastEditDate': '2014-03-26T23:45:56.843', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15977', 'Tags': '<algorithms><graph-theory><spanning-trees>', 'CreationDate': '2014-03-26T22:08:28.540', 'FavoriteCount': '2', 'Id': '23101'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If given that all edges in a graph $G$ are of equal weight $c$, can one use breadth-first search (BFS) in order to produce a minimal spanning tree in <strong>linear time</strong>?</p>\n\n<p>Intuitively this sounds correct, as BFS does not visit a node twice, and it only traverses from vertex $v$ to vertex $u$ iff it hasn't visited $u$ before, such that there aren't going to be any cycles, and if $G$ is connected it will eventually visit all nodes. Since the weight of all edges is equal, it doesn't matter which edges the BFS chose.</p>\n\n<p>Does my reasoning make any sense?</p>\n", 'ViewCount': '318', 'Title': 'If all edges are of equal weight, can one use BFS to obtain a minimal spanning tree?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-03-29T19:58:59.877', 'LastEditDate': '2014-03-29T19:58:59.877', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23181', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<algorithms><graphs><spanning-trees>', 'CreationDate': '2014-03-28T13:34:40.343', 'Id': '23179'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The $k$-bounded spanning tree problem is where you have an undirected graph $G(V,E)$ and you have to decide whether or not it has a spanning tree such that each vertex has a degree of at most $k$.</p>\n\n<p>I realize that for the case $k=2$, this is the Hamiltonian path problem. However I'm having trouble with cases where $k&gt;2$. I tried thinking about it in the sense that you can add more nodes onto an existing spanning tree where $k=2$ and maybe since the base is NP complete, adding things on will make it NP-complete as well, but that doesn't seem right. I'm self-studying CS and am having trouble with theory, so any help will be appreciated!</p>\n", 'ViewCount': '141', 'Title': 'Why is the k-bounded spanning tree problem NP-complete?', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-30T06:54:45.953', 'LastEditDate': '2014-04-30T06:54:45.953', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24247', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '17199', 'Tags': '<spanning-trees>', 'CreationDate': '2014-04-30T01:56:50.577', 'Id': '24246'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know that leaf-bound-MST is NP-complete by reducing two-leaf-MST to Hamiltonian Path. However, I don't know how to reduce 10-leaf-MST problem (MST with exactly 10-leaf) to a existing NP-complete problem.\nThanks!</p>\n", 'ViewCount': '30', 'ClosedDate': '2014-05-01T02:41:39.773', 'Title': 'How to prove 10-leaf-MST is NP-complete?', 'LastActivityDate': '2014-05-01T01:38:50.957', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17235', 'Tags': '<np-complete><spanning-trees><hamiltonian-path>', 'CreationDate': '2014-05-01T01:38:50.957', 'FavoriteCount': '1', 'Id': '24284'}