{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '529', 'Title': 'Does a never-halting machine always loop?', 'LastEditDate': '2012-07-18T10:09:48.590', 'AnswerCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2157', 'FavoriteCount': '2', 'Body': "<p>A Turing machine that returns to a previously encountered state with its read/write head on the same cell of the exact same tape will be caught in a loop. Such a machine doesn't halt.</p>\n\n<p>Can someone give an example of a never-halting machine that doesn't loop?</p>\n", 'Tags': '<computability><turing-machines><halting-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T10:09:48.590', 'CommentCount': '4', 'AcceptedAnswerId': '2730', 'CreationDate': '2012-07-13T15:18:18.840', 'Id': '2728'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/266/why-are-the-total-functions-not-enumerable">Why are the total functions not enumerable?</a>  </p>\n</blockquote>\n\n\n\n<p>Are there programming languages that allow to express every algorithm that terminates but no nonterminating programs?</p>\n\n<p>I always thought that algorithms like the ackerman function are impossible to implement in such a model, but I recently learned that there are indeed programming languages that guarantee termination and have the capability to calculate the ackerman function.</p>\n\n<p>This might be related to the halting problem, but I don\'t exactly see how the unability to determine it might make such a language impossible.</p>\n', 'ViewCount': '35', 'ClosedDate': '2012-07-26T21:17:48.327', 'Title': 'Are there programming languages that allow the expression of exactly all terminating algorithms?', 'LastActivityDate': '2012-07-26T21:01:57.657', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<programming-languages><halting-problem>', 'CreationDate': '2012-07-26T21:01:57.657', 'Id': '2918'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove that </p>\n\n<p>$L_1=\\{\\langle M\\rangle \\mid M \\text{ is a Turing machine and visits } q_0 \\text{ at least twice on } \\varepsilon\\} \\notin R$.</p>\n\n<p>I'm not sure whether to reduce the halting problem to it or not. I tried to construct a new machine $M'$ for $(\\langle M \\rangle,w)$, such that $M'$ visits $q_0$ twice, iff $M$ halts on $w$. This is specific $q_0$ given to me, but I didn't come to any smart construction, which would yield the requested. Maybe it's easier to show that it's $RE$ and not $coRE$? It is obvious that it's in $RE$, and I need to show that $L_2^{c}$ is not in $RE$.</p>\n\n<p>What should I do?</p>\n", 'ViewCount': '134', 'Title': 'Showing that the set of TMs which visit the starting state twice on the empty input is undecidable', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-08-02T05:53:06.110', 'LastEditDate': '2012-08-01T15:00:46.580', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2984', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-08-01T12:41:06.703', 'Id': '2981'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>We know the halting problem (on Turing Machines) is undecidable for Turing Machines. Is there some research into how well the human mind can deal with this problem, possibly <em>aided</em> by Turing Machines or general purpose computers?</p>\n\n<p><em>Note</em>: Obviously, in the strictest sense, you can always say no, because there are Turing Machines so large they couldn't even be read in the life span of a single human. But this is a nonsensical restriction that doesn't contribute to the actual question. So to make things even, we'd have to assume humans with an arbitrary life span.</p>\n\n<p>So we could ask: Given a Turing Machine T represented in any suitable fashion, an arbitrarily long-lived human H and an arbitrary amount of buffer (i.e. paper + pens), can H decide whether T halts on the empty word?</p>\n\n<hr>\n\n<p><em>Corollary: If the answer is yes, wouldn't this also settle if any computer has a chance of passing the turing-test?</em></p>\n", 'ViewCount': '1255', 'Title': 'Human computing power: Can humans decide the halting problem on Turing Machines?', 'LastActivityDate': '2013-05-18T19:19:20.827', 'AnswerCount': '7', 'CommentCount': '10', 'Score': '21', 'PostTypeId': '1', 'OwnerUserId': '26', 'Tags': '<computability><turing-machines><halting-problem><human-computing>', 'CreationDate': '2012-08-21T10:46:52.483', 'FavoriteCount': '6', 'Id': '3271'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>"Alan Turing proved in 1936 that a general algorithm to solve the\n  halting problem for <em>all</em> possible program-input pairs cannot exist"</p>\n</blockquote>\n\n<p>Can I find a general algorithm to solve the halting problem for <em>some</em> possible program input pairs? </p>\n\n<p>Can I find a programming language (or languages), where I for every kind of program in this language, it can decide if the program terminates or run forever?</p>\n', 'ViewCount': '654', 'Title': u'Algorithm to solve Turing\'s "Halting problem\u200d\u200b"', 'LastEditorUserId': '41', 'LastActivityDate': '2013-04-05T11:21:40.253', 'LastEditDate': '2012-10-03T19:12:15.243', 'AnswerCount': '6', 'CommentCount': '3', 'Score': '11', 'OwnerDisplayName': 'user11775', 'PostTypeId': '1', 'Tags': '<computability><formal-methods><halting-problem><software-verification>', 'CreationDate': '2011-12-08T17:52:03.623', 'FavoriteCount': '3', 'Id': '4856'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What problem does the halting problem solve in computing, whether theoretical or practical?</p>\n\n<p>It is very easy to debug code which loops forever, just signal the debugger to break if the program is running for too long? What purpose / good is the halting problem? Why was Turing praised for it?</p>\n', 'ViewCount': '316', 'Title': 'What helpful solution does the Halting Problem give to computing?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-04T10:03:22.663', 'LastEditDate': '2012-10-04T10:03:22.663', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '4869', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3051', 'Tags': '<computability><terminology><halting-problem>', 'CreationDate': '2012-10-03T21:42:54.827', 'Id': '4867'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>$L_0 = \\{ \\langle M, w, 0 \\rangle \\mid \\text{$M$ halts on $w$}\\}$ <br>\n  $L_1 = \\{ \\langle M, w, 1 \\rangle \\mid \\text{$M$ does not halt on  $w$}\\}$</p>\n  \n  <p>$L = L_0 \\cup L_1$</p>\n</blockquote>\n\n<p>I need to determine where in the hierarchy of languages (recursive, recursively enumerable, not recursively enumerable) $L$ and its complement $\\overline L$ belong. I reasoned as follows</p>\n\n<p>$L = \\{ \\langle M, w, x\\rangle  \\mid \\text{$M$ halts on $w$ when $x=0$, $M$ doesn't halt on $w$ when $x = 1$, $x \\in \\{0, 1\\}$}\\}$</p>\n\n<p>$L$ is clearly not recursively enumerable as a Turing machine wouldn't be able accept in all cases.  It can accept only in case the input refers to $L_0$, but can't in case the input refers to $L_1$.</p>\n\n<p>$\\overline L = \\overline L_0 \\cap \\overline L_1 = \\emptyset$<br>\nThus $\\overline L$ is recursive.</p>\n\n<p>Is my reasoning ok? This is a question from a previous exam paper.</p>\n", 'ViewCount': '121', 'Title': 'Determining the classification of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-26T14:27:29.443', 'LastEditDate': '2012-10-26T14:27:29.443', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6310', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><turing-machines><undecidability><halting-problem>', 'CreationDate': '2012-10-25T13:39:53.527', 'Id': '6309'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a book that proves the halting problem with this simple statement:</p>\n\n<p>$$\nA_\\text{TM} \\le_m  \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon\n$$</p>\n\n<p>It states that halting problem reduces to the language consisting of $\\langle M, \\omega \\rangle$ for which a Turing machine $M$ accepts $\\omega$ is undecidable.</p>\n\n<p>What does this mean? What does the notation $\\le_m$ indicate?</p>\n', 'ViewCount': '88', 'Title': 'Why does $A_\\text{TM} \\le_m \\text{HALTING} \\le_m \\text{HALTING}^\\varepsilon$?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-12T09:28:48.157', 'LastEditDate': '2012-11-07T20:47:20.573', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '7902', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2012-11-07T19:55:12.923', 'Id': '6541'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Here\'s a lab from a first-year computer science course, taught in Scheme: <a href="https://www.student.cs.uwaterloo.ca/~cs135/assns/a07/a07.pdf">https://www.student.cs.uwaterloo.ca/~cs135/assns/a07/a07.pdf</a></p>\n\n<p>At the end of the lab, it basically presents the halting problem, and shows that it is impossible to solve by introducing the function <code>diagonal</code>, which is defined as:</p>\n\n<pre><code>(de\ufb01ne (diagonal x)\n  (cond\n     [(halting? x x) (eternity 1)]\n     [else true]))\n</code></pre>\n\n<p>Where <code>eternity</code> is a non-terminating program defined as <code>(define (eternity x) (eternity x))</code>. What happens when you feed <code>diagonal</code> its own definition as input ... ?</p>\n\n<p>This is all fairly standard stuff. Then, the lab says: </p>\n\n<blockquote>\n  <p>For a real challenge, de\ufb01nitively answer the question posed at the end of Exercise 20.1.3 of the\n  text, with the interpretation that function=? consumes two lists representing the code for the two\n  functions. This is the situation Church considered in his proof.</p>\n</blockquote>\n\n<p>So the gist of it is that <code>function=?</code> takes two inputs. Each is a list, which represents the definition of a function, i.e. it is a list of the form <code>(define (id args ...) body ...)</code>. We can assume that both functions are syntactically valid and will terminate for all inputs (without runtime errors). <code>function=?</code> returns true if and only if the two functions will always return the same result when given the same inputs. For example,</p>\n\n<pre><code>(function=? \'(define (foo x) (* 2 x)) \n            \'(define (bar x) (+ x x))) ; should return #t\n\n(function=? \'(define (foo x) (+ x 1)) \n            \'(define (bar x) (+ x 2))) ; should return #f\n</code></pre>\n\n<p>Now, <code>function=?</code> is obviously impossible to write - the challenge is to <em>prove</em> it is impossible. I thought about this for a while, and the best solution I could come up with is the following:</p>\n\n<pre><code>(define (disprove-function=? x)\n  ((lambda (snip)\n     (let ((self (list \'define \'(disprove-function=? x)\n                       (list snip (list \'quote snip)))))\n       (if (function=? self \'(define (id x) x))\n           (list x)\n           x)))\n   \'(lambda (snip) \n      (let ((self (list \'define \'(disprove-function=? x)\n                        (list snip (list \'quote snip)))))\n        (if (function=? self \'(define (id x) x))\n            (list x)\n            x)))))\n</code></pre>\n\n<p>Basically, <code>disprove-function=?</code> uses standard quining techniques to generate its own source code (the variable <code>self</code>), and then asks <code>function=?</code> if it is equivalent to the identity function. If <code>function=?</code> says #f, then <code>disprove-function=?</code> will always behave like the identity function. Contradiction! If <code>function=?</code> says #t, then <code>disprove-function=?</code> will always behave differently from identity; in particular, it will behave like the <code>list</code> function. Contradiction! Thus, <code>function=?</code> can\'t exist. QED.</p>\n\n<p>My question is: is there a more elegant way to approach this problem? My solution seems ... long and ugly. Not nearly as nice as the <code>diagonal</code> function for proving that the halting problem is unsolvable.</p>\n\n<p>NB: Please give me answers and not hints! Even though this is a homework question, it is not <em>my</em> homework question: I don\'t go to this university! Further, as you can see from the lab, this question is under the <code>Enhancements</code> category and isn\'t worth marks, so even if you don\'t believe me, there is still no problem with just giving me an answer. Finally, I already <em>have</em> a solution, which I am pretty sure is right; I was just wondering if there was a <em>better</em> solution.</p>\n', 'ViewCount': '115', 'Title': 'Showing the function=? is impossible', 'LastEditorUserId': '4720', 'LastActivityDate': '2012-11-27T01:00:44.990', 'LastEditDate': '2012-11-25T02:06:41.870', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6936', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4720', 'Tags': '<undecidability><lambda-calculus><halting-problem>', 'CreationDate': '2012-11-25T01:41:33.743', 'Id': '6879'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am new to Computability Theory and find it is both amazing and confusing. Specifically, it is difficult for me to get through the undecidability of the well-known Halting Problem. </p>\n\n<blockquote>\n  <p><strong>Halting function:</strong> The Halt function takes an input a pair $&lt;\\alpha, x&gt;$ and outputs 1 if and only if the TM $M_{\\alpha}$ represented by $\\alpha$ halts on input $x$ within a finite number of steps.</p>\n</blockquote>\n\n<p>The undecidability of Halting function is proved by reduction from another undecidable function $UC$, which is defined as follows <a href="http://www.cs.duke.edu/~reif/courses/complectures/books/AB/ABbook.pdf" rel="nofollow">Book by Arora and Barak</a>.</p>\n\n<blockquote>\n  <p><strong>$UC$:</strong> For every $\\alpha \\in \\lbrace 0,1 \\rbrace^{\\ast}$, if $M_{\\alpha}(\\alpha) = 1$, then $UC(\\alpha) = 0$; otherwise (if $M_{\\alpha}(\\alpha)$ outputs a different value or enters an infinite loop), $UC(\\alpha) = 1$.</p>\n</blockquote>\n\n<p>The undecidability of $UC$ is proved by the also well-known <em>"diagonalization"</em> technique. I can understand the technique. However, I am puzzling over a more basic problem involving the definition of $UC$.</p>\n\n<blockquote>\n  <p><strong>My Problem:</strong> The definition of $UC$ is based on the value of $M_{\\alpha}(\\alpha)$. Especially, it seem to be based on <em>whether a Turing Machine halts on an input</em>. However, the latter is undecidable (Worse still, it is undecidable due to the undecidability of $UC$!). In this sense, is the $UC$ function well-defined?</p>\n</blockquote>\n\n<p>What is wrong with my opinion? How should I understand the definition of $UC$ and the relation between $UC$ and Halting Problem?</p>\n\n<p>Thank for your help.</p>\n', 'ViewCount': '126', 'Title': 'Is the undecidable function $UC$ well-defined for proving the undecidability of Halting Problem?', 'LastActivityDate': '2013-01-07T19:26:06.113', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7788', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<computability><proof-techniques><undecidability><halting-problem>', 'CreationDate': '2013-01-05T11:29:41.143', 'Id': '7785'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am tackling the halting problem right now and its remarkable theorem. My book states $\\text{HALT}(x,y)$ is true if $\\psi^{(1)}_{\\mathcal P}$ is defined and conversely $\\text{HALT}(x,y)$ is false if $\\psi^{(1)}_{\\mathcal P}$ is undefined. </p>\n\n<p>The purpose of the theorem, of course, is showing that $\\text{HALT}(x,y)$ is a not computable predicate. I will report the extract of the proof given:</p>\n\n<p>Suppose $\\text{HALT}(x,y)$ were computable. Then we could construct the program $\\mathcal P$:</p>\n\n<p>$$[A]\\;\\;\\;\\;\\;\\text{IF HALT}(X,X)\\text{ GOTO } A$$</p>\n\n<p>It is quite clear that $\\mathcal P$ has been constructed so that</p>\n\n<p>\\begin{equation}\n\\psi^{(1)}_{\\mathcal P}=\n\\begin{cases}\n\\text{undefined} \\;\\;\\; \\text{if HALT}(x,x) \\\\\n0 \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if ~HALT}(x,x)\n\\end{cases}\n\\end{equation}</p>\n\n<p>I don't understand how $\\psi^{(1)}_{\\mathcal P}$ is undefined if $\\text{HALT}(x,x)$ is true, shouldn't $Y$ be equal to $0$ by default and moreover how could a non-terminating program <del>be defined</del> can have $0$ as output value. What am I missing here?</p>\n\n<p><em><strong>Edit</em></strong>: $\\psi^{(1)}_{\\mathcal P}(x)$ is the value of the output variable $Y$ at the terminal snapshot.</p>\n", 'ViewCount': '97', 'Title': 'Clarification on halting predicate computability', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-19T23:33:36.743', 'LastEditDate': '2013-01-19T18:12:20.003', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '9043', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><halting-problem>', 'CreationDate': '2013-01-19T15:30:36.087', 'Id': '9040'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '142', 'Title': 'Program synthesis, decidability and the halting problem', 'LastEditDate': '2013-04-05T15:19:36.143', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '1', 'Body': '<p>I was reading an answer to a recent question, and sort of a strange, ephemeral thought came to mind. My asking this might betray either that my theory chops are seriously lacking (mostly true) or that it\'s just too early for me to read this site. Now, with the disclaimer out of the way...</p>\n\n<p>It is a well-known result it computability theory that the halting problem cannot be decided for TMs. However, this doesn\'t exclude the possibility that there exist machines that can solve the halting problem for certain classes of machines (just not all of them).</p>\n\n<p>Consider the set of all decidable problems. For each problem, there exist infinitely many TMs which decide that language. Could the following be possible </p>\n\n<ul>\n<li>There is a TM that decides the halting problem for a subset $S$ of Turing machines; and</li>\n<li>All decidable problems are decided by at least one Turing machine in $S$?</li>\n</ul>\n\n<p>Of course, finding the Turing machine in $S$ may not be computable itself; but we ignore that problem.</p>\n\n<p>EDIT: Based on Shaull\'s answer below, it seems that either (a) this idea is too ill-specified to be meaningful or (b) my previous attempt wasn\'t quite on the mark. As I try to elaborate in the comments to Shaull\'s answer, my intent isn\'t that we\'re guaranteed that the input TM is in $S$. What I really meant by my question is whether there could exist such an $S$, <em>such that membership in $S$ is a decidable problem</em>. The program to solve the halting problem for $S$ would, presumably, write "invalid input" on the tape or something when given an input that it recognizes as not being in $S$. When I formulate it like that, I\'m not sure whether this allows us to solve the halting problem or not, or whether Rice\'s theorem applies (is decidability a semantic property of a language w.r.t. Rice\'s theorem?)</p>\n', 'Tags': '<turing-machines><undecidability><halting-problem>', 'LastEditorUserId': '69', 'LastActivityDate': '2013-04-05T15:20:46.887', 'CommentCount': '2', 'AcceptedAnswerId': '11059', 'CreationDate': '2013-04-05T13:19:48.110', 'Id': '11056'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If there is a Turing Machine $M_e$ (computing some partially computable function $f$), is there an algorithm to decide if $f$ diverges for all possible inputs?</p>\n', 'ViewCount': '109', 'Title': 'Does Turing Machine divergence depend on the input?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T04:44:34.687', 'LastEditDate': '2013-04-10T18:34:48.943', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'Gauk', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><undecidability><halting-problem>', 'CreationDate': '2013-04-10T10:36:06.323', 'Id': '11196'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am attempting to prove the following problem is undecidable. Given a Turing machine $M$ and input $x$, does $M$ visit infinitely many tape cells on input $x$? </p>\n\n<p>I am considering a reduction from the halting problem. Is this the right approach? </p>\n', 'ViewCount': '109', 'Title': 'Show the problem of a machine visiting infinitely many tape cells on some input is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-04T15:47:41.333', 'LastEditDate': '2013-04-21T23:15:04.180', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<computability><turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2013-04-21T22:25:41.810', 'Id': '11479'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Would it be possible for a runtime environment to detect infinite loops and subsequently stop the associated process, or would implementing such logic be equivalent to solving the halting problem?</p>\n\n<p>For the purpose of this question, I define an "infinite loop" to mean a series of instructions and associated starting stack/heap data that, when executed, return the process to exactly the same state (including the data) as it was in before initiating the infinite loop. (In other words, a program generating an indefinitely long decimal expansion of pi isn\'t "stuck" in an "infinite loop," because at every iteration, it has more digits of pi somewhere in its associated memory.)</p>\n\n<p>(Ported from <a href="http://stackoverflow.com/q/16250472/1858225">http://stackoverflow.com/q/16250472/1858225</a>)</p>\n', 'ViewCount': '838', 'Title': 'Can a runtime environment detect an infinite loop?', 'LastActivityDate': '2013-05-01T01:48:50.400', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '7953', 'Tags': '<halting-problem>', 'CreationDate': '2013-04-28T23:35:36.627', 'FavoriteCount': '1', 'Id': '11645'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '116', 'Title': 'Is there an always-halting, limited model of computation accepting $R$ but not $RE$?', 'LastEditDate': '2013-05-10T21:42:07.617', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '0', 'Body': '<p>So, I know that the halting problem is undecidable for Turing machines. The trick is that TMs can decide recursive languages, and can accept Recursively Enumerable (RE) languages.</p>\n\n<p>I\'m wondering, is there a more limited model of computation which accepts only recursive languages, and not RE? And if so, is there such a model which is always guaranteed to halt?</p>\n\n<p>Obviously this model would be strictly less powerful than TMs and strictly more powerful than PDAs.</p>\n\n<p>I\'m open to a machine-style model, or a lambda-calculus style model.</p>\n\n<p>As an example of what I\'m thinking: the Coq language has a restriction that for any self-recursive calls, the first argument must be strictly decreasing in "size" i.e. if it is a natural number, it must be smaller, if it is a list, it must be shorter, etc. This guarantees that it always halts, but I have no idea if you can compute all of R this way.</p>\n', 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><halting-problem>', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-11T07:39:41.863', 'CommentCount': '1', 'AcceptedAnswerId': '11943', 'CreationDate': '2013-05-10T15:58:41.437', 'Id': '11936'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>suppose <strong>we don't know that Halting problem is not recursive</strong>.</p>\n\n<p>I want to prove that <strong>complement of halting set is not r.e.</strong> then we can find <strong>halting problem is not recursive</strong>.</p>\n\n<p><strong>Can you direct prove that complement of halting set is not r.e.??</strong></p>\n", 'ViewCount': '129', 'Title': 'Complement of halting set is not r.e', 'LastEditorUserId': '8133', 'LastActivityDate': '2013-05-13T21:37:04.930', 'LastEditDate': '2013-05-13T21:37:04.930', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8133', 'Tags': '<undecidability><halting-problem>', 'CreationDate': '2013-05-13T20:54:26.763', 'Id': '11997'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This might be a bit of an abstruse question, but it's something I've been trying to prove.</p>\n\n<p>I'm trying to show that it is undecidable whether a given Turing Machine is a member of the set of all Turing Machines that either always halt, or have non-halting loops where all of which can be detected (a positive decision made on it's existence) by some Turing Mahcine.</p>\n\n<p>I'm trying to do a reduction from the Entscheidungsproblem, and my proof looks something like this:</p>\n\n<p>Create a Turing machine $D$ on input $&lt;M,w&gt;$ that does the following:</p>\n\n<ol>\n<li><p>Mechanically create TM $M_2$ which does the following on $x$:</p>\n\n<ol>\n<li>if $M$ accepts $w$ (via simulation from UTM): accept $x$.</li>\n<li>if $M$ rejects $w$: loop in a manner such that $M_2$ would not be a member of the aforementioned set.</li>\n</ol></li>\n<li><p>Run decider for above problem on $M_2$:</p>\n\n<ul>\n<li>if decider accepts, it should accept because if $M$ accepts $w$, $M_2$ must always halt and must be a member of the set in question.</li>\n<li>if decider rejects, it should reject because if $M$ does not accept $w$, $M_2$ must have a non mechanically detectable loop and is not in the set.</li>\n</ul></li>\n</ol>\n\n<p>The above Turing Machine $D$ should therefore decide Entscheidungsproblem and shows the reduction. However, I'm not sure how to show that it possible to mechanically create a loop which cannot be mechanically detected, or whether an alternate method of proof would be adequate.</p>\n\n<p>Any insight in this proof would be appreciated.</p>\n", 'ViewCount': '111', 'Title': 'Undecidability of whether a given TM halts or only has loops which can be detected by some TM', 'LastEditorUserId': '8262', 'LastActivityDate': '2013-06-19T01:38:13.963', 'LastEditDate': '2013-05-20T01:15:44.853', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '1', 'OwnerDisplayName': 'Phillip Huff', 'PostTypeId': '1', 'OwnerUserId': '8262', 'Tags': '<turing-machines><reductions><halting-problem><undecidability>', 'CreationDate': '2013-05-19T01:12:03.770', 'Id': '12141'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>BB(n) is roughly the maximum number of new states an n-state TM can run into without halting. So for a particular n, if we know BB(n), then we can find out if an arbitrary n-state TM halts by running it for BB(n) steps.</p>\n\n<p>So given some n-state TM, can we construct an m-state TM, where m>n, to calculate BB(n) and thus decides if it halts?</p>\n\n<p>Now some might say that this is equivalent to solving the halting problem, but I don't think so. Because given an arbitrary TM, we don't in fact know how many states it has. And if we don't know n, we certainly can't find m.</p>\n\n<p>If the answer is in the negative, then how is it that we can in fact find out the values of BB(n) for small n? What's the connection between incomputability and unknowability?</p>\n", 'ViewCount': '59', 'Title': 'Given an n-state TM, can we construct an m-state TM (m>n) to determine if it halts?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-28T19:59:32.793', 'LastEditDate': '2013-05-28T19:59:32.793', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2157', 'Tags': '<computability><turing-machines><halting-problem><busy-beaver>', 'CreationDate': '2013-05-25T03:11:19.460', 'Id': '12261'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have some concerns about the Halting problem. This is the proof I know:</p>\n\n<p>Let $h(M, i)$ be a function, $M$ being Turing machine and $i$ input for the Turing machine. Let $h(M, i)$ output true whenever $M(i)$ halts. Let $h(M,i)$ output false if $M(i)$ does not halt.</p>\n\n<p>Then define $p(M)$ on Turing machine $M$. $p(M)$ will halt whenever $h(M, M)$ equals false and $p(M)$ will not halt whenever $h(M, M)$ is true.</p>\n\n<p>What will $p(p)$ do? Now, suppose $p(p)$ halts not. Then $h(p, p)$ is true so $p(p)$ will halt.\nSuppose $p(p)$ halts. Then $h(p, p)$ is false so $p(p)$ will not halt.</p>\n\n<p>So $p(p)$ will either halt and halt not.</p>\n\n<p>But, I think it will loop endlessly. $h(M, i)$ calls $M(i)$ and $p(M)$ will call $h(M, M)$. This is not a problem. But evaluating $p(p)$ results in calling $h(p, p)$ - which will check the value of $p(p)$. But therefor, $p(p)$ is called again, so there was a cycle and the program will continue in an infinite loop.</p>\n\n<p>What am I thinking wrong?</p>\n', 'ViewCount': '75', 'Title': 'Halting problem', 'LastActivityDate': '2013-06-08T18:43:20.273', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12539', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8588', 'Tags': '<turing-machines><halting-problem>', 'CreationDate': '2013-06-08T18:16:33.533', 'Id': '12538'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '426', 'Title': 'Relationship between Undecidable Problems and Recursively Enumerable languages', 'LastEditDate': '2013-06-18T20:28:01.030', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7363', 'FavoriteCount': '0', 'Body': '<p>I have read the Wikipedia article on <a href="http://en.wikipedia.org/wiki/Recursively_enumerable_language#Example" rel="nofollow">Recursively Enumerable languages</a>. The article suggests that the halting problem is recursively enumerable but undecidable. My idea till today was that the halting problem belongs to a class of languages which are not even recursively enumerable. But the article suggests that the halting problem is recursively enumerable. My doubt is about the relationship between undecidable problems and recursively enumerable languages. Are all undecidable problems recursively enumerable languages?</p>\n\n<p>If there is a problem which belongs to the class of non recursively enumerable languages, will it be always undecidable? </p>\n\n<p>Also could any one suggest a problem which is not even recursively enumerable?</p>\n', 'Tags': '<undecidability><halting-problem>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-18T20:28:01.030', 'CommentCount': '0', 'AcceptedAnswerId': '12749', 'CreationDate': '2013-06-18T18:33:24.070', 'Id': '12747'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a question I found in a practice exam while I am preparing for my mid term exam.</p>\n\n<p>The answer needs justification, either a pseudo code or a logical explanation why not.</p>\n\n<p>What puzzled me about that question is that we already know that all LOOP programs terminate at some point, the question seems odd to me.</p>\n\n<p>Any references about LOOP and/or WHILE programs are  welcome. Our professor didn't give much.</p>\n", 'ViewCount': '90', 'Title': 'Can a Turing machine decide if a LOOP program stops for the integer input 0', 'LastActivityDate': '2013-06-26T02:48:46.597', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12905', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8874', 'Tags': '<turing-machines><halting-problem><loops>', 'CreationDate': '2013-06-26T01:31:21.623', 'Id': '12903'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Solve this problem: "build an infinite binary oscilator"</p>\n\n<p>With a Turing Machine we can solve it</p>\n\n<pre><code>a=False\nWhile True:\n   a=not a\n   print a,\n</code></pre>\n\n<p>then output will be</p>\n\n<pre><code>True False True False True False ...\n</code></pre>\n\n<p>(for ever)</p>\n\n<p>I think an oracle can\'t do it, because its definition, it could solve in "one operation", but here there\'s not halting as a request of the problem statement. Is it true?</p>\n\n<p><strong>EDIT</strong>:  Oracle definition from wikipedia</p>\n\n<p>".. an\xa0<em>oracle machine</em>\xa0is an\xa0abstract machine\xa0used to study\xa0decision problems. It can be visualized as a\xa0Turing machine with a black box, called an\xa0<em>oracle</em>, which is able to decide certain decision problems in a single operation. The problem can be of any\xa0complexity class. Even\xa0undecidable problems, like the\xa0halting problem, can be used."</p>\n\n<p>So what if that TM ask its black box oracle to create an infinite binary oscilation?</p>\n\n<pre><code>   1- oracle black box can\'t do infinite loops\n   2-TM can\'t ask that problem to oracle \n   3- Does it return a string with a source code as answer? weird\n   4-or other options...\n</code></pre>\n', 'ViewCount': '140', 'Title': 'Is oracle computer capable of doing infinite loops?', 'LastEditorUserId': '1396', 'LastActivityDate': '2013-06-27T08:30:35.333', 'LastEditDate': '2013-06-26T22:30:23.360', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12920', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<turing-machines><halting-problem><oracle-machines>', 'CreationDate': '2013-06-26T18:33:18.140', 'Id': '12917'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The proof of the undecidability of $A_{TM}$ in Michael Sipser\'s textbook<code>*</code> contains the definition of a Turing Machine, which accepts the encoding of a TM, if this TM doesn\'t accept its own encoding, and rejects it, if it does. If this TM is run on its own encoding, there is problem: it should accept if it doesn\'t accept and vice versa.</p>\n\n<p>My problem with this proof is that it strongly resembles <a href="http://en.wikipedia.org/wiki/Russell%27s_paradox" rel="nofollow">Russel\'s paradox</a>. This paradox arises if we define a set, which contains all sets that are not members of themselves. If we ask whether this set contains itself, there is problem: it should contain itself if it doesn\'t contain itself and vice versa. </p>\n\n<p>Russels\'s paradox has been eliminated from axiomatic set theory: in <a href="http://en.wikipedia.org/wiki/ZFC" rel="nofollow">ZFC</a>, it follows from the axioms that such a property doesn\'t define a valid set. Interestingly enough, in the theory of computation, a similar property defines a valid TM. </p>\n\n<p>That\'s why I don\'t like the proof in Sipser\'s book. I\'d like to emphasize that I know that this proof is perfectly valid, but I\'d like to know if there is another proof which follows a different chain of thought, and doesn\'t define such a TM.</p>\n\n<hr>\n\n<p><code>*</code>Sipser, M.: Introduction to the Theory of Computation (2nd ed.), 2006, page 179. On this page, Sipser uses the term <em>halting problem</em> for the language $A_{TM}$. The proper name for this language is <em>acceptance problem</em>, see the footnote on page 188.</p>\n', 'ViewCount': '101', 'Title': 'Alternative proof for the undecidability of $A_{TM}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-16T11:23:01.367', 'LastEditDate': '2013-08-16T11:23:01.367', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '13770', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<terminology><computability><turing-machines><halting-problem>', 'CreationDate': '2013-08-15T21:00:43.357', 'Id': '13766'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $B$ be a recursive enumerable set and $B = W_n$, where $W_n = \\{x \\in \\mathbb N \\mid \\Phi(x,n)\\downarrow\\}$ and $\\Phi^{(n)}(x_1, \\ldots, x_n, y)$ is the value of the function at the terminal snaphot.</p>\n\n<p>There is a definition that leaves me really confused:\n$$n \\in W_n \\Leftrightarrow \\Phi(n,n)\\downarrow \\Leftrightarrow \\text{HALT}(n,n)$$ </p>\n\n<p>the thing is we know that $\\text{HALT}$ is not computable, therefore is is <em>undefined</em> so how is it possible that it is equivalent to $\\Phi(n,n)\\downarrow$ which is actually a defined function? What am I missing here?</p>\n', 'ViewCount': '52', 'Title': 'Confusing equivalence $\\Phi(n,n)\\downarrow \\Leftrightarrow \\text{HALT}(n,n)$', 'LastActivityDate': '2013-09-04T11:52:38.303', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14126', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><halting-problem>', 'CreationDate': '2013-09-04T11:38:00.880', 'Id': '14125'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a language is decidable, we can write a method that always halts and returns <code>true</code> for each string that is an element of the language and <code>false</code> otherwise.</p>\n\n<p>If a language is undecidable, what does that mean? Does it mean:</p>\n\n<p>a.) We cannot write a method; we cannot even conceive of a method.</p>\n\n<p>b.) We can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely.</p>\n\n<p>c.) Other (what?)</p>\n', 'ViewCount': '111', 'Title': 'Can a method be written if the language is undecidable?', 'LastActivityDate': '2013-09-21T17:08:19.787', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '14501', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<formal-grammars><undecidability><decision-problem><halting-problem><turing-completeness>', 'CreationDate': '2013-09-21T16:43:09.593', 'Id': '14499'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '188', 'Title': 'Is there a TM that halts on all inputs but that property is not provable?', 'LastEditDate': '2013-11-27T22:07:04.507', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '2', 'Body': '<blockquote>\n  <p>Does there exist a Turing machine that halts on all inputs but that property is not provable for some reason?</p>\n</blockquote>\n\n<p>I am wondering if this question has been studied. Note, "unprovable" could mean a "limited" proof system (which in the weak sense think the answer must be yes). I am of course interested in the strongest possible answer, i.e. one that is not provable to halt on all inputs in say <a href="http://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory">ZFC set theory</a> or whatever.</p>\n\n<p>It occurred to me this could be true of the <a href="http://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a> but I am hazy on the details. It doesn\'t seem like Wikipedia describes this aspect clearly.</p>\n', 'Tags': '<computability><reference-request><turing-machines><halting-problem>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-03T19:03:16.420', 'CommentCount': '3', 'AcceptedAnswerId': '18425', 'CreationDate': '2013-11-27T21:44:59.707', 'Id': '18424'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>$\\mathrm{Halt} = \\{ (f,x) | f(x)\\downarrow \\}$ is r.e. (semi-decidable) but undecidable.</p>\n\n<p>$\\mathrm{Total} = \\{ f | \\forall x f(x)\\downarrow \\}$ is not r.e. (not even semi-decidable).</p>\n\n<p>I need some help in proving that $\\mathrm{Total}$ is not recursive (decidable). </p>\n\n<p>I know the diagonalization proof for the halting problem, I just need the same kind of proof for $\\mathrm{Total}$. I'm posting the proof for the halting problem for reference:</p>\n\n<h2>Undecidability of the halting problem</h2>\n\n<p>Assume we can decide the halting problem. Then there exists some total function $\\mathrm{Halt}$ such \nthat \n$$\n\\mathrm{Halt}(x,y) = \\begin{cases} 1 &amp; \\text{if $\\phi_x(y)$ is defined}, \\\\ 0 &amp; \\text{if $\\phi_x(y)$ is not defined}.\\end{cases}\n$$</p>\n\n<p>Here, we have numbered all programs and $\\phi_x$ refers to the $x$'th program in this ordering. We can view $\\mathrm{Halt}$ as a mapping from $\\mathbb{N}$ into $\\mathbb{N}$ by treating its input as a single number representing the pairing of two numbers via the one-one onto function \n$$ \\mathrm{pair}(x,y) = \\langle x,y \\rangle = 2^x (2y + 1) \u2013 1 , $$\nwith inverses \n$$\n\\begin{align*}\n \\langle z \\rangle_1 &amp;= \\exp(z+1,1), \\\\\n \\langle z \\rangle_2 &amp;= ((( z + 1 ) // 2^{\\langle z \\rangle_1}) \u2013 1 ) // 2 \n\\end{align*}\n$$\nNow if $\\mathrm{Halt}$ exists, then so does $\\mathrm{Disagree}$, where \n$$\n\\mathrm{Disagree}(x) = \\begin{cases} 0 &amp; \\text{if $\\mathrm{Halt}(x,x)=0$, i.e., if $\\phi_x(x)$ is not defined}, \\\\ \\operatorname*{\\mu}_y (y=y+1) &amp; \\text{if $\\mathrm{Halt}(x,x)=1$, i.e., if $\\phi_x(x)$ is defined}. \\end{cases}\n$$</p>\n\n<p>Since $\\mathrm{Disagree}$ is a program from $\\mathbb{N}$ into $\\mathbb{N}$, $\\mathrm{Disagree}$ can be reasoned about by $\\mathrm{Halt}$. Let $d$ \nbe such that $\\mathrm{Disagree} = \\phi_d$, then </p>\n\n<p>$$\\mathrm{Disagree}(d)\\text{ is defined} \\Leftrightarrow \\mathrm{Halt}(d,d) = 0 \\Leftrightarrow \u03a6_d(d)\\text{ is undefined} \u21d4 \\mathrm{Disagree}(d)\\text{ is undefined}.$$ </p>\n\n<p>But this means that $\\mathrm{Disagree}$ contradicts its own existence. Since every step we took was constructive, except for the original assumption, we must presume that the original assumption was in error. Thus, the halting problem is not decidable. </p>\n", 'ViewCount': '63', 'Title': 'How to prove that "Total" is not recursive (decidable)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T05:56:05.760', 'LastEditDate': '2014-04-07T05:56:05.760', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Michael Anthony Leber', 'PostTypeId': '1', 'Tags': '<computability><undecidability><halting-problem>', 'CreationDate': '2013-12-03T03:53:04.973', 'Id': '18980'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The proofs that the halting problem is undecidable seem to make very few assumptions about the kind of program/machine under consideration: just that the programs take one input and either loop or produce an output. Not just Turing machines have these characteristics: for example, a linear-bounded automaton can also loop.</p>\n\n<p>So, as well as a proof that you can't use a Turing machine to decide whether a Turing machine will halt, is it not also a proof that you can't use a pushdown automaton to decide whether a pushdown automaton will halt, and so on, for any automaton/language that has the ability to loop?</p>\n", 'ViewCount': '91', 'Title': 'Is the halting problem specific to Turing machines?', 'LastActivityDate': '2013-12-24T11:05:36.670', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '19242', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12332', 'Tags': '<turing-machines><halting-problem>', 'CreationDate': '2013-12-24T05:00:55.947', 'Id': '19231'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What would the repercussions on computer science theory as we know it today be if the proof for the incomputability of the halting problem was shown to be wrong?</p>\n\n<p>What would change in terms of the direction of research?</p>\n\n<p>Which doors would open, which would close?</p>\n\n<p>Put another way: why is the halting problem significant to computing science theory as we know it today?</p>\n\n<p>EDIT: I\'d like to point out that in this what-if universe, Godel\'s incompleteness theory still holds. The supposed problem with the incomputability of the halting problem proof in this alternate-universe: <a href="http://www.cs.toronto.edu/~hehner/RHP.pdf" rel="nofollow">http://www.cs.toronto.edu/~hehner/RHP.pdf</a></p>\n', 'ViewCount': '82', 'LastEditorDisplayName': 'user12330', 'ClosedDate': '2013-12-26T01:18:03.290', 'Title': 'What if the proof for the halting problem was wrong?', 'LastActivityDate': '2013-12-25T00:22:15.477', 'LastEditDate': '2013-12-25T00:22:15.477', 'AnswerCount': '0', 'CommentCount': '13', 'Score': '1', 'OwnerDisplayName': 'user12330', 'PostTypeId': '1', 'Tags': '<turing-machines><halting-problem>', 'CreationDate': '2013-12-24T23:45:29.370', 'Id': '19264'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Posted this question on cstheory.SE where they said to go here:</p>\n\n<blockquote>\n  <p>I read the demonstration of the Halting problem, it is done by\n  reductio ad absurdum where the push to get to the absurd is to use the\n  halting function "H(A,b)" (where A=another function, b=the A\n  parameter) as its own parameter. This proofs that can\'t exist a\n  function which takes every function including its own as parameter and\n  says if it is an infinite loop or not, but doesn\'t proof that a\n  function Z(A,b) where {A,b!=Z} (1*) can\'t exist.</p>\n</blockquote>\n\n<p>While I deleted that question I had this answer by dkuper:</p>\n\n<blockquote>\n  <p>It is easy to circumvent this problem, by giving to the functions the\n  code of a different machine which computes the same function.</p>\n  \n  <p>Say you succeeded in building your machine computing Z(a,b) which\n  works as you said. Then you still get the reductio ad absurdum, by\n  feeding to this machine the code of another machine which is\n  equivalent. This is always possible because for every machine M, there\n  are infinitely machines M\u2032 which behaves the same as M (i.e. halt on\n  exactly the same instances). So checking that the input is not\n  precisely the machine M is not enough to avoid the paradox. And\n  checking that the input does not behave the same as M is impossible.</p>\n</blockquote>\n\n<p>So, now, this doesn\'t work if we assume that the function passed as parameter has a flag (applied by the constructor) that indicates if it is the halt function.</p>\n', 'ViewCount': '85', 'Title': 'Trying to break the proof of undecidability of the halting problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-09T23:24:09.077', 'LastEditDate': '2014-01-09T23:11:05.887', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'OwnerDisplayName': 'user12708', 'PostTypeId': '1', 'Tags': '<computability><halting-problem>', 'CreationDate': '2014-01-09T17:17:52.337', 'Id': '19601'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '119', 'Title': 'Why is the halting problem unsolvable by a turing machine?', 'LastEditDate': '2014-01-30T15:21:08.293', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13245', 'FavoriteCount': '1', 'Body': "<p>So my knowledge of CS is amateurish at best but to me, logically, it seems like the halting problem is solvable.</p>\n\n<p>So any human can determine if a problem halts with rigorous inspection, so why can't a very advanced, say human AI, solve the halting problem?</p>\n\n<p>Also, is there a machine, say more powerful than a turing machine, that can solve this problem?</p>\n\n<p>PS: I might be making some bad assumptions, please point that out if so.</p>\n", 'ClosedDate': '2014-02-11T11:06:09.057', 'Tags': '<computability><halting-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T15:32:51.337', 'CommentCount': '3', 'AcceptedAnswerId': '20111', 'CreationDate': '2014-01-30T14:22:09.677', 'Id': '20109'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm a CS undergrad so my math/CS knowledge is not that deep so please correct me if my premise is flawed or I have made some incorrect assumptions.</p>\n\n<p>So I was thinking, much in the way that some primality testers are probabilistic(they give you yes or no but have a chance to be wrong). Would it be possible to build a probabilistic halting problem solver? One that reports within a certain degree of error, whether a problem halts or not?</p>\n", 'ViewCount': '70', 'Title': 'Possible to construct a probabilistic halting problem solver?', 'LastActivityDate': '2014-02-13T02:24:54.360', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '13245', 'Tags': '<probability-theory><halting-problem><probabilistic-algorithms>', 'CreationDate': '2014-02-12T23:13:06.320', 'FavoriteCount': '1', 'Id': '21581'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '54', 'Title': 'Regarding Turing Machine Halting Problem', 'LastEditDate': '2014-03-09T19:51:40.390', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13053', 'FavoriteCount': '1', 'Body': "<p>All problems solved by standard today's general purpose computer can be solved by standard Turing machine.As general purpose computer can't do more than Turing machine so The Turing machine halting problem must also be  unsolved by today's general purpose computer.How can I realize the fact that halting problem can't be solved by todays general purpose computers.</p>\n", 'ClosedDate': '2014-03-09T22:12:51.443', 'Tags': '<computability><turing-machines><halting-problem>', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-09T19:54:26.980', 'CommentCount': '5', 'CreationDate': '2014-03-09T06:34:28.180', 'Id': '22420'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have read in <a href="https://en.wikipedia.org/wiki/Halting_problem#Common_pitfalls" rel="nofollow">Wikipedia</a> and some other texts that</p>\n\n<blockquote>\n  <p>The halting problem is [...] decidable for <a href="https://en.wikipedia.org/wiki/Linear_bounded_automaton" rel="nofollow">linear bounded\n  automata</a> (LBAs) [and] deterministic machines with finite memory.</p>\n</blockquote>\n\n<p>But earlier it is written that the halting problem is an undecidable problem and thus TM can\'t solve it! Since LBA are defined as a type of TM, should the same not hold for them?</p>\n', 'ViewCount': '192', 'Title': 'Why is the halting problem decidable for LBA?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-22T13:15:09.093', 'LastEditDate': '2014-03-22T13:15:09.093', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '4', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<turing-machines><automata><undecidability><halting-problem><linear-bounded-automata>', 'CreationDate': '2014-03-22T02:06:19.990', 'Id': '22925'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For an assignment in my university, we have to answer multiple choice questions about theoretical computer science. This particular one I find very hard to understand. I wonder if some of you could explain it to me.</p>\n\n<pre><code>In this question, L1, L2, L3, L4 refer to languages and M, M1, M2 refer to Turing machines.  \n</code></pre>\n\n<p>Let  </p>\n\n<pre><code>L1 = {(M1,M2) | L(M1) is a subset of L(M2)},\nL2 = {M | There exists an input on which TM M halts within 100 steps},\nL3 = {M | There exists an input w of size less than 100, such that M accepts w},\nL4 = {M | L(M) contains at least 2 strings}.\n</code></pre>\n\n<p>Decide whether each of L1, L2, L3 and L4 are recursive, RE or neither. Then identify the true statement below.</p>\n\n<pre><code>     a)      The complement of L3 is recursively enumerable.\n     b)      The complement of L2 is recursive.\n     c)      The complement of L2 is not recursively enumerable.\n     d)      L1 is recursively enumerable.\n</code></pre>\n\n<p><strong>What I do not understand is, how the definitions of L1, L2, L3, L4 can tell me whether or not they are recursive (enumerable).</strong> </p>\n\n<p>My guesses (probably wrong) are:</p>\n\n<p>L1: ?</p>\n\n<p>L2: recursive enumerable (I thought this since obviously there are inputs on which the TM halts but we can not say if it halts every time &ndash; therefore only recursive enumerable and not recursive)</p>\n\n<p>L3: recursive enumerable (Same explanation as for L2)</p>\n\n<p>L4: not recursive (This is only a guess, I don't get how the number of minimum strings of the language can imply any type of recursiveness.)  </p>\n", 'ViewCount': '42', 'Title': 'Turing machines and languages -- recursive (enumerable) or not', 'LastEditorUserId': '16286', 'LastActivityDate': '2014-03-30T12:46:48.657', 'LastEditDate': '2014-03-30T12:38:55.190', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16286', 'Tags': '<formal-languages><turing-machines><halting-problem>', 'CreationDate': '2014-03-30T09:58:27.093', 'FavoriteCount': '1', 'Id': '23250'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The question is whether this is recursive or not. I first thought that it wasn\'t but then I read this question which seems similar and is recursive.</p>\n\n<p><a href="http://cs.stackexchange.com/questions/3119/is-it-decidable-whether-a-tm-reaches-some-position-on-the-tape">Is it decidable whether a TM reaches some position on the tape?</a></p>\n\n<p>I think it\'s a slightly different question though (?) and so I have tried to show that it isn\'t recursive by reduction from the halting problem. </p>\n\n<p>Ignore the below if it is recursive!</p>\n\n<p>So for an instance  of the Halting problem we can use 2 tape TM M\' as follows:</p>\n\n<p>on input (code(M)code(x)) to M\'</p>\n\n<ul>\n<li>M\' copies code(x) to tape 2 </li>\n<li>M\' simulates M on tape 2</li>\n<li>If M halts on the input x then......</li>\n</ul>\n\n<p>I am not really sure what to do now. I thought that I could get M\' to only enter a certain cell if M halts on x and then use this to show that if we could decide the problem above then we could decide the Halting problem (by seeing if M\' enters that particular cell)</p>\n\n<p>But I am not sure what cell I can use to guarantee that it won\'t have already been entered? The two tape thing is kind of confusing me -do I need to pick a cell that won\'t be entered on either tape 1 or tape 2?</p>\n\n<p>Any help appreciated!</p>\n', 'ViewCount': '14', 'Title': 'Does the head of TM M ever move into cell x when processing Input I?', 'LastActivityDate': '2014-04-27T21:17:58.543', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17058', 'Tags': '<turing-machines><decision-problem><halting-problem>', 'CreationDate': '2014-04-27T21:17:58.543', 'Id': '24157'}