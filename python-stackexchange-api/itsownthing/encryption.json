{'ViewCount': '1940', 'Title': 'Why is encrypting with the same one-time-pad not good?', 'LastEditDate': '2012-03-15T07:22:59.783', 'AnswerCount': '4', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '1', 'Body': '<p>To encrypt a message $m_1$ with a one-time-pad key $k$ you do\n$Enc(m_1,k) = m_1 \\oplus k$. </p>\n\n<p>If you use the same $k$ to encrypt a different message $m_2$ you get\n$Enc(m_2,k) = m_2 \\oplus k$, and if you perform Xor of the two ciphertext you get\n$$( m_1 \\oplus k) \\oplus ( m_2 \\oplus k) = m_1 \\oplus m_2$$</p>\n\n<p>so, OK, there is some information leakage becuse you learn $m_1 \\oplus m_2$, but why is it not secure? I have no way to learn (say) $m_1$ unless I know $m_2$. So why is it wrong to use $k$ twice??</p>\n', 'Tags': '<cryptography><information-theory><encryption>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-25T07:11:47.277', 'CommentCount': '5', 'AcceptedAnswerId': '365', 'CreationDate': '2012-03-14T06:52:07.727', 'Id': '349''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '2078', 'Title': "Why hasn't there been an encryption algorithm that is based on the known NP-Hard problems?", 'LastEditDate': '2012-03-15T07:04:19.330', 'AnswerCount': '4', 'Score': '51', 'PostTypeId': '1', 'OwnerUserId': '5', 'FavoriteCount': '8', 'Body': "<p>Most of today's encryption, such as the RSA, relies on the integer factorization, which is not believed to be a NP-hard problem, but it belongs to BQP, which makes it vulnerable to quantum computers. I wonder, why has there not been an encryption algorithm which is based on an known NP-hard problem. It sounds (at least in theory) like it would make a better encryption algorithm than a one which is not proven to be NP-hard.</p>\n", 'Tags': '<complexity-theory><np-hard><encryption><cryptography>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-22T00:58:17.060', 'CommentCount': '1', 'AcceptedAnswerId': '364', 'CreationDate': '2012-03-14T08:02:26.627', 'Id': '356''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Windows NT used a point-to-point protocol where a client can communicate "securely" with a server by using a stream cipher to encrypt an array of messages with some key $k$. The server also encrypts its response with the same key $k$. But how is it aware of this key?</p>\n\n<p>More general: if Alice and Bob use some encryption/decryption algorithm that operates on the same private key $k$, what is a secure way of exchanging this key? (without using a different key ofcourse) </p>\n\n<p>This is something that I\'ve always asked myself whilest studying private key cryptography.</p>\n', 'ViewCount': '209', 'Title': 'How is the key in a private key encryption protocol exchanged?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-03-19T08:22:05.680', 'LastEditDate': '2012-03-18T00:58:39.457', 'AnswerCount': '5', 'CommentCount': '1', 'AcceptedAnswerId': '472', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '17', 'Tags': '<cryptography><encryption>', 'CreationDate': '2012-03-17T17:30:02.783', 'Id': '470''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>How does the password that we enter (to connect to a wireless network) encrypt the data on the wireless network?</p>\n\n<p>Through my reading I am not sure if the password that we enter is the same as the passphrase. If that is right then how can the passphrase generate the four WEP keys?</p>\n\n<p>I understand how the four keys work in WEP and how they encrypt the data. Also, I know how WPA's keys encrypt the data but the only thing I have to know is: </p>\n\n<blockquote>\n  <p>what is the benefit of the password that we enter to get access to the network, and how does this password help in encrypting the data?</p>\n</blockquote>\n", 'ViewCount': '1009', 'Title': 'How does a wifi password encrypt data using WEP and WPA?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T14:54:04.653', 'LastEditDate': '2012-03-25T14:54:04.653', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '701', 'Tags': '<cryptography><computer-networks><encryption><security>', 'CreationDate': '2012-03-23T19:41:23.180', 'FavoriteCount': '1', 'Id': '704''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '201', 'Title': 'Is it possible to create a "Time Capsule" using encryption?', 'LastEditDate': '2012-04-26T22:25:21.077', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1038', 'FavoriteCount': '1', 'Body': '<p>I want to create a digital time capsule which will remain unreadable for some period of time and then become readable. I do not want to rely on any outside service to, for instance, keep the key secret and then reveal it at the required time. Is this possible? If not, is some kind of proof possible that it is not?</p>\n\n<p>One strategy would be based on projections of future computing capabilities, but that is unreliable and makes assumptions about how many resources would be applied to the task.</p>\n', 'Tags': '<cryptography><encryption><digital-preservation>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-06-12T05:46:21.313', 'CommentCount': '1', 'AcceptedAnswerId': '1518', 'CreationDate': '2012-04-26T13:37:39.000', 'Id': '1514''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>it\'s a well known statement that </p>\n\n<p>"<em>Cryptographic security must rely on a secret key instead of a secret algorithm</em>."</p>\n\n<p>I would like to ask about some details about it. <em>And which are their differences?</em></p>\n\n<p>I see the obvious thing that for a multi user system, generating a key is overwhelmingly easier than generating a distinct alghorithm for every user pair, (and even for a single pair of users one could argue that updating the key is easier)</p>\n\n<p>But, Is it the only argument? </p>\n\n<p>I mean, if we define </p>\n\n<pre><code>AlgorithmA = AlgorithmX + key A\nAlgorithmB = AlgorithmX + key B\n</code></pre>\n\n<p>Then a change on the key is not different from a change in the algorithm.</p>\n\n<p>The only different I see is that for a new pair of users/keys</p>\n\n<ul>\n<li><p><em>Most of</em> the Algorithm structure <strong>remains constant</strong> in the case of secret key,</p></li>\n<li><p><em>Most of</em> Algorithm structure <strong>need to change</strong> in the case of secret Algorithm</p></li>\n</ul>\n\n<p>But where is the limit? "most of" meaning?</p>\n\n<p>I would like to have more views and clues to understand why this distinction is usually mentioned.</p>\n', 'ViewCount': '255', 'Title': 'Key secrecy vs Algorithm secrecy', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-14T15:49:59.243', 'LastEditDate': '2012-05-11T22:36:20.483', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '1834', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<cryptography><security><encryption>', 'CreationDate': '2012-05-11T17:57:33.800', 'Id': '1797''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>If an encryption algorithm is meant to convert a string to another string which can then be decrypted back to the original, how could this process involve any randomness?  </p>\n\n<p>Surely it has to be deterministic, otherwise how could the decryption function know what factors were involved in creating the encrypted string?</p>\n', 'ViewCount': '210', 'Title': 'How can encryption involve randomness?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-05-26T18:25:38.433', 'LastEditDate': '2012-05-26T18:25:38.433', 'AnswerCount': '5', 'CommentCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1622', 'Tags': '<cryptography><encryption><randomness>', 'CreationDate': '2012-05-23T21:13:58.847', 'Id': '2030''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p><strong>Preface:</strong> This question was originally asked on <a href="http://cstheory.stackexchange.com/questions/11521">Theoretical Computer Science</a>, and the kind people there referred me to this web site. It is being repeated here in an attempt to find a satisfying answer.</p>\n\n<hr>\n\n<p>Over the years, two novel encryption techniques have come to mind and been implemented as programming libraries that could be integrated into applications. However, how to analyze their security and vulnerability characteristics has never been very clear, and their usage has been limited to mainly experimental tests. Are there tools available for automated examination of such parameters one may be interested in understanding for an encryption library? Are there bodies of people who are interested in being introduced to new encryption concepts for the purpose of executing their own personal analysis on such a process? I\'m not sure where to look.</p>\n\n<p>The first encryption algorithm is a mono-alphabetic simple substitution cipher. It requires two keys to operate and is designed to frustrate frequency analysis. The longer of the keys forms a table by which plain-text has a normal substitution cipher applied. Each encoded byte is then split into four values of two bits each. The second, shorter key is then used to allow a random selection from four groups of sixty-four unique bytes each. Each two bit value from the encoded byte is used to select which group of sixty-four bytes to use. Encoding has two disadvantages: the output is four times larger, and repeated data encoding may allow some frequency analysis.</p>\n\n<p>The second encryption algorithm is a stream cipher like the first but internally operates on blocks of data. It utilizes two keys to operate: the first is a two-dimensional array that describes how to construct a (virtual) multidimensional grid, and the second is an initialization vector for the encoding/decoding engine. It attempts to overcome frequency analysis by encoding bytes with a window of preceding bytes (initialized from the second key). A byte with its preceding window of bytes form a multidimensional index into the aforementioned grid. Unfortunately, encoding duplicate blocks of data longer than the window size starts yielding equivalent data.</p>\n', 'ViewCount': '284', 'Title': 'After implementing a novel encryption algorithm, how would one go about analyzing its security or get help from others in doing so?', 'LastEditorUserId': '1644', 'LastActivityDate': '2012-05-25T08:31:52.593', 'LastEditDate': '2012-05-25T08:31:52.593', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1633', 'Tags': '<cryptography><encryption>', 'CreationDate': '2012-05-24T20:48:26.443', 'Id': '2053''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm trying to solve a problem:</p>\n\n<p>I have 11 ciphers encoded with the same key.\nMy aim is to decode target cipher.</p>\n\n<p>If I do xor C1, C2 (<strong>ciphers encoded with the same key</strong>) I do get M1 xor M2 (where M1, M2 are plain text messages).</p>\n\n<p>Please say what to do next. I don't understand how to get plain texts from M1 xor M2</p>\n\n<p><strong>UPD:</strong> it's a two time pad (i.e. the same key has been use more than one time)</p>\n", 'ViewCount': '573', 'Title': 'One time pad, get plaintext using ciphers encoded with the same key', 'LastEditorUserId': '4639', 'LastActivityDate': '2012-12-23T10:32:19.413', 'LastEditDate': '2012-11-18T14:04:32.200', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4639', 'Tags': '<cryptography><encryption><xor>', 'CreationDate': '2012-11-18T11:07:56.430', 'FavoriteCount': '1', 'Id': '6740''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Which one is better approach do data compression before encrypting it  or Encrypt data before compression ? I think it is biased towards the application requirement.  Please share your views.</p>\n', 'ViewCount': '64', 'Title': 'Data Compression: Which one is Better "Compress before Encrypt" or "Encrypt before Compression"', 'LastActivityDate': '2014-03-10T02:10:22.340', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '15399', 'Tags': '<data-compression><encryption>', 'CreationDate': '2014-03-07T18:48:22.273', 'Id': '22378''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}