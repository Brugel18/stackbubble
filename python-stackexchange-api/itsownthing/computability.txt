{'ViewCount': '1377', 'Title': 'What is the significance of context-sensitive (Type 1) languages?', 'LastEditDate': '2012-03-07T16:09:28.450', 'AnswerCount': '9', 'Score': '23', 'PostTypeId': '1', 'OwnerUserId': '26', 'FavoriteCount': '1', 'Body': '<p>Seeing that in the <a href="http://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky Hierarchy</a> Type 3 languages can be recognised by a state machine with no external memory (i.e., a finite automaton), Type 2 by a state machine with a <em>single</em> stack (i.e. a push-down automaton) and Type 0 by a state machine with <em>two</em> stacks (or, equivalently, a tape, as is the case for Turing Machines), how do Type 1 languages fit into this picture? And what advantages does it bring to determine that a language is not only Type 0 but Type 1?</p>\n', 'Tags': '<formal-languages><applied-theory><computability><automata><formal-grammars>', 'LastEditorUserId': '69', 'LastActivityDate': '2012-03-08T02:30:13.020', 'CommentCount': '9', 'AcceptedAnswerId': '31', 'CreationDate': '2012-03-06T20:06:29.977', 'Id': '14'}{'ViewCount': '463', 'Title': "Rice's theorem for non-semantic properties", 'LastEditDate': '2014-02-06T20:32:46.053', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '41', 'FavoriteCount': '1', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Rice%27s_theorem" rel="nofollow">Rice\'s theorem</a> tell us that the only <em>semantic</em> properties of <a href="http://en.wikipedia.org/wiki/Turing_machines" rel="nofollow">Turing Machines</a> (i.e. the properties of the function computed by the machine) that we can decide are the two trivial properties (i.e. always true and always false).</p>\n\n<p>But there are other properties of Turing Machines that are not decidable. For example, the property that there is an unreachable state in a given Turing machine is undecidable$^{\\dagger}$.</p>\n\n<p>Is there a similar theorem to Rice\'s theorem that categorizes the decidability of similar properties? I don\'t have a precise definition. Any known theorem that covers the example I have given would be interesting for me.</p>\n\n<p>$^\\dagger$ it is easy to prove that this set is undecidable using <a href="http://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem" rel="nofollow">Kleene\'s Recursion/Fixed Point theorems</a>.</p>\n', 'Tags': '<computability><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-02-06T20:32:46.053', 'CommentCount': '4', 'AcceptedAnswerId': '37', 'CreationDate': '2012-03-06T22:46:52.293', 'Id': '33'}{'Body': '<p>I want to know if the following problem is decidable and how to find out. Every problem I see I can say "yes" or "no" to it, so are most problems and algorithms decidable except a few (which is provided <a href="http://en.wikipedia.org/wiki/List_of_undecidable_problems" rel="nofollow">here</a>)?</p>\n\n<blockquote>\n  <p>Input: A directed and finite graph $G$, with $v$ and $u$ as vertices<br>\n  Question: Does a path in $G$ with $u$ as initial vertex and $v$ as final vertex exist?</p>\n</blockquote>\n', 'ViewCount': '327', 'Title': 'Is this finite graph problem decidable? What factors make a problem decidable?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-30T21:37:25.987', 'LastEditDate': '2012-04-30T21:37:25.987', 'AnswerCount': '4', 'CommentCount': '1', 'AcceptedAnswerId': '153', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<algorithms><computability><graph-theory><undecidability>', 'CreationDate': '2012-03-09T00:47:22.190', 'Id': '143'}{'ViewCount': '154', 'Title': 'Equivalence of Kolmogorov-Complexity definitions', 'LastEditDate': '2012-03-09T03:10:00.007', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '1', 'Body': '<p>There are many ways to define the <a href="https://en.wikipedia.org/wiki/Kolmogorov_complexity">Kolmogorov-Complexity</a>, and usually, all these definitions they are equivalent up to an additive constant. That is if $K_1$ and $K_2$ are kolmogorov complexity functions (defined via different languages or models), then there exists a constant $c$ such that for every string $x$, $|K_1(x) - K_2(x)| &lt; c$. I believe this is because for every Kolmogorov complexity function $K$ and for every $x$ it holds that $K(x) \\le |x| +c$, for some constant $c$.</p>\n\n<p>I\'m interested in the following definitions for $K$, based on Turing-machines</p>\n\n<ol>\n<li><strong>number of states</strong>: Define $K_1(x)$ to be the minimal number $q$ such that a TM with $q$ states outputs $x$ on the empty string.</li>\n<li><strong>Length of Program</strong>: Define $K_2(x)$ to be the shortest "program" that outputs $x$. Namely, fix a way to encode TMs into binary strings; for a machine $M$ denote its (binary) encoding as $\\langle M \\rangle$.  $K_2(x) = \\min |\\langle M \\rangle|$ where the minimum is over all $M$\'s that output $x$ on empty input.</li>\n</ol>\n\n<p>Are $K_1$ and $K_2$ equivalent? What is the relation between them, and which one grasps better the concept of Kolmogorov complexity, if they are not equivalent.</p>\n\n<p>What especially bugs me is the rate $K_2$ increase with $x$, which seems not to be super-linear (or at least linear with constant $C&gt;1$ such that $K_2 &lt; C|x|$, rather than $|x|+c$).\nConsider the most simple TM that outputs $x$ - the one that just encodes $x$ as part of its states and transitions function. it is immediate to see that\n$K_1(x) \\le |x|+1$. However the encoding of the same machine is much larger, and the trivial bound I get is $K_2(x) \\le |x|\\log |x|$. </p>\n', 'Tags': '<computability><kolmogorov-complexity>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-15T01:02:24.947', 'CommentCount': '4', 'AcceptedAnswerId': '402', 'CreationDate': '2012-03-09T01:46:42.533', 'Id': '146'}{'Body': u'<p>Consider decision problems stated in some \u201creasonable\u201d formal language. Let\'s say formulae in higher-order Peano arithmetic with one free variable as a frame of reference, but I\'m equally interested in other models of computation: Diophantine equations, word problems from rewriting rules using Turing machines, etc. An answer expressed in any classical formalization would be fine, though if you know how much the choice of formalization influences the answer, that would also be interesting.</p>\n\n<p>Given the length $N$ of the statement of a decision problem, we can define the number $D(N)$ of decidable statements of length $N$ and the number $U(N)$ of undecidable statements of length $N$.</p>\n\n<p>What is known about the relative growth of $U(N)$ and $D(N)$? In other words, if I take a well-formed decision problem at random, what is the probability of its being decidable for a given statement length?</p>\n\n<p><sub> Inspired by <a href="http://cs.stackexchange.com/questions/143/what-factors-make-a-problem-decidable">this question</a> which asks whether \u201cmost problems and algorithms [are] decidable\u201d. Well, if you don\'t filter by interest, are they? </sub>  </p>\n', 'ViewCount': '318', 'Title': 'Ratio of decidable problems', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-22T13:05:21.823', 'LastEditDate': '2012-03-10T15:12:03.217', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-03-09T12:54:25.553', 'FavoriteCount': '5', 'Id': '155'}{'ViewCount': '539', 'Title': 'What are the possible sets of word lengths in a regular language?', 'LastEditDate': '2012-03-10T15:16:58.000', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Given a language $L$, define the length set of $L$ as the set of lengths of words in $L$:\n$$\\mathrm{LS}(L) = \\{|u| \\mid u \\in L \\}$$</p>\n\n<p>Which sets of integers can be the length set of a regular language?</p>\n', 'Tags': '<formal-languages><computability><regular-languages><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-10T15:16:58.000', 'CommentCount': '2', 'AcceptedAnswerId': '175', 'CreationDate': '2012-03-09T16:46:44.240', 'Id': '164'}{'ViewCount': '274', 'Title': 'Is there a "natural" undecidable language?', 'LastEditDate': '2012-12-13T02:16:00.593', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '157', 'FavoriteCount': '2', 'Body': '<p>Is there any "natural" language which is undecidable?</p>\n\n<p>by "natural" I mean a language defined directly by properties of strings, and not via machines and their equivalent. In other words, if the language looks like\n$$ L = \\{ \\langle M \\rangle \\mid \\ldots \\}$$\nwhere $M$ is a TM, DFA (or regular-exp), PDA (or grammar), etc.., then $L$ <strong>is not</strong> natural. However $L = \\{xy \\ldots \\mid x \\text{ is a prefix of y} \\ldots \\}$ is natural.</p>\n', 'Tags': '<formal-languages><automata><computability><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:16:00.593', 'CommentCount': '0', 'AcceptedAnswerId': '179', 'CreationDate': '2012-03-10T05:08:27.597', 'Id': '178'}{'Body': "<p>The halting problem cannot be solved in the general case. It is possible to come up with defined rules that restrict allowed inputs and can the halting problem be solved for that special case?</p>\n\n<p>For example, it seems likely that a language that does not allow loops for instance, would be very easy to tell if the program would halt or not.</p>\n\n<p>The problem I'm trying to solve right now is that I'm trying to make a script checker that checks for the validity of the program. Can halting problem be solved if I know exactly what to expect from script writers, meaning very predictable inputs. If this cannot be solved exactly, what are some good approximation techniques to solve this?</p>\n", 'ViewCount': '242', 'Title': 'Is it possible to solve the halting problem if you have a constrained or a predictable input?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-13T00:49:09.953', 'LastEditDate': '2012-03-13T00:20:34.387', 'AnswerCount': '5', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<computability><undecidability><software-engineering><formal-methods>', 'CreationDate': '2012-03-12T23:00:03.130', 'Id': '258'}{'Body': '<p>We learned about the concept of enumerations of functions. In practice, they correspond to programming languages.</p>\n\n<p>In a passing remark, the professor mentioned that the class of all total functions (i.e. the functions that always terminate for every input) is <em>not</em> enumerable. That would mean that we can not devise a programming language that allows us to write all total functions but no others---which would be nice to have!</p>\n\n<p>So how is it that we (apparently) have to accept the potential for non-termination if we want decent computational power?</p>\n', 'ViewCount': '631', 'Title': 'Why are the total functions not enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T09:26:07.503', 'LastEditDate': '2013-09-09T09:26:07.503', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '274', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<computability><enumeration>', 'CreationDate': '2012-03-13T00:02:58.013', 'Id': '266'}{'Body': '<p>At the midterm there was a variant of the following question:</p>\n\n<blockquote>\n  <p>For a decidable $L$ define  $$\\text{Pref}(L) = \\{ x \\mid \\exists y \\text{ s.t. } xy \\in L\\}$$\n  Show that $\\text{Pref}(L)$ is not necessarily decidable.</p>\n</blockquote>\n\n<p>But if I choose $L=\\Sigma^*$ then I think $\\text{Pref}(L)$ is also $\\Sigma^*$, thus decidable. Also $L=\\emptyset$ gives the same result. And since $L$ must be decidable I cannot pick the halting problem or such..</p>\n\n<ol>\n<li>How can I find $L$ such the $\\text{Pref}(L)$ is not decidable?</li>\n<li>Which conditions on $L$ will make $\\text{Pref}(L)$ decidable, and which will make it undecidable?</li>\n</ol>\n', 'ViewCount': '630', 'Title': 'Decidability of prefix language', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-19T22:18:32.557', 'LastEditDate': '2013-03-19T20:27:27.193', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '287', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '157', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-03-13T03:54:05.710', 'Id': '285'}{'Body': "<p>I am a graduate student taking a course in theory of computation and I have serious trouble producing content once I'm asked to. I'm able to follow the textbook (Introduction to the Theory of Computation by Michael Sipser) and lectures; however when asked to prove something or come up with a formal description of a specific TM, I just choke. </p>\n\n<p>What can I do in such situations? I guess my issue is with fully comprehending abstract concepts to the point I can actually use them. Is there a structured way to approaching a new, abstract concept and eventually build intuition?</p>\n", 'ViewCount': '390', 'Title': 'Strategies for becoming unstuck in understanding TCS', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-04T18:07:41.553', 'LastEditDate': '2012-09-02T15:23:23.673', 'AnswerCount': '4', 'CommentCount': '7', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '196', 'Tags': '<computability><education><intuition>', 'CreationDate': '2012-03-13T08:04:00.633', 'FavoriteCount': '3', 'Id': '294'}{'ViewCount': '4546', 'Title': 'How can it be decidable whether $\\pi$ has some sequence of digits?', 'LastEditDate': '2012-03-14T16:40:56.483', 'AnswerCount': '2', 'Score': '54', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '11', 'Body': '<p>We were given the following exercise.</p>\n\n<blockquote>\n  <p>Let</p>\n  \n  <p>$\\qquad \\displaystyle f(n) = \\begin{cases} 1 &amp; 0^n \\text{ occurs in the decimal representation of } \\pi \\\\ 0 &amp; \\text{else}\\end{cases}$</p>\n  \n  <p>Prove that $f$ is computable.</p>\n</blockquote>\n\n<p>How is this possible? As far as I know, we do not know wether $\\pi$ contains every sequence of digits (or which) and an algorithm can certainly not decide that some sequence is <em>not</em> occurring. Therefore I think $f$ is not computable, because the underlying problem is only semi-decidable.</p>\n', 'Tags': '<computability><undecidability>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-08-13T10:53:55.560', 'CommentCount': '2', 'AcceptedAnswerId': '369', 'CreationDate': '2012-03-14T13:19:52.857', 'Id': '367'}{'Body': '<p><a href="http://cs.stackexchange.com/questions/367/how-can-it-be-decidable-whether-pi-has-some-sequence-of-digits">How can it be decidable whether $\\pi$ has some sequence of digits?</a> inspired me to ask whether the following innocent-looking variation is computable:</p>\n\n<p>$$f(n) = \\begin{cases}\r\n  1 &amp; \\text{if \\(\\bar n\\) occurs in the decimal representation of \\(\\pi\\)} \\\\\r\n  0 &amp; \\text{otherwise} \\\\\r\n\\end{cases}$$</p>\n\n<p>where $\\bar n$ is the decimal representation of $n$ with no leading zeroes.</p>\n\n<p>If the decimal expansion of $\\pi$ contains all finite digit sequences (let\'s call this a <a href="http://fr.wikipedia.org/wiki/Nombre_univers" rel="nofollow">universal number</a> (in base 10)), then $f$ is the constant $1$. But this is an open mathematical question. If $\\pi$ is not universal, does this mean that $f$ is uncomputable?</p>\n', 'ViewCount': '150', 'Title': 'Is a function looking for subsequences of digits of $\\pi$ computable?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-03-15T15:08:30.000', 'LastEditDate': '2012-03-15T15:08:30.000', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<computability><real-numbers>', 'CreationDate': '2012-03-15T00:49:03.667', 'FavoriteCount': '1', 'Id': '401'}{'Body': u'<p>I\'ve always thought vaguely that the answer to the above question was affirmative along the following lines. G\xf6del\'s incompleteness theorem and the undecidability of the halting problem both being negative results about decidability and established by diagonal arguments (and in the 1930\'s), so they must somehow be two ways to view the same matters. And I thought that Turing used a universal Turing machine to show that the halting problem is unsolvable. (See also <a href="http://math.stackexchange.com/questions/108964/halting-problem-and-universality">this math.SE</a> question.)</p>\n\n<p>But now that (teaching a course in computability) I look closer into these matters, I am rather bewildered by what I find. So I would like some help with straightening out my thoughts. I realise that one one hand G\xf6del\'s diagonal argument is very subtle: it needs a lot of work to construct an arithmetic statement that can be interpreted as saying something about it\'s own derivability. On the other hand the proof of the undecidability of the halting problem I found <a href="http://en.wikipedia.org/wiki/Halting_problem#Sketch_of_proof">here</a> is extremely simple, and doesn\'t even explicitly mention Turing machines, let alone the existence of universal Turing machines.</p>\n\n<p>A practical question about universal Turing machines is whether it is of any importance that the alphabet of a universal Turing machine be the same as that of the Turing machines that it simulates. I thought that would be necessary in order to concoct a proper diagonal argument (having the machine simulate itself), but I haven\'t found any attention to this question in the bewildering collection of descriptions of universal machines that I found on the net. If not for the halting problem, are universal Turing machines useful in any diagonal argument?</p>\n\n<p>Finally I am confused by <a href="http://en.wikipedia.org/wiki/Halting_problem#Relationship_with_G.C3.B6del.27s_incompleteness_theorem">this further section</a> of the same WP article, which says that a weaker form of G\xf6del\'s incompleteness follows from the halting problem: "a complete, consistent and sound axiomatization of all statements about natural numbers is unachievable" where "sound" is supposed to be the weakening. I know a theory is consistent if one cannot derive a contradiction, and a complete theory about natural numbers would seem to mean that all true statements about natural numbers can be derived in it; I know G\xf6del says such a theory does not exist, but I fail to see how such a hypothetical beast could possibly fail to be sound, i.e., also derive statements which are false for the natural numbers: the negation of such a statement would be true, and therefore by completeness also derivable, which would contradict consistency.</p>\n\n<p>I would appreciate any clarification on one of these points.</p>\n', 'ViewCount': '2098', 'Title': u"Is there any concrete relation between G\xf6del's incompleteness theorem, the halting problem and universal Turing machines?", 'LastActivityDate': '2012-03-21T06:56:38.617', 'AnswerCount': '4', 'CommentCount': '4', 'AcceptedAnswerId': '585', 'Score': '37', 'PostTypeId': '1', 'OwnerUserId': '136', 'Tags': '<computability><logic>', 'CreationDate': '2012-03-15T16:43:28.693', 'FavoriteCount': '9', 'Id': '419'}{'ViewCount': '298', 'Title': 'Easy to state open problems in computability theory', 'LastEditDate': '2012-03-16T00:43:34.430', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '41', 'FavoriteCount': '1', 'Body': '<p>I was searching for interesting and easy to state open problems in computability (understandable by undergraduate students taking their first course in computability) to give examples of open problems (and obviously I want the students to be able to understand the problem without needing too much new definitions and also be interesting to them). </p>\n\n<p>I found <a href="http://math.berkeley.edu/~slaman/qrt/qrt.pdf">this list</a> but the problems in it seem too complicated for undergraduates and will need spending considerable time giving definitions before stating the problem. The only problem I have found so far is </p>\n\n<blockquote>\n  <p>Is Diophantine problem over rational numbers decidable?</p>\n</blockquote>\n\n<p>Do you know any other interesting and easy to state open problem in computability theory?</p>\n', 'Tags': '<computability>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-16T02:35:02.933', 'CommentCount': '3', 'AcceptedAnswerId': '432', 'CreationDate': '2012-03-16T00:21:37.827', 'Id': '430'}{'Body': '<p>Rewriting system is a set of rules in the form of  $A \\leftrightarrow B$. \nIf we apply that rule to a string $w$ we replace any substring $A$ in $w$ with a substring $B$ and vice versa.</p>\n\n<p>Given a starting string $AAABB$ can we derive $BAAB$ in the system with the following rules:</p>\n\n<ul>\n<li>$A \\leftrightarrow BA$</li>\n<li>$BABA \\leftrightarrow AABB$</li>\n<li>$AAA \\leftrightarrow AB$</li>\n<li>$BA \\leftrightarrow AB$</li>\n</ul>\n\n<p>Is there a general algorithm for that?</p>\n', 'ViewCount': '63', 'Title': 'Is it possible to derive a string in this rewriting system?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-16T12:16:33.377', 'LastEditDate': '2012-03-16T12:16:33.377', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '434', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '147', 'Tags': '<computability><term-rewriting>', 'CreationDate': '2012-03-16T05:05:58.920', 'Id': '433'}{'ViewCount': '574', 'Title': 'Is interaction more powerful than algorithms?', 'LastEditDate': '2013-03-20T20:57:17.867', 'AnswerCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '3', 'Body': '<p>I\'ve heard the motto <a href="http://www.cs.brown.edu/people/pw/papers/ficacm.ps"><strong>interaction is more powerful than algorithms</strong></a> from <a href="http://www.cs.brown.edu/~pw/">Peter Wegner</a>. The basis of the idea is that a (classical) Turing Machine cannot handle interaction, that is, communication (input/output) with the outside world/environment.</p>\n\n<blockquote>\n  <p>How can this be so? How can something be more powerful than a Turing Machine? What is the essence of this story? Why is it not more well known?</p>\n</blockquote>\n', 'Tags': '<computability><computation-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T20:57:17.867', 'CommentCount': '8', 'AcceptedAnswerId': '488', 'CreationDate': '2012-03-16T20:33:26.857', 'Id': '438'}{'Body': '<p>I was given the question </p>\n\n<blockquote>\n  <p>Where does the following language fit in the Chomsky hierarchy?</p>\n  \n  <p>Nonnegative solutions $(x,y)$ to the Diophantine equation $3x-y=1$.</p>\n</blockquote>\n\n<p>I understand languages like $L = \\{ 0^n1^n \\mid n \\ge 1\\}$, but this language confuses me. What do the words in the language look like? How could I represent it using a grammar or regular expression?</p>\n', 'ViewCount': '204', 'Title': 'How can solutions of a Diophantine equation be expressed as a language?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T16:32:48.977', 'LastEditDate': '2012-03-25T16:32:48.977', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><computability>', 'CreationDate': '2012-03-21T18:09:06.090', 'Id': '618'}{'Body': '<p><em>Note this is a question related to study in a CS course at a university, it is NOT homework and can be found <a href="http://www.cs.ucf.edu/~dmarino/ucf/transparency/cot4210/exam/">here</a> under Fall 2011 exam2.</em></p>\n\n<p>Here are the two questions I\'m looking at from a past exam.  They seem to be related, the first:</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{CFG}} = \\{ &lt; \\! G \\! &gt; \\mid G \\text{ is a Context Free Grammar with } |\\mathcal{L}(G)|&lt;\\infty \\} $</p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{CFG}}$ is a decidable language.   </p>\n</blockquote>\n\n<p>and...</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{TM}} = \\{ &lt; \\! M\\!&gt; \\mid M \\text{ is a Turing Machine with } |\\mathcal{L}(M)|&lt;\\infty \\}$ </p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{TM}}$ is an undecidable language.   </p>\n</blockquote>\n\n<p>I am a bit lost on how to tackle these problems, but I have a few insights which I think may be in the right direction.  The first thing is that I am aware of is that the language $A_{\\mathrm{REX}}$, where </p>\n\n<blockquote>\n  <p>$\\qquad A_{\\mathrm{REX}} = \\{ &lt;\\! R, w \\!&gt; \\mid R \\text{ is a regular expression with } w \\in\\mathcal{L}(R)\\}$</p>\n</blockquote>\n\n<p>is a decidable language (proof is in Michael Sipser\'s <i>Theory of Computation</i>, pg. 168).  The same source also proves that a Context Free Grammar can be converted to a regular expression, and vice versa.  Thus $A_{\\mathrm{CFG}}$, must also be decidable as it can be converted to a regular expression.  This, and the fact that $A_{\\mathrm{TM}}$ is <b>un</b>-decidable, seems to be related to this problem.</p>\n\n<p>The only thing I can think of is passing G to Turing machines for $A_{\\mathrm{REX}}$ (after converting G to a regular expression) and $A_{\\mathrm{TM}}$.  Then accepting if G does and rejecting if G doesn\'t.  As $A_{\\mathrm{TM}}$ is undecidable, this will never happen.  Somehow I feel like I\'m making a mistake here, but I\'m not sure of what it is.  Could someone please lend me a hand here? </p>\n', 'ViewCount': '639', 'Title': 'Decidablity of Languages of Grammars and Automata', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T02:52:20.370', 'LastEditDate': '2012-03-27T02:52:20.370', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '629', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><computability><context-free><regular-languages><turing-machines>', 'CreationDate': '2012-03-21T20:07:51.783', 'Id': '627'}{'Body': "<p>OK, so here is a question from a past test in my Theory of Computation class:</p>\n\n<blockquote>\n  <p>A useless state in a TM is one that is never entered on any input string.  Let $$\\mathrm{USELESS}_{\\mathrm{TM}} = \\{\\langle M, q \\rangle \\mid  q \\text{ is a useless state in }M\\}.$$\n  Prove that $\\mathrm{USELESS}_{\\mathrm{TM}}$ is undecidable. </p>\n</blockquote>\n\n<p>I think I have an answer, but I'm not sure if it is correct.   Will include it in the answer section.</p>\n", 'ViewCount': '765', 'Title': 'A Question relating to a Turing Machine with a useless state', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T20:56:08.023', 'LastEditDate': '2012-03-25T20:56:08.023', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '637', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<computability><undecidability><formal-methods><turing-machines>', 'CreationDate': '2012-03-22T00:21:58.210', 'Id': '636'}{'ViewCount': '2944', 'Title': 'Are Turing machines more powerful than pushdown automata?', 'LastEditDate': '2012-03-25T15:41:43.987', 'AnswerCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': "<p>I've came up with a result while reading some automata books, that Turing machines appear to be more powerful than pushdown automata. Since the tape of a Turing machine can always be made to behave like a stack, it'd seem that we can actually claim that TMs are more powerful. </p>\n\n<p>Is this true?</p>\n", 'Tags': '<formal-languages><computability><automata><turing-machines><pushdown-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-16T18:31:50.493', 'CommentCount': '4', 'AcceptedAnswerId': '670', 'CreationDate': '2012-03-22T20:00:29.897', 'Id': '669'}{'Body': '<p>Note that by "two-way pushdown automaton", I mean a pushdown automaton that can move its reading head both ways on the input tape.</p>\n\n<p>I recently had the question of determining the computational power of two-way PDAs in the Chomsky hierarchy. I don\'t entirely understand two-way PDAs, but I can see how with the ability to read in both directions on the input, it could handle languages of the form $L=\\{0^n 1^n 2^n\\}$. I can\'t say that for sure, but it seems that would make it powerful enough to least handle context-sensitive languages. </p>\n\n<p>This is all a guess because I don\'t know exactly how they work. Can someone explain the process of how a two-way PDA operates, maybe even on my example?</p>\n\n<p>UPDATE: </p>\n\n<blockquote>\n  <p>The model is a generalization of a pushdown automaton in that two-way motion is allowed on the input tape which is assumed to have endmarkers. </p>\n</blockquote>\n', 'ViewCount': '1078', 'Title': 'How does a two-way pushdown automaton work?', 'LastEditorUserId': '69', 'LastActivityDate': '2012-04-02T15:40:37.177', 'LastEditDate': '2012-04-02T15:40:37.177', 'AnswerCount': '1', 'CommentCount': '12', 'AcceptedAnswerId': '705', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><computability><automata><pushdown-automata>', 'CreationDate': '2012-03-23T15:39:20.283', 'Id': '699'}{'ViewCount': '499', 'Title': 'Decidable restrictions of the Post Correspondence Problem', 'LastEditDate': '2012-09-21T13:15:50.123', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Post_correspondence_problem" rel="nofollow">Post Correspondence Problem</a> (PCP) is undecidable.</p>\n\n<p>The <em>bounded version of the PCP</em> is $\\mathrm{NP}$-complete and the <em>marked version of the PCP</em> (the words of one of the two lists are required to differ in the first letter) is in $\\mathrm{PSPACE}$ [1].</p>\n\n<ol>\n<li>Are these restricted versions used to prove some complexity results of other problems (through reduction)?</li>\n<li>Are there other restricted versions of the PCP that make it decidable (and in particular $\\mathrm{PSPACE}$-complete)?</li>\n</ol>\n\n<p>[1] "<a href="http://dx.doi.org/10.1016/S0304-3975%2899%2900163-2" rel="nofollow">Marked PCP is decidable</a>" by V. Halava, M. Hirvensalo, R. De Wolf (1999)</p>\n', 'Tags': '<complexity-theory><computability><reference-request>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-21T13:15:50.123', 'CommentCount': '0', 'AcceptedAnswerId': '4638', 'CreationDate': '2012-03-23T17:15:49.773', 'Id': '701'}{'Body': '<p>I <a href="http://blog.computationalcomplexity.org/2004/04/blum-complexity-measures.html" rel="nofollow">read</a> that the number of coin tosses of a probabilistic Turing machine (PTM) is not a <a href="http://en.wikipedia.org/wiki/Blum_axioms" rel="nofollow">Blum complexity measure</a>. Why?</p>\n\n<p>Clarification:</p>\n\n<p>Note that since the execution of the machine is not deterministic, one should be careful about defining the number of coin tosses for a PTM $M$ on input $x$ in a way similar to the time complexity for NTMs and PTMs. One way is to define it as the maximum number of coin tosses over possible executions of $M$ on $x$.</p>\n\n<p>We need the definition to satisfy the axiom about decidability of $m(M,x)=k$. We can define it as follows:</p>\n\n<p>$$\nm(M,x) =\n\\begin{cases}\nk &amp; \\text{all executions of $M$ on $x$ halt, $k=\\max$ #coin tosses} \\\\\n\\infty &amp; o.w. \\\n\\end{cases}\n$$</p>\n\n<p>The number of random bits that an algorithm uses is a complexity measure that appears in papers, e.g. "algorithm $A$ uses only $\\lg n$ random bits, whereas algorithm $B$ uses $n$ random bits".</p>\n', 'ViewCount': '119', 'Title': 'Is the number of coin tosses of a probabilistic Turing machine a Blum complexity measure?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-28T17:32:38.167', 'LastEditDate': '2012-03-28T17:32:38.167', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<computability><complexity-theory><randomness><probabilistic-algorithms>', 'CreationDate': '2012-03-27T20:35:16.207', 'Id': '835'}{'ViewCount': '1652', 'Title': 'Are there minimum criteria for a programming language being Turing complete?', 'LastEditDate': '2012-04-15T18:17:23.073', 'AnswerCount': '5', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '385', 'FavoriteCount': '6', 'Body': '<p>Does there exist a set of programming language constructs in a programming language in order for it to be considered Turing Complete?</p>\n\n<p>From what I can tell from <a href="http://en.wikipedia.org/wiki/Turing_completeness">wikipedia</a>, the language needs to support recursion, or, seemingly, must be able to run without halting. Is this all there is to it?</p>\n', 'Tags': '<computability><programming-languages><turing-machines><turing-completeness>', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-19T19:43:12.440', 'CommentCount': '3', 'AcceptedAnswerId': '995', 'CreationDate': '2012-04-02T13:40:03.487', 'Id': '991'}{'ViewCount': '321', 'Title': 'What is required for universal analogue computation?', 'LastEditDate': '2012-04-15T22:27:58.790', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1101', 'FavoriteCount': '1', 'Body': '<p>What operations need to be performed in order to do any arbitrary <a href="http://en.wikipedia.org/wiki/Analog_computer" rel="nofollow">analogue computation</a>? Would addition, subtraction, multiplication and division be sufficient?</p>\n\n<p>Also, does anyone know exactly what problems are tractable using analogue computation, but not with digital?</p>\n', 'Tags': '<computability><computation-models><turing-completeness>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-25T12:25:53.527', 'CommentCount': '10', 'AcceptedAnswerId': '1293', 'CreationDate': '2012-04-15T15:04:06.820', 'Id': '1292'}{'Body': '<p>I am studying different approaches for the definition of computation with continuous dynamical systems. I have been trying to find a nice introduction to the theory of <a href="http://en.wikipedia.org/wiki/State_transition_system">"State transition systems"</a> but failed to do so.</p>\n\n<p>Does anybody know a modern introduction to the topic? \nOf particular interest would be something dealing with computability.</p>\n', 'ViewCount': '186', 'Title': 'What is a good reference to learn about state transition systems?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T18:45:31.160', 'LastEditDate': '2012-04-18T18:45:31.160', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '715', 'Tags': '<computability><automata><reference-request><computation-models>', 'CreationDate': '2012-04-18T09:13:20.920', 'FavoriteCount': '1', 'Id': '1335'}{'ViewCount': '186', 'Title': 'What is co-something?', 'LastEditDate': '2012-04-20T10:18:16.487', 'AnswerCount': '2', 'Score': '5', 'OwnerDisplayName': 'Vanwaril', 'PostTypeId': '1', 'OwnerUserId': '1160', 'Body': '<p>What does the notation <code>co-</code> mean when prefixing <code>co-NP</code>, <code>co-RE</code> (recursively enumerable), or <code>co-CE</code> (computably enumerable) ?</p>\n', 'Tags': '<complexity-theory><computability><terminology>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-20T10:18:16.487', 'CommentCount': '4', 'AcceptedAnswerId': '1372', 'CreationDate': '2012-04-19T20:06:10.973', 'Id': '1370'}{'Body': u'<p>Let A and B be languages with A \u2286 B, and B is Turing-recognizable. Can A be not Turing-recognizable? If so, is there any example?</p>\n', 'ViewCount': '463', 'Title': 'Sub language is not Turing-recognizable, or could it be?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-06T19:25:36.940', 'LastEditDate': '2012-04-22T12:55:17.770', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '1430', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1192', 'Tags': '<computability>', 'CreationDate': '2012-04-22T02:24:17.757', 'Id': '1427'}{'Body': '<p>I\'m studying for my final in theory of computation, and I\'m struggling with the proper way of answering whether this statement is true of false.</p>\n\n<p>By the <a href="https://en.wikipedia.org/wiki/Mapping_reducibility" rel="nofollow">definition</a> of $\\leq_m$ we can construct the following statement, </p>\n\n<p>$w \\in A \\iff f(w) \\in B \\rightarrow w \\notin A \\iff f(w) \\notin B$ </p>\n\n<p>This is where I\'m stuck, I want to say that since we have such computable function $f$ then it\'ll only give us the mapping from A to B if there is one, otherwise it wont. </p>\n\n<p>I don\'t know how to phrase this correctly, or if I\'m even on the right track.</p>\n', 'ViewCount': '776', 'Title': 'If A is mapping reducible to B then the complement of A is mapping reducible to the complement of B', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-23T07:12:26.980', 'LastEditDate': '2012-05-23T07:12:26.980', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1520', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '196', 'Tags': '<complexity-theory><computability><reductions>', 'CreationDate': '2012-04-26T20:00:07.483', 'Id': '1517'}{'ViewCount': '337', 'Title': 'Turing reducibility implies mapping reducibility', 'LastEditDate': '2012-04-30T01:11:53.080', 'AnswerCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '196', 'FavoriteCount': '1', 'Body': '<p>The question is whether the following statement is true or false:</p>\n\n<p>$A \\leq_T B \\implies A \\leq_m B$</p>\n\n<p>I know that if $A \\leq_T B$ then there is an oracle which can decide A relative to B. I know that this is not enough to say that there is a computable function from A to B that can satisfy the reduction.</p>\n\n<p>I don\'t know how to word this in the proper way or if what I\'m saying is enough to say that the statement is false. How would I go about showing this?</p>\n\n<p>EDIT: This is not a homework problem per se, I\'m reviewing for a test.\nWhere $\\leq_T$ is <a href="http://en.wikipedia.org/wiki/Turing_reduction" rel="nofollow">Turing reducibility</a>, and $\\leq_m$ is <a href="http://en.wikipedia.org/wiki/Mapping_reduction" rel="nofollow">mapping reducibility</a>.</p>\n', 'Tags': '<computability><reductions><turing-machines>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-03T11:58:52.843', 'CommentCount': '0', 'AcceptedAnswerId': '1563', 'CreationDate': '2012-04-29T04:57:06.113', 'Id': '1562'}{'Body': '<p>One of the definitions of a computably enumerable (c.e., equivalent to recursively enumerable, equivalent to semidecidable) set is the following:</p>\n\n<blockquote>\n  <p>$A \\subseteq \\Sigma^*$ is c.e. iff there is a decidable language $V\\subseteq \\Sigma^*$ (called verifier) s.t. \n  for all $x\\in \\Sigma^*$, </p>\n  \n  <p>$x\\in A$ iff there exists a $y\\in\\Sigma^*$ s.t. $\\langle x, y \\rangle \\in V$.</p>\n</blockquote>\n\n<p>So one way to show that a language is not c.e. is to show that there is no decidable verifier $V$ for it. Is this method useful to show that languages are not c.e. in practice?</p>\n', 'ViewCount': '256', 'Title': 'Can we show a language is not computably enumerable by showing there is no verifier for it?', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-03T11:46:38.007', 'LastEditDate': '2012-04-30T08:01:59.740', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1314', 'Tags': '<computability><proof-techniques><undecidability>', 'CreationDate': '2012-04-30T05:32:15.673', 'Id': '1586'}{'Body': '<p>I have a general question about mapping reductions. I have seen several examples of reducing functions to $A_{TM}$</p>\n\n<p>where $A_{TM} = \\{\\langle M, w \\rangle : \\text{ For } M \\text{ is a turing machine which accepts string } w\\}$</p>\n\n<p>which is great for proving undecidability. But say I want to prove unrecognizability instead. That is, I want to use the corollary that given $A \\le_{m} B$, if $A$ is unrecognizable then $B$ is unrecognizable.</p>\n\n<p>So for any arbitrary unrecognizable language $C$ which can be reduced to $\\overline{A_{TM}}$ (any example language would suffice for sake of example), how can I reduce $\\overline{A_{TM}} \\le_{m} C$?</p>\n\n<p>For simplicity, suffice to merely consider TM in $\\overline{A_{TM}}$.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>For clarification, $\\overline{A_{TM}} = \\{ \\langle M, w \\rangle : M \\text{ is a turing machine which does not accept string } w \\}$</p>\n', 'ViewCount': '381', 'Title': 'Mapping Reductions to Complement of A$_{TM}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T13:12:53.150', 'LastEditDate': '2012-05-09T13:12:53.150', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1604', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1057', 'Tags': '<computability><proof-techniques><reductions>', 'CreationDate': '2012-05-01T00:13:40.497', 'Id': '1603'}{'Body': '<p>Are there undecidable properties of linear bounded automata (avoiding the empty set language trick)? What about for a deterministic finite automaton? (put aside intractability). </p>\n\n<p>I would like to get an example (if possible) of an undecidable problem that is defined <em>without using Turing machines</em> explicitly.</p>\n\n<p>Is Turing completeness of a model necessary to support uncomputable problems?</p>\n', 'ViewCount': '506', 'Title': 'Are there undecidable properties of non-turing-complete automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-23T18:22:59.677', 'LastEditDate': '2012-05-10T14:18:02.203', 'AnswerCount': '5', 'CommentCount': '5', 'AcceptedAnswerId': '1699', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<computability><automata><undecidability>', 'CreationDate': '2012-05-06T21:35:14.827', 'Id': '1697'}{'Body': '<p>A recent exam question went as follows:</p>\n\n<blockquote>\n  <ol>\n  <li>$A$ is an infinite recursively enumerable set. Prove that $A$ has an infinite recursive subset.</li>\n  <li>Let $C$ be an infinite recursive subset of $A$. Must $C$ have a subset that is <em>not</em> recursively enumerable?</li>\n  </ol>\n</blockquote>\n\n<p>I answered 1. already. Regarding 2., I answered affirmatively and argued as follows. </p>\n\n<p>Suppose that all the subsets of $C$ were recursively enumerable. Since $C$ is infinite, the power set of $C$ is uncountable, so by assumption there would be uncountably many recursively enumerable sets. But the recursively enumerable sets are in one-to-one correspondence with the Turing machines that recognize them, and Turing machines are enumerable. Contradiction. So $C$ must have a subset that is not recursively enumerable.</p>\n\n<p>Is this correct?</p>\n', 'ViewCount': '625', 'Title': 'subsets of infinite recursive sets', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T15:08:27.217', 'LastEditDate': '2012-05-14T15:08:27.217', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1435', 'Tags': '<computability><check-my-proof>', 'CreationDate': '2012-05-11T03:35:27.040', 'FavoriteCount': '1', 'Id': '1790'}{'Body': "<p>This is a question I have stumbled upon in my exam revision and I find it intriguing:</p>\n\n<p><strong>My computer is blue and it has a massive graphics card and a DVD and every-\nthing so which is more powerful: my computer or a Pushdown Automaton?</strong></p>\n\n<hr>\n\n<h2>My Thoughts</h2>\n\n<p>When we talk about power I have assumed this to be computational power. I believe that a PDA has the computational power to equal the computational power of a CPU (cpu in this case is the core elements of a computer ie memory and processor). This is because a PDA utilises a stack which is memory(RAM) in a computer. The PDA has states as does a CPU and also the PDA calculates simple logic at each state. I realise that the PDA itself would be a complex series of states to emulate the computational power of the cpu and there would have to be a series of PDAs to compute different functions.  </p>\n\n<p>My Question:  I know that Turing machines are best used to simulate the logic of a CPU but <strong>am I right in saying that a PDA (Or PDA's) can be designed to be as powerful as a cpu?</strong></p>\n", 'ViewCount': '516', 'Title': 'Is a PDA as powerful as a CPU?', 'LastEditorUserId': '55', 'LastActivityDate': '2012-05-16T13:59:34.493', 'LastEditDate': '2012-05-16T12:48:10.083', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'OwnerDisplayName': 'Mike Howard', 'PostTypeId': '1', 'Tags': '<computability><computation-models><computable-analysis>', 'CreationDate': '2012-05-16T10:47:59.193', 'Id': '1868'}{'ViewCount': '1059', 'Title': "Why isn't this undecidable problem in NP?", 'LastEditDate': '2013-10-05T23:00:15.917', 'AnswerCount': '3', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1528', 'FavoriteCount': '2', 'Body': '<p>Clearly there aren\'t any undecidable problems in NP.  However, according to <a href="http://en.wikipedia.org/wiki/NP_%28complexity%29" rel="nofollow">Wikipedia</a>:</p>\n\n<blockquote>\n  <p>NP is the set of all decision problems for which the instances where the answer is "yes" have [.. proofs that are] verifiable in polynomial time by a deterministic Turing machine.</p>\n  \n  <p>[...]</p>\n  \n  <p>A problem is said to be in NP if and only if there exists a verifier for the problem that executes in polynomial time.</p>\n</blockquote>\n\n<p>Now consider the following problem:</p>\n\n<blockquote>\n  <p>Given a <a href="http://en.wikipedia.org/wiki/Diophantine_equation" rel="nofollow">Diophantine equation</a>, does it have any integer solutions?</p>\n</blockquote>\n\n<p>Given a solution, it\'s easy to verify in polynomial time that it really <em>is</em> a solution:  just plug the numbers into the equation.  Thus, the problem is in NP.  However, <em>solving</em> this problem is famously <a href="http://en.wikipedia.org/wiki/Hilbert%27s_tenth_problem" rel="nofollow">known to be undecidable</a>!</p>\n\n<p><em>(Similarly, it seems the halting problem should be in NP, since the "yes"-solution of "this program halts at the N-th step" can be verified in N steps.)</em></p>\n\n<p>Obviously there\'s something wrong with my understanding, but what is it?</p>\n', 'Tags': '<complexity-theory><computability><undecidability><decision-problem>', 'LastEditorUserId': '1528', 'LastActivityDate': '2013-10-05T23:00:15.917', 'CommentCount': '4', 'AcceptedAnswerId': '1902', 'CreationDate': '2012-05-17T16:50:51.853', 'Id': '1887'}{'Body': u"<p>I would like to use your help with the following problem:</p>\n\n<p>$L=\\{\u27e8M\u27e9 \u2223 L(M) \\mbox{ is context-free} \\}$. Show that $L \\notin RE \\cup  CoRE$.</p>\n\n<p>I know that to prove $L\\notin RE$, it is enough to find a language $L'$ such that $L'\\notin RE$ and show that there is a reduction from $L'$ to $L$ $(L'\\leq _M L)$.</p>\n\n<p>I started to think of languages which I already know that they are not in $RE$, and I know that $Halt^* =\\{\u27e8M\u27e9 \u2223 M\\mbox{ halts for every input} \\} \\notin RE$. I thought of this reduction from $Halt^*$ to $L$: $f(\u27e8M\u27e9)=(M')$. for every $\u27e8M\u27e9$: if $M$ halts for every input  $L(M')=0^n1^n$ otherwise it would be $o^n1^n0^n$, but this is not correct, Isn't it? How can I check that $M$ halts for every input to begin with? and- is this the way to do that?</p>\n", 'ViewCount': '295', 'Title': u'Proof that $\\{\u27e8M\u27e9 \u2223 L(M) \\mbox{ is context-free} \\}$ is not (co-)recursively enumerable', 'LastEditorUserId': '1589', 'LastActivityDate': '2012-05-22T01:10:33.537', 'LastEditDate': '2012-05-21T21:24:16.623', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1985', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<formal-languages><computability><context-free><turing-machines>', 'CreationDate': '2012-05-21T19:28:38.840', 'Id': '1979'}{'ViewCount': '1041', 'Title': 'Is there an undecidable finite language of finite words?', 'LastEditDate': '2012-05-24T13:02:04.297', 'AnswerCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1396', 'FavoriteCount': '2', 'Body': '<p>Is there <em>a need</em> for $L\\subseteq \\Sigma^*$ to be <em>infinite</em> to be undecidable?</p>\n\n<p>I mean what if we choose a language $L\'$ be a <em>bounded finite version of</em> $L\\subseteq \\Sigma^*$, that is $|L\'|\\leq N$, ($N \\in \\mathbb{N}$), with $L\' \\subset L$.  Is it possible for $L\'$ to be an undecidable language?  </p>\n\n<p>I see that there is a problem of "How to choose the $N$ words that $\\in$ $L\' "$ for which we have to establish a rule for choosing which would be the first $N$ elements of $L\'$, a kind of "finite" Kleene star operation. The aim is to find undecidability language without needing an infinite set, but I can\'t see it.</p>\n\n<p><strong>EDIT Note:</strong> </p>\n\n<p>Although I chose an answer, many answers <strong>and all comments</strong> are important.</p>\n', 'Tags': '<formal-languages><computability><undecidability>', 'LastEditorUserId': '1396', 'LastActivityDate': '2013-01-02T01:05:19.163', 'CommentCount': '11', 'AcceptedAnswerId': '2014', 'CreationDate': '2012-05-22T13:11:23.497', 'Id': '1990'}{'Body': '<p>From this statement </p>\n\n<blockquote>\n  <p>As there is no surjection from $\\mathbb{N}$ onto $\\mathcal{P}(\\mathbb{N})$, thus there must exist an undecidable language.</p>\n</blockquote>\n\n<p>I would like to understand why similar reasoning does not work with a <em>finite</em> set $B$ which also has no surjection onto $\\mathcal{P}(B)$!  (with $|B|=K$ and $K \\in \\mathbb{N}$)</p>\n\n<p>Why is there a minimum need for the infinite set? </p>\n\n<p><strong>EDIT Note:</strong> </p>\n\n<p>Although I chose an answer, many answers <strong>and all comments</strong> are important.</p>\n', 'ViewCount': '161', 'Title': 'Why absence of surjection with the power set is not enough to prove the existence of an undecidable language?', 'LastEditorUserId': '1396', 'LastActivityDate': '2012-05-24T13:02:44.670', 'LastEditDate': '2012-05-24T13:02:44.670', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1997', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2012-05-22T14:23:03.890', 'Id': '1993'}{'ViewCount': '948', 'Title': 'Ternary processing instead of Binary', 'LastEditDate': '2012-05-24T10:55:18.980', 'AnswerCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1543', 'FavoriteCount': '2', 'Body': '<p>Most of the computers available today are designed to work with binary system. It comes from the fact that information comes in two natural form, <strong>true</strong> or <strong>false</strong>.</p>\n\n<p>We humans accept another form of information called "maybe" :)</p>\n\n<p>I know there are ternary processing computers but not much information about them.</p>\n\n<ol>\n<li>What is the <strong>advantages</strong> / <strong>disadvantages</strong> of designing and using ternary or higher levels of data  signals in computers? </li>\n<li>Is it feasible? </li>\n<li>In which domain can it be better than classic binary systems?</li>\n<li>Can we give computers the chance to make mistakes and expect to see performance \nimprovements in most situations by this way? (I think performance gains can be observed if computers are not so strict about being absolutely correct)</li>\n</ol>\n\n<p><strong>EDIT:</strong> Are there difficulties differentiating between 3 levels of signal? Would it be too hard to keep data in memory since memory voltage is frequently released and loaded, (maybe hundreds of time a second?).</p>\n', 'Tags': '<computability><computer-architecture>', 'LastEditorUserId': '1543', 'LastActivityDate': '2012-05-30T05:30:06.650', 'CommentCount': '5', 'AcceptedAnswerId': '2042', 'CreationDate': '2012-05-24T09:10:58.547', 'Id': '2040'}{'ViewCount': '501', 'Title': 'How do you check if two algorithms return the same result for any input?', 'LastEditDate': '2012-05-25T20:16:22.707', 'AnswerCount': '4', 'Score': '9', 'OwnerDisplayName': 'Andres Riofrio', 'PostTypeId': '1', 'OwnerUserId': '1638', 'FavoriteCount': '2', 'Body': u'<p>How do you check if two algorithms (say, Merge sort and Na\xefve sort) return the same result for any input, when the set of all inputs is infinite?</p>\n\n<p><strong>Update:</strong> Thank you <a href="http://cs.stackexchange.com/a/2062/1638">Ben</a> for describing how this is impossible to do algorithmically in the general case. <a href="http://cs.stackexchange.com/a/2063/1638">Dave\'s answer</a> is a great summary of both algorithmic and manual (subject to human wit and metaphor) methods that don\'t always work, but are quite effective.</p>\n', 'Tags': '<computability><formal-methods><software-engineering><software-verification><program-verification>', 'LastEditorUserId': '1638', 'LastActivityDate': '2012-05-25T20:16:22.707', 'CommentCount': '8', 'CreationDate': '2012-05-25T00:03:21.817', 'Id': '2059'}{'ViewCount': '267', 'Title': 'Simple explanation as to why certain computable functions cannot be represented by a typed term?', 'LastEditDate': '2012-05-26T14:40:07.843', 'AnswerCount': '3', 'Score': '7', 'OwnerDisplayName': 'ixtmixilix', 'PostTypeId': '1', 'OwnerUserId': '1693', 'FavoriteCount': '1', 'Body': '<p>Reading the paper <a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf">An Introduction to the Lambda Calculus</a>, I came across a paragraph I didn\'t really understand, on page 34 (my italics):</p>\n\n<blockquote>\n  <p>Within each of the two paradigms there are several versions of typed\n  lambda calculus. In many important systems, especially those a la\n  Church, it is the case that terms that do have a type always possess a\n  normal form. By the unsolvability of the halting problem this\n  implies that not all computable functions can be represented by a\n  typed term, see Barendregt (1990), Theorem 4.2.15. This is not so bad\n  as it sounds, because in order to find such computable functions that\n  cannot be represented, one has to stand on one\'s head. For example in\n  2, the second order typed lambda calculus, only those partial\n  recursive functions cannot be represented that happen to be total,\n  but not provably so in mathematical analysis (second order\n  arithmetic).</p>\n</blockquote>\n\n<p>I am familiar with most of these concepts, but not the concept of a partial recursive function, nor the concept of a provably total function. However, this is not what I am interested in learning.</p>\n\n<p>I am looking for a simple explanation as to why certain computable functions cannot be represented by a typed term, as well as to why such functions can only be found \'by standing on one\'s head.\'</p>\n', 'Tags': '<computability><logic><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T11:43:59.000', 'CommentCount': '0', 'CreationDate': '2012-05-25T17:39:06.803', 'Id': '2092'}{'Body': "<p>$L=\\{&lt;\\!M,x\\!&gt;\\, \\mid M's \\text{ transition function can only move right and   } M\\text{ halts on } x \\}$. I need to show that $L$ is recursive/decidable.</p>\n\n<p>I thought of checking the encoding of $M$ first and determine whether its transition function moves only right (Can I do that?). If so then try to simulate $M$ on $x$ for $|Q|+1$ steps, if it stops then $&lt;\\!M,x\\!&gt;\\, \\in L$ otherwise it is not.</p>\n\n<p>Is this correct?</p>\n", 'ViewCount': '237', 'Title': 'Show that the halting problem is decidable for one-pass Turing machines', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-18T09:58:30.713', 'LastEditDate': '2012-06-03T15:42:33.780', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2213', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<formal-languages><computability><turing-machines><check-my-proof>', 'CreationDate': '2012-06-03T14:32:39.493', 'Id': '2212'}{'Body': '<p>The document I am reading is here: <a href="http://www.cs.odu.edu/~toida/nerzic/390teched/tm/definitions.html" rel="nofollow">Turing Machines</a></p>\n\n<p>Before getting into the question, here is the notation used on the picture:</p>\n\n<blockquote>\n  <p>Here $\\Delta$ denotes the blank and R, L and S denote move the head right, left\n  and do not move it, respectively. A transition diagram can also be\n  drawn for a Turing machine. The states are represented by vertices and\n  for a transition $\\delta( q, X ) = ( r, Y, D )$ , where D represents R, L \n  or S , an arc from q to r is drawn with\n  label ( X/Y , D ) indicating that the state is changed from q to r,\n  the symbol X currently being read is changed to Y and the tape head is\n  moved as directed by D.</p>\n</blockquote>\n\n<p>According to the document:</p>\n\n<blockquote>\n  <p>A Turing machine T is said to decide a language L if and only if T\n  writes "yes" and halts if a string is in L and T writes "no" and halts\n  if a string is not in L</p>\n</blockquote>\n\n<p>Here is the three examples:</p>\n\n<ul>\n<li>Case 1:</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/lGDWj.jpg" alt="Case 1"></p>\n\n<ul>\n<li>Case 2:</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/SlYEj.jpg" alt="Case 2"></p>\n\n<ul>\n<li>Case 3:</li>\n</ul>\n\n<p><img src="http://i.stack.imgur.com/Eextt.jpg" alt="Case 3"></p>\n\n<p>I just want to verify my understanding. According to the definition, in case 1 and case 2, its turing machines cannot decide because the machines cannot tell whether invalid inputs rather than { a } (such as aa, aaa, aaaa....) is in L or not. </p>\n\n<p>In case 2, if another a appears after the first a, or if the input is empty, the machine goes to state S and loop forever. </p>\n\n<p>In case 3, if <code>a</code> is detected and only a single <code>a</code> exists, that <code>a</code> is replaced by <code>1</code> and the machine accepts. Otherwise, a <code>0</code> is replaced and the input is decided not in the language.</p>\n\n<p>Am I correct on all of these? However, in case 3, what if I give any input which contains other character rather than <code>a</code> (such as string <code>ab</code>, <code>bc</code>...)? Or is it said that TM decides only languages over a set of alphabet $\\Sigma$ allowed by the Turing Machine?</p>\n\n<p>If a string which is longer than a single <code>a</code> (like <code>aa</code>, <code>aaa</code>,<code>ab</code>,<code>bc</code>...), the machine may loop forever (like in case 2) or halt without accepting (in other words, it is "crashed", where it does not have transition rules for a symbol in the input such as <code>b</code> in the case of above Turing Machines). Is this correct also?</p>\n', 'ViewCount': '307', 'Title': 'Turing machine and language decidability', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-04T23:29:48.913', 'LastEditDate': '2012-06-04T23:29:48.913', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '2219', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-06-04T05:51:42.557', 'Id': '2218'}{'Body': "<p>I get the proof of going from an enumerator to a Turing Machine (keep running enumerator and see if it matches input) but I don't see how the other way works.</p>\n\n<p>According to my notes and the book (Intro to the Theory of Computation - Sipser), to get Turing enumerator from a Turing machine, we basically write all combinations of the alphabet. You then run the TM on this input, if it accepts print it out, replace with new string repeat ad infinitum.</p>\n\n<p>The problem I am having is surely this requires the language to be decidable. Otherwise it might get stuck on the third word in some infinite loop doomed never to accept or reject and certainly never print out the whole language. </p>\n\n<p>What am I missing?</p>\n", 'ViewCount': '117', 'Title': 'Turing Recognisable => enumerable', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-06T11:16:44.820', 'LastEditDate': '2012-06-06T11:16:44.820', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2239', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1759', 'Tags': '<computability><turing-machines><intuition>', 'CreationDate': '2012-06-05T19:38:42.417', 'Id': '2238'}{'Body': '<p>There are devices that do not allow users to load any application they want on it, only run a limited class of applications approved by the device vendor.</p>\n\n<p>Take an iPhone as an example where new applications are loaded (solely) from app-store and programs that would allow execution of arbitrary code by user (without permission of Apple) are not permitted (e.g. Flash).</p>\n\n<p>Are such machines where users cannot execute arbitrary code on themselves still Turing-complete computers? Can they still be considered as <em>universal Turing machines</em>?</p>\n', 'ViewCount': '247', 'Title': 'Is a device with restrictive execution policies Turing-complete?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-06-08T08:29:20.493', 'LastEditDate': '2012-06-07T21:42:34.033', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1770', 'Tags': '<computability><turing-completeness>', 'CreationDate': '2012-06-06T20:06:25.773', 'FavoriteCount': '1', 'Id': '2243'}{'Body': "<p>Let $C$ be a non-trivial set of recursively enumerable languages ($\\emptyset \\subsetneq C \\subsetneq \\mathrm{RE}$) and let $L$ be the set of encodings of Turing machines that recognize some language in $C$: $$L=\\{\\langle M \\rangle \\mid L(M) \\in C \\}$$</p>\n\n<p>Suppose that $\\langle M_{loopy}\\rangle \\in L$, where $M_{loopy}$ is a TM that never halts.\nI wonder if  it is possible that $L \\in \\mathrm{RE}$?</p>\n\n<p>By Rice's theorem I know that $L \\notin \\mathrm{R}$ (the set of recursive languages), so either $L \\notin \\mathrm{RE}$ or $\\overline{L} \\notin \\mathrm{RE}$. Does it have to be the first option since $M_{loopy} \\in L$?</p>\n", 'ViewCount': '167', 'Title': 'Can the encodings set of a non-trivial class of languages which contains the empty set be recursively enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-10T20:19:25.683', 'LastEditDate': '2012-06-09T08:34:45.397', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '2298', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1589', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-06-08T21:46:15.523', 'Id': '2293'}{'ViewCount': '214', 'Title': 'Recursive, Recursively Enumerable and None of the Above', 'LastEditDate': '2013-01-17T04:12:54.550', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1577', 'FavoriteCount': '1', 'Body': '<p>Let </p>\n\n<ul>\n<li>$A = \\mathrm{R}$ be the set of all languages that are recursive,</li>\n<li>$B = \\mathrm{RE} \\setminus \\mathrm{R}$ be the set of all languages that are recursively enumerable but not recursive and</li>\n<li>$C = \\overline{\\mathrm{RE}}$ be the set of all languages that are not recursively enumerable.</li>\n</ul>\n\n<p>It is clear that for example $\\mathrm{CFL} \\subseteq A$.</p>\n\n<p>What is a simple example of a member of set B?</p>\n\n<p>What is a simple example of a member of set C?</p>\n\n<p>In general, how do you classify a language as either A, B or C?</p>\n', 'Tags': '<formal-languages><computability>', 'LastEditorUserId': '-1', 'LastActivityDate': '2013-01-17T04:12:54.550', 'CommentCount': '2', 'AcceptedAnswerId': '2307', 'CreationDate': '2012-06-09T22:56:54.363', 'Id': '2304'}{'Body': u'<p>Turing machines have a <a href="https://en.wikipedia.org/wiki/Turing_machine#Formal_definition">formal</a> symbol alphabet, state and transition-rules based description of how a computation is done.   </p>\n\n<p><a href="https://en.wikipedia.org/wiki/Actor_model">The Actor Model</a> is sometimes mentioned as a more powerful computational-model than Turing machines (not in what it can compute, but in other aspects).  </p>\n\n<ol>\n<li>Is The Actor Model a full fledged Turning machine alternative as a computational model?  </li>\n<li>Does The Actor Model also have such a symbol-based formal computation description akin to the Turing machine?</li>\n<li>Are the actors assumed to be Turing machine equivalent - since each message is processed sequentially (and atomically)?</li>\n</ol>\n\n<p>There are many theoretical results based on Turing machines, e.g. the halting problem, decidability, relation to G\xf6del\'s incompleteness theorem etc.  </p>\n\n<p>Can these proofs be formally generalize to the Actor Model? Has this been done?</p>\n', 'ViewCount': '233', 'Title': 'Turing Machine-Like Formalism for The Actor Model', 'LastEditorUserId': '41', 'LastActivityDate': '2013-07-20T09:20:54.697', 'LastEditDate': '2013-07-20T09:20:54.697', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1813', 'Tags': '<terminology><computability><reference-request><programming-languages><computation-models>', 'CreationDate': '2012-06-10T05:42:02.043', 'Id': '2311'}{'Body': u'<p>Here is the document: <a href="http://spark-public.s3.amazonaws.com/automata/slides/19_tm4.pdf" rel="nofollow">More Undecidable Problems</a></p>\n\n<p>For a given property $P$ of languages, define $L_P$ as the set of all Turing machines (resp. their encodings) that accept languages with $P$, that is</p>\n\n<p>$\\qquad \\displaystyle L_{p} = \\{ \u27e8M\u27e9 \\mid \\mathcal{L}(M) \\text{ has property } P \\}$</p>\n\n<p>If $P$ is a trivial property, that is if $P$ holds for all or no language, $L_P$ is decidable, too (as $L_P=\\emptyset$ or $L_P = \\{\\langle M\\rangle \\mid M \\text{ Turing machine }\\}$. If $P$ is not trivial, $L_p$ is undecidable (by Rice\'s theorem), which means the strings in this language (or with such property) cannot be determined if it can be halt.</p>\n\n<p>We determine a language $M$ has property $P$ by reduce $M$ to another $M\'$, and check that if $M\'$ accepts the reduced string $x$ from the initial string $w$, we can conclude that $L(M)$ and $L(M\')$ have property $P$.</p>\n\n<p>However, as the title suggests, we only reduce a single string $w$ to $x$ and if $x$ is accepted, but we conclude the whole $L(M\')$ has property $P$. Thus, $M\'$ is obviously part of $L_p$. <em>What if some random strings in $L(M\')$ do not have property $P$?</em></p>\n\n<p><em>What if M accepts some string, but the reduction of those strings are not accepted by M\'?</em></p>\n\n<p>A reduction from language $L$ to language $L\u2019$ is an algorithm (TM that always halts) that takes a string $w$ and converts it to a string $x$, with the property that: <strong>$x$ is in $L\u2019$ if and only if $w$ is in $L$</strong>. </p>\n\n<p><em>Does this imply the reduced language $L\'$ will contain every property $P$ from $L$?</em> Since we can conclude that if $L\'$ is decidable, then $L$ is decidable as well and vice verse. <em>Can we conclude the same thing to property $P$?</em></p>\n', 'ViewCount': '231', 'Title': "How can a TM M' have a property P if it only accepts a single string x from language of P?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-11T13:43:44.273', 'LastEditDate': '2012-06-11T13:16:13.410', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-06-10T14:54:25.343', 'Id': '2319'}{'Body': '<p>Is it theoretically possible to specify a programming language for which no implementation could exist? A programming language is a way of defining functions. An implementation means a method to execute a given program in that language on a given input to the output of the function corresponding to the program on that input.</p>\n\n<p>What is are the minimal requirements of such a language?</p>\n', 'ViewCount': '250', 'Title': 'Can you specify a programming language without implementation?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-03T23:24:03.857', 'LastEditDate': '2012-06-14T16:16:48.313', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '5', 'OwnerDisplayName': 'meisam', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><programming-languages>', 'CreationDate': '2011-07-18T15:21:14.573', 'FavoriteCount': '2', 'Id': '2348'}{'Body': '<p>It is proven that neural networks with rational weights has the computational power of the Universal Turing Machine <a href="http://www.math.rutgers.edu/~sontag/FTP_DIR/aml-turing.pdf" rel="nofollow">Turing computability with Neural Nets</a>. From what I get, it seems that using real-valued weights yields even more computational power, though I\'m not certain of this one.</p>\n\n<p>However, is there any correlation between the computational power of a neural net and its activation function? For example, if the activation function compares the input against a limit of a Specker sequence (something you can\'t do with a regular Turing machine, right?), does this make the neural net computationally "stronger"? Could someone point me to a reference in this direction?</p>\n', 'ViewCount': '204', 'Title': 'Is computational power of Neural networks related to the activation function', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-14T21:29:14.587', 'LastEditDate': '2012-06-14T21:29:14.587', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1789', 'Tags': '<computability><neural-networks>', 'CreationDate': '2012-06-12T23:23:51.467', 'FavoriteCount': '1', 'Id': '2353'}{'ViewCount': '138', 'Title': 'Semi-decidable problems with linear bound', 'LastEditDate': '2012-06-21T20:32:07.537', 'AnswerCount': '2', 'Score': '5', 'OwnerDisplayName': 'Joachim Breitner', 'PostTypeId': '1', 'OwnerUserId': '1913', 'Body': u'<p>Take a semi-decidable problem and an algorithm that finds the positive answer in finite time. The run-time of the algorithm, restricted to inputs with a positive answer, cannot be bounded by a computable function. (Otherwise we\u2019d know how long to wait for a positive answer. If the algorithm runs longer than that we know that the answer is no and the problem would be solvable.)</p>\n\n<p>My question is now: Can such an algorithm still have a, say, a run-time bound linear (polynomial, constant,...) in the input size, but with an uncomputable constant? Or would that still allow me to decide the problem? Are there example?</p>\n', 'Tags': '<computability><time-complexity><undecidability>', 'LastEditorUserId': '1728', 'LastActivityDate': '2012-06-21T20:32:07.537', 'CommentCount': '2', 'AcceptedAnswerId': '2426', 'CreationDate': '2012-06-20T07:52:13.637', 'Id': '2425'}{'ViewCount': '209', 'Title': "A concrete example about string w and string x used in the proof of Rice's Theorem", 'LastEditDate': '2012-06-23T18:39:25.723', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1134', 'FavoriteCount': '1', 'Body': '<p>So, in lectures about Rice\'s Theorem, reduction is usually used to proved the theorem. Reduction usually consists a construction of $M\'$, using a TM $M$ which is in the form $\\langle M,w \\rangle$  to be simulated first, an input $x$ to be simulated if $M$ accepts. $M\'$ accepts if x is accepted. </p>\n\n<p>I really want a concrete input about $\\langle M,w \\rangle$  and $x$. For example:</p>\n\n<blockquote>\n  <p>$L = \\{ \\langle M\\rangle  \\mid L(M) = \\{\\text{ stackoverflow }\\}\\}$, that is L contains all Turing machines whose languages contain one string: "stackoverflow". $L$ is undecidable.</p>\n</blockquote>\n\n<p>What kind of $\\langle M,w \\rangle$ to be simulated? </p>\n\n<p>Suppose we have input x = "stackoverflow" or x = "this is stackoverflow" or any x with "stackoverflow" in it.</p>\n\n<p>What if we first simulate a TM $M$ selected from in the possibilities of all TMs, and this TM accepts only a single character $a$ as its language. So, we simulate this $\\langle M,w \\rangle$  with $w = a$, and surely it will be accepted. And then input $x$ is also accepted according to the definition of $L$. </p>\n\n<p>So, we conclude that $\\langle M,w \\rangle$  in which language is a single $a$ is reducible to $L$ that accepts all TMs which have "stackoverflow"?</p>\n\n<p><strong>Edit:</strong> I\'ve just looked up a brief definition of reduction. A reduction is a transformation from an unknown but easier problem to a harder problem but already known. If the harder problem is solvable, so is the easier one. Otherwise, it\'s not. </p>\n\n<p>Given that definition, I think the correct TM $M$ with its description $\\langle M,w \\rangle$  in my example should be a TM such that it accepts regular languages. This is the harder problem. If this is solvable, then my trivial $L$ with one string is solvable. But apparently, it\'s not according to the proof. We can effectively say we reduced from language one string problem to regular language problem and try to solve it. Previously, I thought the other way around: $\\langle M,w \\rangle$  is reduced to one string problem. </p>\n\n<p>Is my thinking correct? </p>\n', 'Tags': '<computability>', 'LastEditorUserId': '1134', 'LastActivityDate': '2012-06-23T18:39:25.723', 'CommentCount': '1', 'AcceptedAnswerId': '2435', 'CreationDate': '2012-06-21T03:53:05.287', 'Id': '2433'}{'Body': '<p>I am reading "Efficient Cryptographic Schemes Provably as Secure as Subset Sum" by R. Impagliazzo and M. Naor (<a href="http://www.stevens.edu/algebraic/Files/SubsetSum/impagliazzo96efficient.pdf" rel="nofollow">paper</a>) and came across the following statement in the proof of Theorem 3.1 (pages 10-11):</p>\n\n<blockquote>\n  <p>Let $\\  l(n) = (1-c)n \\ $ for $ \\ c &gt; 0  \\ $ ...</p>\n  \n  <p>Given $a_1, a_2, \\cdots, a_n \\in \\{0,1\\}^{l(n)}$ and a target sum $T$, we construct an input to the collision finding algorithm as follows:</p>\n  \n  <ol>\n  <li><p>Let the collision finding algorithm select a (non-empty) $ s_1 \\in \\{0,1\\}^n $</p></li>\n  <li><p>compute $T\' = \\sum_{i \\in s_1} a_i$.  Choose a random $j$ such that $j \\in s_1$ and define $a_j\' = a_j - T\' + T$.</p></li>\n  <li><p>Give the instance $a_1, a_2, \\cdots , a_j\', \\cdots, a_n$ and $s_1$ to the algorithm that finds collisions.  The algorithm attempts to find $s_2$ such that $f_{(a_1, a_2, \\cdots, a_j\', \\cdots, a_n)}(s_2) = T\'$.</p></li>\n  </ol>\n  \n  <p>If the algorithm returns $s_2$ that collides with $s_1$ and $j \\notin s_2$, then <strong>$s_2$ is a solution to our original problem</strong>, since swapping $a_j$ and $a_j\'$ does not affect the sum over $s_2$.</p>\n</blockquote>\n\n<p>Where the emphasis is mine.</p>\n\n<p>Where $f$ concatenates $\\stackrel{\\rightarrow}{a}$ with the sum of the $a_i$\'s:</p>\n\n<p>$$ f( \\stackrel{\\rightarrow}{ a } , S) = f_{(a_1, a_2, \\cdots, a_n)}(S) = \\ \\stackrel{\\rightarrow}{a}, \\sum_{i \\in S} a_i \\mod 2^{l(n)} $$</p>\n\n<p>(taken from the top of page 3 from the same paper).</p>\n\n<p>For the life of me, I don\'t understand how $s_2$ is a solution to the original instance.  Can someone elaborate on what they mean?  What am I missing?</p>\n\n<p>The above definition for the subset sum problem is, if I\'m not mistaken, just another form of the <a href="http://garden.irmacs.sfu.ca/?q=op/theoretical_computer_science/subset_sums_equality" rel="nofollow">pigeonhole subset sum problem</a> (i.e. $\\sum_j a_j &lt; 2^n -1$ ).  If I read the above right, they are claiming that, given an oracle that finds collisions, they can then construct a solution to the original (pigeonhole) subset sum problem but I do not see how this is done.  Any help would be appreciated.</p>\n', 'ViewCount': '138', 'Title': 'Does a collision oracle for the pigeonhole subset sum problem produce solutions?', 'LastEditorUserId': '67', 'LastActivityDate': '2013-12-04T13:14:36.753', 'LastEditDate': '2012-06-21T22:17:31.350', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '67', 'Tags': '<complexity-theory><computability><np-complete><reductions>', 'CreationDate': '2012-06-21T20:44:25.477', 'Id': '2442'}{'ViewCount': '300', 'Title': 'Why is Turing completeness right?', 'LastEditDate': '2012-06-23T15:17:09.140', 'AnswerCount': '2', 'Score': '9', 'OwnerDisplayName': 'MathematicalOrchid', 'PostTypeId': '1', 'OwnerUserId': '1951', 'FavoriteCount': '1', 'Body': '<p>I am using a digital computer to write this message. Such a machine has a property which, if you think about it, is actually quite remarkable: It is <em>one machine</em> which, if programmed appropriately, can perform <em>any possible computation</em>.</p>\n\n<p>Of course, calculating machines of one kind or another go back to antiquity. People have built machines which for performing addition and subtraction (e.g., an abacus), multiplication and division (e.g., the slide rule), and more domain-specific machines such as calculators for the positions of the planets.</p>\n\n<p>The striking thing about a computer is that it can perform <em>any</em> computation. Any computation at all. And all without having to rewire the machine. Today everybody takes this idea for granted, but if you stop and think about it, it\'s kind of amazing that such a device is possible.</p>\n\n<p>I have two actual <em>questions</em>:</p>\n\n<ol>\n<li><p>When did mankind figure out that such a machine was possible? Has there ever been any serious <em>doubt</em> about whether it can be done? When was this settled? (In particular, was it settled before or after the first actual implementation?)</p></li>\n<li><p>How did mathematicians <em>prove</em> that a Turing-complete machine really can compute everything?</p></li>\n</ol>\n\n<p>That second one is fiddly. Every formalism seems to have some things that <em>cannot</em> be computed. Currently "computable function" is <em>defined as</em> "anything a Turing-machine can compute". But how do we know there isn\'t some slightly more powerful machine that can compute more stuff? How do we know that Turing-machines are the correct abstraction?</p>\n', 'Tags': '<computability><turing-machines><history>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-23T22:50:06.447', 'CommentCount': '7', 'AcceptedAnswerId': '2465', 'CreationDate': '2012-06-23T13:58:23.750', 'Id': '2462'}{'ViewCount': '183', 'Title': 'What are the minimum requirements for a language to be considered Turing Complete?', 'LastEditDate': '2012-06-25T01:54:29.010', 'AnswerCount': '3', 'Score': '3', 'OwnerDisplayName': 'Dabloons', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/991/are-there-minimum-criteria-for-a-programming-language-being-turing-complete">Are there minimum criteria for a programming language being Turing complete?</a>  </p>\n</blockquote>\n\n\n\n<p>I overheard a conversation on the topic and the conclusion that one gent came to was that in order to be Turing complete, given one has infinite storage, all one needs is a conditional control structure and a jump instruction. </p>\n\n<p>Is this true? </p>\n\n<p>If it is true, and Turing completeness requires that the language that is Turing complete be able to simulate every instruction available in another Turing complete language, how do those two simple elements achieve that?</p>\n', 'ClosedDate': '2012-06-25T03:19:29.510', 'Tags': '<computability><programming-languages><turing-completeness>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-25T01:54:29.010', 'CommentCount': '6', 'CreationDate': '2012-06-21T13:40:11.397', 'Id': '2476'}{'Body': "<p>There are obvious analogs (pardon the pun) between Boolean algebra and algebra. They have similar laws, operators and properties. I can't figure out why Karnaugh Maps and sum of products, which are used to derive a Boolean function from a truth table, doesn't have an equivalent in algebra.  Perhaps it does, but I haven't seen it. </p>\n\n<p>My only explanation is that if it were possible, you could theoretically find a function for any arbitrary series of numbers (0, 2, 4, 6, 8 f(n)=2n). Thus, you could solve a ton of very difficult problems. I'm not necessarily looking for a formal proof but an explanation. </p>\n\n<p>Right now, I am having fleeting ideas that it has something to do with infinite outputs and inputs, something to do with place values, or true or false equivalents in algebra. There's something here that's difficult to put my finger on.</p>\n", 'ViewCount': '435', 'Title': 'Can truth tables be used in non-boolean algebra to derive functions?', 'LastEditorUserId': '2029', 'LastActivityDate': '2012-09-16T01:05:18.613', 'LastEditDate': '2012-07-01T21:12:14.550', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2029', 'Tags': '<algorithms><computability><logic>', 'CreationDate': '2012-06-30T22:00:28.147', 'FavoriteCount': '2', 'Id': '2566'}{'ViewCount': '147', 'Title': 'Time complexity version of the Church-Turing Thesis', 'LastEditDate': '2012-07-16T23:22:05.273', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1590', 'FavoriteCount': '1', 'Body': '<p>There\'s a <a href="http://plato.stanford.edu/entries/church-turing/#Bloopers" rel="nofollow">lot of debate</a> about what exactly the Church-Turing thesis is, but roughly it\'s the argument that "undecidable" should be considered equivalent to "undecidable by a universal turing machine."</p>\n\n<p>I\'m wondering if there\'s an analogous statement for time complexity, i.e. an argument that if some language is decided in $\\Theta\\left(f(n)\\right)$ on a universal turing machine, then we should say its time complexity is $\\Theta\\left(f(n)\\right)$. </p>\n\n<p>This isn\'t equivalent to the CT thesis - e.g. quantum computers decide precisely those languages which are decidable in a non-quantum TM, but they may run that decision procedure more quickly.</p>\n', 'Tags': '<computability><terminology><turing-machines><church-turing-thesis>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:22:05.273', 'CommentCount': '3', 'AcceptedAnswerId': '2766', 'CreationDate': '2012-07-02T16:28:33.263', 'Id': '2587'}{'Body': '<p>In <em>Algorithmic Randomness and Complexity</em> from Downey and Hirschfeldt, it is stated on page 129 that </p>\n\n<p>$\\qquad \\displaystyle \\sum_{K(\\sigma)\\downarrow} 2^{-K(\\sigma)} \\leq 1$, </p>\n\n<p>where $K(\\sigma)\\downarrow$ means that $K$ halts on $\\sigma$, $\\sigma$ being a binary string. $K$ denotes the prefix-free Kolmogorov complexity.</p>\n\n<p>When does $K$ halt? I think it only halts on a finite number of inputs, since the classical proof on non-computability of the Kolmogorov complexity gives an upper bound on the domain of $K$. But then, the finite set of inputs on which $K$ halts can be chosen arbitrary (one just needs to store the finite number of complexities in the source code).</p>\n\n<p>So is this sum well-defined? In other words, is the domain of $K$ well defined?</p>\n', 'ViewCount': '145', 'Title': 'When does the function mapping a string to its prefix-free Kolmogorov complexity halt?', 'LastEditorUserId': '2069', 'LastActivityDate': '2012-07-08T09:51:02.807', 'LastEditDate': '2012-07-05T09:06:51.267', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '2625', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2069', 'Tags': '<computability><terminology><kolmogorov-complexity><descriptive-complexity>', 'CreationDate': '2012-07-04T15:34:08.397', 'Id': '2614'}{'Body': "<p>Given Graphs $G=(V_1,E_1)$ and $H=(V_2,E_2)$. Can a graph isomorphic to $H$ be obtained from $G$ by a sequence of edge contractions ? We know this problem is NP-complete. What about if only a subset of edges are valid for contraction at each step of the sequence. For example when deciding the first edge for contraction, there are only a subset $E'\\subset E_1$ of edges eligible for contraction. If you pick $e\\in E'$ for contraction and get an intermediate graph then when deciding the second edge for contraction in this intermediate graph there are a subset $E''$ of edges eligible for contraction and so on. </p>\n\n<p>Does this problem stay NP-complete ? </p>\n", 'ViewCount': '267', 'Title': 'NP-completeness of graph isomorphism through edge contractions with an edge validity condition', 'LastEditorUserId': '39', 'LastActivityDate': '2012-07-09T09:35:13.907', 'LastEditDate': '2012-07-09T09:35:13.907', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2090', 'Tags': '<complexity-theory><computability><graphs><np-complete><np-hard>', 'CreationDate': '2012-07-06T02:40:35.660', 'Id': '2634'}{'ViewCount': '512', 'Title': 'Does there exist a Turing complete typed lambda calculus?', 'LastEditDate': '2012-07-09T08:50:19.440', 'AnswerCount': '1', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '2096', 'FavoriteCount': '2', 'Body': '<p>Do there exist any Turing complete typed lambda calculi? If so, what are a few examples?</p>\n', 'Tags': '<computability><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-09T08:50:19.440', 'CommentCount': '0', 'AcceptedAnswerId': '2639', 'CreationDate': '2012-07-06T23:16:05.897', 'Id': '2638'}{'Body': "<p>I want to specify, what it means to give an algebra as input to an algorithm and didn't find very much literature about it. So first I want to ask if you can recommend a book or paper that deals with the topic of complexity analysis of algebras over fields <em>and clearly define the decision problem</em>.</p>\n\n<p>After some digging I found <em>something</em> and want to share it here and furthermore ask if the definitions make sense and are in compliance with literature (if there is any):</p>\n\n<blockquote>\n  <p><strong>Definition:</strong> Let $\\mathbb F$ be a field and $A$ be a finitely generated commutative $\\mathbb F$-algebra with additive basis $b_1,\\ldots, b_n\\in\\mathbb F$. We now want to capture the multiplicative structure of the algebra and therefore write every product of base elements as a linear combination of all base elements:\n  $$\n\\forall 1\\leq i, j, k\\leq n: \\exists a_{ijk}: b_ib_j=\\sum_{k=1}^n a_{ijk}b_k.\n$$\n  The $a_{ijk}$ are called <strong>structure coefficients</strong>. We directly have that:\n  $$ A \\cong \\left.\\mathbb{F}[b_1, \\ldots, b_n] \\middle/ \\left&lt;b_i b_j-\\sum_{k=1}^n a_{ijk}b_k\\right&gt;_{1\\leq i,j\\leq n}\\right..$$\n  Now one can define the following decision problem:\n  $$\n\\{(A,B)\\mid A, B \\text{ commutative $\\mathbb F$-algebras with basis $b_1, \\ldots b_n$ and } A\\cong B\\}.\n$$\n  To specify an isomorphism $\\phi:A\\rightarrow B$ it is sufficient to write every $\\phi(b_i)$ as linear combination of the elements of a basis of $B$.</p>\n</blockquote>\n\n<p>Does anything in this definition seem strange to you or do you think that one can work with it? </p>\n\n<blockquote>\n  <p><strong>Motivation:</strong> My motivation behind this is to give a very clear definition of the decision problem first to connect it to other problems, i.e. the problem of deciding polynomial equivalence: Given two polynomials $f,g\\in\\mathbb F[x_1, \\ldots, x_n]$, we say that $f$ is <strong>equivalent</strong> to $g$ if there exists an invertible linear transformation $\\tau$ on the variables such that $f(\\tau(x_1), \\ldots, \\tau(x_n))=g(x_1, \\ldots, x_n)$. In other words, two polynomials are equivalent if you can replace every variable by a linear combination of all variables to obtain the other polynomial. </p>\n</blockquote>\n\n<p>I'm not sure if this helps as a motivation but the connection of this problems is established by constructing finitely generated commutative $\\mathbb F$-algebras from the two polynomials that are isomorphic if and only if the polynomials are equivalent. For this I wanted to make sure that the decision problem is defined very clearly. </p>\n", 'ViewCount': '112', 'Title': 'An $\\mathbb F$-algebra as input to an algorithm', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T06:09:52.990', 'LastEditDate': '2012-07-17T05:59:47.400', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2103', 'Tags': '<computability><terminology><decision-problem>', 'CreationDate': '2012-07-07T20:18:54.500', 'FavoriteCount': '1', 'Id': '2642'}{'Body': "<p>Let $\\Sigma$ be a given alphabet. Is there a way to code up Deterministic Finite state Automata (DFA) over $\\Sigma$ as strings of $\\Sigma$ in such a way that the corresponding subset of $\\Sigma^*$ is a regular language?</p>\n\n<p>For example for Turing machines, the set of codes of Turing machines over a fixed alphabet is decidable, and we can speak of decidable sets of Turing machines (through their codes).</p>\n\n<p>Of course we can also speak of regular sets of DFA's (through their codes). Is the set of all DFA's regular in this sense?</p>\n", 'ViewCount': '143', 'Title': 'Is the set of codes of Deterministic Finite-State Automata a regular language?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-06-13T13:23:28.980', 'LastEditDate': '2012-07-17T05:57:31.880', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '5', 'OwnerDisplayName': 'user1491069', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-07-09T16:26:02.807', 'Id': '2682'}{'ViewCount': '755', 'Title': 'What is the difference between quantum TM and nondetermistic TM?', 'LastEditDate': '2012-08-21T07:36:36.807', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '1', 'Body': '<p>I was going through the discussion on the question <a href="http://cs.stackexchange.com/questions/125/how-to-define-quantum-turing-machines/">How to define quantum-turing-machines?</a> and I feel that quantum TM and <em>nondetermistic</em> TM are one and the same. The answers to the other question do not touch on that. Are these two models one and the same?</p>\n\n<p>If no,</p>\n\n<ol>\n<li>What are the differences between quantum TM and NDTM? </li>\n<li>Is there any computation which a NDTM would do quicker than Quantum TM? </li>\n<li>If this is the case then quantum TM is a DTM, then why is there so much fuzz about this technology, we already have so many DTM. Why to design a new DTM in the end?</li>\n</ol>\n', 'Tags': '<computability><turing-machines><quantum-computing><nondeterminism>', 'LastEditorUserId': '2137', 'LastActivityDate': '2012-08-21T07:36:36.807', 'CommentCount': '1', 'AcceptedAnswerId': '2721', 'CreationDate': '2012-07-13T05:56:28.627', 'Id': '2718'}{'ViewCount': '529', 'Title': 'Does a never-halting machine always loop?', 'LastEditDate': '2012-07-18T10:09:48.590', 'AnswerCount': '4', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2157', 'FavoriteCount': '2', 'Body': "<p>A Turing machine that returns to a previously encountered state with its read/write head on the same cell of the exact same tape will be caught in a loop. Such a machine doesn't halt.</p>\n\n<p>Can someone give an example of a never-halting machine that doesn't loop?</p>\n", 'Tags': '<computability><turing-machines><halting-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T10:09:48.590', 'CommentCount': '4', 'AcceptedAnswerId': '2730', 'CreationDate': '2012-07-13T15:18:18.840', 'Id': '2728'}{'Body': '<p>What\'s the definition of Kolmogorov complexity for a decision problem? For example, how to define the length of the shortest program that solves the 3SAT problem? Is it the "smallest" Turing machine that recognizes the 3SAT langauge?</p>\n', 'ViewCount': '76', 'Title': 'Kolmogorov complexity of a decision problem', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T01:33:05.280', 'LastEditDate': '2012-07-18T01:33:05.280', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '2779', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1986', 'Tags': '<computability><terminology><decision-problem><kolmogorov-complexity><3-sat>', 'CreationDate': '2012-07-16T18:48:03.180', 'Id': '2770'}{'Body': '<p>I cannot understand decidability really well. I have been reading from books and internet, but I am little bit confused. \nAccording to the book (as I understood), we can decide on decidability of a problem by constructing Turing Machines. Let us say that we want to decide whether an NFA is a decidable language. First, we need to construct a Turing Machine that accepts if the run on w in NFA ends in accept state, otherwise Turing Machine rejects. \nAccording to this definition, I can construct any Turing Machine that can decide every NFA. As a result, I can say that every NFA that can be constructed is decidable. Is this true ?</p>\n\n<p>Additionally, I realized that we cannot decide whether two Context Free Grammars produce same languages. However, we can decide whether two NFA produce same language. Therefore, can we conclude that as our machines get complicated, some of the problems get harder to decide ? </p>\n\n<p>I mean lets take an example. Let us say that there is an NFA that accepts some string w whose length is a composite number. I think that this is a decidable problem.</p>\n\n<p>As you can see that I am little bit confused with these concepts. It will be a lot better for me to go over an example, because it is difficult for me to understand only from conceptual explanations.</p>\n', 'ViewCount': '90', 'Title': 'Decidability of Machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:04:31.740', 'LastEditDate': '2012-07-17T22:04:31.740', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'OwnerDisplayName': 'Marigi Maskere', 'PostTypeId': '1', 'Tags': '<computability><automata><finite-automata><turing-machines>', 'CreationDate': '2009-12-06T15:47:36.283', 'Id': '2797'}{'ViewCount': '1439', 'Title': "Perplexed by Rice's theorem", 'LastEditDate': '2012-11-26T12:04:48.433', 'AnswerCount': '2', 'Score': '21', 'PostTypeId': '1', 'OwnerUserId': '1951', 'FavoriteCount': '5', 'Body': '<p><strong>Summary:</strong> According to Rice\'s theorem, everything is impossible. And yet, I <em>do</em> this supposedly impossible stuff <em>all the time!</em></p>\n\n<hr>\n\n<p>Of course, Rice\'s theorem doesn\'t simply say "everything is impossible". It says something rather more specific: "Every property of a computer program is non-computable."</p>\n\n<p>(If you want to split hairs, every "non-trivial" property. That is, properties which <em>all</em> programs posses or <em>no</em> programs posses are trivially computable. But any other property is non-computable.)</p>\n\n<p>That\'s what the theorem says, or appears to say. And presumably a great number of very smart people have carefully verified the correctness of this theorem. But it seems to completely defy logic! There are <em>numerous</em> properties of programs which are <em>trivial</em> to compute!! For example:</p>\n\n<ul>\n<li><p>How many steps does a program execute before halting? To decide whether this number is finite or infinite is precisely the Halting Problem, which is non-computable. To decide whether this number is greater or less than some finite $n$ is <em>trivial!</em> Just run the program for up to $n$ steps and see if it halts or not. Easy!</p></li>\n<li><p>Similarly, does the program use more or less than $n$ units of memory in its first $m$ execution steps? Trivially computable.</p></li>\n<li><p>Does the program text mention a variable named $k$? A trivial textual analysis will reveal the answer.</p></li>\n<li><p>Does the program invoke command $\\sigma$? Again, scan the program text looking for that command name.</p></li>\n</ul>\n\n<p>I can see plenty of properties that <em>do</em> look non-computable as well; e.g., how many additions does a complete run of the program perform? Well, that\'s nearly the same as asking how many <em>steps</em> the program performs, which is virtually the Halting Problem. But it looks like there are boat-loads of program properties which a really, really <em>easy</em> to compute. And yet, Rice\'s theorem insists that none of them are computable.</p>\n\n<p>What am I missing here?</p>\n', 'Tags': '<computability><terminology><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-26T18:26:22.353', 'CommentCount': '1', 'AcceptedAnswerId': '6928', 'CreationDate': '2012-07-18T09:23:10.527', 'Id': '2811'}{'ViewCount': '2459', 'Title': 'Is a push-down automaton with two stacks equivalent to a turing machine?', 'LastEditDate': '2012-08-13T10:22:59.483', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'Lazer', 'PostTypeId': '1', 'OwnerUserId': '1558', 'FavoriteCount': '2', 'Body': '<p>In <a href="http://stackoverflow.com/a/559969/113124">this answer</a> it is mentioned</p>\n\n<blockquote>\n  <p>A regular language can be recognized by a finite automaton. A context-free language requires a stack, and <strong>a context sensitive language requires two stacks (which is equivalent to saying it requires a full Turing machine)</strong>.</p>\n</blockquote>\n\n<p>I wanted to know regarding the truth of the bold part above. Is it in fact true or not? What is a good way to reach at an answer to this?</p>\n', 'Tags': '<computability><automata><turing-machines>', 'LastEditorUserId': '917', 'LastActivityDate': '2012-08-13T10:22:59.483', 'CommentCount': '5', 'AcceptedAnswerId': '2833', 'CreationDate': '2012-07-19T10:50:44.883', 'Id': '2832'}{'Body': '<p>In <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf" rel="nofollow">Knuth\'s original paper on $LR(k)$ grammars</a>, he proved that the decision problem "Given a CFG $G$, is there a $k$ such that $G$ is an $LR(k)$ grammar?" is undecidable.</p>\n\n<p>Is there a similar result showing that it is undecidable whether a given CFG is an $LL(k)$ grammar for some choice of $k$?  Or is this problem known to be decidable?</p>\n', 'ViewCount': '175', 'Title': 'Determining whether a CFG is $LL(k)$ for any $k$?', 'LastEditorUserId': '2131', 'LastActivityDate': '2012-12-10T22:55:35.893', 'LastEditDate': '2012-12-10T22:55:35.893', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4928', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><computability><formal-grammars><context-free><parsing>', 'CreationDate': '2012-07-23T23:15:59.023', 'Id': '2889'}{'ViewCount': '371', 'Title': 'Do non-computable functions grow asymptotically larger?', 'LastEditDate': '2012-07-29T18:23:35.940', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2157', 'FavoriteCount': '1', 'Body': "<p>I read about busy beaver numbers and how they grow asymptotically larger than any computable function. Why is this so? Is it because of the busy beaver function's non-computability? If so, then do all non-computable functions grow asymptotically larger than computable ones?</p>\n\n<p><strong>Edit:</strong></p>\n\n<p>Great answers below but I would like to explain in plainer english what I understand of them.</p>\n\n<p>If there was a computable function f that grew faster than the busy beaver function, then this means that the busy beaver function is bounded by f. In other words, a turing machine would simply need to run for f(n) many steps to decide the halting problem. Since we know the halting problem is undecidable, our initial presupposition is wrong. Therefore, the busy beaver function grows faster than all computable functions.</p>\n", 'Tags': '<computability><asymptotics>', 'LastEditorUserId': '2157', 'LastActivityDate': '2012-07-29T18:23:35.940', 'CommentCount': '2', 'AcceptedAnswerId': '2940', 'CreationDate': '2012-07-28T13:58:25.233', 'Id': '2939'}{'Body': "<p>Let $\\mathrm{MIN}_{\\mathrm{DFA}}$ collection of all the codings of DFAs such that they are minimal regarding their states number. I mean if $\\langle A \\rangle \\in \\mathrm{MIN}_{\\mathrm{DFA}}$ then for every other DFA $B$ with less states than $A$, $L(A)\\ne L(B)$ holds. I'm trying to figure out how come that $\\mathrm{MIN}_{\\mathrm{DFA}} \\in R$? How come it is decidable?</p>\n\n<p>What is about this kind of DFAs that is easy to decide?</p>\n", 'ViewCount': '131', 'Title': 'Is the set of minimal DFA decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-05T14:43:53.250', 'LastEditDate': '2012-08-05T14:43:53.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3046', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2329', 'Tags': '<formal-languages><computability><automata><finite-automata>', 'CreationDate': '2012-08-05T13:05:39.717', 'Id': '3044'}{'Body': '<p>I wonder how come that the following language is in $\\mathrm R$.</p>\n\n<p>$L_{M_1}=\\Bigl\\{\\langle M_2\\rangle \\;\\Big|\\;\\; M_2 \\text{ is a TM, and } L(M_1)=L(M_2), \\text{ and } |\\langle M_1\\rangle| &gt; | \\langle M_2 \\rangle| \\Bigr\\} $</p>\n\n<p>(I know that it\'s in $\\mathrm R$ since there\'s an answer for this multi-choice question, but without explanation).</p>\n\n<p>I immediately thought that the $L_{M_1} \\notin \\textrm{co-RE} \\cup \\textrm{RE}$  since we know that checking if two machines accept the same language is really not decidable, I came to think: is it immediate "False", but it can\'t be since there\'s a lot of Turing machines who accepts the same answer and have different codings.</p>\n\n<p>Thanks! </p>\n', 'ViewCount': '127', 'Title': 'For a Turing Machine $M_1$, how is the set of machines $M_2$ which are "shorter" than $M_1$ and which accept the same language decidable?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-13T05:44:48.050', 'LastEditDate': '2012-08-13T05:44:48.050', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3091', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-08-08T12:01:12.723', 'Id': '3090'}{'Body': '<p>How can I prove that a set is complete for $\\Pi_2$ complete? Can you give me an example proof? Say for $All_{TM}$ = Turing machines whose accepted language is all strings?</p>\n', 'ViewCount': '106', 'Title': 'How to show a set is $\\Pi_2$ complete', 'LastEditorUserId': '2131', 'LastActivityDate': '2012-08-09T18:25:55.410', 'LastEditDate': '2012-08-09T02:38:40.510', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2423', 'Tags': '<computability>', 'CreationDate': '2012-08-08T23:08:49.097', 'Id': '3098'}{'Body': '<p><em>F</em>&nbsp;=&nbsp;{&nbsp;&lang;<em>M</em>&rang;&nbsp;: <em>M</em> is a turing machine which stops on every input in no more than 50 steps&nbsp;}. </p>\n\n<p>I need to decide whether <em>F</em> is decidable or recursive enumerable.</p>\n\n<p>This "50 steps" part immediate turns the <strong>R</strong> sign for me, I know that if it was for specific input it was decidable for sure, but here it\'s for every input, so I need to check it for all inputs in some way. checking it for infinite inputs makes me think that the problem is <strong>co-RE</strong>, <em>i.e.</em>&nbsp;its complement is acceptable, but still I\'m not sure.</p>\n\n<p>I have a feeling it\'s decidable, but I don\'t know to prove it, Any help?</p>\n\n<p>Or maybe I can check the configurations and see that all configurations after 50 steps don\'t lead to accept state- how do I do that?</p>\n', 'ViewCount': '930', 'Title': 'Is the set of Turing machines which stop in at most 50 steps on all inputs, decideable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-09T21:03:55.937', 'LastEditDate': '2012-08-09T21:03:55.937', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '3105', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<computability><undecidability>', 'CreationDate': '2012-08-09T10:27:53.680', 'Id': '3101'}{'Body': "<p>I'd like your help with proving that the language\n$$L=\\{\\langle M \\rangle \\mathrel| L(M) \\in \\mathrm{NP}\\smallsetminus \\mathrm{P} \\}$$\nis decidable iff $\\mathrm{P}=\\mathrm{NP}$.</p>\n\n<p>If $\\mathrm{P}=\\mathrm{NP}$, I get that it's the language of empty Turing machines. So $L$ is a $\\text{co-RE}$ problem &mdash; but that's not what's being asked, so I got confused.</p>\n\n<p>I know that in order to show $\\mathrm{P}=\\mathrm{NP}$, I need to show problem which it's $\\mathrm{NPC}$ and $\\mathrm{P}$ as well.</p>\n\n<p>Any help? \nThanks!</p>\n", 'ViewCount': '126', 'Title': 'How to show that the set of machines which accept languages in $\\mathrm{NP}\\smallsetminus\\mathrm P$, is decidable only if $\\mathrm P=\\mathrm{NP}$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-09T21:03:07.123', 'LastEditDate': '2012-08-09T21:03:07.123', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<computability><undecidability><p-vs-np>', 'CreationDate': '2012-08-09T11:56:04.413', 'Id': '3103'}{'ViewCount': '572', 'Title': 'Is it decidable whether a TM reaches some position on the tape?', 'LastEditDate': '2012-08-11T12:12:07.167', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1183', 'FavoriteCount': '1', 'Body': "<p>I have these questions from an old exam I'm trying to solve. For each problem, the input is an encoding of some Turing machine $M$.</p>\n\n<blockquote>\n  <p>For an integer $c&gt;1$, and the following three problems:</p>\n  \n  <ol>\n  <li><p>Is it true that for every input $x$, M does not pass the $|x|+c$ position when running on $x$?</p></li>\n  <li><p>Is it true that for every input $x$, M does not pass the $\\max \\{|x|-c,1 \\}$ position when running on $x$?</p></li>\n  <li><p>Is it true that for every input $x$, M does not pass the $(|x|+1)/c$ position when running on $x$?</p></li>\n  </ol>\n  \n  <p>How many problems are decidable? </p>\n</blockquote>\n\n<p>Problem number (1), in my opinion,  is in $\\text {coRE} \\smallsetminus \\text R$ if I understand correct since, I can run all inputs in parallel, and stop if some input reached this position and for showing that it's not in $\\text R$ I can reduce the complement of <strong>Atm</strong> to it. I construct a Turing machine $M'$ as follows: for an input $y$ I check if $y$ is a history of computation, if it is, then $M'$ running right and doesn't stop, if it's not, then it stops.</p>\n\n<p>For (3), I believe that it is decidable since for $c \\geqslant 2$ it is all the Turing machines that always stay on the first cell of the stripe, since for a string of one char it can pass the first cell, so I need to simulate all the strings of length 1 for $|Q|+1$ steps (Is this correct?), and see if I'm using only the first cell in all of them.</p>\n\n<p>I don't really know what to do with (2).</p>\n", 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '1183', 'LastActivityDate': '2012-08-12T03:39:42.523', 'CommentCount': '2', 'AcceptedAnswerId': '3127', 'CreationDate': '2012-08-10T19:10:45.963', 'Id': '3119'}{'ViewCount': '389', 'Title': 'How to show two models of computation are equivalent?', 'LastEditDate': '2012-08-13T22:04:59.613', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'FavoriteCount': '1', 'Body': "<p>I'm seeking explanation on how one could prove that two models of computation are equivalent. I have been reading books on the subject except that equivalence proofs are omitted. I have a basic idea about what it means for two models of computation to be equivalent (the automata view: if they accept the same languages). Are there other ways of thinking about equivalence? If you could help me understand how to prove that the Turing-machine model is equivalent to lambda calculus, that would be sufficient.</p>\n", 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><machine-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:00.330', 'CommentCount': '5', 'AcceptedAnswerId': '3162', 'CreationDate': '2012-08-13T21:03:50.690', 'Id': '3154'}{'Body': '<p>I need help finding an algorithm which, given a Turing machine description $\\langle M \\rangle$, decides whether there exists an input $w$ such that in the computation of $M(w)$, the head only moves right and $M$ never stops.</p>\n', 'ViewCount': '173', 'Title': 'Decider for the family of Turing machines that move infinitly to the right on some input', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-14T21:42:57.557', 'LastEditDate': '2012-08-14T15:43:25.920', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'user1521539', 'PostTypeId': '1', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-07-12T17:46:55.297', 'FavoriteCount': '1', 'Id': '3180'}{'Body': "<p>We know the halting problem (on Turing Machines) is undecidable for Turing Machines. Is there some research into how well the human mind can deal with this problem, possibly <em>aided</em> by Turing Machines or general purpose computers?</p>\n\n<p><em>Note</em>: Obviously, in the strictest sense, you can always say no, because there are Turing Machines so large they couldn't even be read in the life span of a single human. But this is a nonsensical restriction that doesn't contribute to the actual question. So to make things even, we'd have to assume humans with an arbitrary life span.</p>\n\n<p>So we could ask: Given a Turing Machine T represented in any suitable fashion, an arbitrarily long-lived human H and an arbitrary amount of buffer (i.e. paper + pens), can H decide whether T halts on the empty word?</p>\n\n<hr>\n\n<p><em>Corollary: If the answer is yes, wouldn't this also settle if any computer has a chance of passing the turing-test?</em></p>\n", 'ViewCount': '1255', 'Title': 'Human computing power: Can humans decide the halting problem on Turing Machines?', 'LastActivityDate': '2013-05-18T19:19:20.827', 'AnswerCount': '7', 'CommentCount': '10', 'Score': '21', 'PostTypeId': '1', 'OwnerUserId': '26', 'Tags': '<computability><turing-machines><halting-problem><human-computing>', 'CreationDate': '2012-08-21T10:46:52.483', 'FavoriteCount': '6', 'Id': '3271'}{'Body': '<p>Is the following FOL-problem (equality is a logical symbol) \neffectively decidable?</p>\n\n<p><strong>Given.</strong>  A finite equation system $E$ and an equation $s = t$.</p>\n\n<p><strong>Question.</strong>  Is there a substitution $\\sigma$, such that $\\sigma(E)\n\\models \\sigma(s = t)$?</p>\n\n<p><strong>Some useful information.</strong>  </p>\n\n<ol>\n<li><p>Obviously one can restrict $\\sigma$ to be a ground substitution.</p></li>\n<li><p>This problem is decidable:  Given a finite system $E$ of<br>\nground equations and a ground equation $s = t$, does $E \\models s = t$<br>\nhold? (c.f. [1: Corollary 4.3.6]) </p></li>\n</ol>\n\n<p><strong>References</strong></p>\n\n<p>[1] Franz Baader, Tobias Nipkow: Term Rewriting and All That,\n&copy; 1998 Cambridge University Press.</p>\n', 'ViewCount': '90', 'Title': 'Is the validity of some instance of an equational problem decidable?', 'LastEditorUserId': '2626', 'LastActivityDate': '2012-08-25T10:02:52.893', 'LastEditDate': '2012-08-24T20:50:16.470', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3329', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2626', 'Tags': '<computability><logic><decision-problem><equality>', 'CreationDate': '2012-08-24T11:30:29.003', 'Id': '3312'}{'ViewCount': '354', 'Title': 'Using a step-counting function in a Turing Machine construction', 'CommunityOwnedDate': '2012-09-11T12:58:07.527', 'LastEditDate': '2012-09-12T09:44:18.067', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2775', 'Body': "<p>I have an question relating to the elementary foundations of Turing Machine theory. I would like to have a clarification of the status of a function $\\phi$ (a mapping between TM indexes) I shall introduce in the formal question after the preamble. First to the preamble.</p>\n\n<p>Let us assume that we have a fixed Turing Machine language and corresponding Universal Turing Machine. Thus ${TM_i}$ is an enumeration of machines, with UTM say as the Universal Machine in that enumeration. Let us also introduce a numerical parameter <strong>c</strong> for this example: (for example <strong>c</strong> = 500).</p>\n\n<p>Now execution of any TM can be simulated on UTM.</p>\n\n<p><strong>EDIT (Explaining notation)</strong> I am using some notation in this question which I shall outline here. Let S be an arbitrary input string for TM, then I shall write:</p>\n\n<p>$$UTM(TM_i; S)$$</p>\n\n<p>to indicate that $TM_i$ is using S as its input. So we will have the equation:\n$$UTM(TM_i; S) = TM_i(S)$$\nsince UTM is Universal, and its purpose is simply to simulate TMs on their input. If S is a composition of x,y I shall write:\n$$UTM(TM_i;x,y)$$</p>\n\n<p>(End notation discussion.)</p>\n\n<p>Let us modify UTM to UTM2 (and using the above notation) with the following property when a given $TM_i$ is executed on UTM2:</p>\n\n<p>$UTM_2(TM_i;c,x) = UTM(TM_i;c,x) = TM_i(x)$ if $TM_i$ requires <strong>c</strong> steps or less to compute the output</p>\n\n<p>$UTM_2(TM_i;c,x)=0$ if $TM_i(x)$ requires at least <strong>c</strong> steps for computation</p>\n\n<p><strong>EDIT</strong> The original question with this second condition has been answered. In this edit I would like to modify the condition to the following (introducing UTM3 which also meets the first condition):</p>\n\n<p>$UTM_3 (TM_i; c, x) = [s]$ if $TM_i (x)$ requires at least <strong>c</strong> steps for computation.</p>\n\n<p>In this expression [s] is the string on the tape which results after <strong>c</strong> steps of computation by $TM_i$ on Input. (EDIT The corresponding state of $TM_i$ will not be a Final state (ACCEPT or REJECT), but just an arbitrary state $q_j$. This is because UTM3 stops executing after <strong>c</strong> steps, ignoring the Turing Machine convention requiring termination only in Final states.) As a result (almost) all input strings x, including those with |x| > c will be modified (in a maximum of c string positions) - expressed in Language terms many such strings will just have their ACCEPTANCE calculation prematurely terminated in a non-Final state - but some strings of arbitrary length will still be ACCEPTED by some Turing Machines in less than <strong>c</strong> steps (IE those for which ACCEPTANCE requires examining less than the first <strong>c</strong> terms.)</p>\n\n<p>So under UTM2/3 the output is determined partly by a (hidden) step counting function. Here UTM2/3 has taken on some of the role of an operating system, by monitoring the actual steps taken by the simulated machines, and using some step-counting variable to behave as above.</p>\n\n<p>(EDIT: We show below that UTM2/3 is a Universal Machine)and so capable of <em>executing</em> any TM - on any argument - it is provided with, at least as far as <strong>c</strong> steps. Despite this limitation I believe that an infinite number of (TM,input) pairs will result in a non-zero output. So most TMs executed on UTM2/3 will not behave as they do on UTM. In UTM3 the outputs will explicitly depend on x,i and c.(End preamble.)</p>\n\n<p>The question is whether any given $TM_i$ can be modified into $TM_{\\phi (i,c)}$ with the property that (generalising to arbitrary c):</p>\n\n<p>$UTM_3(TM_i; c, x)$ = $UTM (TM_{\\phi(i,c)}; x)$       (for all $x$ and $c$)</p>\n\n<p><strong>EDIT2\\phi</strong> Both questions for the $\\phi(i,c)$ have been answered. For reasons discussed below I want to modify the definition to $\\phi(i)$. This new definition is:</p>\n\n<p>$UTM_3(TM_i; c, x)$ = $UTM (TM_{\\phi(i)}; c,x)$ = $TM_{\\phi(i)}(c,x)$       (for all $x$ and $c$)</p>\n\n<p>This condition is meant to ensure that $TM_{\\phi (i)}$ is a correct simulation of $TM_i$.\nThe specific questions to be proven about $\\phi: (i) \\rightarrow i$ are: (i) Is $\\phi$ well defined and non-trivial; (ii) Is $\\phi$ recursive; (iii) Is $\\phi$ non-recursive? </p>\n\n<p>In the LHS of the above definitions c is an input, which is ignored by $TM_i$ but used by UTM3 to determine the stopping stage. Asking for $\\phi(x,c)$ made this a <em>fixed</em> parameter built into the definition of $TM_{\\phi(x,c)}$. However the correct UTM simulation will be given <strong>c</strong> as in the modified equation RHS. This parameter needs to be used by $TM_{\\phi(i)}$ along with its own input x, to construct the correct simulation. (EDIT) Of course since the UTM is a regular Universal Machine it simply simulates the execution of $TM_{\\phi(i)}$ - the parameters on <em>its</em> tape - like <strong>c</strong> - are meant for its TM's only.</p>\n\n<p>Note that a special symbol <strong>u</strong> could be introduced switching off the UTM3 counts, and so</p>\n\n<p>$$UTM3(TM_i;u,x) = UTM(TM_i;u,x) = TM_i(x)$$</p>\n\n<p>Also the same problem can be formulated for the original UTM2 (with modified $\\phi$).</p>\n\n<p>This question is a simplification of a problem I am trying to understand (I am a math but not a CS major, but have some textbooks like Hopcroft/Ullmann), and I hope that I can get some clarification on this piece.</p>\n", 'Tags': '<complexity-theory><computability><turing-machines>', 'LastEditorUserId': '2775', 'LastActivityDate': '2012-09-12T09:44:18.067', 'CommentCount': '6', 'AcceptedAnswerId': '3488', 'CreationDate': '2012-09-10T11:53:12.470', 'Id': '3487'}{'ViewCount': '212', 'Title': 'Approximating the Kolmogorov complexity', 'LastEditDate': '2013-12-10T11:06:26.913', 'AnswerCount': '2', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '702', 'FavoriteCount': '3', 'Body': '<p>I\'ve studied something about the <a href="http://en.wikipedia.org/wiki/Kolmogorov_complexity" rel="nofollow">Kolmogorov Complexity</a>, read some articles and books from <a href="http://homepages.cwi.nl/~paulv/kolmogorov.html" rel="nofollow">Vitanyi and Li</a> and used the concept of <a href="http://complearn.org/ncd.html" rel="nofollow">Normalized Compression Distance</a> to verify the stilometry of authors (identify how each author writes some text and group documents by their similarity).</p>\n\n<p>In that case, data compressors were used to approximate the Kolmogorov complexity, since the data compressor could be used as a Turing Machine.</p>\n\n<p>Besides data compression and programming languages (in which you would write some kind of compressor), what else could be used to approximate the Kolmogorov complexity? Are there any other approaches that could be used?</p>\n', 'Tags': '<computability><approximation><data-compression><kolmogorov-complexity>', 'LastEditorUserId': '702', 'LastActivityDate': '2013-12-10T21:28:05.640', 'CommentCount': '4', 'AcceptedAnswerId': '3531', 'CreationDate': '2012-09-11T00:02:12.553', 'Id': '3501'}{'Body': "<p>I have a question and I haven't been able to figure out the answer yet. I need to do the on-line simulation of a two-head tape Turing machine using single-head tape(s). I've found some online articles for the fact that one single-head tape doesn't suffice for this problem and the simulation should be done using two single-head tapes, but I haven't been able to present an accurate simulation of two-head TM using these single-head tapes. Are there any thoughts on how to do so? Thanks,</p>\n", 'ViewCount': '198', 'Title': 'On-line simulation of a two-head tape Turing machine using single-head tape(s)', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T00:40:34.167', 'LastEditDate': '2012-09-13T06:43:33.710', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'Parsa Rastegari', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models><simulation>', 'CreationDate': '2012-09-13T00:29:00.457', 'Id': '3526'}{'Body': "<p>It's easy to see how a multi-track Turing machine can simulate a single-track Turing machine; it does so by ignoring all but the first track. But how does it work the other way? I need a specification of a transition function that does the job. If there are $k$ tracks, then we can think of symbols as being vectors and arrange them one after another in the tape; but again, what's the transition function like in the equivalent single-track machine?</p>\n", 'ViewCount': '399', 'Title': 'How does a single-track Turing machine simulate a multi-track Turing machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-14T23:20:23.407', 'LastEditDate': '2012-09-13T12:38:47.133', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '3552', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<computability><turing-machines><simulation>', 'CreationDate': '2012-09-13T11:25:55.437', 'Id': '3529'}{'Body': '<p>Is a Turing Machine that is allowed to read and write symbols from an infinite alphabet more powerful than a regular TM (that is the only difference, the machine still has a finite number of states)?</p>\n\n<p>Intuition tells me not, since you need an infinite number of states to differentiate each symbol. So I think some of the symbols or the transitions caused by the symbols (or some subsets of the transitions) have to be equivalent. So you can actually simulate such machine with a regular TM and a bounded subset of such symbols or transitions.</p>\n\n<p>How could I approach a formal proof of this?</p>\n', 'ViewCount': '414', 'Title': 'Infinite alphabet Turing Machine', 'LastActivityDate': '2012-09-28T13:35:38.480', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '3534', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1451', 'Tags': '<computability><turing-machines><reductions><simulation>', 'CreationDate': '2012-09-13T23:01:24.267', 'Id': '3533'}{'ViewCount': '165', 'Title': 'Is a single symbol, not in a set, a language?', 'LastEditDate': '2013-05-24T08:02:35.497', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Pampero', 'PostTypeId': '1', 'OwnerUserId': '2830', 'Body': "<p>I was reading about Turing machines and realized I'm not sure about the difference between the following scenario. Given the alphabet $\\Sigma = \\{a, b \\}$, we have the following assertions:</p>\n\n<ol>\n<li>$a \\in R $</li>\n<li>$\\{a\\} \\in R$</li>\n</ol>\n\n<p>I think that assertion $1$ is incorrect because $a$ is just a symbol, not a language. On the other hand $\\{a\\}$ is the language which contains only the $a$ symbol. Given that information, we can prove that $\\{a\\} \\in R$ by trivially building a TM. Here, $R$ denotes the set of recursive languages.</p>\n\n<p>Is my reasoning wrong? Thanks in advance.</p>\n", 'Tags': '<formal-languages><terminology><computability>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-24T14:39:13.220', 'CommentCount': '5', 'AcceptedAnswerId': '3538', 'CreationDate': '2012-09-14T14:41:42.840', 'Id': '3537'}{'ViewCount': '470', 'Title': 'What is the difference between decidability and computability?', 'LastEditDate': '2012-09-15T13:10:11.437', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2835', 'FavoriteCount': '1', 'Body': '<p>If they are different, what are the typical problems in each that do not fall on the other category? Or are the mutually exclusive or does one completely capture the other?</p>\n', 'Tags': '<computability><terminology>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-16T06:23:49.840', 'CommentCount': '7', 'AcceptedAnswerId': '4573', 'CreationDate': '2012-09-15T02:03:45.667', 'Id': '3555'}{'ViewCount': '168', 'Title': 'Kolmogorov complexity of string concatenation', 'LastEditDate': '2012-09-16T06:11:49.433', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>If $K(s)$ is the <a href="http://en.wikipedia.org/wiki/Kolmogorov_complexity" rel="nofollow">Kolmogorov complexity</a> of the string $s \\in \\{0,1\\}^*$,</p>\n\n<blockquote>\nCan we prove (or disprove) the following statement:\n<br><br>\n"Every string $s$ is a prefix of an incompressible string; i.e. for every string $s$ there exists a string $r$ such that $K(sr) \\geq |sr|$" ?\n</blockquote>\n\n<p>In a very informal (and perhaps not too meaningful) way: we know that $K(r) \\leq |r| + O(1)$; if we pick a large enough incompressible string $r$, can we "use" the $O(1)$ to "mask" the compressibility of the given string $s$ ?</p>\n\n<p>A similar (but different) result is that for any $c$, we can find $s$ and $r$ such that: $K(sr) &gt; K(s) + K(r) + c$</p>\n', 'Tags': '<computability><kolmogorov-complexity>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-16T18:30:20.183', 'CommentCount': '2', 'AcceptedAnswerId': '4576', 'CreationDate': '2012-09-15T22:20:59.723', 'Id': '4570'}{'Body': '<p>I\'d like to understand what approaches should one adopt when deciding/proving that a given function <em>F</em> is uncomputable, by any Turing Machine (TM). The ones I\'ve tried so far are as follows:</p>\n\n<ul>\n<li>Reduction, from a known uncomputable function (such as $UC(\\alpha)$, the uncomputable function as proved by Cantor\'s diagonalization argument in Chapter 1 of the book "Computational Complexity" by Sanjeev Arora and Boaz Barak, or $HALT(\\alpha, x)$, which is nothing but the function in the <a href="http://en.wikipedia.org/wiki/Halting_problem" rel="nofollow">Halting problem</a>), to <em>F</em>. If such a reduction is possible, it can be argued that <em>F</em> is uncomputable as otherwise, the problems that are proved to be uncomputable would become be computable as well.</li>\n<li>Proof by contradiction, in which one shows that if there is a TM <em>M</em> that computes <em>F</em>, it would lead to some sort of inconsistency in either the <em>M</em>\'s output, or the functions evaluated value.</li>\n</ul>\n\n<p>I\'ve applied (or rather, tried to apply) both the above techniques to some reductions, two of which I now state here (for illustrating the limitations of my approach):</p>\n\n<blockquote>\n  <ol>\n  <li><p>If whenever a TM <em>M</em> accepts a string <em>w</em> $\\in$ ${\\{0,1\\}}^*$, it also accepts $w^R$, the TM <em>M</em> is said to possess property <em>R</em>. ($w^R$ is the string obtained by reversing $w$ i.e. $(110)^R$ is $011$). Let $R: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: $R(\\alpha) = 1$ if $M_\\alpha$ possesses property $R$, and $R(\\alpha) = 0$ otherwise. Prove that $R$ is uncomputable.</p></li>\n  <li><p>Let $B: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$ be defined as follows: \n  $B(\\alpha,x) = 1$ if $M_\\alpha$ writes a non-blank symbol on its output tape while computing input $x$, $B(\\alpha,x) = 0$ otherwise. Prove that function $B$ is uncomputable.</p></li>\n  </ol>\n</blockquote>\n\n<p>For problem 1, I tried reducing the uncomputable function $UC$ to $R$, but the reason I couldn\'t quite complete the reduction is because $R$ is a property of the Turing Machine, not dependent on any input instance, where $UC$ depends on the output of a specific instance $M_\\alpha(\\alpha)$. Also, for both $R(\\alpha)$ = 0 and $R(\\alpha)$ = 1, it is possible that $M_\\alpha$ can go on indefinitely for some inputs! </p>\n\n<p>For problem 2, I tried reducing the function $HALT$ to $B$ (thus attempting to make a TM that computes $HALT(\\alpha,x)$ by using the output of a TM $M_\\beta$ that computes $B$). But here as in problem 1, <em>it is possible</em> that for both outputs of $M_\\beta(\\alpha,x)$, the TM $M_\\alpha$ may not halt at all on input $x$! </p>\n\n<p>So, I\'m stumped here - I understand intuitively why these functions should be uncomputable (No TM should be able to predict whether another TM would halt/output anything on any possible input), I\'m not quite able to derive a concrete proof! So, I really want to understand what approaches am I missing here, or are there holes in the current approaches that I\'ve tried so far!</p>\n\n<p>Note: For self-containment, I\'m stating what are the functions UC and HALT here as well:</p>\n\n<p>$UC: {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$UC(\\alpha) = 0$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ = 1</p>\n\n<p>$UC(\\alpha) = 1$, otherwise.</p>\n\n<p>$HALT: {\\{0,1\\}}^*$ x $ {\\{0,1\\}}^* \\rightarrow \\{0,1\\}$:</p>\n\n<p>$HALT(\\alpha, x) = 1$, when the Turing Machine represented by $\\alpha$, $M_\\alpha(\\alpha)$ halts on input $x$.</p>\n\n<p>$HALT(\\alpha, x) = 0$, otherwise.</p>\n', 'ViewCount': '338', 'Title': 'What approaches are most useful when proving uncomputability of a given function?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-20T12:16:37.440', 'LastEditDate': '2012-09-16T21:19:35.027', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '476', 'Tags': '<computability><turing-machines><proof-techniques><undecidability>', 'CreationDate': '2012-09-16T20:40:29.383', 'FavoriteCount': '1', 'Id': '4577'}{'Body': '<p>I just had this interesting question. What is the fastest growing function known to man? Is it <a href="http://en.wikipedia.org/wiki/Busy_beaver">busy beaver</a>?</p>\n\n<p>We know functions such as $x^2$, but this function grows slower than $2^x$, which in turn grows slower than $x!$, which in turn grows slower than $x^x$. We can then combine functions, to have $(x^x)!$ that grows faster than $x^x$, and so on.</p>\n\n<p>Then we arrive at recursive functions such as Ackermann\'s function $A(x,x)$ that grows much faster than $(x^x)!$. Then people though about busy beaver $B(x)$ function that grows even faster than Ackermann\'s function.</p>\n\n<p>At this point I haven\'t heard of any other functions that grow faster than busy beaver. Does it mean that there are no other functions that can possibly grow quicker than busy beaver? (Aside from factorial of $B(x)$ and like $A(B(x), B(x))$, etc.)</p>\n', 'ViewCount': '2593', 'Title': 'Is busy beaver the fastest growing function known to man?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-11-18T12:02:35.520', 'LastEditDate': '2012-09-22T22:14:17.657', 'AnswerCount': '4', 'CommentCount': '16', 'Score': '13', 'OwnerDisplayName': 'bodacydo', 'PostTypeId': '1', 'Tags': '<computability>', 'CreationDate': '2012-09-22T21:58:45.487', 'FavoriteCount': '6', 'Id': '4678'}{'Body': "<p>In a lecture a professor mentioned that modern computers don't have as much computational power as a Turing machine because they don't have infinite memory, and since no computer can have infinite memory the Turing machine is therefore unattainable and simply represents the upper limit of computing. Is there a measure, or definition of what problems (or class of problems) lie beyond the reach of our computing power because of this?</p>\n", 'ViewCount': '184', 'Title': 'Turing complete and computational power', 'LastActivityDate': '2012-09-26T22:19:35.047', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '4737', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2964', 'Tags': '<computability>', 'CreationDate': '2012-09-26T02:37:36.487', 'FavoriteCount': '3', 'Id': '4734'}{'ViewCount': '717', 'Title': 'How is the rule 110 Turing complete?', 'LastEditDate': '2012-09-30T00:59:44.817', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Pureferret', 'PostTypeId': '1', 'OwnerUserId': '2952', 'FavoriteCount': '3', 'Body': '<p>I\'ve read the wikipedia page for <a href="http://en.wikipedia.org/wiki/Rule_110" rel="nofollow">rule 110</a> in cellular automata, and I more or less know how they work (a set of rules decides where to draw the next 1 or 0).</p>\n\n<p>I\'ve just read they\'re Turing complete, but I can\'t even fathom how would you  \'program\' in \'rule 110\'? </p>\n', 'Tags': '<computability><automata><turing-completeness><cellular-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-09-30T00:59:44.817', 'CommentCount': '11', 'CreationDate': '2012-09-21T23:44:56.810', 'Id': '4779'}{'Body': '<blockquote>\n  <p>"Alan Turing proved in 1936 that a general algorithm to solve the\n  halting problem for <em>all</em> possible program-input pairs cannot exist"</p>\n</blockquote>\n\n<p>Can I find a general algorithm to solve the halting problem for <em>some</em> possible program input pairs? </p>\n\n<p>Can I find a programming language (or languages), where I for every kind of program in this language, it can decide if the program terminates or run forever?</p>\n', 'ViewCount': '654', 'Title': u'Algorithm to solve Turing\'s "Halting problem\u200d\u200b"', 'LastEditorUserId': '41', 'LastActivityDate': '2013-04-05T11:21:40.253', 'LastEditDate': '2012-10-03T19:12:15.243', 'AnswerCount': '6', 'CommentCount': '3', 'Score': '11', 'OwnerDisplayName': 'user11775', 'PostTypeId': '1', 'Tags': '<computability><formal-methods><halting-problem><software-verification>', 'CreationDate': '2011-12-08T17:52:03.623', 'FavoriteCount': '3', 'Id': '4856'}{'Body': '<p>What problem does the halting problem solve in computing, whether theoretical or practical?</p>\n\n<p>It is very easy to debug code which loops forever, just signal the debugger to break if the program is running for too long? What purpose / good is the halting problem? Why was Turing praised for it?</p>\n', 'ViewCount': '316', 'Title': 'What helpful solution does the Halting Problem give to computing?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-04T10:03:22.663', 'LastEditDate': '2012-10-04T10:03:22.663', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '4869', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3051', 'Tags': '<computability><terminology><halting-problem>', 'CreationDate': '2012-10-03T21:42:54.827', 'Id': '4867'}{'Body': "<p>The definitions I've found were highly technical and using terms I've never seen before. </p>\n\n<p>Say, I have a certain irrational number <em>e</em> that I get get closer and closer to with a computer and I want to determine if there is a particular digit <em>d</em> appearing after a certain position. Or what about the halting problem (give a program and ask 'will the computer ever halt?')? Are these problems semi-computable problems or noncomputable?</p>\n", 'ViewCount': '114', 'Title': "What's an intuitive distinction between semi-computable problems and noncomputable problems/functions?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-11T07:25:53.277', 'LastEditDate': '2012-10-11T07:25:53.277', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '5007', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2835', 'Tags': '<computability><terminology>', 'CreationDate': '2012-10-11T02:57:07.000', 'Id': '5006'}{'Body': '<p>I have come across the following interesting problem: let $p,q$ be polynomials over the field of real numbers, and let us suppose that their coefficients are all integer (that is, there is a finite exact representation of these polynomials). If needed, we may suppose that the degree of both polynomials is equal. Let us denote by $x_p$ (resp. $x_q$) the greatest absolute value of some (real or complex) root of the polynomial $p$ (resp. $q$). Is the property $x_p = x_q$ decidable?</p>\n\n<p>If not, does this property hold for some restricted families of polynomials? In the context from which this problem arises, the polynomials are characteristic polynomials of matrices, and their roots are eigenvalues.  </p>\n\n<p>I am aware of some numerical algorithms for computing roots of polynomials / eigenvalues, however these seem to be of no use here, since the output of these algorithms is only approximate. It seems to me that computer algebra might be useful here, however, unfortunately, I do not have almost any knowledge in that field.</p>\n\n<p>I am not searching for a detailed solution to this problem, however any intuition and ideas where to search for the solution would be helpful. </p>\n\n<p>Thank you in advance.</p>\n', 'ViewCount': '109', 'Title': 'Decidability of a problem concerning polynomials', 'LastActivityDate': '2012-10-16T19:19:49.487', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6091', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2091', 'Tags': '<computability><undecidability><computer-algebra>', 'CreationDate': '2012-10-15T07:37:19.173', 'Id': '6088'}{'Body': '<p>As the title suggests. Also, such a language must satisfy that neither it nor its complement are semi-decidable. I already know that $All_{TM}, EQ_{TM}, T$ (that is the set of all deciders) satisfy this property. But I tried reducing these to their complements directly, and via some sort of intermediate language, but to no avail. Can anyone help?</p>\n', 'ViewCount': '503', 'Title': 'Find an undecidable language that is mapping-reducible to its complement', 'LastActivityDate': '2012-11-17T21:30:14.087', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1718', 'Tags': '<computability><reductions>', 'CreationDate': '2012-10-16T04:13:05.393', 'Id': '6100'}{'Body': u'<p>Suppose I have a formula, and a lying witness is attempting to make it evaluate to False.</p>\n\n<blockquote>\n  <p>Given a <a href="http://en.wikipedia.org/wiki/Truth_table" rel="nofollow">truth table</a> $c(F_1,\u2026, F_n)$, how could you force a lying\n   witness to contradict herself?</p>\n</blockquote>\n\n<p>A contradiction is simply when the witness\'s statements are logically impossible; i.e. that $x_1,x_2$ are each True, but $x_1 \\space AND\\space x_2$ is False.</p>\n\n<ul>\n<li>How can I characterize the set of all formula for which I force the witness to contradict herself?</li>\n<li>What complexity class does this problem fall in?</li>\n</ul>\n', 'ViewCount': '252', 'Title': 'Given a truth table, force a contradiction', 'LastEditorUserId': '4304', 'LastActivityDate': '2012-12-26T07:32:37.003', 'LastEditDate': '2012-11-26T07:05:41.493', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4222', 'Tags': '<complexity-theory><computability><np-complete><closure-properties><decision-problem>', 'CreationDate': '2012-10-16T23:32:35.117', 'FavoriteCount': '1', 'Id': '6116'}{'ViewCount': '190', 'Title': 'How to show that f(x) is primitive recursive?', 'LastEditDate': '2012-10-17T13:30:56.957', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': "<blockquote>\n  <p>Let </p>\n  \n  <p>$$f(x)=\\begin{cases} x \\quad \\text{if Goldbach's conjecture is true\n }\\\\ 0 \\quad \\text{otherwise}\\end{cases}$$</p>\n  \n  <p>Show that f(x) is primitive recursive.</p>\n</blockquote>\n\n<p>I know a primitive recursive function is obtained by composition or recursion, but I don't know what should I do about this problem. </p>\n", 'Tags': '<computability><recursion>', 'LastEditorUserId': '51', 'LastActivityDate': '2012-10-17T13:37:37.383', 'CommentCount': '1', 'AcceptedAnswerId': '6123', 'CreationDate': '2012-10-17T13:15:23.120', 'Id': '6122'}{'ViewCount': '338', 'Title': 'If a Language is Non-Recognizable then what about its complement?', 'LastEditDate': '2012-10-19T08:28:33.073', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '1', 'Body': '<p>Is the complement of a Non-Recognizable language</p>\n\n<ol>\n<li>Recognizable</li>\n<li>Non-Recognizable</li>\n<li>May be Recognizable, May be Non-recognizable. I.e cant comment.</li>\n</ol>\n\n<p>A mathematical proof would be of great help since im unable to think of any way to prove this.</p>\n\n<p>I did some research on this and found below examples. Im specifying complement using a "!"</p>\n\n<ol>\n<li>!A(TM) is a non-recognizable language while A(TM) is a recognizable language.</li>\n<li>EQ(TM) is a non-recognizable language and !EQ(TM) is also non-recognizable language</li>\n</ol>\n\n<p>The above two would mean that we simply cant comment on the Recognizability of the complement of non-recognizable language. But I feel that there should be some way to prove (or disprove) this.</p>\n', 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '2137', 'LastActivityDate': '2012-10-19T09:45:19.683', 'CommentCount': '0', 'AcceptedAnswerId': '6168', 'CreationDate': '2012-10-19T08:04:00.140', 'Id': '6167'}{'Body': '<p>$H(x)$ is the program size complexity of $x$ for some universal Turing machine $U$. $H$ is not computable, however $H$ is "<em>computable in the limit from above</em>".</p>\n\n<p>From my notes:</p>\n\n<blockquote>\n  <p>i.e the set $\\{(x,n) \\mid x \\in B^*,n \\geq 0, H(x) \\leq n\\}$ is computably enumerable.</p>\n</blockquote>\n\n<p>Can someone tell me what this means? I understand the incomputability of $H$ but the term "limit from above" is confusing me.</p>\n', 'ViewCount': '71', 'Title': "What does 'computable in the limit from above' mean?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T13:51:49.480', 'LastEditDate': '2012-10-22T13:51:49.480', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6215', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4296', 'Tags': '<computability><terminology>', 'CreationDate': '2012-10-21T02:38:57.497', 'Id': '6206'}{'Body': '<p>Doing the following exercise:</p>\n\n<blockquote>\n  <p>Let $\\overline{HALT(x,y)}$ be defined as </p>\n  \n  <p>$\\overline {HALT(x,y)} \\iff \\text{program number y never halts on input x}$</p>\n  \n  <p>Show that it is not computable.</p>\n</blockquote>\n\n<p>Just want to make sure I have understood the concept correctly. We had in a theorem that HALT(x,y) is not computable which means that we cannot determine whether program number y eventually halts on input x. I realized that $\\overline {HALT(x,y)}$ is the negation of HALT(x,y). Is it true (I cannot find it in my book or on the internet) that if a function is (not) computable, its negation is also (not) computable? A function being computable means there is a program p which computes it, we cannot say there is a program Q that computes its negation. Or can we draw such conclusion? </p>\n', 'ViewCount': '159', 'Title': 'If a predicate is not computable, what can be said about its negation?', 'LastActivityDate': '2012-10-23T23:59:04.863', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '6273', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<computability><proof-techniques>', 'CreationDate': '2012-10-23T11:34:34.550', 'Id': '6262'}{'Body': '<p>If $f(x_1,\\dots, x_n)$ is a total function that for some constant $K$, $f(x_1,\\dots, x_n) \\leq K$ for all $x_1,\\dots, x_n$ then $f$ is computable. </p>\n\n<p>I want some hints on how to prove/disprove the above claim. This an exercise from the book <a href="http://rads.stackoverflow.com/amzn/click/0122063821" rel="nofollow">Computability, Complexity, and Languages</a>. As I didn\'t find the solutions to the exercises online, I want to see a formal solution of such problems, if possible. </p>\n', 'ViewCount': '149', 'Title': 'How to prove or disprove that f is computable?', 'LastEditorUserId': '140', 'LastActivityDate': '2012-10-23T18:10:18.237', 'LastEditDate': '2012-10-23T12:14:33.447', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '6269', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<computability><proof-techniques>', 'CreationDate': '2012-10-23T12:01:35.420', 'Id': '6263'}{'Body': '<p>I was told that quantum computers are not computationally more powerful than Turing machines.\nCould someone kindly help in giving some literature references explaining that fact?</p>\n', 'ViewCount': '217', 'Title': 'References on comparison between quantum computers and Turing machines', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-30T05:24:51.813', 'LastEditDate': '2012-10-25T11:04:54.370', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4349', 'Tags': '<computability><reference-request><turing-machines><quantum-computing>', 'CreationDate': '2012-10-24T20:44:35.533', 'Id': '6296'}{'Body': "<p>I am trying to teach myself computability theory with a textbook. According to my book, a function $f$ over an alphabet $A=\\{a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z\\}$ is only computable iff the language</p>\n\n<p>$$\nL = \\{s\\#^j\\sigma : s\\in A^*, \\sigma \\in A, \\text{ the }j\\text{'th symbol of } f(s)\\text{ is } \\sigma\\}$$</p>\n\n<p>is decidable. Why is that? Couldn't a function $f$ be not computable even if $L$ is decidable?</p>\n", 'ViewCount': '102', 'Title': 'Can $f$ be not computable even if $L$ is decidable?', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-31T21:55:23.710', 'LastEditDate': '2012-10-31T21:55:23.710', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6407', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4414', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2012-10-31T21:31:58.657', 'Id': '6406'}{'Body': '<p>A <a href="http://en.wikipedia.org/wiki/Formal_grammar" rel="nofollow">grammar</a> is <em><a href="http://en.wikipedia.org/wiki/Ambiguous_grammar" rel="nofollow">ambiguous</a></em> if at least one of the words in the\nlanguage it defines can be parsed in more than one way. A simple example of an ambiguous grammar\n$$\n   E \\rightarrow E+E \\ |\\ E*E \\ |\\ 0 \\ |\\ 1 \\ |\\ ...\n$$\nbecause the string 1+2*3 can be parsed as (1+2)*3 and 1+(2*3).  For\ncontext free grammars (CFGs) ambiguity is not decidable [1, 2]. This implies that non-ambiguity is also not decidable. Moreover, at least one of ambiguity and\nnon-ambiguity cannot even be recursively enumerable, for otherwise\nambiguity of a given CFG $G$ could be decided by running the\nenumeration of ambiguity and non-ambiguity together and seeing which\none contains $G$ (and one of them must).</p>\n\n<p>So which problem is harder in this sense? Ambiguity or non-ambiguity?</p>\n\n<ol>\n<li><p>D. G. Cantor, On The Ambiguity Problem of Backus Systems.</p></li>\n<li><p>R. W. Floyd, On ambiguity in phrase structure languages.</p></li>\n</ol>\n', 'ViewCount': '127', 'Title': 'Hardness of ambiguity/non-ambiguity for context-free grammars', 'LastEditorUserId': '2887', 'LastActivityDate': '2012-11-03T16:47:16.880', 'LastEditDate': '2012-11-03T16:47:16.880', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6464', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<computability><formal-grammars><context-free><undecidability><ambiguity>', 'CreationDate': '2012-11-03T14:29:51.043', 'Id': '6463'}{'ViewCount': '101', 'Title': 'Reduction of A_LBA to E_LBA', 'LastEditDate': '2012-11-06T20:48:13.643', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Kevin Stadler', 'PostTypeId': '1', 'OwnerUserId': '4479', 'Body': "<p>I have a rather interesting one to ponder and would love if I could get an answer for it. We were discussing the topic of mapping reduction today in my Computing theory course and I was wondering why this reduction can't exist, $A_{LBA} \\leq_{m} E_{LBA}$, since both of them are linear bound automata (LBAs). I do realize that $E_{LBA}$ is undecidable, $A_{LBA}$ is decidable, and the normal proof uses $A_{TM}$, or $E_{TM}$, to prove the undecidibility of $E_{LBA}$. I am just curious why the proof is using a TM to prove an LBA. But, my Professor could not come up with a solution to my confusion. I was wondering is this possible, if so, why or why not.</p>\n\n<p><strong>Definitions:</strong></p>\n\n<p>$A_{LBA} = \\{\\langle M, w\\rangle \\mid \\text{$M$ is a linear bound automaton that accepts the string $w$}\\}$</p>\n\n<p>$E_{LBA} = \\{\\langle M \\rangle \\mid \\text{$M$ is a linear bound automaton with $L(M)=\\emptyset$}\\}$</p>\n\n<p>$A_{TM}$ and $E_{TM}$ are the equivalent problems for Turing Machines.</p>\n", 'Tags': '<computability><turing-machines><reductions><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T20:48:13.643', 'CommentCount': '0', 'AcceptedAnswerId': '6516', 'CreationDate': '2012-11-06T05:19:27.213', 'Id': '6515'}{'ViewCount': '527', 'Title': 'How can P =? NP enhance integer factorization', 'LastEditDate': '2012-11-13T20:01:21.107', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '4365', 'FavoriteCount': '3', 'Body': '<p>If ${\\sf P}$ does in fact equal ${\\sf NP}$, how would this enhance our algorithms to factor integers faster. In other words, what kind of insight would this fact give us in understanding integer factorization better?</p>\n', 'Tags': '<complexity-theory><computability><np-complete><p-vs-np><factoring>', 'LastEditorUserId': '2755', 'LastActivityDate': '2012-11-18T19:44:37.800', 'CommentCount': '0', 'AcceptedAnswerId': '6652', 'CreationDate': '2012-11-13T19:13:56.870', 'Id': '6650'}{'Body': '<p>So I would like to show that the class of Recursively Enumerable languages are closed under the shrink operation. In other words, $\\text{shrink}_a(L) = \\{\\text{shrink}_a(w)\\mid w\\in L\\}$ and where $\\text{shrink}_a(w)$ is the string formed from $w$ by replacing every maximal substring of two or more $a$\'s by a single a. For example, $\\text{shrink}_a(baaab) = bab$.</p>\n\n<p>So I was browsing around for other examples to study, and I came across the following proof for the <strong>prefix</strong> operation: <a href="http://cs.stackexchange.com/questions/1731/proving-that-recursively-enumerable-languages-are-closed-against-taking-prefixes">Proving that recursively enumerable languages are closed against taking prefixes</a> (the proof given by the user Wu Yin). I thought that this was a very cool way of proving something like this, instead of just directly building an alternate TM. I\'m curious to know, can anyone come up with a proof that is of a similar style and flavor to the one pointed above? I would be very curious to see a similar bijective proof regarding countable/uncountable sets!!</p>\n\n<p>This has reminded me that there can be many ways to prove something, so I wanted to see what kind of flavor other people\'s proofs might have to this sample problem. I find that too often, students (and myself included) get caught up in a single procedure for finding solutions to a particular type of problem and neglect to see other ways of showing the same result.</p>\n', 'ViewCount': '195', 'Title': 'Seeking Alternate Proof Regarding Closure Of Recursively Enumerable Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-28T17:38:40.397', 'LastEditDate': '2012-11-26T11:46:51.627', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '6920', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4734', 'Tags': '<formal-languages><computability><proof-techniques><closure-properties>', 'CreationDate': '2012-11-26T06:27:42.250', 'Id': '6907'}{'Body': '<blockquote>\n  <p>$L_1$ is a recursively enumerable language over some alphabet\n  $\\Sigma$. An algorithm effectively enumerates its words as $w_1, w_2, ...$. <br> $L_2$ is another language over $\\Sigma \\cup \\{\\#\\}$ as\n  $\\{w_i\\#w_j : w_i, w_j \\in L_1, i &lt; j\\}$<br> Consider the following\n  assertions.</p>\n  \n  <ol>\n  <li>$L_1$ is recursive implies $L_2$ is recursive</li>\n  <li>$L_2$ is recursive implies $L_1$ is recursive</li>\n  </ol>\n  \n  <p>Which statements is/are true?</p>\n</blockquote>\n\n<p>I reasoned both the statements to be true.</p>\n\n<p>Statement 1 is true. $L_1$ is recursive means it can lexicographically enumerate its strings. The membership question for $L_2$ can be easily settled using the decider and lexicographic enumerator of $L_1$.</p>\n\n<p>Statement 2 is true. The algorithm which decides $L_2$ can be modified to accept if the input string matches either $w_i$ or $w_j$. This settles the membership question for $L_1$.</p>\n\n<p>The given solution to this question however says that statement 2 is false. Could you let me know if my reasoning has gone wrong someplace?</p>\n', 'ViewCount': '163', 'Title': 'Decidability of languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-27T21:39:04.723', 'LastEditDate': '2012-11-26T14:57:24.467', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '6930', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><computability>', 'CreationDate': '2012-11-26T13:17:04.930', 'Id': '6917'}{'Body': '<p>Consider the following property of recursively enumberable (RE) languages </p>\n\n<p>$$ L = \\{ J \\in \\text{RE} \\mid J \\cap L_{uni} \\ne \\emptyset \\}$$</p>\n\n<p>where $L_{uni}$ is the language of the Universal Turing machine.</p>\n\n<p>I am wondering if $L$ is semi-decidable. That is (by definition) if the set $$ S = \\{ \\langle T \\rangle \\mid L(T) \\in L\\}$$ is recursively enumerable.</p>\n\n<p>If I am not mistaken then this should be true because one can always construct a Turing machine $M$ that accepts a code $\\langle T \\rangle$ and  (using non-determinism) generates the "right" input for $T$ and $T_{uni}$, verifies that both accept the generated word (simulating the machines) and if so accepts the supplied string.</p>\n\n<p>Can someone verify this claim?</p>\n', 'ViewCount': '144', 'Title': 'Question about a semi-decidable property of languages', 'LastEditorUserId': '5180', 'LastActivityDate': '2013-02-03T12:26:24.057', 'LastEditDate': '2013-02-03T09:34:52.777', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4766', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-11-27T19:47:27.383', 'Id': '6964'}{'Body': "<p>Given $n \\in \\mathbb{N}$ and  $p,q \\in \\mathbb{N}[x_1,\\ldots,x_n]$  one can define the following formula in the language of formal arithmetics</p>\n\n<p>$$\\varphi(n,p,q) = \\forall x_1 \\cdots \\forall x_n : \\neg (p(x_1,\\ldots,x_n) = q(x_1,\\ldots,x_n))$$</p>\n\n<p>I would like to show that there are infinitely many triples $(n,p,q)$ such that neither $\\varphi(n,p,q)$ nor $\\neg \\varphi(n,p,q)$ is a theorem of formal arithmetic. </p>\n\n<p>In showing this I can use the fact that the problem of deciding if a polynomial $r \\in \\mathbb{Z}[x_1,\\ldots,x_n]$ has a natural zero is undecidable.</p>\n\n<p>Knowing the above fact we know that there is a polynomial $r \\in \\mathbb{Z}[x_1,\\ldots,x_n]$ such that neither $$\\varphi' = \\forall x_1 \\cdots \\forall x_n : \\neg (r(x) = 0)$$ nor $\\neg \\varphi'$ is a theorem. (Here the quantifiers are over the naturals which I am not sure if I can use deliberately?)</p>\n\n<p>Once we have such $r$ we can write it as $$r(x_1,\\ldots,x_n) = p(x_1,\\ldots,x_r) - q(x_1,\\ldots,x_n)$$ for $p,q \\in \\mathbb{N}[x_1,\\ldots,x_n]$ and hence $\\varphi(n,p,q)$ and $\\neg \\varphi(n,p,q)$ are also not theorems since $\\varphi$ is logically equivalent to $\\varphi'$ and we have shown that this is not a theorem.</p>\n\n<p>Once we have one such triple $(n,p,q)$ we have infinitely many of them since we can just take $(n,p+k,q+k)$ for $k \\in \\mathbb{N}.$</p>\n\n<p>Since I never did such things before I am wondering if the above reasoning is correct?</p>\n", 'ViewCount': '105', 'Title': "Question related to Hilbert's 10th problem", 'LastEditorUserId': '3092', 'LastActivityDate': '2012-12-23T05:46:13.213', 'LastEditDate': '2012-11-28T14:42:50.287', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<computability><logic><undecidability>', 'CreationDate': '2012-11-28T14:33:42.353', 'Id': '6993'}{'Body': '<p>In my studies in computability I have come across the notion of the "machine", an abstract representation of a device that essentially computes. I have read about Turing Machines and Wolfram\'s binary cellular automata and I understand them.ie. the rules, states, colours, etc. and how they work. They begin in some state and run forever(unless a terminating state is specified). The point I\'m trying to make here is that they receive no external input and are essentially functions of themselves:their current state is some function of its starting state, unlike realistic computers.</p>\n\n<p>For the above reasons I\'d like to know why automata are used to represent computers. More generally how can a machine be used to represent a computation?</p>\n', 'ViewCount': '81', 'Title': 'How does an automaton actually "compute"?', 'LastActivityDate': '2012-11-30T13:51:34.223', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '802', 'Tags': '<computability><automata><cellular-automata>', 'CreationDate': '2012-11-30T11:26:36.597', 'Id': '7042'}{'Body': '<p>I have devised the following TM for the language EQUAL. </p>\n\n<p>EQUAL accepts all strings with the same number of a\'s and b\'s. It is context free but non regular. </p>\n\n<p>Using the TM I devised, how can I show that EQUAL is recursive? How can I show that it crashes when the input is not in EQUAL.</p>\n\n<p><img src="http://i.stack.imgur.com/81uEa.png" alt="enter image description here"></p>\n', 'ViewCount': '247', 'LastEditorDisplayName': 'user3115', 'Title': 'Show the Language is Recursive', 'LastActivityDate': '2012-12-02T20:07:52.897', 'LastEditDate': '2012-12-02T19:25:52.953', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7110', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-languages><computability><turing-machines>', 'CreationDate': '2012-12-01T00:44:52.273', 'Id': '7061'}{'Body': '<p>I need a clarification related to the following situation.</p>\n\n<p>Consider a Turing machine $T_1$ that halts for every input. In other words $J_1 = L(T_1) \\subseteq \\Sigma^*$ is recursive. Suppose we are given a function $f:\\Sigma^* \\mapsto \\Sigma^*$ and a language $J_2 \\in \\Sigma^*$ such that $$ x \\in J_2 \\iff f(x) \\in J_1.$$</p>\n\n<p>I would assume this readily implies $J_2$ is recursive as well since one can create a Turing machine $T_2$ that on given input $x$ evaluates $y = f(x)$ and simulates $T_2$ on the given input $y.$ Clearly $L(T_2) = J_2.$</p>\n\n<p>What now confuses me is the following.</p>\n\n<blockquote>\n  <p>Are there any restrictions on $f$ for this \'\'reduction\'\' to work?</p>\n</blockquote>\n\n<p>What is the usual approach here? Is $f$ assumed to be given as a black box that always evaluates $f(x)?$ If so could someone explain the motivation behind this, because it appears to me that it could as well be that $f(x)$ cannot be computed effectively and hence $T_2$ cannot be constructed in a "feasible" way.</p>\n\n<p>As for the motivation for the question, I would like to show that given $f:\\Sigma^* \\mapsto \\Sigma^*$ and a recursive language $L,$ the language $f^{-1}(L)$ is recursive as well.</p>\n', 'ViewCount': '95', 'Title': 'Reducing recursive languages', 'LastActivityDate': '2012-12-02T18:41:47.083', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7107', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-12-02T08:21:03.207', 'Id': '7101'}{'Body': '<p>If we limit a turing machine so that it is not allowed to write the symbol that it reads would it reduce its power?</p>\n\n<p>For example: $( State, A, State, Z, DIRECTION)$</p>\n\n<p>$A$ cannot be the same symbol as $Z$.  </p>\n', 'ViewCount': '188', 'Title': 'Does forcing TMs to change all symbols they read change their power?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-11T22:41:56.343', 'LastEditDate': '2012-12-04T23:16:30.893', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7164', 'Score': '7', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models>', 'CreationDate': '2012-12-04T20:48:56.857', 'Id': '7162'}{'Body': '<p>I\'m reviewing for a computability test, and my professor has not provided solutions to his practice questions. I came up with a "solution" to this problem, but it really seems like my answer is wrong (since I call upon $\\mathsf{Halt}$ twice)...</p>\n\n<p>We are given this initial language for some machine $M$:</p>\n\n<p>$\\mathsf{2Strings} = \\left\\{ \\left&lt;M\\right&gt;\\ |\\ L(M)\\text{ contains at least 2 distinct strings }\\land M\\text{ is a }TM \\right\\}$</p>\n\n<p>And we are told to "<em>[s]how that [the language] is recursive-enumerable.</em>" The problem title is <strong>Reduction</strong>, so I assume we are supposed to use that.</p>\n\n<p>My solution is as follows:</p>\n\n<ol>\n<li>Pass $\\left&lt;M\\right&gt;$ to the following reduction:</li>\n<li>Create $w_1 \\in L(M), w_2 \\in L(M)$, so that $w_1 \\not= w_2$, and let $M\' = M$.</li>\n<li>Pass $\\left&lt;M\', w_1\\right&gt;$ to $\\mathsf{Halt}$. If the answer is <strong>Yes</strong>, proceed to step 4. Otherwise, return <strong>No</strong>.</li>\n<li>Pass $\\left&lt;M\', w_2\\right&gt;$ to $\\mathsf{Halt}$. If the answer is <strong>Yes</strong>, return <strong>Yes</strong>. Otherwise, return <strong>No</strong>.</li>\n</ol>\n\n<p>Basically, this is my logic: We pass each of two distinct strings from $L(M)$ to $\\mathsf{Halt}$ separately; if either one says <strong>No</strong>, our answer is <strong>No</strong>. If both say <strong>Yes</strong>, the answer is <strong>Yes</strong>.</p>\n\n<p>Is my answer valid? More importantly, is it correct? If not, what should I do to fix it?</p>\n', 'ViewCount': '163', 'Title': 'Reducing a problem to Halt', 'LastActivityDate': '2012-12-23T04:55:15.973', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7218', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2827', 'Tags': '<computability><reductions>', 'CreationDate': '2012-12-06T20:09:25.660', 'Id': '7215'}{'Body': '<p>In this question we only consider Turing machines that halt on all inputs. If $k \\in \\mathbb{N}$ then by $T_k$ we denote the Turing machine whose code is $k$.</p>\n\n<p>Consider the following function </p>\n\n<p>$$s(x,y) = \\min\\{k \\mid |L(T_k) \\cap \\{x,y\\}| = 1\\}$$</p>\n\n<p>In other words, $s(x,y)$ is the code of the smallest Turing machine that recognizes precisely one of the strings $x,y.$ We can now define the following map</p>\n\n<p>$$d(x,y) = \\left\\{\n    \\begin{array}{ll}\n  2^{-s(x,y)}  &amp; \\mbox{if } x \\ne y, \\\\\n  0 &amp; \\mbox{otherwise.}\n    \\end{array}\n\\right.\n$$</p>\n\n<p>It can be quickly verified that $d(x,y)$ induces a metric space (in fact an ultrametrics) on $\\Sigma^{*}.$</p>\n\n<p>Now I would like to prove that if $f:\\Sigma^{*} \\mapsto \\Sigma^{*}$ is a <a href="http://en.wikipedia.org/wiki/Uniform_continuity">uniformly continuous</a> function then for every recursive language L, $f^{-1}(L)$ is recursive as well. </p>\n\n<p>In other words let $f$ be a map such that for every $\\epsilon &gt; 0$ there is a $\\delta &gt; 0$ such that if for strings $x,y \\in \\Sigma^{*}$ $$\\quad d(x,y) \\leq \\delta$$ then $$ d(f(x),f(y)) &lt; \\epsilon.$$  Then we need to show that $f^{-1}(L)$ is a recursive language given that $L$ is recursive.</p>\n\n<p>Now as already noted in <a href="http://cs.stackexchange.com/questions/7101/reducing-recursive-languages">this</a> post one way to approach the problem is to show that there is a Turing machine that given a string $x \\in \\Sigma^{*}$ computes $f(x).$ </p>\n\n<p>I am stuck proving this claim and slowly wondering if there is some other approach to solve this?</p>\n\n<p>Hints, suggestions and solutions are welcome!</p>\n', 'ViewCount': '226', 'Title': 'An interesting metric space related to Turing machines', 'LastActivityDate': '2012-12-11T05:58:31.013', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7255', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '3092', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-12-08T13:30:50.157', 'FavoriteCount': '3', 'Id': '7253'}{'Body': "<p>I have a language which is made out of and has a grammar only operating on well parenthesized words or words of one symbol. I want to know if the problem of belonging to this language is decidable.</p>\n\n<p><strong>Example.</strong> Consider the following grammar:\n$$a \\to a(aa) \\\\ a \\to b \\\\a (a(a(ab))) \\to b$$\nI'll denote by $L(x)$ the language generated by the above grammar and rule $S \\to x$.</p>\n\n<p>Trivially, $b \\in L(a)$, using rule 2.<br>\nAlso $b \\in L(a(aa))$ by the sequence of productions $a(aa) \\to a(a(a(aa))) \\to a(a(a(ab))) \\to b$.<br>\nHowever $b \\notin L(aa)$ because after applying rule 1 any number of times and then rule 2, symbol $a$ will be repeated $2n + 1$ times and rule 3 can only remove $4m$ of them.</p>\n\n<p>Note, the grammar is actually dealing with trees. Parentheses denote a subtree and symbols denote leaves. Hopefully the notation is clear enough. The language seems much weaker than RE but stronger than context free.</p>\n", 'ViewCount': '72', 'Title': 'About complexity of a language', 'LastActivityDate': '2012-12-23T15:08:22.480', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '7563', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5167', 'Tags': '<formal-languages><computability>', 'CreationDate': '2012-12-23T11:51:17.500', 'Id': '7561'}{'ViewCount': '447', 'Title': 'Which languages are recognized by one-counter machines?', 'LastEditDate': '2012-12-24T01:10:01.373', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2131', 'FavoriteCount': '1', 'Body': '<p><strong><a href="http://en.wikipedia.org/wiki/Counter_machine">Counter machines</a></strong> with two or more counters are typically shown to be equivalent to Turing machines in courses on the theory of computation.  However, I have not seen a formal analysis of which languages can be recognized by a one-counter machine.  Are these languages equivalent to the context-free languages (perhaps by some clever construction relating them to PDAs), or are they an entirely different class of languages?</p>\n', 'Tags': '<computability><automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-24T22:14:55.497', 'CommentCount': '1', 'AcceptedAnswerId': '7575', 'CreationDate': '2012-12-24T00:20:48.480', 'Id': '7574'}{'Body': "<p>Why are computable numbers (in Turing's sense) enumerable?\nIt must be very obvious, but I'm currently just not seeing it.</p>\n", 'ViewCount': '107', 'Title': "Why are computable numbers (in Turing's sense) enumerable?", 'LastActivityDate': '2012-12-31T03:51:04.403', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'OwnerDisplayName': 'Michiel Borkent', 'PostTypeId': '1', 'Tags': '<computability><turing-machines>', 'CreationDate': '2012-12-30T21:05:23.323', 'Id': '7654'}{'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Universal_Turing_machine" rel="nofollow">universal Turing machine</a> $U_{TM}$ is a TM that takes in as input an encoding of a TM and a string, then runs the TM on the string and does whatever the simulated TM does.  The language of the universal TM is the set of all encodings of a TM/string pair as a string for which the TM accepts the string.</p>\n\n<p>I have seen several different names for the language of the universal Turing machine.  Michael Sipser refers to it as $A_{TM}$ (the acceptance language for Turing machines), while Hopcroft, Ullman, and Motwani call it $L_u$ (the universal language).</p>\n\n<p>Is the a standardized term for the language of the universal Turing machine?  I would understand if there might be many "universal Turing machines" that vary in their encoding schemes, so if the answer is "no, there is no general term for this" that would be good to know.  I\'m mostly asking because I\'m teaching an introductory course in the theory of computation and have been using the term $A_{TM}$ for this without knowing if there is a better term to use.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '256', 'Title': 'Standard notation for the language of the universal Turing machine?', 'LastActivityDate': '2013-01-02T07:46:58.950', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7688', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><terminology><turing-machines>', 'CreationDate': '2013-01-02T05:30:33.547', 'Id': '7687'}{'ViewCount': '334', 'Title': 'Importance of recursion in computability theory', 'LastEditDate': '2013-01-05T01:35:23.707', 'AnswerCount': '2', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '3', 'Body': '<p>It is said that computability theory is also called recursion theory. Why is it called like that? Why recursion has this much importance?</p>\n', 'Tags': '<computability><terminology><history>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-05T13:01:20.953', 'CommentCount': '0', 'AcceptedAnswerId': '7762', 'CreationDate': '2013-01-04T15:15:03.867', 'Id': '7759'}{'Body': "<p>Given some complexity class $\\mathsf{C}$, I want to know if there exists a function (Turing machine) $F:\\mathbb{N} \\to \\mathsf{C}$ such that, if $S$ is any set for which the problem $x \\mapsto x \\in S$ is in $\\mathsf{C}$, then $F(n)$ is a Turing machine which (partially, if $\\mathsf C = \\mathsf{RE}$) decides $x \\in S$ for some $n$.</p>\n\n<p>Note that if $g$ and $h$ are two Turing machines that decide $x \\in S$, then $F$ only needs to enumerate one of them (hopefully this makes the problem easier). Thus the title is a bit wrong, but kept as it is for lack of a better one.</p>\n\n<p>Trivially, if $\\mathsf{C}$ equals something in the Chomsky hierarchy, such machine $F$ exists (enumerating all grammars of the required type). I'm interested in the less obvious classes.</p>\n", 'ViewCount': '88', 'Title': 'Which complexity classes are $\\mathsf{RE}$?', 'LastActivityDate': '2013-01-04T20:40:13.800', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '7765', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5167', 'Tags': '<complexity-theory><computability>', 'CreationDate': '2013-01-04T18:09:33.833', 'Id': '7764'}{'Body': '<p>I am new to Computability Theory and find it is both amazing and confusing. Specifically, it is difficult for me to get through the undecidability of the well-known Halting Problem. </p>\n\n<blockquote>\n  <p><strong>Halting function:</strong> The Halt function takes an input a pair $&lt;\\alpha, x&gt;$ and outputs 1 if and only if the TM $M_{\\alpha}$ represented by $\\alpha$ halts on input $x$ within a finite number of steps.</p>\n</blockquote>\n\n<p>The undecidability of Halting function is proved by reduction from another undecidable function $UC$, which is defined as follows <a href="http://www.cs.duke.edu/~reif/courses/complectures/books/AB/ABbook.pdf" rel="nofollow">Book by Arora and Barak</a>.</p>\n\n<blockquote>\n  <p><strong>$UC$:</strong> For every $\\alpha \\in \\lbrace 0,1 \\rbrace^{\\ast}$, if $M_{\\alpha}(\\alpha) = 1$, then $UC(\\alpha) = 0$; otherwise (if $M_{\\alpha}(\\alpha)$ outputs a different value or enters an infinite loop), $UC(\\alpha) = 1$.</p>\n</blockquote>\n\n<p>The undecidability of $UC$ is proved by the also well-known <em>"diagonalization"</em> technique. I can understand the technique. However, I am puzzling over a more basic problem involving the definition of $UC$.</p>\n\n<blockquote>\n  <p><strong>My Problem:</strong> The definition of $UC$ is based on the value of $M_{\\alpha}(\\alpha)$. Especially, it seem to be based on <em>whether a Turing Machine halts on an input</em>. However, the latter is undecidable (Worse still, it is undecidable due to the undecidability of $UC$!). In this sense, is the $UC$ function well-defined?</p>\n</blockquote>\n\n<p>What is wrong with my opinion? How should I understand the definition of $UC$ and the relation between $UC$ and Halting Problem?</p>\n\n<p>Thank for your help.</p>\n', 'ViewCount': '126', 'Title': 'Is the undecidable function $UC$ well-defined for proving the undecidability of Halting Problem?', 'LastActivityDate': '2013-01-07T19:26:06.113', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7788', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<computability><proof-techniques><undecidability><halting-problem>', 'CreationDate': '2013-01-05T11:29:41.143', 'Id': '7785'}{'ViewCount': '140', 'Title': 'Decision problem and algorithm', 'LastEditDate': '2013-01-05T12:41:30.573', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was reading about decision problem. I understand that decision problem tell yes/no answer for an input. The decision is based on a decision procedure also called an algorithm. </p>\n\n<p>The wikipedia says that </p>\n\n<blockquote>\n  <p>It is traditional to define the decision problem equivalently as: the set of inputs for which the problem returns yes.</p>\n  \n  <p>These inputs can be natural numbers, but may also be values of some other kind, such as strings over the binary alphabet $\\{0,1\\}$ or over some other finite set of symbols. The subset of strings for which the problem returns "yes" is a formal language, and often decision problems are defined in this way as formal languages.</p>\n</blockquote>\n\n<p>Whether I can take it like algorithm written in a programming language defines the set of all possibilities and gives the output based on the input?</p>\n\n<p>So in computability theory, the problem should be encoded to some form? Is this same thing as the input tape and configuration of a Turing machine (set of 0\'s and 1\'s )?</p>\n', 'Tags': '<computability><turing-machines><undecidability><decision-problem>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-05T14:46:26.633', 'CommentCount': '0', 'AcceptedAnswerId': '7790', 'CreationDate': '2013-01-05T12:27:42.627', 'Id': '7786'}{'Body': "<p>I am doing some excercises to train myself in computability.\nThere is one that I am not able to solve, here it is.</p>\n\n<p>Consider the following transformation associated to an extended WHILE program:</p>\n\n<p>For all $x \\in \\mathbb{N}$,\n$\\begin{cases}\n  A f(x) = x \\cdot f((x+3)/2) &amp; \\text{if \\(x\\) is odd} \\\\\n  A f(x) = f(x+1) &amp; \\text{otherwise} \\\\\n\\end{cases}$</p>\n\n<ol>\n<li>How many fixed points does $A$ have?</li>\n<li>Is there a maximum fixed point?</li>\n<li>Find the minimum fixed point.</li>\n</ol>\n\n<p>I know that a fixed point is a function $f$ such as $A f = f$.</p>\n\n<p>I would say there is an infinite fixed point. But how to prove it?</p>\n\n<p>To calculate the minimum, I would make a table with on each row: $\\bot$, $A \\bot$, $A^2 \\bot$, ... and if there are two similar lines, that's our minimum. But once again I am not sure this is enough to do this.</p>\n", 'ViewCount': '70', 'Title': 'Fixpoints of a transformation of an extended WHILE program', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-10T08:51:34.710', 'LastEditDate': '2013-01-08T20:26:26.420', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'Flo', 'PostTypeId': '1', 'Tags': '<computability>', 'CreationDate': '2013-01-08T15:54:04.527', 'Id': '7839'}{'Body': '<p>Let $A$ be the language $\\{\\langle M\\rangle\\mid M\\text{ is a Turing machine that accepts only one string}\\}$</p>\n\n<p>According to my understanding, if a Turing machine is able to decide if another Turing machine will accept only one string, then the halting problem could also be solved. Therefore, $A$ is non-recursively enumerable in my understanding.\nIs it correct ? </p>\n', 'ViewCount': '123', 'Title': 'Language comprising of Turing machine encodings', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-10T08:58:45.577', 'LastEditDate': '2013-01-10T06:55:38.930', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-01-10T01:54:48.163', 'Id': '7858'}{'Body': '<p>If a language is defined such that<br>\n$L = (0+1)^{\\ast}$   if $\\mathsf{P} = \\mathsf{NP}$ and $\\emptyset$   otherwise</p>\n\n<p>Then $L$ is a regular language if $\\mathsf{P} = \\mathsf{NP}$, otherwise it is the empty langauge. \nTherefore $\\mathsf{P} = \\mathsf{NP}$ , $L$ is recursive (being regular), but is $L$ still recursive if $\\mathsf{P} \\neq \\mathsf{NP}$?</p>\n', 'ViewCount': '150', 'Title': 'Recusively Enumerable or Recursive dependent on whether P=NP', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-10T11:51:40.033', 'LastEditDate': '2013-01-10T06:57:26.673', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><regular-languages><p-vs-np>', 'CreationDate': '2013-01-10T01:41:26.263', 'Id': '7859'}{'Body': '<p>Let $L_{1}$ and $L_{2}$ be two languages defined as follows :<br>\n   $L_1 = \\{ \\langle M\\rangle \\mid L(M) \\neq \\emptyset \\}$<br>\n   $L_2 = \\{ \\langle M\\rangle \\mid L(M) = \\emptyset \\}$<br>\n   where $\\langle M\\rangle$ denotes the encoding of a Turing Machine $M$. \n$L_{1}$ is the set of encodings of TMs that accept at least one string (i.e. the with non-empty languages), and $L_{2}$ is the set of encodings of TMs that do not accept any string (i.e. with empty lanugages). By making a language out of such encodings, I am essentially asking a Turing Machine to decide on another Turing machine as to whether the second TM has an empty language or not. This is essentially the halting problem, and so both languages are undecidable.             </p>\n\n<p>Now, I am not able to characterize $L_{1}$ and $L_{2}$ from among   </p>\n\n<ul>\n<li>not recursively enumerable  </li>\n<li>recursively enumerable but not recursive </li>\n<li>recursive </li>\n</ul>\n', 'ViewCount': '203', 'Title': 'Deciding Recursive/Recursively Enumerable when given Turning machine encoding as a language', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-01-10T03:58:22.040', 'LastEditDate': '2013-01-10T03:58:22.040', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-01-10T01:29:39.413', 'Id': '7860'}{'ViewCount': '826', 'Title': 'The difference between a sequence and a set', 'LastEditDate': '2013-01-13T13:14:58.283', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'MHZ', 'PostTypeId': '1', 'OwnerUserId': '5404', 'Body': "<p>I am new to discrete mathematics and the theory of computation I am trying to learn and understand the terminology. </p>\n\n<p>I am having a difficult time understanding the difference between a set and a sequence. I understand that unlike a set, in a sequence order and repetition does matter and sequences contain objects rather than elements or members. However, I don't see how sequences can be logically applied to the real world. </p>\n\n<p>Can someone please give a clear and simple example of when a sequence would be used as opposed to a set and explain how is a sequence is different that a set?</p>\n\n<p>I appreciate any clarification.</p>\n", 'Tags': '<computability><terminology><logic>', 'LastEditorUserId': '5404', 'LastActivityDate': '2013-01-13T13:14:58.283', 'CommentCount': '0', 'AcceptedAnswerId': '7920', 'CreationDate': '2013-01-13T01:29:02.113', 'Id': '7912'}{'Body': "<p>I was reading about counting principle related to TOC. I understand that the set of TMs are countable infinity. I couldn't understand the significance of it. What is its not countable?</p>\n", 'ViewCount': '129', 'Title': "If set of TM's is not countable?", 'LastEditorUserId': '947', 'LastActivityDate': '2013-01-27T03:55:56.253', 'LastEditDate': '2013-01-13T07:37:55.000', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<computability><turing-machines><uncountability><church-turing-thesis>', 'CreationDate': '2013-01-13T06:49:46.727', 'Id': '7915'}{'Body': "<p>I am studying primitive recursive functions and there's something that I don't quite understand: let's take the function that computes $x+y$, then, in order to show that $f(x,y)=x+y$ is primitive recursive, my lecture notes give the following equations:</p>\n\n<p>\\begin{cases}\n   f(x,0)=x \\\\\n   f(x,y+1) = f(x,y)+1\n  \\end{cases}\nthis first bunch makes perfect sense to me, on the other hand, looking at the equations down below, I don't get why a new function $g$ is used and also why does it have three parameters, when the sum clearly has only two? Is that $y$ the variable that supposedly holds (partial) results from computation?</p>\n\n<p>\\begin{cases}\n   f(x,0)=u^1_1(x) \\\\\n   f(x,y+1) = g(y, f(x,y),x)\n  \\end{cases}</p>\n\n<p>where $g(x_1, x_2, x_3) = s(u^3_2(x_1, x_2, x_3))$.</p>\n", 'ViewCount': '64', 'Title': 'Clarifications on primitive recursive function definition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-16T12:05:02.913', 'LastEditDate': '2013-01-16T10:06:59.627', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '8966', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><terminology><recursion>', 'CreationDate': '2013-01-16T09:41:09.907', 'Id': '8963'}{'Body': '<p>As this thread title gives away I need to prove $x^y$ to be a primitive recursive function. </p>\n\n<p>So mathematically speaking, I think the following are the recursion equations, well aware that I am assigning to $0^0$ the value $1$, which shouldn\'t be, since it is an "indeterminate" form.</p>\n\n<p>\\begin{cases}\n  x^0=1 \\\\\n  x^{n+1} = x^n\\cdot x\n\\end{cases}</p>\n\n<p>More formally I would write:\n\\begin{cases}\n  h(0) = 1 \\\\\n  h(x,y+1) = g(y,h(x,x),x)\n\\end{cases}</p>\n\n<p>as $g(x_1, x_2, x_3) = h\\left(u^3_2(x_1, x_2, x_3),u^3_3(x_1, x_2, x_3)\\right)$ and provided $h(x,y) = x \\cdot y$ is primitive recursive.</p>\n\n<p>Is my proof acceptable? Am I correct, am I missing something or am I doing anything wrong?</p>\n', 'ViewCount': '524', 'Title': 'Show $x^y$ is a primitive recursive function', 'LastActivityDate': '2013-02-02T21:20:18.577', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><recursion><check-my-proof>', 'CreationDate': '2013-01-16T12:35:30.310', 'Id': '8967'}{'Body': "<p>Let $\\varphi(x)=2x$ if $x$ is a perfect square, $\\varphi(x) = 2x+1$ otherwise. Show $\\varphi$ is primitive recursive.</p>\n\n<p>In proving $\\varphi$ to be a p.r. function I think it could come in handy the following theorem:</p>\n\n<p>Let $\\mathcal C$ be a PRC class. Let the functions $g$, $h$ and the predicate $P$ belong to $\\mathcal C$, let</p>\n\n<p>\\begin{equation}\n f(x_1,\\ldots, x_n) =\n \\begin{cases}\n  g(x_1, \\ldots, x_n) \\;\\;\\;\\;\\;\\text{ if } P(x_1, \\ldots, x_n)\\\\\n  h(x_1,\\ldots,x_n) \\;\\;\\;\\;\\;\\text{ otherwise}\n \\end{cases}\n\\end{equation}\nThen $f$ belongs to $\\mathcal C$ because $$f(x_1, \\ldots, x_n) = g(x_1, \\ldots, x_n) \\cdot  P(x_1, \\ldots, x_n) + g(x_1, \\ldots, x_n) \\cdot \\alpha(P(x_1, \\ldots, x_n))$$ where </p>\n\n<p>\\begin{equation}\n \\alpha(x) =\n \\begin{cases}\n  1 \\;\\;\\;\\;\\;\\text{ if } x = 0\\\\\n  0 \\;\\;\\;\\;\\;\\text{ if } x \\neq 0\n \\end{cases}\n\\end{equation}</p>\n\n<p>and $\\alpha(x)$ is p.r.</p>\n\n<p>So similarly I would say that $\\varphi(x)$ is p.r. as</p>\n\n<p>\\begin{equation}\n \\varphi(x) =\n \\begin{cases}\n  2x \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{ if } x = t \\cdot t \\\\\n  2x+1 \\;\\;\\;\\;\\;\\text{ otherwise}\n \\end{cases}\n\\end{equation}\nhence $$\\varphi(x) = 2x \\cdot  P(x_1, \\ldots, x_n) + (2x+1) \\cdot \\alpha(P(x_1, \\ldots, x_n))$$ and $P$ is a primitive recursive predicate as $x \\cdot y$ is p.r. and also $x = y$.</p>\n\n<p>Does everything hold? Is there anything wrong? If so, since I am tackling this kind of exercise for the fist time, will you please tell me what's the proper way to solve this?</p>\n", 'ViewCount': '103', 'Title': 'Prove $\\varphi(x)$ to be primitive recursive', 'LastActivityDate': '2013-02-17T04:22:42.263', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><recursion><check-my-proof>', 'CreationDate': '2013-01-17T18:30:40.390', 'Id': '8999'}{'ViewCount': '146', 'Title': 'Faster growing busy beaver function', 'LastEditDate': '2013-01-21T11:19:52.540', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '6472', 'FavoriteCount': '1', 'Body': "<p>Standard busy beaver function draws attention to final count of nonzero symbols on tape. We could instead look at largest amount of nonzero symbols appearing on tape at <em>any</em> point of computation. This function's lower bound would be $\\Sigma(n)$ and upper bound would be $S(n)$ (max shifts function). Was there made any research on such functions? If so, are there any known values for this?</p>\n", 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-11T16:00:37.653', 'CommentCount': '1', 'AcceptedAnswerId': '9032', 'CreationDate': '2013-01-18T15:27:29.833', 'Id': '9031'}{'Body': "<p>I am tackling the halting problem right now and its remarkable theorem. My book states $\\text{HALT}(x,y)$ is true if $\\psi^{(1)}_{\\mathcal P}$ is defined and conversely $\\text{HALT}(x,y)$ is false if $\\psi^{(1)}_{\\mathcal P}$ is undefined. </p>\n\n<p>The purpose of the theorem, of course, is showing that $\\text{HALT}(x,y)$ is a not computable predicate. I will report the extract of the proof given:</p>\n\n<p>Suppose $\\text{HALT}(x,y)$ were computable. Then we could construct the program $\\mathcal P$:</p>\n\n<p>$$[A]\\;\\;\\;\\;\\;\\text{IF HALT}(X,X)\\text{ GOTO } A$$</p>\n\n<p>It is quite clear that $\\mathcal P$ has been constructed so that</p>\n\n<p>\\begin{equation}\n\\psi^{(1)}_{\\mathcal P}=\n\\begin{cases}\n\\text{undefined} \\;\\;\\; \\text{if HALT}(x,x) \\\\\n0 \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{if ~HALT}(x,x)\n\\end{cases}\n\\end{equation}</p>\n\n<p>I don't understand how $\\psi^{(1)}_{\\mathcal P}$ is undefined if $\\text{HALT}(x,x)$ is true, shouldn't $Y$ be equal to $0$ by default and moreover how could a non-terminating program <del>be defined</del> can have $0$ as output value. What am I missing here?</p>\n\n<p><em><strong>Edit</em></strong>: $\\psi^{(1)}_{\\mathcal P}(x)$ is the value of the output variable $Y$ at the terminal snapshot.</p>\n", 'ViewCount': '97', 'Title': 'Clarification on halting predicate computability', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-19T23:33:36.743', 'LastEditDate': '2013-01-19T18:12:20.003', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '9043', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><halting-problem>', 'CreationDate': '2013-01-19T15:30:36.087', 'Id': '9040'}{'Body': '<p>I need to show that $H_1(x)$ defined as follows is partially computable.</p>\n\n<p>\\begin{equation}\nH_1(x)=\n\\begin{cases}\n1 \\;\\;\\;\\;\\;\\text{ if } \\Phi(x,x) \\downarrow \\\\\n\\uparrow \\;\\;\\;\\;\\; \\text{ otherwise}\n\\end{cases}\n\\end{equation}</p>\n\n<p>The thing is my textbook, that is  "Computability, Complexity, and Languages" by Davis, Sigal and Weyuker, lacks of examples and walkthroughs so, personally, I find hard solving even the easiest exercises. </p>\n\n<p>I think I can prove $H_1(x)$ partially computable, if I can find a program $\\mathcal P$ that executes it.</p>\n\n<p>First of all for the Universality Theorem:</p>\n\n<p>$$\\Phi(x,x) = \\psi^{(1)}_{\\mathcal P}(x) \\text{ and } \\# (\\mathcal P)=x$$</p>\n\n<p>so I can write a program that computes $\\psi^{(1)}_{\\mathcal P}(x)$:</p>\n\n<p>\\begin{array} \\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;Y \\gets 0 \\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{IF } X \\neq 0 \\text{ GOTO } A \\\\\n[E] \\;\\;\\;\\text{ GOTO } E \\\\\n[A]\\;\\;\\;\\; Y \\gets Y+1 \n\\end{array}</p>\n\n<p>I don\'t know if I am on the right track. I would greately appreciate every comment, suggestion, nudge in the right direction, because I really feel kind of lost.</p>\n\n<p><strong>Attempt #2</strong>: First of all I am so very sorry for not providing you enough details. Basically:\n$$\\Phi^{(n)}(x_1, \\ldots, x_n, x_{n+1}) = \\psi^{(n+1)}_{\\mathcal P}(x_1, \\ldots, x_n, x_{n+1})$$</p>\n\n<p>in plain English $\\psi^{(n)}_{\\mathcal P}(x_1, \\ldots, x_n)$ is the value of the output at the terminal snapshot; $\\Phi^{(n)}(x_1, \\ldots, x_n, y)$, where $\\#(\\mathcal P) = y$  is the universal program $\\mathcal U_n$, which works as an interpreter, it keeps track of the current snapshot by <em>decoding</em> the number of program being interpreted, decides what to do next and do it. So $f(x) = \\Phi^{(1)}(x,y)=\\psi^{(2)}_{\\mathcal U_1}(x,y)$. So my answer would be:</p>\n\n<p>\\begin{array} \\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{IF } \\Phi(x,x) \\text{ GOTO } C \\\\\n[A] \\;\\;\\;\\text{ GOTO } A \\\\\n[C]\\;\\;\\;\\; Y \\gets 1 \n\\end{array}</p>\n\n<p>or</p>\n\n<p>\\begin{array} \\\\\n\\;\\;\\;\\;\\;\\;\\;\\;\\;\\text{IF STP}^{(2)}(x,x,y,k)  \\text{ GOTO } C \\\\\n[A] \\;\\;\\;\\text{ GOTO } A \\\\\n[C]\\;\\;\\;\\; Y \\gets 1 \n\\end{array}</p>\n\n<p>where $STP^{(n)}(x_1, \\ldots, x_n, y, t)$ is a primitive recursive predicate that happens to be true if the program with number $y$ on input $(x_1, \\ldots, x_n)$ eventually stops after $t$ steps.</p>\n', 'ViewCount': '135', 'Title': 'Show $H_1(x)$ is partially computable', 'LastEditorUserId': '2778', 'LastActivityDate': '2013-07-23T17:14:46.530', 'LastEditDate': '2013-07-23T17:14:46.530', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><check-my-proof>', 'CreationDate': '2013-01-20T19:07:16.897', 'Id': '9060'}{'Body': "<p>If I have a collection of oracle machines, can I decide every language? (I got this question from a former university exam and it sparked my interest).</p>\n\n<p>I thought if my collection has to be countable than I can't decide every language, since there's an uncountable amount of languages.</p>\n\n<p>But if my collection can be of any kind I figured could just add an oracle machine for every language with an oracle for that language, which would be sort of a trivial - brute force approach (the size of the collection would be uncountable than).</p>\n\n<p>Is there an issue with my approach / did I miss something? What happens if I have a countable number of oracles that can be used?</p>\n", 'ViewCount': '96', 'Title': 'Can a collection of oracle machines decide every language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T11:15:14.517', 'LastEditDate': '2013-01-21T11:15:14.517', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6490', 'Tags': '<formal-languages><computability>', 'CreationDate': '2013-01-20T20:14:03.270', 'Id': '9061'}{'ViewCount': '147', 'Title': "Where can I find a short and 'easy' peer reviewed paper on something from computability, decidability or complexity?", 'LastEditDate': '2013-01-26T20:49:07.570', 'AnswerCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6572', 'FavoriteCount': '2', 'Body': "<p>It's a homework assignment, we were asked to read, understand, and present to our colleagues a short paper/article (suggested 4-6 pages) for our Computability, Decidability or Complexity class.</p>\n\n<p>The articles I was able to find in the past couple days using google scholar a way over what we were taught, plus, 50-100+ pages is way over the scope of my assignment. In class, we were provided with an introduction to the three topics, complexity classes, relations between them, and (mostly informal) proofs for the most representative problems from each class by modelling them using all kinds of Turing Machines.</p>\n\n<p>Any possible solutions? It's the first time in my life I'm touching anything related to research, I can barely understand even the scope of most papers I find.. I guess any advice would be welcome.</p>\n", 'Tags': '<complexity-theory><computability><turing-machines><research>', 'LastEditorUserId': '6572', 'LastActivityDate': '2013-01-30T15:17:09.530', 'CommentCount': '0', 'AcceptedAnswerId': '9179', 'CreationDate': '2013-01-26T20:36:18.643', 'Id': '9178'}{'ViewCount': '258', 'Title': 'Is it possible to decide if a given algorithm is asymptotically optimal?', 'LastEditDate': '2013-02-02T12:51:15.650', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6642', 'FavoriteCount': '0', 'Body': '<p>Is there an algorithm for the following problem:</p>\n\n<blockquote>\n  <p>Given a Turing machine $M_1$ that decides a language $L$,<br>\n  Is there a Turing machine $M_2$ deciding $L$ such that\n  $t_2(n) = o(t_1(n))$?</p>\n</blockquote>\n\n<p>The functions $t_1$ and $t_2$ are the worst-case running times of Turing machines $M_1$ and $M_2$ respectively.</p>\n\n<p>What about space complexity?</p>\n', 'Tags': '<complexity-theory><computability><undecidability><decision-problem>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-02T12:51:15.650', 'CommentCount': '1', 'AcceptedAnswerId': '9399', 'CreationDate': '2013-01-31T10:58:26.190', 'Id': '9349'}{'ViewCount': '334', 'Title': 'P, NP and specialised Turing Machines', 'LastEditDate': '2013-02-08T08:34:13.790', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '6769', 'FavoriteCount': '2', 'Body': "<p>I'm sort of new, but very interested to the field of computing and complexity theory, and I want to clarify my understanding about how to class problems, and how strongly the problems relate to the machine being used to solve them.</p>\n\n<p><strong>My Understanding</strong></p>\n\n<ul>\n<li>Standard Turing Machine - a Turing Machine which has a finite alphabet, finite number of states and a single right-infinite tape</li>\n<li>Turing-Equivalent Machine - a Turing Machine which, can emulate, and be emulated by, a Standard Turing Machine (quite often with some trade-off between space and time achieved by the emulation)</li>\n<li><code>P</code> - the class of problems which can be solved in polynomial time using a Standard Turing Machine (defined above)</li>\n<li><code>NP</code> - the class of problems which can be verified in polynomial time using a Standard Turing Machine</li>\n<li><code>NP-complete</code> - the hardest problems which are still in <code>NP</code>, which all <code>NP</code> problems can be converted to in polynomial time</li>\n</ul>\n\n<p><strong>My Question</strong></p>\n\n<p>Are the complexity classes (<code>P</code>, <code>NP</code>, <code>NP-complete</code>, etc) related to the algorithm, or the algorithm and the machine?</p>\n\n<p>Said in another way, if you could create a Turing Equivalent Machine (that can solve all the problems that a Standard TM can, but in a different amount of time/space) and this new machine could solve an <code>NP-complete</code> problem in time which grows as a polynomial with respect to the input, would that imply <code>P=NP</code>?</p>\n\n<p>Or must the <code>NP-complete</code> problem be solvable on all possible Turing Machines in polynomial time to be considered in <code>P</code>?</p>\n\n<p>Or do I mis-understand something fundamental above?</p>\n\n<p>I have had a look (maybe not with the correct search terms, I don't know all the jargon quite well) but it seems most lectures/notes etc. focus on standard machines but say that custom machines often have some time/space speed up at the expense of space/time, without saying how that bears on complexity classes. I'm not really familiar enough with the jargon in this field yet to find papers which explain this.</p>\n", 'Tags': '<complexity-theory><computability><terminology><turing-machines><complexity-classes>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-08T20:15:58.060', 'CommentCount': '1', 'AcceptedAnswerId': '9593', 'CreationDate': '2013-02-08T02:06:20.137', 'Id': '9585'}{'ViewCount': '599', 'Title': 'Clear, intuitive derivation of the fixed-point combinator (Y combinator)?', 'LastEditDate': '2013-02-10T23:47:01.757', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '5291', 'FavoriteCount': '6', 'Body': '<p>The fixed-point combinator FIX (aka the Y combinator) in the (untyped) lambda calculus ($\\lambda$) is defined as:</p>\n\n<p>FIX $\\triangleq \\lambda f.(\\lambda x. f~(\\lambda y. x~x~y))~(\\lambda x. f~(\\lambda y. x~x~y))$</p>\n\n<p>I understand its purpose and I can trace the execution of its application perfectly fine; <strong>I would like to understand how to derive FIX from first principles</strong>.</p>\n\n<p>Here is as far as I get when I try to derive it myself:</p>\n\n<ol>\n<li>FIX is a function: FIX $\\triangleq \\lambda_\\ldots$</li>\n<li>FIX takes another function, $f$, to make it recursive: FIX $\\triangleq \\lambda f._\\ldots$</li>\n<li>The first argument of the function $f$ is the "name" of the function, used where a recursive application is intended. Therefore, all appearances of the first argument to $f$ should be replaced by a function, and this function should expect the rest of the arguments of $f$ (let\'s just assume $f$ takes one argument): FIX $\\triangleq \\lambda f._\\ldots f~(\\lambda y. _\\ldots y)$</li>\n</ol>\n\n<p>This is where I do not know how to "take a step" in my reasoning. The small ellipses indicate where my FIX is missing something (although I am only able to know that by comparing it to the "real" FIX).</p>\n\n<p>I already have read <a href="http://rads.stackoverflow.com/amzn/click/0262162091" rel="nofollow">Types and Programming Languages</a>, which does not attempt to derive it directly, and instead refers the reader to <a href="http://mitpress.mit.edu/books/little-schemer" rel="nofollow">The Little Schemer</a> for a derivation. I have read that, too, and its "derivation" was not so helpful. Moreover, it is less of a direct derivation and more of a use of a very specific example and an ad-hoc attempt to write a suitable recursive function in $\\lambda$.</p>\n', 'Tags': '<computability><logic><programming-languages><lambda-calculus>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-10T23:47:01.757', 'CommentCount': '3', 'AcceptedAnswerId': '9651', 'CreationDate': '2013-02-08T14:23:39.617', 'Id': '9604'}{'ViewCount': '152', 'Title': 'Unique tilings of squares', 'LastEditDate': '2013-02-12T06:32:28.717', 'AnswerCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '96', 'FavoriteCount': '2', 'Body': "<p>We want to tile $m\\times m$-square using two types of tiles: $1 \\times 1$-square tile and $2 \\times 2$-square tile such that every underlying square is covered without overlapping. Let us define a function $f(n)$ that gives the size of largest uniquely tillable square using $n$ $1\\times 1$-squares and any number of $2 \\times 2$-squares.</p>\n\n<p>Is this function computable? What is the algorithm?</p>\n\n<p>EDIT1: Based on Steven's answer, unique tiling means that there is one way to place the $2 \\times 2$-squares inside the $m \\times m$-square with a unique configuration for the positions of the $n$ $1 \\times 1$-squares inside the $m \\times  m$-square.</p>\n", 'Tags': '<computability><combinatorics>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-12T06:32:28.717', 'CommentCount': '14', 'AcceptedAnswerId': '9628', 'CreationDate': '2013-02-09T20:50:43.813', 'Id': '9621'}{'ViewCount': '705', 'Title': 'Why are there more non-computable functions than computable ones?', 'LastEditDate': '2013-02-11T05:56:31.970', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'user1288420', 'PostTypeId': '1', 'OwnerUserId': '6834', 'FavoriteCount': '2', 'Body': "<p>I'm currently reading a book in algorithms and complexity. At the moment I'm, reading about computable and non-computable functions, and my book states that there are many more functions that are non-computable than computable, in fact the majority is non-computable it says. In some sense I can intuitively accept that but the book does not give a formal proof nor does it  elaborate much on the topic.</p>\n\n<p>I just wanted to see a proof/let someone here elaborate about it/understand more strictly why there are so many more non-computable functions than computable ones.</p>\n", 'Tags': '<computability><turing-machines><combinatorics>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-11T05:56:31.970', 'CommentCount': '1', 'AcceptedAnswerId': '9634', 'CreationDate': '2013-02-10T08:57:32.950', 'Id': '9633'}{'Body': "<p>I am having trouble understanding a mapping reduction and I would appreciate your help. Define</p>\n\n<p>$\\quad \\begin{align}\n  A_{TM} &amp;= \\{ \\langle M, w \\rangle \\mid M \\text{ Turing machine}, w \\in \\mathcal{L}(M)\\} \\\\\n  S_{TM} &amp;= \\{ \\langle M,w \\rangle \\mid M \\text{ Turing machine}, w \\in \\mathcal{L}(M) \\implies w^R \\in \\mathcal{L}(M)\\} \\\\\n\\end{align}$</p>\n\n<p>and consider the reduction of $A_{TM}$ to $S_{TM}$ as follows.</p>\n\n<p>Given $\\langle M, w \\rangle$ the following Turing machine $M'$ is defined:</p>\n\n<pre><code>M' on input x:  \n  if x = 01 then accept  \n  else run M on w and accept x if M accepts w\n</code></pre>\n\n<p>I don't understand the reduction entirely, this reduction is supposed to solve $S_{TM}$ using $A_{TM}$.  Why do I need to check if <code>x = 01</code>? There is no need to check anything about the reverse of $w$?  How is that covered by the reduction?</p>\n", 'ViewCount': '177', 'Title': 'Mapping reductions for dummies', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-27T06:29:53.117', 'LastEditDate': '2013-03-27T11:59:03.577', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6821', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-02-11T16:15:33.440', 'FavoriteCount': '1', 'Id': '9683'}{'Body': '<p><strong>Motivation</strong>:  This question is motivated by my <a href="http://cs.stackexchange.com/questions/9621/unique-tilings-of-squares">previous question</a> . In that question, my statment of the uniqueness requirement is not interesting since it leads to easily computable function.  I am interested in constructing uncomputable function from a simple combainatorial problem.</p>\n\n<p>We want to tile $m\\times m$-square using two types of tiles: $1 \\times 1$-square tile and $2 \\times 2$-square tile without overlapping. We require packing the maximum number of $2 \\times 2$-squares while posiblliy leaving some of the $m \\times m$-squares uncovered? </p>\n\n<p>Let us define a function $f(n)$ that gives the size of largest tillable square using $n$ $1\\times 1$-squares and maximum number of $2 \\times 2$-squares.</p>\n\n<p>Is this function computable? Is it computable if we use Trominos instead of $2 \\times 2$-squares?</p>\n', 'ViewCount': '105', 'Title': 'Tiling of squares', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-12T06:32:38.140', 'LastEditDate': '2013-02-12T06:32:38.140', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<computability><combinatorics>', 'CreationDate': '2013-02-11T17:51:28.563', 'FavoriteCount': '1', 'Id': '9684'}{'ViewCount': '261', 'Title': 'Meaning of the Halting problem', 'LastEditDate': '2013-02-12T10:29:39.797', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '6836', 'FavoriteCount': '3', 'Body': "<p>The Halting Problem is defined as:</p>\n\n<p>$H_{TM} = \\{ \\langle M, w \\rangle \\mid \\text{\\(M\\) halts on input \\(w\\)}\\}$</p>\n\n<p>I'm not sure what it means. Is $H_{TM}$ a collection of Turing Machines such that all of them accept/reject the word $w$? Is that a specific word? Or does that mean any word in their alphabet?</p>\n\n<p>Thanks</p>\n", 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-12T23:33:30.040', 'CommentCount': '2', 'AcceptedAnswerId': '9702', 'CreationDate': '2013-02-12T10:07:51.983', 'Id': '9699'}{'Body': '<p>Is there an algorithm which decides whether a regular tree grammar $G$ is ambiguous, i.g. there exists a tree $t\\in L(G)$ which can be parsed by the grammar in more than one ways, using only leftmost derivations?</p>\n\n<p>Is there a proof available about the decidability, or a cite to a paper which proposes such an algorithm?</p>\n', 'ViewCount': '241', 'Title': 'Is the ambiguity of a regular tree grammar decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:40:05.507', 'LastEditDate': '2013-02-14T06:40:05.507', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6866', 'Tags': '<formal-languages><computability><formal-grammars><ambiguity><tree-grammars>', 'CreationDate': '2013-02-13T15:29:34.530', 'Id': '9745'}{'Body': '<p>I have a question about how you would find a example of a non Turing-recognizable language from the symmetric difference of two Turing-recognizable languages. I believe this is possible, but I am having problems coming up with a example in my head. Does anyone have any hints, or ideas about how to think about this?</p>\n', 'ViewCount': '86', 'Title': 'Non Turing-Recognizable from symmetric difference', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:35:24.823', 'LastEditDate': '2013-02-14T06:35:24.823', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6634', 'Tags': '<computability>', 'CreationDate': '2013-02-14T04:52:30.173', 'Id': '9760'}{'Body': '<p>The Halting problem is a natural undecidable language which is complete for the set of recursivly enumrable sets. I am interested in undecidable but not Turing-complete language such that we can not reduce the Halting problem to it.</p>\n\n<p>What is the most <strong>natural</strong> undecidable RE problem which is not Turing-complete?</p>\n', 'ViewCount': '112', 'Title': 'Natural RE undecidable problems but not Turing-complete', 'LastEditorUserId': '96', 'LastActivityDate': '2013-03-23T13:31:59.690', 'LastEditDate': '2013-03-23T13:31:59.690', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '96', 'Tags': '<computability><turing-completeness>', 'CreationDate': '2013-02-14T14:45:21.160', 'FavoriteCount': '1', 'Id': '9772'}{'ViewCount': '161', 'Title': 'A variant of the busy beaver function', 'LastEditDate': '2013-02-15T08:39:40.037', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '140', 'FavoriteCount': '1', 'Body': '<p>Reading this question "<a href="http://cs.stackexchange.com/questions/9772/natural-re-undecidable-problems-but-not-turing-complete">Natural RE undecidable problems but not Turing-complete</a>" the following language came to my mind:</p>\n\n<p>If $\\Sigma(\\cdot)$ is the busy beaver function (maximum attainable score among all halting 2-symbol n-state Turing machines of the above-described type, when started on a blank tape), define the function:</p>\n\n<p>$$BB(\\langle M \\rangle) = \n\\begin{cases} \n1 &amp; \\text{$\\langle M \\rangle$ computes $\\Sigma(\\cdot)$}\\\\  \n0 &amp; \\text{ otherwise}\n\\end{cases}$$</p>\n\n<p>Now define the language:</p>\n\n<p>$L = \\{ \\langle M \\rangle \\; | \\; \\langle M \\rangle \\mbox{ halts and } BB(\\langle M \\rangle) = 0 \\}$</p>\n\n<blockquote>\n  <p>Is $L$ recursively enumerable? (it should be r.e.: just simulate in parallel M with all TMs of the same length, and if $M$ halts and another $M\'$ halts with a higher score add M to the enumeration).</p>\n  \n  <p>Can we reduce the halting problem to $L$ ? (it seems that it cannot "capture" the halting of the busy beavers)</p>\n</blockquote>\n', 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '140', 'LastActivityDate': '2013-02-15T09:02:42.193', 'CommentCount': '9', 'AcceptedAnswerId': '9796', 'CreationDate': '2013-02-14T18:13:35.677', 'Id': '9780'}{'Body': '<p>Can I use principles of set theory in order to solve the following question?</p>\n\n<blockquote>\n  <p>For every $A,B \\in \\mathsf{co\\text{-}RE}$ with $A \\cap B = \\emptyset$, there is a separating language $C$ with $A \\subseteq C$ and $B \\cap C = \\emptyset$ so that $C$ is recursive.</p>\n</blockquote>\n', 'ViewCount': '167', 'Title': 'Are co-semidecidable languages separated by decidable ones?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-20T06:48:15.267', 'LastEditDate': '2013-02-20T06:48:15.267', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6911', 'Tags': '<computability>', 'CreationDate': '2013-02-16T23:51:31.950', 'Id': '9843'}{'Body': "<p>Between my textbook and various online sources (namely wikipedia), I'm very confused... can somebody clear up which words are synonymous and which mean different things?</p>\n\n<ul>\n<li>Many-to-one reduction</li>\n<li>Mapping reduction</li>\n<li>Turing reduction</li>\n<li>Cook reduction</li>\n<li>Karp reduction</li>\n<li>Polynomial-time many-to-one reduction</li>\n<li>Polynomial time turing reduction</li>\n</ul>\n\n<p>I've also seen others, but I can't recall them currently.</p>\n", 'ViewCount': '105', 'Title': 'What is the difference between these terms?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-17T08:53:28.023', 'LastEditDate': '2013-02-17T08:53:28.023', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '9855', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<complexity-theory><computability><terminology><reductions>', 'CreationDate': '2013-02-17T01:30:50.600', 'Id': '9847'}{'Body': '<p>We know that at the end computation should be done by physical systems which follow laws of physics. I know there are some researches that study the <a href="http://en.wikipedia.org/wiki/Phase_transition" rel="nofollow">phase transition</a> phenomenon in physics and try to connect it with some properties in complexity theory (such as P and NP famous problem ). Just a quick review for example the phase transition happens from 2-SAT problem to 3-SAT problem. The first one is in P and the second one is NP-Complete. </p>\n\n<p>My question is that: Is there any study that shows the <strong>mapping of Polynomial Hierarchy</strong> (PH) and <strong>multi-phase systems</strong>? Is there any mapping between PH-Complete problems and real physical system states? If so, are all levels of these hierarchy stable?</p>\n', 'ViewCount': '34', 'Title': 'Polynomial Hierarchy and its Relation to Multi-Phase/States Physical Systems', 'LastActivityDate': '2013-02-17T18:09:44.167', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6550', 'Tags': '<complexity-theory><computability>', 'CreationDate': '2013-02-17T18:09:44.167', 'Id': '9864'}{'Body': "<p>For any language $L$ over $\\{0,1\\}^*$, a language $L'$ can be defined as $\\{ a | ab \\in L \\text{ for some } b \\in \\{0,1\\}^* \\}$.</p>\n\n<p>If $L$ is decidable, is $L'$ decidable?</p>\n\n<p>I think that $L'$ should be decidable because we can create a Turing machine for $L'$ that will run the decider for $L$ on the input $w$ for $L'$, accept if it accepts, and otherwise will enumerate all the possible strings $b$ and run $wb$ on $L$. Does that make sense?</p>\n", 'ViewCount': '60', 'Title': 'computability - decidability of a prefix language', 'LastEditorUserId': '683', 'LastActivityDate': '2013-02-20T19:24:39.137', 'LastEditDate': '2013-02-20T19:24:39.137', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6965', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-02-20T18:21:41.973', 'Id': '9976'}{'Body': '<p>Turing machines and unrestricted grammars are two different formalisms that define the RE languages.  Some RE languages are decidable, but not all are.</p>\n\n<p>We can define the decidable languages with Turing machines by saying that a language is decidable iff there is a TM for the language that halts and accepts all strings in the language and halts and rejects all strings not in the language.  My question is this: <em>is there an analogous definition of decidable languages based on unrestricted grammars rather than Turing machines?</em></p>\n', 'ViewCount': '215', 'Title': 'Decidable languages and unrestricted grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-27T11:29:06.683', 'LastEditDate': '2013-02-27T11:19:06.537', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><turing-machines><formal-grammars>', 'CreationDate': '2013-02-26T17:07:14.603', 'Id': '10124'}{'Body': '<p>Programmers do sometimes write a program that creates infinite loop if some particular input is passed into the program.</p>\n\n<p>But Simply-typed lambda calculus has to stop - so the question is, can anyone show some "useful" program in Turing-complete language (e.g. untyped lambda calculus) that does not go into infinite loop but cannot be written in (simply-)typed lambda calculus?</p>\n\n<p>from comment section:</p>\n\n<p>"Yes I know all of these and I know that they are more expressive and those - but halting problem would only have meaning if there is an algorithm (program) that typed ones cannot express - otherwise, we can write all programs into typed one and see whether it is well-formed, right? Then we automatically know whether a program halts or not. This is what I am asking."</p>\n', 'ViewCount': '206', 'Title': 'A program that cannot be written in (simply-)typed lambda calculus but only in lambda calculus or Turing-complete language', 'LastEditorUserId': '7103', 'LastActivityDate': '2013-03-02T09:08:56.633', 'LastEditDate': '2013-03-02T09:08:56.633', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7103', 'Tags': '<complexity-theory><computability><programming-languages><lambda-calculus>', 'CreationDate': '2013-03-02T04:49:49.113', 'FavoriteCount': '1', 'Id': '10197'}{'Body': u'<p>I have to reduce $L_\\text{empty}$ to $L_\\text{inf}$</p>\n\n<p>where </p>\n\n<p>$\\qquad L_\\text{empty} = \\{e \\mid |L(P_e)| = 0 \\}$ and<br>\n$\\qquad L_\\text{inf}= \\{e \\mid |L(P_e)| = \\infty \\}$.</p>\n\n<p>where $P_e$ is the program with G\xf6del number $e$, and $L(P_e)$ the language it accepts.</p>\n\n<p>So can I define a program $P$ like this</p>\n\n<pre><code>input n\nRun Pe on 1...n for n steps\nif Pe accepts any number then \n  enter an infinite loop and start accepting infinite number\nif Pe does not accept any number then \n  accept 1\n</code></pre>\n\n<p>Now if I can define program P like above then asking the question whether the index of $P$ is in $L_\\text{inf}$ will tell me whether the language accepted by $P_e$ is empty or not.</p>\n', 'ViewCount': '75', 'Title': 'Can I use infinite numbers in a reduction?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-11T07:31:15.733', 'LastEditDate': '2013-03-11T07:31:15.733', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7222', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-03-11T00:40:18.537', 'Id': '10442'}{'ViewCount': '391', 'Title': 'Can a Turing Machine decide if an NFA accepts a string of prime length?', 'LastEditDate': '2013-03-28T10:11:57.990', 'AnswerCount': '1', 'Score': '10', 'OwnerDisplayName': 'user2216670', 'PostTypeId': '1', 'OwnerUserId': '7450', 'FavoriteCount': '1', 'Body': "<p>I want to know if the following problem is decidable:</p>\n\n<p>Instance: An NFA A with n states</p>\n\n<p>Question: Does there exist some prime number p such that A accepts some string of length p.</p>\n\n<p>My belief is that this problem is undecidable, but I can't prove it. The decider can easily have an algorithm to figure out if a particular number is prime, but I don't see how it would be able to analyze the NFA in enough detail to know exactly what lengths it can produce. It could start testing strings with the NFA, but for an infinite language, it may never halt (and thus not be a decider).</p>\n\n<p>The NFA can easily be changed to a DFA or regular expression if the solution needs it, of course.</p>\n\n<p>This question is something I've been pondering as a self-made prep question for a final I have coming up in 2 weeks.</p>\n", 'Tags': '<computability><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T10:11:57.990', 'CommentCount': '3', 'AcceptedAnswerId': '10851', 'CreationDate': '2013-03-27T17:28:14.523', 'Id': '10848'}{'Body': '<p>Earlier I asked the question: <a href="http://cs.stackexchange.com/questions/10848/can-a-turing-machine-decide-if-an-nfa-accepts-a-string-of-prime-length">Can a Turing Machine decide if an NFA accepts a string of prime length?</a>. The answer introduced me to Parikh\'s theorem, which I\'ve been reading about. The concept of Parikh\'s theorem, if we apply it to regular expressions, allows us to break down a regular expression into expressions that only have one level of Kleene-star nesting.</p>\n\n<p>So: $aa(b(cc)^*)^*$ can have a list of expressions created using the same methodology as Parikh\'s theorem where none of the new expressions in the final list has nested Kleene-stars. The linear subsets will use starred expressions </p>\n\n<p>To make it more clear, I\'m referencing this paper: <a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow"><a href="http://people.inf.ethz.ch/torabidm/par-ext.pdf" rel="nofollow">http://people.inf.ethz.ch/torabidm/par-ext.pdf</a></a>.</p>\n\n<p>I\'m not too concerned with it actually being a regular expression, DFAs or NFAs would work fine. It seems easier to work with as an RE.</p>\n\n<hr>\n\n<p>I want to know if the problem is decidable:</p>\n\n<p><strong>Instance</strong>: A regular expression $R$</p>\n\n<p><strong>Question</strong>: Does there exist some length $l \\ge 1$ such that $R$ accepts every string of that length (ie. if its alphabet is $\\Sigma$, it accepts $\\Sigma^l$, for some $l \\ge 1$.</p>\n\n<hr>\n\n<p>I\'m pretty sure the problem actually is decidable but it\'s a tough one. I\'ve enjoyed pondering it so far and would love to see what someone more experienced than myself can come up with.</p>\n', 'ViewCount': '359', 'Title': 'Can a Turing Machine decide if a regular expression matches all strings of exactly some length $l \\geq 1$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-02T07:22:55.830', 'LastEditDate': '2013-03-29T18:35:42.483', 'AnswerCount': '3', 'CommentCount': '8', 'AcceptedAnswerId': '10880', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7450', 'Tags': '<computability><finite-automata><regular-expressions>', 'CreationDate': '2013-03-28T20:10:53.063', 'Id': '10879'}{'Body': '<p>I know every regular language is Turing-acceptable, but does that imply it is Turing-decidable?</p>\n', 'ViewCount': '537', 'Title': 'Is every regular language Turing-decidable, and how can we prove this?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-03T07:10:25.113', 'LastEditDate': '2013-04-03T07:10:25.113', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10973', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<terminology><computability><regular-languages><decision-problem>', 'CreationDate': '2013-04-02T13:51:03.390', 'Id': '10971'}{'Body': "<p>I'm studying Turing Machines and I've already showed how Turing-Decidable is closed for the operations of Union, Intersection, Concatenation, Complement and Kleene Star. Next I did some demonstrations to show how T-Recognizable languages are closed for Union, Intersection, Concatenation and Kleene Star.</p>\n\n<p>Now I'm trying to answer a question to show why the classe of T-Recognizable languages are not closed for the operation of Complementation, but I cannot understand it. Could someone please explain this?</p>\n", 'ViewCount': '1166', 'Title': "Why isn't the class of Turing-Recognizable languages closed under Complement?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T19:56:48.270', 'LastEditDate': '2013-04-07T19:01:23.620', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7632', 'Tags': '<computability><undecidability><closure-properties>', 'CreationDate': '2013-04-07T17:52:07.083', 'Id': '11104'}{'Body': "<p>In writing a decider for a machine to see if it has made a left move or not on an input of <em>w</em>, it is said that if we continue the computation for $|w|+N+1$ ($N$ : number of states) number of steps, we can make a decision for this decide.</p>\n\n<p>I didn't get why $|w|+N+1$ number of steps. Could someone explain this in more detail?</p>\n", 'ViewCount': '132', 'Title': 'Deciding if a Turing machine has made a left move', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:58:44.187', 'LastEditDate': '2013-04-10T08:58:44.187', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11162', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7415', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-04-09T12:10:26.377', 'Id': '11159'}{'ViewCount': '1040', 'Title': 'How to show that a function is not computable?', 'LastEditDate': '2013-06-06T16:06:21.617', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '5', 'Body': "<p>I know that there exist a Turing Machine, if a function is computable. Then how to show that the function is <em>not</em> computable or there aren't any Turing Machine for that. Is there anything like a Pumping lemma?</p>\n", 'Tags': '<computability><proof-techniques><undecidability><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-08-07T07:04:22.880', 'CommentCount': '4', 'AcceptedAnswerId': '11289', 'CreationDate': '2013-04-10T02:38:54.367', 'Id': '11181'}{'Body': '<p>If there is a Turing Machine $M_e$ (computing some partially computable function $f$), is there an algorithm to decide if $f$ diverges for all possible inputs?</p>\n', 'ViewCount': '109', 'Title': 'Does Turing Machine divergence depend on the input?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T04:44:34.687', 'LastEditDate': '2013-04-10T18:34:48.943', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'OwnerDisplayName': 'Gauk', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><undecidability><halting-problem>', 'CreationDate': '2013-04-10T10:36:06.323', 'Id': '11196'}{'ViewCount': '98', 'Title': 'Why the name Recursively Enumerable and Recursive?', 'LastEditDate': '2013-04-10T18:35:14.180', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>Why did the sets of languages accepted/decided by a TM get the name Recursively Enumerable and Recursive, respectively?</p>\n', 'ClosedDate': '2013-12-10T22:13:09.560', 'Tags': '<terminology><computability><turing-machines><history>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T20:02:27.980', 'CommentCount': '1', 'CreationDate': '2013-04-10T17:08:52.637', 'Id': '11197'}{'Body': '<p>In computability and complexity theory (and maybe other fields), reductions are ubiquitous. There are many kinds, but the principle remains the same: show that one problem $L_1$ is at least as hard as some other problem $L_2$ by mapping instances from $L_2$ to solution-equivalent ones in $L_1$. Essentially, we show that any solver for $L_1$ can also solve $L_2$ if we allow it to use the reduction function as preprocessor.</p>\n\n<p>I have performed my share of reductions over the years, and something keeps bugging me. While every new reduction requires a (more or less) creative construction, the task can feel repetitive. Is there a pool of canonical methods?</p>\n\n<p>What are techniques, patterns and tricks one can regularly employ for constructing reduction functions?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '548', 'LastEditorDisplayName': 'user742', 'Title': 'What are common techniques for reducing problems to each other?', 'LastActivityDate': '2014-01-17T18:09:43.470', 'LastEditDate': '2013-05-15T10:15:37.360', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><computability><reductions><proof-techniques><reference-question>', 'CreationDate': '2013-04-10T21:31:03.203', 'FavoriteCount': '10', 'Id': '11209'}{'Body': '<blockquote>\n  <p>A TM for a recursive language corresponds to our informal notion of an algorithm.</p>\n</blockquote>\n\n<p>as per Automata Theory, Languages and Computation by Ullman et al. Then there are languages called RE and $L_d$, where there exist TM that halts for accepting strings in the case of RE languages.</p>\n\n<p>This means that we cannot construct a algorithm for RE languages that are not recursive? Then what is the significance of these RE languages from an algorithm point of view.</p>\n\n<p>What confuses me is that for RE language you can construct a TM. So you can construct an algorithm?</p>\n', 'ViewCount': '97', 'Title': "What does it mean to say that there doesn't exist an algorithm from a TM point of view?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-14T11:20:42.773', 'LastEditDate': '2013-04-14T11:13:02.347', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '11310', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-04-13T13:34:34.777', 'Id': '11285'}{'Body': '<p>I have a homework problem that says:</p>\n\n<p><em><strong>For $g(x,y)=xy-5$ compute $h(x) = \\mu y(g(x,y))$ and determine its domain.</em></strong></p>\n\n<p>I was under the impression that this means the least y such that $g(x,y)=0$, so then $y = \\frac{5}{x}, D=\\{x \\in \\mathbb{N}, x \\neq 0\\}$</p>\n\n<p>So $h(x)=\\frac{5}{x}$?</p>\n', 'ViewCount': '60', 'Title': 'Have I got the right understanding of the mu operator?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-04-16T00:59:05.323', 'LastEditDate': '2013-04-16T00:54:30.127', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Tags': '<terminology><computability><mu-calculus>', 'CreationDate': '2013-04-15T15:55:45.027', 'Id': '11337'}{'Body': '<p>I got stuck on this question while studying for final exam.</p>\n\n<p><img src="http://i.stack.imgur.com/AdZCy.png" alt="the language"></p>\n\n<p>I thought about reducing L\' to L to prove that L\' is recognizable since L is recognizable. I am not 100% sure if that is correct.</p>\n', 'ViewCount': '68', 'Title': 'Prove that the Language is Recognizable', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-19T03:28:21.033', 'LastEditDate': '2013-04-19T03:28:21.033', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '11396', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7779', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-04-18T22:57:49.270', 'Id': '11391'}{'ViewCount': '408', 'Title': 'Is the intersection of two context free languages recursively enumerable?', 'LastEditDate': '2013-04-21T14:01:43.797', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Stephen', 'PostTypeId': '1', 'OwnerUserId': '6551', 'Body': '<p>I read a quotation attributed to Sheila Greibach that says that the intersection of two context free grammars is recursively enumerable.</p>\n\n<p>I could not, however, find a citation for this quotation (and searching has failed to turn up a restatement of this result somewhere else).</p>\n\n<p>Can anyone provide a proof or a citation to the original proof for this result?  Can anyone state that it is false?</p>\n', 'Tags': '<formal-languages><computability><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:01:43.797', 'CommentCount': '2', 'AcceptedAnswerId': '11394', 'CreationDate': '2013-04-16T23:24:53.927', 'Id': '11393'}{'Body': "<p>Why isn't the set $\\{ \\langle i, j \\rangle \\mid W_i = \\overline W_j\\}$ a r.e. set?</p>\n\n<p>Note: $W_x = L(M_x)$</p>\n", 'ViewCount': '51', 'Title': "Why isn't set $\\{ \\langle i, j \\rangle \\mid W_i = \\overline{W_j}\\}$ a recursively enumerated set?", 'LastEditorUserId': '2205', 'LastActivityDate': '2013-04-19T07:08:49.287', 'LastEditDate': '2013-04-19T06:44:43.583', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '11400', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<computability><reductions>', 'CreationDate': '2013-04-19T02:15:16.947', 'Id': '11395'}{'Body': "<p>I'm looking for a good book that explains these subjects in a readable way.\nAny suggestions ?</p>\n\n<p>I currently pursuing my BSC in computer science, and I just failed to pass the course introduction to thr theory of computation and complexity.\nI would like to have more reference and sources of knowledge so I can understand the subject better. Examples and solutions for various problems like proving undecidability, many to one reductions, etc can help me alot.</p>\n", 'ViewCount': '214', 'Title': 'Introduction to complexity and computability', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:20:11.200', 'LastEditDate': '2013-04-21T14:20:11.200', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5187', 'Tags': '<complexity-theory><computability><reference-request><books>', 'CreationDate': '2013-04-19T06:54:25.990', 'FavoriteCount': '1', 'Id': '11399'}{'Body': "<p>A few definitions..</p>\n\n<p>$$\n\\begin{align*}\n\\mathrm{ALL}_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle  \\,\\Big|\\, \\text{$M$ a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; L(M) = \\{0,1\\}^{*} \\Bigr\\}\n\\\\[2ex]\n\\overline{\\mathrm{ALL}}_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle  \\,\\Big|\\, \\text{$M$ a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; L(M) \\ne \\{0,1\\}^{*} \\Bigr\\}\n\\\\[2ex]\nB_{\\mathrm{TM}} &amp;= \\Bigl\\{\\langle M \\rangle \\,\\Big|\\, \\text{$M$ is a Turing Machine over $\\{0,1\\}^{*}$},\\;\\; \\varepsilon \\in L(M) \\Bigr\\}\n\\end{align*}\n$$</p>\n\n<p>We are showing a reduction from $B_{\\mathrm{TM}}$ to $\\overline{\\mathrm{ALL}}_{\\mathrm{TM}}$. In my notes I have the following solution to this problem which I'm trying to understand.</p>\n\n<ol>\n<li><p>Let $\\alpha \\in \\{0,1\\}^*$. Check that $\\alpha$ is of form $\\langle M \\rangle$, where $M$ is a TM over $\\{0,1\\}$. Else, let $f(\\alpha)$ be anything not in $\\overline{\\mathrm{ALL}}_{\\mathrm{TM}}$.</p></li>\n<li><p>Let $f(\\alpha)$ be $\\langle M' \\rangle$, where $M'$ on $x$ runs $M$ on $\\varepsilon$ (blank string) for up to $|x|$ steps. If $M$ accepts (in that time), then $M'$ rejects. Otherwise, $M'$ accepts.</p></li>\n</ol>\n\n<p>What I'm trying to understand is why must we run the TM $M'$ for $|x|$ steps for this to work? If we change the part #2 of the transformation to the following, why wouldn't this work?</p>\n\n<ul>\n<li>Let $f(\\alpha)$ be $\\langle M' \\rangle$, where $M'$ on $x$ runs $M$ on $\\varepsilon$ (blank string). If $M$ accepts, reject. Otherwise accept.</li>\n</ul>\n\n<p>Which then it follows that $\\varepsilon \\in L(M) \\!\\iff\\! L(M) = \\varnothing$,  that is $L(M) \\neq \\{0,1\\}^*$.</p>\n", 'ViewCount': '257', 'Title': 'Proving ALLTM complement not recognizable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:06:43.400', 'LastEditDate': '2013-04-21T14:06:43.400', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11412', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7776', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-04-19T16:41:41.893', 'Id': '11411'}{'Body': '<p>I am attempting to prove the following problem is undecidable. Given a Turing machine $M$ and input $x$, does $M$ visit infinitely many tape cells on input $x$? </p>\n\n<p>I am considering a reduction from the halting problem. Is this the right approach? </p>\n', 'ViewCount': '109', 'Title': 'Show the problem of a machine visiting infinitely many tape cells on some input is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-04T15:47:41.333', 'LastEditDate': '2013-04-21T23:15:04.180', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6723', 'Tags': '<computability><turing-machines><reductions><undecidability><halting-problem>', 'CreationDate': '2013-04-21T22:25:41.810', 'Id': '11479'}{'Body': "<p>If you have a language L, without doing any proofs, is there a way to tell if it's recognizable or co-recognizable or decidable?</p>\n\n<p>Basically any hints or tricks that can be used to tell. Or maybe the common patterns to search for to tell which kind it is?</p>\n", 'ViewCount': '452', 'Title': 'How to tell if a language is recognizable, co-recognizable or decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T18:02:58.057', 'LastEditDate': '2013-04-23T09:12:19.267', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<computability><undecidability><intuition>', 'CreationDate': '2013-04-22T21:00:40.460', 'Id': '11500'}{'ViewCount': '248', 'Title': 'Does our PC work as Turing Machine?', 'LastEditDate': '2013-04-23T12:28:36.693', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7384', 'FavoriteCount': '2', 'Body': u'<p>Does our PC work as Turing Machine?  The model of a Turing Machine consists of infinite memory tape, which means infinite states. But suppose if our PC has 128 MB memory and 30GB disk it would have 256^30128000000 states and thus, it has finite states.</p>\n\n<p>I know that we can write a type of program that, if during execution we run out of memory, will request to swap memory disk with empty memory disk and resume execution.</p>\n\n<p><strong>But what if we don\u2019t swap memory disk, in this case is it right to consider PC as FA</strong>?  </p>\n', 'Tags': '<complexity-theory><computability><turing-machines><automata>', 'LastEditorUserId': '1861', 'LastActivityDate': '2013-04-23T15:53:04.873', 'CommentCount': '1', 'AcceptedAnswerId': '11516', 'CreationDate': '2013-04-23T11:46:49.043', 'Id': '11514'}{'Body': "<p>How can we prove that $h(x) = g(f(x))$ is a reduction function for $A \\leq_m C$,</p>\n\n<p>if $f$ is the reduction function of  $A \\leq_m B$ and $g$ is the reduction function for  $B \\leq_m C$</p>\n\n<p>The given Proposition is: $A \\leq_m B, B \\leq_m C \\Rightarrow A \\leq_m C$</p>\n\n<p>I was thinking about using $HALT_{TM}$ for A. So on input $\\langle M, w\\rangle \\in A$ if and only if $\\langle M'',w'' \\rangle \\in  C$</p>\n\n<p>The output of A would be $ \\langle M', w' \\rangle$ and the output of B would be $\\langle M'',w'' \\rangle$</p>\n\n<p>If the constructed $M$ rejects the input $x$, then it loops forever, so $C$ is not recursive if $A$ is not recursive</p>\n\n<p>If this isn't sufficient, then what am I missing?</p>\n", 'ViewCount': '318', 'Title': 'How to prove Transitive property of Reducibility with a TM?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:32:52.450', 'LastEditDate': '2013-08-22T14:32:52.450', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11537', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-04-24T11:19:14.237', 'Id': '11536'}{'ViewCount': '115', 'Title': 'Is there a name for complement of recursively enumerable set?', 'LastEditDate': '2013-04-27T04:51:56.517', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Juris', 'PostTypeId': '1', 'OwnerUserId': '7911', 'Body': '<p>If there is a recursive function\n$$\nf(x) = \n\\begin{cases}\n1 &amp; \\text{if $x \\notin A$}\\\\\n\\text{undefined} &amp; \\text{if $x \\in A$}\\\\\n\\end{cases}\n$$</p>\n\n<p>Is there a special name for the class of sets like $A$?</p>\n', 'Tags': '<terminology><computability><undecidability>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-27T04:51:56.517', 'CommentCount': '3', 'AcceptedAnswerId': '11584', 'CreationDate': '2013-04-25T15:45:02.357', 'Id': '11564'}{'Body': '<p>Is there any way to find out how to replace for/if for elementary recursive algorithms? I know that primitive recursive functions cannot basically eliminate "for", but for elementary recursive functions, there must be a way to convert the program into ones that do not have for/if/while and so on (which is elementary recursive).</p>\n', 'ViewCount': '76', 'Title': "How to eliminate for/if/while from algorithms when it's possible", 'LastActivityDate': '2013-04-28T01:40:46.220', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7941', 'Tags': '<complexity-theory><computability><programming-languages>', 'CreationDate': '2013-04-28T01:40:46.220', 'FavoriteCount': '1', 'Id': '11618'}{'Body': '<p>I am doing some work on register machine theory which revolves around a 2-register register machine and attempting to show that it is not possible to compute an upper-bound on the final contents of its two registers on the basis of its program code and initial input, in halting configurations only. I believe this can be related in some way to the <em>busy beaver</em> problem, but I cannot quite see how, and the stipulations that it is for halting configurations only has confused me somewhat.</p>\n\n<p>What do I know so far?</p>\n\n<ul>\n<li><p>Clearly a register machine configuration specified by the 3-tuple <em>(instruction label, register 0, register 1)</em> has an infinite number of possible states, owing to the abstract nature of the machines, as no practical limit is imposed on the size of the natural numbers which can be stored in each register.</p></li>\n<li><p>I considered whether I could simply define a partial function $f : \\mathbb{N}^3 \\to \\mathbb{N}$ where the arguments are the program encoded as a natural number and the initial contents of the two registers, but I do not think this gets me anywhere. I defined the function to be undefined when the partial function computed by the register machine specification is undefined on the given input, as the problem specifies computing the upper bound for halting configurations only. <br/><br/>Therefore, I cannot use a diagonal argument to suggest it would imply the halting problem, because being undefined for a non-halting configuration suggests it would not.</p></li>\n<li><p>Secondly, I tried to come up with a proof on the basis that there is an infinite number of possible configurations which a 2-register machine can be in. In particular, there is an infinite number of possible programs $e \\in \\mathbb{N}$ which could be executed, and each of those programs can be executed on an infinite number of initial register configurations $\\mathbb{N}^2$.<br /><br />By construction, if there is a machine which can decide this partial function for any given combination, then I thought it may be the case that it required an infinite number of states in which to do so - which is of course not possible, as a register machine must be specified by a finite number of instructions.</p></li>\n</ul>\n\n<p>I am not confident that either approach is correct or not, and wonder whether either of the above is a correct tact or if a formal proof exists for this?</p>\n', 'ViewCount': '66', 'Title': 'Upper bound on register machine contents', 'LastActivityDate': '2013-04-30T16:32:15.903', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11679', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7928', 'Tags': '<computability><turing-machines><church-turing-thesis>', 'CreationDate': '2013-04-30T15:48:51.427', 'Id': '11678'}{'Body': "<p>Fix a universal Turing machine $M$.</p>\n\n<p>Let $A^*=\\{0,1\\}^n$ be the set of all binary string of length $n$.</p>\n\n<p>Determine the Kolmorogov complexity $K(x)$ of each $x\\in A$, w.r.t. $M$.</p>\n\n<p>Just for a matter of simplicity assume that $K(x)'=\\min(|x|,K(x))$.</p>\n\n<p>Let $B^*=\\{0,1\\}^n$ be the set of all programs $y\\in B$ of $T$: $x= M(y)$.</p>\n\n<p>Now, suppose a parallel machine $M_p$ that can run each program $y\\in B$ for each element in $A$, in parallel. So we can get the length of all the programs $y$ whose machine ended with the right string $x$, and take the minimum as $K(x)'$.</p>\n\n<p>So, should I assume that the non-computability is due to the fact that some machines that has not ended jet whose inputs $y$ are less than the current minimal program  will eventually halt? What's the probability of this?</p>\n\n<p>Also, maybe a measure of complexity should include a minimal length with a probabilistic confidence? Say $P(K(x)\\geq l)\\geq p$?</p>\n", 'ViewCount': '86', 'Title': 'Computability of Kolmogorov Complexity', 'LastActivityDate': '2013-05-09T10:59:55.187', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11852', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6655', 'Tags': '<computability><kolmogorov-complexity>', 'CreationDate': '2013-05-07T08:38:31.827', 'Id': '11850'}{'Body': "<p>I was asked this question at an interview, and couldn't answer it, and would like to know how it is 'shown' that two Turing machines which accept the same language is undecidable. This is not a homework question!</p>\n", 'ViewCount': '482', 'Title': 'Show that it is undecidable if two Turing Machines accept the same language', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-05-14T03:12:53.943', 'LastEditDate': '2013-05-09T20:06:15.133', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8104', 'Tags': '<algorithms><computability><finite-automata><undecidability>', 'CreationDate': '2013-05-09T17:18:46.500', 'Id': '11916'}{'Body': u'<p>I\'ve been reading some formal language theory papers, and I\'ve come across a term that I don\'t understand.</p>\n\n<p>The paper will often refer to a set being "effectively closed under intersection" or other operations. What does "effectively" mean here? How does this differ from normal closure?</p>\n\n<p>For reference, the paper I\'m seeing these in is:</p>\n\n<p>M. Daley and I. McQuillan. Formal modelling of viral gene compression. International Journal of Foundations of Computer Science, 16(3):453\u2013469, 2005.</p>\n', 'ViewCount': '125', 'Title': 'What does it mean to say that a language is "effectively closed" under an operation?', 'LastActivityDate': '2013-05-09T20:16:49.303', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11922', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><terminology><computability><automata><closure-properties>', 'CreationDate': '2013-05-09T19:51:28.577', 'Id': '11920'}{'ViewCount': '116', 'Title': 'Is there an always-halting, limited model of computation accepting $R$ but not $RE$?', 'LastEditDate': '2013-05-10T21:42:07.617', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '0', 'Body': '<p>So, I know that the halting problem is undecidable for Turing machines. The trick is that TMs can decide recursive languages, and can accept Recursively Enumerable (RE) languages.</p>\n\n<p>I\'m wondering, is there a more limited model of computation which accepts only recursive languages, and not RE? And if so, is there such a model which is always guaranteed to halt?</p>\n\n<p>Obviously this model would be strictly less powerful than TMs and strictly more powerful than PDAs.</p>\n\n<p>I\'m open to a machine-style model, or a lambda-calculus style model.</p>\n\n<p>As an example of what I\'m thinking: the Coq language has a restriction that for any self-recursive calls, the first argument must be strictly decreasing in "size" i.e. if it is a natural number, it must be smaller, if it is a list, it must be shorter, etc. This guarantees that it always halts, but I have no idea if you can compute all of R this way.</p>\n', 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><halting-problem>', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-11T07:39:41.863', 'CommentCount': '1', 'AcceptedAnswerId': '11943', 'CreationDate': '2013-05-10T15:58:41.437', 'Id': '11936'}{'Body': '<p>$A \\times B$ is an r.e. set,  I want to show that $A$ (or $B$) is  r.e.</p>\n', 'ViewCount': '100', 'Title': 'Each of the two sets is recursively enumerable given their cartesian product is', 'LastActivityDate': '2013-05-12T17:47:25.320', 'AnswerCount': '2', 'CommentCount': '10', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<computability><enumeration>', 'CreationDate': '2013-05-12T09:47:43.230', 'Id': '11961'}{'Body': '<p>I have this confusion related to the time complexity of the algorithm solving the knapsack problem using dynamic programming</p>\n\n<p><img src="http://i.stack.imgur.com/CvvMV.png" alt="enter image description here"></p>\n\n<p>I didn\'t get how the time complexity of the algorithm came out to be $O(nV^*)$</p>\n', 'ViewCount': '914', 'Title': 'Confusion related to time complexity of dynamic programming algorithm for knapsack problem', 'LastActivityDate': '2013-05-13T02:10:27.163', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6999', 'Tags': '<computability><time-complexity><dynamic-programming><knapsack-problems>', 'CreationDate': '2013-05-12T20:43:16.567', 'Id': '11976'}{'Body': '<p>I have two algorithms</p>\n\n<p>Algorithm 1:</p>\n\n<pre><code>if( Condition1(input)==true )\n   print(input);\nelse\n   loop forever;\n</code></pre>\n\n<p>Algorithm 2:</p>\n\n<pre><code>if( Condition2(input)==true )\n   print(input);\nelse\n   loop forever;\n</code></pre>\n\n<p>for any arbitrary fully-computable conditions 1 and 2.</p>\n\n<p>We know both of these algorithms are partially computable.</p>\n\n<p>I want to write a new algorithm (algorithm 3) like this:</p>\n\n<pre><code>if algorithm1 prints x and algorithm2 does not print x "if and only if" algorithm3 print x\n</code></pre>\n\n<p>Can I write algorithm3? And how?</p>\n', 'ViewCount': '60', 'Title': 'Algorithm for difference of two semi-decidable languages', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-15T15:29:47.080', 'LastEditDate': '2013-06-15T15:25:56.763', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8133', 'Tags': '<computability>', 'CreationDate': '2013-05-14T02:45:08.903', 'Id': '12000'}{'Body': '<p>I am trying to (intuitively) understand the two terms "decidability" and "verifiability".</p>\n\n<p>I have done a reasonable amount of searching and going through the various texts I can put my hands on. However, their intuitive understanding seems to escape me, specially for the second one.</p>\n\n<p>Out of the many definitions found, the following one found in <a href="http://kilby.stanford.edu/~rvg/154/handouts/decidability.html" rel="nofollow">this page</a>, clearly explained decidability to me.</p>\n\n<blockquote>\n  <p>A language is called decidable if there exists a method - any method\n  at all - to determine whether a given word belongs to that language or\n  not.</p>\n</blockquote>\n\n<p>However, I fail to find a parallel definition for verifiability.</p>\n\n<p>In the <a href="http://rads.stackoverflow.com/amzn/click/0534950973" rel="nofollow">Theory of Computation book by Sipser</a>, we find,</p>\n\n<blockquote>\n  <p>P = the class of languages for which membership can be <em>decided</em>\n  quickly. </p>\n  \n  <p>NP = the class of languages for which membership can be\n  <em>verified</em> quickly.</p>\n</blockquote>\n\n<p>In light of the above, I want to understand verifiability. </p>\n\n<p>Please provide as many examples as you can, at one moment, I try catch the meaning, in the next one, I get confused again.</p>\n', 'ViewCount': '154', 'Title': 'Please explain "decidability" and "verifiability"', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-17T18:15:56.733', 'LastEditDate': '2013-05-17T06:41:56.163', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '12079', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7200', 'Tags': '<complexity-theory><formal-languages><terminology><computability>', 'CreationDate': '2013-05-16T13:44:06.820', 'Id': '12068'}{'Body': '<p>I wonder how it\'s possible that:</p>\n\n<blockquote>\n  <p>it can be shown that all reasonable choices of programming\n  languages lead to quantification of the amount of absolute information in\n  individual objects that is invariant up to an additive constant.   </p>\n</blockquote>\n\n<p>from the <a href="http://books.google.co.uk/books?id=25fue3UYDN0C&amp;pg=PR7&amp;lpg=PR7&amp;dq=it+can+be+shown+that+all+reasonable+choices+of+programming+languages+lead+to+quantification&amp;source=bl&amp;ots=U58ndePaej&amp;sig=ZTCWNL8-tKStxBgoEaL3bPiYAsQ&amp;hl=en&amp;sa=X&amp;ei=zj-GUazlNYaY0AXy34CwDw&amp;ved=0CDgQ6AEwAg#v=onepage&amp;q=it%20can%20be%20shown%20that%20all%20reasonable%20choices%20of%20programming%20languages%20lead%20to%20quantification&amp;f=false" rel="nofollow">Preface to the First Edition, An Introduction to Kolmogorov Complexity and Its Applications</a> by Li &amp; Vitanyi.</p>\n\n<p>I don\'t know how they defined "<em>reasonable choice of programming language</em>", but in my sense, it seems natural that the choice of programming language could mix the rank of the complexity. If the programming language fits the object, the program would be shorter, and if not, it would be longer.</p>\n\n<p>But, if I understood it all right, the paragraph above says that no matter which programming language you choose for the strings(objects), the rank of the length of the programs would not change!</p>\n\n<p>Is it really possible? and could someone explain how it\'s possible? </p>\n\n<p>It is well known that either AND and NOT or OR and NOT can be a primitive function for a computer,</p>\n\n<p>and if I want to implement AND with (OR and NOT), it goes like</p>\n\n<p>NOT(NOT a OR NOT b) instead of just AND!!!</p>\n', 'ViewCount': '72', 'Title': 'The choice of programming language and the length of a program', 'LastActivityDate': '2013-05-16T16:04:59.000', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'user1924418', 'PostTypeId': '1', 'Tags': '<computability><kolmogorov-complexity>', 'CreationDate': '2013-05-06T08:30:57.243', 'Id': '12074'}{'Body': "<p>BB(n) is roughly the maximum number of new states an n-state TM can run into without halting. So for a particular n, if we know BB(n), then we can find out if an arbitrary n-state TM halts by running it for BB(n) steps.</p>\n\n<p>So given some n-state TM, can we construct an m-state TM, where m>n, to calculate BB(n) and thus decides if it halts?</p>\n\n<p>Now some might say that this is equivalent to solving the halting problem, but I don't think so. Because given an arbitrary TM, we don't in fact know how many states it has. And if we don't know n, we certainly can't find m.</p>\n\n<p>If the answer is in the negative, then how is it that we can in fact find out the values of BB(n) for small n? What's the connection between incomputability and unknowability?</p>\n", 'ViewCount': '59', 'Title': 'Given an n-state TM, can we construct an m-state TM (m>n) to determine if it halts?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-28T19:59:32.793', 'LastEditDate': '2013-05-28T19:59:32.793', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2157', 'Tags': '<computability><turing-machines><halting-problem><busy-beaver>', 'CreationDate': '2013-05-25T03:11:19.460', 'Id': '12261'}{'Body': u'<p>I am not sure whether this is the right place to ask this question, but since it involves register machine and computability, hopefully this is the right place.</p>\n\n<p>I have tried to post on Programmers and Stack Overflow, but they redirected me to this site, they said it is more related to CS.</p>\n\n<p>The question is about how can I write a register machine code/program that computes the Fibonacci number. The syntax of the code is actually really simple.</p>\n\n<p>(Below are just for reference only, sorry for the long post)<br>\n(For more explanation see the book on Formal Logic: Its Scope And Limits by Richard Carl Jeffrey)  </p>\n\n<p>According to Wikipedia a register machine is a generic class of abstract machines used in a manner similar to a Turing machine. A (processor) register is a small amount of storage available as part of a CPU or other digital processor.</p>\n\n<p>We can simplify the problem by modelling the registers as empty buckets, and we can let marbles or rocks to be put into the register ("bucket"). The rule is to add or remove marbles from the bucket to perform computations.</p>\n\n<p>The rules are:<br>\n1. A register machine uses of a finite number of buckets, and an unending supply of marbles.<br>\n2. Each bucket can be individually identified. The marbles need not be distinguishable.<br>\n3. A register machine program is a finite set of instructions:<br>\n- To add marble to a bucket (and then to go on to the next instruction).<br>\n- Or to take a marble away from a bucket (and to go on to one next\ninstruction if you can, or another one, if you can\u2019t).<br>\n4. The program can be written in a flowchart or in a list of instructions.</p>\n\n<p>Here is an example of a register machine program that performs addition.<br>\nLet A, B, C be buckets.<br>\n1. (-B; 2,4) means take away one marble from bucket B, go to instruction 2 if can, or 4 if cannot<br>\n2. (+A; 3) means add one marble to bucket A, then go to instruction 3<br>\n3. (+C; 1) means add one marble to bucket C, then go to instruction 1<br>\n4. (-C; 5,-) means take away one marble from bucket C, go to instruction 2 if can, or exit if cannot<br>\n5. (+B; 4) means add one marble to bucket B, then go to instruction 4</p>\n\n<p>It is easily shown that suppose we have 3 marbles in bucket A and 2 marbles in bucket B, and 4 marbles in bucket C. After performing this algorithm, there will be |A|+|B| = 3+2 = 5 marbles in bucket A and |B|+|C| = 2+4 = 6 marbles in bucket B.</p>\n\n<p>(I hope the example above is clear enough for illustration purpose)  </p>\n\n<p>(Now here comes the question)  </p>\n\n<p>Now, I would like to write a register machine code which when given an input of n in bucket A, returns (also in bucket A) the nth Fibonacci number. The Fibonacci numbers are 0 (the 0th), 1 (the 1st), 1 = 0 + 1 (the 2nd), etc. We can use any number of buckets, the goal is to write the code as simple as possible (i.e. with fewest instructions). Fibonacci recurrence relation is F(n)=F(n-1)+F(n-2) given F(0)=0 and F(1)=1. </p>\n\n<p>Here is my attempt and the code:<br>\nMy idea is to use bucket A as input and finally as output F(n) (since the question requires the output in bucket A), bucket B as the "counter", bucket C as the F(n-1) and bucket D as F(n-2).<br>\n1. (+C; 2)<br>\n2. (-A; 3,4)<br>\n3. (+B; 2)<br>\n4. (-D; 5,7)<br>\n5. (+A; 4)<br>\n6. (-C; 5,7)<br>\n7. (-B; 6,-)  </p>\n\n<p>But my code only works for up to n=2 sadly, I am struggling to make the code works for any n>2. </p>\n\n<p>I have been thinking for this days and nights, I would appreciate if anyone could help me on this. Please do not hesitate to ask me for clarification if anything is unclear.</p>\n\n<p>Many many thanks in advance!</p>\n', 'ViewCount': '36', 'ClosedDate': '2013-05-29T10:40:58.470', 'Title': 'How to write register machine code for Fibonacci', 'LastEditorUserId': '8141', 'LastActivityDate': '2013-05-29T08:33:20.713', 'LastEditDate': '2013-05-29T08:33:20.713', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8141', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-05-28T18:36:39.097', 'Id': '12339'}{'ViewCount': '130', 'Title': 'Computation of busy beaver function', 'LastEditDate': '2013-05-28T19:59:17.293', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8417', 'FavoriteCount': '2', 'Body': "<p>The busy beaver max shifts function, $S(n)$, has known values for $n\\leq4$. Is there some basic, structural reason why it's inconceivable that we will ever find $S(n)$ for $n&gt;4$?  What is so different about $n=4$  than $n=5$? Or $n=6$? Somewhere along the way there must be some fundamental difference, otherwise $S(n)$ would be, in principle, computable for all $n$, so what exactly <em>is</em> this difference?</p>\n", 'Tags': '<computability><busy-beaver>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-30T22:49:23.523', 'CommentCount': '0', 'AcceptedAnswerId': '12384', 'CreationDate': '2013-05-28T19:54:44.263', 'Id': '12340'}{'Body': '<p>If ${A}{ \\le _M} {{B}} $ then $\\overline A { \\le _M}\\overline B$ since the mapping reduction function is computable. </p>\n\n<p>So, if ${A_{TM}}{ \\le _M}\\overline {{A_{TM}}} $ then $\\overline{A_{TM}}{ \\le _M} {{A_{TM}}} $, hence $A{}_{TM} \\notin RE$. However, $A{}_{TM} \\in RE$.</p>\n\n<p>So is the claim above is true?</p>\n', 'ViewCount': '87', 'Title': 'The complement of the acceptance problem reduces to the acceptance problem: ${A_{TM}}{ \\le _M}\\overline {{A_{TM}}} $ is this claim true?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-05-31T13:04:46.543', 'LastEditDate': '2013-05-31T13:04:46.543', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8462', 'Tags': '<computability><reductions><computation-models>', 'CreationDate': '2013-05-31T11:54:45.417', 'Id': '12396'}{'Body': '<p>Are these languages recursively enumerable?</p>\n\n<ol>\n<li>$L = \\{ \\langle A\\rangle \\mid x\\in L(A)\\implies |x|\\leq 13\\}$</li>\n<li>$L = \\{\\langle A\\rangle \\mid L(A) \\subseteq \\overline{L_{\\mathrm{uni}}}\\}$, where $L_{\\mathrm{uni}} = \\{\\langle T\\rangle x \\in \\{0,1\\}^*\\mid x \\in L(T)\\}$.</li>\n</ol>\n\n<p>How would I prove / disprove that these languages are RE?</p>\n', 'ViewCount': '92', 'Title': 'Are these languages RE? How would I determine this?', 'LastEditorUserId': '2131', 'LastActivityDate': '2013-06-10T03:02:26.377', 'LastEditDate': '2013-06-10T03:02:26.377', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8599', 'Tags': '<computability>', 'CreationDate': '2013-06-09T15:54:15.107', 'Id': '12576'}{'Body': '<p>I have a a few fundamental doubts in recursive enumerability and countability and below, I have written what I understand them to be with proofs. But there are contradictions at the end. What is wrong with the statements/proofs i have made?</p>\n\n<p>Countability (C=Countable): A set $X$ is C when a bijection exists between the set of natural numbers and the set $X$</p>\n\n<p>Recursive Enumerability (RE= Recursively Enumerable): Say set $S\'$ is a subset of another set $S$. When there exists a turing machine with alphabet $A$ (where $S$ is a subset of $A^*$) which halts if the input to it belongs to the set $S\'$ and does not halt if the input belongs to $S-S\'$ then I say that the set $S\'$ is recursively enumerable (given the fact that inputs comes only from the set $S$ and not from $A^*-S$ hence the latter will not concern us.) I have referred to the book "Elements of the theory of Computation" by Papadimitrou for this definition, though the introduction of an alphabet A is my own addition to make things more firm</p>\n\n<p>Now I will prove 2 statements:</p>\n\n<ol>\n<li>if a set $X$ is RE then it is C</li>\n<li>if a set $X$ is C then it is RE</li>\n</ol>\n\n<p>Hence proving 3. RE iff C </p>\n\n<p>I will prove 2 first.</p>\n\n<p>I can write a Turing Machine $M$ which when asked to check if an element $x$ belongs to $X$ or not will follow the algorithm:</p>\n\n<p>There exists a mapping from the set of natural numbers to $X$ call it $f$. $M$ can search for $x$ (like a linear search algorithm running on $X$) starting from $f(1)$ going to $f(2)$... and it keeps going till it finds $x$. By this method, $M$ terminates iff $x$ belongs to $X$.</p>\n\n<p>The behaviour above proves that $X$ is RE</p>\n\n<p>Now I prove 1- Given a Turing Machine $M$ exists which halts iff $x$ belongs to $X$</p>\n\n<p>I can construct a bijective map from the set of naturals to $X$ as follows: To map $x$ (given it belongs to $X$) , we run it as input against $M$. I take the concatenation of all configurations (Configuration=tape head position+tape content+state) of $M$ which it goes through from the starting of a computation to the end and decode that string as a natural number. It will be unique.</p>\n\n<p>Hence 1. is proven and so is 3.</p>\n\n<p>But then I find certain resources on the internet which tell me that enumerability and recursive enumerability are different things. How is it possible? Furthermore- We know that the power set of a countably infinite set is uncountably infinite. If $X$ was countably infinite, it would be RE (see 2.). Now we know that the subset of a set which is C is also C. Hence all subsets of $X$ would be C hence they would be RE. Now there would be an uncountable number of RE sets. </p>\n\n<p>Now for each RE set, we can write a turing machine (with appropriate halting behaviour) which can be encoded as a natural number implying that the "set of all RE sets" must be C. This contradicts the conclusion of the previous paragraph.</p>\n\n<p>Where exactly am I wrong?\nThankyou in advance!</p>\n', 'ViewCount': '116', 'Title': 'Where am I wrong?: "countability" and "recursive enumerability"', 'LastActivityDate': '2013-06-13T19:55:03.743', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12665', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8657', 'Tags': '<computability><turing-machines><uncountability>', 'CreationDate': '2013-06-13T19:33:00.480', 'Id': '12664'}{'Body': '<p>As I remember:</p>\n\n<ul>\n<li>A decision problem is a problem that has the answer yes or no.</li>\n<li>An algorithm (in the context of automata theory) answers yes or no; it halts on all inputs, accepted or not.</li>\n<li>A TM represents an algorithm. The TM accepts an input string and executes with that input. If the machine ends up in an accept state, the answer is yes, otherwise no.</li>\n</ul>\n\n<p>How does a yes/no problem relate to general algorithms we are doing that have more than yes/no problems? Or is that every problem can be thought as a yes/no problem, i.e. is this a function f produce 5 (or whatever input) with input 2 (or whatever output)?</p>\n', 'ViewCount': '85', 'Title': 'How a TM can represent any algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-23T20:55:36.627', 'LastEditDate': '2013-06-21T06:24:53.090', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '12793', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-06-20T07:57:48.957', 'Id': '12781'}{'Body': '<p>I have to find out whether the language $J_1=\\{0^n1^n0^n \\mid n \\in \\mathbb{N}\\}$ and $J^{c}_{1}$ is recursively enumerable.</p>\n\n<p>I already know that $J_1$ is RE, because I have found Turing machine which accepts $J_1$.\nI would also like to prove this for  $J^{c}_{1}$ by using the following theorem:\n$J\\in RE \\wedge J^{c} \\in RE \\Leftrightarrow J \\in Rec$.</p>\n\n<p>So I have to prove that $J_1 \\in Rec$. I have already tried but I am stuck. Can anybody please help me?</p>\n', 'ViewCount': '79', 'Title': 'Is the language $0^n 1^n 0^n$ recursive?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-22T11:30:44.293', 'LastEditDate': '2013-06-22T11:30:44.293', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8766', 'Tags': '<formal-languages><computability>', 'CreationDate': '2013-06-21T16:27:52.773', 'Id': '12818'}{'Body': '<p>Let there be 2 sets $X$ and $Y$, both are countable (assume the bijection from $\\mathbb{N}$ to the respective sets is computable) and infinite. Let $S$ be the set of all possible functions (NOT necessarily computable, i dont care about computability at this point) from $A$ to $Y$ for all $A \\subset X$ (Remember that $A$ is not fixed here and it varies to cover all subsets of $X$. Note that $X$ and $Y$ are fixed in this question).I understand that $S$ is uncountable (as the number of subsets of $X$ will be uncountable) and hence all functions in it cannot be computable because there are countable number of computable functions. My question is that if there are indeed uncomputable functions in $S$, can somebody please give me an example of one such function or example of a subset of $S$ which contains only uncomputable functions ? </p>\n\n<p>Thankyou! </p>\n', 'ViewCount': '135', 'Title': 'Finding an Uncomputable Function', 'LastEditorUserId': '8912', 'LastActivityDate': '2013-07-01T04:48:35.867', 'LastEditDate': '2013-06-30T14:21:48.663', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '12989', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8912', 'Tags': '<computability>', 'CreationDate': '2013-06-30T09:35:30.530', 'Id': '12985'}{'Body': u'<p>I am reading Kolmogorov Complexity by Li and Vit\xe1nyi:</p>\n\n<p>"Let $x$ be a finite binary string. We write \'$x$ is random\' if the shortest binary description of $x$ with respect to the optimal specification method $D_0$ has length at least $x$."\nBy length $x$ I understand the natural number that the binary string maps to canonically.</p>\n\n<p>[proof which I do not understand follows]</p>\n\n<p>"This shows that although most strings are random, it is impossible to effectively prove them random."</p>\n\n<p>However, I am able to produce a counterexample and can find a proof that $x$ is random effectively (there is an algorithm). Iterate over all the words of size up to $x-1$ of a description language. If you find a description $\\alpha_x$ such that $D_0(\\alpha_x)=x$ ($\\alpha_x$ describes $x$) then terminate with verdict that $x$ is not random. If you exhaust all the words of length $&lt;x$(there are finitely many since $x$ is finite so the program halts) and none of them describes $x$ and then terminate with result that $x$ is random.</p>\n\n<p>What is wrong in my counterexample?</p>\n', 'ViewCount': '88', 'Title': 'Proving a string is random', 'LastEditorUserId': '683', 'LastActivityDate': '2013-07-01T05:05:12.860', 'LastEditDate': '2013-07-01T05:05:12.860', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2598', 'Tags': '<computability><kolmogorov-complexity>', 'CreationDate': '2013-07-01T03:36:35.217', 'Id': '13001'}{'ViewCount': '175', 'Title': 'Why every finite set is computable?', 'LastEditDate': '2013-07-10T08:48:48.523', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2260', 'FavoriteCount': '1', 'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/Recursive_set#Examples" rel="nofollow">wikipedia</a>, every finite set is computable. \nDefinition: set $S \\subset N$ is <em>computable</em> if there exists an algorithm which defines in finite time if a given number $n$ is in Set.</p>\n\n<p>Question: what is wrong with this counter-example:</p>\n\n<ul>\n<li>given some $TM$</li>\n<li>$S \\subset N$</li>\n<li>Lets assume $S$ could contain only $0$, i.e., either $S = \\{0\\}$ or $S = \\emptyset$</li>\n<li>if a given $TM$ halts then $S=\\{0\\}$ otherwise $S=\\emptyset$</li>\n</ul>\n\n<p>So set $S$ is finite, but not computable, since we cannot "compute" if a given $TM$ halts.</p>\n\n<p>What is wrong above?</p>\n', 'Tags': '<computability><turing-machines>', 'LastEditorUserId': '2260', 'LastActivityDate': '2013-07-12T05:55:27.977', 'CommentCount': '5', 'AcceptedAnswerId': '13177', 'CreationDate': '2013-07-09T13:58:30.313', 'Id': '13173'}{'ViewCount': '112', 'Title': "Is there an algorithm which can compute every algorithm's time complexity?", 'LastEditDate': '2013-07-10T08:03:02.860', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8744', 'FavoriteCount': '1', 'Body': "<p>I think of an algorithm which computes the time complexity. It would be great if a code editor could compute the time complexity of the selected lines and even compare two pieces of codes in order to help developer to select one of them. I heard something related with halting problem but couldn't figure out. </p>\n", 'Tags': '<computability><time-complexity>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-10T08:03:02.860', 'CommentCount': '0', 'AcceptedAnswerId': '13197', 'CreationDate': '2013-07-10T07:09:48.463', 'Id': '13196'}{'Body': '<p>In Andrew W. Appel\'s book, <em>Modern Compiler Implementation in ML</em>, he says under chapter 17 that <em>Computability theory shows that it will always be possible to invent new optimizing transformations</em> and proceeds to prove that a <em>fully optimizing compiler</em> will solve the halting problem: A program <em>Q</em> that produces no output and never halts can easily be replaced by its optimal representation, <em>Opt(Q)</em>, being "L: goto L". So a fully optimizing compiler can solve the halting problem.</p>\n\n<p>So my question is this: <strong>Does a fully optimizing compiler exist for terminating programs?</strong> My only thoughts are the following: Even though a program is guaranteed to terminate, it can still be arbitrarily complex, and for any concrete optimizing compiler, C, one could perhaps construct a program that takes C as input and somehow produces a worse program as some kind of corner case.</p>\n\n<p>Also, <strong>What are the implications of restricting ourselves to terminating programs?</strong></p>\n', 'ViewCount': '185', 'Title': 'Do fully optimizing compilers for terminating programs exist?', 'LastEditorUserId': '9213', 'LastActivityDate': '2013-07-18T16:25:27.483', 'LastEditDate': '2013-07-18T16:25:27.483', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13315', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '9213', 'Tags': '<computability><compilers><program-optimization>', 'CreationDate': '2013-07-17T12:14:57.423', 'Id': '13313'}{'Body': '<p>I have an assignment to do and I\'m quite stuck with the following question :</p>\n\n<blockquote>\n  <p>Use Rice\'s theorem to show that </p>\n  \n  <p>$ \\qquad L\' = \\{ \\langle M \\rangle \\mid \\; (\\exists \\text{ TM } M\') \\; [ L(M\') = L(M) \\text{ and } M\' \\text{ has less than 29 states} ] \\}$ </p>\n  \n  <p>is undecidable.</p>\n</blockquote>\n\n<p>I have absolutely no idea how to proceed.</p>\n\n<p>Would someone be kind enough to, at least, give me some clues?</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>First, I wrote the question wrong. It is now \'$M\'$ has less than 29 states\' (not \'steps\')."</p>\n\n<p>Here\'s what I\'m thinking after more reading and consulting other students at school.</p>\n\n<p>Rice\'s theorem :</p>\n\n<blockquote>\n  <p>$L = \\{ \\langle M \\rangle \\mid L(M) \\text{ has some property } P \\}$ where :</p>\n  \n  <ol>\n  <li><p>$P$ is non-trivial, i.e. there exists at least one machine $M_1$ such that $\\langle M_1 \\rangle \\in L$, and at least one machine $M_2$ such that $\\langle M_2 \\rangle \\not \\in L$.</p></li>\n  <li><p>$P$ is indeed a property of the language of TMs, i.e. whenever $L(M_a) = L(M_b)$, we have $\\langle M_a \\rangle \\in L$ if and only if $\\langle M_b \\rangle \\in L$.</p></li>\n  </ol>\n  \n  <p>Then, $L$ is undecidable.</p>\n</blockquote>\n\n<p>So here, the property is "$M\'$ has less than 29 states".</p>\n\n<p>We can show that this property is non-trivial.</p>\n\n<p>Let\'s take the language "abcdefghijklmnopqrstuvwxyz0123456789" (only one string is accepted). We can build a TM $M$ this way :</p>\n\n<p>-> Enter in state $q_0$</p>\n\n<p>-> In $q_0$ : if you read "a", proceed to $q_a$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>-> In $q_a$ : if you read "b", proceed to $q_{ab}$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>$\\vdots$</p>\n\n<p>-> In $q_{abcdefghijklmnopqrstuvwxyz012345678}$ : if you read "9" go to $q_{accept}$, otherwise go to $q_{reject}$ and halt.</p>\n\n<p>So here we got 3 "basic states" : $q_0$, $q_{reject}$ and $q_{accept}$ and we have $|abcdefghijklmnopqrstuvwxyz0123456789| - 1$ states (there is no $q_{abcdefghijklmnopqrstuvwxyz0123456789}$ because when we read "9" at the end, we go to $q_{accept}$). So that\'s 26 + 10 - 1 = 35 states. We have a total of 35 + 3 = 38 states.</p>\n\n<p>Unless I am wrong, there can\'t be a TM $M\'$ that can test wether a string $w$ belongs to that language without having <em>at least</em> 38 states !</p>\n\n<p>So the property "$M\'$ has less than 29 steps" is non-trivial as there is at least one TM that respects it, and at least one that does not.</p>\n\n<p>Now, $P$ is indeed a property of the language of TMs, because any two machines $M_1$ and $M_2$ such that $L(M_1) = L(M_2)$ implies :</p>\n\n<p>$\\langle M_1 \\rangle  \\in L\' \\Leftrightarrow L(M_1) = L(M_2) \\Leftrightarrow \\langle M_2 \\rangle \\in L\'$.</p>\n\n<p>(I know there is at least one missing clause in there, but I can\'t figure how to write it, it\'s got something to do with that "$M\'$ has less than 29 steps")</p>\n\n<p>So, according to Rice\'s theorem, $L\'$ is undecidable.</p>\n', 'ViewCount': '352', 'Title': "Use Rice's theorem to show that the language of optimisable Turing machines is undecidable", 'LastEditorUserId': '8737', 'LastActivityDate': '2013-07-30T22:50:11.450', 'LastEditDate': '2013-07-30T22:50:11.450', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8737', 'Tags': '<computability><proof-techniques><undecidability>', 'CreationDate': '2013-07-29T06:12:15.467', 'Id': '13485'}{'Body': '<p>Im sorry if this question has some trivial answer which I am missing. Whenever I study some problem which has been proven undecidable, I observe that the proof relies on a reduction to another problem which has been proven to be undecidable. I understand that it creates some kind of an order on the degree of difficulty of a problem. But my question is - has it been proven that all problems which are undecidable can be reduced to another problem which is undecidable. Is it not possible that there exists a undecidable problem which can proved to have no reduction to any other undecidable problem (Hence to prove the undecidability of such a problem, one cannot use reductions). If we use reductions to create an order on the degree of computability then this problem cannot be assigned such a degree. </p>\n', 'ViewCount': '174', 'Title': 'Reductions among Undecidable Problems', 'LastActivityDate': '2013-08-01T13:30:51.810', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13564', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '8912', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-08-01T07:07:54.960', 'Id': '13559'}{'Body': '<p>Are there classes of problems that cannot be solved by an oracle machine? If so, are there specific problem examples of that class of problems?</p>\n\n<p>Even the Omega number, at least the first N digits, could be computed as the Oracle could just return TRUE or FALSE for each {0,1}-digits... </p>\n', 'ViewCount': '35', 'ClosedDate': '2013-08-04T23:28:03.570', 'Title': 'Problems unsolvable by an oracle machine?', 'LastActivityDate': '2013-08-04T21:59:11.873', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'OwnerDisplayName': 'Phil', 'PostTypeId': '1', 'Tags': '<complexity-classes><computability>', 'CreationDate': '2013-08-04T13:09:27.020', 'FavoriteCount': '0', 'Id': '13601'}{'Body': '<p>I need help to understand Chaitin\'s elegant program proof. An elegant program is the shortest program that produces a given output.</p>\n\n<p>Here is the proof:</p>\n\n<blockquote>\n  <p>Construct a program $B$ that takes as input a number $N$ and enumerates all possible programs $P_k$ longer than $N$. $B$ runs the elegance tester $\\mathrm{ET}$ on each enumerated program $P_k$ in turn until it finds some $P_k$ which $\\mathrm{ET}$ claims is elegant. $B$ then runs that $P_k$, thus producing the same output as that $P_k$.</p>\n  \n  <p><strong>Lemma:</strong> B must produce some output.</p>\n  \n  <p><strong>Proof:</strong> There are an infinite number of elegant programs, as noted earlier. So if $\\mathrm{ET}$ works as assumed, $B$ must eventually find one of those elegant programs whereupon it will produce that program\'s output.\n  Now run $B$ with $N$ set to $|B| + 1$ (See note 1). (This is the "threshold size" mentioned in the theorem.) $B$ now will produce the same output as some program $P_k$ which $\\mathrm{ET}$ claimed was elegant. But $P_k$ is longer than $B$, so $P_k$ cannot be elegant because $B$, which is shorter, produced the same output. Therefore, $\\mathrm{ET}$ was wrong when it claimed $P_k$ was elegant. QED.</p>\n</blockquote>\n\n<p>My question is: The proof begins with a program $B$ that is a program "that takes as input a number $N$ and enumerates all possible programs $P_k$ longer than $N$" But because of the halting problem such a program is not possible, so the proof starts dead? There is something I\'m not understanding here.</p>\n', 'ViewCount': '91', 'Title': "Chaitin's elegant programs", 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-13T10:15:58.190', 'LastEditDate': '2013-08-13T08:44:01.653', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9631', 'Tags': '<computability><program-optimization>', 'CreationDate': '2013-08-13T07:22:40.833', 'Id': '13728'}{'Body': '<p>The proof of the undecidability of $A_{TM}$ in Michael Sipser\'s textbook<code>*</code> contains the definition of a Turing Machine, which accepts the encoding of a TM, if this TM doesn\'t accept its own encoding, and rejects it, if it does. If this TM is run on its own encoding, there is problem: it should accept if it doesn\'t accept and vice versa.</p>\n\n<p>My problem with this proof is that it strongly resembles <a href="http://en.wikipedia.org/wiki/Russell%27s_paradox" rel="nofollow">Russel\'s paradox</a>. This paradox arises if we define a set, which contains all sets that are not members of themselves. If we ask whether this set contains itself, there is problem: it should contain itself if it doesn\'t contain itself and vice versa. </p>\n\n<p>Russels\'s paradox has been eliminated from axiomatic set theory: in <a href="http://en.wikipedia.org/wiki/ZFC" rel="nofollow">ZFC</a>, it follows from the axioms that such a property doesn\'t define a valid set. Interestingly enough, in the theory of computation, a similar property defines a valid TM. </p>\n\n<p>That\'s why I don\'t like the proof in Sipser\'s book. I\'d like to emphasize that I know that this proof is perfectly valid, but I\'d like to know if there is another proof which follows a different chain of thought, and doesn\'t define such a TM.</p>\n\n<hr>\n\n<p><code>*</code>Sipser, M.: Introduction to the Theory of Computation (2nd ed.), 2006, page 179. On this page, Sipser uses the term <em>halting problem</em> for the language $A_{TM}$. The proper name for this language is <em>acceptance problem</em>, see the footnote on page 188.</p>\n', 'ViewCount': '101', 'Title': 'Alternative proof for the undecidability of $A_{TM}$', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-16T11:23:01.367', 'LastEditDate': '2013-08-16T11:23:01.367', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '13770', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<terminology><computability><turing-machines><halting-problem>', 'CreationDate': '2013-08-15T21:00:43.357', 'Id': '13766'}{'Body': '<p>It\'s known that the following language, the so-called acceptance problem is undecidable:</p>\n\n<p>$A_{TM} = \\{\\langle M,w\\rangle\\,\\vert\\,M\\text{ is a TM which accepts }w\\}$</p>\n\n<p>The proof is by contradiction: Assume there is a TM $H$ which decides $A_{TM}$. Let $D$ be another TM. Given the code of a TM $M$, $\\langle M\\rangle$ as input, $D$ simulates $H$ on $\\langle M,\\langle M\\rangle\\rangle$, and accepts, if $H$ rejects this input and rejects, if $H$ accepts it. That is, $D$ accepts $\\langle M\\rangle$ if $M$ rejects its own code, and vice versa. Running $D$ on its own code, $\\langle D\\rangle$, leads to contradiction.</p>\n\n<hr>\n\n<p>Let\'s restrict $A_{TM}$ by excluding all input strings which encode a TM:</p>\n\n<p>$E = \\{w\\,\\vert\\,w\\text{ is a structurally valid encoding of a TM}\\}$\n $A\'_{TM} = \\{\\langle M,w\\rangle\\,\\vert\\,M\\text{ is a TM which accepts }w\\text{ and }w\\not\\in E\\}$</p>\n\n<p>I\'d like to know whether $A\'_{TM}$ is also undecidable. </p>\n\n<p>I tried to prove it the above way: Assume there is a TM $H\'$ which decides $A\'_{TM}$. Let $D\'$ be another TM. Given the code of a TM $M$, $\\langle M\\rangle$ as input, $D\'$ simulates $H\'$ on $\\langle M,\\langle M\\rangle\\rangle$, and accepts, if $H\'$ rejects this input and rejects, if $H\'$ accepts it. The problem is that running $D\'$ on its own code, $\\langle D\'\\rangle$, doesn\'t necessarily lead to contradiction. I mean since $\\langle D\',\\langle D\'\\rangle\\rangle$ is not a member of $A\'_{TM}$, we don\'t know what $H\'$ will do with it.</p>\n\n<hr>\n\n<p><strong>Note: An encoding of TMs, and TMs along with an input string</strong></p>\n\n<p>Let $M = (Q, \\Sigma, \\Gamma, \\delta, q_{i}, q_{a}, q_{r})$ be a TM, where </p>\n\n<ul>\n<li>$Q$ is the set of states, </li>\n<li>$\\Sigma = \\{0, 1\\}$ is the input alphabet, </li>\n<li>$\\Gamma$ is the tape alphabet ($\\Sigma\\subset\\Gamma$), </li>\n<li>$\\delta: (Q-\\{q_a, q_r\\})\\times\\Gamma\\rightarrow Q\\times\\Gamma\\times\\{L,R,S\\}$ is the transition function,</li>\n<li>$L$, $R$ and $S$ denote the respective head movements, "left", "right" and "stay", and</li>\n<li>$q_i$, $q_a$ and $q_r$ are the initial, accepting and rejecting state, respectively. </li>\n</ul>\n\n<p>Let\'s assign a unique positive integer to each element of $Q$, and do the same in case of $\\Sigma$, $\\Gamma$ and $\\{L,R,S\\}$. Now every transition rule $\\delta(p, a) = (q, b, m)$ can be encoded as $\\langle p\\rangle 1\\langle a\\rangle 1\\langle q\\rangle 1\\langle b\\rangle 1 \\langle m\\rangle$, where $\\langle x\\rangle$ denotes a sequence of $0$\'s, with length being equal to the positive integer assigned to $x$. The encoding of $M$, denoted by $\\langle M\\rangle$, can be created by concatenating its transition rules, separated by $11$\'s. The combined encoding of $M$, and an input string, $w\\in\\Sigma^*$, denoted by $\\langle M,w\\rangle$ is $\\langle M\\rangle111w$.</p>\n', 'ViewCount': '111', 'Title': 'Undecidability of a restricted version of the acceptance problem', 'LastEditorUserId': '9571', 'LastActivityDate': '2013-08-16T16:02:40.407', 'LastEditDate': '2013-08-16T14:04:03.693', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13776', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-08-16T08:47:47.587', 'Id': '13771'}{'Body': '<p><a href="http://en.wikipedia.org/wiki/Tag_system" rel="nofollow">Tag systems</a> are Turing-complete. I was wondering if there is any easy way to create tag systems that simulate finite automata. So create tag systems that recognize languages, e.g. by having at the end just one output symbol "A" for accepting the initial input or "R" for rejecting it.</p>\n\n<p>I guess a solution would be to make a Tag system simulate a specific Turing machine that simulates a finite automaton but that seems too much and too complicated. Is there perhaps a direct way from tag systems to finite automata?</p>\n', 'ViewCount': '67', 'Title': 'Make a tag system simulate a finite automaton?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-22T14:35:42.117', 'LastEditDate': '2013-08-22T14:35:42.117', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '927', 'Tags': '<computability><finite-automata><simulation><computation-models><turing-completeness>', 'CreationDate': '2013-08-19T03:42:11.630', 'FavoriteCount': '1', 'Id': '13808'}{'Body': "<p>Given this question:</p>\n\n<blockquote>\n  <p>$L$ is an infinite language of encoded Turing machines who always halt.</p>\n  \n  <ol>\n  <li>$L$ might be decidable </li>\n  <li>$L$ might be in RE but not in R</li>\n  <li>both 1. and 2. are correct</li>\n  </ol>\n</blockquote>\n\n<p>I know the solution to this question is 3., but I seem to lack the understanding on how am I suppose to get to that solution. Could you explain how should I approach this kind of questions? Am I supposed to start drawing TMs?\nWhy is the answer is C? What's the indication of that?</p>\n\n<p>It would help me a lot if you could explain to me your thought process when facing this kind of problem.</p>\n", 'ViewCount': '67', 'Title': 'Classifying infinite languages of encodings of halting Turing machines', 'LastEditorUserId': '9844', 'LastActivityDate': '2013-08-26T17:52:28.617', 'LastEditDate': '2013-08-26T15:47:34.610', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '13945', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9844', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-08-26T15:15:31.767', 'Id': '13943'}{'Body': "<p>I get that R is a set of languages that are decidable by a Turing Machines</p>\n\n<p>And that RE is a set of languages that a each language can be recognized by a TM, that is the machine will halt when given a word from that language and loop otherwise.</p>\n\n<p>But I can't wrap my head around co-RE.  Is there a good way to describe it? A good example to convey what it really means?</p>\n", 'ViewCount': '269', 'Title': 'Good way to describe co-RE (co-recursively enumerable)?', 'LastEditorUserId': '755', 'LastActivityDate': '2013-08-27T05:33:05.260', 'LastEditDate': '2013-08-26T18:23:13.443', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '13950', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9844', 'Tags': '<terminology><computability>', 'CreationDate': '2013-08-26T17:34:07.933', 'Id': '13947'}{'Body': "<p>If you could include your thought process in determining why it's regular it would help me a lot.</p>\n\n<ul>\n<li><p>$L_1 = (0^*(10)^*11)$</p></li>\n<li><p>$L_2 = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing machine that halts on all inputs from }L_1 \\}$</p></li>\n<li><p>$L_3 = \\{ x \\in \\{0,1\\}^* \\mid \\exists y \\in L_2. xy \\in L_1 \\}$</p></li>\n</ul>\n\n<p>Why is $L_3$ regular? It's a set of strings, I need to determine if there's a DFA that can accept it. Do I even care about $L_2$ and $L_1$ in this case?</p>\n", 'ViewCount': '99', 'Title': 'Why is this language regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T11:33:04.927', 'LastEditDate': '2013-08-27T11:19:56.530', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '13971', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9844', 'Tags': '<formal-languages><computability><regular-languages>', 'CreationDate': '2013-08-27T08:42:44.590', 'Id': '13960'}{'Body': '<p>I formulate the question in terms of universal distributions. Fix a version of Solomonoff\'s universal distribution $\\mathbf M$ and consider the following procedure for generating an infinite binary sequence $\\omega$. </p>\n\n<p>Start with some $\\omega_0$. Each subsequent element is given by $\\omega_n=\\arg \\max_a\\mathbf M(a|\\omega_{1:n-1})$.</p>\n\n<p>What are the properties of $\\omega$? For example, is it necessarily computable? Does the answer depend on the choice of $\\mathbf M$?</p>\n\n<p>The equivalent formulation is the following but it does not really help me advance with the problem. </p>\n\n<p>Is there a universal lower semicomputable $\\lambda$-supermartingale $t$ and a binary sequence $\\tilde\\omega$ such that $t$ always "goes up" along $\\tilde\\omega$ but never succeeds?</p>\n\n<p>This type of problem arises when a player plays against a reactive environment and the sequence the player observes is not exogenous. A more general question is what is the short-run behavior of $\\mathbf M$ since asymptotic results do not seem to help here.</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>As an example, consider a simple coordination game with payoff matrix:</p>\n\n<p>(1,1)     (0,0)</p>\n\n<p>(0,0)     (1,1)</p>\n\n<p>Consider two players who infinitely repeatedly play this game. Their goal is to maximize the payoff. Assume that the player are myopic that is they care only about the payoff in the current period. </p>\n\n<p>Each player observes his opponent\'s history and tries to match him. Each player has a prior distribution about his opponent\'s play and updates it using Bayes\'s rule. </p>\n\n<p>Now assume that the prior distribution is Solomonoff\'s $\\mathbf M$. Then every period a player chooses an action $\\arg \\max_a\\mathbf M(a|\\omega_{1:n-1})$ where $\\omega_{1:n-1}$ is the opponent\'s history. The other player does the same, thus the rule $\\omega_n=\\arg \\max_a\\mathbf M(a|\\omega_{1:n-1})$.</p>\n', 'ViewCount': '67', 'Title': 'The sequence in which every symbol minimizes conditional complexity?', 'LastEditorUserId': '9931', 'LastActivityDate': '2013-09-02T15:46:46.007', 'LastEditDate': '2013-09-02T15:46:46.007', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9931', 'Tags': '<computability><randomness>', 'CreationDate': '2013-09-01T20:30:50.230', 'Id': '14073'}{'Body': '<p>I know that in an infinite language there are infinite number of strings.  I want to know what type of the languages are C, C++ and JAVA? I can have infinite number of variables in all these languages, so I think all these languages are infinite. Please correct me if I am wrong.     </p>\n', 'ViewCount': '177', 'Title': 'How do I find if a programming language is infinite or finite?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-03T10:03:15.900', 'LastEditDate': '2013-09-03T06:50:25.873', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<formal-languages><computability>', 'CreationDate': '2013-09-02T13:18:59.083', 'Id': '14084'}{'Body': '<p>Let $B$ be a recursive enumerable set and $B = W_n$, where $W_n = \\{x \\in \\mathbb N \\mid \\Phi(x,n)\\downarrow\\}$ and $\\Phi^{(n)}(x_1, \\ldots, x_n, y)$ is the value of the function at the terminal snaphot.</p>\n\n<p>There is a definition that leaves me really confused:\n$$n \\in W_n \\Leftrightarrow \\Phi(n,n)\\downarrow \\Leftrightarrow \\text{HALT}(n,n)$$ </p>\n\n<p>the thing is we know that $\\text{HALT}$ is not computable, therefore is is <em>undefined</em> so how is it possible that it is equivalent to $\\Phi(n,n)\\downarrow$ which is actually a defined function? What am I missing here?</p>\n', 'ViewCount': '52', 'Title': 'Confusing equivalence $\\Phi(n,n)\\downarrow \\Leftrightarrow \\text{HALT}(n,n)$', 'LastActivityDate': '2013-09-04T11:52:38.303', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14126', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><halting-problem>', 'CreationDate': '2013-09-04T11:38:00.880', 'Id': '14125'}{'Body': '<p>Let $B = \\{z \\mid (\\exists x)\\; P(x,z)\\}$ and $P$ be a computable predicate. Show $B$ is a recursive enumerable set.</p>\n\n<p><strong>My attempt</strong></p>\n\n<p>As $P$ is a computable predicate then there is a program that computes it, therefore $B= \\{z \\mid (\\exists x)(\\exists t)\\;\\text{STP}^{(1)}(x,z,t)\\} \\Rightarrow B= \\{z \\mid \\Phi(x)\\downarrow\\} = W_z$ and so $B$ is a recursive enumerable set.</p>\n\n<p><strong>Further info</strong></p>\n\n<p>$\\text{STP}^{(n)} (x_1, \\ldots, x_n, y,t)$ is a predicate that is true if the program number $y$ halts after $t$ or fewer steps on inputs $x_1, \\ldots, x_n$.</p>\n\n<p><em>Note: please note this is the first time I ever try to solve this kind of exercises, so even if I got everything wrong and nothing makes sense, every nudge in the right direction is really welcome.</em></p>\n', 'ViewCount': '71', 'Title': 'Show $B= \\{z \\mid (\\exists x)\\; P(x,z)\\}$ is a recursive enumerable set', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-05T14:07:40.023', 'LastEditDate': '2013-09-05T14:07:40.023', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><check-my-proof><enumeration>', 'CreationDate': '2013-09-04T14:21:03.683', 'Id': '14129'}{'ViewCount': '202', 'Title': 'Machines in P undecidable?', 'LastEditDate': '2013-09-09T10:30:31.167', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9515', 'FavoriteCount': '1', 'Body': "<p>Given a Turing machine $M$, we say that $L(M) \\in P$ if the language decided by the machine can be decided by some machine in polynomial time. We say that $M \\in P$ if the machine runs in polynomial time. Note that there can be machines that run needlessly long but still decide a language in $P$. By Rice's theorem, we know that</p>\n\n<p>$\\{ \\langle M \\rangle \\mid M \\mbox{ is a Turing machine such that }L(M) \\in P \\mbox{ } \\}$ is undecidable. Is it known whether:</p>\n\n<p>$\\{ \\langle M \\rangle \\mid M \\mbox{ is a Turing machine such that }M \\in P \\mbox{ } \\}$ is also undecidable?</p>\n", 'Tags': '<computability><time-complexity><turing-machines>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-09T10:30:31.167', 'CommentCount': '4', 'AcceptedAnswerId': '14216', 'CreationDate': '2013-09-08T17:55:31.410', 'Id': '14215'}{'Body': "<p>A type-0 grammar generates a recursively enumerable (RE) language. </p>\n\n<p>A RE language is also known as a semi-decidable language. </p>\n\n<p>A semi-decidable language is a particular kind of undecidable language: If a language is semi-decidable, we can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely. </p>\n\n<p>Problem: Provide an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>Answer (I think): The following grammar generates this language: </p>\n\n<pre><code>(a+b+) union (infinite a's)\n</code></pre>\n\n<p>Here is the grammar:</p>\n\n<pre>\nS &rarr; aA | bE\nA &rarr; aA | bB\nB &rarr; bB | &epsilon; | aE\nbE &rarr; aE \nE &rarr; aE\n</pre>\n\n<p>A method for recognizing strings in the language generated by this grammar would return true for strings that are an element of a+b+ and would run indefinitely for strings that are not an element of a+b+</p>\n\n<p>I think that this is an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>If I am incorrect, would you provide an example please?</p>\n", 'ViewCount': '73', 'Title': 'Is this an example of a type-0 grammar that is not context-sensitive?', 'LastActivityDate': '2013-09-21T20:01:25.747', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><formal-grammars><undecidability><linear-bounded-automata>', 'CreationDate': '2013-09-21T20:01:25.747', 'FavoriteCount': '1', 'Id': '14503'}{'Body': '<p>I was looking at this: <a href="http://www.cs.odu.edu/~toida/nerzic/390teched/tm/othertms.html" rel="nofollow">http://www.cs.odu.edu/~toida/nerzic/390teched/tm/othertms.html</a></p>\n\n<p>At the very beginning, they show a 2d tape and (I assume) it\'s 1d equivalent. However, I cannot figure out they got from the 2d case to the 1d case. I was hoping someone could elaborate.</p>\n', 'ViewCount': '315', 'Title': 'Two Dimensional Tape of Turing Machine', 'LastActivityDate': '2013-09-26T17:07:19.787', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<computability><turing-machines><simulation>', 'CreationDate': '2013-09-26T16:50:20.973', 'Id': '14628'}{'Body': '<p>I have seen web sites that purport to "prove" that HTML5+CSS is Turing Complete.</p>\n\n<p>I have seen web sites that purport to "prove" that SQL is Turing Complete.</p>\n\n<p>I have seen a bunch of web sites that purport to "explain" what it means to be Turing Complete.</p>\n\n<p>Enough!</p>\n\n<p>Where can I find a book (written by an expert in computability theory) or a peer-reviewed article (in a reputable journal) that shows a proof of, "This language XYZ is capable of describing a computational machine which has the same computational power as a Turing Machine"?</p>\n', 'ViewCount': '315', 'Title': 'Clear, complete, proof that a language is Turing Compete?', 'LastActivityDate': '2013-09-30T17:12:59.010', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><automata><turing-completeness><church-turing-thesis>', 'CreationDate': '2013-09-30T11:35:37.607', 'FavoriteCount': '1', 'Id': '14697'}{'Body': u'<p><a href="http://en.wikipedia.org/wiki/Structured_program_theorem" rel="nofollow">Wikipedia</a>:</p>\n\n<blockquote>\n  <p>The structured program theorem [...] states that [...] any algorithm\n  can be expressed using only three control structures. They are</p>\n  \n  <ul>\n  <li>Executing one subprogram, and then another subprogram (sequence)</li>\n  <li>Executing one of two subprograms according to the value of a boolean expression (selection)</li>\n  <li>Executing a subprogram until a boolean expression is true (iteration)</li>\n  </ul>\n</blockquote>\n\n<p>This theorem is developed in the following papers:</p>\n\n<ul>\n<li>C. B\xf6hm, "On a family of Turing machines and the related programming language", ICC Bull., 3, 185\u2013194, July 1964. </li>\n<li>C. B\xf6hm, G. Jacopini, "Flow diagrams, Turing Machines and Languages with only Two Formation Rules", Comm. of the ACM, 9(5): 366\u2013371,1966.</li>\n</ul>\n\n<p>Unfortunately, the first one is practically unavailable, and the second one, in addition to being a bit cryptic (at least for me), refers to the first, so I have problems to understand the proof. Can anyone help me? Is there a modern paper or book which presents the proof? Thanks.</p>\n\n<hr>\n\n<p><strong>UPDATE</strong> </p>\n\n<p>To be exact, I would like to understand the <em>second part of the CACM paper</em> (section 3). The authors write in section 1 the following:</p>\n\n<blockquote>\n  <p>In the second part of the paper (by C. B\xf6hm), some results of a\n  previous paper are reported [8] and the results of the first part of\n  this paper are then used to prove that every Turing machine is\n  reducible into, or in a determined sense is equivalent to, a program\n  written in a language which admits as formation rules only composition\n  and iteration.</p>\n</blockquote>\n\n<p>Here [8] refers to the unavailable ICC Bulletin paper. It is easy to see that the above quote from Wikipedia refers to this second part of the CACM paper (the Turing machine serves as a precise definition of algorithms; "composition" means sequence; an iteration can replace a selection).</p>\n', 'ViewCount': '198', 'Title': 'How to prove the structured program theorem?', 'LastEditorUserId': '9571', 'LastActivityDate': '2013-10-11T18:34:04.180', 'LastEditDate': '2013-10-10T19:44:45.940', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '14988', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9571', 'Tags': '<computability><programming-languages><computation-models>', 'CreationDate': '2013-10-10T11:42:54.877', 'Id': '14983'}{'Body': '<p>Let $PAL = \\{ww^R\\ | w\\in\\{0,1\\}^*\\}$. </p>\n\n<p>Then let $A = \\{\\langle M\\rangle \\ | \\textit{M is a Turing Machine and } L(M)\\subseteq PAL\\}$</p>\n\n<p>Is A semi-decidable (Turing recognizable or recursively enumerable)?</p>\n\n<p>My try!</p>\n\n<p>I said it is so here is my proof, tell me if I am way off base or tell me if A ought not to semi-decidable in the first place.</p>\n\n<p>$\\underline{Proof}$</p>\n\n<p>A is semi-decidable by The Certificate Theorem, which states that:</p>\n\n<p>If $A\\subseteq\\Sigma^*$ then $A\\in SD$(semi-decidable) iff there is some decidable relation, $R\\subseteq \\Sigma^* \\times \\Sigma^*$, such that $\\forall x\\in\\Sigma^*$, $x\\in{A}$ iff $\\exists y$ such that $R(x,y)$ holds.</p>\n\n<p>We know that if $x\\in{A}$ that means that $x=\\langle M\\rangle$, so we can choose $y = \\langle M,w\\rangle$ where $w\\in{PAL}$. What we know is that when $M$ takes $w$ as an input it will accept (since we choose $w$ as an input), if that is the case then $w\\in{L(M)}\\subseteq{PAL}$. That means that $A\\in{SD}$. QED</p>\n\n<p>Any help would be greatly appreciated, have a great day!</p>\n', 'ViewCount': '191', 'Title': 'Is the language that consists of machine configurations whose language is a subset of even palindromes semi-decidable?', 'LastActivityDate': '2013-10-21T06:15:55.890', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-10-20T19:26:57.903', 'Id': '16264'}{'Body': "<p>I have this question I'm struggling with. </p>\n\n<p>Let $A=\\{&lt;i,n&gt;|\\;n \\in \\phi ^{(i)}\\}$. In other words, $A$ is the language defined by the set of all pairs $&lt;i,n&gt;$ such that $n$ is $\\leq_m$ to the $i$th Turing jump.\nA is definitely not an arithmetically definable language, and you can prove this by contradiction. </p>\n\n<p>I have to find a language, let's say $B$, that is more complex than $A$ $i.e.$ $B\\nleq_T A$. I thought about $B=\\{&lt;i,n&gt;|\\;n \\not\\in \\phi ^{(i)}\\}$, but I'm not sure about my reasoning, I think an oracle turing machine with an oracle $A$ couldn't reduce to $B$..</p>\n\n<p>And one last thing, do you think there exists a language that is more complex than any other (it doesn't reduce to anything)?</p>\n\n<p>If you have any hints that could help me solve those two questions I would be really grateful! </p>\n", 'ViewCount': '62', 'Title': 'What would be a not arithmetically definable language that is not Turing reducible to another given not arithmetically definable language?', 'LastActivityDate': '2013-10-24T16:13:26.107', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '16405', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<complexity-theory><computability><reductions><arithmetic>', 'CreationDate': '2013-10-21T00:29:52.033', 'Id': '16271'}{'Body': '<p>Given two ordered sets of words $a_1, a_2, ..., a_k$, $b_1, b_2, ..., b_k$ taking values in some discrete alphabet $A$, a solution to the PCP problem is a sequence $i_1, ..., i_n$ taking values in $1, 2,..., k$ such that $a_{i_1}|a_{i_2}|...|a_{i_n}=b_{i_1}|b_{i_2}|...|b_{i_n}$ where $|$ means concatenation. $k$ can be called the length of the problem, $n$ the length of the solution and if we let $w$ be the length of the largest word in $a_1, a_2, ..., a_k, b_1, b_2, ..., b_k$, $w$ is called the width of the problem.</p>\n\n<p>I know that the PCP problem becomes decidable in several scenarios, for instance: for bounded $n$, or if $A$ is unary, etc. On the other hand for $k\\geq7$ PCP is still undecidable. My question is, is there any result known for bounded values of $w$? </p>\n', 'ViewCount': '43', 'Title': 'Undecidability of the PCP problem with bounded width', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:09:30.400', 'LastEditDate': '2013-11-13T22:09:30.400', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '16358', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10931', 'Tags': '<computability><reference-request><undecidability><decision-problem>', 'CreationDate': '2013-10-23T09:27:07.050', 'Id': '16357'}{'Body': "<p>Let $C$ be an infinite set of characters.  I'd like an abstract machine which can recognize sequences consisting of $k$ (constant) of repetitions of a char from $C$.</p>\n\n<p>For example, if ${x,y,z} \\subset C$, and $k = 3$, it should recognize $xxx$ but not $ddd$ or $xyz$.  (The same char must be repeated.)</p>\n\n<p>Since $C$ is infinite, a finite state machine <em>cannot</em> recognize this.  A Turing machine trivially can.  But we don't anything like the power of a Turing machine; simply extending the FSM with a single register that points to a member of $C$ is enough.</p>\n\n<p>My question is: What's the simplest formal abstract machine that is powerful enough to recognize this? Is there a standard extension to FSM's that enables them to recognize this? If I have more complicated versions of this machine (e.g. <em>Move from state 2 to state 3 if you encounter a $k$ repetition of a $C$ char</em>), what's the best way to express them?</p>\n", 'ViewCount': '108', 'Title': 'Abstract machine that can recognize repetition', 'LastActivityDate': '2013-12-22T22:31:30.443', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10925', 'Tags': '<formal-languages><computability><turing-machines><automata><finite-automata>', 'CreationDate': '2013-10-23T13:09:59.097', 'Id': '16362'}{'Body': '<p>In Theoretical Computer Science, which one is more important? Computability of a problem or Complexity of a problem?</p>\n', 'ViewCount': '72', 'ClosedDate': '2013-10-27T15:58:25.267', 'Title': 'Computability vs Complexity?', 'LastActivityDate': '2013-10-27T14:05:27.103', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '16471', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10700', 'Tags': '<algorithms><complexity-theory><computability>', 'CreationDate': '2013-10-27T10:35:47.770', 'Id': '16466'}{'Body': "<p>I am stuck and having a hard time with this question. I want to construct a CFG for the language $$L = \\{{a^lb^mc^n | l,m\\in N, n=|l-m|\\}}$$\nI know that the language consists of strings where:\n<br>1. number of a's = number of b's, so c=0\n<br>2. number of a's more than number of b's, c=l-m\n<br>3. number of a's less than number of b's, c=-(l-m)\n<br>\nI started with\n$$S-&gt;ab$$\n$$S-&gt;aSb$$\nThis generates all of case one, where number of a's = number of b's and c=0. I know that I could increment a's and c's by having aSc but I cant put that in the second line because it could generate a(aSc)b which is not in the language. </p>\n", 'ViewCount': '288', 'ClosedDate': '2013-11-03T22:53:27.903', 'Title': 'Constructing Context Free Grammar', 'LastActivityDate': '2013-11-03T20:53:04.023', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16679', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><computability><context-free>', 'CreationDate': '2013-11-03T19:19:09.937', 'Id': '16678'}{'Body': "<p>I can't figure out a proof that recursive languages are closed under concatenation. I know this is easy for most of the people but unfortunately my professor is not very good at explaining the material. If anybody can provide any hints on how to do it I would greatly appreciate it.</p>\n", 'ViewCount': '106', 'Title': 'Proof that recursive languages are closed under concatenation', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-19T21:27:20.623', 'LastEditDate': '2014-04-19T21:27:20.623', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<formal-languages><computability><closure-properties>', 'CreationDate': '2013-11-03T22:38:03.393', 'Id': '16680'}{'Body': '<p>They have finite resources so they can be modeled by finite number of state what is the same that a finite state machine. There are any proof that it is not true?</p>\n\n<p>Thanks.</p>\n', 'ViewCount': '113', 'ClosedDate': '2013-11-05T13:05:35.547', 'Title': 'Are real computers finite state machines?', 'LastActivityDate': '2013-11-05T12:39:29.787', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '16734', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11196', 'Tags': '<computability><finite-automata>', 'CreationDate': '2013-11-05T08:33:46.060', 'Id': '16729'}{'Body': '<p>Let $P$ be the predicate on natural numbers defined by $P(x) \\iff \\varphi_x(x) = 1$ where $\\varphi_x$ is the $x$-th computable function. Show that $P$ is not computable.</p>\n', 'ViewCount': '58', 'ClosedDate': '2013-11-08T11:47:36.413', 'Title': 'Computability of the function $P(x)=\\varphi_x(x)$', 'LastEditorUserId': '6890', 'LastActivityDate': '2013-11-06T16:56:18.623', 'LastEditDate': '2013-11-06T16:56:18.623', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '11224', 'Tags': '<computability>', 'CreationDate': '2013-11-06T14:10:43.910', 'Id': '16771'}{'Body': "<p>I have a professor who is really poor at explaining the material, which is what makes answering his questions very hard. Here is the question:</p>\n\n<blockquote>\n  <p>Recursive language with non-recursive subsets. Does one exist?</p>\n</blockquote>\n\n<p>I'm sure it is a very simple and easy answer but I can't figure it out. Don't give me the answer just point me in the right direction and I'm sure I'll figure it out.</p>\n", 'ViewCount': '77', 'Title': 'Recursive language with non-recursive subsets', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-10T10:14:36.530', 'LastEditDate': '2013-11-10T10:14:36.530', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2013-11-10T00:38:17.997', 'Id': '17860'}{'Body': '<p>Consider these 2 languages:</p>\n\n<ul>\n<li><blockquote>\n  <p>$L_{\\ge5} = \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts at least 5 strings} \\right\\} $</p>\n</blockquote></li>\n<li><blockquote>\n  <p>$L_{&lt;5} =  \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts fewer than 5 strings} \\right\\}$</p>\n</blockquote></li>\n</ul>\n\n<p>Are these recursive, R.E., or not R.E. sets (languages)?</p>\n\n<p>I would say that they are not recursive, based on applications of Rice\'s Theorem.</p>\n\n<ul>\n<li><p>For the first case $L_{e}= \\left \\{ \\left&lt; M \\right&gt; :L(M)= \\emptyset \\right \\} \\notin L_{\\ge5} $ and $L_{\\ge5}$ are not empty. For example, I define $L= \\left \\{ \\left&lt; M \\right&gt; : M \\text{ accepts all palindromes} \\right \\}$, which is not finite set and accepts an infinite number of strings.</p></li>\n<li><p>For the second case I would do the same thing. I have $L_{e}=\\left\\{ \\left&lt; M \\right&gt;: L(M)= \\emptyset \\right\\} \\in L_{&lt;5}$ and $L=\\left\\{ \\left&lt; M \\right&gt;:M \\text{ accepts all palindromes} \\right\\} \\notin L_{&lt;5} $</p></li>\n</ul>\n\n<p>So I would say that both are not recursive. Is my reasoning correct?</p>\n\n<p>Now about the R.E. of the languages I don\'t have an idea of how I can prove it, this should be the beginning (if L is not RE it can\'t be recursive), how can I check if they are RE or not?</p>\n\n<p>From the definition: "$L$ is RE $\\iff$ there exists a TM $M$ that accepts $L$", so I just have to define a TM that accepts each language?</p>\n', 'ViewCount': '224', 'Title': 'Show that a language is RE or recursive', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:21:03.943', 'LastEditDate': '2014-01-18T20:21:03.943', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17891', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<computability><undecidability><semi-decidability>', 'CreationDate': '2013-11-10T22:17:09.953', 'Id': '17889'}{'Body': "<p>$L$ is defined over the alphabet $\\{a,b\\}$ and it's decidable.\nThe language is $\\mathrm{perm}(L)$ which is the set of all permutations of all words in $L$.</p>\n\n<p>So far my proof is the following:</p>\n\n<p>Construct a TM $M$ that decides the language $\\mathrm{perm}(L)$. $M$ has input $w$.\nLet $\\pi(w)$ be a random permutation of w. Then feed it to $M$: $M$ accepts if $\\pi(w) \\in L$ or rejects if $\\pi(w) \\notin L$. </p>\n\n<p>I.e. if we let $\\pi(w)$ be a permutation of $w$ s.t. $\\pi(w) \\in L$, $M$ should halt and accept.\nIf we let $\\pi(w)$ be a permutation of $w$ s.t. $\\pi(w) \\notin L$, $M$ should halt and reject.</p>\n\n<p>Is this correct and enough?</p>\n", 'ViewCount': '74', 'ClosedDate': '2013-11-12T17:54:57.167', 'Title': 'Prove this language is decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:09:01.850', 'LastEditDate': '2013-11-13T22:09:01.850', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11317', 'Tags': '<computability><permutations>', 'CreationDate': '2013-11-11T19:09:26.007', 'Id': '17920'}{'Body': "<p>I understand how a the language of turing machines which do not accept themselves is not recognizable but I'm not sure if the same proof could be used to describe a DFA... i.e a proof by contradiction in which a recognizer M recognizes a TM which does not accept itself on input ...creates a contradiction in which if M accepts then M does not accept itself. </p>\n", 'ViewCount': '113', 'Title': 'Is the language of DFAs which do not accept themselves recognizable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:46.427', 'LastEditDate': '2013-11-13T22:08:46.427', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11306', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-11-11T20:08:51.590', 'FavoriteCount': '1', 'Id': '17925'}{'Body': '<p>In trying to understand how Turing Machine encoding works, there is a question that I have come across that goes something like this:</p>\n\n<p>Given that the diagonal language, $L_d = \\{ w_i \\mid w_i \\space is \\space not \\space accepted \\space by \\space M_i \\}$, what is the first string of the encoding of the complement of $L_d$ which is $\\bar{L_d}$?</p>\n\n<p>I am assuming also that this is operating with the alphabet of $\\Sigma = \\{0, 1\\}$. Is there any way that it is even possible? I am confused also since $L_d$ is an undecidable language how this is possible?</p>\n\n<p>Also by encoding I think that the question is referring to binary encoding with a tape alphabet $\\{0, 1, B\\}$ with Turing machine $M$ defined as:</p>\n\n<p>$M = &lt; Q, \\{0, 1\\}, \\{0, 1, B\\},\\delta,q_1,B,\\{q_2\\} &gt;$</p>\n\n<p>with moves defined by:</p>\n\n<p>$\\delta(q_i,X_j) = (q_k,X_n,D_m) \\rightarrow 0^i10^j10^k10^n10^m $</p>\n\n<p>where $X_1 = 0, X_2 = 1, X_3 = B$\nand Direction is given by: $D_1 = L, D_2 = R$,</p>\n\n<p>and the Binary encoding of $M$ as $&lt;M&gt;$: $111 \\space move_1 \\space 11 \\space move_2 \\space 11 \\space ... \\space 11 \\space move_{last} \\space 111$</p>\n\n<p><strong>Update:</strong> If my understanding is correct, the correct encoding should represent a Turing machine which accepts every string since originally we do not accept any string? How would one go about formulating an encoding for such a Turing machine? Does it have to be a unique encoding, or does it just imply that any Turing machine that accepts every string is valid?</p>\n', 'ViewCount': '372', 'Title': 'Turing Machine Encoding and Complement of the Diagonal Language', 'LastEditorUserId': '9912', 'LastActivityDate': '2014-04-12T02:09:59.257', 'LastEditDate': '2013-11-12T23:49:58.173', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-11-11T22:57:07.680', 'Id': '17931'}{'Body': "<p>I'm trying to figure out how to prove or disprove the following statement:</p>\n\n<blockquote>\n  <p>Infinite union of recursive languages is recursively enumerable. </p>\n</blockquote>\n\n<p>I know how to prove that infinite union of regular languages is not recursive, but I can't figure out how to prove the statement above. Intuition is telling me that the statement is true, but I'm not sure. Does anybody know how would I go about it?</p>\n\n<p>Any help is greatly appreciated.</p>\n", 'ViewCount': '165', 'Title': 'Infinite union of recursive languages', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:38.003', 'LastEditDate': '2013-11-13T22:08:38.003', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-11-12T00:21:03.943', 'Id': '17938'}{'Body': "<p>Is it true that if A is a subset of B, and B is decidable, than A is guaranteed to be decidable?</p>\n\n<p>I believe it would be true because all the subsets of B should also be decidable making A decidable. I'm not sure if my thought process is right or if there's a easier more intuitive way to explain this.</p>\n", 'ViewCount': '362', 'Title': 'Is every subset of a decidable set, also decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:08:31.597', 'LastEditDate': '2013-11-13T22:08:31.597', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<computability><undecidability><closure-properties><sets>', 'CreationDate': '2013-11-12T18:05:15.880', 'Id': '17966'}{'Body': u"<p>I know this has been a question but based on a past experience, i thought i would rewrite it so i can get input and ask questions faster.</p>\n\n<p>Suppose we have \n$$\\text{NOT-SELF}=\\{\\langle M\\rangle \\mid  M \\text{ is a Turing machine that does not accept }\\langle M\\rangle\\}$$\nthe set of all machines that don't accept their own coding.</p>\n\n<p>Let $Z$ be a TM such that $L(Z)$ is a subset of $\\text{NOT-SELF}$. Prove that $\\langle Z\\rangle$ is an element of $\\text{NOT-SELF}$.</p>\n\n<p>My answer so far is very broad and I'm trying to improve it.</p>\n\n<p>If $\\langle Z\\rangle$ is not an element of $\\text{NOT-SELF}$, than $\\langle Z\\rangle$ can\u2019t be an element in $L(Z)$. Since there\u2019s a condition that $L(Z)$ is a subset of $\\text{NOT-SELF}$,  this contradicts so $\\langle Z\\rangle$ must be an element of $\\text{NOT-SELF}$.</p>\n", 'ViewCount': '86', 'Title': 'Prove that <Z> is not a element of NOT-SELF', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-14T09:29:43.787', 'LastEditDate': '2014-01-15T08:30:51.607', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10773', 'Tags': '<computability><turing-machines><decision-problem>', 'CreationDate': '2013-11-12T22:19:09.830', 'Id': '17973'}{'Body': "<p>I've been thinking about how to show this but I'm stuck.</p>\n\n<p>I'm required to prove this:</p>\n\n<blockquote>\n  <p>Show that the language $$\\mathrm{TOT}= \\{\\langle M \\rangle : M\\text{ is a Turing Machine that halts with all inputs} \\}$$ is not recursively enumerable nor its complement. ($\\langle M \\rangle$ is an encoded Turing Machine with only zeros and ones).</p>\n</blockquote>\n\n<p>I think we have to proceed by contradiction, assuming that $\\mathrm{TOT}$ is recursively enumerable, so there must be a Turing Machine that we will call $T$ such that it can process any possible encoding $\\langle M \\rangle$ of a TM $M$ and only accept those machines that halt with all inputs.</p>\n\n<p>So in order to confirm that $\\mathrm{TOT}$ is r.e., $T$ should be able to do this for every $M$ that halts with all inputs. My idea is to show that this is not possible because the set $\\mathrm{TOT}$ is not countable, so maybe I can show this using the diagonalization argument, but I'm not sure.</p>\n\n<p>So what is the correct way to prove this?</p>\n\n<p>Thanks</p>\n", 'ViewCount': '28', 'ClosedDate': '2013-11-13T22:14:17.077', 'Title': 'Show that the language of all total Turing machines is neither r.e. nor co-r.e', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-13T22:13:18.120', 'LastEditDate': '2013-11-13T22:13:18.120', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11349', 'Tags': '<formal-languages><computability><turing-machines>', 'CreationDate': '2013-11-13T02:20:56.380', 'Id': '17977'}{'Body': '<p>In order to prove a certain function to be partially computable, I need to show an $\\mathbb S$-program that computes it. I could really use the predicate $X \\in B$ in my program to draw my conclusion. To give you the idea of what I am dealing with here it is one of my problems:</p>\n\n<blockquote>\nGive an infinite set $B$ such that $\\Phi(x,x)\\uparrow$ for all $b \\in\nB$ and such that $$H(x) = \\begin{cases}1 \\text{ if }\n\\Phi(x,x)\\downarrow \\\\ 0 \\text{ if } x \\in B \\\\ \\uparrow \\text{\notherwise}\\end{cases}$$ show that $H(x)$ is partially computable.\n</blockquote>\n\n<p>I am wondering if membership for infinite set is decidable and therefore can be used to write $\\text{IF } X \\in B$ such program. Am I allowed?</p>\n\n<p><strong>Edit:</strong> the notation $\\Phi(x,x)\\uparrow$ means the function is undefined.</p>\n', 'ViewCount': '147', 'Title': 'Is membership of x in an infinite set decidable?', 'LastEditorUserId': '2778', 'LastActivityDate': '2014-01-22T12:22:49.970', 'LastEditDate': '2013-11-23T10:45:44.037', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<computability><decision-problem>', 'CreationDate': '2013-11-21T18:20:14.557', 'Id': '18230'}{'Body': '<p>Let $U$ be a universal Turing machine that on input $&lt;M,w&gt;$ simulates a Turing machine $M$ on input $w$. I have a question about what would happen if $U$ "operated" on itself.</p>\n\n<p>That is, what happens when we consider the input $&lt;U, &lt;M,w&gt;&gt;$?</p>\n\n<p>Or what about the input $&lt;U, &lt;U, &lt;M,w&gt;&gt;&gt;$?</p>\n', 'ViewCount': '91', 'Title': 'Recursive Universal Turing Machines', 'LastActivityDate': '2013-11-24T20:12:28.790', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11597', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-11-24T18:55:14.703', 'Id': '18305'}{'Body': "<p>I have the following two languages, which are languages of TM descriptions:</p>\n\n<p>$$INFINITE = \\{ \\langle M \\rangle | \\mbox{M is a TM and L(M) is infinite} \\}$$</p>\n\n<p>$$A_{ALL} = \\{ \\langle M \\rangle | \\mbox{M is a TM and } L(M) = \\Sigma^* \\}$$</p>\n\n<p>Neither of these languages are decidable, recognizable, or co-recognizable. However, I believe they're in $\\Pi_2$, since a TM belongs to $INFINITE$ iff for every x, there is a string y and computation history H where y has length greater than x and H is a history that shows that M accepts y and a TM belongs to $A_{ALL}$ iff for every w, there is a computation history H that shows that M accepts w. (I'm not sure if this reasoning is correct or not, though).</p>\n\n<p>I have been wondering for a while whether either of these languages are mapping reducible to one another. I don't see a quick way to prove that the languages are <em>not</em> reducible to one another, but I similarly can't see a simple reduction in either direction.</p>\n\n<p>Are either of these languages reducible to the other? If so, how?</p>\n\n<p>Thanks!</p>\n", 'ViewCount': '51', 'Title': 'Is it possible to mapping reduce either of these languages to the other?', 'LastActivityDate': '2013-11-26T09:33:52.140', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18368', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><reductions>', 'CreationDate': '2013-11-25T07:37:46.777', 'Id': '18323'}{'Body': "<p>How do I precisely define the function which is a mapping reduction of A to B for the following examples?</p>\n\n<p>What is the process of figuring this out?</p>\n\n<p>Given: A and B are languages over the alphabet {0,1}.</p>\n\n<p>Examples:</p>\n\n<ul>\n<li>A is the language described by 1*0*, B is the language described by 01*0*</li>\n<li>A={w | the length of w is even}, B={w | the length of w is odd}</li>\n<li>A=B={w | the length of w is even}</li>\n<li>A={0,1}*, B={00,1,101}</li>\n</ul>\n\n<p>I am studying this material and I am not sure of how to 'precisely' define these functions. Could somebody provide me with solutions and a methodology to finding the solution?</p>\n", 'ViewCount': '53', 'Title': 'Finding a function which is a mapping reduction of A to B', 'LastEditorUserId': '11622', 'LastActivityDate': '2013-11-29T00:25:26.853', 'LastEditDate': '2013-11-29T00:22:45.743', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18458', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11622', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-11-25T23:31:44.567', 'Id': '18339'}{'ViewCount': '188', 'Title': 'Is there a TM that halts on all inputs but that property is not provable?', 'LastEditDate': '2013-11-27T22:07:04.507', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '699', 'FavoriteCount': '2', 'Body': '<blockquote>\n  <p>Does there exist a Turing machine that halts on all inputs but that property is not provable for some reason?</p>\n</blockquote>\n\n<p>I am wondering if this question has been studied. Note, "unprovable" could mean a "limited" proof system (which in the weak sense think the answer must be yes). I am of course interested in the strongest possible answer, i.e. one that is not provable to halt on all inputs in say <a href="http://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory">ZFC set theory</a> or whatever.</p>\n\n<p>It occurred to me this could be true of the <a href="http://en.wikipedia.org/wiki/Ackermann_function">Ackermann function</a> but I am hazy on the details. It doesn\'t seem like Wikipedia describes this aspect clearly.</p>\n', 'Tags': '<computability><reference-request><turing-machines><halting-problem>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-03T19:03:16.420', 'CommentCount': '3', 'AcceptedAnswerId': '18425', 'CreationDate': '2013-11-27T21:44:59.707', 'Id': '18424'}{'Body': "<p>Is the language $L_{universal} = \\{ \\left \\langle M \\right \\rangle | M \\textrm{is a universal turing machine} \\}$ decidable? </p>\n\n<p>I'm guessing it is decidable according to the definition of a UTM, that a UTM must be able to calculate every recursive function. Since the set of recursive languages and the set of all input words are both enumerable, we are theoretically able to determine if the given $\\left \\langle M \\right \\rangle$ is a UTM. Is my logic somewhat correct?</p>\n", 'ViewCount': '81', 'Title': 'Decidability of the language that accepts a universal turing machine', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-02T12:19:54.130', 'LastEditDate': '2013-12-02T12:19:54.130', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '18508', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11738', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-12-01T18:21:44.070', 'Id': '18506'}{'Body': "<p>Please correct my statement.\nAssuming $L\\in NP$, and algorithm A can determine L in poly-time in a nondeterministic machine, we have algorithm $A'$ and the complement of $L$ -- $L'$. $x$ is the input of $A'$</p>\n\n<pre><code>A'(x)\n{\n   if(A(x) is true)\n      return false\n   else\n      return true\n}\n</code></pre>\n\n<p>In this code, it seems like $A'$ can also run in a nondeterministic machine in poly-time. Can I just say $co-NP=NP$??</p>\n\n<p>Or my flaw is that the input $x\\in L'$ but $x\\notin L$?</p>\n\n<p>Could you please give me a specific example?? </p>\n", 'ViewCount': '27', 'ClosedDate': '2013-12-03T08:12:08.397', 'Title': 'Why NP is not closed under complement?', 'LastActivityDate': '2013-12-03T01:10:20.433', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11773', 'Tags': '<complexity-theory><computability><np-complete><decision-problem>', 'CreationDate': '2013-12-03T01:10:20.433', 'Id': '18553'}{'Body': '<p>Today I\'ve heard about fascinating metagame paradox. I tried to come up with an explanation via Turing Machines formalization (below). Do you know what is the solution to the paradox? (the post content: definition - proposed solution - conclusion)</p>\n\n<p>Something is a game iff:</p>\n\n<pre><code>G1. Two players\nG2. Players alternate\nG3. The game finally ends.\n</code></pre>\n\n<p>The metagame is:</p>\n\n<pre><code>M1. First player picks a game\nM2. Second player starts the game\nM3. The winner is the winner of the game at step 2.\n</code></pre>\n\n<p>Example of a metagame:</p>\n\n<pre><code>1) I pick tic-tac-toe\n2) OK, I put X here ..\n.. so they play ..\n3) .. and let player 2 wins in the tic-tac-toe =&gt; player 2 wins the metagame.\n</code></pre>\n\n<p><strong>Paradox: Is metagame a game?</strong></p>\n\n<p>If metagame is a game, then at point (M1) both players can always pick a metagame, so the metagame will never end => (G3) is violated => metagame is not a game => contradiction.</p>\n\n<p>(also contradiction for case "metagame is not a game" -- metagame will satisfy the definition of a game)</p>\n\n<p>(see also <a href="http://www.math.cornell.edu/~mec/2006-2007/Games/hypergame.html" rel="nofollow">http://www.math.cornell.edu/~mec/2006-2007/Games/hypergame.html</a>)</p>\n\n<p><strong>What is the solution to the paradox?</strong></p>\n\n<p><em>UPDATE:</em> You may want to skip this explanation and go directly to D.W. answer.</p>\n\n<p>I came up with the following explanation:</p>\n\n<p>Lets formalize the problem using Turing Machines notations.\nLet a game be a finite binary string that describes "somehow" game rules. Let a game simulator be a non-deterministic TM that reads a description from the input (without any sanity checks, so the TM doesn\'t know if the game finally ends), and then makes non-deterministic moves for the first and second player. Here we assume (A1) that the game-simulator can decide valid next moves.</p>\n\n<p>Now have a look at the description of a meta-game:</p>\n\n<pre><code>M1. First player picks a game\n</code></pre>\n\n<p>This sentence means that we can "pick a game", i.e. in the definition we assume (A2) that whether an arbitrarily binary string is a game (satisfies G1,G2,G3) is decidable. (see also note (n1) )</p>\n\n<p>M2 and M3 look decidable.</p>\n\n<p>So, <strong>my suggestion is that metagame is not "defined properly"</strong>, since its definition assumes the existence of a decider "if a given binary string is a game". And then we derive a contradiction, so this assumption is wrong.</p>\n\n<p><strong>Does it make sense? Is this related with other explanations of the paradox?</strong>\n(intuitive answers would be great!)</p>\n\n<p>Notes:</p>\n\n<ol>\n<li>Assuming "whether an arbitrarily binary string is a game" may be too much. But we need some computable procedure "pick a game" and one that came into mind is "generate random string, check if it is a game".</li>\n<li>I don\'t know what is a formal word for "not defined properly"</li>\n<li>Assumption A1 may also be undecidable, but I believe it should not change the argument..</li>\n</ol>\n', 'ViewCount': '115', 'Title': 'Metagame Paradox: what is wrong with this explanation?', 'LastEditorUserId': '2260', 'LastActivityDate': '2013-12-11T08:56:46.867', 'LastEditDate': '2013-12-11T08:23:57.650', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18821', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2260', 'Tags': '<computability><turing-machines><game-theory>', 'CreationDate': '2013-12-09T20:00:39.473', 'Id': '18786'}{'Body': "<blockquote>\n  <p>Show that the set $K^{c}$ = $\\lbrace M \\mid M(M) \\text{ diverges} \\rbrace$ is not recursively enumerable.</p>\n</blockquote>\n\n<p>This question is essentially asking to show that the set of turing machines which diverge when run on their own code is not RE.</p>\n\n<p>My idea is to attempt to reduce this problem to something which is the complement of the halting problem.  Thus, the idea is to take a machine M and a word w, and construct a new machine which diverges on it's own code when M diverges on w, but haven't had much luck with that.</p>\n\n<p>This is from a practise exam, but please treat it as a homework question so I can attempt to work through a solution.</p>\n", 'ViewCount': '76', 'Title': 'Turing machine which diverges on its own code', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-10T18:32:40.683', 'LastEditDate': '2014-01-10T18:32:40.683', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11999', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2013-12-10T21:36:02.977', 'Id': '18840'}{'Body': "<p>I've got a problem where I need to check the <em>validity</em> (i.e to say whether it's true or false) of the following statement:</p>\n\n<blockquote>\n  <p><strong>Complement of a non-recursive language can NEVER be recognized by any turing machine.</strong></p>\n</blockquote>\n\n<p>How I've thought of this is that, if a language $\\mathcal{L}$ is non-recursive, there is no turing machine that accepts the language. That is, there's no TM that halts for every string in $\\mathcal{L}$. But there could be a TM $M_1$ that halts for some of the strings in $\\mathcal{L}$.</p>\n\n<p>Now suppose, the proposition is $\\ false$. So there could be a TM ${M_2}$ that recognizes the complement of $\\mathcal{L}$. So ${M_2}$ halts and accepts every string that is <strong>NOT</strong> in $\\mathcal{L}$ and may or may not halt for strings in $\\mathcal{L}$.</p>\n\n<p>Intuitively, It appears that ${M_1}$ and ${M_2}$ could be same, which makes my assumption $\\ true$. That is the the proposition is $\\ false$.</p>\n\n<p>But I'm not certain about the arguments I've made (as the equivalence of $M_1$ and $M_2$ is based on intuition). Can someone verify whether I'm correct or correct me otherwise.</p>\n", 'ViewCount': '65', 'Title': 'Can the complement of a non-recursive language be RE', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-13T13:25:20.253', 'LastEditDate': '2013-12-13T13:25:20.253', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11949', 'Tags': '<computability><undecidability>', 'CreationDate': '2013-12-13T10:53:33.213', 'Id': '18948'}{'ViewCount': '184', 'Title': 'Decidability of Turing Machines with input of fixed length', 'LastEditDate': '2013-12-16T13:54:56.020', 'AnswerCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12094', 'Body': "<p>I'm learning about undecidability, and found this question:</p>\n\n<pre><code>Is this language decidable, make a proof:\n    L = { M : machine M halts for every input of length not exceeding 100 }\n</code></pre>\n\n<p>Update: This is translated from an exam paper some years ago, and I'm quite sure it means that machine M should halt for every input with length from 0 to 100, and that it is no constraints on the tape size.</p>\n\n<p>Update2: The solution given below, and hence the origin of this post, is for an variant of this question with fixed number of steps and input. Sorry for the confusion.</p>\n\n<p>I came to the conclusion that this is an undecidable language. </p>\n\n<p>My logic is as follows: Lets say for the sake of contradiction that it is possible to construct a machine $M_R$, that takes as input an arbitrary input $(M,x)$, and reduces this to $M'$. $M'$ has the property so that $(M,x) \\in M_{HALT}$ iff $M' \\in L$, this means that $M$ halts on all $x$ of input with maximum length of 100. </p>\n\n<p>Then run $M$ on $x$, if it halts then accept. </p>\n\n<p>And shows that $M_R$ decides the halting problem, and in hence a contradiction and proves that his is not decidable.</p>\n\n<p>But in the solution it is written that this question is decidable:</p>\n\n<blockquote>\n  <p>You can simulate $M$ on all inputs of length 100 or less (you can\n  generate such input in a loop and use the universal Turing machine to\n  simulate M on x), it is only $|\\Sigma|^{100}$ possible inputs of\n  length 100, that is finite.</p>\n</blockquote>\n", 'ClosedDate': '2013-12-16T20:32:42.270', 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '12094', 'LastActivityDate': '2013-12-16T20:33:05.603', 'CommentCount': '9', 'AcceptedAnswerId': '18971', 'CreationDate': '2013-12-13T18:19:55.973', 'Id': '18959'}{'Body': u"<p>$\\mathrm{Halt} = \\{ (f,x) | f(x)\\downarrow \\}$ is r.e. (semi-decidable) but undecidable.</p>\n\n<p>$\\mathrm{Total} = \\{ f | \\forall x f(x)\\downarrow \\}$ is not r.e. (not even semi-decidable).</p>\n\n<p>I need some help in proving that $\\mathrm{Total}$ is not recursive (decidable). </p>\n\n<p>I know the diagonalization proof for the halting problem, I just need the same kind of proof for $\\mathrm{Total}$. I'm posting the proof for the halting problem for reference:</p>\n\n<h2>Undecidability of the halting problem</h2>\n\n<p>Assume we can decide the halting problem. Then there exists some total function $\\mathrm{Halt}$ such \nthat \n$$\n\\mathrm{Halt}(x,y) = \\begin{cases} 1 &amp; \\text{if $\\phi_x(y)$ is defined}, \\\\ 0 &amp; \\text{if $\\phi_x(y)$ is not defined}.\\end{cases}\n$$</p>\n\n<p>Here, we have numbered all programs and $\\phi_x$ refers to the $x$'th program in this ordering. We can view $\\mathrm{Halt}$ as a mapping from $\\mathbb{N}$ into $\\mathbb{N}$ by treating its input as a single number representing the pairing of two numbers via the one-one onto function \n$$ \\mathrm{pair}(x,y) = \\langle x,y \\rangle = 2^x (2y + 1) \u2013 1 , $$\nwith inverses \n$$\n\\begin{align*}\n \\langle z \\rangle_1 &amp;= \\exp(z+1,1), \\\\\n \\langle z \\rangle_2 &amp;= ((( z + 1 ) // 2^{\\langle z \\rangle_1}) \u2013 1 ) // 2 \n\\end{align*}\n$$\nNow if $\\mathrm{Halt}$ exists, then so does $\\mathrm{Disagree}$, where \n$$\n\\mathrm{Disagree}(x) = \\begin{cases} 0 &amp; \\text{if $\\mathrm{Halt}(x,x)=0$, i.e., if $\\phi_x(x)$ is not defined}, \\\\ \\operatorname*{\\mu}_y (y=y+1) &amp; \\text{if $\\mathrm{Halt}(x,x)=1$, i.e., if $\\phi_x(x)$ is defined}. \\end{cases}\n$$</p>\n\n<p>Since $\\mathrm{Disagree}$ is a program from $\\mathbb{N}$ into $\\mathbb{N}$, $\\mathrm{Disagree}$ can be reasoned about by $\\mathrm{Halt}$. Let $d$ \nbe such that $\\mathrm{Disagree} = \\phi_d$, then </p>\n\n<p>$$\\mathrm{Disagree}(d)\\text{ is defined} \\Leftrightarrow \\mathrm{Halt}(d,d) = 0 \\Leftrightarrow \u03a6_d(d)\\text{ is undefined} \u21d4 \\mathrm{Disagree}(d)\\text{ is undefined}.$$ </p>\n\n<p>But this means that $\\mathrm{Disagree}$ contradicts its own existence. Since every step we took was constructive, except for the original assumption, we must presume that the original assumption was in error. Thus, the halting problem is not decidable. </p>\n", 'ViewCount': '63', 'Title': 'How to prove that "Total" is not recursive (decidable)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-07T05:56:05.760', 'LastEditDate': '2014-04-07T05:56:05.760', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Michael Anthony Leber', 'PostTypeId': '1', 'Tags': '<computability><undecidability><halting-problem>', 'CreationDate': '2013-12-03T03:53:04.973', 'Id': '18980'}{'Body': '<p>Is the set $S$ = $\\lbrace M \\mid M \\text{ is a Turing machine and }L(M)=\\lbrace \\langle M\\rangle\\rbrace\\rbrace$ empty?</p>\n\n<p>In other words is there a Turing machine $M$ that only accepts its own encoding? What about a Turing machine that rejects only its own encoding? </p>\n', 'ViewCount': '192', 'Title': 'Can I construct a Turing machine that accepts only its own encoding?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-12-14T22:00:05.450', 'LastEditDate': '2013-12-14T19:12:30.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18990', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12115', 'Tags': '<computability><turing-machines>', 'CreationDate': '2013-12-14T18:36:38.220', 'Id': '18989'}{'Body': '<p>I need help with showing that \n$$NeverHalt_{TM} = \\{\\langle M\\rangle \\mid \\text{$M$ is a TM which runs forever on every input $w$}\\}$$\nis undecidable by giving an explicit mapping reduction.</p>\n\n<p>To show that a language reduces to any other language we must show that yes-instances are mapped to yes-instances and no-instances are mapped to no instances. We need to find a TM whose language will "help" us solve $NeverHalt_{TM}$, given $\\langle M\\rangle$.</p>\n\n<p>I am not really sure where to go from here or in general how to proceed with undecidability problems.</p>\n', 'ViewCount': '66', 'Title': 'Mapping reduction to show NeverHalt is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T22:15:30.900', 'LastEditDate': '2014-02-02T22:15:30.900', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<computability><reductions><undecidability>', 'CreationDate': '2013-12-17T00:13:34.353', 'Id': '19055'}{'Body': u'<p>Let $\\phi$ be a the function computed by a <a href="http://en.wikipedia.org/wiki/Universal_Turing_machine" rel="nofollow">universal Turing machine</a>: $\\phi_y(x)$ is the encoding of the output of the machine for the program whose G\xf6del encoding is $y$ with input encoding $x$.</p>\n\n<p>I am looking for an upper bound on the length of the shortest program that computes $\\phi$.</p>\n', 'ViewCount': '87', 'Title': 'upper bound for the size of a universal Turing machine', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-20T18:42:06.630', 'LastEditDate': '2013-12-20T10:40:23.843', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '12189', 'Tags': '<computability>', 'CreationDate': '2013-12-17T18:36:20.703', 'Id': '19068'}{'Body': "<p>You probably know this one (or at least a version of it).<br>\nLet $P$ be a program code, and $w$ be an input string.<br>\nDefine $A_{TM}=\\left\\{(P,w)| P(w)=1\\right\\}$.<br>\nMeaning: $A_{TM}$ is the set of all ordered pairs $(P,w)$ s.t. $P$ accepts $w$.<br>\n$A_{TM}$ is undecidable.</p>\n\n<p>I just read the proof for it, that made me wonder about something.<br>\nThe brief of the proof (by contradiction) looks something like this:<br>\nSuppose there exist $D_{A_{TM}}$ - a computer program that answers 'yes' if $(P,w)\\in A_{TM}$, and 'no' if $(P,w)\\notin A_{TM}$.<br>\nLet us consider the following program:</p>\n\n<p>$Q(w):$<br>\n1. run $D_{A_{TM}}$ on $(w,w)$<br>\n2. if $D_{A_{TM}}$ returned 'yes', then return 'no'.\nif $D_{A_{TM}}$ returned 'no', return 'yes'.</p>\n\n<p>Now running $Q(w);$ with the input $Q$, contradicts the existence of such $D_{A_{TM}}$</p>\n\n<p>This is a brief, since I assume most of you already know this problem (and its proof).  </p>\n\n<p>Now what makes me wonder is this: when I looked at $A_{TM}$, and needed to determine if it's decidable or not, the first thing that came to my mind when I tried to imagine a machine that accepts $A_{TM}$, is how can machine like that handle inputs $(P,w)$ s.t. $P$ doesn't halt on $w$?  How can it 'predicts', beforehand, that $P(w)$ goes to an infinite loop, without actually running $P$ on $w$?<br>\nThat intuition, as it turns out, wasn't wrong.<br>\nThe thing is: How come the proof, as clever as it is, has nothing to do with that fact?<br>\nYou'd expect it to lean - and even in the slightest way - on that leverage, but instead, the proof looks like something that was taken from the realm of paradoxes.</p>\n\n<p>Basically, what I'm asking is: why does this proof work?</p>\n", 'ViewCount': '41', 'Title': 'Question about the undecidability of $A_{TM}$', 'LastActivityDate': '2013-12-19T15:25:33.670', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11972', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2013-12-19T14:24:23.117', 'Id': '19120'}{'Body': "<p>I'm trying to understand decidable languages. In particular, I would like to show that\n$$B = \\lbrace \\langle D \\rangle \\mid \\exists k \\geq 0 \\,.\\,\\text{DFA $D$ accepts $a^k b^k$}\\rangle.$$\nI don't quite understand the process of proving these. I know that $a^kb^k$ is not regular, so then no DFA accepts it. I also know that $A_{DFA}$ (acceptance DFA) is decidable, I also know several other decidable languages like $E_{DFA}$ and $EQ_{DFA}$. How can I use these to prove that $B$ is decidable? </p>\n\n<p>If no DFA accepts $a^kb^k$, doesn't that mean that $A_{DFA}$ will reject? So if $A_{DFA}$ rejects then shouldn't the decider for $B$ accept? </p>\n", 'ViewCount': '110', 'Title': 'Decidability of $\\lbrace \\langle D \\rangle \\mid \\text{$D$ accepts $a^kb^k$ for some $k > 0$}\\rbrace$', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-29T09:53:04.893', 'LastEditDate': '2013-12-29T09:53:04.893', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '19173', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<computability><finite-automata>', 'CreationDate': '2013-12-21T02:54:13.680', 'Id': '19171'}{'Body': "<p>I'm trying to find a formal proof of the following fact:</p>\n\n<blockquote>\n  <p>Given a context-free language $L_1$ and a context-sensitive language $L_2$, it is NOT decidable if their intersection is empty ($L_1 \\cap L_2 = \\varnothing$).</p>\n</blockquote>\n\n<p>I want to be able to prove it by contradiction, knowing the fact that it's undecidable to say if a given context sensitive grammar is empty.</p>\n\n<p>I know that the intersection of two context-free languages is undecidable, but I have to make a formal proof by contradiction. Taking $L_1$ as $\\Sigma^*$ ends up with a CS intersection, ok that's fine but I would like to make a better and more formal proof, without recurring to take specific languages, in a more general way... </p>\n", 'ViewCount': '76', 'Title': 'Intersection between context-free and context-sensitive language decidability', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-28T16:25:05.513', 'LastEditDate': '2013-12-28T16:25:05.513', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12405', 'Tags': '<computability><context-free><automata><undecidability><context-sensitive>', 'CreationDate': '2013-12-27T14:51:43.293', 'Id': '19326'}{'ViewCount': '24', 'Title': 'Decidability. $\\lbrace \\langle D \\rangle \\mid \\text{$D$ accepts $a^kb^k$ for some $k > 0$}\\rbrace$', 'LastEditDate': '2013-12-29T09:52:56.220', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'Data', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Body': "<p>I'm trying to understand decidable languages. In particular, I would like to show that\n$$B = \\lbrace \\langle D \\rangle \\mid \\exists k \\geq 0 \\,.\\,\\text{DFA $D$ accepts $a^k b^k$}\\rangle.$$\nI don't quite understand the process of proving these. I know that $a^kb^k$ is not regular, so then no DFA accepts it. I also know that $A_{DFA}$ (acceptance DFA) is decidable, I also know several other decidable languages like $E_{DFA}$ and $EQ_{DFA}$. How can I use these to prove that $B$ is decidable? </p>\n\n<p>If no DFA accepts $a^kb^k$, doesn't that mean that $A_{DFA}$ will reject? So if $A_{DFA}$ rejects then shouldn't the decider for $B$ accept? </p>\n", 'ClosedDate': '2013-12-29T11:42:46.690', 'Tags': '<computability><finite-automata>', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-29T09:52:56.220', 'CommentCount': '4', 'CreationDate': '2013-12-21T01:42:14.683', 'Id': '19357'}{'Body': u'<p>As I have studied, deciding regularity of context-free languages is undecidable.</p>\n\n<p>However, we can test for regularity using the Myhill\u2013Nerode theorem which provides a necessary and sufficient condition. So the problem should be decidable.</p>\n\n<p>Where is my mistake?</p>\n', 'ViewCount': '151', 'Title': 'Why is deciding regularity of a context-free language undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-05T17:18:35.267', 'LastEditDate': '2014-01-04T18:39:42.627', 'AnswerCount': '1', 'CommentCount': '14', 'AcceptedAnswerId': '19500', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12569', 'Tags': '<formal-languages><computability><regular-languages><undecidability>', 'CreationDate': '2014-01-03T12:37:01.957', 'Id': '19482'}{'Body': "<p>Given a turing machine $T$ that receives an encoding of another turing machine and a word $&lt;M&gt;&lt;w&gt;$, can $T$ 'run' through the encoding and 'mark' specific transitions/states?</p>\n\n<p>For example, if I want to show that the language $L = \\{&lt;M&gt;&lt;w&gt;\\}$ such that when we run $w$ in $M$ we will visit at least two unique states different than the starting state.</p>\n\n<p>Now for this, I suggested this algorithm, but I am not sure it is even compuatable:</p>\n\n<blockquote>\n  <p>Given the encoding $&lt;M&gt;&lt;w&gt;$, we will run through the encoding and 'mark' all states that can be reached from the starting state of $M$, if two or more states have been marked after finishing, accept, else, reject. </p>\n</blockquote>\n\n<p>I know that since this an encoding of a turing machine and a word, we indeed -can- run through the encoding. But can we really do the 'marking' operation? if so, how?</p>\n", 'ViewCount': '34', 'Title': "Turing Machine 'marking' specific portion of encoding", 'LastActivityDate': '2014-01-07T19:09:03.653', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19565', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<computability><undecidability>', 'CreationDate': '2014-01-07T18:33:38.510', 'Id': '19562'}{'Body': "<blockquote>\n  <h3>Sipser theorem 4.4*</h3>\n  \n  <p>$E_{DFA} = \\{ \\langle A \\rangle \\mid \\text{A is a DFA and } L(A)=\\emptyset\\}$ is decidable.</p>\n</blockquote>\n\n<p>I could not quite understand the solution, I'll quote it:</p>\n\n<blockquote>\n  <p>On input $\\langle A \\rangle$ where $A$ is a DFA:</p>\n  \n  <ol>\n  <li><p>Mark the start state of A</p></li>\n  <li><p>Repeat until no new states get marked:</p></li>\n  <li><p>Mark any state that has a transition coming into it from any state that is already marked.</p></li>\n  <li><p>If no accept state is marked, accept; otherwise, reject.</p></li>\n  </ol>\n</blockquote>\n\n<p>My question is, what does it mean to even 'mark' something in the encoding? how do we do this? The encoding is merely a word from $\\{A,c\\}$, how would you 'mark' states?</p>\n", 'ViewCount': '37', 'ClosedDate': '2014-01-23T18:46:52.047', 'Title': 'How to mark things in the input?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-08T08:50:21.273', 'LastEditDate': '2014-01-08T08:47:21.370', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-01-08T07:09:06.683', 'Id': '19574'}{'Body': '<p>I know that <a href="https://en.wikipedia.org/wiki/Idris_%28programming_language%29" rel="nofollow">Idris</a> has dependent types but isn\'t turing complete. What can it not do by giving up Turing completeness, and is this related to having dependent types?</p>\n\n<p>I guess this is quite a specific question, but I don\'t know a huge amount about dependent types and related type systems.</p>\n', 'ViewCount': '236', 'Title': 'What can Idris not do by giving up Turing completeness?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-18T14:35:33.427', 'LastEditDate': '2014-01-08T10:31:43.087', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12668', 'Tags': '<computability><programming-languages><type-theory><dependent-types>', 'CreationDate': '2014-01-08T09:57:09.923', 'FavoriteCount': '1', 'Id': '19577'}{'Body': u'<p>Posted this question on cstheory.SE where they said to go here:</p>\n\n<blockquote>\n  <p>I read the demonstration of the Halting problem, it is done by\n  reductio ad absurdum where the push to get to the absurd is to use the\n  halting function "H(A,b)" (where A=another function, b=the A\n  parameter) as its own parameter. This proofs that can\'t exist a\n  function which takes every function including its own as parameter and\n  says if it is an infinite loop or not, but doesn\'t proof that a\n  function Z(A,b) where {A,b!=Z} (1*) can\'t exist.</p>\n</blockquote>\n\n<p>While I deleted that question I had this answer by dkuper:</p>\n\n<blockquote>\n  <p>It is easy to circumvent this problem, by giving to the functions the\n  code of a different machine which computes the same function.</p>\n  \n  <p>Say you succeeded in building your machine computing Z(a,b) which\n  works as you said. Then you still get the reductio ad absurdum, by\n  feeding to this machine the code of another machine which is\n  equivalent. This is always possible because for every machine M, there\n  are infinitely machines M\u2032 which behaves the same as M (i.e. halt on\n  exactly the same instances). So checking that the input is not\n  precisely the machine M is not enough to avoid the paradox. And\n  checking that the input does not behave the same as M is impossible.</p>\n</blockquote>\n\n<p>So, now, this doesn\'t work if we assume that the function passed as parameter has a flag (applied by the constructor) that indicates if it is the halt function.</p>\n', 'ViewCount': '85', 'Title': 'Trying to break the proof of undecidability of the halting problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-09T23:24:09.077', 'LastEditDate': '2014-01-09T23:11:05.887', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '1', 'OwnerDisplayName': 'user12708', 'PostTypeId': '1', 'Tags': '<computability><halting-problem>', 'CreationDate': '2014-01-09T17:17:52.337', 'Id': '19601'}{'Body': '<p><a href="https://github.com/gurgeh/CodeSpace">This Github repo</a> hosts a very cool project where the creator is able to, give an integer sequence, predict the most likely next values by searching the smallest/simplest programs that output that integer sequence. I was trying to approach the same idea using lambda-calculus instead of a stack-based language, but I was stuck on the enumeration of valid programs on LC\'s grammar.</p>\n\n<p>Anyway, what is the field studying that kind of idea and how can I grasp the current state-of-art?</p>\n', 'ViewCount': '94', 'Title': 'What is the field studying the search and generation of computer programs?', 'LastActivityDate': '2014-01-12T11:12:54.350', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '11547', 'Tags': '<algorithms><complexity-theory><formal-languages><computability><regular-languages>', 'CreationDate': '2014-01-09T20:37:06.207', 'Id': '19605'}{'ViewCount': '90', 'Title': 'Can $\\emptyset$ be reducible to any other language?', 'LastEditDate': '2014-01-10T15:13:43.020', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Body': '<p>While solving some question, that involved the empty set $\\emptyset$, I was really wondering, is $\\emptyset$ reducible to <em>any</em> other language, i.e., $\\emptyset \\leq A$ such that $A$ is a language over a given alphabet $\\Sigma^*$?</p>\n\n<p>I mean, one can never take $x \\in \\emptyset$, right? or am I missing anything?</p>\n\n<p>Maybe $\\emptyset \\leq \\emptyset$? because if I take a reduction $f$ such that $x \\in \\emptyset \\Leftrightarrow f(x) \\in \\emptyset$, this is always true, because $x \\in \\emptyset$ is never true and $f(x) \\in \\emptyset$ is also never true, so that function is a reduction function in the empty-concept, no?</p>\n', 'ClosedDate': '2014-02-07T06:14:13.823', 'Tags': '<computability><reductions>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-10T15:37:51.697', 'CommentCount': '3', 'AcceptedAnswerId': '19630', 'CreationDate': '2014-01-10T13:53:57.107', 'Id': '19628'}{'Body': '<p>As far as I understand, a <code>semi-decidable (recursively enumerable)</code> problem could be: </p>\n\n<blockquote>\n  <ol>\n  <li>decidable (recursive) or </li>\n  <li>undecidable (nonrecursively enumerable)</li>\n  </ol>\n</blockquote>\n\n<p>This <a href="http://stackoverflow.com/questions/9453916/why-arent-recursively-enumerable-languages-undecidable">post</a> made me wonder if this is not conventionally followed. <a href="http://stackoverflow.com/questions/9453916/why-arent-recursively-enumerable-languages-undecidable/21056763#21056763">This</a> is my answer to it and as far as I understand it is correct:</p>\n\n<blockquote>\n  <p>A semidecidable problem (or equivalently a recursively enumerable\n  problem) could be:</p>\n  \n  <p>Decidable: If the problem and its complement are both semidecidable\n  (or recursively enumerable), then the problem is decidable\n  (recursive).</p>\n  \n  <p>Undecidable: If the problem is semidecidable and its complement is not\n  semidecidable (that is, is not recursively enumerable).</p>\n  \n  <p>Important note: Remember that a decidable (recursive) problem is also\n  semidecidable (recursively enumerable). Conversely, if a problem is\n  not recursively enumerable (semidecidable), then is not recursive\n  (decidable).</p>\n  \n  <p>What the Wikipedia entry says is that:</p>\n  \n  <p>Partially decidable problems THAT ARE NOT DECIDABLE are called\n  undecidable.</p>\n  \n  <p>In general, a semidecidable problem (recursively enumerable) could be\n  decidable (recursive) or undecidable (nonrecursively enumerable).</p>\n  \n  <p>Also note that a problem and its complement could both (or just one of\n  them) be not even semi-decidable (nonrecursively enumerable). Also\n  note that, if a problem is recursive, its complement is also\n  recursive.</p>\n</blockquote>\n\n<p>Is it conventionally (always) understood this way? Is there some literature that presents semi-decidability (partially decidable, recursively enumerable) problem as an equivalent of undecidability?</p>\n', 'ViewCount': '104', 'Title': 'Can a semi-decidable problem be also decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:44.787', 'LastEditDate': '2014-01-18T20:20:44.787', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19642', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<terminology><computability><undecidability><semi-decidability>', 'CreationDate': '2014-01-11T00:45:42.170', 'Id': '19641'}{'Body': '<p><a href="http://tex.stackexchange.com/questions/128454/are-there-any-open-research-problems-in-the-world-of-tex/153131?noredirect=1#comment289410_128464">A comment over on tex.SE</a> made me wonder. The statement is essentially:</p>\n\n<blockquote>\n  <p>If I can write a compiler for language X in language X, then X is Turing-complete.</p>\n</blockquote>\n\n<p>In computability and formal languages terms, this is:</p>\n\n<blockquote>\n  <p>If $M$ decides $L \\subseteq L_{\\mathrm{TM}}$ and $\\langle M \\rangle \\in L$, then $F_L = \\mathrm{RE}$.</p>\n</blockquote>\n\n<p>Here $L_{\\mathrm{TM}}$ denotes the language of all Turing machine encodings and $F_L$ denotes the set of functions computed by machines in $L$.</p>\n\n<p>Is this true?</p>\n', 'ViewCount': '502', 'Title': 'Is any language that can express its own compiler Turing-complete?', 'LastActivityDate': '2014-01-12T14:57:59.980', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19669', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<computability><turing-completeness>', 'CreationDate': '2014-01-12T14:00:59.437', 'Id': '19667'}{'Body': "<p>This is an exercise I've been struggling with for a while: </p>\n\n<blockquote>\n  <p>Let $g : \\mathbb{N} \\to \\mathbb{N}$ be a total, non-decreasing function, i.e. $\\forall x &gt; y.\\ g(x) \\geq g(y)$. Is the image $I_g$ of $g$ a recursive set?</p>\n</blockquote>\n\n<p>Intuitively, I know that the image $I_{g}$ is not recursive, as $g$ is not strictly monotonic. In fact, it's because that $g$ is not strictly monotonic that $g$ could be a constant function so testing if $y \\in I_{g}$  may not finish as it could be that $\\forall x, g(x) = c$, $c$ being a constant s.t. $c &lt; y$. Then, testing if there is an $x$ s.t. $g(x) = y$ incrementing $x$ as the $g(x) &lt; y$ may go forever.  On the other hand, it could be that after a while, (for a sufficiently greater $x$) it happens that $g(x) &gt; c$ and $g(x) = y$. If it were stricly monotonic, though, then it would be recursive as I would be able to test if $y = g(x)$ incrementing $x$ until the equality is satisfied or $g(x) &gt; y$ (then $g(x)$ wouldn't get stuck in the same value because $x_1 &gt; x_2$ implies $g(x_1) &gt; g(x_2)$).</p>\n\n<p>However, I haven't been able to prove this formally. Can this intuition become part of a formal proof? Or at least could you give me some help in proving it in some other way? A hint or some outline of a proof would be great.</p>\n", 'ViewCount': '133', 'Title': 'Is the image of a total, non-decreasing function decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T07:35:02.383', 'LastEditDate': '2014-01-15T18:19:25.850', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '19752', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2014-01-15T01:15:56.527', 'Id': '19732'}{'Body': "<p>Given is the definition of a general problem: $\\{ \\langle M,  S\\rangle \\mid M \\text{ is a } TM, L_M \\in S\\}$. In words: Given a TM M, does M decide a language that is an element of the given set of languages S?</p>\n\n<p>I'm stuck with the following instance of that problem: $L = \\{ \\langle M \\rangle \\mid M \\text{ is a } TM, L_M \\in \\mathrm{REG}\\}$. I have found proof that it is undecidable, however I'm stuck at finding if it's recognizable (synonyms: Turing-acceptable, semidecidable, ...) or not.</p>\n\n<p>The problem in words means: Given a TM M, does the TM decide a language that is an element of REG (the set of regular languages)?</p>\n\n<p>To prove a language is not semi-decidable, I would try to prove that it's complement is semi-decidable and that the language is not decidable (which I did by reduction from the Halting-problem).</p>\n\n<p>To prove it is semi-decidable, I would prove it by reduction to the $A_{TM}$, which is semi-decidable.</p>\n\n<p>I have tried both for this problem, but I get stuck / lose my way of thinking at every try ... Some directions would be greatly appreciated!</p>\n", 'ViewCount': '134', 'Title': 'Is regularity of the language accepted by a given Turing machine a semi-decidable property?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T20:20:22.317', 'LastEditDate': '2014-01-18T20:20:22.317', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19781', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<formal-languages><computability><turing-machines><semi-decidability>', 'CreationDate': '2014-01-16T18:10:49.223', 'Id': '19769'}{'Body': "<p>I've been working on the following exercise:</p>\n\n<blockquote>\n  <p>$S = \\{ x | f_x  \\text{ is constant} \\}$. Is $S$ recursively enumerable?</p>\n</blockquote>\n\n<p>Here, $fx$ is the function computed by the $\\text{x-th TM}$. So it is a computable function.</p>\n\n<hr>\n\n<p><strong>Intuitively</strong>, I think that to check if $S$ is constant, I would have to check if $f_x$ stops for every input. That procedure would run forever. </p>\n\n<p><strong>Important:</strong> Same thing about $\\overline{S}$, if some $f_x$ is undefined for every input $y$ (it would not be constant, as far as I understand, <strong>it is constant if it has the same image for all input values</strong>) then I would not be able to list $f_x$ in an enumeration of $\\overline{S}$.</p>\n\n<p>In fact, suppose $\\forall x,fx$ is undefined. This $f_x$ is computable - a TM can be constructed that loops forever. How can you determine that $f_x$ is not constant? There will be no input for which $f_x$ halts. Therefore, we cannot check for equality of $x_1$ and $x_2$ to determine that is not constant. Then, we can't list this $TM_x$ in the enumeration. </p>\n\n<p>A solution in which this $f_x$ was put at the beginning of the enumeration was suggested. But there are infinitely many $TMs$ that are undefined for all inputs. Consequently, I can't put them at the beginning of the enumeration as other $TMs$ won't be enumerated.</p>\n\n<hr>\n\n<p><strong>I tried to</strong> reduce the <em>Halting Problem</em> to this problem without success. I believe that both $S$ and $\\overline{S}$ are not r.e. (see my intuitive thoughts above).</p>\n\n<p>How would you solve this problem?</p>\n", 'ViewCount': '136', 'Title': u'Is the set of G\xf6del numbers of computable constant functions recursively enumerable?', 'LastEditorUserId': '11974', 'LastActivityDate': '2014-01-19T14:53:34.650', 'LastEditDate': '2014-01-19T14:53:34.650', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19784', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<computability><semi-decidability>', 'CreationDate': '2014-01-17T02:56:45.933', 'Id': '19776'}{'ViewCount': '70', 'Title': 'Understanding a proof for the existance of a non-computable function', 'LastEditDate': '2014-01-18T10:06:25.117', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12924', 'FavoriteCount': '1', 'Body': "<p>For school, we have a proof that some functions are not Turing computable.\nThe example is:\n$$ G(k) = \\begin{cases} f_k(k) + 1 &amp; \\text{ if $f_k(k)$ is defined}, \\\\ 1 &amp; \\text{ otherwise}.\\end{cases} $$</p>\n\n<p>Claim: $G$ is non computable.</p>\n\n<p>Proof: In view of obtaining a contradiction, let's say $G$ is computable, say by the $k$th Turing machine.\nGive the encoding of this $k$th Turing machine as an argument for $G$.\nThis leads to a contradiction: if $f_k(k)$ is defined, then $f_k(k)$ is not equal to $g(k) = f_k(k) + 1$. Else $f_k(k)$ is undefined and not equal to $g(k) = 1$.</p>\n\n<p>I don't understand the contradiction, help please...</p>\n", 'Tags': '<computability><turing-machines><undecidability>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-18T10:06:25.117', 'CommentCount': '4', 'AcceptedAnswerId': '19793', 'CreationDate': '2014-01-17T18:17:02.093', 'Id': '19788'}{'Body': '<p>I read a proof on the closure of decidable languages under kleene star. It begins by saying that the turing machine we want to find would non-determistically split the input string and then use the original decider of the language to approve the partition of each branch.</p>\n\n<p>My question is, I can\'t understand how we can do this non-deterministic split on a word whose length we do not yet know. if the word is very big then there exist more partitions, thus more branches are needed.</p>\n\n<p>So, i don\'t understand how this "non-deterministic split" can be materialized. </p>\n\n<p>Also, if someone has another proof of this closure via turing machines it will be more than welcome!</p>\n', 'ViewCount': '194', 'Title': 'Decidable languages kleene star closure - question on a proof', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T13:59:37.270', 'LastEditDate': '2014-01-18T19:29:21.573', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19813', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12948', 'Tags': '<computability><turing-machines><closure-properties><nondeterminism>', 'CreationDate': '2014-01-18T18:43:45.827', 'Id': '19811'}{'Body': "<blockquote>\n  <p>Let $h$ be a total computable function. Is $S = \\{x \\mid f_x \\neq h\\}$\n  recursively enumerable?</p>\n</blockquote>\n\n<p>Originally this was an exercise that restricted $h$ to: $h(x) = x + 1$ . However, it can be formulated as a more general case.</p>\n\n<p>By Rice's Theorem, it is not recursive. Intuitively, </p>\n\n<ul>\n<li><p>$S$ is not r.e. as if it was, it would mean that we would know that\n$f_x(y)$ halts for some input $y$ in order to check if it has a different image of $h(y)$.</p></li>\n<li><p>$\\overline{S}$ is not r.e. as if it was, we would be able to check if $f_x(y)\n   = h(y)$ for every input $y$ (we would check equality for infinite inputs).</p></li>\n</ul>\n\n<p>How would you solve this problem?</p>\n\n<p><strong>Note:</strong> I tried something, but I'll post it as an answer. Some thoughts would be great and really helpful. Any approach to this problem using reduction or diagonalization methods would be useful.</p>\n", 'ViewCount': '101', 'Title': 'Is the set of programs that compute some function other than $h$ recursively enumerable?', 'LastEditorUserId': '11974', 'LastActivityDate': '2014-02-12T20:54:26.437', 'LastEditDate': '2014-01-19T17:14:35.563', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11974', 'Tags': '<computability><reductions><semi-decidability>', 'CreationDate': '2014-01-18T20:07:54.740', 'Id': '19815'}{'Body': '<p>Given the problem $EQ_{TM} = \\{ \\langle M_1,  M_2\\rangle \\mid M_1 \\text{ and } M_2 \\text{ are } TM, L_{M_1} = L_{M_2}\\}$, is it possible to prove that this is undecidable by using (a variant of) Rice theorem?</p>\n\n<p>I have proven this problem by reduction to $E_{TM}$, but was wondering if it was easier to do with Rice.</p>\n', 'ViewCount': '65', 'Title': 'Is it possible to prove EQTM is undecidable by the Rice theorem?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-21T22:47:38.397', 'LastEditDate': '2014-01-21T22:47:38.397', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19877', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12902', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2014-01-21T19:17:43.390', 'Id': '19876'}{'Body': '<p>What is the point of non-binary printed letters on a turing machine? I understand that these need to be omitted to get a computable number, but why are they used in the first place?</p>\n', 'ViewCount': '75', 'Title': 'Why have additional symbols on a Turing machine?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T20:43:54.103', 'LastEditDate': '2014-01-23T18:10:25.883', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '19918', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-01-23T16:19:54.903', 'Id': '19916'}{'Body': "<blockquote>\n  <p>Prove/disprove: $\\exists L \\in RE/R$ such that $L^R \\cup L \\in R$</p>\n</blockquote>\n\n<p>Where in my context, $R$ is the turing decidable, and $RE$ is the recursively enurmable. I tried to find such an $L$ but couldn't. What I know for sure is that I need a language in $RE/R$ such that $L \\cup L^R = \\Sigma^*$, or am I also wrong?</p>\n", 'ViewCount': '31', 'Title': '$L \\in RE/R$ such that $L^R \\cup L \\in R$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:25:59.020', 'LastEditDate': '2014-01-25T16:25:59.020', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19954', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<formal-languages><computability>', 'CreationDate': '2014-01-24T22:31:42.317', 'Id': '19950'}{'Body': u'<p>I have this question about if the decidability of an regular expression and would appreciate if someone can check my answer and see if it makes sense, and if not, what is missing.</p>\n\n<blockquote>\n  <p>Be A = {(R)|R it is a regular expression that describes a language containing at least a w string that has 111 as a substring (that it is, w=x111y to some x and some y)}. Show that A it is decidible</p>\n</blockquote>\n\n<p>Answer: Create a turing machine P, this machine receives a pair where R is the regular expression in question and W is the set of all the strings of the form x111y. P converts R into a NFA called NFAR. It sends the pair to a TM N that acts as a subrotine of it. N will convert NFAR into a DFA called DFAR. Then inside this machine N, there is a turing machine M inside it, also acting as a subrotine. It sends the pair to M. When M receives its input, it will first determines whether it properly represents a DFA DFAR an a set of strings W. If not, it will reject, and as a result, so will N and then P. Otherwise, It will start to simulate DFAR over the first string w(i) of W (where i=0,1,2... n\xb0 last input string). If DFAR accepts, M halts in the accept state, and so will N and then P. Otherwise M will continue to loop through all the strings of W. If it reaches the last w(i) and it is not accepted, M will halt in the refect state and so will N and then P.</p>\n\n<p>My fear is that the number of strings to be tested is infinite, so M could enter in a loop?</p>\n', 'ViewCount': '52', 'Title': 'Decidability of an regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:29:41.253', 'LastEditDate': '2014-01-25T16:29:41.253', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13113', 'Tags': '<computability><regular-languages><undecidability>', 'CreationDate': '2014-01-24T23:42:36.657', 'Id': '19952'}{'ViewCount': '60', 'Title': 'Is it possible to encode an arbitrary computation as a series of NP complete problem instances?', 'LastEditDate': '2014-01-25T16:40:32.763', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13118', 'Body': '<p>For example, can I make a compiler that transforms a C program (Turing complete language) into a bunch of SAT instances.</p>\n\n<p>This encoding would be motivated as a way for specifying a problem piecemeal, where work on each piece could be verified in polynomial time.</p>\n', 'ClosedDate': '2014-02-02T11:29:06.923', 'Tags': '<complexity-theory><computability><np-complete>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T18:14:48.120', 'CommentCount': '6', 'AcceptedAnswerId': '19964', 'CreationDate': '2014-01-25T03:49:36.860', 'Id': '19960'}{'Body': "<p>This is a question from an exam I did today:</p>\n\n<blockquote>\n  <p>Given $M$, a turing machine, we need to decide the following:</p>\n  \n  <p>1) $M$ halts on every input</p>\n  \n  <p>2) The language of $M$ is CFL</p>\n</blockquote>\n\n<p>My question is, can I prove that this problem is not in $RE$ (recursively enumerable) using Rice's theorem? I understand that Rice's theorem works for languages and not machines, and when first looking at it, number 1 is a property of a machine not the language. But what I said, is that actually it <em>is</em> a property of a language: $M$ halts on every input <em>iff</em> $L(M)$ is decidable! (in $R$), so we can use Rice.</p>\n\n<p>What do you think?</p>\n", 'ViewCount': '77', 'Title': "Proving that context-freeness of $L(M)$ is not semi-decidable using Rice's theorem", 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-27T17:52:40.573', 'LastEditDate': '2014-01-26T16:49:27.393', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11424', 'Tags': '<computability><semi-decidability>', 'CreationDate': '2014-01-26T15:32:15.463', 'Id': '19997'}{'ViewCount': '119', 'Title': 'Why is the halting problem unsolvable by a turing machine?', 'LastEditDate': '2014-01-30T15:21:08.293', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13245', 'FavoriteCount': '1', 'Body': "<p>So my knowledge of CS is amateurish at best but to me, logically, it seems like the halting problem is solvable.</p>\n\n<p>So any human can determine if a problem halts with rigorous inspection, so why can't a very advanced, say human AI, solve the halting problem?</p>\n\n<p>Also, is there a machine, say more powerful than a turing machine, that can solve this problem?</p>\n\n<p>PS: I might be making some bad assumptions, please point that out if so.</p>\n", 'ClosedDate': '2014-02-11T11:06:09.057', 'Tags': '<computability><halting-problem>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T15:32:51.337', 'CommentCount': '3', 'AcceptedAnswerId': '20111', 'CreationDate': '2014-01-30T14:22:09.677', 'Id': '20109'}{'ViewCount': '392', 'Title': 'Why is the class of recursively enumerable languages not closed under complementation?', 'LastEditDate': '2014-02-04T11:38:24.893', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9987', 'FavoriteCount': '1', 'Body': '<p>I am having a hard time understanding closure properties of recrusively enumerable languages. I have read the explanation on <a href="http://www.eecs.wsu.edu/~cook/tcs/l19.html" rel="nofollow">this site</a> but still unable to fully understand why they are not closed under complementation?</p>\n\n<p>Explanation also says,</p>\n\n<blockquote>\n  <p>This fails because $M$ only needs to halt if $w \\in L(M)$ - doesn\'t have to say "no".</p>\n</blockquote>\n\n<p>What does it mean?</p>\n', 'Tags': '<computability><closure-properties><semi-decidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T23:26:26.210', 'CommentCount': '2', 'AcceptedAnswerId': '21285', 'CreationDate': '2014-02-04T11:23:23.813', 'Id': '21284'}{'ViewCount': '18', 'Title': 'Decidability of fullness of intersection of a CSL with a regular language', 'LastEditDate': '2014-02-06T16:30:23.490', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'vzn', 'PostTypeId': '1', 'OwnerUserId': '699', 'Body': '<p>Let $L_r$ be a regular language with alphabet $\\Sigma$ and $L_{\\text{csl}}$ be a context sensitive language. Are any of the following questions decidable?</p>\n\n<ol>\n<li>$L_r \\cap L_\\text{csl} \\stackrel{?}{=} L_r$</li>\n<li>$\\Sigma^* \\cap L_\\text{csl} \\stackrel{?}{=} L_r$</li>\n<li>$L_r \\cap L_\\text{csl} \\stackrel{?}{=} \\Sigma^*$</li>\n<li>$\\Sigma^* \\cap L_\\text{csl} \\stackrel{?}{=} \\Sigma^*$</li>\n</ol>\n\n<p>I understand that (1) implies the others. I am also looking for any "near variants" that might be decidable.</p>\n', 'Tags': '<formal-languages><computability><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T16:30:23.490', 'CommentCount': '0', 'AcceptedAnswerId': '21384', 'CreationDate': '2014-01-18T17:05:04.703', 'Id': '21383'}{'ViewCount': '107', 'Title': 'Determining if a context-free grammar produces even-length strings', 'LastEditDate': '2014-02-06T21:11:48.003', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14447', 'Body': '<p>Given a context-free grammar, is there an algorithm to determine if the CFG will ever produce an even length string? Or is this undecidable?</p>\n', 'ClosedDate': '2014-02-15T04:33:24.287', 'Tags': '<computability><context-free><formal-grammars><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T21:11:48.003', 'CommentCount': '1', 'AcceptedAnswerId': '21396', 'CreationDate': '2014-02-06T17:46:33.243', 'Id': '21390'}{'Body': "<p>I am working on a homework question, where I have to show a property P is trivial.</p>\n\n<p>This problem has to do with Rice's Theorem, which I do not completely understand. Can someone explain the difference between trivial and non-trivial properties?</p>\n", 'ViewCount': '141', 'Title': "What's a trivial property?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T07:38:54.810', 'LastEditDate': '2014-02-07T07:38:54.810', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21399', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<terminology><computability>', 'CreationDate': '2014-02-06T19:17:14.787', 'Id': '21398'}{'Body': '<p>I am reducing a given Turing Machine to the complement of the known undecidable problem, \n$$ Complement(A_{TM}) = \\{ \\langle M,w \\rangle \\mid M  \\text{ is TM}, w \\not\\in L(M) \\}$$</p>\n\n<p>To this Turing Machine, known as SPARSE TM:\n$$\nSPARSE_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ is 1-tape TM}, |L(M)| \\leq 1000\\} \n$$</p>\n\n<p>Here is what I have so far, but I think I need help because one of the statements I make seems fishy.</p>\n\n<p>Assume there is a TM <code>S</code> that decides the complement of the accept TM and a TM <code>R</code> that decides SPARSE. Then <code>S</code> looks like:</p>\n\n<pre><code>S = "On input `&lt;M,w&gt;`:\n    Construct M\':\n        M\' = "On input x:\n            if x in L(M):  #Fishy statement\n                accept\n            else: reject\n     Run R on &lt;M\'&gt;\n     if R accepts: accept; if R rejects: reject\n</code></pre>\n\n<p>This (if right) would then reduce the SPARSE TM and prove that it is undeciable, right? Any help would be appreciated.</p>\n', 'ViewCount': '89', 'Title': 'Reduction to complement of Accept Problem', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T00:25:49.743', 'LastEditDate': '2014-02-06T21:17:23.187', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21410', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12971', 'Tags': '<computability><turing-machines><reductions><undecidability>', 'CreationDate': '2014-02-06T20:30:09.477', 'Id': '21400'}{'ViewCount': '117', 'Title': 'The minimization operator is an effective operator', 'LastEditDate': '2014-02-12T18:58:57.467', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Student', 'PostTypeId': '1', 'OwnerUserId': '11762', 'Body': u'<p>Assume $\\{f_i^{(n)}\\}_{i=0}^\\infty$ is a G\xf6del enumeration of the $\\mu$-recursive functions of $n$ arguments, such that the $S^m_n$ theorem and the universal function theorem hold. Denote the set of (total and partial) functions $\\{f:\\mathbb N^k\\to\\mathbb N\\\n\\}$ by $\\mathfrak F^k$</p>\n\n<p><strong>Definition:</strong> We call an operator $G:\\mathfrak F^n\\to\\mathfrak F^k$ effective, if $(\\forall j\\in\\mathbb N)(G(f^{(n)}_j)=f^{(k)}_{g(j)})$ for some total recursive function $g$.</p>\n\n<p><strong>Claim:</strong> The minimization operator $\\mu:\\mathfrak F^{k+1}\\to\\mathfrak F^k$ defined by $$\\mu(f)(\\overline x)=\\mu y[f(y,\\overline x)=0]=y\\iff (f(y,\\overline x)=0\\land(\\forall i&lt;y) (f(i,\\overline x)&gt;0))$$ is an effective operator.</p>\n\n<p><strong>Question:</strong> How can I go about proving the statement? Hints are welcome.</p>\n\n<p><strong>Thought:</strong> By definition the $\\mu$-recursive functions are closed with respect to the $\\mu$-operator. Therefore, $\\mu(f^{(k+1)}_j)=f^{(k)}_{h(j)}$, for some unique total function $h$. But why is $h$ a computable function?</p>\n\n<p>Note that I would really like to stay within the Partial Recursive Functions Formalism. Pseudo code means nothing to me. I cannot read it. I am not familiar with most of the notation from the programming world. I would also prefer not go into Register Machine Formalisms.</p>\n', 'Tags': '<computability><recursion><mu-calculus>', 'LastEditorUserId': '11762', 'LastActivityDate': '2014-02-12T18:58:57.467', 'CommentCount': '6', 'AcceptedAnswerId': '21529', 'CreationDate': '2014-02-10T10:04:12.157', 'Id': '21509'}{'Body': "<p>Is there a way to show that for all <em>finite</em> sets $S$ of context free grammars, there exists a Turing Machine $M$ such that for all grammars $G_1, G_2 \\in S$, we have that $M(G1,G2)$ terminates and answer yes if and only if $L(G_1)=L(G_2)$? Is that even true?</p>\n\n<p>I know that this problem is in general undecidable, but I also know that a finite set is in general decidable. I just can't figure out how to determine the answer for this problem.</p>\n", 'ViewCount': '85', 'Title': 'Is equivalence of CFGs decidable for finite sets of grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T17:25:01.883', 'LastEditDate': '2014-02-12T08:32:58.760', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '21542', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14581', 'Tags': '<computability><undecidability>', 'CreationDate': '2014-02-11T20:07:00.393', 'Id': '21537'}{'Body': '<p>Nobody yet knows if ${\\sf P}={\\sf NP}$. Let us consider the following language</p>\n\n<p>$$L = \\begin{cases} (0+1)^* &amp; \\text{ if ${\\sf P}$ = ${\\sf NP}$} \\\\ \\emptyset &amp;\\text{ otherwise}. \\end{cases}$$</p>\n\n<p>A language is said to be recursive if there exists any rule to determine whether a string belong to language or not. We have a rule here, but the rule itself depends upon an unknown equation. So can we say $L$ is recursive?</p>\n', 'ViewCount': '121', 'Title': 'Is this language depending on P = NP recursive?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-26T05:55:59.580', 'LastEditDate': '2014-02-25T20:21:10.610', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12234', 'Tags': '<computability><undecidability><p-vs-np>', 'CreationDate': '2014-02-25T08:55:19.393', 'Id': '22017'}{'Body': '<p>If a set S is infinite and recognizable, how can I prove that, if any, some subsets K is infinite and decidable? how about infinite and recognizable? </p>\n', 'ViewCount': '99', 'Title': 'If a set S is infinite and recognizable, is there an infinite subset of S that is decidable?', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-26T06:17:08.517', 'LastEditDate': '2014-02-26T03:12:43.210', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22041', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15045', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-02-26T01:43:35.303', 'Id': '22039'}{'Body': "<p>Here is the problem:</p>\n\n<p>Prove the single-tape TM that cannot write on the portion of the tape containing the input string recognize only regular language. </p>\n\n<p>My idea is to prove that this particular TM is equivalent to DFA. </p>\n\n<p>Using this TM to simulate DFA is very straightforward. </p>\n\n<p>However, when I want to use this DFA to simulate TM, I encounter the problem. For the TM transition $\\delta(q,a)=(q',a,R)$, DFA can simulate definitely by reading tape to the right and doing the same state transition. </p>\n\n<p>For $\\delta(q,a)=(q',a,L)$, I cannot figure out how to use this DFA or NFA to simulate the left move because the DFA only reads to left and has no stack or something to store.</p>\n\n<p>Should I consider another way? Could anyone give me some hints? Thanks. </p>\n", 'ViewCount': '56', 'Title': 'Prove Single-Tape and Non-write Turing Machine can Only Recognize Regular Language?', 'LastActivityDate': '2014-02-27T06:41:33.020', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><computability><regular-languages><turing-machines><automata>', 'CreationDate': '2014-02-27T06:41:33.020', 'Id': '22082'}{'Body': "<p>I understand what Rice's theorem states and what Trivial and Non-trivial properties mean. However, when given some property, I am having a hard time seeing if it is Trivial or Non-trivial. Can someone help me understand this better, maybe with some good examples? </p>\n", 'ViewCount': '47', 'ClosedDate': '2014-02-28T08:43:26.950', 'Title': 'How do you classify properties as Trivial and Non-trivial?', 'LastActivityDate': '2014-02-27T20:25:49.257', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22108', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13077', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-02-27T20:16:14.457', 'Id': '22106'}{'ViewCount': '54', 'Title': 'Regarding Turing Machine Halting Problem', 'LastEditDate': '2014-03-09T19:51:40.390', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13053', 'FavoriteCount': '1', 'Body': "<p>All problems solved by standard today's general purpose computer can be solved by standard Turing machine.As general purpose computer can't do more than Turing machine so The Turing machine halting problem must also be  unsolved by today's general purpose computer.How can I realize the fact that halting problem can't be solved by todays general purpose computers.</p>\n", 'ClosedDate': '2014-03-09T22:12:51.443', 'Tags': '<computability><turing-machines><halting-problem>', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-09T19:54:26.980', 'CommentCount': '5', 'CreationDate': '2014-03-09T06:34:28.180', 'Id': '22420'}{'ViewCount': '74', 'Title': 'Can Turing Machines decide on computability?', 'LastEditDate': '2014-03-13T09:35:34.547', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15625', 'FavoriteCount': '1', 'Body': '<p>Can a Turing Machine decide whether an arbitrary real number is computable or not? Does this even follow from the solution of the Halting problem? If not, who proved it?</p>\n', 'ClosedDate': '2014-04-02T13:17:36.307', 'Tags': '<computability><turing-machines><real-numbers>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-13T09:35:34.547', 'CommentCount': '2', 'CreationDate': '2014-03-13T02:49:08.490', 'Id': '22570'}{'Body': "<p>I'm an undergraduate just beginning to read about reversible computing. I know that, because of Landauer's principle, irreversible computations dissipate heat (and reversible ones do not). I brought it up with my professor, who had never heard of reversible computing before, and he was having difficulty understanding why the theory of reversible computing was not trivial.</p>\n\n<p>His point was just that you can always save the input, i.e. for any function $f: \\{ 0, 1 \\}^n \\rightarrow \\{ 0, 1 \\}^n$ that you wish to make reversible, define a new function $f_{reversible}: \\{ 0, 1 \\}^n \\rightarrow \\{0, 1 \\}^{2n}$ (or $\\{ 0, 1 \\}^{2n} \\rightarrow \\{0, 1 \\}^{2n}$ and you just put $0$s in for the last $n$ bits of the input) which returns the output in the first $n$ bits and the input in the other $n$ bits. Then in order to invert $f_{reversible}$ you just discard the output and return the input that you saved.</p>\n\n<p>My immediate objection was that this takes more memory than the original function did -- though only by a constant factor. Constraining the output to $n$ bits would seem to restore the interesting-ness of the problem, though. Is this what is usually meant by reversible computing?</p>\n\n<p>Another objection seemed to be that when we discard the output, we're doing something irreversible which is going to dissipate heat. But we correctly recovered the initial state, so how could it be irreversible? I don't know enough physics to understand whether the important thing w/r/t heat is just for the entire computation to be reversible, or whether every step needs to be reversible as well, or if this idea is just up the wrong tree.</p>\n", 'ViewCount': '602', 'Title': 'What\'s flawed about the "save-the-input" method of reversible computing?', 'LastActivityDate': '2014-03-13T05:50:12.600', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22575', 'Score': '8', 'OwnerDisplayName': 'Eli Rose', 'PostTypeId': '1', 'OwnerUserId': '15627', 'Tags': '<computability>', 'CreationDate': '2014-03-13T05:13:38.303', 'FavoriteCount': '0', 'Id': '22573'}{'Body': "<p>Hello everyone just like the title says I want to prove that $H(x) = \\mu y T(x,x,y)$ has no total computable extension such that if we had a function $BIG(x)$ that is both total and agrees with $H(x)$ whenever $H(x)$ is defined, then $BIG(x)$ is not computable. This is a homework question so I don't want a full solution just some help! </p>\n\n<p>$\\bf{NOTE}:$ The predicate $T(y,x,z)$ means that it holds iff program $y$ takes an input $x$ (could be $n$-ary) and has a computational history z! This is supposed to be the Kleene T predicate basically.  </p>\n\n<p>The function $H(x)$ I believe returns the smallest computational history $y$ such that a program $\\{x\\}(x)$ (program takes input of its own configuration and runs) runs and halts, since $\\mu y R(x,y)$ means the smallest $y$ such that $R(x,y)$ holds. Maybe I am not quite clear what it means for $BIG$ to agree with $H(x)$ or what it's own input. I think I need to create a diagonal function that uses $BIG$ if $BIG$ was computable and show that if I had some program $e$ then it must agree with $BIG$ but based on my definition of that diagonal function it isn't. If you are reading this you might see the mess of my thinking, any help would be greatly appreciated!</p>\n", 'ViewCount': '47', 'Title': 'Using diagonal argument to prove that $H(x) = \\mu y T(x,x,y)$ has no total computable extension', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-14T09:35:23.657', 'LastEditDate': '2014-03-14T09:35:23.657', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10880', 'Tags': '<computability><mu-calculus>', 'CreationDate': '2014-03-14T01:01:26.327', 'Id': '22601'}{'Body': '<p>In the <a href="http://en.wikipedia.org/wiki/Kleene%27s_recursion_theorem#Rogers.27_fixed-point_theorem" rel="nofollow">Wikipedia article on Rogers\' theorem</a>, it is stated that all total computable functions have a fixed point.  The notation is a little hard for me to understand; a symbol is used that is used to denote "semantic equivalence."  I do not know what semantic equivalence is; I would appreciate it if someone could shed some light on what a fixed point is in this context, and on what semantic equivalence is in this context.</p>\n', 'ViewCount': '192', 'Title': "What is a fixed point in the context of Roger's fixed-point theorem?", 'LastActivityDate': '2014-03-16T21:29:51.707', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '22685', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7317', 'Tags': '<computability>', 'CreationDate': '2014-03-16T19:03:39.333', 'FavoriteCount': '1', 'Id': '22684'}{'Body': "<p>I am studying for my algorithms final and came across the following problem:</p>\n\n<p>Find three languages $L_1 \\subset L_2 \\subset L_3$ over the same alphabet such that $L_2 \\in P$ and $L_1,L_3$ are undecidable.</p>\n\n<p>I am having trouble coming up with an example of three such languages. My first thought was to use a form of the halting problem for both $L_1$ and $L_3$ since that is pretty much the only undecidable language I know and am familiar with. I was thinking of perhaps coming up with something of the form \n\\begin{align*}\nL_1 &amp;= \\{M \\mid \\text{$M$ is a Turing machine that starts with 00 and halts}\\}\\\\\nL_2 &amp;= \\{M \\mid \\text{$M$ is a Turing machine that starts with a 00}\\}\\\\\nL_3 &amp;= ?\n\\end{align*}\nbut this doesn't seem to be working.  Any ideas are appreciated!</p>\n", 'ViewCount': '468', 'Title': 'Sandwiching Languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T07:51:13.653', 'LastEditDate': '2014-03-18T07:51:13.653', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22737', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '15615', 'Tags': '<formal-languages><computability><undecidability>', 'CreationDate': '2014-03-18T00:29:05.380', 'Id': '22735'}{'Body': "<p>Given some unrecognizable language $L$, is it possible for its complement $\\overline{L}$ to also be unrecognizable?</p>\n\n<p>If some other language $S$ and its complement $\\overline{S}$ are both recognizable, then $S$ and $\\overline{S}$ are decidable. If $\\overline{S}$ is unrecognizable, then then $S$ is undecidable but still recognizable. Why do we ignore the idea that $S$ and $\\overline{S}$ may both be unrecognizable? This implies that $\\exists! s \\in S \\cup \\overline{S} = \\Sigma^*$ on which no machine halts, otherwise I don't see why we cannot have $x,y \\in \\Sigma^*$ and $x \\neq y$ such that no machine halts on $x$ or $y$, where $x \\in S$ and $y \\in \\overline{S}$.</p>\n\n<p>Perhaps I am making a false assumption somewhere?</p>\n", 'ViewCount': '397', 'Title': 'Is it possible for a language and its complement to both be unrecognizable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-19T21:31:45.540', 'LastEditDate': '2014-03-19T21:31:45.540', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '22818', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<computability><semi-decidability>', 'CreationDate': '2014-03-19T17:45:45.283', 'Id': '22814'}{'Body': '<p>I would like to show that the following language is recognizable:\n$$L:= \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on some string}\\}.$$</p>\n\n<p>How do I go about showing that this language is recognizable? I know that all recognizable languages are reducible to $HALT_\\epsilon$, so I figure if I can show that this language reduces to $HALT_\\epsilon$, then I am all set. I am defining $HALT_\\epsilon$ as follows:</p>\n\n<p>$$HALT_\\epsilon:= \\{ \\langle M \\rangle \\mid M \\text{ is a TM that halts on } \\epsilon \\},$$</p>\n\n<p>where $\\epsilon$ is the empty string. We can reduce $HALT$ on $x$ to $HALT_\\epsilon$ by a reduction $F(\\langle M, x\\rangle) = \\langle M\' \\rangle $, where $M\'(y) = M(x)$. For this reduction, we just ignore the input string $y$, which we know will be $\\epsilon$ and just run $M$ on $x$ instead. Here, $HALT$ is defined as</p>\n\n<p>$$HALT:= \\{ \\langle M,x \\rangle \\mid M \\text{ is a TM that halts on } x \\}.$$</p>\n\n<p>I tried leveraging a similar technique to show that $L$ is recognizable, but I could not come up with anything better than this (somewhat crazy) TM that has a $HALT_\\epsilon$ oracle:</p>\n\n<p>$ D^{HALT_\\epsilon} =$ On input $\\langle M \\rangle:$</p>\n\n<ol>\n<li>Construct $N = $ "On input $x:$\n<ol>\n<li>Run $M$ in parallel on all inputs $y\\in \\Sigma^*$.</li>\n<li>If $M$ halts on any $y$ then <em>accept</em>, otherwise <em>loop.</em>"</li>\n</ol></li>\n<li>Query the oracle to determine whether $\\langle N \\rangle \\in HALT_\\epsilon$.</li>\n<li>If the oracle answers YES, <em>accept</em>; if NO, <em>reject</em>.</li>\n</ol>\n\n<p><em>Note: My notation for TM algorithms is based on "Theory of Computation" by Sipser.</em> Step 2 for the definition of $N$ is a bit redundant, but in this type of context, is it okay to say something like "If $M$ halts on any $y$, then halt?"</p>\n\n<p>I think all I have shown here is that $L$ is decidable relative to $HALT_\\epsilon$. I don\'t know if this implies that $L$ is recognizable. Can a Turing reduction be used in this manner to show that a language is recognizable? I\'m confused as to what it means for a language to be recognizable. The task seems obvious if we go back to the definition: If some TM $R$ accepts strings in $L$, then $R$ recognizes $L$. So what if $R=D^{HALT_\\epsilon}$, and in the body of $D^{HALT_\\epsilon}$ we use some crazy reduction like $N$?</p>\n\n<p>In general, to show recognizability, can we just come up with a reduction like $N$ that may or may not halt? Is it a problem that $N$ will never halt if $\\langle M \\rangle \\notin L$?</p>\n', 'ViewCount': '48', 'Title': 'Is the language of TMs that halt on some string recognizable?', 'LastEditorUserId': '15660', 'LastActivityDate': '2014-03-22T17:05:52.690', 'LastEditDate': '2014-03-22T17:05:52.690', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22935', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<computability><turing-machines>', 'CreationDate': '2014-03-22T06:02:02.640', 'Id': '22929'}{'ViewCount': '84', 'Title': 'Computing the intersection of two NPDA where it is possible', 'LastEditDate': '2014-03-27T08:34:24.147', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '863', 'FavoriteCount': '1', 'Body': '<p>Apropois to Raphael\'s suggestion on <a href="http://cs.stackexchange.com/questions/23056/intersection-of-two-npdas">Intersection of two NPDAs</a>:</p>\n\n<p>Let $A_1$ and $A_2$ NPDA for context-free languages $L_1$ and $L_2$, respectively. Assuming that we know that $L = L_1 \\cap L_2$ is context-free, can we (effectively) construct NPDA $A$ for $L$?</p>\n\n<p>Any type of algorithm would be acceptable, but the more practical the better.</p>\n', 'Tags': '<computability><automata><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T10:20:05.773', 'CommentCount': '5', 'AcceptedAnswerId': '23587', 'CreationDate': '2014-03-27T01:19:07.693', 'Id': '23111'}{'Body': '<p>In proofs of decidability, we often want to simulate another model of computation by a Turing machine. But if I can simulate a $\\mathsf{DFA}$ by, say, a C program, then is there some result which says that the $\\mathsf{DFA}$ can be simulated by some $\\mathsf{TM}$? Could a program be used in place of a $\\mathsf{TM}$ in a proof of decidability?</p>\n\n<p>I know that Java being Turing-complete would mean that it can simulate any $\\mathsf{TM}$, so this is sort of the reverse of Turing-completeness I guess.</p>\n', 'ViewCount': '117', 'Title': 'If a DFA can be simulated by a real program, can it be simulated by a TM', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-30T11:36:35.010', 'LastEditDate': '2014-03-29T21:15:13.643', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '23230', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12588', 'Tags': '<computability><simulation><turing-completeness>', 'CreationDate': '2014-03-29T19:26:11.393', 'Id': '23228'}{'Body': "<p>In mathematics , an $n$-ary relation is subset of cross product on $n$ sets took under consideration.</p>\n\n<p>Let us take $A_1,A_2,A_3 \\cdots A_n$ be the n sets.</p>\n\n<p>Then relation $R \\subseteq A_1\\times A_2\\times A_3 \\times A_n$ .</p>\n\n<p>Here $X$ represents cross product betwen two sets.</p>\n\n<p>If we consider first $k$ sets as input domain and next $n-k$ sets as output range. </p>\n\n<p>Then $R$ is an $k$-ary function that returns $n-k$ multiple outputs. $0 \\le k \\le n$</p>\n\n<p>As we know function is a well-behaved relation. i.e.., A relation can assign same input to any number of outputs.</p>\n\n<p>In the case of functions (well-beahaved relations)  one input at most maps to one output.</p>\n\n<p>My doubt is whether </p>\n\n<ol>\n<li><p>Any program written in any program language ultimately a mathematical relation.</p></li>\n<li><p>Any program written in any program language ultimately a mathematical function.</p></li>\n<li><p>Some programs written in programming languages cannot be a mathematical relation.</p></li>\n<li><p>Some programs written in programming languages cannot be a mathematical function.</p></li>\n</ol>\n\n<p>We know that 2. $\\implies$ 1. and 3. $\\implies$ 4.</p>\n\n<p>Which of the four arguments above are true for all set of programs in all programming languages?</p>\n\n<p>I am arguing with my colleague that 1.,2. are true independent of programming language and program. </p>\n\n<p>But his argument is that procedural languages like c, c++, pascal etc.., doesn't obey 2. but in case of functional programming languages like Haskell it's true.</p>\n\n<p>So, is  functional programming is syntactical extension of mathematical functions or conceptual extension? </p>\n", 'ViewCount': '70', 'Title': 'Mathematical function vs Computer program', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-13T10:08:41.727', 'LastEditDate': '2014-04-13T10:08:41.727', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23730', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '16721', 'Tags': '<terminology><computability><programming-languages><functional-programming>', 'CreationDate': '2014-04-13T04:36:03.103', 'Id': '23725'}{'Body': "<p>In Sipser's Introduction to the Theory of Computation, there is an exercise that asks to prove $T$ decides $A_{TM}$, which is the language </p>\n\n<p>$$A_{TM} = \\{ \\langle M,w \\rangle | M \\text{ is a TM and $w \\in L(M)$}\\}.$$</p>\n\n<p>$T$ is a TM defined as follows. On input $\\langle M,w \\rangle$,</p>\n\n<ol>\n<li>Write the description of a TM $R$ that works as follows. On input $x$,\n<ul>\n<li>Run $T_A$ on $x$.</li>\n<li>If $T_A$ accepts $x$ then accept.</li>\n<li>If $T_A$ rejects $x$ then run $M$ on input $w$ and accept if $M$ does.</li>\n</ul></li>\n<li>Run $P$ on input $\\langle R \\rangle$, accept if $P$ rejects and reject if $P$ accepts.</li>\n</ol>\n\n<p>Here:</p>\n\n<ul>\n<li>$T_A$ is a TM that decides the language $A$.</li>\n<li>$P$ is a TM that can decide the language\n$$  Z = \\{\\langle M\\rangle | M\\text{ is a TM and } L(M) = A\\}. $$   </li>\n<li>$ A = \\{(0 \\cup 1)^a(1 \\cup 2)^b(2 \\cup 3)^c | a \\geq b\\} $.</li>\n</ul>\n\n<p>How can you prove that $T$ decides $A_{TM}$ ?</p>\n", 'ViewCount': '23', 'ClosedDate': '2014-04-14T07:50:11.927', 'Title': 'How do you prove that this TM decides a language that is undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-14T07:49:33.580', 'LastEditDate': '2014-04-14T07:49:33.580', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16742', 'Tags': '<computability><turing-machines><undecidability>', 'CreationDate': '2014-04-14T02:08:14.150', 'Id': '23770'}{'Body': "<blockquote>\n  <p>If $A \\leq_m B$ and $A$ is not mapping reducible to $co\\text{-}B$, then $A \\leq_T co\\text{-}B$.</p>\n</blockquote>\n\n<p>Is this true?</p>\n\n<p>My intuition is false even if we can find some special case to make it true such as $A=B=co\\text{-}A_{TM}$. However, I still can't find a counterexample. </p>\n\n<p>Could anyone give me a little hint?   </p>\n", 'ViewCount': '23', 'Title': 'If A is mapping-reducible to B and is not mapping-reducible to co-B, is A Turing-reducible to co-B?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-15T17:54:12.253', 'LastEditDate': '2014-04-15T10:12:39.880', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<computability><reductions>', 'CreationDate': '2014-04-15T02:39:51.667', 'Id': '23802'}{'Body': u'<p>I\'m having trouble grasping this the concept of reductions. I found the solution and it looks like this:</p>\n\n<p><img src="http://i.stack.imgur.com/eqv7G.png" alt="enter image description here"></p>\n\n<p>Assume that $M_5$ is a Turing Machine that can decide if a given Turing Machine $M$\naccepts any string of length $5$, i.e., $L(M)$ contains a string of length $5$. The above figure shows how we can use this to construct a Turing Machine that can solve the Halting\nproblem.</p>\n\n<p>The output $M\u2032$ of our translator behaves as follows:</p>\n\n<ol>\n<li>$M\u2032$ erases its own input and replaces it with the string w.</li>\n<li>It them simulates $M$ on $w$.</li>\n<li>If $M$ halts on $w$, then it goes into a final state (accepts its input).\nIt is clear that if $M$ halts on $w$, $M\u2032$ accepts all its inputs. So it accepts a string of length 5 as well.\nIf $M$ does not halt on $w$, $M\u2032$ does not accept any string at all. So it does not accept any\nstring of length 5 either.\nSo $L(M\u2032)$ includes a string of length $5$ if and only of $M$ accepts $w$. So by running $M_5$ on $M\u2032$, we can decide if $M$ halts on $w$ or not. But we know that this is not possible since the halting problem is undecidable. Hence $M_5$ does not exist and the given problem is undecidable.</li>\n</ol>\n\n<p>What I am confused about is: "if $M$ halts on $w$, $M\u2032$ accepts all its inputs" and "If $M$ does not halt on $w$, $M\u2032$ does not accept any string at all". Can someone clarify why this is the case? I\'ve been trying to work out the logic for so long. If any of you guys could help this would be great!</p>\n\n<p><a href="http://web.engr.oregonstate.edu/~tadepall/cs321/09/assigns/sol-a7.pdf" rel="nofollow">Source</a></p>\n', 'ViewCount': '55', 'Title': 'Showing that deciding whether a given TM accepts a word of length 5 is undecidable', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-15T10:42:26.763', 'LastEditDate': '2014-04-15T10:14:36.127', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '23808', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<computability><turing-machines><reductions>', 'CreationDate': '2014-04-15T05:22:14.183', 'Id': '23804'}{'Body': "<p>Given a program $P$ which takes a binary string as input, can one always (effectively) construct a program $P'$ such that $P'(0x)$ runs $P(x)$ and $P'(1x)$ outputs the source code of $P'$? I didn't find anything with some googling, but it seems like the kind of thing that could be known.</p>\n", 'ViewCount': '81', 'Title': 'Can every program be turned into a quine?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-16T13:14:32.640', 'LastEditDate': '2014-04-16T13:14:32.640', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '23854', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5006', 'Tags': '<computability>', 'CreationDate': '2014-04-16T08:46:19.017', 'Id': '23848'}{'Body': "<p>Let $L = \\{ &lt;M&gt; | M$ halts on every input $x$ in at most $200 * |x|$ steps $\\}$. </p>\n\n<p>Is $L$ decidable? Recognizable?</p>\n\n<p>Given that membership in $L$ asserts something about $M$'s behavior on an infinite set of strings, it seems extremely unlikely to me that $L$ could be either. I have shown that co-$L$ is Turing-recognizable (I think): you can make an enumerator that tests each $M_1, M_2, \\dots, $ for each $s_1, s_2, \\dots$ and emits $M$ if it does not accept some $s$ in at most $200|x|$ steps.</p>\n\n<p>Since co-$L$ is recognizable, either $L$ is not recognizable, or it is decidable. I can't imagine that $L$ is decidable. However, it definitely cannot be reduced to the halting problem, nor can Rice's theorem be applied to it (since the quality in question is the quality of halting in a particular number of steps, being able to decide it doesn't let us decide other arbitrary properties).</p>\n\n<p>It seems to me that the best way to go will be to show that $L$ lets me recognize something that is unrecognizable, since the only problems it solves are ones which require me to run over infinite sets of strings. But I can't think of what this could be. I thought that maybe co-HALT would work, but I can't ever prove that a TM will never halt on some input.</p>\n\n<p>I'm stuck. What direction should I go in?</p>\n", 'ViewCount': '38', 'Title': 'Deciding the set of all Turing machines that halt in at most $k|x|$ steps $\\forall x \\in \\Sigma^*$', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-16T12:31:22.373', 'LastEditDate': '2014-04-16T12:31:22.373', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16612', 'Tags': '<computability><turing-machines><undecidability><decision-problem>', 'CreationDate': '2014-04-16T09:25:10.423', 'Id': '23849'}{'Body': "<p>Let the following datatype be defined:</p>\n\n<pre><code> data T = A | B T | C T T\n</code></pre>\n\n<p>That is, <code>B, B T, B (B T), C A A, C (B T) A</code> and so on all are members of T. Now, suppose we define two functions that operate on that type:</p>\n\n<pre><code>f :: T -&gt; T\nf A = A\nf (B x) = B (B (f x))\n\ng :: T -&gt; T\ng A = A\ng (B x) = B (B (B (g x)))\n</code></pre>\n\n<p>There are restrictions on the definition of <code>f</code> and <code>g</code>: first, recursive calls can only be applied directly to a subterm of one of the inputs (guaranteeing termination), and second, they can't use any datatype other than T on their bodies (consider T is the only existing type). In this case, we know that the following function:</p>\n\n<pre><code>h :: T -&gt; T\nh A = A\nh (B x) = B (B (B (B (B (B (h x))))))\n</code></pre>\n\n<p>works as the composition <code>f . g</code>. My question is, is it possible/decidable to find the composition of <code>f</code> and <code>g</code> in this form - that is, without any reference to <code>f</code> and <code>g</code> themselves? What is the name of the problem I am trying to solve?</p>\n", 'ViewCount': '48', 'Title': 'Is there a decidable algorithm to compose two well-behaved recursive functions that work on a recursive tree datatype?', 'LastEditorUserId': '16949', 'LastActivityDate': '2014-04-21T19:21:04.403', 'LastEditDate': '2014-04-21T15:45:57.793', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16949', 'Tags': '<algorithms><complexity-theory><computability><programming-languages>', 'CreationDate': '2014-04-21T15:36:19.557', 'Id': '23992'}{'Body': '<p>I need to show the following 2 statements:</p>\n\n<ol>\n<li>Set of distinct partial recursive functions are countable.</li>\n<li>Each partial recursive function has an infinite number of indices.</li>\n</ol>\n\n<p>Completely no clue. I think for 1, we just show since we can number them, so they are countable?</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-04-27T11:42:56.097', 'Title': 'Partial recursive functions and indices', 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-27T08:38:48.450', 'LastEditDate': '2014-04-27T08:38:48.450', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17100', 'Tags': '<computability><recursion>', 'CreationDate': '2014-04-26T19:59:34.180', 'Id': '24139'}{'Body': '<p>I was studying the proof of Ackermann function being recursive, but not primitive recursive, and a question hit me: "So what?". Why does it matter? What is the significance of primitive recursive functions?</p>\n', 'ViewCount': '97', 'Title': 'What is the significance of primitive recursive functions?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-27T21:35:16.937', 'LastEditDate': '2014-04-27T19:41:56.967', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '24154', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7410', 'Tags': '<terminology><computability><machine-models>', 'CreationDate': '2014-04-27T15:59:40.287', 'Id': '24152'}{'Body': "<p>For a function (1-Dimension)</p>\n\n<p>$u(x)=\\sum_{i=1}^4H_i(x)u_i $</p>\n\n<p>where $H_i$ is the interpolation function (Hermite interpolation basis functions), $u_i$ be the nodal value. </p>\n\n<p>now, for the nonlinear term $u^3$, it's known that if we want to simulate it  we should apply Newton iteration method. Here I can't write the stiffness matrix , could anybody help me? </p>\n\n<p>Thanks a lot!</p>\n", 'ViewCount': '10', 'ClosedDate': '2014-04-29T08:36:26.537', 'Title': 'nonlinear question', 'LastActivityDate': '2014-04-29T01:22:57.523', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17158', 'Tags': '<computability>', 'CreationDate': '2014-04-29T01:22:57.523', 'Id': '24203'}{'Body': "<p>The definition of the complexity class $\\mathsf{NP}$ seems to ensure (as good as possible) that it is computably enumerable. It looks as if the class could be enumerated by enumerating all Turing machines, and for each Turing machine report for each $k\\in\\mathbb{N}$ the language generated by stopping each computation after $n^k$ steps, and reject if the input hasn't been accepted before reaching this step limit.</p>\n\n<p>This only gives a computable enumeration of Turing machines. However, it seems that the corresponding languages will be decidable, because the enumeration includes an explicit time bound for each of its Turing machines. Hence this should give an computable enumeration of $\\mathsf{NP}$.</p>\n\n<blockquote>\n  <p>Question: Is the conclusion from this reasoning correct, i.e. is $\\mathsf{NP}$ computably enumerable? One issue that I have is that even for decidable languages, we can only (computably) decide whether two given languages are different, but not whether they are equal. Hence it seems that we can't avoid to report the same language more than once. The deeper issue here is that being computably enumerable is a property of subsets of the natural numbers, but the complexity class $\\mathsf{NP}$ doesn't seem to correspond to a subset of the natural numbers in any canonical way.</p>\n</blockquote>\n", 'ViewCount': '101', 'Title': 'Is the complexity class NP computably enumerable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-03T00:18:54.527', 'LastEditDate': '2014-05-02T21:46:47.193', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1557', 'Tags': '<computability><complexity-classes><np><enumeration>', 'CreationDate': '2014-05-02T20:51:31.623', 'Id': '24326'}