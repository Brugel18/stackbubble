{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>If we have an algorithm that need to run $n=2$ operations and then halt, I think we could say the problem it solves, is tractable, but if $n=10^{120}$ althought It could be theoretically solvable it seems to be intractable, and what about a problem that needs $n=10^{1000}$, or $n=10^{10^{1000}}$ operations, that\'s seems an intractable problem for sure.</p>\n\n<p>Then we see there is a k, from which $n\\ge k$ operations problems are intractable, and $n\\lt k$ are tractable ones.</p>\n\n<p>I doubt about that k to exist.. Where is the limit? Can a Technological advance turn some intractable problems <strong>for a given n</strong> into a tractable ? </p>\n\n<p>I would like to read your opinion.</p>\n\n<p><strong>EDIT</strong></p>\n\n<p>I think this question is similar as asking if Church\u2013Turing thesis is correct, because if the difference about solving a computable problem in a Turing Machine and in any other Turing Complete Machine, is "only a constant" about the number of operations, then I think that asking about computable is the same as asking about effective calculability.. Now I see tractable means polynomial time, and inctractable is related with no polynomial time solution. But the difference between two machines, for the same (even tractable) problem, is about Church-Turing thesis. </p>\n', 'ViewCount': '129', 'Title': 'Which is the minimal number of operations for intractability?', 'LastEditorUserId': '1396', 'LastActivityDate': '2012-09-27T02:29:12.420', 'LastEditDate': '2012-09-27T02:29:12.420', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2386', 'Score': '-4', 'PostTypeId': '1', 'OwnerUserId': '1396', 'Tags': '<complexity-theory><church-turing-thesis>', 'CreationDate': '2012-06-15T23:38:43.623', 'Id': '2385'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '147', 'Title': 'Time complexity version of the Church-Turing Thesis', 'LastEditDate': '2012-07-16T23:22:05.273', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1590', 'FavoriteCount': '1', 'Body': '<p>There\'s a <a href="http://plato.stanford.edu/entries/church-turing/#Bloopers" rel="nofollow">lot of debate</a> about what exactly the Church-Turing thesis is, but roughly it\'s the argument that "undecidable" should be considered equivalent to "undecidable by a universal turing machine."</p>\n\n<p>I\'m wondering if there\'s an analogous statement for time complexity, i.e. an argument that if some language is decided in $\\Theta\\left(f(n)\\right)$ on a universal turing machine, then we should say its time complexity is $\\Theta\\left(f(n)\\right)$. </p>\n\n<p>This isn\'t equivalent to the CT thesis - e.g. quantum computers decide precisely those languages which are decidable in a non-quantum TM, but they may run that decision procedure more quickly.</p>\n', 'Tags': '<computability><terminology><turing-machines><church-turing-thesis>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:22:05.273', 'CommentCount': '3', 'AcceptedAnswerId': '2766', 'CreationDate': '2012-07-02T16:28:33.263', 'Id': '2587'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I was reading about counting principle related to TOC. I understand that the set of TMs are countable infinity. I couldn't understand the significance of it. What is its not countable?</p>\n", 'ViewCount': '129', 'Title': "If set of TM's is not countable?", 'LastEditorUserId': '947', 'LastActivityDate': '2013-01-27T03:55:56.253', 'LastEditDate': '2013-01-13T07:37:55.000', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<computability><turing-machines><uncountability><church-turing-thesis>', 'CreationDate': '2013-01-13T06:49:46.727', 'Id': '7915'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am doing some work on register machine theory which revolves around a 2-register register machine and attempting to show that it is not possible to compute an upper-bound on the final contents of its two registers on the basis of its program code and initial input, in halting configurations only. I believe this can be related in some way to the <em>busy beaver</em> problem, but I cannot quite see how, and the stipulations that it is for halting configurations only has confused me somewhat.</p>\n\n<p>What do I know so far?</p>\n\n<ul>\n<li><p>Clearly a register machine configuration specified by the 3-tuple <em>(instruction label, register 0, register 1)</em> has an infinite number of possible states, owing to the abstract nature of the machines, as no practical limit is imposed on the size of the natural numbers which can be stored in each register.</p></li>\n<li><p>I considered whether I could simply define a partial function $f : \\mathbb{N}^3 \\to \\mathbb{N}$ where the arguments are the program encoded as a natural number and the initial contents of the two registers, but I do not think this gets me anywhere. I defined the function to be undefined when the partial function computed by the register machine specification is undefined on the given input, as the problem specifies computing the upper bound for halting configurations only. <br/><br/>Therefore, I cannot use a diagonal argument to suggest it would imply the halting problem, because being undefined for a non-halting configuration suggests it would not.</p></li>\n<li><p>Secondly, I tried to come up with a proof on the basis that there is an infinite number of possible configurations which a 2-register machine can be in. In particular, there is an infinite number of possible programs $e \\in \\mathbb{N}$ which could be executed, and each of those programs can be executed on an infinite number of initial register configurations $\\mathbb{N}^2$.<br /><br />By construction, if there is a machine which can decide this partial function for any given combination, then I thought it may be the case that it required an infinite number of states in which to do so - which is of course not possible, as a register machine must be specified by a finite number of instructions.</p></li>\n</ul>\n\n<p>I am not confident that either approach is correct or not, and wonder whether either of the above is a correct tact or if a formal proof exists for this?</p>\n', 'ViewCount': '66', 'Title': 'Upper bound on register machine contents', 'LastActivityDate': '2013-04-30T16:32:15.903', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11679', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7928', 'Tags': '<computability><turing-machines><church-turing-thesis>', 'CreationDate': '2013-04-30T15:48:51.427', 'Id': '11678'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a deep appreciation for formalisms like the Turing Machine and the $\\lambda$-Calculus, and enjoy studying them and learning more about how they relate to physical computers. I am now learning about writing GUI programs, and the graphical library (GTK) relies on things like signals and callbacks, which I have not seen modeled by either Turing Machines or the $\\lambda$-Calculus; <strong>can either the $\\lambda$-Calculus or Turing Machines model things like signals, callbacks, sleeping/waiting, or buses?</strong> If so, where can I find some good reference material to learn more? If not, why not? and are there any formalisms which are capable of expressing such things?</p>\n', 'ViewCount': '146', 'Title': 'Can the Lambda Calculus or Turing Machines model signals, callbacks, sleep/wait, or buses?', 'LastActivityDate': '2013-09-18T18:46:18.427', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><computer-architecture><lambda-calculus><church-turing-thesis>', 'CreationDate': '2013-06-20T00:58:47.687', 'Id': '12771'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I hope my question makes sense: Starting with the premise that the untyped $\\lambda $ calculus is equivalent in power to a Turing machine, to what in a Turing machine does adding types to the $\\lambda $ calculus correspond? Is there some kind of automaton analog to typing, whether static or dynamic?</p>\n', 'ViewCount': '123', 'Title': 'To what does typing correspond in a Turing Machine?', 'LastActivityDate': '2013-07-09T03:05:03.767', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><lambda-calculus><type-theory><church-turing-thesis>', 'CreationDate': '2013-07-08T05:47:39.780', 'FavoriteCount': '2', 'Id': '13158'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have seen web sites that purport to "prove" that HTML5+CSS is Turing Complete.</p>\n\n<p>I have seen web sites that purport to "prove" that SQL is Turing Complete.</p>\n\n<p>I have seen a bunch of web sites that purport to "explain" what it means to be Turing Complete.</p>\n\n<p>Enough!</p>\n\n<p>Where can I find a book (written by an expert in computability theory) or a peer-reviewed article (in a reputable journal) that shows a proof of, "This language XYZ is capable of describing a computational machine which has the same computational power as a Turing Machine"?</p>\n', 'ViewCount': '315', 'Title': 'Clear, complete, proof that a language is Turing Compete?', 'LastActivityDate': '2013-09-30T17:12:59.010', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><automata><turing-completeness><church-turing-thesis>', 'CreationDate': '2013-09-30T11:35:37.607', 'FavoriteCount': '1', 'Id': '14697'}},