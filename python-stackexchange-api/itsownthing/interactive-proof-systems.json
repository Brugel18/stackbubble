269_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to understand different interactive proof systems. Is there a typical problem for the complexity class MA (like graph-nonisomorphism is for AM)? Is there a problem in MA but not known to be in NP or BPP?</p>\n\n<p>Is there a reason that most books discuss AM in detail while merely glossing over MA, which seems to be the more natural proof system at least to me?</p>\n', 'ViewCount': '114', 'Title': '"Essential" problem for MA', 'LastEditorUserId': '41', 'LastActivityDate': '2013-04-03T23:56:22.440', 'LastEditDate': '2012-10-06T03:30:26.930', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '984', 'Tags': '<complexity-theory><interactive-proof-systems>', 'CreationDate': '2012-10-05T23:32:59.910', 'FavoriteCount': '1', 'Id': '4896'},269_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to ask you some clarification on the following question:\nknow that ${\\sf NP}$ is a subset of ${\\sf IP}$ \nand also ${\\sf coNP}$ it is a subset of ${\\sf IP}$.\nSo ${\\sf IP}$ is a biggest class, but how much it is big?</p>\n\n<p>May i say that ${\\sf PSPACE}$ is a subset of ${\\sf IP}$? or that they may intersect?</p>\n\n<p>Can you give me a easy clarification about it?</p>\n', 'ViewCount': '160', 'Title': 'Relation between interactive proof systems (IP), NP, coNP, PSPACE', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-16T21:07:21.567', 'LastEditDate': '2012-11-16T21:07:21.567', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4488', 'Tags': '<complexity-theory><time-complexity><space-complexity><complexity-classes><interactive-proof-systems>', 'CreationDate': '2012-11-15T13:47:04.607', 'Id': '6679'},269_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to sketch an IP proof for the minSAT problem. The minSAT problem is define in this way:</p>\n\n<ul>\n<li>For a given formulae find a satisfying assignment with a min subset of variables assigned to True;</li>\n</ul>\n\n<p>My sketched IP protocol is:</p>\n\n<ol>\n<li><p>Prover and Verifier share the input formula</p></li>\n<li><p>Prover sends to the Verifier a set of variables assigned to True, which should be the minimum</p></li>\n<li><p>Verifier checks if the given set indeed satisfies the formula. If it is the case, it chooses one variable, re-computes the formula and sends the new formula to the Prover</p></li>\n</ol>\n\n<p>I would iterate this process untill the Prover gives an empty set or I reach a contradiction.</p>\n\n<p>My questions are:</p>\n\n<ul>\n<li><p>Is this a right protocol? If not, how can I exploit the cases in which the protocol doesn't work?</p></li>\n<li><p>How can I evaluate the probability of completness and soundness for this protocol?</p></li>\n</ul>\n", 'ViewCount': '188', 'Title': 'Sketch an IP proof for minSAT', 'LastActivityDate': '2013-02-18T02:27:58.833', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4221', 'Tags': '<satisfiability><interactive-proof-systems>', 'CreationDate': '2012-11-20T15:22:19.130', 'FavoriteCount': '1', 'Id': '6788'},269_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to understand <a href="https://en.wikipedia.org/wiki/Interactive_proof_system" rel="nofollow">interactive proof systems</a> and tried the following problem as an exercise. We know that $PH \\subseteq PSPACE$ and $IP=PSPACE$, so come up with (easy to understand) interactive proof systems for $PH$?</p>\n\n<p>An interactive proof system for $NP$ is trivial, but I failed to get an interactive proof system even for $coNP$. Do you know of an explicit interactive proof system (by explicit I mean without going through the $IP=PSPACE$ route) for $coNP$?</p>\n', 'ViewCount': '93', 'Title': 'Interactive Proofs for coNP', 'LastEditorUserId': '41', 'LastActivityDate': '2013-07-17T08:03:41.293', 'LastEditDate': '2013-07-17T08:03:41.293', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '984', 'Tags': '<complexity-theory><interactive-proof-systems>', 'CreationDate': '2013-07-15T14:49:51.387', 'Id': '13286'},269_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the web draft of Arora and Barak, "Computational Complexity: A Modern Approach", the way I understand their definition of a round of interaction is that it consists of either the verifier or the prover sending a message. In other sources on the matter, it seems to me that a round consists of both the verifier and the prover sending a message. Could someone clarify which of the definitions is the one that is usually used?</p>\n', 'ViewCount': '86', 'Title': 'Number of rounds in interactive proofs - Arora & Barak', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-28T16:36:25.773', 'LastEditDate': '2013-07-29T08:07:58.093', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13469', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6689', 'Tags': '<complexity-theory><interactive-proof-systems>', 'CreationDate': '2013-07-26T14:18:50.917', 'Id': '13452'},269_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In Haskell, are datatypes converted to the "Church encoding" i.e. folding the data type.  For example, given </p>\n\n<pre><code>data N = Z | S N\n</code></pre>\n\n<p>in Haskell, it can be converted to its church encoding by </p>\n\n<pre><code>foldN Z z s = z\nfoldN (S n) z s = s (foldN z s n)\n</code></pre>\n\n<p>Where if we do foldN m, we get the church encoding:</p>\n\n<pre><code>\\z s . s (  .... s n ... )\n</code></pre>\n\n<p>In Proofs and Types, Girard shows how this works for any inductive datatype.  There are two questions I have: (1) is this actually how Haskell treats datatypes and (2) what is the equivalent construction for coinductive datatypes.</p>\n', 'ViewCount': '57', 'Title': 'Implementation of datatypes in Haskell?', 'LastActivityDate': '2013-09-11T00:13:35.923', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4775', 'Tags': '<data-structures><term-rewriting><interactive-proof-systems>', 'CreationDate': '2013-09-11T00:13:35.923', 'FavoriteCount': '0', 'Id': '14261'}