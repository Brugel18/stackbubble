{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Assume that we have a set $D$ and each member of $D$ is a data and key pair. We want a data structure that would support the following operations:</p>\n\n<ul>\n<li>Insert $(d,k)$ into $D$,</li>\n<li>Delete member $e$, (no need to search to find $e$, e.g. $e$ points to a member in $D$),</li>\n<li>MostFrequent, which returns a member $e \\in D$ such that $e.key$ is one of the most frequent keys in $D$ (note that the most frequent key doesn't need to be unique).</li>\n</ul>\n\n<p>What would be an efficient implementation of this data structure?</p>\n\n<p>My solution is a heap for the keys and their frequencies prioritized by the frequencies plus a hash table where the hash function maps members with the same key to the same slot in the hash table (with pointers from each part to the other). </p>\n\n<p>This can give $\\Theta(\\lg n)$ for the first two operations and $\\Theta(1)$ for the third (worst case running time). </p>\n\n<p>I am wondering if there is more efficient solution? (or a simpler solution with the same efficiency?)</p>\n", 'ViewCount': '870', 'Title': 'An efficient data structure supporting Insert, Delete, and MostFrequent', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-23T16:20:22.333', 'LastEditDate': '2012-11-02T21:39:10.150', 'AnswerCount': '3', 'CommentCount': '10', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<algorithms><data-structures><abstract-data-types>', 'CreationDate': '2012-11-02T17:00:40.447', 'FavoriteCount': '5', 'Id': '6455'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1073', 'Title': 'Implement queue with a linked list; why would it be bad to insert at the head and remove at the tail?', 'LastEditDate': '2013-03-10T19:51:55.500', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '1', 'Body': '<p>In my textbook, Data Structures and Algorithms in Java, the author says when implementing a queue using a linked list you choose the front of the queue to be at the head of the list, and the rear of the queue to be at the tail of the list. In this way, you remove from the head and insert at the tail.</p>\n\n<p>The author then asks cryptically, "Why would it be bad to insert at the head and remove at the tail?" without providing an answer.</p>\n\n<p>I can\'t see what the difference really is. In effect, "Head" and "Tail" are just arbitrary names we define. What would be so bad if to enqueue() we add a head and create a reference to the old head, and to dequeue() we take from the tail and move the tail over?</p>\n\n<p>What is the answer to the author\'s question?</p>\n', 'Tags': '<time-complexity><linked-lists><abstract-data-types>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-10T19:51:55.500', 'CommentCount': '0', 'AcceptedAnswerId': '10435', 'CreationDate': '2013-03-10T19:10:25.620', 'Id': '10434'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '104', 'Title': '"OOD allows ADTs to be created and used."', 'LastEditDate': '2013-07-30T10:22:35.197', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9416', 'FavoriteCount': '1', 'Body': '<p>I just had a CS mid-term and one of the questions was:</p>\n\n<blockquote>\n  <p>OOD allows ADTs to be created and used.</p>\n  \n  <ul>\n  <li>True</li>\n  <li>False</li>\n  </ul>\n</blockquote>\n\n<p>I answered false, but my answer was marked as incorrect. I suspect what the question means is "objected-oriented design can be used to implement abstract data types", but if that\'s what it means it seems very clumsily worded to me. My rationale for answering false was ADTs are conceptual and exist outside of any particular programming paradigm, so "creation" of an ADT is purely a theoretical exercise.</p>\n\n<p>To me it seems like the question is analogous to saying "OOD allows algorithms to be created". You might use OOD in the implementation of an algorithm, but it has nothing to do with its creation.</p>\n\n<p>Would I be right in appealing my mark? My professor is kind of an idiot and I\'ve already corrected him on several other points throughout the term, so I\'m trying to avoid antagonizing him if I\'m wrong.</p>\n', 'Tags': '<programming-languages><object-oriented><abstract-data-types>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-30T10:22:35.197', 'CommentCount': '1', 'AcceptedAnswerId': '13505', 'CreationDate': '2013-07-29T23:22:03.170', 'Id': '13503'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Most specifically, his use of small epsilon introduced at the end of section 1 of "Types, Abstraction and Parametric Polymorphism" is throwing me, but in general I would like references to symbols in the Type and Logical Relations literature.</p>\n', 'ViewCount': '51', 'Title': 'Looking for cheat sheet to J.C. Reynolds symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T10:46:17.957', 'LastEditDate': '2013-08-27T10:46:17.957', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13957', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9831', 'Tags': '<terminology><reference-request><type-theory><abstract-data-types>', 'CreationDate': '2013-08-27T03:17:11.390', 'Id': '13954'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>On <a href="http://en.wikipedia.org/wiki/Pizza_%28programming_language%29" rel="nofollow">this page describing the precursor to the Scala language</a> - the pizza language - they refer to it having both case classes and <a href="http://en.wikipedia.org/wiki/Pattern_matching" rel="nofollow">pattern matching</a> - and then imply that these taken together provide <a href="http://en.wikipedia.org/wiki/Algebraic_data_type" rel="nofollow">algebraic types</a>. </p>\n\n<p>Is this the case? To provide algebraic types - do you combine <a href="http://en.wikipedia.org/wiki/Scala_%28programming_language%29#Case_classes_and_pattern_matching" rel="nofollow">case classes and pattern matching</a>?</p>\n', 'ViewCount': '33', 'Title': 'Are Algebraic types just the combination of case classes and pattern matching?', 'LastActivityDate': '2013-12-07T10:26:16.887', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18712', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<type-theory><pattern-recognition><abstract-data-types>', 'CreationDate': '2013-12-07T10:12:33.263', 'Id': '18711'}}