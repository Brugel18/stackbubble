{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '198', 'Title': 'Characterization of lambda-terms that have union types', 'LastEditDate': '2012-03-07T11:03:44.950', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '3', 'Body': '<p>Many textbooks cover intersection types in the lambda-calculus. The typing rules for intersection can be defined as follows (on top of the simply typed lambda-calculus with subtyping):</p>\n\n<p>$$\r\n\\dfrac{\\Gamma \\vdash M : T_1 \\quad \\Gamma \\vdash M : T_2}\r\n      {\\Gamma \\vdash M : T_1 \\wedge T_2}\r\n      (\\wedge I)\r\n\\qquad\\qquad\r\n\\dfrac{}\r\n      {\\Gamma \\vdash M : \\top}\r\n      (\\top I)\r\n$$</p>\n\n<p>Intersection types have interesting properties with respect to normalization:</p>\n\n<ul>\n<li>A lambda-term can be typed without using the $\\top I$ rule iff it is strongly normalizing.</li>\n<li>A lambda-term admits a type not containing $\\top$ iff it has a normal form.</li>\n</ul>\n\n<p>What if instead of adding intersections, we add unions?</p>\n\n<p>$$\r\n\\dfrac{\\Gamma \\vdash M : T_1}\r\n      {\\Gamma \\vdash M : T_1 \\vee T_2}\r\n      (\\vee I_1)\r\n\\qquad\\qquad\r\n\\dfrac{\\Gamma \\vdash M : T_2}\r\n      {\\Gamma \\vdash M : T_1 \\vee T_2}\r\n      (\\vee I_2)\r\n$$</p>\n\n<p>Does the lambda-calculus with simple types, subtyping and unions have any interesting similar property? How can the terms typable with union be characterized?</p>\n', 'Tags': '<lambda-calculus><type-theory><logic>', 'LastEditorUserId': '68', 'LastActivityDate': '2012-03-08T10:06:42.440', 'CommentCount': '2', 'AcceptedAnswerId': '116', 'CreationDate': '2012-03-07T02:07:40.470', 'Id': '62'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '404', 'Title': 'What is beta equivalence?', 'LastEditDate': '2012-04-22T16:20:23.093', 'AnswerCount': '2', 'Score': '9', 'OwnerDisplayName': 'atticae', 'PostTypeId': '1', 'OwnerUserId': '594', 'FavoriteCount': '2', 'Body': '<p>In the script I am currently reading on the lambda calculus, beta equivalence is defined as this:</p>\n\n<blockquote>\n  <p>The $\\beta$-equivalence $\\equiv_\\beta$ is the smallest equivalence that contains $\\rightarrow_\\beta$.</p>\n</blockquote>\n\n<p>I have no idea what that means. Can someone explain it in simpler terms? Maybe with an example?</p>\n\n<p>I need it for a lemma following from the Church-Russer theorem, saying</p>\n\n<blockquote>\n  <p>If M $\\equiv_\\beta$ N then there is a L with M $\\twoheadrightarrow_\\beta$ L and N $\\twoheadrightarrow_\\beta$ L.</p>\n</blockquote>\n', 'Tags': '<logic><terminology><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T16:20:23.093', 'CommentCount': '1', 'AcceptedAnswerId': '635', 'CreationDate': '2012-03-21T18:42:56.037', 'Id': '634'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am currently learning the lambda calculus and was wondering about the following two different kinds of writing a lambda term. </p>\n\n<ol>\n<li>$\\lambda xy.xy$  </li>\n<li>$\\lambda x.\\lambda y.xy$</li>\n</ol>\n\n<p>Is there any difference in meaning or the way you apply beta reduction, or are those just two ways to express the same thing?</p>\n\n<p>Especially this definition of pair creation made me wonder:</p>\n\n<blockquote>\n  <p><strong>pair</strong> = $\\lambda xy.\\lambda p.pxy$</p>\n</blockquote>\n', 'ViewCount': '470', 'Title': 'Is there a difference between $\\lambda xy.xy$ and $\\lambda x.\\lambda y.xy$?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-25T16:36:14.043', 'LastEditDate': '2012-03-25T16:36:14.043', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '657', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '594', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2012-03-22T14:20:58.330', 'Id': '653'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '430', 'Title': 'Quantum lambda calculus', 'LastEditDate': '2012-04-02T03:49:36.880', 'AnswerCount': '1', 'Score': '19', 'PostTypeId': '1', 'OwnerUserId': '55', 'FavoriteCount': '5', 'Body': '<p>Classically, there are 3 popular ways to think about computation: Turing machine, circuits, and lambda-calculus (I use this as a catch all for most functional views). All 3 have been fruitful ways to think about different types of problems, and different fields use different formulation for this reason. </p>\n\n<p>When I work with quantum computing, however, I only ever think about the circuit model. Originally, QC was defined in terms of <a href="http://cs.stackexchange.com/q/125/55">quantum Turing machines</a> but as far as I understand, this definition (although equivalent to quantum circuits if both are formulated carefully) has not been nearly as fruitful. The 3rd formulation (in terms of lambda-calculus or similar functional settings) I am completely unfamiliar with. Hence my questions:</p>\n\n<ul>\n<li><p><strong>What are useful definitions of quantum lambda-calculus (or other functional paradigms)?</strong></p></li>\n<li><p><strong>What subfields of QIP gain deeper insight from using this formulation instead of the circuit model?</strong></p></li>\n</ul>\n\n<hr>\n\n<h3>Notes</h3>\n\n<p>I am aware that I am ignoring many other popular formalisms like cellular automata, RAM-models, etc. I exclude these mostly because I don\'t have experience with thinking in terms of these models classically, let alone <a href="http://cstheory.stackexchange.com/q/6932/1037">quantumly</a>. </p>\n\n<p>I am also aware that there are popular alternatives in the quantum setting, such as measurement-based, topological, and adiabatic. I do not discuss them because I am not familiar with the classical counterparts.</p>\n', 'Tags': '<lambda-calculus><quantum-computing><reference-request><computation-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-20T22:51:58.170', 'CommentCount': '3', 'AcceptedAnswerId': '1400', 'CreationDate': '2012-04-02T00:30:46.053', 'Id': '971'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I know this is a simple question but can someone show me how\n$(\\lambda y. \\lambda x. \\lambda y.y) (\\lambda x. \\lambda y. y)$ reduces to $\\lambda x. \\lambda y. y$.</p>\n', 'ViewCount': '184', 'Title': 'Lambda Calculus Evaluation', 'LastEditorUserId': '916', 'LastActivityDate': '2012-04-07T11:49:25.153', 'LastEditDate': '2012-04-07T11:49:25.153', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1013', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '926', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2012-04-03T21:47:38.827', 'Id': '1012'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I understand that a <a href="http://en.wikipedia.org/wiki/Church_encoding">Church numeral</a> $c_n$ looks like $\\lambda s. \\lambda z. s$ (... n times ...) $s\\;z$. This means nothing more than "the function $s$ applied $n$ times to the function $z$".</p>\n\n<p>A possible definition of the $\\mathtt{times}$ function is the following: $\\mathtt{times} = \\lambda m. \\lambda n. \\lambda s. m \\; (n\\; s)$. Looking at the body, I understand the logic behind the function. However, when I start evaluating, I get stuck. I will illustrate it with an example:</p>\n\n<p>$$\\begin{align*}\r\n (\\lambda m. \\lambda n. \\lambda s. m \\; (n\\; s))(\\lambda s.\\lambda z.s\\;s\\;z)(\\lambda s.\\lambda z.s\\;s\\;s\\;z) \\mspace{-4em} \\\\\r\n \\to^*&amp; \\lambda s. (\\lambda s.\\lambda z.s\\;s\\;z) \\; ((\\lambda s.\\lambda z.s\\;s\\;s\\;z)\\; s)) \\\\\r\n \\to^*&amp; \\lambda s. (\\lambda s.\\lambda z.s\\;s\\;z) \\; (\\lambda z.s\\;s\\;s\\;z) \\\\\r\n \\to^*&amp; \\lambda s. \\lambda z.(\\lambda z.s\\;s\\;s\\;z)\\;(\\lambda z.s\\;s\\;s\\;z)\\;z\r\n\\end{align*}$$</p>\n\n<p>Now in this situation, if I first apply $(\\lambda z.s\\;s\\;s\\;z)\\;z$, I get to the desired result. However, if I apply $(\\lambda z.s\\;s\\;s\\;z)\\;(\\lambda z.s\\;s\\;s\\;z)$ first, as I should because application is associative from the left, I get a wrong result:</p>\n\n<p>$\\lambda s. \\lambda z.(\\lambda z.s\\;s\\;s\\;z)\\;(\\lambda z.s\\;s\\;s\\;z)\\;z \\to \\lambda s. \\lambda z.(s\\;s\\;s\\;(\\lambda z.s\\;s\\;s\\;z))\\;\\;z$</p>\n\n<p>I can no longer reduce this. What am I doing wrong? The result should be $\\lambda s. \\lambda z.s\\;s\\;s\\;s\\;s\\;s\\;z$</p>\n', 'ViewCount': '144', 'Title': 'A lambda calculus evaluation involving Church numerals', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-19T18:18:32.317', 'LastEditDate': '2013-09-19T18:18:32.317', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1260', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '17', 'Tags': '<lambda-calculus><church-numerals>', 'CreationDate': '2012-04-13T23:55:58.743', 'Id': '1259'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to learn Lambda calculus from <a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf" rel="nofollow">here</a></p>\n\n<p>and while trying to solve some problems, I got stuck. I was trying to solve the following problem (page 14, excercise 2.6 part (i):</p>\n\n<p>Simplify $M \\equiv (\\lambda xyz.zyx) aa (\\lambda pq. q)$.</p>\n\n<p>My evaluation using the beta rule reduces it to $(\\lambda z. z)$ as follows:\nFirst I replace occurences of $x$ in $M$ by $aa (\\lambda pq. q)$, and then since there are no occurences of $y$ in the resulting $\\lambda$ term, the expression simply evaluates to $(\\lambda z. z)$.</p>\n\n<p>Is my reasoning correct? (Since there were no solutions to these notes, I want to ensure my understanding is correct. Any corrections, will be much appreciated! Thanks in advance.</p>\n', 'ViewCount': '894', 'Title': 'Lambda Calculus beta reduction', 'LastEditorUserId': '41', 'LastActivityDate': '2012-04-22T16:08:38.917', 'LastEditDate': '2012-04-22T16:08:38.917', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1199', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2012-04-22T13:03:13.390', 'Id': '1434'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m working through Simon Peyton Jones\' "The Implementation of Functional Programming Languages" and on page 20 I see:</p>\n\n<pre>\nIF TRUE ((&#955;p.p) 3) &#8596; IF TRUE 3         (per &#946; red)   (1)\n                   &#8596; (&#955;x.IF TRUE 3 x)  (per &#951; red)   (2)\n                   &#8596; (&#955;x.3)                          (3)\n</pre>\n\n<p>Step 1 to 2 is explained as &#951;-conversion. But from 2 to 3 it says "The final step is the reduction rule for IF." I\'m not sure what this reduction rule is. </p>\n', 'ViewCount': '213', 'Title': 'Reduction rule for IF?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-10T03:26:39.087', 'LastEditDate': '2012-05-10T03:26:39.087', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '7', 'OwnerDisplayName': 'galaxybeing', 'PostTypeId': '1', 'OwnerUserId': '1335', 'Tags': '<logic><programming-languages><lambda-calculus><term-rewriting><operational-semantics>', 'CreationDate': '2012-05-01T03:47:18.940', 'Id': '1607'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '136', 'Title': 'Why are lambda-abstractions the only terms that are values in the untyped lambda calculus?', 'LastEditDate': '2012-05-04T17:11:00.220', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '17', 'FavoriteCount': '1', 'Body': '<p>I am confused about the following claim: "The only values in the untyped lambda calculus are lambda-abstractions".</p>\n\n<p>Why are the other terms not values? What does it mean for a lambda-abstraction to be a value? The first thing that came to my mind was that maybe lambda-abstractions are the only possible normal forms, but this is not true of course, e.g. $(\\lambda x.\\; x)\\;y \\to y$.</p>\n\n<p>Can someone enlighten me?</p>\n', 'Tags': '<logic><lambda-calculus>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-04T17:49:35.677', 'CommentCount': '7', 'AcceptedAnswerId': '1663', 'CreationDate': '2012-05-04T14:23:15.200', 'Id': '1662'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Most of us know the correspondence between <a href="http://en.wikipedia.org/wiki/Combinatory_logic" rel="nofollow">combinatory logic</a> and <a href="http://en.wikipedia.org/wiki/Lambda_calculus" rel="nofollow">lambda calculus</a>. But I\'ve never seen (maybe I haven\'t looked deep enough) the equivalent of "typed combinators", corresponding to the simply typed lambda calculus. Does such thing exist? Where could one find information about it?</p>\n', 'ViewCount': '218', 'Title': 'Is there a typed SKI calculus?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T15:47:46.390', 'LastEditDate': '2012-05-14T15:47:16.223', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1818', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1300', 'Tags': '<logic><reference-request><lambda-calculus><type-theory>', 'CreationDate': '2012-05-13T01:39:47.143', 'Id': '1816'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '267', 'Title': 'Simple explanation as to why certain computable functions cannot be represented by a typed term?', 'LastEditDate': '2012-05-26T14:40:07.843', 'AnswerCount': '3', 'Score': '7', 'OwnerDisplayName': 'ixtmixilix', 'PostTypeId': '1', 'OwnerUserId': '1693', 'FavoriteCount': '1', 'Body': '<p>Reading the paper <a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf">An Introduction to the Lambda Calculus</a>, I came across a paragraph I didn\'t really understand, on page 34 (my italics):</p>\n\n<blockquote>\n  <p>Within each of the two paradigms there are several versions of typed\n  lambda calculus. In many important systems, especially those a la\n  Church, it is the case that terms that do have a type always possess a\n  normal form. By the unsolvability of the halting problem this\n  implies that not all computable functions can be represented by a\n  typed term, see Barendregt (1990), Theorem 4.2.15. This is not so bad\n  as it sounds, because in order to find such computable functions that\n  cannot be represented, one has to stand on one\'s head. For example in\n  2, the second order typed lambda calculus, only those partial\n  recursive functions cannot be represented that happen to be total,\n  but not provably so in mathematical analysis (second order\n  arithmetic).</p>\n</blockquote>\n\n<p>I am familiar with most of these concepts, but not the concept of a partial recursive function, nor the concept of a provably total function. However, this is not what I am interested in learning.</p>\n\n<p>I am looking for a simple explanation as to why certain computable functions cannot be represented by a typed term, as well as to why such functions can only be found \'by standing on one\'s head.\'</p>\n', 'Tags': '<computability><logic><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T11:43:59.000', 'CommentCount': '0', 'CreationDate': '2012-05-25T17:39:06.803', 'Id': '2092'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '219', 'Title': 'Does High Order Functions provide more power to Functional Programming?', 'LastEditDate': '2012-06-06T12:46:42.487', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1763', 'FavoriteCount': '1', 'Body': '<p><em>I\'ve asked a similar question <a href="http://cstheory.stackexchange.com/questions/11652/does-high-order-functions-provide-more-power-to-functional-programming">on cstheory.SE</a>.</em></p>\n\n<p>According to <a href="http://stackoverflow.com/a/1990580/209629">this answer on Stackoverflow</a> there is an algorithm that on a non-lazy pure functional programming language has an $\\Omega(n \\log n)$ complexity, while the same algorithm in imperative programming is $\\Omega(n)$. Adding lazyness to the FP language would make the algorithm $\\Omega(n)$.</p>\n\n<p>Is there any equivalent relationship comparing a FP language with and without High Order Functions? Is it still Turing Complete? If it is, does the lack of High Order on FP makes the language less "powerful" or efficient? </p>\n', 'Tags': '<complexity-theory><lambda-calculus><functional-programming><turing-completeness>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-06T12:56:27.090', 'CommentCount': '2', 'AcceptedAnswerId': '2241', 'CreationDate': '2012-06-06T01:10:04.083', 'Id': '2240'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '953', 'Title': 'Representing Negative and Complex Numbers Using Lambda Calculus', 'LastEditDate': '2013-09-19T18:19:18.270', 'AnswerCount': '2', 'Score': '7', 'OwnerDisplayName': 'zcaudate', 'PostTypeId': '1', 'OwnerUserId': '1800', 'FavoriteCount': '1', 'Body': '<p>Most tutorials on Lambda Calculus provide example where Positive Integers and Booleans can be represented by Functions. What about -1 and i?</p>\n', 'Tags': '<data-structures><lambda-calculus><integers><real-numbers>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-19T18:19:18.270', 'CommentCount': '0', 'AcceptedAnswerId': '2279', 'CreationDate': '2012-06-08T03:25:50.233', 'Id': '2272'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '512', 'Title': 'Does there exist a Turing complete typed lambda calculus?', 'LastEditDate': '2012-07-09T08:50:19.440', 'AnswerCount': '1', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '2096', 'FavoriteCount': '2', 'Body': '<p>Do there exist any Turing complete typed lambda calculi? If so, what are a few examples?</p>\n', 'Tags': '<computability><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-09T08:50:19.440', 'CommentCount': '0', 'AcceptedAnswerId': '2639', 'CreationDate': '2012-07-06T23:16:05.897', 'Id': '2638'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m looking for a simple calculus that supports reasoning about <a href="http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">reflection</a>, namely, the introspection and manipulation of running programs.</p>\n\n<blockquote>\n  <p>Is there an untyped $\\lambda$-calculus extension that enables one to convert $\\lambda$-terms into a form that can be syntactically manipulated and then subsequently evaluated?</p>\n</blockquote>\n\n<p>I imagine that the calculus has two main additional terms:</p>\n\n<ul>\n<li>$\\mathtt{reflect}\\ v$: takes $v$ and produces a representation of $v$ amendable to\nsyntactic manipulation.</li>\n<li>$\\mathtt{eval}\\ v$: takes a syntactic representation of a term and evaluates it.</li>\n</ul>\n\n<p>In order to support reflection, a syntactic representation of terms is required. It would look something like:</p>\n\n<ul>\n<li>$\\lambda x.e$ would be represented as a term $(\\mathsf{LAM}\\ R(e))$, where\n$R(e)$ is the reflected version of $e$,</li>\n<li>$e\\ e\'$ would be represented as term $(\\mathsf{APP}\\ R(e)\\ R(e\'))$, and</li>\n<li>$x$ would be represented as $(\\mathsf{VAR}\\ x)$.</li>\n</ul>\n\n<p>With this representation, pattern matching could be used to manipulate terms.</p>\n\n<p>But we run into a problem. $\\mathtt{reflect}$ and $\\mathtt{eval}$ need to be encoded as terms, as does pattern matching. Dealing with this seems to be straightforward,\nadding $\\mathsf{REFLECT}$, $\\mathsf{EVAL}$ and $\\mathsf{MATCH}$, but will I need to add other terms to support the manipulation of these?</p>\n\n<p>There are design choices that need to be made. What should the $R(-)$ function alluded to above do with \nthe body of $\\mathtt{reflect}$ and $\\mathtt{eval}$? Should $R(-)$ transform the body or\nnot?</p>\n\n<p>As I am not so much interested in studying reflection itself -- the calculus would serve as a vehicle for other research -- I do not want to reinvent the wheel.</p>\n\n<blockquote>\n  <p>Are there any existing calculi that match what I have just described?</p>\n</blockquote>\n\n<p>As far as I can tell, calculi such as MetaML, suggested in a comment, go a long way, but they do not include the ability to pattern match and deconstruct code fragments that have already been built.</p>\n\n<p>One thing I would like to be able to do is the following:</p>\n\n<ul>\n<li>$\\mathtt{let}\\ x=\\lambda y.y\\ \\mathtt{in}\\ \\mathtt{reflect}\\ x \n\\to (\\mathsf{LAM}\\ (\\mathsf{VAR}\\ y)\\ (\\mathsf{VAR}\\ y))$</li>\n</ul>\n\n<p>And then perform pattern matching on the result to build a completely different\nexpression. </p>\n\n<p>This is certainly not a conservative extension to the $\\lambda$-calculus and the meta-theory is likely to be ugly, but this is kind of the point for my application. I want to break $\\lambda$-abstractions apart.</p>\n', 'ViewCount': '284', 'Title': '$\\lambda$-calculus with reflection', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-27T06:09:52.923', 'LastEditDate': '2012-07-16T23:37:11.120', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '31', 'Tags': '<logic><lambda-calculus><semantics><reflection>', 'CreationDate': '2012-07-12T11:26:19.763', 'FavoriteCount': '2', 'Id': '2707'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '389', 'Title': 'How to show two models of computation are equivalent?', 'LastEditDate': '2012-08-13T22:04:59.613', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'FavoriteCount': '1', 'Body': "<p>I'm seeking explanation on how one could prove that two models of computation are equivalent. I have been reading books on the subject except that equivalence proofs are omitted. I have a basic idea about what it means for two models of computation to be equivalent (the automata view: if they accept the same languages). Are there other ways of thinking about equivalence? If you could help me understand how to prove that the Turing-machine model is equivalent to lambda calculus, that would be sufficient.</p>\n", 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><machine-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:00.330', 'CommentCount': '5', 'AcceptedAnswerId': '3162', 'CreationDate': '2012-08-13T21:03:50.690', 'Id': '3154'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was solving exercises on Lambda calculus. However, my solutions are different from the answers and I cannot see what is wrong.</p>\n\n<ol>\n<li><p>Find free variables of $(\\lambda x.xy)x$.<br>\nMy workings: $FV((\\lambda x.xy)x)=FV(\\lambda x.xy) \\cup FV(x)=\\{y\\} \\cup \\{x\\}=\\{x,y\\}$.<br>\nThe model answer: $FV((\\lambda x.xy)x)=\\{x\\}$.</p></li>\n<li><p>Find bound variables of $\\lambda xy.x$.<br>\nMy workings: A variable $y$ has its binding but since it is not present in the body of the $\\lambda$-abstraction it cannot be bound and thus $BV(\\lambda xy.x)=\\{x\\}$ only.<br>\nThe model answer: $BV(\\lambda xy.x)=\\{x, y\\}$.</p></li>\n</ol>\n', 'ViewCount': '232', 'Title': u'Free variables of (\u03bbx.xy)x and bound variables of \u03bbxy.x', 'LastEditorUserId': '29', 'LastActivityDate': '2012-08-26T16:15:56.437', 'LastEditDate': '2012-08-26T16:15:56.437', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '3277', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2598', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2012-08-21T15:48:13.773', 'Id': '3274'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Below is the lambda expression which I am finding difficult to reduce i.e. I am not able to understand how to go about this problem.</p>\n\n<p>$$(\\lambda mn.(\\lambda sz.ms(nsz)))(\\lambda sz.sz)(\\lambda sz.sz)$$</p>\n\n<p>I am lost with this.</p>\n\n<p>if anyone could lead me in the right direction that would be much appreciated</p>\n', 'ViewCount': '355', 'Title': 'Lambda Calculus simplification', 'LastEditorUserId': '2448', 'LastActivityDate': '2013-01-25T20:46:15.443', 'LastEditDate': '2012-10-10T09:00:22.700', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'OwnerDisplayName': 'Bob Dylan', 'PostTypeId': '1', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2012-10-10T07:26:46.720', 'FavoriteCount': '1', 'Id': '4990'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>It was brought to my attention that the cost of type inference in a functional language like OCaml can be very high. The claim is that there is a sequence of expressions such that for each expression the length of the corresponding type is exponential on the length of the expression.</p>\n\n<p>I devised the sequence below. My question is: do you know of a sequence with more concise expressions that achieves the same types?</p>\n\n<pre><code># fun a -&gt; a;;\n- : 'a -&gt; 'a = &lt;fun&gt;\n# fun b a -&gt; b a;;\n- : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;\n# fun c b a -&gt; c b (b a);;\n- : (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'c = &lt;fun&gt;\n# fun d c b a -&gt; d c b (c b (b a));;\n- : ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'd\n= &lt;fun&gt;\n# fun e d c b a -&gt; e d c b (d c b (c b (b a)));;\n- : (((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n   ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'e\n= &lt;fun&gt;\n# fun f e d c b a -&gt; f e d c b (e d c b (d c b (c b (b a))));;\n- : ((((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n     (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n    ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'e -&gt; 'f) -&gt;\n   (((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n   ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'f\n= &lt;fun&gt;\n</code></pre>\n", 'ViewCount': '332', 'Title': 'Concise example of exponential cost of ML type inference', 'LastEditorUserId': '4554', 'LastActivityDate': '2012-11-11T20:23:32.303', 'LastEditDate': '2012-11-11T19:48:39.593', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '8', 'OwnerDisplayName': 'mrrusof', 'PostTypeId': '1', 'OwnerUserId': '4554', 'Tags': '<lambda-calculus><type-theory><functional-programming><type-inference><type-checking>', 'CreationDate': '2012-11-11T14:01:45.770', 'Id': '6617'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I know that if you try and make the theory</p>\n\n<p>$$\\lambda\\beta+\\{s = t\\ |\\text{ s, t are terms without }\\lambda\\beta\\text{ normal forms}\\}$$</p>\n\n<p>then that theory becomes inconsistent. Are two terms where one is without a $\\lambda\\beta$ normal form also unconvertible in $\\lambda\\beta$, ie can it ever be true that $\\lambda\\beta \\vdash s=t$ if $s$ dosen't have a normal form?</p>\n", 'ViewCount': '67', 'Title': 'Are two terms where one is without a $\\lambda\\beta$ normal form unconvertible in $\\lambda\\beta$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-13T11:54:01.047', 'LastEditDate': '2012-11-12T11:31:26.100', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1579', 'Tags': '<terminology><logic><lambda-calculus>', 'CreationDate': '2012-11-12T01:03:00.430', 'Id': '6624'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '488', 'Title': 'Lambda calculus outside functional programming?', 'LastEditDate': '2012-11-21T09:12:46.613', 'AnswerCount': '4', 'Score': '9', 'OwnerDisplayName': 'AzaraT', 'PostTypeId': '1', 'OwnerUserId': '4669', 'FavoriteCount': '3', 'Body': "<p>I'm a university student, and we're currently studying Lambda Calculus. However, I still have a hard time understanding exactly why this is useful for me. I realize if you do loads of functional programming it might be useful, however I reckon that it's not really needed for learning functional programming, what do you think?</p>\n\n<p>Secondly, is there any use for Lambda Calculus within the realm of Computer Science but outside of functional programming languages? </p>\n", 'Tags': '<lambda-calculus><functional-programming>', 'LastEditorUserId': '4669', 'LastActivityDate': '2012-11-21T09:12:46.613', 'CommentCount': '0', 'AcceptedAnswerId': '6794', 'CreationDate': '2012-11-20T19:57:23.943', 'Id': '6791'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Here\'s a lab from a first-year computer science course, taught in Scheme: <a href="https://www.student.cs.uwaterloo.ca/~cs135/assns/a07/a07.pdf">https://www.student.cs.uwaterloo.ca/~cs135/assns/a07/a07.pdf</a></p>\n\n<p>At the end of the lab, it basically presents the halting problem, and shows that it is impossible to solve by introducing the function <code>diagonal</code>, which is defined as:</p>\n\n<pre><code>(de\ufb01ne (diagonal x)\n  (cond\n     [(halting? x x) (eternity 1)]\n     [else true]))\n</code></pre>\n\n<p>Where <code>eternity</code> is a non-terminating program defined as <code>(define (eternity x) (eternity x))</code>. What happens when you feed <code>diagonal</code> its own definition as input ... ?</p>\n\n<p>This is all fairly standard stuff. Then, the lab says: </p>\n\n<blockquote>\n  <p>For a real challenge, de\ufb01nitively answer the question posed at the end of Exercise 20.1.3 of the\n  text, with the interpretation that function=? consumes two lists representing the code for the two\n  functions. This is the situation Church considered in his proof.</p>\n</blockquote>\n\n<p>So the gist of it is that <code>function=?</code> takes two inputs. Each is a list, which represents the definition of a function, i.e. it is a list of the form <code>(define (id args ...) body ...)</code>. We can assume that both functions are syntactically valid and will terminate for all inputs (without runtime errors). <code>function=?</code> returns true if and only if the two functions will always return the same result when given the same inputs. For example,</p>\n\n<pre><code>(function=? \'(define (foo x) (* 2 x)) \n            \'(define (bar x) (+ x x))) ; should return #t\n\n(function=? \'(define (foo x) (+ x 1)) \n            \'(define (bar x) (+ x 2))) ; should return #f\n</code></pre>\n\n<p>Now, <code>function=?</code> is obviously impossible to write - the challenge is to <em>prove</em> it is impossible. I thought about this for a while, and the best solution I could come up with is the following:</p>\n\n<pre><code>(define (disprove-function=? x)\n  ((lambda (snip)\n     (let ((self (list \'define \'(disprove-function=? x)\n                       (list snip (list \'quote snip)))))\n       (if (function=? self \'(define (id x) x))\n           (list x)\n           x)))\n   \'(lambda (snip) \n      (let ((self (list \'define \'(disprove-function=? x)\n                        (list snip (list \'quote snip)))))\n        (if (function=? self \'(define (id x) x))\n            (list x)\n            x)))))\n</code></pre>\n\n<p>Basically, <code>disprove-function=?</code> uses standard quining techniques to generate its own source code (the variable <code>self</code>), and then asks <code>function=?</code> if it is equivalent to the identity function. If <code>function=?</code> says #f, then <code>disprove-function=?</code> will always behave like the identity function. Contradiction! If <code>function=?</code> says #t, then <code>disprove-function=?</code> will always behave differently from identity; in particular, it will behave like the <code>list</code> function. Contradiction! Thus, <code>function=?</code> can\'t exist. QED.</p>\n\n<p>My question is: is there a more elegant way to approach this problem? My solution seems ... long and ugly. Not nearly as nice as the <code>diagonal</code> function for proving that the halting problem is unsolvable.</p>\n\n<p>NB: Please give me answers and not hints! Even though this is a homework question, it is not <em>my</em> homework question: I don\'t go to this university! Further, as you can see from the lab, this question is under the <code>Enhancements</code> category and isn\'t worth marks, so even if you don\'t believe me, there is still no problem with just giving me an answer. Finally, I already <em>have</em> a solution, which I am pretty sure is right; I was just wondering if there was a <em>better</em> solution.</p>\n', 'ViewCount': '115', 'Title': 'Showing the function=? is impossible', 'LastEditorUserId': '4720', 'LastActivityDate': '2012-11-27T01:00:44.990', 'LastEditDate': '2012-11-25T02:06:41.870', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6936', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4720', 'Tags': '<undecidability><lambda-calculus><halting-problem>', 'CreationDate': '2012-11-25T01:41:33.743', 'Id': '6879'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '223', 'Title': 'Studying Programming Language Theory', 'LastEditDate': '2013-02-17T01:14:39.193', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '106', 'FavoriteCount': '2', 'Body': "<p>I have recently become extremely interested in understanding and proving aspects of (functional) programming languages.</p>\n\n<p>However as I dive deeper in, things like $\\lambda$ calculus, category theory, and denotational semantics are a little difficult to grok without proper explanation.</p>\n\n<p>I read SICP (quite an enlightening book) but I'm looking to dive deeper into the theory of functional programming. Are there any books/blogs/sites/you-name-it that would discuss the theory of functional programming languages from the ground up?</p>\n", 'Tags': '<reference-request><lambda-calculus><functional-programming><books>', 'LastEditorUserId': '106', 'LastActivityDate': '2013-02-18T01:07:53.190', 'CommentCount': '0', 'AcceptedAnswerId': '7323', 'CreationDate': '2012-12-11T04:40:37.923', 'Id': '7322'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '964', 'Title': '"Applicative order" and "Normal order" in lambda-calculus', 'LastEditDate': '2013-01-02T19:15:08.873', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4409', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p><strong>Applicative order:</strong> Always fully evaluate the arguments of a function\n  before evaluating the function itself , like -</p>\n  \n  <p>$(\\lambda x. x^2(\\lambda x.(x+1) \\ \\ 2))) \\rightarrow (\\lambda x.\n x^2(2+1))\\rightarrow \\  (\\lambda x. x^2(3)) \\rightarrow \\  3^2 \\\n \\rightarrow \\ 9$</p>\n  \n  <p><strong>Normal order:</strong> The expression would be reduced from the outside in ,\n  like  -</p>\n  \n  <p>$(\\lambda x.x^2 (\\lambda x.(x+1) \\  2)) \\rightarrow \\ (\\lambda x.(x+1)\n \\ \\ \\   2)^  2 \\rightarrow\\ (2+1)^2 \\ \\rightarrow 3^2 \\ \\rightarrow \\\n 9 $</p>\n</blockquote>\n\n<p>Let $M = (\\lambda x.y \\  (\\lambda x.(x \\  \\ x) \\  \\lambda x.(x \\ \\  x)))$</p>\n\n<p>Why is it that under applicative order, $M \\rightarrow$  infinite loop,<br>\nbut under normal order, $M \\rightarrow y$?</p>\n', 'Tags': '<logic><lambda-calculus><normal-forms>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-02T20:10:18.520', 'CommentCount': '2', 'AcceptedAnswerId': '7703', 'CreationDate': '2013-01-02T17:45:42.587', 'Id': '7702'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '535', 'Title': 'Can someone give a simple but non-toy example of a context-sensitive grammar?', 'LastEditDate': '2013-01-03T14:56:30.403', 'AnswerCount': '3', 'Score': '7', 'OwnerDisplayName': 'BlueBomber', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Body': "<p>I'm trying to understand context-sensitive grammars.</p>\n\n<p>I understand why languages like</p>\n\n<blockquote>\n  <ol>\n  <li>$\\{ww \\mid w \\in A^*\\}$</li>\n  <li>$\\{a^n b^n c^n \\mid n\\in\\mathbb{N}\\}$</li>\n  </ol>\n</blockquote>\n\n<p>are not context free, but what I'd like to know if a language similar to the untyped lambda calculus is context sensitive.</p>\n\n<p>I'd like to see an example of a simple, but non-toy (I consider the above toy examples), example of a context-sensitive grammar that can, for some production rule, e.g., tell whether or not some string of symbols is in scope currently (e.g. when producing the body of a function).</p>\n\n<p>Are context sensitive grammars powerful enough to make undefined/undeclared/unbound variables a syntactic (rather than semantic) error?</p>\n", 'Tags': '<formal-grammars><programming-languages><lambda-calculus><context-sensitive>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-09T16:31:26.590', 'CommentCount': '0', 'AcceptedAnswerId': '7718', 'CreationDate': '2013-01-01T07:51:23.580', 'Id': '7716'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>For testing automated theorem provers we have <a href="http://www.sfu.ca/~jeffpell/papers/75ATPproblems86.pdf" rel="nofollow">Seventy-Five Problems for Testing\nAutomatic Theorem Provers</a> by Pelletier.</p>\n\n<p>Are there any such standard/well regarded tests for a \u03bb-calculus that verify the evaluation?</p>\n\n<p>EDIT</p>\n\n<p>The best \u03bb-Calculus evaluator I have found so far is:</p>\n\n<p><a href="http://www.itu.dk/people/sestoft/lamreduce/lamframes.html" rel="nofollow">Lambda calculus reduction workbench</a> with info <a href="http://www.itu.dk/people/sestoft/lamreduce/index.html" rel="nofollow">here</a>.</p>\n\n<p>I like this one because<br>\n1. It is a working example that seems to corretly pass every example I can find.<br>\n2. Has a trace option for the output.<br>\n3. Can do multiple reduction strategies<br>\n    * normal order<br>\n    * call-by-name<br>\n    * head spine reduction<br>\n    * call-by-value<br>\n    * applicative order<br>\n    * hybrid normal order<br>\n    * hybrid applicative order<br>\n4. Has a list of pre defined abbreavtions such as<br>\n    * S, K, I<br>\n    * 0 - 5<br>\n    * pair<br>\n    * pred<br>\n    * succ<br>\n    * add<br>\n    * mul<br>\n5. Has source code in SML  </p>\n', 'ViewCount': '145', 'Title': u'Test cases for \u03bb-Calculus', 'LastEditorUserId': '268', 'LastActivityDate': '2013-02-07T02:10:20.710', 'LastEditDate': '2013-02-07T02:10:20.710', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<reference-request><lambda-calculus><software-testing>', 'CreationDate': '2013-01-17T19:51:51.120', 'Id': '9001'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>When working with \u03bb-Calculus I see lots of extensions that use other symbols such as \n\u2200 &lt;:Top {} \u2190, which are from "<a href="http://www.cis.upenn.edu/~bcpierce/tapl/" rel="nofollow">Types and Programming Languages</a>" (<a href="http://www.worldcat.org/title/types-and-programming-languages/oclc/51958338&amp;referer=brief_results" rel="nofollow">WorldCat</a>) by Benjamin C. Pierce.</p>\n\n<pre><code>Name                   Extends/Based on Figure                          Figure                                                   Page\nB unyped                                                                3-1 Booleans (B)                                         34\nB \u2115 (untyped)          Extends 3-1 B                                    3-2 Arithmetic expressions (\u2115B)                          41\n\u2192 (untyped)                                                             5-3 Unyped lambda-calculus (\u03bb)                           72\nB (typed)              Extends 3-1 B                                    8-1 Typing rules for booleans (B)                        93\nB \u2115 (typed)            Extends 3-1, 8-1 B                               8-2 Typing rules for numbers (\u2115B)                        93\n\u2192 (typed)              Based on5-3 \u03bb                                    9-1 Pure simply typed lambda-calculus (\u03bb\u2192)               103\n\u2192 Unit                 Extends 9-1 \u03bb\u2192                                   11-2 Unit type                                           119\n\u2192 as                   Extends 9-1 \u03bb\u2192                                   11-3 Ascription                                          122\n\u2192 let                  Extends 9-1 \u03bb\u2192                                   11-4 let binding                                         124\n\u2192 x                    Extends 9-1 \u03bb\u2192                                   11-5 Pairs                                               126\n\u2192 {}                   Extends 9-1 \u03bb\u2192                                   11-6 Tuples                                              128\n\u2192 {}                   Extends 9-1 \u03bb\u2192                                   11-7 Records                                             129\n\u2192 {} let p (untyped)   Extends 11-7, 11-4                               11-8 (Untyped) record patterns                           131\n\u2192 +                    Extends 9-1 \u03bb\u2192                                   11-9 Sums                                                132\n\u2192 +                    Extends 9-1 \u03bb\u2192                                   11-10 Sums (with unique typing)                          135\n\u2192 &lt;&gt;                   Extends 9-1 \u03bb\u2192                                   11-11 Variants                                           136\n\u2192 fix                  Extends 9-1 \u03bb\u2192                                   11-12 General recursion                                  144\n\u2192 B List               Extends 9-1 \u03bb\u2192 with 8-1 booleans                 11-13 Lists                                              147\n\u2192 Unit Ref             Extends 9-1 \u03bb\u2192 with 11-2 Unit                    13-1 References                                          166\n\u2192 error                Extends 9-1 \u03bb\u2192                                   14-1 Errors                                              172\n\u2192 error try            Extends 9-1 \u03bb\u2192 with 14-1 Errors                  14-2 Error handling                                      174\n\u2192 exceptions           Extends 9-1 \u03bb\u2192                                   14-3 Exceptions carrying values                          175\n\u2192 &lt;: Top               Extends 9-1 \u03bb\u2192                                   15-1 Simply typed lambda-calculus with subtyping (\u03bb&lt;:)   186\n\u2192 {} &lt;:                Extends 15-1 \u03bb&lt;: and 11-7 Records                15-3 Records and subtyping                               187\n\u2192 &lt;: Bot               Extends 15-1 \u03bb&lt;:                                 15-4 Bottom type                                         192\n\u2192 &lt;&gt; &lt;:                Extends 15-1 \u03bb&lt;: and 11-11 Simple variant rules  15-5 Variants and subtyping                              197\n\u2192 {} &lt;:                Extends 15-1 \u03bb&lt;: and 15-3 Records and subtyping  16-1 Subtype relataion with records (compact version)    211\n\u2192 {} &lt;:                                                                 16-2 Algorithmic subtyping                               212\n\u2192 {} &lt;:                                                                 16-3 Algorithmic typing                                  217\n\u2192 u                    Extends 9-1 \u03bb\u2192                                   20-1 Iso-recursive types (\u03bbu)                            276\n\u2192\u2200                     Based on 9-1 \u03bb\u2192                                  23-1 Polymorphic lambda-calculus (System F)              343\n\u2192\u2200\u2203                    Extends 23-1 System F                            24-1 Exestential types                                   366\n\u2192\u2200\u2203 Top                Based on 23-1 System F and 15-1 simple subtyping 26-1 Bounded quantification (kernel F&lt;:)                 392\n\u2192\u2200\u2203 Top full           Extends 26-1 F&lt;:                                 26-2 "Full" bounded quantification                       395\n\u2192\u2200&lt;: Top \u2203             Extends 26-1 F&lt;: and 24-1 unbounded existentials 26-3 Bounded existential quantification (kernel variant) 406 \n\u2192\u2200&lt;: Top                                                                28-1 Exposure Algorithm for F&lt;:                          418\n\u2192\u2200&lt;: Top               Extends 16-3 \u03bb&lt;:                                 28-2 Algorithmic typing for F&lt;:                          419\n\u2192\u2200&lt;: Top               Extends 16-2 \u03bb&lt;:                                 28-3 Algorithmic subtyping for kernel F&lt;:                422\n\u2192\u2200&lt;: Top full          Extends 28-3                                     28-4 Algorithmic subtyping for full F&lt;:                  424\n-\u21d2                     Extends 9-1 \u03bb\u2192                                   29-1 Type operators and kinding (\u03bb\u03c9)                     466\n-\u2200\u21d2                    Extends 29-1 \u03bb\u03c9 and 23-1 System F                30-1 Higher-order polymorphic lambda-calculus (F\u03c9)       450\n-\u2200\u2203\u21d2                   Extends 30-1 F\u03c9 and 24-1                         30-2 Higher-order existential types                      452\n-\u2200\u21d2&lt;: Top              Based on 30-1 F\u03c9 and 16-1 kernel F&lt;:             31-1 Higher-order bounded quantification (F\u03c9&lt;:)          470\n-\u2200&lt;: Top {}\u2190           Based on 26-1 F&lt;: with 11-7 records              32-1 Polymorphic update                                  485  \n</code></pre>\n\n<p>or use of \u03c3 and \u03bd as in</p>\n\n<p>"<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.8716" rel="nofollow">From \u03bb\u03c3 to \u03bb\u03bd-a Journey through Calculi of Explicit Substitutions</a>" by Pierre Lescanne.</p>\n\n<p>and of course <a href="http://www.rbjones.com/rbjpub/logic/cl/tlc001.htm" rel="nofollow">Barendregt\'s Lambda Cube</a>  </p>\n\n<p>Note: For the Weak systems \u03c9 should be underlined.  </p>\n\n<pre><code>\u03bb\u2192   The Simply Typed Lambda Calculus  \n\u03bb\u03c9   Weak Lambda Omega  \n\u03bb2   Polymorphic or Second Order, Typed Lambda Calculus  \n\u03bb\u03c9   The System F\u03c9  \n\u03bbP   LF  \n\u03bbP\u03c9  Weak Lambda P omega   \n\u03bbP2  Lambda P2   \n\u03bbP\u03c9  The Calculus of Constructions  \n</code></pre>\n\n<p>Is there any standard or commonality to the use of these symbols? Where can I find a listing of their meaning.</p>\n\n<p>Also, as I have shown with the extenstions using TAPL, is there any list of the most noteworthy calculi with there symbols, defnition and what they extend? </p>\n\n<p>I am really after a DAG of related \u03bb-Calculi that gives a brief explaination of each one.</p>\n', 'ViewCount': '242', 'Title': u'\u03bb-Calculus extensions: meaning of extension symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:32:58.173', 'LastEditDate': '2013-02-14T06:32:58.173', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<terminology><lambda-calculus><computation-models>', 'CreationDate': '2013-02-06T15:28:33.213', 'Id': '9548'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '599', 'Title': 'Clear, intuitive derivation of the fixed-point combinator (Y combinator)?', 'LastEditDate': '2013-02-10T23:47:01.757', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '5291', 'FavoriteCount': '6', 'Body': '<p>The fixed-point combinator FIX (aka the Y combinator) in the (untyped) lambda calculus ($\\lambda$) is defined as:</p>\n\n<p>FIX $\\triangleq \\lambda f.(\\lambda x. f~(\\lambda y. x~x~y))~(\\lambda x. f~(\\lambda y. x~x~y))$</p>\n\n<p>I understand its purpose and I can trace the execution of its application perfectly fine; <strong>I would like to understand how to derive FIX from first principles</strong>.</p>\n\n<p>Here is as far as I get when I try to derive it myself:</p>\n\n<ol>\n<li>FIX is a function: FIX $\\triangleq \\lambda_\\ldots$</li>\n<li>FIX takes another function, $f$, to make it recursive: FIX $\\triangleq \\lambda f._\\ldots$</li>\n<li>The first argument of the function $f$ is the "name" of the function, used where a recursive application is intended. Therefore, all appearances of the first argument to $f$ should be replaced by a function, and this function should expect the rest of the arguments of $f$ (let\'s just assume $f$ takes one argument): FIX $\\triangleq \\lambda f._\\ldots f~(\\lambda y. _\\ldots y)$</li>\n</ol>\n\n<p>This is where I do not know how to "take a step" in my reasoning. The small ellipses indicate where my FIX is missing something (although I am only able to know that by comparing it to the "real" FIX).</p>\n\n<p>I already have read <a href="http://rads.stackoverflow.com/amzn/click/0262162091" rel="nofollow">Types and Programming Languages</a>, which does not attempt to derive it directly, and instead refers the reader to <a href="http://mitpress.mit.edu/books/little-schemer" rel="nofollow">The Little Schemer</a> for a derivation. I have read that, too, and its "derivation" was not so helpful. Moreover, it is less of a direct derivation and more of a use of a very specific example and an ad-hoc attempt to write a suitable recursive function in $\\lambda$.</p>\n', 'Tags': '<computability><logic><programming-languages><lambda-calculus>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-10T23:47:01.757', 'CommentCount': '3', 'AcceptedAnswerId': '9651', 'CreationDate': '2013-02-08T14:23:39.617', 'Id': '9604'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>What are anonymous (lambda) functions? What is the formal definition of an anonymous function in a functional programming language? </p>\n\n<p>In my simple terms, when I am programming in scheme/lisp I would say an anonymous (lambda) function is a function that is not bound to an identifier.</p>\n\n<p>Is that all that you can say formally about a lambda function? I think there is more detail that can be added to this simple definition. Please elaborate, and thank you!</p>\n', 'ViewCount': '262', 'Title': 'anonymous lambda functions (functional programming)', 'LastEditorUserId': '41', 'LastActivityDate': '2013-02-20T06:25:28.973', 'LastEditDate': '2013-02-11T05:42:39.403', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '9663', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<logic><programming-languages><lambda-calculus><functional-programming>', 'CreationDate': '2013-02-11T01:41:11.730', 'Id': '9655'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><em>Following the article\'s notation, I write $\\mathcal{F}$ for the\ncategory of presheaves on a (suitable) category $\\mathbb{F}$, $TV$ for the\npresheaf of terms, $\\delta$ for the context extension, and\n$\\bullet$ for the product of the $\\mathcal{F}$-monoid.</em></p>\n\n<p>In <a href="http://www.dcs.ed.ac.uk/home/dt/abstractsyn.html" rel="nofollow">Abstract Syntax and Variable Binding</a> [Fiore, Plotkin, Turi], the\nauthors set out to define substitution by structural recursion\n(Section 3). I was expecting to see substitution expressed as an\ninitial algebra of some sort.</p>\n\n<p>Instead, from what I understand, the authors:</p>\n\n<ol>\n<li> Construct the substitution $\\sigma : \\delta(TV) \\times TV \\to TV$ by some universal construction ("Definition of substitution by structural recursion") </li>\n<li> Show that it forms a substitution algebra (Theorem 3.2) </li>\n<li> Show that the categories of substitution algebras and clones are equivalent (Theorem 3.3) </li>\n<li> Show that the categories of clones and monoids in $\\mathcal{F}$ are equivalent (Proposition 3.4) </li>\n<li> Show that subtitution is the multiplication of such a monoid (Proposition 3.5) </li>\n<li> Conclude that $\\sigma$, the substitution, is defined by structural recursion (Corollary 3.6). </li>\n</ol>\n\n<p>I\'m failing to appreciate their motive in moving from substitution\nalgebras to clones to monoids. Is that a natural thing to do for a\nmathematician? </p>\n\n<p>In particular, why not stay focused on substitution algebras and, I\nguess, present substitution as the initial one?</p>\n\n<p>Conversely, they claim that Corollary 3.6 gives a definition of\nsubstitution by structural recursion: how is that? It is just said\nthat "$\\sigma$ is the unique homomorphic extension of $V \\bullet TV\n\\cong TV$": how did they derive their example (substitution for the\nlambda calculus, very end of Section 3) from this statement?</p>\n', 'ViewCount': '80', 'Title': 'Substitution by structural recursion', 'LastActivityDate': '2013-02-17T21:13:47.763', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9872', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6922', 'Tags': '<lambda-calculus><category-theory>', 'CreationDate': '2013-02-17T20:48:52.867', 'FavoriteCount': '1', 'Id': '9871'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Programmers do sometimes write a program that creates infinite loop if some particular input is passed into the program.</p>\n\n<p>But Simply-typed lambda calculus has to stop - so the question is, can anyone show some "useful" program in Turing-complete language (e.g. untyped lambda calculus) that does not go into infinite loop but cannot be written in (simply-)typed lambda calculus?</p>\n\n<p>from comment section:</p>\n\n<p>"Yes I know all of these and I know that they are more expressive and those - but halting problem would only have meaning if there is an algorithm (program) that typed ones cannot express - otherwise, we can write all programs into typed one and see whether it is well-formed, right? Then we automatically know whether a program halts or not. This is what I am asking."</p>\n', 'ViewCount': '206', 'Title': 'A program that cannot be written in (simply-)typed lambda calculus but only in lambda calculus or Turing-complete language', 'LastEditorUserId': '7103', 'LastActivityDate': '2013-03-02T09:08:56.633', 'LastEditDate': '2013-03-02T09:08:56.633', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7103', 'Tags': '<complexity-theory><computability><programming-languages><lambda-calculus>', 'CreationDate': '2013-03-02T04:49:49.113', 'FavoriteCount': '1', 'Id': '10197'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Here\'s something from Slonneger\'s "Syntax and Semantics of Programming Languages":</p>\n\n<blockquote>\n  <p>A variable may occur both bound and free in the same lambda\n  expression: for example, in \u03bbx.y\u03bby.yx the first occurrence of y is\n  free and the other two are bound.</p>\n</blockquote>\n\n<p>I assume the free variable is the y right after the \u03bbx. and the bound y\'s are the \u03bby.y which I can sort of intuitively grasp. So ((\u03bbx.y\u03bby.yx)a)b) would reduce to (y\u03bby.ya)b) then to bba ? Can someone explain how this came to be? In the end it\'s the expression b twice. Can someone perhaps provide more examples of bound and free variables? </p>\n', 'ViewCount': '58', 'Title': 'Free and Bound in Lambda Calculus', 'LastActivityDate': '2013-03-02T21:17:08.893', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'user2054900', 'PostTypeId': '1', 'Tags': '<lambda-calculus>', 'CreationDate': '2013-03-02T04:47:32.160', 'FavoriteCount': '1', 'Id': '10212'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>For this term:\n      $\\lambda x.(f (g x))$, what are the free and bound variables?</p>\n\n<p>I'm confused as to how to expand this so it will be easier to see.\nIf I expand this will it be $\\lambda x. \\lambda f. \\lambda g$?</p>\n", 'ViewCount': '72', 'Title': 'Free and bound variables in a lambda-calculus term', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T13:11:16.640', 'LastEditDate': '2013-04-07T13:11:16.640', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'OwnerDisplayName': 'user', 'PostTypeId': '1', 'Tags': '<terminology><lambda-calculus><variable-binding>', 'CreationDate': '2013-04-06T23:41:20.587', 'Id': '11083'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '124', 'Title': 'Are there a lambda-mu expression equivalent to the yin yang puzzle?', 'LastEditDate': '2013-09-17T18:12:48.660', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'Earth Engine', 'PostTypeId': '1', 'OwnerUserId': '7805', 'FavoriteCount': '1', 'Body': u'<p>The <a href="http://stackoverflow.com/questions/2694679/how-does-the-yin-yang-puzzle-work">yin yang puzzle</a> was written in Scheme. Since it uses call/cc, it is not possible to express it in a pure lambda expression, unless we do a CPS transform.</p>\n\n<p>However, given the fact that $\\lambda \\mu$-calculus have the power to model call/cc, is it possible to write an equivalent $\\lambda \\mu$-expression? I am still learning $\\lambda \\mu$-deductions, so this would be a good example to show how the deduction works.</p>\n\n<p>There is no need to model the "display" command in a pure expression. Ideally only showing how the calculus keep looping and evaluates diffident terms again and again.</p>\n\n<p><strong>UPDATE</strong> My translation in $\\lambda$-expression with CPS:</p>\n\n<pre><code>(\u03bbcallcc.callcc (\u03bbyin.callcc (\u03bbyang.yin yang))(\u03bbcc.cc cc)\n</code></pre>\n\n<p>In CPS, <code>(\u03bbcc.cc cc)</code> is what "call with current continuation" means. So the expression takes it as a parameter. This will result in assign the sub-expression starts <code>\u03bbyin</code> assign its continuation into parameter <code>yin</code>. And then in the body, the second callcc assigns the <code>yang</code> of sub-expression starts <code>\u03bbyang</code> into itself. Finally, apply <code>yin yang</code>.</p>\n\n<p>Note the above translate is not full CPS, only the concept of call/cc has been translated. But it provides the same behavior and it is not hard to do a full CPS translate. </p>\n', 'Tags': '<lambda-calculus><continuations>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T18:12:48.660', 'CommentCount': '0', 'CreationDate': '2013-04-19T00:26:18.020', 'Id': '11417'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '327', 'Title': 'What makes lambda calculus relevant to study?', 'LastEditDate': '2013-09-17T17:38:58.107', 'AnswerCount': '2', 'Score': '8', 'OwnerDisplayName': 'Jules Mazur', 'PostTypeId': '1', 'OwnerUserId': '7814', 'FavoriteCount': '3', 'Body': u'<p>I\'m starting an undergraduate computer science course next fall, but I can\'t really understand \u03bb-calculus in the context of functional programming. I may be misinterpreting this completely, but based on this <a href="http://plato.stanford.edu/entries/lambda-calculus/" rel="nofollow">definition</a> from the Stanford Encyclopedia of Philosophy, it\'s just another notation for functions.</p>\n\n<p>If it <em>is</em> just that, why is it advantageous to use \u03bb-calculus over regular function notations to calculate algorithm run time?</p>\n', 'Tags': '<programming-languages><lambda-calculus>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T17:38:58.107', 'CommentCount': '4', 'AcceptedAnswerId': '11449', 'CreationDate': '2013-04-20T14:25:07.760', 'Id': '11448'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '116', 'Title': 'Is there an always-halting, limited model of computation accepting $R$ but not $RE$?', 'LastEditDate': '2013-05-10T21:42:07.617', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '0', 'Body': '<p>So, I know that the halting problem is undecidable for Turing machines. The trick is that TMs can decide recursive languages, and can accept Recursively Enumerable (RE) languages.</p>\n\n<p>I\'m wondering, is there a more limited model of computation which accepts only recursive languages, and not RE? And if so, is there such a model which is always guaranteed to halt?</p>\n\n<p>Obviously this model would be strictly less powerful than TMs and strictly more powerful than PDAs.</p>\n\n<p>I\'m open to a machine-style model, or a lambda-calculus style model.</p>\n\n<p>As an example of what I\'m thinking: the Coq language has a restriction that for any self-recursive calls, the first argument must be strictly decreasing in "size" i.e. if it is a natural number, it must be smaller, if it is a list, it must be shorter, etc. This guarantees that it always halts, but I have no idea if you can compute all of R this way.</p>\n', 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><halting-problem>', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-05-11T07:39:41.863', 'CommentCount': '1', 'AcceptedAnswerId': '11943', 'CreationDate': '2013-05-10T15:58:41.437', 'Id': '11936'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I need a little help with a lambda calculus reduction to normal form:\n$$(\\lambda xxxx.xx)(\\lambda x.xx)(\\lambda x.x)y((\\lambda x.x)x)$$\nIt should be solved like this:\n$$xx(\\lambda x.x)y((\\lambda x.x)x)$$\nand then:\n$$xx(\\lambda x.x)y(x)$$</p>\n\n<p>This is the result of any of the lambda calculators that you can find online.</p>\n\n<p>My question is: why can't I go on with reductions and make also $(\\lambda x.x)y$ so the resulting expression would be $xxy(x)$?</p>\n\n<p>Can you give me a complete answer, with theory of lambda calculus rules/proofs?</p>\n\n<p>I really want to understand this exercise, any help would be appreciated.</p>\n", 'ViewCount': '272', 'Title': 'Normal form Lambda calculus expression', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-28T07:06:07.330', 'LastEditDate': '2013-05-28T07:06:07.330', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Rose', 'PostTypeId': '1', 'Tags': '<lambda-calculus><normal-forms>', 'CreationDate': '2013-05-24T13:32:55.860', 'Id': '12268'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am working with HOL-Light parser and keeping seeing references to preterm parser. </p>\n\n<p>What is a preterm parser?</p>\n\n<p>The most informative statement I find is from the <a href="http://www.cl.cam.ac.uk/~jrh13/hol-light/reference.pdf" rel="nofollow">HOL-Light reference</a> for the parse_pretype function.</p>\n\n<blockquote>\n  <p>This is mostly an internal function; pretypes and preterms are used as\n  an intermediate representation for typechecking and overload\n  resolution and are not normally of concern to users.</p>\n</blockquote>\n', 'ViewCount': '47', 'Title': 'What is a preterm parser?', 'LastEditorUserId': '268', 'LastActivityDate': '2013-12-13T17:21:13.157', 'LastEditDate': '2013-10-27T14:17:03.933', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16473', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<lambda-calculus><parsers><type-checking>', 'CreationDate': '2013-06-05T21:59:40.477', 'Id': '12478'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am having a difficulty in deciding the scope of the left-most lambda in the following expression. </p>\n\n<pre><code>\u03bbx.x(\u03bbuv.v)(\u03bbab.a)(\u03bbcd.c)\n</code></pre>\n\n<p>I have learnt that we should put brackets in such a way that the scope of lambda will be maximum. So arrived at candidate- answer 1, below.</p>\n\n<p>On the other hand, since the expression <code>(\u03bbuv.v)(\u03bbab.a)(\u03bbcd.c)</code> does not contain any x, if we put brackets as in answer 2, still we are not changing the scope, right?</p>\n\n<p>But I know that these two answers are not equivalent. So which one is the correct one?</p>\n\n<p>The two candidate answers are:</p>\n\n<ol>\n<li><code>\u03bbx.(x(\u03bbuv.v)(\u03bbab.a)(\u03bbcd.c))</code></li>\n<li><code>(\u03bbx.x)(\u03bbuv.v)(\u03bbab.a)(\u03bbcd.c)</code> </li>\n</ol>\n\n<p>I came up with this confusion through the tutorial: <a href="http://www.utdallas.edu/~gupta/courses/apl/lambda.pdf" rel="nofollow">A Tutorial Introduction to the Lambda Calculus by Raul Rojas</a>. There, in page 6, ~T is given as <code>\u03bbx.x(\u03bbuv.v)(\u03bbab.a)(\u03bbcd.c)</code>. If we apply brackets as in my answer-1, we will not be able to evaluate ~T to F.   </p>\n', 'ViewCount': '89', 'Title': 'How to decide the scope of the following lambda expression?', 'LastEditorUserId': '8734', 'LastActivityDate': '2013-09-07T14:12:56.517', 'LastEditDate': '2013-06-18T15:49:18.680', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '12741', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8734', 'Tags': '<lambda-calculus>', 'CreationDate': '2013-06-18T15:07:57.553', 'Id': '12740'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a deep appreciation for formalisms like the Turing Machine and the $\\lambda$-Calculus, and enjoy studying them and learning more about how they relate to physical computers. I am now learning about writing GUI programs, and the graphical library (GTK) relies on things like signals and callbacks, which I have not seen modeled by either Turing Machines or the $\\lambda$-Calculus; <strong>can either the $\\lambda$-Calculus or Turing Machines model things like signals, callbacks, sleeping/waiting, or buses?</strong> If so, where can I find some good reference material to learn more? If not, why not? and are there any formalisms which are capable of expressing such things?</p>\n', 'ViewCount': '146', 'Title': 'Can the Lambda Calculus or Turing Machines model signals, callbacks, sleep/wait, or buses?', 'LastActivityDate': '2013-09-18T18:46:18.427', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><computer-architecture><lambda-calculus><church-turing-thesis>', 'CreationDate': '2013-06-20T00:58:47.687', 'Id': '12771'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am studying for my exam and I wanted to do some extra excercises, but I have some problems with solving :) Can anyone please help or give me some advice where to start? Thank you!</p>\n\n<p>We can represent every list of lambda expressions <strong>$x_0, x_1, ..., x_k$</strong> with lambda expression <strong>$[x_0, x_1, ..., x_k]$</strong> , defined as:\n<strong>$[x_0, x_1, ... , x_k] = \\lambda c n. c \\, x_0 \\, (c \\, x_1 \\, (... (c \\, x_k \\, n) ...))$</strong> </p>\n\n<p>Define lambda expression s, satisfying the equation  <strong>$s([\\underline{n_0}, ..., \\underline{n_k}]) = \\underline{n_0 + ... + n_k}$</strong> , where  <strong>$\\underline{n}$</strong> is a Church numeral, representing natural number <strong>$n$</strong>.</p>\n\n<p>Define lambda expression <strong>$r$</strong> , satisfying the equation  <strong>$r([x_0, ..., x_k]) = [x_k,  ..., x_0]$</strong> .</p>\n\n<p>Define lambda expression <strong>$h$</strong> and <strong>$t$</strong> , satisfying the equation  <strong>$h([x_0, ..., x_k]) = x_0 in t([x_0, x_1, ..., x_k]) = [x_1, ..., x_k]$</strong> .</p>\n', 'ViewCount': '102', 'Title': 'defining lambda expressions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-20T16:27:33.463', 'LastEditDate': '2013-09-20T16:27:33.463', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8749', 'Tags': '<data-structures><lambda-calculus>', 'CreationDate': '2013-06-20T06:19:20.127', 'Id': '12779'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Can somebody refer me to peer-reviewed papers studying the advantages or disadvantages of writing code in a functional style? Are there papers which discuss the applications of Lambda Calculus in fields such as Machine Learning, Language Design, etc.?</p>\n', 'ViewCount': '202', 'Title': 'Are there peer-reviewed papers studying the pros and cons of functional programming?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-07-10T19:02:23.393', 'LastEditDate': '2013-07-04T05:35:51.533', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '8998', 'Tags': '<reference-request><programming-languages><machine-learning><lambda-calculus><functional-programming>', 'CreationDate': '2013-07-03T23:37:07.887', 'FavoriteCount': '7', 'Id': '13076'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '172', 'Title': 'Is lambda calculus suitable for expressing semantics of non-functional languages?', 'LastEditDate': '2013-07-05T14:41:24.283', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': u'Petr Bedn\xe1\u0159', 'PostTypeId': '1', 'OwnerUserId': '9034', 'Body': '<p>Would it be convenient to express semantics of imperative languages (e.g. C) and object-oriented languages (e.g. Java) with $\\lambda$-calculus?</p>\n\n<p>Or in the other words: is $\\lambda$-calculus a suitable candidate for expressing semantics of all context-sensitive languages?</p>\n', 'Tags': '<programming-languages><lambda-calculus><semantics>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-06T04:24:05.467', 'CommentCount': '6', 'AcceptedAnswerId': '13103', 'CreationDate': '2013-07-05T08:13:53.170', 'Id': '13097'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I hope my question makes sense: Starting with the premise that the untyped $\\lambda $ calculus is equivalent in power to a Turing machine, to what in a Turing machine does adding types to the $\\lambda $ calculus correspond? Is there some kind of automaton analog to typing, whether static or dynamic?</p>\n', 'ViewCount': '123', 'Title': 'To what does typing correspond in a Turing Machine?', 'LastActivityDate': '2013-07-09T03:05:03.767', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><lambda-calculus><type-theory><church-turing-thesis>', 'CreationDate': '2013-07-08T05:47:39.780', 'FavoriteCount': '2', 'Id': '13158'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>From the Introduction section of Homotopy Type Theory book:</p>\n\n<blockquote>\n  <p>Type theory was originally invented by Bertrand Russell ... It was later developed as a rigorous formal system in its own right(under tha name "$\\lambda$-calculus").</p>\n</blockquote>\n\n<p>Can anyone explain me this sentence? I\'m having trouble seeing $\\lambda$-calculus as a type system.</p>\n\n<p>(also in the same paragraph, $\\lambda$-calculus called as "Church\'s type system")</p>\n', 'ViewCount': '127', 'Title': 'lambda calculus as a type theory', 'LastActivityDate': '2013-08-12T06:52:18.220', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13717', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5209', 'Tags': '<lambda-calculus><type-theory>', 'CreationDate': '2013-08-11T20:01:40.917', 'Id': '13712'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've recently started casually reading into combinatorial logic, and I noticed that a higher-order function that I regularly use is a combinator. This combinator is actually pretty useful (you can use it to define addition on polynomial equations, for example), but I never gave it a decent name. Does anyone recognise this combinator? (ignoring differences in function currying)</p>\n\n<pre><code>unknown = function (h, f, g)\n    function (x) h( f(x), g(x) )\n}\n</code></pre>\n\n<p>In lambda calculus, the fully curried implementation would be\n$\\lambda h. \\lambda f. \\lambda g. \\lambda x. h (f x) (g x)$. In other words, if $M$ is this mystery combinator, then its defining equation is $M \\, h \\, f \\, g \\, x = h \\, (f \\, x) \\, (g \\, x)$.</p>\n\n<p>If more information is needed, or my question is lacking key information please leave a comment and I will edit my question.</p>\n", 'ViewCount': '115', 'Title': 'What is the name of this combinator?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-25T13:24:35.553', 'LastEditDate': '2013-08-24T08:27:46.530', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13922', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7554', 'Tags': '<logic><lambda-calculus><functional-programming>', 'CreationDate': '2013-08-24T05:09:45.133', 'Id': '13901'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to calculate $\\text{pred}\\, c_0$, where $\\text{pred}$ is the previous church encoded number and $c_0$ is the number $0$ ($\\lambda s. \\lambda z. z$).</p>\n\n<p>The formula for $\\text{pred}$ is $\\lambda n. \\lambda s. \\lambda z. n (\\lambda g. \\lambda h. h (g s))(\\lambda u.z)(\\lambda v.v)$</p>\n\n<p>My $\\beta$ reduction looks like this so far (I've underlined the function and the applied parameter)</p>\n\n<p>$$\n\\text{pred}\\, c_0 \\to \\lambda s. \\lambda z. c_0 \\underline{(\\lambda g. \\lambda h. h (g s))}\\text{ }\\underline{(\\lambda u.z)}(\\lambda v.v) \\to $$</p>\n\n<p>$$\\lambda s. \\lambda z. c_0 (\\lambda h. h (\\underline{(\\lambda u.z)}\\text{ } \\underline{s}))(\\lambda v.v) \\to$$</p>\n\n<p>$$\\lambda s. \\lambda z. c_0 \\underline{(\\lambda h. h z)}\\text{ }\\underline{(\\lambda v.v)} \\to$$</p>\n\n<p>$$\\lambda s. \\lambda z. \\underline{c_0}\\text{ } \\underline{z} \\to$$</p>\n\n<p>$$\\lambda s. \\lambda z. (???)$$</p>\n", 'ViewCount': '88', 'Title': "What's wrong with my beta reduction of pred c_0 on Church numerals?", 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T20:05:30.100', 'LastEditDate': '2013-09-17T20:05:30.100', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14134', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9984', 'Tags': '<lambda-calculus><church-numerals>', 'CreationDate': '2013-09-04T21:00:55.873', 'Id': '14133'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm having difficulties understanding lambda calculus, specially identifying what's a redex. Which redexes are there in $\\lambda s. \\lambda z. (\\lambda u. z)(\\lambda v. v)$?</p>\n\n<p>The book uses\n$(\\lambda u. z) [u \\to (\\lambda v. v)]$, </p>\n\n<p>but isn't $(\\lambda s. \\lambda z. (\\lambda u. z))[s \\to (\\lambda v. v)]$ valid too?</p>\n", 'ViewCount': '48', 'Title': 'Which redexes are there in $\\lambda s. \\lambda z. (\\lambda u. z)(\\lambda v. v)$? How to substitute arguments?', 'LastActivityDate': '2013-09-07T11:23:37.910', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9984', 'Tags': '<lambda-calculus>', 'CreationDate': '2013-09-07T09:22:29.183', 'Id': '14184'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'ve seen two different lambda expressions for the logical NOT function.<br/>\nOne of them just applies its parameter to constants <code>true</code> and <code>false</code> internally in a reverse order:</p>\n\n<p>$NOT \\;\\;=\\;\\; \\lambda x.\\; x \\; \\mbox{false}\\; \\mbox{true} \\;\\;=\\;\\; \\lambda x. \\; x \\; (\\lambda t.\\lambda f.f) \\; (\\lambda t. \\lambda f. t ) $</p>\n\n<p>and the other one which captures two more parameters instead of passing them to the returned function externally, and applies $x$ to them in reverse order too:</p>\n\n<p>$NOT \\;\\;=\\;\\; \\lambda x. \\; \\lambda t.\\lambda f.xft$</p>\n\n<p>of which the other one seems a bit simpler (and it is also simpler when encoded in binary).</p>\n\n<p>So my question is this:<br/>\nIs there any transformation which could get me from one of these representations to the other?</p>\n\n<p>I see they are equivalent "extensionally", that is, both produce the same results. But I\'d like to "prove" it somehow by algebraic transformations, such as those for alpha, beta and eta conversions. Unfortunately, none of these can help me in this case: Alpha is just for renaming. Beta works only for function calls, but we don\'t have any function call here which could be reduced, since $x$ is free in the function body (not the whole expression, though) in all these expressions until we actually call <code>NOT</code> on something. The most close one seems to be the eta, which is related to extensional equivalence and forwarding parameters, but when the parameters are being reversed, it\'s not a simple forwarding anymore and eta doesn\'t seem to apply here.</p>\n\n<p>Is there any more conversion rule I\'m missing?<br/>\n(Well, I guess they won\'t just skip two Greek letters from no particular reason, wouldn\'t they?)</p>\n\n<p>P.S.: This question is actually a model one, since there are many other definitions for other functions which have several different forms which seem to be extensionally equivalent, but completely different with regard to the known reduction rules. I\'ve chosen the simplest example of this problem.</p>\n\n<p><strong>Edit:</strong><br/>\nTo better clarify what I\'d like to know, here\'s a diagram showing the reduction steps for both versions of the <code>not</code> function:\n<a href="http://sasq.comyr.com/Stuff/Lambda/Not.png" rel="nofollow">http://sasq.comyr.com/Stuff/Lambda/Not.png</a></p>\n\n<p>As you can see, they really both reduce to the same results (contrary to what <a href="http://cs.stackexchange.com/a/14384/2381">@Jonathan Gallagher</a> was saying below). This is what I already know: that they are confluent, and so they\'re Church-Rosser equivalent. What I <em>don\'t</em> know however is if there is any conversion rule (similar to alpha, beta &amp; eta) which could allow me to transform one form of <code>not</code> to the other. This would allow me to at least make sure if some other functions (more complicated than these two here), are also equivalent, which could be hard when they can reduce to more than just two possible answers. I\'d like to know if there\'s some conversion rule which could allow me to convert one intensional definition into another <em>when</em> two functions are already extensionally equivalent (i.e. they give the same results for the same parameters). Or (which would be better) if some function can be converted somehow to the other even if I don\'t know whether they\'re extensionally equivalent.</p>\n', 'ViewCount': '148', 'Title': 'Equivalence of two lambda expressions for NOT', 'LastEditorUserId': '2381', 'LastActivityDate': '2014-01-03T20:51:59.593', 'LastEditDate': '2013-09-18T00:39:26.020', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2381', 'Tags': '<lambda-calculus>', 'CreationDate': '2013-09-17T04:11:18.760', 'Id': '14372'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I didn\'t know how to ask this question before but now that I\'m reading about typed lambda calculus I think I\'ve got a better idea. </p>\n\n<p>There is <a href="http://stackoverflow.com/a/5239256/1219414">this answer</a> to a question asking whether CSS is Turing complete or not (note that this question is NOT about CSS at all), which I consider is not (at least in certain way, and this "certain" is what my question below is about), even if you can simulate <a href="http://en.wikipedia.org/wiki/Rule_110" rel="nofollow">Rule 110</a> with it, which is proven to be Turing complete. My intuition behind it is that only an insignificant subset of what CSS can output can be the result of a calculation. You cannot perform any calculation on colors or sizes to be set to element\'s styles.</p>\n\n<p>Now I found an even simpler example while reading about typed lambda calculus. <a href="http://www.cis.upenn.edu/~bcpierce/sf/Stlc.html#lab565" rel="nofollow">This article\'s overview</a> describes a lambda calculus that can use booleans. I noticed that, in addition to the untyped lambda calculus operations, there is the conditional operation (<code>if t1 then t2 else t3</code>), which makes perfect sense. Without this, you wouldn\'t be able to do anything with booleans, and I would go ahead and say is really not Turing complete, or at least that is Turing complete but only in a trivial way. </p>\n\n<p>So my question is, if this typed lambda calculus with booleans wouldn\'t have that conditional operator, would you say is Turing complete? If not, why not, and if yes, how would you express the fact that you cannot do any operation at all on it\'s main type of data which is what you\'d expect from any Turing complete language in a categorical, technical way such that is clear that the Turing completeness of the language is really meaningless? </p>\n\n<p>The reason why I\'m giving so much importance to this is because I was recently trying to create a small Turing complete language myself and while doing it, got to a point in which my language was Turing complete but only in this trivial way (wasn\'t as obvious as the boolean lambda calculus without conditionals above, though). If I would have asked "Is this language Turing complete?" I would have probably got "Yes" as an answer and I would\'ve think I\'m done creating my language. But I really was not. And when asking myself why am I still working on my language, I\'d like to be able to state exactly what is that my language is missing.</p>\n', 'ViewCount': '120', 'Title': 'How do you say when a language is Turing-complete only in a trivial way?', 'LastEditorUserId': '10401', 'LastActivityDate': '2013-10-05T00:52:29.057', 'LastEditDate': '2013-10-04T16:04:29.620', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14820', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><turing-completeness>', 'CreationDate': '2013-10-04T15:59:18.787', 'Id': '14814'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Would it be possible to apply $(\\lambda x.\\lambda y. x)$ to the argument $y$? It seems to me that this must not be possible as it would give a different answer if applied to a constant, call it $\\alpha$ and $y$. Namely:</p>\n\n<p>$(\\lambda x.\\lambda y. x) \\alpha = \\alpha$</p>\n\n<p>but </p>\n\n<p>$(\\lambda x.\\lambda y. x)y = \\lambda y.y$</p>\n\n<p>I am afraid that I might be making considerable mistakes but this is only the case because I have been studying $\\lambda$-calculus for just one day.</p>\n\n<p>Thank you very much in advance for your comments and suggestions.</p>\n', 'ViewCount': '30', 'Title': 'Is this $\\beta$-reduction well defined?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-06T23:14:47.590', 'LastEditDate': '2013-10-06T23:14:47.590', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14865', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10537', 'Tags': '<programming-languages><lambda-calculus><term-rewriting><variable-binding>', 'CreationDate': '2013-10-06T22:23:47.130', 'Id': '14863'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '69', 'Title': 'Confused about beta-reduction/shifting in untyped $\\lambda$-calculus with de Bruijn terms', 'LastEditDate': '2013-10-27T07:19:05.737', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10992', 'FavoriteCount': '1', 'Body': "<p>In <em>Types and Programming Languages</em>, the family of sets of terms with de Bruijn indices in the untyped $\\lambda$-calculus is defined in this way:</p>\n\n<p>Let $T$ be the smallest family of sets $\\{T_0, T_1, T_2, ...\\}$ such that</p>\n\n<ol>\n<li>$k \\in T_n$ whenever $0 \\le k \\lt n$;</li>\n<li>if $t_1 \\in T_n$ and $n \\gt 0$, then $\\lambda. t_1 \\in T_{n-1}$;</li>\n<li>if $t_1 \\in T_n$ and $t_2 \\in T_n$, then $(t_1\\ t_2) \\in T_n$.</li>\n</ol>\n\n<p>The $\\beta$-reduction operation is then defined as $(\\lambda. t_{12})\\ v_2 \\rightarrow\\ \\uparrow^{-1}([0 \\mapsto\\ \\uparrow^1(v_2)]t_{12})$, where $\\uparrow^d(t)$ is the function to add $d$ to the indices of all free variables in $t$. By the definition of the $\\uparrow$ function, if $t \\in T_n$, then $\\uparrow^d(t) \\in T_{n+d}$. Substitution is defined like so:</p>\n\n<ol>\n<li>$[j \\mapsto s]k = s\\ $if $k = j; k$ otherwise</li>\n<li>$[j \\mapsto s](\\lambda. t_1) = \\lambda. [j+1 \\mapsto\\ \\uparrow^1(s)]t_1$</li>\n<li>$[j \\mapsto s](t_1\\ t_2) = ([j \\mapsto s]t_1\\ [j \\mapsto s]t_2)$</li>\n</ol>\n\n<p>I can't seem to get these definitions to work properly in manually reducing the term $((\\lambda. 0)\\ (\\lambda. 0))$ (i.e. the identity function applied to itself). Here are the steps I've gone through in attempting to apply the $\\beta$-reduction rule; I'll add a subscript to each term indicating which set in $T$ I think the term is in, so e.g. $(\\lambda. 0_1)_0$ is an abstraction of $0 \\in T_1$, and the abstraction itself is in $T_0$. I believe that if done properly, $((\\lambda. 0_1)_0\\ (\\lambda. 0_1)_0)$ should reduce to $(\\lambda. 0_1)_0$.</p>\n\n<ul>\n<li>$(\\lambda. 0_1)_0\\ (\\lambda. 0_1)_0$</li>\n<li>(by def. of $\\beta$-reduction) $\\rightarrow\\ \\uparrow^{-1}([0 \\mapsto\\ \\uparrow^1((\\lambda. 0_1)_0)] (\\lambda. 0_1)_0)$</li>\n<li>(by def. of $\\uparrow$) $\\rightarrow\\ \\uparrow^{-1}([0 \\mapsto (\\lambda. 0_2)_1] (\\lambda. 0_1)_0)$</li>\n<li>(by def. 2 of substitution) $\\rightarrow\\ \\uparrow^{-1}(\\lambda. [1 \\mapsto\\ \\uparrow^1((\\lambda. 0_2)_1)]0_1)$</li>\n<li>(by def. of $\\uparrow$) $\\rightarrow\\ \\uparrow^{-1}(\\lambda. [1 \\mapsto (\\lambda. 0_3)_2]0_1)$</li>\n<li>(by def. 1 of substitution) $\\rightarrow\\ \\uparrow^{-1}(\\lambda. 0_1)$</li>\n</ul>\n\n<p>Now I've worked myself into a corner - $\\uparrow^{-1}(\\lambda. 0_1)$ should reduce to $(\\lambda. 0_0)_{-1}$, which is nonsensical. I also haven't actually performed any substitutions, which seems like it must be incorrect. Am I misapplying these definitions somehow?</p>\n", 'Tags': '<lambda-calculus>', 'LastEditorUserId': '10992', 'LastActivityDate': '2013-10-28T15:51:04.527', 'CommentCount': '0', 'AcceptedAnswerId': '16504', 'CreationDate': '2013-10-26T20:31:22.597', 'Id': '16454'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Functional programming has the very elegant Lambda Calculus and its variants as a backup theory. Is there such a thing for OOP? What is an abstraction for the object oriented model?</p>\n', 'ViewCount': '142', 'Title': 'Is there a theory/abstraction behind OOP?', 'LastEditorUserId': '31', 'LastActivityDate': '2013-12-15T15:43:22.080', 'LastEditDate': '2013-12-15T15:43:22.080', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11547', 'Tags': '<terminology><lambda-calculus><functional-programming><object-oriented>', 'CreationDate': '2013-12-13T20:43:26.677', 'Id': '18963'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I see how objects in a category stand for types, but where do I find the terms and more specifically the rules which tell me which of them are allowed? When I e.g. consider a <a href="http://en.wikipedia.org/wiki/Cartesian_closed_categories#Definition" rel="nofollow">Cartesian closed category</a> as model of a type theory, how are term constructors represented? </p>\n\n<p>I guess this is the same as asking how do I know or specify appropriately what the homsets of this category are, which I assume are in bijection with the lambda terms. The Curry\u2013Howard\u2013Lambek correspondence as presented at the end of the Wikipedia page <a href="http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="nofollow">Curry\u2013Howard\u2013Lambek correspondence</a> presents all terms conventionally as in a type theory, but if I start out with a category, the model, then I must have specified them in a more algebraic sense. </p>\n\n<p>And once given, does the model also represent $\\beta$ and $\\eta$ conversion? I actually read on the (quite too high level for me) <a href="http://ncatlab.org/nlab/show/syntactic+category" rel="nofollow">nLab</a> that morphisms relate to substitutions. Then I guess the lambda terms are somehow elements of the objects.</p>\n', 'ViewCount': '81', 'Title': 'What do functions look like, if I stated out with the categoical model of my type theory?', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-18T09:07:40.443', 'LastEditDate': '2013-12-18T07:30:07.547', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19089', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2695', 'Tags': '<lambda-calculus><type-theory><category-theory>', 'CreationDate': '2013-12-17T22:59:56.883', 'Id': '19074'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Say I have Simply typed lambda calculus, and add an assignment rule:</p>\n\n<pre><code>&lt;identifier&gt; : &lt;type&gt; = &lt;abstraction&gt;\n</code></pre>\n\n<p>Where <code>&lt;identifier&gt;</code> is the name of the function, <code>&lt;type&gt;</code> is the function type and <code>&lt;abstraction&gt;</code> is the abstraction to be assigned to the identifier. </p>\n\n<p>Then I add a typing rule that says that when you see an assignment such as the above, you use a temporary type context, in which the declared type (the one in <code>&lt;identifier&gt; : &lt;type&gt;</code>) is associated with the identifier, to type check <code>&lt;abstraction&gt;</code> and then make sure the declared type equals the abstraction\'s type.</p>\n\n<p>And finally I add another rule that would let me have a list of assignments on top of a lambda term which is the one I\'d evaluate, such that all these assignments would be added to the global scope before the term is evaluated.</p>\n\n<p>Seems to me that this alone would make it Turing complete since I\'d be able to do stuff like:</p>\n\n<pre><code>stackoverflow: NUM -&gt; NUM = \u03bbn:NUM.(stackoverflow n)\n(stackoverflow 0)\n</code></pre>\n\n<p>And at the same time, everything I can define in this language would be "well typed" in the sense that it wouldn\'t be able to define infinite types (I wouldn\'t be able to define the Y combinator).</p>\n\n<p>So my questions are, is this really Turing complete? And, am I missing something when I say everything would be "well typed" (like for instance, I could define the Y combinator in a way I haven\'t yet realized or is there any gotcha in this type system)?</p>\n', 'ViewCount': '63', 'Title': 'Would adding recursive named functions to Simply typed lambda calculus make it Turing complete?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-22T17:08:16.207', 'LastEditDate': '2013-12-22T17:08:16.207', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19193', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><recursion><type-theory><turing-completeness><typing>', 'CreationDate': '2013-12-22T05:19:44.457', 'Id': '19187'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>Iam a beginner in Lambda Calculus, I have a expression\nsaying </p>\n\n<p>(\u03bbx.xy)</p>\n\n<p>Here <strong>y</strong> is a free variable and <strong>x</strong> is a bound variable. My question is what would be the value of the expression (which has free variables).</p>\n', 'ViewCount': '85', 'Title': 'how to solve this lambda expression with free variable/s', 'LastActivityDate': '2013-12-23T16:13:06.807', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8701', 'Tags': '<lambda-calculus><discrete-mathematics>', 'CreationDate': '2013-12-23T06:53:11.977', 'Id': '19204'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>As there is an untyped lambda calculus, and a simply-typed lambda calculus (as described, for example, in Benjamin Pierce\'s book Types and Programming Languages), is there a simply-typed combinatory logic?</p>\n\n<p>For example, it would seem that natural types for the combinators S, K, and I would be</p>\n\n<pre><code>S : (a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c\nK : a -&gt; b -&gt; a\nI : a -&gt; a\n</code></pre>\n\n<p>where a, b, and c are type variables ranging over some set of types T.  Now, perhaps we could get started with a single base type, Bool.  Our set of types T is then Bool along with whatever types can be formed using the three patterns</p>\n\n<pre><code>(a -&gt; b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c\na -&gt; b -&gt; a\na -&gt; a\n</code></pre>\n\n<p>where a, b, c in T.</p>\n\n<p>There would be two new constants in the language.</p>\n\n<pre><code>T : Bool\nF : Bool\n</code></pre>\n\n<p>So, this language consists of the symbols S, K, I, T, and F, along with parentheses.  It has one base type Bool, and the "function types" that can be made from the S, K, and I combinator patterns.</p>\n\n<p>Can this system be made to work?  For example, is there a well-typed if-then-else construction that can be formed from only S, K, I, T, F?</p>\n', 'ViewCount': '30', 'Title': 'Simply Typed Combinatory Logic?', 'LastActivityDate': '2013-12-29T03:46:31.960', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '19353', 'Score': '5', 'OwnerDisplayName': 'Scott Walck', 'PostTypeId': '1', 'Tags': '<functional-programming><logic><lambda-calculus>', 'CreationDate': '2013-12-24T16:12:48.470', 'Id': '19352'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m reading about this algorithm while writing an implementation, and see that, as long as every variable is bound, you\'ll always get either atomic types or types where the arguments will determine the final type, such as <code>t1 -&gt; t1</code> or <code>(t1 -&gt; t2) -&gt; (t1 -&gt; t2)</code>. </p>\n\n<p>I cannot think of a way you\'d get something like <code>t1 -&gt; t2</code> or simply <code>t1</code>, which I understand would mean the algorithm is broken since there would be no way to determine the actual type of the expression. How do you know you\'ll never get a type such as these "broken" ones as long as every variable is bound?</p>\n\n<p><strong>EDIT</strong> Seems that you can get these "broken" types in ML, but I\'m asking about lambda calculus.</p>\n', 'ViewCount': '97', 'Title': 'Why will the Hindley-Milner algorithm never yield a type like t1 -> t2?', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-01-01T17:44:44.103', 'LastEditDate': '2014-01-01T17:44:44.103', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '19431', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><type-theory><typing><type-inference>', 'CreationDate': '2014-01-01T03:28:39.107', 'Id': '19430'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to understand <a href="http://www.cs.rpi.edu/academics/courses/spring11/proglang/handouts/lambda-calculus-chapter.pdf" rel="nofollow">this</a> lecture, section 2.7. Why would the normal order sequencing print out <code>"hello" "world"</code> and not <code>"world" "hello"</code>? I may be misinterpreting the order in which the arguments are applied.</p>\n\n<p>It looks like the expression </p>\n\n<p>$$\n((Seq (display "hello"))\\; (display "world"))\n$$</p>\n\n<p>would evaluate to</p>\n\n<p>$$\n\\lambda z.((display "world")\\; (display "hello"))\n$$</p>\n\n<p>and that would, under normal order, would print out <code>"world" "hello"</code>.</p>\n\n<p>My question is whether the assumption I\'m making is correct. If not, could you show the correct derivation of the end-expression?</p>\n', 'ViewCount': '38', 'Title': 'Normal order sequencing vs applicative order sequencing', 'LastActivityDate': '2014-01-05T06:47:56.200', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19508', 'Score': '1', 'OwnerDisplayName': 'alexwriteshere', 'PostTypeId': '1', 'OwnerUserId': '12599', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2014-01-04T04:35:17.650', 'Id': '19507'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m going to take the few pieces of knowledge I have about lambda calculi and ask a pair of very uninformed questions :-)</p>\n\n<p>Is it possible to "embed" the corners of the lambda cube within the untyped lambda calculus?  </p>\n\n<p>It would seem that this might lead to a language where the programmer implements the type system in the language, rather than having it already implemented in the compiler.  Also, maybe the concept of type system could be generalized to "any arbitrary compile-time or run-time constraint checking".  Does such a language already exist?</p>\n', 'ViewCount': '65', 'Title': 'Can type information be encoded in the untyped lambda calculus?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-17T08:42:03.753', 'LastEditDate': '2014-01-17T08:42:03.753', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12900', 'Tags': '<programming-languages><lambda-calculus><typing><type-checking>', 'CreationDate': '2014-01-16T17:13:25.953', 'Id': '19767'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Consider two lambda expressions $\\mu$, $\\nu$ representing computable functions $f_{\\mu,\\nu}:\\mathbb{N} \\rightarrow \\mathbb{N}$. If $\\mu$ and $\\nu$ are equivalent under the combination of $\\beta$-reductions, $\\alpha$-conversions and $\\eta$-conversions then $f_\\mu=f_\\nu$. </p>\n\n<blockquote>\n  <p>Under what conditions does the converse hold? In particular, if it is possible to prove in Peano arithmetic that $f_\\mu=f_\\nu$, does it follow $\\mu$, $\\nu$ are equivalent in the above sense?</p>\n</blockquote>\n', 'ViewCount': '78', 'Title': 'How strong is equivalence of lambda expressions?', 'LastActivityDate': '2014-02-05T18:01:05.057', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '13206', 'Tags': '<logic><lambda-calculus>', 'CreationDate': '2014-01-29T01:21:58.243', 'Id': '20052'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '143', 'Title': 'Define a list using only the Hindley-Milner type system', 'LastEditDate': '2014-01-30T20:26:58.877', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10401', 'FavoriteCount': '3', 'Body': u'<p>I\'m working on a small lambda calculus compiler that has a <a href="http://codereview.stackexchange.com/questions/38763/is-this-implementation-of-the-hindley-milner-algorithm-correct">working Hindley-Milner type inference system</a> and now also supports recursive let\'s (not in the linked code), which I understand <a href="http://cs.stackexchange.com/questions/19187/would-adding-recursive-named-functions-to-simply-typed-lambda-calculus-make-it-t">should be enough to make it Turing complete</a>. </p>\n\n<p>The problem now is I have no idea how to make it support lists, or whether it already does support them and I just need to find a way to encode them. I\'d like to be able to define them without having to add new rules to the type system.</p>\n\n<p>The easiest way I can think of a list of <code>x</code> is as something that is either <code>null</code> (or the empty list), or a pair that contains both an <code>x</code> and a list of <code>x</code>. But to do this I need to be able to define pairs and or\'s, which I believe are the product and the sum types.</p>\n\n<p>Seems that I can define pairs this way:</p>\n\n<pre><code>pair = \u03bbabf.fab\nfirst = \u03bbp.p(\u03bbab.a)\nsecond = \u03bbp.p(\u03bbab.b)\n</code></pre>\n\n<p>Since <code>pair</code> would have the type <code>a -&gt; (b -&gt; ((a -&gt; (b -&gt; x)) -&gt; x))</code>, after passing, say, an <code>int</code> and a <code>string</code>, it\'d yield something with type <code>(int -&gt; (string -&gt; x)) -&gt; x</code>, which would be the representation of a pair of <code>int</code> and <code>string</code>. What bothers me here is that if that represents a pair, why is that not logically equivalent to, nor implies the proposition <code>int and string</code>?. However, is equivalent to <code>(((int and string) -&gt; x) -&gt; x)</code>, as if I could only have product types as parameters to functions. <a href="http://mathoverflow.net/a/151319">This answer</a> seem to address this problem, but I have no idea what the symbols he uses mean. Also, if this does not really encode a product type, is there anything I can do with product types I couldn\'t do with my definition of pairs above (considering I can also define n-tuples the same way)? If not, wouldn\'t this contradict the fact that you cannot express (AFAIK) conjunction using only implication?</p>\n\n<p>Also, how about the sum type? Can I somehow encode it using only the function type? If so, would this be enough to define lists? Or else, is there any other way to define lists without having to extend my type system? And if not, what changes would I need to make if I want to keep it as simple as possible?</p>\n\n<p>Please keep in mind that I\'m a computer programmer but not a computer scientist nor a mathematician and pretty bad at reading math notation.</p>\n\n<p><strong>Edit:</strong>  I\'m not sure what\'s the technical name of what I have implemented so far, but all I have is basically the code I\'ve linked above, which is a constraint generation algorithm that uses the rules for applications, abstractions and variables taken from the Hinley-Milner algorithm and then a unification algorithm that gets the principal type. For instance, the expression <code>\\a.a</code> will yield the type <code>a -&gt; a</code>, and the expression <code>\\a.(a a)</code> will throw an occurs check error. On top of this, there is not exactly a <code>let</code> rule but a function that seems to have the same effect that lets you define recursive global functions like this pseudo-code:</p>\n\n<pre><code>GetTypeOfGlobalFunction(term, globalScope, nameOfFunction)\n{\n    // Here \'globalScope\' contains a list of name-value pair where every value is of class \'ClosedType\', \n    // meaning their type will be cloned before unified in the unification algorithm so that they can be used polymorphically \n    tempType = new TypeVariable() // Assign a dummy type to `tempType`, say, type \'x\'.\n    // The next line creates an scope with everything in \'globalScope\' plus the \'nameOfFunction = tempType\' name-value pair\n    tempScope = new Scope(globalScope, nameOfFunction, tempType) \n    type = TypeOfTerm(term, tempScope) // Calculate the type of the term \n    Unify(tempType, type)\n    return type\n    // After returning, the code outside will create a \'ClosedType\' using the returned type and add it to the global scope.\n}\n</code></pre>\n\n<p>The code basically gets the type of the term as usual, but before unifying, it adds the name of the function being defined with a dummy type into the type scope so that it can be used from within itself recursively. </p>\n\n<p><strong>Edit 2:</strong> I just realized that I\'d also need recursive types, which I don\'t have, to define a list like I want.</p>\n', 'Tags': '<lambda-calculus><type-theory><type-inference>', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-02-03T12:07:00.370', 'CommentCount': '4', 'AcceptedAnswerId': '20151', 'CreationDate': '2014-01-29T22:45:04.833', 'Id': '20088'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I would like an example of a <a href="http://en.wikipedia.org/wiki/Quine_%28computing%29" rel="nofollow">quine</a> in pure <a href="http://en.wikipedia.org/wiki/Lambda_calculus" rel="nofollow">lambda calculus</a>. I was quite surprised that I couldn\'t find one by googling. <a href="http://www.nyx.net/~gthompso/quine.htm" rel="nofollow">The quine page</a> lists quines for many \n"real" languages, but not for lambda calculus.</p>\n\n<p>Of course, this means defining what I mean by a quine in the lambda calculus, which I do below. (I\'m asking for something quite specific.)</p>\n\n<p>In a few places, e.g. Larkin and Stocks (2004), I see the following quoted as a "self-replicating" expression: $(\\lambda x.x \\; x)\\;(\\lambda x.x \\; x)$. This reduces to itself after a single beta-reduction step, giving it a somehow quine-like feel. However, it\'s un-quine-like in that it doesn\'t terminate: further beta-reductions will keep producing the same expression, so it will never reduce to normal form. To me a quine is a program that terminates and outputs itself, and so I would like a lambda expression with that property.</p>\n\n<p>Of course, any expression that contains no redexes is already in normal form, and will therefore terminate and output itself. But that\'s too trivial. So I propose the following definition in the hope that it will admit a non-trivial solution:</p>\n\n<p><em>definition</em> (tentative): A quine in lambda calculus is an expression of the form\n$$(\\lambda x . A)$$\n(where $A$ stands for some specific lambda calculus expression) such that $((\\lambda x . A)\\,\\, y)$ becomes $(\\lambda x . A)$, or something equivalent to it under changes of variable names, when reduced to normal form, for <em>any</em> input $y$.</p>\n\n<p>Given that the lambda calculus is as Turing equivalent as any other language, it seems as if this should be possible, but my lambda calculus is rusty, so I can\'t think of an example.</p>\n\n<p><strong>Reference</strong></p>\n\n<p>James Larkin and Phil Stocks. (2004) "Self-replicating expressions in the Lambda Calculus"\nConferences in Research and Practice in Information Technology, 26 (1), 167-173.\n<a href="http://epublications.bond.edu.au/infotech_pubs/158" rel="nofollow">http://epublications.bond.edu.au/infotech_pubs/158</a></p>\n', 'ViewCount': '108', 'Title': 'A quine in pure lambda calculus', 'LastEditorUserId': '13299', 'LastActivityDate': '2014-02-07T05:08:00.917', 'LastEditDate': '2014-02-07T05:08:00.917', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '13299', 'Tags': '<lambda-calculus>', 'CreationDate': '2014-02-06T09:05:03.560', 'Id': '21367'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am currently writing lists with lazy semantics in the pure\nlambda-calculus with call-by-value reduction strategy.</p>\n\n<p>Here is an example: <a href="http://pastebin.com/yLtjdDzV" rel="nofollow">http://pastebin.com/yLtjdDzV</a></p>\n\n<p>Here is a simple (and very inefficient) interpeter: <a href="http://pastebin.com/LxrqB5c4" rel="nofollow">http://pastebin.com/LxrqB5c4</a></p>\n\n<pre><code>Edit: \n</code></pre>\n\n<p>I tried to construct pleasant to use and relatively efficient "lazy" functions on lists. As in the Church encoding I identify list with its right fold function, but with some differences. Here is nil and cons:</p>\n\n<pre><code>nil  = \\     _ _ z. z\ncons = \\x xs _ f z. f (\\_. x) (\\f\' _. force xs f\' z)\n</code></pre>\n\n<p>This representation of cons gives a simple way to get the tail of a list, which is O(1):</p>\n\n<pre><code>tail = \\xs f z. force xs (\\_ r. force (r f)) z\n</code></pre>\n\n<p>You just discard the first argument of f in cons and force the second after applying it to function f, which tail function receives. But it brings some problems with foldr. Consider</p>\n\n<pre><code>cons (s z) (cons (s (s z)) nil) \n</code></pre>\n\n<p>After call-by-value and full beta-reduction (it reduces a term to a readable form) it becomes</p>\n\n<pre><code>\\_ f z. f (\\_ s z. s z) (\\f\' _. f\' (\\_ s z. s (s z)) (\\\'f\' _. z))\n</code></pre>\n\n<p>To fold this term with one function, e.g. plus, you need to wrap and replicate it a little:</p>\n\n<pre><code>(\\x r. plus (force x) (force (r \n(\\x r. plus (force x) (force (r _))))))\n</code></pre>\n\n<p>\'_\' means "there is no difference, what term to choose". Then you add a default value z and after call-by-value and full beta-reduction the whole term</p>\n\n<pre><code>force (cons (s z) (cons (s (s z)) nil))\n    (\\x r. plus (force x) (force (r \n    (\\x r. plus (force x) (force (r _)))))) z\n</code></pre>\n\n<p>reduces to</p>\n\n<pre><code>\\s z. s (s (s z))\n</code></pre>\n\n<p>foldr is the generalization of this idea and defined as</p>\n\n<pre><code>foldr = \\f z xs. force xs (fix (\\rec f x r. f x (r (rec f))) f) z\n</code></pre>\n\n<p>"Wrapping and replicating" is defined by fix, which is Z-combinator.</p>\n\n<p>Having head and tail functions it\'s easy to define take:</p>\n\n<pre><code>take = fix (\\take n xs. if (eq0 n) nil (ifNullNil xs\n    (\\xs. consC (\\_. head xs) (take (pred n) (tail xs)))))\n</code></pre>\n\n<p>ifNullNil returns nil, if function null (emptyness test) returns true for its first argument, or applies the second to the first and wraps the result into the thunk otherwise:</p>\n\n<pre><code>ifNull    = \\xs z f. if (null xs) z (\\_. force (f xs))\nifNullNil = \\xs. ifNull xs nil\n</code></pre>\n\n<p>consC receives a thunk instead of a value and defined as</p>\n\n<pre><code>consC = \\x xs _ f z. f x (\\f\' _. force xs f\' z);\n</code></pre>\n\n<p>Finally you can define infinite lists:</p>\n\n<pre><code>nats = fix (\\rec n _. force (cons n (rec (s n)))) z\n</code></pre>\n\n<p>And compose them with usual functions on lists:</p>\n\n<pre><code>foldr (\\x acc. plus (force x) (force acc)) z (take (s (s (s z))) (cons (s (s (s z))) nats))\n</code></pre>\n\n<p>It reduces to</p>\n\n<pre><code>\\s z. s (s (s (s z)))\n</code></pre>\n\n<p>and equals to Haskell\'s</p>\n\n<pre><code>foldr (+) 0 $ take 3 $ 3:[0..] -- 3 + 0 + 1 + 0 = 4\n\nEdit2:\n</code></pre>\n\n<p>You need an extra \'_\' in the arguments of cons because it allows you to compose ordinary functions with functions, that generate infinite lists. Consider</p>\n\n<pre><code>nats = fix (\\rec n _. force (cons n (rec (s n)))) z\n</code></pre>\n\n<p>It reduces to</p>\n\n<pre><code>nats = \\_. force (cons z (fix (\\rec n _. force (cons n (rec (s n)))) (s z)))\n</code></pre>\n\n<p>So list, which cons receives, should be "forceable". So list, which cons produces, should be "forceable" too, because you want to compose conses.</p>\n\n<p>So my question is: are there some sources, from where I can learn more about such a representation or a better representations, that allow you to write programms with lazy semantics in languages with eager evaluation, especially in the pure lambda-calculus?</p>\n', 'ViewCount': '117', 'Title': 'Lazy lists with call-by-value reduction strategy', 'LastEditorUserId': '14652', 'LastActivityDate': '2014-02-16T10:05:56.943', 'LastEditDate': '2014-02-16T10:05:56.943', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '2', 'OwnerDisplayName': 'user3237465', 'PostTypeId': '1', 'OwnerUserId': '14652', 'Tags': '<lambda-calculus>', 'CreationDate': '2014-02-13T11:01:15.397', 'Id': '21605'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let </p>\n\n<p>$T\\equiv\\lambda xy.x$<br>\n$F\\equiv\\lambda xy.y$</p>\n\n<p>Numbers are represented as:</p>\n\n<p>$0\\equiv\\lambda sz.z$<br>\n$1\\equiv\\lambda sz.s(z)$<br>\n$2\\equiv\\lambda sz.s(s(z))$<br>\n$N\\equiv\\lambda sz.\\underbrace{s(s( ... (s(}_\\text{N times}z))...))$</p>\n\n<p>I want to define zero checking expression $Z$, being applied to $0$ reduces to $T$, otherwise $F$. </p>\n\n<p>$Z\\equiv\\lambda f.f(\\lambda t.F)T$</p>\n\n<p>$Z0\\equiv(\\lambda f.f(\\lambda t.F)T)(\\lambda sz.z)=(\\lambda sz.z)(\\lambda t.F)T=T$<br>\n$ZN\\equiv(\\lambda f.f(\\lambda t.F)T)(\\lambda sz.\\underbrace{s(s( ... (s(}_\\text{N times}z))...)))=(\\lambda sz.\\underbrace{s(s( ... (s(}_\\text{N times}z))...)))(\\lambda t.F)T=\\underbrace{(\\lambda t.F)((\\lambda t.F)( ... ((\\lambda t.F)(}_\\text{N times}T))...)))=F$  </p>\n\n<p>Is my solution correct?</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-02-22T09:51:57.947', 'Title': 'Definition of zero checking expression', 'LastEditorUserId': '14932', 'LastActivityDate': '2014-02-22T07:49:06.977', 'LastEditDate': '2014-02-22T07:49:06.977', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14932', 'Tags': '<lambda-calculus>', 'CreationDate': '2014-02-22T05:31:09.817', 'Id': '21917'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m currently learning untyped $\\lambda$-calculus and especially the $\\eta$-reduction.</p>\n\n<p>The professor hat the following in his slides:</p>\n\n<p>$$\\lambda x. \\lambda y. f~z~x~y \\stackrel{\\eta}{=} \\lambda x. f~z~x$$</p>\n\n<p>I don\'t know how to read and understand this. Could you please explain it to me?</p>\n\n<h2>My try</h2>\n\n<p>On the left side and the right side is a function and they are $\\eta$-equivalent.</p>\n\n<p>The right side seems simpler, so I start with that.</p>\n\n<p>It is a $\\lambda$ function with one bound parameter $x$ and two unbound parameters $f$ and $z$. But here start my problems: What does $f~z~x$ mean? Is this a triple? Is it a function $f$ and a function $z$ and a function $x$?</p>\n\n<p>I think in $\\lambda$-calculus everything can be viewed as a $\\lambda$-function, so $f$, $z$ and $x$ are functions. So the right side is the same as</p>\n\n<p>$$\\lambda(x) = f(z(x))$$</p>\n\n<p>correct?</p>\n\n<p>Applying the same logic on the left side, I get:</p>\n\n<p>\\begin{align}\n\\lambda x. \\lambda y. f~z~x~y &amp;= \\lambda(x)\\\\\n&amp;= f(z(x(y)))\n\\end{align}</p>\n\n<p>As $y$ is not in $\\lambda(x)$ it is not bound. So we can simply remove it. Correct?</p>\n\n<p>I think this could work. But I still don\'t know how to read it. I guess it will be something like:</p>\n\n<p>"The lambda-function with the parameter $x$ that is a lambda function with a parameter y is f applied to z applied to x applied to y is eta-equivalent to the lambda function with the paramter x that is f applied to z applied to x".</p>\n', 'ViewCount': '57', 'Title': 'How should $\\lambda x. \\lambda y. f z x y \\stackrel{\\eta}{=} \\lambda x. f z x$ be read?', 'LastActivityDate': '2014-03-02T23:32:42.713', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '22192', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2914', 'Tags': '<lambda-calculus>', 'CreationDate': '2014-03-02T12:15:37.643', 'Id': '22188'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '192', 'Title': 'Why is it important for functions to be anonymous in lambda calculus?', 'LastEditDate': '2014-03-12T11:21:46.183', 'AnswerCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '15533', 'FavoriteCount': '2', 'Body': '<p>I was watching the lecture by Jim Weirich, titled \'Adventures in Functional Programming\' (<a href="http://vimeo.com/45140590" rel="nofollow">http://vimeo.com/45140590</a>). In this lecture, he introduces the concept of Y-combinators, which essentially finds the fixed point for higher order functions. One of the motivations, as he mentions it, is to be able to express recursive functions using lambda calculus so that the theory by Church (anything that is effectively computable can be computed using lambda calculus) stays. The problem is that a function cannot call itself simply so, because lambda calculus does not allow named functions, i.e.,</p>\n\n<p>n(x, y) = x + y</p>\n\n<p>cannot bear the name \'n\', it must be defined anonymously:</p>\n\n<p>(x, y) -> x + y</p>\n\n<p>Why is it important for lambda calculus to have functions that are not named? What principle is violated if there are named functions? Or is it that I just misunderstood jim\'s video?</p>\n', 'Tags': '<lambda-calculus><functional-programming>', 'LastEditorUserId': '15533', 'LastActivityDate': '2014-03-13T07:49:23.543', 'CommentCount': '13', 'AcceptedAnswerId': '22503', 'CreationDate': '2014-03-11T11:04:11.983', 'Id': '22497'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I need to verify the type for the lambda expression: $\\lambda f.\\lambda x.f (f x)$</p>\n\n<p>My method gives me: $(a\\rightarrow c)\\rightarrow b\\rightarrow c$</p>\n\n<p>Im trying to define it in Haskell (on Hugs) like this: </p>\n\n<pre><code>h= \\f x -&gt; f (f x)\n</code></pre>\n\n<p>When i call the :type comamnd it gives me:</p>\n\n<pre><code>(a -&gt; a) -&gt; a -&gt; a\n</code></pre>\n\n<p>Is mi function correctly defined in Haskell?, or my method gives me a wrong result?</p>\n', 'ViewCount': '27', 'Title': 'Verify the type of a lambda expression', 'LastActivityDate': '2014-03-19T17:51:33.670', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22815', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12923', 'Tags': '<lambda-calculus><type-theory>', 'CreationDate': '2014-03-19T03:11:41.567', 'Id': '22791'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Firstly, I'd like to say that my text below may contain errors, so feel free to point out any mistakes in my formulation of the question.</p>\n\n<p>Consider an untyped lambda calculus with booleans and if-statements whose terms are given by this syntax:</p>\n\n<pre><code> t ::= v | t t | if t t t | x\n v ::= \\x.t | #t | #f\n</code></pre>\n\n<p>Contexts C in this case would be given according to this syntax:</p>\n\n<pre><code>C ::= [-] | \\x. C | C t | t C | if C t t | if t C t | if t t C \n</code></pre>\n\n<p>Additionally, one could define evaluation contexts E according to this other syntax:</p>\n\n<pre><code>E ::= [-] | \\x. E | v E | E t | if E t t \n</code></pre>\n\n<p>I split my question in three sub-points which I'd like to be addressed.</p>\n\n<ol>\n<li>When are the two notions used? I know for example that evaluation contexts are used to define the semantics of the calculus, but the usage of contexts still somewhat eludes me. Also I'd like some confirmation of my knowledge here.</li>\n<li>When is one to be preferred to the other and why?</li>\n<li>Could you point to relevant articles that could help me sort out this matter?</li>\n</ol>\n", 'ViewCount': '78', 'Title': 'Lambda calculus: difference between contexts and evaluation contexts', 'LastActivityDate': '2014-03-20T14:41:39.790', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '6', 'OwnerDisplayName': 'Squera', 'PostTypeId': '1', 'Tags': '<programming-languages><lambda-calculus>', 'CreationDate': '2014-03-19T12:10:15.223', 'Id': '22864'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was wondering if anyone had any good references or book recommendations that cover abstract syntax trees (ASTs). Specifically, I am interested in the abstract syntax trees of different evaluation strategies (call by value vs. call by name) of the pure lambda calculus. I would like to be able to draw the AST of some pure lambda calculus expression such as\n$$and \\, true \\, false = (\\lambda a. \\lambda b. a \\, b \\, (\\lambda t. \\lambda f. f))(\\lambda t. \\lambda f. t)(\\lambda t. \\lambda f. f).$$</p>\n\n<p>I would like to know if/how evaluation strategies affect the structure of ASTs, or how order of operation is reflected in the AST of an expression. This seems trivial for any pure lambda calculus interpreter; so perhaps there is some AST generator out there somewhere? I did some searching on Google but found nothing.</p>\n\n<p>I think if I could just get some practice with the AST representation of some non-trivial functions in any language, I will be okay.</p>\n', 'ViewCount': '27', 'Title': 'Abstract Syntax Tree of Pure Lambda Calculus', 'LastActivityDate': '2014-03-23T05:29:48.010', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22958', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<lambda-calculus><syntax-trees>', 'CreationDate': '2014-03-22T22:44:40.753', 'Id': '22949'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the pure lambda calculus, we have the inductively defined set of terms (the grammar):\n$$e::= x \\mid \\lambda x . e \\mid e_1 e_2$$</p>\n\n<p>Under the call-by-value evaluation strategy, we have the inference rules for beta-reduction and rules on how to evaluate applications (congruence rules). I am trying to understand how evaluation contexts can replace the congruence rules without actually changing the syntax of the language. Without evaluation contexts, we have the following:</p>\n\n<p>$$\n\\frac{e_1 \\rightarrow e_1\'}{e_1e_2 \\rightarrow e_1\'e_2}\n$$\nand\n$$\n\\frac{e_2 \\rightarrow e_2\'}{ve_2 \\rightarrow ve_2\'}.\n$$</p>\n\n<p>This makes sense, since if we have an instance of an expression $t = (\\lambda f . \\lambda x. f x)((\\lambda y .y)\\lambda z .z)\\lambda w.w$, it is clear that it is of the form $e_1e_2 \\rightarrow e_1\'e_2$ and thus $$(\\lambda f . \\lambda x. f x)((\\lambda y .y)\\lambda z .z)\\lambda w.w \\rightarrow (\\lambda f . \\lambda x. f x)(\\lambda z .z)\\lambda w.w$$</p>\n\n<p>If we replace the congruence rules with evaluation contexts:\n$$E::= [\\cdot] \\mid Ee \\mid vE$$\nthen we need only a single rule to express the congruence rules of the language:\n$$\n\\frac{e \\rightarrow e\'}{E[e] \\rightarrow E[e\']}.\n$$</p>\n\n<p>I am confused as to how evaluation contexts can tell us how to evaluate the expression $t$ from above without changing the syntax of the language. I don\'t understand how the evaluation context "works" without rewriting $t$ as </p>\n\n<p>$$E_t = (\\lambda f . \\lambda x. f x)[\\cdot]\\lambda w.w$$</p>\n\n<p>where $t = E_t[((\\lambda y .y)\\lambda z .z)]$. There is no obvious a priori reason to evaluate $t$ under call-by-value without knowledge of $E_t$. I really have no idea where I am going wrong. Can someone help correct my thinking?</p>\n', 'ViewCount': '70', 'Title': 'Lambda Calculus: How do evaluation contexts "work"', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T07:08:12.150', 'LastEditDate': '2014-03-24T10:30:47.387', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23314', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15660', 'Tags': '<programming-languages><lambda-calculus><semantics>', 'CreationDate': '2014-03-23T00:44:53.920', 'Id': '22954'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus" rel="nofollow">Wikipedia article on Simply Typed Lambda Calculus</a> (among other places), there is a notion of a "term constant".  This is particularly notable in the production grammar given:</p>\n\n<p><img src="http://i.stack.imgur.com/4b722.png" alt="enter image description here"></p>\n\n<p>In this production grammar, the <code>c</code> is the term constant.  I am new to the simply typed variant of lambda calculus -- I do not understand what role this constant plays in the overall computations of STLC.  Can anyone give some examples of how the term constant is used and explain its general purpose?</p>\n', 'ViewCount': '37', 'Title': 'Role of Term Constants in Simply Typed Lambda Calculus', 'LastActivityDate': '2014-03-24T16:06:35.497', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '22965', 'Score': '0', 'OwnerDisplayName': 'BlackVegetable', 'PostTypeId': '1', 'OwnerUserId': '14648', 'Tags': '<type-theory><lambda-calculus>', 'CreationDate': '2014-03-22T19:06:16.520', 'Id': '22964'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm wondering if there is a way to extend Hinley-Milner's type system to allow polymorphic types without the need of a let construct, by adding an intersection type (as Dan pointed out) that represents the possible types of a function type.</p>\n\n<p>Say I have this expression:</p>\n\n<p>$\\lambda x.\\lambda y.(x\\ (x\\ y))$</p>\n\n<p>While running the type inference algorithm, I'd normally, after looking at the expression $(x\\ y)$, assign to $x$ some type $Y \\rightarrow A$, where $Y$ is the type of $y$ and $A$ is whatever $x$ returns. Then, since $x$ also takes $(x\\ y)$ which has the type $A$, I replace $Y$ with $A$, such that the type of $x$ becomes $A \\rightarrow A$ and give to the whole thing the type $(A \\rightarrow A) \\rightarrow (A \\rightarrow A)$.</p>\n\n<p>But what if I, instead of replacing $Y$ with $A$ when I see $(x\\ (x\\ y))$, add a new type to $x$, say, $A \\rightarrow B$, such that the final type is $((Y \\rightarrow A) \\wedge (A \\rightarrow B)) \\rightarrow (Y \\rightarrow B)$, which is also a tautology and seems like a better representation of what the function does.</p>\n\n<p>Now say I give to this abstraction the term $\\lambda n.n$ like this:</p>\n\n<p>$(\\lambda x.\\lambda y.(x\\ (x\\ y))\\ \\lambda n.n)$</p>\n\n<p>Since $\\lambda n.n$ has the type $N \\rightarrow N$, I'd need to unify $N \\rightarrow N$ with $((Y \\rightarrow A) \\wedge (A \\rightarrow B))$. So I instantiate two copies of $N \\rightarrow N$, say $N_1 \\rightarrow N_1$ and $N_2 \\rightarrow N_2$, and unify $N_1 \\rightarrow N_1$ with $Y \\rightarrow A$ and $N_2 \\rightarrow N_2$ with $A \\rightarrow B$. Because $A$ would be equal to $N_1$ on one side and equal to $N_2$ on the other side, $N_1$, $Y$, $A$ and $B$ are all equal to $N_2$, so the type $Y \\rightarrow B$ becomes $N_2 \\rightarrow N_2$, which is consistent with the expression you'd get after evaluating the lambda term.</p>\n\n<p>With this type system I should be able to type things like this:</p>\n\n<p>$(\\lambda i.\\lambda x.\\lambda y.((i\\ x)\\ (i\\ y))\\ \\lambda n.n)$</p>\n\n<p>But these examples are simple, and it becomes a pain to type something like:</p>\n\n<p>$(\\lambda x.\\lambda y.(x\\ (x\\ y))\\ \\lambda x.\\lambda y.(x\\ (x\\ y)))$</p>\n\n<p>I'm having trouble trying to figure out what the actual rules of this system would be, like what would you do if you'd have to unify two intersection types (or whether that situation is even possible). </p>\n\n<p>So my question is, am I moving towards a type system that already exists? If yes, which one? If not, is this because my type system wouldn't meet the requirements of a type system (such as being decidable)?</p>\n", 'ViewCount': '33', 'Title': 'Does there exist a type system for a non-let-polymorphic lambda calculus?', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-03-31T16:54:26.607', 'LastEditDate': '2014-03-31T16:54:26.607', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><type-theory><type-inference>', 'CreationDate': '2014-03-30T07:48:34.587', 'Id': '23249'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m taking a graduate course on the theory of functional programming, based on Paul Taylor\'s "Practical Foundations of  Mathematics." I understand the statement of Tarski\'s theorem about how for any $\\omega$-compelte poset $X$, and any $\\omega$-continuous function $T:X\\rightarrow X$, that $T$ has a fixed point which is the join of (The statement and proof can be found <a href="http://www.paultaylor.eu/~pt/prafm/html/s33.html" rel="nofollow">here</a>).</p>\n\n<p>What I want to know is, how is this applicable, other than being a proof that the Y-combinator exists? It just seems to me that it says "we can use recursion to build a function that is defined for all natural numbers", where we could use some other recursive type for numbers. Doesn\'t the existence of the Y-combinator show the same thing?</p>\n', 'ViewCount': '73', 'Title': "What does Tarski's Fixed-Point theorem give us that that Y-Combinator does't", 'LastActivityDate': '2014-04-04T19:32:29.183', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<lambda-calculus><recursion><type-theory><partial-order><lattices>', 'CreationDate': '2014-04-04T19:16:13.043', 'Id': '23431'}},