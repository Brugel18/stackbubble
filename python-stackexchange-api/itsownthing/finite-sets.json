{'Body': '<p><strong>Inputs.</strong> I am given a finite set $S$ of symbols.  I know there should exist some total order $&lt;$ on $S$, but I\'m not given this ordering and it could be anything.</p>\n\n<p>I am also given a collection of assertions.  Each assertion takes the form $s_1&lt;s_2&lt;\\cdots&lt;s_m$, where $s_1,\\dots,s_m$ form a subset of the symbols of $S$.  The assertion probably won\'t mention all of the symbols of $S$, just a subset.  Each assertion will probably cover a different subset.</p>\n\n<p><strong>Warmup problem.</strong> The starter problem is: Given $n$ assertions, identify whether they are all internally self-consistent, i.e., whether there exists a total order on $S$ that is consistent with all of the assertions, and if so, output an example of such a total order.</p>\n\n<p><strong>The real problem.</strong> In practice, a few assertions might be faulty.  Almost all of them should be correct, though.  So, the real problem is: if the assertions are not all internally self-consistent, find a minimal subset of assertions to label as "probably-erroneous", such that if you remove the probably-erroneous assertions, the remainder are all self-consistent.</p>\n\n<p><strong>What I know.</strong> I know how to solve the warmup problem (just compute the transitive closure of the union of the partial orders given by each assertion, and check that the result is antisymmetric; or, in other words, create a graph with $S$ as vertex set and an edge $s\\to t$ if $s&lt;t$ appears in any assertion, then check for cycles).  However, I don\'t know how to solve the real problem.  Any ideas?</p>\n\n<p><strong>Real-world parameters.</strong> In the application domain where I\'ve run into this, $S$ might have up to a few hundred symbols, and I might have up to a few thousand assertions, with each assertion typically mentioning dozens of symbols.</p>\n', 'ViewCount': '112', 'Title': 'Given many partial orders, check them for consistency and report any that are not consistent', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-19T22:21:54.297', 'LastEditDate': '2012-10-19T18:36:26.050', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><graphs><approximation><finite-sets><partial-order>', 'CreationDate': '2012-10-19T17:25:00.620', 'FavoriteCount': '1', 'Id': '6173''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>Let $S$ be a finite set of integers (this set contains about 200000 elements). Let $T \\subset S$ be a particular subset of $S$ called <em>target</em>. $S$ keeps growing. So does $T$. Each new element of $S$ might or might not be in $T$.</p>\n\n<p>No (known, or practical) algorithm can determine if an element $s \\in S$ is in the <em>target</em> set: a human being must give the final word (ie, it is subjective). It is estimated that $T$ has about 30000-35000 elements. I already know $T_1$, a first approximation of $T$, with about 25000 elements. I also already know some thousands of elements of $S$ that are certainly not in $T$.</p>\n\n<p>What I want is a way to approximate $T$ as closely as possible, and present only those elements to a human being. Also, for each new element of $S$, I want to determine if it has high probability of being in $T$ -- and present only those with high probability to a human being.</p>\n\n<hr>\n\n<p>Now, I describe what I can use to try to approximate $T$.</p>\n\n<p>Each integer $s \\in S$ has some <em>labels</em> associated. These can be represented as subsets $L_i \\subset S, \\forall i \\in \\{1, ..., n\\}$ ($n$ is about 250). These subsets are known, determined by algorithms (ie, I have functions $l_i \\to \\{in,out\\}$ such that $l_i(s) = in \\iff s \\in L_i$).</p>\n\n<p>Some label algorithms are very fast, some are slow. Anyways, these labels (ie, the sets $L_i$) have already been determined. Some of these labels contain very few (1-100) elements, some contain a lot (100000-150000). Many labels are independent, some are closely related (ie, I know that some labels are subsets of others, I know that some are disjoint, etc).</p>\n\n<hr>\n\n<p>So, given this framework, what kind of algorithms can I use to approximate $T$? They can be interactive, ie, they could get better after each new approximation of $T$, if this makes the problem easier.</p>\n\n<p>I thought about using a <strong>genetic algorithm</strong> to determine which labels, when intersected, give good approximations of $T$. However, this can get slow, with a na\xefve intersection algorithm (ie, suppose $L_1, L_2, L_3$ are to be intersected; if they are all "big" (50000-150000), it can be quite time consuming to calculate the intersection! -- now, imagine a gene that would require to intersect, say, 50 labels...).</p>\n\n<p>How can I speed this, without sacrificing too much the precision?</p>\n', 'ViewCount': '43', 'Title': 'Approximate target subset by intersecting other subsets', 'LastEditorUserId': '7051', 'LastActivityDate': '2013-02-26T22:51:21.717', 'LastEditDate': '2013-02-26T22:51:21.717', 'AnswerCount': '0', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7051', 'Tags': '<algorithms><probabilistic-algorithms><finite-sets>', 'CreationDate': '2013-02-26T22:42:08.043', 'Id': '10128''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have to prove or disprove the implications in these two situations</p>\n\n<ol>\n<li>$L^* = \\emptyset$ $\\rightarrow$ $L$ is infinite</li>\n<li>$L^+ = \\emptyset$ $\\rightarrow$ $L$ is infinite</li>\n</ol>\n\n<p>Here are my thoughts.</p>\n\n<ol>\n<li><p>I would say Kleene star operation (*) is union of </p>\n\n<p>$\\qquad L^0 \\cup L^1 \\cup L^2 \\cup \\dots$</p>\n\n<p>and since $\\_^0 = \\{\\epsilon\\}$ (even $\\emptyset^ 0 = \\{\\epsilon\\}$), there is no language $L$ such that $L^* = \\emptyset$. </p>\n\n<p>How to prove finiteness/infiniteness?</p></li>\n<li><p>Only language $L$ where $L^+ = \\emptyset$ is $\\emptyset$ which is a finite language. But how to prove there is no other language that is inifinite and the argument is valid for it?</p></li>\n</ol>\n\n<hr>\n\n<p>EDIT: will it help if I rewrite the implications $A \\rightarrow B$ to $\\neg B \\rightarrow \\neg A$ ?</p>\n\n<ol>\n<li>$L$ is finite $\\rightarrow$ $L^* \\neq \\emptyset$</li>\n<li>$L$ is finite $\\rightarrow$ $L^+ \\neq \\emptyset$</li>\n</ol>\n\n<p>2) can be now interpreted as $\\emptyset^+ = \\{\\epsilon\\}$ and $\\emptyset$ is a finite language. So the implication doesn't work.</p>\n", 'ViewCount': '93', 'Title': 'If $L^*$ or $L^+$ is empty, can L be an infinite language?', 'LastEditorUserId': '6689', 'LastActivityDate': '2014-01-20T07:40:08.050', 'LastEditDate': '2014-01-18T23:14:53.983', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12947', 'Tags': '<formal-languages><finite-sets>', 'CreationDate': '2014-01-18T18:48:12.320', 'Id': '19812''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}