{'Body': '<p>I came across an interesting procedure that ranks (sorts) a set of tuples, <em>not</em> by comparisons between tuples, but by the proximity between <em>next</em> tuple(s) and the set of tuples already ranked.</p>\n\n<p>Specifically, consider the ranking procedure as follows,</p>\n\n<p>Input: $D=\\{p_i\\mid p_i \\in \\mathbb{R}^2, i=1, 2,\\ldots,n\\}$, $i_{start} \\in \\{1, 2,\\ldots, n\\}$, and distance metric $f: 2^D \\times D \\mapsto \\mathbb{R}_{\\ge 0}$<br>\nOutput: $\\Pi = \\left[ i_1, i_2, \\ldots, i_n\\right]$</p>\n\n<ol>\n<li>$\\Pi \\gets \\left[~ \\right]$; // empty sequence</li>\n<li>$A \\gets \\emptyset$;  </li>\n<li>$i_{next} \\gets i_{start}$;  </li>\n<li>while $D \\neq \\emptyset$  </li>\n<li>&nbsp;&nbsp;&nbsp;&nbsp;$\\Pi \\gets \\Pi \\oplus i_{next} $ // append $i_{next}$ to sequence</li>\n<li>&nbsp;&nbsp;&nbsp;&nbsp;$A \\gets A \\bigcup \\left\\{ p_{i_{next}} \\right\\}$; // $p_{i_{next}}$ is a tuple from $D$ identified by subscript ${i_{next}}$  </li>\n<li>&nbsp;&nbsp;&nbsp;&nbsp;$D \\gets D \\setminus \\left\\{p_{i_{next}}\\right\\}$;  // same $p_{i_{next}}$ as in line 6  </li>\n<li>&nbsp;&nbsp;&nbsp;&nbsp;${i_{next}} \\gets \\min \\bigl\\{\\arg_j\\,\\min_{p_j\\in D}\\,f(A, p_j) \\bigr\\}$; // not defined when $D = \\emptyset$   </li>\n</ol>\n\n<p>An example of the distance metric $f(A, p)$ is, say, the distance between 2D point $p$ and the centroid of 2D points in set $A$. As such, the procedure is literally the expansion of a cluster of 2D points, starting from a given point $p_{start}$, until all $n$ points from $D$ have been included. And the sequence $\\Pi$ records the order by which points from $D$ are included in the cluster.</p>\n\n<p>Could anyone shed some light on the literature, background, or well-known examples, of such ranking procedures? In particular, are there any previous results on the complexity bounds of such a procedure perhaps under different types of distance metrics?</p>\n', 'ViewCount': '93', 'Title': 'On ranking (sorting) by a varying distance metric', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-23T13:08:49.810', 'LastEditDate': '2013-12-23T13:08:49.810', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7644', 'Tags': '<algorithms><complexity-theory><reference-request><sorting><ranking>', 'CreationDate': '2013-12-19T18:41:36.297', 'FavoriteCount': '1', 'Id': '19128'}{'Body': "<p>I'm looking for public algorithm which gives the engine these abilities:</p>\n\n<ul>\n<li>Query by ranked terms</li>\n<li>Limit outcome by date/time range</li>\n</ul>\n\n<p>Basically, i'd like to concentrate articles (generally <code>title|text|timestamp</code>) identify the source and make N-N correlation to terms (is term for datasource same marking as term for dataentry?)</p>\n\n<p>Given the database of such information</p>\n\n<pre><code>entry_data_type:[type_id|title|description]\nentry_data:[entry_id|data_type_id|data_content]\nentry:[id|entry_type(data,source)|parent_entry_id|created|updated]\nterms(keywords):[id|keyword]\nentry2term:[entry_id|term_id|term_weight]\n</code></pre>\n\n<p>Where keywords are both automatically defined (text frequency analysis) and manually assigned (probably abstract terms in context to entry contents)</p>\n\n<p>I should be able to query by keywords like this: <code>kw1:3 kw2:10 kw3:-2 [range:-7 days]</code><br>\nand output shall be entries sorted by given keyword weights (pattern <code>keyword:weight</code>)</p>\n\n<p>I thought about something similar to EdgeRank, but that is social-graph-oriented, and I'm looking for more straight-forward solution (more selfish, meaning input filter is given by personal preferences, not social-graph-near preferences or social-score ranking)</p>\n\n<p>Also TF-IDF would have to be limited by time, so the document base to calculate the entry score is inserted in given date/time range only. Is there any possible break-down of TF-IDF ranking, eg. to pre-calculate raw-data for each day and then, based on query, merge them for given date-range?</p>\n\n<p>This question is independent of any particular programming language, platform, etc. I'm generally looking for keywords to look for, papers to read or ready implementations to study, but accepted are only answers not using paid or closed-source software parts or non-public-domain patents.</p>\n", 'ViewCount': '16', 'Title': 'TF-IDF query engine in context of terms weight', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-07T16:53:08.100', 'LastEditDate': '2014-04-07T16:53:08.100', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16077', 'Tags': '<reference-request><search-algorithms><statistics><search-problem><ranking>', 'CreationDate': '2014-04-07T01:30:29.197', 'Id': '23494'}{'Body': '<p>I am looking for any good Lex Ranking tool like Sumy in python. I would like to experiment with my data with multiple lex ranking  algorithms. So could anyone please suggest me a good tool in Python for Lex Ranking?</p>\n\n<p>Thank you</p>\n', 'ViewCount': '3', 'Title': 'Any good python Lex Ranking tool apart from sumy?', 'LastActivityDate': '2014-05-04T01:56:24.440', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17307', 'Tags': '<natural-lang-processing><ranking>', 'CreationDate': '2014-05-04T01:56:24.440', 'Id': '24375'}