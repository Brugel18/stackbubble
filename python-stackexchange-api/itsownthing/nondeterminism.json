{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '649', 'Title': 'What are the conditions for a NFA for its equivalent DFA to be maximal in size?', 'LastEditDate': '2012-03-15T10:17:50.310', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '1', 'Body': "<p>We know that DFAs are equivalent to NFAs in expressiveness power; there is also a known algorithm for converting NFAs to DFAs (unfortunately I do now know the inventor of that algorithm), which in worst case gives us $2^S$ states, if our NFA had $S$ states.</p>\n\n<p>My question is: what is determining the worst case scenario?</p>\n\n<hr>\n\n<p>Here's a transcription of an algorithm in case of ambiguity:</p>\n\n<p>Let $A = (Q,\\Sigma,\\delta,q_0,F)$ be a NFA. We construct a DFA $A&#39; = (Q&#39;,\\Sigma,\\delta&#39;,q&#39;_0,F&#39;)$ where </p>\n\n<ul>\n<li>$Q&#39; = \\mathcal{P}(Q)$, </li>\n<li>$F&#39; = \\{S \\in Q&#39; | F \\cap S \\neq \\emptyset \\}$,</li>\n<li>$\\delta&#39;(S,a) =\\bigcup_{s \\in S} (\\delta(s,a) \\cup \\hat \\delta(s,\\varepsilon))$, and</li>\n<li>$q&#39;_0 = \\{q_0\\} \\cup \\hat \\delta(q_0, \\varepsilon)$,</li>\n</ul>\n\n<p>where $\\hat\\delta$ is the extended transition function of $A$.</p>\n", 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T10:45:27.090', 'CommentCount': '1', 'AcceptedAnswerId': '131', 'CreationDate': '2012-03-08T10:20:46.940', 'Id': '130'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '724', 'Title': 'Computational power of deterministic versus nondeterministic min-heap automata', 'LastEditDate': '2012-03-16T18:25:40.237', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '0', 'Body': '<p><em>This is a follow-up question of <a href="http://cs.stackexchange.com/q/110/98">this one</a>.</em></p>\n\n<p>In a previous question about <a href="http://cs.stackexchange.com/q/110/69">exotic state machines</a>, Alex ten Brink and Raphael addressed the computational capabilities of a peculiar kind of state machine: min-heap automata. They were able to show that the set of languages accepted by such machines ($HAL$) is neither a subset nor a superset of the set of context-free languages. Given the successful resolution of and apparent interest in that question, I proceed to ask several follow-up questions.</p>\n\n<p>It is known that deterministic and nondeterministic finite automata have equivalent computational capabilities, as do deterministic and nondeterministic Turing machines. However, the computational capabilities of deterministic push-down automata are less than those of nondeterministic push-down automata.</p>\n\n<blockquote>\n  <p>Are the computational capabilities of deterministic min-heap automata less than, or are they equal to, those of nondeterministic min-heap automata?</p>\n</blockquote>\n', 'Tags': '<formal-languages><automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-16T18:25:40.237', 'CommentCount': '0', 'AcceptedAnswerId': '406', 'CreationDate': '2012-03-14T21:52:44.340', 'Id': '394'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '902', 'Title': 'What is meant by "solvable by non deterministic algorithm in polynomial time"', 'LastEditDate': '2012-04-22T16:05:06.120', 'AnswerCount': '4', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '2', 'Body': '<p>In many textbooks NP problems are defined as:</p>\n\n<blockquote>\n  <p>Set of all decision problems solvable by non deterministic algorithms in polynomial time</p>\n</blockquote>\n\n<p>I couldn\'t understand the part "solvable by non deterministic algorithms". Could anyone please explain that?</p>\n', 'Tags': '<complexity-theory><terminology><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T16:05:06.120', 'CommentCount': '2', 'AcceptedAnswerId': '1247', 'CreationDate': '2012-04-13T05:35:10.410', 'Id': '1243'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '597', 'Title': 'Words that have the same right- and left-associative product', 'LastEditDate': '2012-04-24T06:17:40.090', 'AnswerCount': '4', 'Score': '7', 'OwnerDisplayName': 'Ismael Mezquino', 'PostTypeId': '1', 'OwnerUserId': '1217', 'FavoriteCount': '1', 'Body': '<p>I have started to study non deterministic automata using the book of <a href="https://en.wikipedia.org/wiki/Introduction_to_Automata_Theory,_Languages,_and_Computation" rel="nofollow">Hopcroft and Ullman</a>. I\'m stuck in a problem that I found very interesting:</p>\n\n<blockquote>\n  <p>Give a non deterministic finite automaton accepting all the strings that\n  have the same value when evaluated left to right as right to left by\n  multiplying according to the following table:</p>\n  \n  <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \r\n    \\times &amp; a &amp; b &amp; c \\\\\r\n    \\hline \r\n    a &amp; a &amp; a &amp; c \\\\\r\n    b &amp; c &amp; a &amp; b \\\\\r\n    c &amp; b &amp; c &amp;a\r\n   \\end{array}$</p>\n</blockquote>\n\n<p>So if we have the string $abc$,<br>\nthe product from left to right is $(a \\times b) \\times c=a \\times c=c$ and<br>\nthe product from right to left is $a \\times (b \\times c)=a \\times b=a$</p>\n\n<p>So $abc$ should not be acceptable for the automata. To me its obvious that any string $aa^*$ or $bb^*$ or $cc^*$ is an aceptable string (their right and left evaluation work on the same partial strings). It is easy to give an NFA that describes the left to right evaluation but the problem is that if the machine try to compute the <em>right to left</em> evaluation I think it needs to know the length of the string (so infinite memory is necessary).</p>\n\n<p>So how can a non deterministic automata evaluate from right to left in order to compare with the left to right evaluation?</p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-25T17:11:22.873', 'CommentCount': '0', 'AcceptedAnswerId': '1479', 'CreationDate': '2012-04-23T18:12:11.180', 'Id': '1467'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '755', 'Title': 'What is the difference between quantum TM and nondetermistic TM?', 'LastEditDate': '2012-08-21T07:36:36.807', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '1', 'Body': '<p>I was going through the discussion on the question <a href="http://cs.stackexchange.com/questions/125/how-to-define-quantum-turing-machines/">How to define quantum-turing-machines?</a> and I feel that quantum TM and <em>nondetermistic</em> TM are one and the same. The answers to the other question do not touch on that. Are these two models one and the same?</p>\n\n<p>If no,</p>\n\n<ol>\n<li>What are the differences between quantum TM and NDTM? </li>\n<li>Is there any computation which a NDTM would do quicker than Quantum TM? </li>\n<li>If this is the case then quantum TM is a DTM, then why is there so much fuzz about this technology, we already have so many DTM. Why to design a new DTM in the end?</li>\n</ol>\n', 'Tags': '<computability><turing-machines><quantum-computing><nondeterminism>', 'LastEditorUserId': '2137', 'LastActivityDate': '2012-08-21T07:36:36.807', 'CommentCount': '1', 'AcceptedAnswerId': '2721', 'CreationDate': '2012-07-13T05:56:28.627', 'Id': '2718'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In Sipser\'s textbook "Introduction to the Theory of Computation, Second Edition," he defines nondeterministic time complexity as follows:</p>\n\n<blockquote>\n  <p>Let $N$ be a nondeterministic Turing machine that is a decider.  The <strong>running time</strong> of $N$ is the function $f : \\mathbb{N} \\rightarrow \\mathbb{N}$, where $f(n)$ is the maximum number of steps that $N$ uses on any branch of its computation on any input of length $n$ [...].</p>\n</blockquote>\n\n<p>Part of this definition says that the running time of the machine $N$ is the maximum number of steps taken by that machine on any branch.  Is there a reason that all branches are considered?  It seems like the length of the shortest accepting computation would be a better measure (assuming, of course, that the machine halts), since you would never need to run the machine any longer than this before you could conclude whether the machine was going to accept or not.</p>\n', 'ViewCount': '129', 'Title': 'Why does NTIME consider the length of the longest computation?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-24T08:48:55.467', 'LastEditDate': '2012-07-24T08:48:55.467', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '2892', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<complexity-theory><time-complexity><terminology><turing-machines><nondeterminism>', 'CreationDate': '2012-07-23T22:49:08.547', 'Id': '2887'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '173', 'Title': 'Length of the certificate in complexity classes', 'LastEditDate': '2012-10-10T20:04:46.300', 'AnswerCount': '3', 'Score': '3', 'OwnerDisplayName': 'Ingrid Morstrad', 'PostTypeId': '1', 'OwnerUserId': '2777', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p>A nondeterministic machine trying to decide membership in a language\n  is presented with a hint (called a "witness" or "certificate") which\n  proves membership (no such witness is provided for elements outside\n  the language; the definition is asymmetric).</p>\n</blockquote>\n\n<p>So, if a non-deterministic algorithm can solve a problem in O(f(n)) time, does this mean the length of the certificate is f(n) [Since it could try all the possible combinations and the length of the shortest one will be f(n)]? And the input size is n?</p>\n\n<p>Also, if a deterministic algorithm A exists that can verify a certificate in O(f(n)) time, how does this imply the existence of a non-deterministic algorithm that can solve the problem in O(f(n)) time?</p>\n', 'Tags': '<complexity-theory><terminology><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-11T01:01:12.950', 'CommentCount': '2', 'CreationDate': '2012-09-10T08:11:06.193', 'Id': '3494'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>What differences and relationships are between randomized algorithms and nondeterministic algorithms?</p>\n\n<p>From Wikipedia</p>\n\n<blockquote>\n  <p>A <strong>randomized algorithm</strong> is an algorithm which employs a degree of\n  randomness as part of its logic. The algorithm typically uses\n  uniformly random bits as an auxiliary input to guide its behavior, in\n  the hope of achieving good performance in the "average case" over all\n  possible choices of random bits. Formally, the algorithm\'s performance\n  will be a random variable determined by the random bits; thus either\n  the running time, or the output (or both) are random variables.</p>\n  \n  <p>a <strong>nondeterministic algorithm</strong> is an algorithm that can exhibit\n  different behaviors on different runs, as opposed to a deterministic\n  algorithm. There are several ways an algorithm may behave differently\n  from run to run. A <strong>concurrent algorithm</strong> can perform differently on\n  different runs due to a race condition. A <strong>probabalistic algorithm</strong>\'s\n  behaviors depends on a random number generator. An algorithm that\n  solves a problem in nondeterministic polynomial time can run in\n  polynomial time or exponential time depending on the choices it makes\n  during execution.</p>\n</blockquote>\n\n<p>Are randomized algorithms and probablistic algorithms the same concept? </p>\n\n<p>If yes, so are randomized algorithms just a kind of nondeterministic algorithms?</p>\n', 'ViewCount': '1555', 'Title': 'Differences and relationships between randomized and nondeterministic algorithms?', 'LastEditorUserId': '31', 'LastActivityDate': '2014-02-02T18:42:47.173', 'LastEditDate': '2014-01-23T10:11:12.273', 'AnswerCount': '4', 'CommentCount': '7', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '336', 'Tags': '<algorithms><terminology><randomized-algorithms><machine-models><nondeterminism>', 'CreationDate': '2012-10-11T05:19:33.520', 'FavoriteCount': '5', 'Id': '5008'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '348', 'Title': 'How to prove that DFAs from NFAs can have exponential number of states?', 'LastEditDate': '2012-10-14T14:49:28.763', 'AnswerCount': '3', 'Score': '12', 'OwnerDisplayName': 'John Hoffman', 'PostTypeId': '1', 'OwnerUserId': '3003', 'Body': '<p>All non-deterministic finite automata can be turned into equivalent deterministic finite automata. However, a deterministic finite automata only allows a single arrow per symbol pointing from a state. Therefore, its states should be members of the power set of states of the NFA. This seems to indicate that the number of states of the DFA could scale exponentially in terms of the number of states of the NFA. However, I was wondering how to actually prove this.</p>\n', 'Tags': '<automata><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-14T14:49:28.763', 'CommentCount': '2', 'AcceptedAnswerId': '6065', 'CreationDate': '2012-09-15T21:10:09.980', 'Id': '6063'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Are there any superpolynomial time set $\\mathsf{SP}$ in between $\\mathsf{P}$ and $\\mathsf{EXPTIME}$ such that the problem $\\mathsf{SP}=\\mathsf{NSP}$ has a known answer?</p>\n\n<p><strong>UPDATE</strong>: It must be defined by time and strictly between $\\mathsf{P}$ and $\\mathsf{EXPTIME}$. I was wondering, what if Cobham's thesis is wrong and we are fighting with $\\mathsf{P=NP}$ because of that thesis when the really useful question is another one? Maybe one that's even already answered?</p>\n", 'ViewCount': '81', 'Title': 'Superpolynomial time set such that SP=NSP is known?', 'LastActivityDate': '2012-10-17T18:28:03.410', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'Ignacio Calvo', 'PostTypeId': '1', 'Tags': '<complexity-theory><nondeterminism>', 'CreationDate': '2012-10-16T16:28:10.287', 'Id': '6132'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '172', 'Title': 'Classfication of randomized algorithms', 'LastEditDate': '2012-10-22T00:56:03.857', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '336', 'FavoriteCount': '3', 'Body': '<p>From <a href="http://en.wikipedia.org/wiki/Randomized_algorithm">Wikipedia</a> about randomized algorithms</p>\n\n<blockquote>\n  <p>One has to distinguish between <strong>algorithms</strong> that use the random\n  input to reduce the expected running time or memory usage, but always\n  terminate with a correct result in a bounded amount of time, and\n  <strong>probabilistic algorithms</strong>, which, depending on the random input, have a chance of producing an incorrect result (Monte Carlo\n  algorithms) or fail to produce a result (Las Vegas algorithms) either\n  by signalling a failure or failing to terminate.</p>\n</blockquote>\n\n<ol>\n<li>I was wondering how the first kind of "<strong>algorithms</strong> use the random\ninput to reduce the expected running time or memory usage, but\nalways  terminate with a correct result in a bounded amount of time?</li>\n<li>What differences are between it and Las Vegas algorithms which may\nfail to produce a result?</li>\n<li>If I understand correctly,  probabilistic algorithms and randomized algorithms are not the same concept. Probabilistic algorithms are just one\nkind of randomized algorithms, and the other kind is those use the\nrandom  input to reduce the expected running time or memory usage,\nbut always  terminate with a correct result in a bounded amount of\ntime?</li>\n</ol>\n', 'Tags': '<algorithms><terminology><randomized-algorithms><nondeterminism><machine-models>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-07T14:10:29.767', 'CommentCount': '0', 'AcceptedAnswerId': '6222', 'CreationDate': '2012-10-22T00:53:00.617', 'Id': '6221'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I know that we can visualize a Non deterministic TM as a TM which splits into multiple copies of itself whenever it sees a non deterministic path (Yes, I also know that this is just a visualization and is usually used by beginners like me for understanding non determistisism). </p>\n\n<p>Further, I also know that a Decider is a TM that halts on all possible inputs.</p>\n\n<p>Now, my question is how can I visualize a Non determistic Decider? Does a non-determistic decider mean a TM where</p>\n\n<ol>\n<li>All the copies must halt, (OR)</li>\n<li>At-least one copy halts.</li>\n</ol>\n\n<p>Kindly explain in detail why so. Thanks.</p>\n', 'ViewCount': '181', 'Title': 'Visualizing a Non Deterministic Decider', 'LastActivityDate': '2013-06-30T16:13:23.483', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '6257', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2137', 'Tags': '<turing-machines><undecidability><nondeterminism>', 'CreationDate': '2012-10-23T06:42:09.307', 'FavoriteCount': '1', 'Id': '6253'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have read of an algorithm that a <a href="http://en.wikipedia.org/wiki/Non-deterministic_Turing_machine" rel="nofollow">non-deterministic Turing machine</a> $N$ can run to determine whether a given graph $G$ has a <a href="http://en.wikipedia.org/wiki/Hamiltonian_path" rel="nofollow">Hamiltonian path</a> from the start node $s$ to a certain node $n$:</p>\n\n<ol>\n<li><p>Write a list of $x$ numbers $p_1, p_2, p_3 ... p_x$, where $x$ is the number of nodes in $G$. Each number in this list is non-deterministically selected to be from 1 to $x$.</p></li>\n<li><p>Check for repetitions in this list. If a repetition exists, reject.</p></li>\n<li><p>Check whether both $s = p_1$ and $n = p_x$. If either do not hold, reject.</p></li>\n<li><p>For each $i \\in [1, x - 1]$, check whether $(p_i, p_{i + 1})$ is an edge of $G$. If any are not, reject.</p></li>\n<li><p>Accept.</p></li>\n</ol>\n\n<p>I do not understand how this algorithm works. Specifically, in step 1, why am I making a list of random (potentially repeating) numbers from 1 to $x$ (What does this list have to do with the nodes of $G$?)?</p>\n\n<p>Likewise, in step 4, why does $(p_i, p_{i + 1})$ represent a potential edge in $G$?</p>\n', 'ViewCount': '220', 'Title': 'How does this non-deterministic algorithm to find if a Hamiltonian path exists work?', 'LastActivityDate': '2012-12-01T03:21:21.020', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7067', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<turing-machines><nondeterminism>', 'CreationDate': '2012-12-01T02:39:39.353', 'Id': '7065'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Problems in NP have certificates which can be verified in polynomial time.</p>\n\n<p>It seems conceivable that there could be problems in P which have certificates which can be verified in logarithmic time.  (Such certificates would also have to be logarithmic in size, naturally.)</p>\n\n<p>However, it is also conceivable that there are no such problems.  I\'ve tried to come up with examples, but none of them have worked out so far.</p>\n\n<p>Have problems like this been studied and shown to exist (or not exist)?</p>\n\n<p>I can\'t seem to find a complexity class that would describe them in the <a href="http://complexityzoo.uwaterloo.ca/Complexity_Zoo" rel="nofollow">Complexity Zoo</a>, although it\'s certainly possible that there\'s one there and I\'m just having a hard time identifying it.  (L and LOG usually refer to space, and neither LH nor NLOG looks like it necessarily captures the idea.)</p>\n', 'ViewCount': '69', 'Title': 'Are any problems in P known to have logarithmic-time-verifiable certificates?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-12-23T04:23:58.610', 'LastEditDate': '2012-12-23T04:23:58.610', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5049', 'Tags': '<complexity-theory><nondeterminism>', 'CreationDate': '2012-12-16T18:10:40.223', 'Id': '7442'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I had an interview today, and the interviewer has told me about a theorem (of someone called Hill- or Hell-something) which states that for a non-deterministic algorithm there exists a deterministic algorithm of some time complexity and a space complexity of no more than the original space complexity times log(n).</p>\n\n<p>I am looking for that theorem (couldn't find it on Google). Thanks!</p>\n", 'ViewCount': '183', 'Title': 'Logarithmic space difference between deterministic and non-deterministic algorithms', 'LastActivityDate': '2012-12-23T08:37:29.267', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5165', 'Tags': '<algorithms><space-complexity><nondeterminism>', 'CreationDate': '2012-12-23T08:37:29.267', 'Id': '7559'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am particularly interested in solutions to the problem that encapsulated search can depend on the order of evaluation.</p>\n\n<p>According to [1], encapsulated search in PAKCS depends on the order of evaluation, while in MCC, it does not, but using it requires knowledge of the compiler implementation and it does not follow the Curry language specification. This was written in 2007, so it may of course be out of date now.</p>\n\n<p>KiCS2 returns results from encapsulated search in the IO monad, but I do not understand why.</p>\n\n<p>[1] Bra\xdfel and Huch, <em>On a Tighter Integration of\nFunctional and Logic Programming</em>, Proc. APLAS 2007</p>\n', 'ViewCount': '120', 'Title': 'What is the state of the art in encapsulated search in functional logic programming?', 'LastActivityDate': '2013-07-25T20:41:16.697', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1617', 'Tags': '<nondeterminism><functional-programming><logic-programming>', 'CreationDate': '2012-12-23T15:47:11.007', 'Id': '7564'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a background in computer architecture and only cursory understanding of process networks. For a paper I am writing I need to understand prefix monotonicity properly. </p>\n\n<p>For now I have "a stream transformer is prefix monotonic if its output for a given input record r is dependent only on the input stream up to and including r, and independent from whether r is the last record in the stream". But this was gathered by word-of-mouth and I am not sure it is the proper approach.</p>\n\n<p>I would welcome suggestions for:</p>\n\n<ul>\n<li>proper formal background and definitions;</li>\n<li>useful analogies to explain the concept to a newcomer (the audience of the paper needs to understand prefix monotonicity but may not be knowledgeable with TCS).</li>\n</ul>\n', 'ViewCount': '123', 'Title': 'What is prefix monotonicity?', 'LastActivityDate': '2013-06-03T14:32:09.153', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'OwnerDisplayName': 'kena', 'PostTypeId': '1', 'OwnerUserId': '1922', 'Tags': '<reference-request><terminology><nondeterminism>', 'CreationDate': '2013-01-01T13:03:26.163', 'Id': '7685'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am struggling in trying to figure out a non-deterministic algorithm for the following problem.</p>\n\n<p>Consider the following problem, called the \ufb01gure-of-eight problem (FOE). An instance is an undirected graph $G = (V,E)$ with vertices $V$ and edges $E$. $G$ is a yes-instance if there is a sequence of vertices $(v_{0},v_{1},...,v_{k+1})\\ (some\\ k \\geq 6)$ such that</p>\n\n<p>\u2022 Each pair $(v_{i},v_{i+1})$ is an edge $(each\\ i &lt; k \u2212 1)$ and $(v_{k\u22121},v_{0})$ is an edge. </p>\n\n<p>\u2022 Every vertex in $V$ occurs at least once in the sequence. </p>\n\n<p>\u2022 There is $j$ with $2 &lt; j &lt; k \u2212 2$ such that $v_{0} = v_{j}$. </p>\n\n<p>\u2022 No other vertex in the sequence is counted twice, i.e. if $v_{s} = v_{t} (any\\ s,t &lt; k)$ then either $s = t$ or ${s,t} = {0,j}$.</p>\n\n<p>If there is no such sequence of vertices then $G$ is a no-instance of FOE.</p>\n\n<p>Thanks</p>\n', 'ViewCount': '106', 'Title': 'Non-deterministic algorithm for solving figure of 8', 'LastActivityDate': '2013-01-04T14:17:12.447', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7757', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5300', 'Tags': '<algorithms><complexity-theory><graphs><nondeterminism>', 'CreationDate': '2013-01-04T13:03:33.720', 'Id': '7756'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1104', 'Title': 'Can we say DFA is more efficient than NFA?', 'LastEditDate': '2013-05-17T04:01:16.283', 'AnswerCount': '6', 'Score': '8', 'OwnerDisplayName': 'avi', 'PostTypeId': '1', 'OwnerUserId': '6665', 'Body': "<p>I just started reading about theory of computation. If we compare which is more powerful (in accepting strings), both are same. But what about efficiency ? DFA will be fast compared to NFA, since it has only one outgoing edge &amp; there will be no ambiguity. But in case of NFA we have to check all possible cases &amp; that surely takes time. So can we say DFA is more efficient than NFA ? </p>\n\n<p>But, my other part of brain is also thinking that NFA exists only in theory, so we cannot compare it's efficiency with DFA. </p>\n", 'Tags': '<finite-automata><efficiency><nondeterminism>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-17T07:39:06.093', 'CommentCount': '0', 'AcceptedAnswerId': '9393', 'CreationDate': '2013-02-01T14:42:41.990', 'Id': '9389'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm looking at my textbook here from Michael Sipser and he says that a <strong>nondeterministic Turing machine is a decider if all its computation branches halt on all inputs.</strong> I think I recall seeing somewhere what you'd call a nondeterministic Turing machine that halts on at least one branch for all inputs, but may loop on others. Is there a name for such a thing? I see later in this chapter the word <strong>verifier</strong>, but that doesn't seem to fit... I think that refers to an algorithm.</p>\n\n<blockquote>\n  <p>A <strong><em>verifier</em></strong> for a language $A$ is an algorithm $V$, where\n  $$A=\\{w\\mid V\\text{ accepts }\\langle w,c\\rangle\\text{ for some string c}\\}.$$\n  We measure the time of a verifier only in terms of the length of $w$, so a <strong><em>polynomial time verifier</em></strong> runs in polynomial time in the length of $w$. A language $A$ is <strong><em>polynomially verifiable</em></strong> if it has a polynomial time verifier.</p>\n</blockquote>\n", 'ViewCount': '278', 'Title': 'Non-deterministic Turing machine that halts on at least one branches of computation', 'LastEditorUserId': '39', 'LastActivityDate': '2014-01-06T12:20:39.040', 'LastEditDate': '2013-02-12T18:50:22.260', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '9710', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<turing-machines><nondeterminism>', 'CreationDate': '2013-02-12T16:04:55.013', 'Id': '9706'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am taking the <a href="https://class.coursera.org/compilers-selfservice/class/index" rel="nofollow">Coursera class</a> on compilers and in the lesson about lexers it is hinted that there is a time-space tradeoff between using non-deterministic finite automaton (NFA) and deterministic finite automaton (DFA) to parse regular expressions. If I understand correctly, the tradeoff is that a NFA is smaller, but is more time consuming to traverse because all possible states have to be regarded at the same time and therefore it is most of the time transformed into a DFA.  Are there any lexers that use NFAs instead of DFAs in "real"-life i.e. some compiler that is used in production and not a just a proof of concept?</p>\n', 'ViewCount': '200', 'Title': 'Are there real lexers that use NFAs directly instead of first transforming them to DFAs?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-05T19:53:06.097', 'LastEditDate': '2013-04-02T07:28:48.933', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6843', 'Tags': '<automata><finite-automata><compilers><efficiency><nondeterminism>', 'CreationDate': '2013-02-12T17:55:33.023', 'Id': '9708'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I was looking at the construction proof showing the equivalence of NFA and DFA from Sipser's text. It started by taking number of states of DFA as $\\mathcal{P}(Q)$, where $\\mathcal{P}(Q)$ is the set of subsets of $Q$. </p>\n\n<p>My doubt is when we construct DFA from NFA, all the subsets may not occur in that DFA. So how could we write that the number of states of DFA constructed is $\\mathcal{P}(Q)$.</p>\n", 'ViewCount': '243', 'Title': 'Equivalence of NFA and DFA - proof by construction', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-21T10:40:49.660', 'LastEditDate': '2013-02-21T10:40:49.660', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9999', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><nondeterminism><automated-theorem-proving>', 'CreationDate': '2013-02-21T02:55:37.267', 'Id': '9998'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was going through construction proofs for closure of regular languages under union, star and concatenation operation in the book: "<a href="http://rads.stackoverflow.com/amzn/click/053494728X" rel="nofollow">Introduction to Theory of Computation</a>" by Michael Sipser.</p>\n\n<p>I have doubts regarding how he wrote the transition function. </p>\n\n<p><img src="http://i.stack.imgur.com/R7KhO.jpg" alt="enter image description here"></p>\n\n<p>When $Q \\in F_1$ and $a=\\epsilon$ he wrote $\\delta_1(q,a) \\cup \\{q_2\\}$. I couldn\'t understand why its so. When the input is epsilon, the state moves to $q_2$ and what is the need for writing that $\\delta_1(q,a)$</p>\n\n<p>Also if that is so, the $A^*$ example he wrote for the transition function $\\{q_1\\}$ only  when $q=q_0$ and $a=\\epsilon$</p>\n', 'ViewCount': '171', 'Title': 'Closure of regular Language - Transition Function : Sipser Proof', 'LastEditorUserId': '947', 'LastActivityDate': '2013-04-27T13:09:00.637', 'LastEditDate': '2013-02-26T12:31:34.827', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><proof-techniques><finite-automata><nondeterminism>', 'CreationDate': '2013-02-26T11:47:09.320', 'Id': '10117'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>When Savitch\'s famous theorem is stated, one often sees the requirement that $S(n)$ be space constructible (interestingly, it is omitted in Wikipedia). My simple question is: Why do we need this? I understand the requirement for $S(n)$ being in $\\Omega(\\log n)$, which is clear from the proof. But no proof I have seen so far explicitly uses that $S(n)$ is space constructable.</p>\n\n<p>My explanation: in order to call the procedure REACH (or PATH or whatever you like to call it), the last parameter needs to be "spelled out", and in order not to leave our space bounds of S(n) for one call, we must not need more than $S(n)$ space to write it down. </p>\n', 'ViewCount': '106', 'Title': "Why is one often requiring space constructibility in Savitch's theorem?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-11T06:54:59.833', 'LastEditDate': '2013-04-10T13:33:01.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '11217', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<complexity-theory><space-complexity><complexity-classes><nondeterminism>', 'CreationDate': '2013-04-09T18:45:00.597', 'Id': '11168'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I saw this term "Glushkov NFA" at <a href="http://lambda-the-ultimate.org/node/2064" rel="nofollow">http://lambda-the-ultimate.org/node/2064</a> . Search engines are returning references to articles that use glushkov nfa, but nothing specific about the glushkov nfa itself. </p>\n\n<p>What is Glushkov NFA? How different is it from the NFA created from Thompson Construction?</p>\n', 'ViewCount': '168', 'Title': 'what is glushkov NFA. What is the difference between Glushkov NFA and Thompson NFA?', 'LastActivityDate': '2013-04-26T17:33:41.730', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'OwnerDisplayName': 'MIkhail', 'PostTypeId': '1', 'OwnerUserId': '7925', 'Tags': '<nondeterminism>', 'CreationDate': '2013-04-26T12:26:51.750', 'Id': '11582'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm doing some research regarding NFAs and inclusion problems with them. I know that in general, the inclusion problems, and converting to an unambiguous NFA, are both PSPACE-complete.</p>\n\n<p>I'm wondering, are there any sub-classes of NFA for which these can be decided efficiently? In particular, the NFAs I'm looking at accept finite language where all words have the same Parikh vector.</p>\n", 'ViewCount': '107', 'Title': 'Classes of NFAs which allow efficient subset testing or unambiguity conversions', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-06-13T16:33:18.830', 'LastEditDate': '2013-05-06T23:38:41.717', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<complexity-theory><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-05-06T22:26:42.443', 'FavoriteCount': '1', 'Id': '11841'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>So I\'ve been trying to crack this for a long time and almost feel like I am going in loops about this question.</p>\n\n<p>Given the following NFA:</p>\n\n<p><img src="http://i.stack.imgur.com/hL3Ps.png" alt="enter image description here"></p>\n\n<p>Using the GNFA algorithm get the regular expression.</p>\n\n<p>I understand that you would have the following for the first step(adding empty states):\n<img src="http://i.stack.imgur.com/6XXjj.png" alt="enter image description here"></p>\n\n<p>The next step would be removing the state [q1] I would get:\n<img src="http://i.stack.imgur.com/cwjUd.png" alt="enter image description here"></p>\n\n<p>Finally removing [q2] would get:\n<img src="http://i.stack.imgur.com/WW3Fj.png" alt="enter image description here"></p>\n\n<p>However the answers others have got is:\n$(a \\cup bb^*a)^*bb^*$\nWhich does not make sense as I got, $a^*b(b \\cup aa^*b)^*$?\nA GNFA(generalised nondeterministic finite automaton) is described as follows:</p>\n\n<p>A GNFA is similar to an NFA but must obey certain rules: </p>\n\n<ul>\n<li>It has only one accept state</li>\n<li>The initial state has no transitions coming into it</li>\n<li>The accept state has no transitions coming out from it</li>\n<li>A transition can denote any regular expression, rather than just a\nsymbol from the alphabet Note that a symbol is a kind of regular\nexpression.</li>\n</ul>\n\n<p>Furthermore, We may convert an NFA into a GNFA as follows: </p>\n\n<ul>\n<li>Add a new start state with an \u03b5-transition to the old start state</li>\n<li>Add a new accept state with \u03b5-transitions from the old accept states</li>\n<li>If arrows have multiple labels, or if there are multiple arrows\nbetween two states, replace them with the union (or) of those labels</li>\n</ul>\n', 'ViewCount': '2097', 'Title': 'Converting an NFA to regex using GNFA algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-12T10:23:30.563', 'LastEditDate': '2013-05-12T10:23:30.563', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '11950', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7216', 'Tags': '<automata><finite-automata><regular-expressions><nondeterminism>', 'CreationDate': '2013-05-10T14:50:56.853', 'Id': '11935'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is it theoretically possible to have a nondeterministic finite state machine without any initial state or does it need at least one initial state?</p>\n', 'ViewCount': '122', 'Title': 'Nondeterministic finite state machine without any initial state possible', 'LastActivityDate': '2013-05-29T15:15:48.100', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8414', 'Tags': '<formal-languages><regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2013-05-28T18:27:39.930', 'Id': '12338'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><a href="http://www.google.ca/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CCwQFjAA&amp;url=http://www.cs.rpi.edu/~moorthy/Courses/modcomp/fall2005/slides/DPDA.ppt&amp;ei=qI6mUeD6KaKOigLr-YH4Cg&amp;usg=AFQjCNHdu1SacbRI9CaOjOvXxzNziaHtEQ&amp;sig2=DLSgGZ-VegxX1lFVSTZTCw&amp;bvm=bv.47244034,d.cGE">These lecture slides</a> sketch a proof that $L=\\{ a^n b^n \\mid n \\geq 0 \\} \\cup  \\{ a^n b^{2n} \\mid n \\geq 0 \\}$\ncannot be accepted by any Deterministic Pushdown Automaton. Unfortunately, the slides give no references as to where the proof comes from.</p>\n\n<p>I was wondering, does anybody know of an academic paper or textbook that gives a full proof? I\'d love to be able to cite it, but I haven\'t been able to find one.</p>\n', 'ViewCount': '143', 'Title': 'Paper with proof that $L=\\{ a^n b^n \\mid n \\geq 0 \\} \\cup \\{ a^n b^{2n} \\mid n \\geq 0 \\}$ is not Deterministic Context Free?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-29T20:10:06.177', 'LastEditDate': '2013-11-29T20:10:06.177', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12367', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><reference-request><automata><pushdown-automata><nondeterminism>', 'CreationDate': '2013-05-29T23:32:51.367', 'Id': '12365'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '409', 'Title': 'Why is NFA minimization a hard problem when DFA minimization is not?', 'LastEditDate': '2013-06-15T18:22:30.120', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '8184', 'FavoriteCount': '1', 'Body': "<p>I know that we can minimize DFAs by finding and merging equivalent states, but why can't we do the same with NFAs?  I'm not looking for a proof or anything like that--unless a proof is simpler to understand.  I just want to understand intuitively why NFA minimization is so hard when DFA minimization is not.</p>\n", 'Tags': '<complexity-theory><finite-automata><nondeterminism>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-06-18T03:28:02.137', 'CommentCount': '0', 'AcceptedAnswerId': '12712', 'CreationDate': '2013-06-15T17:57:35.147', 'Id': '12693'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am studying now for a test in my complexity course. When I solved previous exams I saw the following question : Prove that the language $L$ of all directed graphs on $n$ vertices that contain exactly $10\\sqrt(n)$ strongly connected components is in $NL$. </p>\n\n<p>We saw in class that checking whether a directed graph contains exactly $C$ strongly connected components is in $NL$ for any fixed $C$, but I thought about this question the whole day and I absolutely have no idea how to do it in $NL$ when then number of SCC required is $10\\sqrt(n)$. In the test this question was worth 20 points, so it shouldn't be too hard so I thought that maybe I am missing something important.<br>\nAny ideas people?</p>\n", 'ViewCount': '145', 'Title': 'Checking whether a directed graph on n vertices contains exactly 10*sqrt(n) strongly connected components is in non-deterministic logspace', 'LastActivityDate': '2013-06-28T05:07:36.833', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12942', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4631', 'Tags': '<complexity-theory><space-complexity><nondeterminism>', 'CreationDate': '2013-06-27T22:34:14.210', 'Id': '12932'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm doing some research with NFAs, and I'm wondering there are algorithms which quasi-efficiently minimize them. I realize that this problem is $PSPACE$ hard, so I'm not looking for a polynomial time algorithm.</p>\n\n<p>What I mean by this is an algorithm which may run in exponential time in the worst cases, but which uses some sort of heuristic to speed up the process, albiet not enough to make it exponential.</p>\n\n<p>I'm only using this to try to get a better idea of what the minimal NFAs of certain languages look like. I'm not using it in any production code, so it doesn't need to be blazingly fast.</p>\n\n<p>For example, the Antichains algorithm for NFAs does equivalence testing which is usually fast but sometimes has exponential explosion. I'm looking for something similar, but for minimization.</p>\n\n<p>Note that I'm NOT looking for things like equivalences, etc. which run efficiently but don't produce a minimal NFA.</p>\n\n<p>Bonus points to anyone who find one with an implementation, and quadruple bonus points if it's in Prolog or Python.\nIf the tool I'm looking for doesn't exist, I'd be happy if anyone gave any old implementation of NFA minimization.</p>\n", 'ViewCount': '152', 'Title': 'Are there algorithms to exactly minimize NFAs which are sometimes efficient?', 'LastActivityDate': '2014-02-05T14:19:54.790', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<algorithms><formal-languages><automata><finite-automata><nondeterminism>', 'CreationDate': '2013-07-10T17:56:35.363', 'FavoriteCount': '1', 'Id': '13206'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This is somewhat related to <a href="http://cs.stackexchange.com/questions/13206/are-there-algorithms-to-exactly-minimize-nfas-which-are-sometimes-efficient?noredirect=1#comment27879_13206">another question I asked</a>, but I feel it\'s different enough to warrant its own question.</p>\n\n<p>I\'m doing research where I\'m trying to find the structure of complements of a certain class of finite languages. It\'s easy for me to get the minimal DFAs accepting these languages, but I\'d like to examine what kind of structure NFAs accepting these langauges have, particularly how nondeterminism helps with state-size of the automata (the DFAs are exponentially large).</p>\n\n<p>The problem is, the main NFA reduction technique uses equivalences, which won\'t produce any reduction if I start with a minimal DFA (since it\'s basically using the same technique). If I start with a non-minimal DFA, it just spits out the minimal DFA.</p>\n\n<p>What I\'m wondering is, are there algorithms which can start with a DFA, and shrink it into a smaller NFA by introducing nondeterminism? Are there "standard techniques" to do this?</p>\n\n<p>I have found <a href="http://www.csd.uwo.ca/faculty/ilie/TisF04.pdf">preorder reductions</a>, which look promising but hard to implement. I\'m open to many suggestions.</p>\n', 'ViewCount': '205', 'Title': 'Algorithm to shrink a DFA by introducing nondeterminism?', 'LastActivityDate': '2013-07-17T13:39:28.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '13266', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<formal-languages><automata><finite-automata><discrete-mathematics><nondeterminism>', 'CreationDate': '2013-07-12T16:19:26.300', 'FavoriteCount': '1', 'Id': '13249'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I realize non-deterministic pushdown automata can be an improvement over deterministic ones as they can "choose" among several states and there are some context-free languages which cannot be accepted by a deterministic pushdown.</p>\n\n<p>Still, I do not understand <em>how</em> exactly they "choose". For palindormes for example every source I found just says the automaton "guesses" the middle of the word. What does that mean?</p>\n\n<p>I can think of several possible meanings:</p>\n\n<ol>\n<li><p>It goes into one state randomly and therefore might not accept a\nword, which actually is in the language</p></li>\n<li><p>It somehow goes\n"every possible way", so if the first one is wrong it tests if any\nof the other might be right</p></li>\n<li><p>There is some mechanism I am not\naware of, that chooses the middle of the word and is therefore not\nrandom, but the automaton always finds the right middle.<br></p></li>\n</ol>\n\n<p>This is just an example; what I want to know is how it works for any automaton that has several following states for one and the same state before it.</p>\n', 'ViewCount': '118', 'Title': 'Push Down Automatons "guess" - what does that mean?', 'LastEditorUserId': '2253', 'LastActivityDate': '2013-07-23T19:18:13.910', 'LastEditDate': '2013-07-23T19:13:48.330', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9308', 'Tags': '<formal-languages><automata><pushdown-automata><nondeterminism>', 'CreationDate': '2013-07-23T17:57:55.890', 'Id': '13400'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I read that most scientist don\'t believe that P=NP. This might be subjective but can you simplify why not? I\'m not informed enough to have an opinion but I\'d like to know the definitions and some "pretty simple" explanation why to believe one or the other case, for instance why even believe that it can be proved?</p>\n', 'ViewCount': '200', 'Title': u'Why do most scientists believe that P\u2260NP?', 'LastActivityDate': '2013-09-21T14:57:09.303', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2529', 'Tags': '<nondeterminism><polynomial-time>', 'CreationDate': '2013-09-21T04:09:46.230', 'FavoriteCount': '1', 'Id': '14487'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>At the time of writing, Wikipedia describes determinism as:</p>\n\n<p><em>"a deterministic algorithm is an algorithm which, given a particular input, will always produce the same output, with the underlying machine always passing through the same sequence of states"</em></p>\n\n<p>That aligns with my interpretation of determinism as a natural scientist.</p>\n\n<p>If a program contains a benign race condition and its control flow varies depending upon the outcome of the race, is it deterministic? I would say not. However, many people describe thread-safe reference counting, such as <code>shared_ptr</code> in C++, as deterministic even though threads race to decrement the reference count to zero and the winner is responsible for executing the destructor.</p>\n\n<p>The <a href="http://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29#Reference_counting" rel="nofollow">Wikipedia page about garbage collection</a> lists determinism as an advantage of reference counting compared to tracing collection and determinism is also referred to <a href="https://twitter.com/herbsutter/status/389144549517320192" rel="nofollow">here</a>. On the other hand, people have <a href="http://nerds-central.blogspot.co.uk/2011/11/reference-counting-if-not-deterministic.html" rel="nofollow">blogged rants</a> explaining why this is wrong.</p>\n\n<p>So what does "reference counting is deterministic" mean, if anything?</p>\n', 'ViewCount': '179', 'Title': 'What does "deterministic" mean in the context of memory management?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T17:34:35.060', 'LastEditDate': '2014-02-02T17:34:35.060', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10707', 'Tags': '<nondeterminism><memory-management>', 'CreationDate': '2013-10-15T10:18:08.177', 'Id': '16100'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am learning about CS Theory and specifically Nondeterministic Finite Automata (NFA) right now. In my book I came across a section of text that discussed a way to determine the length of a walk stating specifically that :</p>\n\n<blockquote>\n  <p>If a transition graph has a walk labeled $w$, then there is a walk <em>w</em> of length no more than $\\Lambda + (1 + \\Lambda)|w|$ where $\\Lambda$ is the number of $\\lambda$ transitions in the graph.</p>\n</blockquote>\n\n<p>The book does not define $|w|$ which is causing part of my confusion. I\'m assuming $|w|$ is the length of the label of the walk. So in this case it would be 1 when going from $q_1 \\to q_0 \\to q1$ because $a$ is the only labeled edge.\nI am trying to understand this concept and how it works because when I have tested out this claim it has not held true.</p>\n\n<p>Here is the test I did with this NFA</p>\n\n<p><img src="http://i.stack.imgur.com/9tV6X.png" alt="enter image description here"></p>\n\n<p>$q_1$ is the final state. So assuming you were trying to find the length of the walk $a$, the label would indicate that the length is 1 (e.g. $\\delta^* (q_1, a)$) . However due to the lambdas you actually have $\\lambda \\lambda a$ to go from $q_1 \\to q_0 \\to q_1$.</p>\n\n<p>This theorem doesn\'t hold with my math though because it is defined as \u039b + (1 + \u039b)|w| where \u039b is the number of \u03bb-edges in the graph.</p>\n\n<p>Since there are two \u03bb-edges (and it doesn\'t state whether it means \u03bb-edges in the walk itself or in the graph in total...) this would then be 2 + (1 + 2)|w|. So thats 2 + 3|w|. This clearly is more than 3, which is the length of q1 -> q1 of \u03bb\u03bba.</p>\n\n<p>What am I missing here? Any help is greatly appreciated.</p>\n\n<p>This comes from Peter Linz "An Introduction to Formal Languages and Automata" 5th edition.</p>\n\n<p>Some more information about the argument for this claim:</p>\n\n<blockquote>\n  <p>While \u03bb-edges may be repeated, there is always a walk in which every repeated \u03bb-edge is separated by an edge labeled with a nonempty symbol. Otherwise, the walk contains a cycle labeled \u03bb, which can be replaced by a simple path without changing the label of the walk.</p>\n</blockquote>\n\n<p>Also the book never names this as a theorem or lemma or anything of the sort so it has been very difficult to find online resources about this topic.</p>\n', 'ViewCount': '90', 'Title': 'Determining Length of a walk in Nondeterministic Finite Automata with Lambda Transitions', 'LastEditorUserId': '39', 'LastActivityDate': '2013-11-28T21:40:46.183', 'LastEditDate': '2013-11-28T21:40:46.183', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11178', 'Tags': '<graph-theory><finite-automata><nondeterminism>', 'CreationDate': '2013-11-04T17:36:38.040', 'FavoriteCount': '0', 'Id': '16716'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '66', 'Title': 'Do these languages both have DPDA?', 'LastEditDate': '2013-11-09T15:24:56.840', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10030', 'Body': "<p>We have these languages:\n$$L_1 = \\{a^nb^na^mb^m \\ | n \\ge 0, m \\ge 1\\}$$\n$$L_2 = \\{a^nb^na^mb^{2m} \\ | n \\ge 0, m \\ge 1\\}$$</p>\n\n<p>are both these languages NCFG?</p>\n\n<p>I guess that both of them are NCFG because of $n \\ge 0$ ,at start we can't distinguish whether it is $a$ for the first part or the second part and hence we should act non deterministic.</p>\n", 'ClosedDate': '2013-11-11T13:54:24.870', 'Tags': '<formal-languages><context-free><automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T15:24:56.840', 'CommentCount': '5', 'AcceptedAnswerId': '16849', 'CreationDate': '2013-11-09T12:50:19.650', 'Id': '16846'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have to design a DFA with last 4th character from end is 1.</p>\n\n<p>The alphabets are {0,1}</p>\n\n<p>for e.g. (Anything)1***</p>\n\n<p>One way is to make an NFA and then convert it to DFA...</p>\n\n<p>But i am finding it quite difficult to do it.</p>\n', 'ViewCount': '85', 'ClosedDate': '2013-11-25T09:45:16.640', 'Title': 'Designing a DFA in which last fourth character is 1', 'LastActivityDate': '2013-11-14T17:49:03.743', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '18027', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10861', 'Tags': '<automata><finite-automata><nondeterminism>', 'CreationDate': '2013-11-14T17:04:50.323', 'Id': '18023'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Show that if 3SAT is polynomial-time reducible to $complement of 3SAT$ then $PH = NP$.</p>\n\n<p>Above problem is Exercise problem from Arora and Barak,</p>\n\n<p>i don't know how to solve this problem,if anybody knows how to solve please post the solution </p>\n\n<p>Thanks for help!!</p>\n", 'ViewCount': '71', 'ClosedDate': '2013-11-16T15:29:29.187', 'Title': 'Proving $PH = NP$', 'LastActivityDate': '2013-11-15T13:09:15.560', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<complexity-theory><np-complete><complexity-classes><nondeterminism><polynomial-time>', 'CreationDate': '2013-11-15T09:28:14.230', 'Id': '18043'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '430', 'Title': 'Maximum number of states in minimized DFA from NFA with $n$ states', 'LastEditDate': '2013-11-23T16:37:20.623', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8533', 'Body': '<p>If an NFA with $n$ states is converted to an equivalent minimized DFA then what will be the maximum number of states in the DFA? Will it be $2^n$ or $2n$?</p>\n', 'ClosedDate': '2013-11-28T06:27:57.097', 'Tags': '<automata><finite-automata><nondeterminism>', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-23T17:32:54.963', 'CommentCount': '2', 'AcceptedAnswerId': '18280', 'CreationDate': '2013-11-23T15:18:01.973', 'Id': '18278'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I\'ve converted this NFA to a DFA and I get a similar soultion automata but I\'m not sure if I really understand everything. </p>\n\n<p>Please correct me if I\'m explaining it wrong, I would love some feedback.</p>\n\n<p>From the state 0 we only have the set {0} since there doesn\'t exist any \u03b5-transition.\nAfter that we have to input "a" to move to state 1 and here I\'ve got a question. Does it include the 0 also since "a" can either take you to state 1 but also to state 0 since it loops? </p>\n\n<p>Continuing we want to move to state 2 via "a" input. Why does it include the "0"? Is it because you have to consider all the inputs from each set in the state 1? Like, if you input "a" at 0 you loop but you can also go to state 1. From 1 if you input "a" you move forward to state 2. Which gives us the set {0,1,2}. </p>\n\n<p>If this is correct, then the procedure for state 3 should be the same, right? \nAlso, at the third state {0,1,2,3} he can\'t just loop "b" since the other states can\'t "handle" the input so you have to create a new state containing the set {0,3} which can handle the "b" input?</p>\n\n<p>Sorry if this is a bit long, I just want to understand what is going on really. </p>\n\n<p><img src="http://i.imgur.com/O3X8kQB.png?1" alt="Automatas"></p>\n', 'ViewCount': '93', 'Title': 'NFA to DFA convertion explanation', 'LastActivityDate': '2013-11-27T16:27:27.337', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18421', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11661', 'Tags': '<automata><finite-automata><nondeterminism>', 'CreationDate': '2013-11-27T13:45:53.487', 'Id': '18415'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have this nondeterministic pda:\n$$\\Sigma=  \\{a,b,c\\}$$</p>\n\n<p>and </p>\n\n<p>$$\nL=\\{\\omega\\  \\epsilon\\ \\Sigma^*\\ |\\ \\omega\\ = \\alpha\\beta\\beta^R\\gamma\\ and\\ \\alpha,\\beta,\\gamma\\ \\epsilon\\ \\Sigma^*\\ and\\ |\\beta|\\ &gt;3 \\}\n$$</p>\n\n<p>So once i have create the NPDA, i have to calculate the probability of accepting a correct word, i know it depends on the size of $\\alpha$ and the "free" jumps ($\\varepsilon,\\varepsilon-&gt;\\varepsilon$).\nMy problem is that i can\'t find the exact function of probability can someone explain me how to do it?</p>\n\n<p>Thanks.</p>\n', 'ViewCount': '90', 'Title': 'help with the probability of acceptance of a Nondeterministic Pushdown automata', 'LastActivityDate': '2013-11-29T22:57:27.457', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18468', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '11695', 'Tags': '<context-free><probability-theory><pushdown-automata><nondeterminism>', 'CreationDate': '2013-11-29T11:15:00.567', 'Id': '18464'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given the following multiplication table how could one construct an NFA such that it accepts all strings that have a certain product (say a) ? </p>\n\n<p>The string "abcb" would be evaluated as (a(b(cb))) = a</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; a &amp; c \\\\\n    b &amp; c &amp; a &amp; b \\\\\n    c &amp; b &amp; c &amp;a\n   \\end{array}</p>\n\n<p>I tried to take the transpose of the above matrix:</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; c &amp; b \\\\\n    b &amp; a &amp; a &amp; c \\\\\n    c &amp; c &amp; b &amp; a\n   \\end{array}</p>\n\n<p>And build an NFA for that. I then reversed all the transitions, but I don\'t think that works.</p>\n', 'ViewCount': '72', 'Title': 'NFA for right left multiplication', 'LastActivityDate': '2013-12-02T04:34:35.407', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11741', 'Tags': '<regular-languages><finite-automata><nondeterminism><multiplication>', 'CreationDate': '2013-12-01T20:37:27.720', 'Id': '18509'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given a non-deterministic push down automata (we define "accept" here using accept states), if we assume any operation popping from the stack and checking if the top of the stack contains some symbol can succeed (i.e. "getting rid" of the stack), we get a non-deterministic finite automata.</p>\n\n<p>If we convert two such PDAs, whose languages recognized are the same, and assuming <em>all states are reachable</em>, to NFAs in this fashion, are the languages recognized by the NFAs still the same?</p>\n\n<hr>\n\n<p>Here\'s a simple example.  Consider the language $\\{a^n b^n : n \\in \\mathbb{N}\\}$.  Here\'s one simple PDA for it.  The PDA has two states, $q_0,q_1$.  When it is in state $q_0$ and it reads the symbol $a$ on the input tape, it pushes $A$ on the stack and remains in state $q_0$.  When it reads the symbol $b$ on the input table and the stack is non-empty, it pops whatever is on the stack and moves to state $q_1$.  The PDA accepts if the stack is empty at the end of the input string.  If we convert this PDA to a NFA, we get a NFA with two states $q_0,q_1$ and transitions $q_0 \\stackrel{a}{\\to} q_0$, $q_0 \\stackrel{b}{\\to} q_1$, $q_1 \\stackrel{b}{\\to} q_1$.  This NFA accepts the language $a^* b^*$.  There are other ways to build a PDA for the language $\\{a^n b^n : n \\in \\mathbb{N}\\}$; if we apply the same conversion to them, does the corresponding NFA always accept the language $a^* b^*$?</p>\n', 'ViewCount': '86', 'Title': 'Relaxing the stack in a push down automata', 'LastEditorUserId': '9173', 'LastActivityDate': '2013-12-14T11:26:22.807', 'LastEditDate': '2013-12-14T06:50:09.547', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '18970', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9173', 'Tags': '<formal-languages><pushdown-automata><nondeterminism>', 'CreationDate': '2013-12-13T16:15:38.797', 'Id': '18955'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I need to show that the language Anfa = {(A,w)| A is an nondeterministic finite automata that accepts w} can be decided in polynomial time. My problem is every solution that I think of requires exponential time.</p>\n\n<p>I would appreciate any help, Thanks in advance..</p>\n', 'ViewCount': '115', 'Title': 'how to solve NFA acceptance problem in polynomial time', 'LastActivityDate': '2013-12-19T17:38:29.810', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12242', 'Tags': '<time-complexity><finite-automata><nondeterminism><polynomial-time>', 'CreationDate': '2013-12-19T17:12:44.090', 'Id': '19126'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I read a proof on the closure of decidable languages under kleene star. It begins by saying that the turing machine we want to find would non-determistically split the input string and then use the original decider of the language to approve the partition of each branch.</p>\n\n<p>My question is, I can\'t understand how we can do this non-deterministic split on a word whose length we do not yet know. if the word is very big then there exist more partitions, thus more branches are needed.</p>\n\n<p>So, i don\'t understand how this "non-deterministic split" can be materialized. </p>\n\n<p>Also, if someone has another proof of this closure via turing machines it will be more than welcome!</p>\n', 'ViewCount': '194', 'Title': 'Decidable languages kleene star closure - question on a proof', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T13:59:37.270', 'LastEditDate': '2014-01-18T19:29:21.573', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '19813', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12948', 'Tags': '<computability><turing-machines><closure-properties><nondeterminism>', 'CreationDate': '2014-01-18T18:43:45.827', 'Id': '19811'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '85', 'Title': 'Non determininstic finite state automata', 'LastEditDate': '2014-01-28T06:55:30.370', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'user116317', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Body': '<p>I wanted to construct a NFA over sigma star, where sigma={a,b}, such that at least one of the last 2 symbols is an "a".  I just wanted to make sure that this construction is correct.</p>\n\n<p><img src="http://i.stack.imgur.com/Tusk8.png" alt="State table"></p>\n\n<p><a href="http://i.stack.imgur.com/6zC8W.jpg" rel="nofollow">Original image</a></p>\n', 'ClosedDate': '2014-01-28T08:04:38.627', 'Tags': '<finite-automata><nondeterminism>', 'LastEditorUserId': '1669', 'LastActivityDate': '2014-01-28T06:55:30.370', 'CommentCount': '4', 'CreationDate': '2014-01-28T01:16:36.123', 'Id': '20025'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am taking a course in the theory of computation and am trying to understand how to correctly design NFA\'s so that I can transform them into regex. I was wondering if I have Sigma={a,b} and need to design a NFA over Sigma Star that has at least one of its last 2 characters to be an \'a\'; Can I simply start 2 threads, one that will accept \'a\' as the last character and the other will accept \'a\' or \'b\' in the second to last position and \'a\' as the last symbol? Also, the fact that this will be over Sigma Star, would that also mean that I have to have epsilon transitions included in this design?<img src="http://i.stack.imgur.com/LGiyR.jpg" alt="L(A)={w: at least one the last 2 characters of w is an \'a\'}"></p>\n', 'ViewCount': '30', 'ClosedDate': '2014-01-28T17:50:39.120', 'Title': 'Non-deterministic finite state automoton', 'LastEditorUserId': '13175', 'LastActivityDate': '2014-01-29T19:02:16.467', 'LastEditDate': '2014-01-29T19:02:16.467', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<finite-automata><nondeterminism>', 'CreationDate': '2014-01-28T14:15:44.520', 'Id': '20038'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Assuming we have an automaton that simultaneously accepts a string on two paths. Would this mean that the construction of the NFA might be faulty?  In other words; at the end of any string over any alphabet, does the NFA have to end up accepting one single path only? Or could it accept several at the same time?</p>\n', 'ViewCount': '57', 'ClosedDate': '2014-02-16T18:12:58.687', 'Title': '2 threads accepted at the same time', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-31T09:11:28.767', 'LastEditDate': '2014-01-31T08:26:18.397', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<terminology><automata><finite-automata><nondeterminism>', 'CreationDate': '2014-01-31T00:41:46.270', 'Id': '20136'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I saw this old post on stack overflow of a PDA that accepts a language where there are exactly twice as many a\'s as there are b\'s. The image they used is below and so is the link to the post itself.</p>\n\n<p><a href="http://stackoverflow.com/questions/7018113/what-language-does-this-pushdown-automata-pda-accept">PDA for language that accepts twice as many a\'s as b\'s.</a></p>\n\n<p><img src="http://i.stack.imgur.com/BK7Q4.jpg" alt="enter image description here"></p>\n\n<p>It was commented that the PDA was not deterministic. So I\'m wondering what exactly makes a PDA deterministic, for example, would you remove the epsilon transitions here to make it deterministic or what?</p>\n\n<p>If somebody could convert this into a deterministic PDA and explain the steps to do so, I would appreciate it, I\'m pretty lost when it comes to push down automata.</p>\n', 'ViewCount': '80', 'Title': 'Creating a Deterministic Push Down Automata', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-11T17:44:07.337', 'LastEditDate': '2014-02-11T07:08:59.830', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '21523', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13257', 'Tags': '<automata><pushdown-automata><nondeterminism>', 'CreationDate': '2014-02-11T04:35:31.363', 'Id': '21518'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '163', 'Title': 'Why is this function computable in $O(n^{1.5})$ time?', 'LastEditDate': '2014-02-15T02:13:40.423', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '14654', 'FavoriteCount': '0', 'Body': '<p>My textbook says: "We define the function $f\\colon \\mathbb{N}\\to\\mathbb{N}$ as follows: $f(1)=2$ and $f(i+1)=2^{f(i)^{1.2}}$. Note that given $n$, we can easily find in $O(n^{1.5})$ time the number $i$ such that $n$ is sandwiched between $f(i)$ and $f(i+1)$."</p>\n\n<p>How can I convince myself that we can in fact easily find $i$ in $O(n^{1.5})$ time? As $f$ is defined recursively, I think we have to compute $f(1),f(2),f(3)\\dots f(j)$ until $f(j)\\geq n$. In order to find out the time that these computations take, I think we have to find a suitable upper bound for $i$ dependent on $n$ and we have to find an upper bound on the execution time of the function $x\\to2^{x^{1.2}}$. In the end, we can hopefully show the quoted proposition. Unfortunately, I don\'t see neither one thing nor the other.</p>\n\n<p>I forgot to mention: Please note that we are in a nondeterministic context. So $f$ is claimed to be computable in $O(n^{1.5})$ by a nondeterministic Turing machine.</p>\n\n<hr>\n\n<p>As quite a few people have already read this question, with some of them finding it useful and interesting too, but nobody answered so far, I want to provide some more information on the context: The quoted claim is an integral part of the proof of the nondeterministic time hierarchy theorem. The proof (with the claim) can be found e. g. in the <a href="http://www.cs.princeton.edu/theory/complexity/diagchap.pdf" rel="nofollow">book by Arora and Barak</a>, but I have found quite a few other resources on the Web too which present the same proof. Each of those calls the claim easy or trivial and does not elaborate on how to find $i$ in $O(n^{1.5})$ time. So either all these resources just copied from Arora and Barak or the claim is in fact not so difficult.</p>\n', 'Tags': '<complexity-theory><algorithm-analysis><nondeterminism>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-15T02:25:32.873', 'CommentCount': '2', 'AcceptedAnswerId': '21654', 'CreationDate': '2014-02-14T14:31:23.487', 'Id': '21636'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Consider\n  the language $L = \\{w, w \\in \\{a,b,c\\}^*, n_c(w) = n_a(w) + n_b(w)\\}$, where $n_q(\\omega)$ is defined to be "the number of $p \\in \\omega$.</p>\n\n<p>I have tried a couple of PDA\'s that follow this whole idea of a stack-replacement kind of algorithm, but the reasoning behind it is incorrect. I know it is not the right structure; furthermore, those examples of my previous attempts don\'t really fit in the context of the question that I\'m asking.</p>\n\n<p>There I have a gut feeling that I need to exploit the fact that $0=n_a(w)+n_b(w)-n_c(w)$ but I have absolutely the faintest idea how to do so. When building this kind of "counting machine," what are some design patterns that I can exploit? </p>\n', 'ViewCount': '64', 'Title': 'A NPDA for the language $L = \\{w \\mid w \\in \\{a,b,c\\}^*, n_c(w) = n_a(w) + n_b(w)\\}$', 'LastEditorUserId': '12863', 'LastActivityDate': '2014-03-11T02:53:10.467', 'LastEditDate': '2014-03-11T02:53:10.467', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22414', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12863', 'Tags': '<formal-languages><pushdown-automata><nondeterminism>', 'CreationDate': '2014-03-09T01:16:21.513', 'Id': '22412'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I was going through a deterministic PDA that accepts $wcw^R$ (described in Ullman's textbook), in which the last transition is given as $(q_1,\\epsilon, Z_0)\\to(q_2,Z_0)$, where $q_2$ is the final state. </p>\n\n<p>In DFAs we don't consider $\\epsilon$ transitions, while in PDAs we do include them. Why?</p>\n", 'ViewCount': '40', 'Title': 'Why Deterministic PDA accepts $\\epsilon$ input but DFA not', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-10T09:14:56.833', 'LastEditDate': '2014-03-10T02:39:07.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><pushdown-automata><nondeterminism>', 'CreationDate': '2014-03-10T02:06:20.490', 'Id': '22446'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '698', 'Title': 'Why is non-determinism useful concept?', 'LastEditDate': '2014-03-11T11:29:18.970', 'AnswerCount': '8', 'Score': '13', 'PostTypeId': '1', 'OwnerUserId': '13053', 'FavoriteCount': '4', 'Body': '<p>An automaton is an abstract model of a digital computer. Digital computers are completely deterministic; their state at any time is uniquely predictable from the input and the initial state. </p>\n\n<p>When we are trying to model real systems, why include nondeterminism in Automata theory? </p>\n', 'Tags': '<automata><nondeterminism><applied-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-29T08:53:54.247', 'CommentCount': '5', 'AcceptedAnswerId': '22481', 'CreationDate': '2014-03-10T15:18:44.627', 'Id': '22472'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have read that linear bounded automaton is a Non deterministic Turing machine. Why is it so?</p>\n', 'ViewCount': '25', 'Title': 'Why it is said that LBA is a non deterministic Turing Machine', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:35:08.413', 'LastEditDate': '2014-03-22T11:35:08.413', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22922', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<terminology><turing-machines><automata><nondeterminism><linear-bounded-automata>', 'CreationDate': '2014-03-22T01:05:54.747', 'Id': '22919'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Let A = $(Q, \\Sigma, \\delta, S, F)$ be a deterministic finite automaton associated with the language \n$L \\subseteq \\Sigma^*$ </p>\n\n<blockquote>\n  <p>$L' = \\{y \\in \\Sigma^*:\\exists x\\in L. |x| = |y|\\}$ </p>\n  \n  <p>$L \\subseteq L'$</p>\n</blockquote>\n\n<p>How do I show that there exist a NDFA associated with L' ? </p>\n", 'ViewCount': '35', 'Title': 'NDFA associated with language L', 'LastActivityDate': '2014-04-06T10:16:11.893', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16431', 'Tags': '<regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2014-04-04T01:31:52.257', 'Id': '23407'}},