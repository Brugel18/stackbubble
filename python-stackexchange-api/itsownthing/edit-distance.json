274_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have two strings, where one is a permutation of the other. I was wondering if there is an alternative to <a href="http://en.wikipedia.org/wiki/Hamming_distance">Hamming distance</a> where instead of finding the minimum number of substitutions required, it would find the minimum number of translocations required to go from string a to string b.</p>\n\n<p>My strings are always of the same size and I know there are no errors/substitutions.</p>\n\n<p>Example:</p>\n\n<pre><code>1 2 3 4 5\n3 2 5 4 1\n</code></pre>\n\n<p>This would give me two:</p>\n\n<pre><code>3 2 5 4 1 (start)\n-&gt; 3 2 1 4 5 \n-&gt; -&gt; 1 2 3 4 5\n</code></pre>\n\n<p>If this is already implemented in R that would be even better.</p>\n', 'ViewCount': '419', 'Title': 'Alternative to Hamming distance for permutations', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-13T13:08:30.077', 'LastEditDate': '2012-10-12T19:35:10.880', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '6', 'OwnerDisplayName': 'user1357015', 'PostTypeId': '1', 'OwnerUserId': '3174', 'Tags': '<terminology><string-metrics><permutations><edit-distance>', 'CreationDate': '2012-10-12T16:31:30.713', 'Id': '5036'},274_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am not sure how to draw parallel between the Wagner\u2013Fischer algorithm and dtw algo.\nIn both case we want to find the distance of each index combination (i,j).</p>\n\n<p>In Wagner\u2013Fischer, we initiate the distance by the number of insert we\'d have to do from one empty string to another.</p>\n\n<pre><code>let wagnerFischer (s: string) (t: string) =\n   let m, n = s.Length, t.Length\n   let d = Array2D.create (m + 1) (n + 1) 0\n\n   for i = 0 to m do d.[i, 0] &lt;- i\n   for j = 0 to n do d.[0, j] &lt;- j    \n\n   for j = 1 to n do\n       for i = 1 to m do\n          d.[i, j] &lt;- List.min [\n                           d.[i-1, j  ] + 1; \n                           d.[i  , j-1] + 1; \n                           d.[i-1, j-1] + if s.[i-1] = t.[j-1] then 0 else 1; ]\n   printfn "edit matrix \\n %A" d \n   d.[m,n]\n</code></pre>\n\n<p>in the DWT we initiate the boundary at +infinity because we dont want to \'skip\' any numbers of the sequence, we always want to match with another item.</p>\n\n<p>What I dont see is what changes between the DWT and the WF algo that prevent use to update the distance in homogeneous way. \nIn DWT we systematically add the cost, whereas in the WF algo, we have this non homegenous function wrt different cases </p>\n\n<p>I understand both algo, but dont make the connexion between those differences in the cost function update ..\nAny idea to understand the difference intuitively  ?</p>\n\n<pre><code>let sequencebacktrack (s: \'a seq) (t:\'a seq) (cost:\'a-&gt;\'a-&gt;double) (boundary:int-&gt;double)  =\n   let m, n = s |&gt; Seq.length, t |&gt; Seq.length\n   let d = Array2D.create (m + 1) (n + 1) 0.\n\n   for i = 0 to m do d.[i, 0] &lt;- boundary(i)\n   for j = 0 to n do d.[0, j] &lt;- boundary(j)\n\n   t |&gt; Seq.iteri( fun j tj -&gt;\n            s |&gt; Seq.iteri( fun i si -&gt; \n                        d.[1+i, 1+j] &lt;- cost tj si + List.min [d.[1+i-1, 1+j  ]; \n                                                               d.[1+i  , 1+j-1]; \n                                                               d.[1+i-1, 1+j-1]; ] ))\n   printfn "edit matrix \\n %A" d \n   d.[m,n]\n//does not work\nlet wagnerFischer2 (s: string) (t: string) =\n   sequencebacktrack s t (fun a b -&gt; if a = b then 0. else 1.) (id &gt;&gt; double)\n\nlet b = wagnerFischer2 "ll" "la"\n</code></pre>\n', 'ViewCount': '244', 'Title': 'Levenstein distance and dynamic time warp', 'LastActivityDate': '2012-11-06T12:43:09.843', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4469', 'Tags': '<algorithms><dynamic-programming><edit-distance>', 'CreationDate': '2012-11-05T22:39:54.580', 'Id': '6502'},274_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If you have a long string of length $n$ and a shorter string of length $m$, what is a suitable recurrence to let you compute all $n-m+1$ <a href="http://en.wikipedia.org/wiki/Levenshtein_distance" rel="nofollow">Levevenshtein distances</a> between the shorter string and all substrings of the longer string of length $m$?</p>\n\n<p>Can it in fact be done in $O(nm)$ time?</p>\n', 'ViewCount': '132', 'Title': 'Semi-local Levenshtein distance', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-02T09:52:43.530', 'LastEditDate': '2013-09-02T09:52:43.530', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8938', 'Tags': '<recurrence-relation><dynamic-programming><strings><string-metrics><edit-distance>', 'CreationDate': '2013-06-30T11:00:35.020', 'Id': '12986'},274_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I have two vectors $V_1, V_2 \\in R^l$. Can they be converted into bit vectors $B_1,B_2 \\in \\{0,1\\}^l $ such that if $V_1, V_2$ is close in Euclidean distance, $B_1,B_2$ is close in hamming distance?</p>\n\n<p>Please note that this is a little different from locality sensitive hashing, where    each vector will be hashed into a bucket with certain probability and $l$ such hash functions will be combined to generate $B_i$. The problem appears to be simpler than that as I am not concerned with dimensionality reduction, which is a goal of LSH. </p>\n\n<p>Side note: Please feel free to add new tags as I am not sure which tags should go here. </p>\n', 'ViewCount': '35', 'Title': 'Distance preserving projection for Euclidean distance', 'LastActivityDate': '2014-03-28T22:09:00.227', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16255', 'Tags': '<algorithms><hash><edit-distance>', 'CreationDate': '2014-03-28T22:09:00.227', 'Id': '23196'},274_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Title says it all pretty much. I do realize that often edit distance is defined as the minimum number of operations needed to transform one string to another, but I want something to point to that\'s even more general than that. </p>\n\n<p>I recently saw a brain teaser that claimed that some string was connected in a network to another as "friends" given an edit distance of one. It then went on to claim that friends of friends, friends of friends of friends, etc. (with no given upper bound on the degree of separation), were also in the network of that original string. I can\'t see how this definition of network doesn\'t include every possible string, and so I think the brain teaser is ill-formed. Given sufficient edits, a string can transform to any other string, right? -- but is there a name for that observation? I think this is so fundamental as to be near-impossible to Google, but there is always the distinct possibility of me being an idiot.</p>\n', 'ViewCount': '100', 'Title': 'Is there a basic proof that there exists some edit distance between two strings?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-03T07:54:13.697', 'LastEditDate': '2014-04-03T06:40:20.177', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '23385', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16402', 'Tags': '<strings><string-metrics><edit-distance>', 'CreationDate': '2014-04-03T04:06:27.853', 'Id': '23382'}