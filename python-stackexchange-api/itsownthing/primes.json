{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Say I want to find the n-th prime. Is there an algorithm to directly calculate it or must I do with sieving? I know always calculate the next prime with a sieve principle, but what if I want the n-th prime?</p>\n\n<p>Duplicate:</p>\n\n<p><a href="http://math.stackexchange.com/questions/1257/is-there-a-known-mathematical-equation-to-find-the-nth-prime">http://math.stackexchange.com/questions/1257/is-there-a-known-mathematical-equation-to-find-the-nth-prime</a></p>\n', 'ViewCount': '1212', 'Title': 'What is the time complexity of generating n-th prime number?', 'LastEditorUserId': '41', 'LastActivityDate': '2013-03-22T15:22:39.600', 'LastEditDate': '2013-03-22T05:17:32.637', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2529', 'Tags': '<algorithms><primes>', 'CreationDate': '2013-03-21T14:01:43.727', 'Id': '10683'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1991', 'Title': 'Why is it best to use a prime number as a mod in a hashing function?', 'LastEditDate': '2013-04-05T12:49:56.007', 'AnswerCount': '3', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '4348', 'FavoriteCount': '2', 'Body': "<p>If I have a list of key values from 1 to 100 and I want to organize them in an array of 11 buckets, I've been taught to form a mod function</p>\n\n<p>$$ H = k \\bmod \\ 11$$</p>\n\n<p>Now all the values will be placed one after another in 9 rows. For example, in the first bucket there will be $0, 11, 22 \\dots$. In the second, there will be $1, 12, 23 \\dots$ etc.</p>\n\n<p>Let's say I decided to be a bad boy and use a non-prime as my hashing function - take 12.\nUsing the Hashing function</p>\n\n<p>$$ H = k \\bmod \\ 12$$</p>\n\n<p>would result in a hash table with values $0, 12, 24 \\dots $ in the first bucket, $1, 13, 25 \\dots$ etc. in the second and so on.</p>\n\n<p>Essentially they are the same thing. I didn't reduce collisions and I didn't spread things out any better by using the prime number hash code and I can't see how it is ever beneficial.</p>\n", 'Tags': '<data-structures><hash><hash-tables><primes>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-04-10T16:28:56.047', 'CommentCount': '0', 'AcceptedAnswerId': '11031', 'CreationDate': '2013-04-04T19:36:37.447', 'Id': '11029'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am given a list of $n&gt;1$ arrays, where each array has fairly small number of elements (rarely above $5$). Also $n$ is quite small in practice (around $6$).</p>\n\n<p>My problem is that I would like to efficiently map each element product to unique integer. Also, I would like to efficiently compute the integer, when I change the order of the arrays in the list.</p>\n\n<p>I was thinking something in the line of integer factorization.</p>\n\n<p>Take first $n$ primes ($p_1, p_2, ..., p_n$) and remeber the index of the array in the original list with $ind: A \\rightarrow \\mathbb{N}$. So the initial function would be $ind(A_i)=i$.</p>\n\n<p>Also we denote with $a_{i,j}$ the $j$-th element of the $i$-th array in the list. So the function $F:A_1 \\times A_2 \\times \\ldots \\times A_n \\rightarrow \\mathbb{N}$ would be:</p>\n\n<p>$$F(a_{1,i_1}, a_{2,i_2}, \\ldots, a_{n,i_n})=\\prod_{j=1}^{j=n}p_{ind(A_i)}^{i_j}$$</p>\n\n<p>In more common words, we initially assign a prime number $p_i$ to array $i$ and raise $p_i$ to the index of the element in array $i$. </p>\n\n<p>This guarantees us the uniqueness and also if we change the order of the arrays in the list, we just need to change the $ind$ function. But the problem here is that these products are fairly large and will overflow soon enough (even with using doubles).</p>\n\n<p>Do you have any better idea how to enumerate these products without the large number constraint? I am implementing this in Java and I really would not like to use BigInteger implementation.</p>\n', 'ViewCount': '70', 'Title': 'Assign unique integer keys to sets', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T11:42:08.067', 'LastEditDate': '2013-04-05T10:11:00.107', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4254', 'Tags': '<enumeration><primes>', 'CreationDate': '2013-04-05T09:58:17.547', 'Id': '11046'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>During a programming contest I was asked to find just smallest prime number to given number N.\nAs Sieve cannot be used and brute force also doesn't work.</p>\n\n<p>So, I was wondering is there any other faster implementation.</p>\n\n<p>Here N -> (2, 10^18).</p>\n", 'ViewCount': '162', 'Title': 'What is the fastest to find just smallest prime number to a given number N where N can be as large as 10^18?', 'LastEditorUserId': '39', 'LastActivityDate': '2014-03-24T14:07:02.130', 'LastEditDate': '2014-03-24T14:07:02.130', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '11884', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7711', 'Tags': '<algorithms><primes>', 'CreationDate': '2013-05-08T08:41:37.337', 'Id': '11883'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I need to find largest value for $\\frac{\\phi(i)}{i}$ for $i \\in (2, N)$ where $N$ can be as large as $10^{18}$.</p>\n\n<p>I tried this approach , but is too slow.\nFinding the just smallest prime number to $N$, as its $\\frac{\\phi(i)}{i}$ value is $\\frac{i-1}{i}$, which is maximum in the range. (See <a href="http://math.stackexchange.com/questions/381053/maximum-of-frac-phiii">Maximum of \u03d5(i)i\\frac{\\phi(i)}i</a>)</p>\n\n<p>So, I was wondering if there is any other faster way to find the maximum value. More precisely I need the value of i where $\\frac{\\phi(i)}{i}$ is maximum.</p>\n', 'ViewCount': '76', 'Title': 'Finding largest value for $\\frac{\\phi(i)}{i}$ for $i \\in (2, N)$', 'LastEditorUserId': '39', 'LastActivityDate': '2013-05-08T15:05:00.257', 'LastEditDate': '2013-05-08T14:20:51.633', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7711', 'Tags': '<algorithms><arithmetic><primes>', 'CreationDate': '2013-05-08T09:29:46.807', 'Id': '11885'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am looking for an efficient way to count the number of coprime vectors in a finite and bounded set of integer vectors.</p>\n\n<p>The vectors in my set are $N$-dimensional integer vectors whose components are bounded on the top and bottom by an arbitrary value $K$. Let $x = [x_1,x_2,\\ldots,x_N]$ denote a vector from this set. Then $x$ is <em>coprime</em> if the greatest common denominator of all its elements is 1. That is, $\\gcd(x_1,x_2,...,x_N)=1$.</p>\n\n<p>Some 3-dimensional coprime vectors include: $x = [1,2, 3] , [6, 10, 15] ,[0, 1, 1]$<br>\nSome 3-dimensional non-coprime vectors include: $x = [2,4,6] ,[0, 10, 15] ,[0, 12, 12]$</p>\n\n<p>For fixed $N$ and $K$, my set contains a total of $(2K+1)^N$ distinct integer vectors as each of the $N$ elements can take on integer values from $-K,\\ldots,0,\\ldots,K$. \nA brute-force approach for counting the number of coprime vectors consists of iterating over each of the $(2K+1)^N$ possible vectors and checking to see whether they are coprime (using, for instance, <a href="http://stackoverflow.com/questions/20206152/how-to-quickly-check-if-an-array-is-coprime-using-matlab">this function</a>). Unfortunately, this approach quickly runs into time and memory issues for large values of $N$ and $K$.</p>\n\n<p>I am wondering if anyone can think of a way to smart algorithm to do this. Ideally, I am looking to implement this algorithm as a MATLAB function that can number of coprime pairs given $N$ and $K$ as its input.</p>\n', 'ViewCount': '61', 'Title': 'Counting the number of N-dimensional coprime integer vectors', 'LastActivityDate': '2013-12-03T08:16:42.663', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18564', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2046', 'Tags': '<discrete-mathematics><counting><primes>', 'CreationDate': '2013-12-03T00:57:34.597', 'Id': '18552'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Relevant Information:<br>\n<a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes" rel="nofollow">Sieve of Eratosthenes</a><br>\n<a href="http://en.wikipedia.org/wiki/Sieve_of_Sundaram" rel="nofollow">Sieve of Sundaram</a></p>\n\n<p>Suppose I want to generate all primes in <code>[2,n]</code>, and I have both of these algorithms at my disposal to get the job done. Which is preferable under what conditions?</p>\n\n<p>I read that Sundaram runs in O(n log n) time, whereas Eratosthenes runs in O(n log log n) time, so it seems that Eratosthenes is preferable. However, that is just a very superficial evaluation. Are there other factors (aside from ease of implementation) to be considered? Which is the \'better\' algorithm?</p>\n', 'ViewCount': '81', 'Title': 'Sieve of Eratosthenes vs. Sieve of Sundaram', 'LastActivityDate': '2013-12-19T10:41:54.903', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11093', 'Tags': '<algorithms><time-complexity><primes>', 'CreationDate': '2013-12-19T10:41:54.903', 'Id': '19115'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>There're a lot of examples of code for checking if a number is prime. Why don't people use Fermat's little theorem, i.e. this simple formula </p>\n\n<p>$\\qquad a^{p-1} \\equiv 1 \\pmod p$,</p>\n\n<p>to check if a number is prime?</p>\n", 'ViewCount': '65', 'Title': "Why don't people use Fermat's little theorem to check if number is prime?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T15:36:55.510', 'LastEditDate': '2014-01-19T15:30:11.473', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8659', 'Tags': '<discrete-mathematics><number-theory><primes>', 'CreationDate': '2014-01-19T13:48:30.600', 'Id': '19825'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>So, I've got this problem:</p>\n\n<blockquote>\n  <p>Given a string $\\omega\\in\\{0,\\ldots,9\\}^*$, find the smallest prime number (in base 10) that contains that string, or otherwise returns 0. </p>\n</blockquote>\n\n<p>What I'm asking is a fast algorithm for the problem?</p>\n", 'ViewCount': '107', 'Title': 'Fast ways to compute the smallest prime with a given substring?', 'LastEditorUserId': '31', 'LastActivityDate': '2014-01-23T20:58:12.430', 'LastEditDate': '2014-01-23T15:24:19.347', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11695', 'Tags': '<algorithms><strings><primes>', 'CreationDate': '2014-01-23T12:32:05.913', 'Id': '19910'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>From the proof of <a href="http://en.wikipedia.org/wiki/Miller-Rabin_primality_test">Miller-Rabin</a>, if a number passes the <a href="http://en.wikipedia.org/wiki/Fermat_primality_test">Fermat primality test</a>, it must also pass the Miller-Rabin test with the same base $a$ (a variable in the proof). And the computation complexity is the same.</p>\n\n<p>The following is from the <a href="http://en.wikipedia.org/wiki/Fermat_primality_test">Fermat primality test</a>:</p>\n\n<blockquote>\n  <p>While Carmichael numbers are substantially rarer than prime\n  numbers,<a href="http://en.wikipedia.org/wiki/Miller-Rabin_primality_test">1</a> there are enough of them that Fermat\'s primality test is\n  often not used in the above form. Instead, <strong>other more powerful\n  extensions</strong> of the Fermat test, such as Baillie-PSW, Miller-Rabin, and\n  Solovay-Strassen are more commonly used. </p>\n</blockquote>\n\n<p>What is the benefit of Miller-Rabin and why it is said to be more powerful than the Fermat primality test?</p>\n', 'ViewCount': '133', 'Title': u'Why Miller\u2013Rabin instead of Fermat primality test?', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-09T11:22:04.147', 'LastEditDate': '2014-02-09T09:41:15.330', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '14516', 'Tags': '<algorithms><primes>', 'CreationDate': '2014-02-09T07:38:07.713', 'Id': '21462'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>If suppose your hashCode function results in the following hashCodes among others {x , 2x, 3x, 4x, 5x, 6x...}, then all these are going to be clustered in just m number of buckets, </p>\n\n<pre><code>  where m = table_length/GreatestCommonFactor(table_length, x)\n</code></pre>\n\n<p>Can someone help me to prove the above equation.</p>\n\n<pre><code> Example for the above question would be:\n x = 3, table_length = 24\n m = 24/gcd(3,24) = 24/3 = 8\n\nSo 3%24 = 3  -&gt;1\n   6%24 = 6  -&gt;2\n   9%24 = 9   -&gt;3\n   12%24 = 12 -&gt;4\n   15%24 = 15 -&gt;5\n   18%24 = 18 -&gt;6\n   21%24 = 21 -&gt;7\n   24%24 = 0  -&gt;8\n   27 %24 = 3 -&gt;1\n</code></pre>\n\n<p>From the above equation inference can be drawn that when             </p>\n\n<pre><code>   table_length/GreatestCommonFactor(table_length, x) is 1,\n</code></pre>\n\n<p>i.e when x and table_length are co-prime, the distribution would be proper and will cover all the buckets.</p>\n\n<p>Based on observation</p>\n\n<pre><code>exactly 8 distinct multiples of 3 modulo 8.\nexactly 2 distinct multiples of 4 modulo 8\nexactly 1 distinct multiple of 8 modulo 8\nexactly 4 distinct multiples of 6 modulo 8\nexactly 8 distinct multiples of 6 modulo 8\n</code></pre>\n\n<p>There are exactly LCM(n,c)/c = n/GCD(c,n)distinct multiples of c modulo n</p>\n\n<p>Is a better way of proving possible?</p>\n', 'ViewCount': '41', 'Title': 'Proving that collision is less likely if the table size is prime in case modulo arithmetic is used', 'LastEditorUserId': '15061', 'LastActivityDate': '2014-03-24T14:45:26.307', 'LastEditDate': '2014-02-26T16:02:15.250', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15061', 'Tags': '<hash><hash-tables><primes>', 'CreationDate': '2014-02-26T09:35:01.783', 'Id': '22049'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have been working on a challenge i found on the internet. It is as follows:</p>\n\n<blockquote>\n  <p>You\'ve stumbled onto a significant vulnerability in a commonly used cryptographic library. It turns out that the random number generator it uses frequently produces the same primes when it is generating keys.</p>\n  \n  <p>Exploit this knowledge to factor the (hexadecimal) keys below, and enter your answer as the last six digits of the largest factor you find (in decimal).</p>\n  \n  <p>Key 1: 1c7bb1ae67670f7e6769b515c174414278e16c27e95b43a789099a1c7d55c717b2f0a0442a7d49503ee09552588ed9bb6eda4af738a02fb31576d78ff72b2499b347e49fef1028182f158182a0ba504902996ea161311fe62b86e6ccb02a9307d932f7fa94cde410619927677f94c571ea39c7f4105fae00415dd7d</p>\n  \n  <p>Key 2: \n   2710e45014ed7d2550aac9887cc18b6858b978c2409e86f80bad4b59ebcbd90ed18790fc56f53ffabc0e4a021da2e906072404a8b3c5555f64f279a21ebb60655e4d61f4a18be9ad389d8ff05b994bb4c194d8803537ac6cd9f708e0dd12d1857554e41c9cbef98f61c5751b796e5b37d338f5d9b3ec3202b37a32f</p>\n</blockquote>\n\n<p>These seem to be common RSA 1024-bit keys.</p>\n\n<p>My approach to the problem was to implement <a href="http://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm" rel="nofollow">Pollard\'s rho algorithm</a> to find factors, then once a factor is found, try dividing the decimal form of the keys by that factor until it is not divisible anymore. Iterate. </p>\n\n<p>Now, i used Pollard\'s rho and tried to divide until the key is not divided anymore because of the information the problem gave: the keys are not completely random. </p>\n\n<p>But here comes the question: assuming the algorithm generates two primes and multiplies them to get a co-prime, which is the key, the low randomness doesn\'t help much, does it? I mean, even if both keys share a common factor, finding it the first time would take the regular-impractical-exponential time.</p>\n\n<p>That seems to be the case, as my Python algorithm is running for about 5 hours now and has not found any factor to the second key, which i decided to start with.</p>\n\n<p>As it is a challenge, i assume there is a practical way of finding the answer. \nSo what im i doing wrong? Is just the algorithm choice wrong, as Pollard\'s rho is intended mainly for integer with small factors? Is my assumption that i can only use the lack of randomness after i find the first of the four factor, to then try to break the other key with the same factor, wrong?</p>\n\n<p>I would like if someone could just point me in right direction, instead of just giving the answer. Thank you. </p>\n', 'ViewCount': '33', 'Title': 'Finding prime factors of non-random key generator', 'LastActivityDate': '2014-03-05T05:41:29.360', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22291', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15293', 'Tags': '<algorithms><cryptography><randomness><primes>', 'CreationDate': '2014-03-05T03:22:05.833', 'Id': '22289'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I am trying to get an idea of how the <a href="https://en.wikipedia.org/wiki/Aks_primality_test" rel="nofollow">AKS primality test</a> should be interpreted as I learn about it, e.g. a corollary for proving that PRIMES \u2286 P, or an actually practical algorithm for primality testing on computers.</p>\n\n<p>The test has polynomial runtime but with high degree and possible high constants. So, in practive, at which $n$ does it surpass other primality tests?\nHere, $n$ is the number of digits of the prime, and "surpass" refers to the approximate runtime of the tests on typical computer architectures.</p>\n\n<p>I am interested in functionally comparable algorithms, that is deterministic ones that do not need conjectures for correctness.</p>\n\n<p>Additionally, is using such a test over the others practical given the test\'s memory requirements?</p>\n', 'ViewCount': '294', 'Title': 'When is the AKS primality test actually faster than other tests?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-02T22:41:02.053', 'LastEditDate': '2014-03-31T07:48:51.077', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '16292', 'Tags': '<algorithms><efficiency><primes>', 'CreationDate': '2014-03-30T13:40:07.150', 'FavoriteCount': '3', 'Id': '23260'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>How would one write code to find and add the prime numbers between 4 and 5 million? I need a code that can find all such numbers, and then add them together. I'm not too keen on computer science, so I wouldn't know even where to begin. (I'm a math major).</p>\n\n<p>Any help is appreciated. Also any advice on how to compile and run the code would be helpful.  </p>\n\n<p><strong>PS</strong> I know the answer is one of the following: 294185048443, 303141243820, 294095048847, 277319432363, 453190021165, or 210569014847.</p>\n", 'ViewCount': '59', 'Title': 'Algorithm to find and add prime numbers', 'LastActivityDate': '2014-04-28T01:14:22.950', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17126', 'Tags': '<algorithms><primes>', 'CreationDate': '2014-04-27T23:26:30.997', 'Id': '24162'}},