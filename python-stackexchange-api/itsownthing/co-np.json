412_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose you have an NP problem, and a polynomial time verifier which accepts valid solutions within <code>f(n)</code> operations.</p>\n\n<p>You make a tweak to the verifier program, so that if it takes more than <code>f(n)</code> operations it unconditionally rejects. Then you place it into an NP machine and run it on all possible certificates for some instance of the problem where you\'re not sure if it has a solution. The unconditional reject after <code>f(n)</code> operations ensures the computation terminates within <code>f(n)</code> operations, even when rejecting. So this NP machine can solve the co-NP dual of the NP problem, where you want to reject in polynomial time when there is no solution.</p>\n\n<p>Except that can\'t be right, because it seems to imply <code>NP=co-NP</code> and that\'s not believed to be true. I have an incorrect assumption or inference somewhere. What is it? Why can\'t I avoid NP\'s "negatives might run for a long time or even forever" with algorithm-specific time cutoffs?</p>\n\n<p>A concrete example: suppose you have a 3-SAT verifier that takes no more than <code>42 n^2</code> operations to check a solution to an <code>n</code> clause problem (involving up to <code>3n</code> variables). You then make an NP program like "non-deterministically choose a variable assignment, run verifier for up to 42 n^2 steps, return its result else reject if it didn\'t finish". So within <code>42 n^2</code> operations we\'ll have an answer, and flipping it gives the "is there no satisfying assignment" answer. Why is this not an NP algorithm for the co-NP problem of determining if there is no satisfying assignment to a 3-SAT problem?</p>\n', 'ViewCount': '41', 'Title': "Why doesn't a time cutoff convert NP problems into co-NP?", 'LastEditorUserId': '535', 'LastActivityDate': '2014-03-02T21:08:48.943', 'LastEditDate': '2014-03-02T20:56:00.557', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '535', 'Tags': '<np><intuition><paradox><co-np>', 'CreationDate': '2014-03-02T20:31:20.237', 'FavoriteCount': '2', 'Id': '22204'},412_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m trying to understand/show that DNF VALID is coNP-hard. I have given an algorithm for the complement of DNF VALID and shown that this is in NP (since the complement of a language in NP is in coNP), but I\'m really struggling to show that DNF VALID is coNP-hard. </p>\n\n<blockquote>\n  <p>The complement of DNF VALID = {\u03d5 | \u03d5 is not in DNF OR \u03d5 is falsifiable}</p>\n</blockquote>\n\n<p>A simple algorithm for the complement of DNF VALID:</p>\n\n<pre><code>On a non-deterministic TM M: "on input \u03d5 (boolean formula):\n 1. Scan through \u03d5 and check whether \u03d5 is on DNF. \n      If it is, accept, \n      if not, continue to step 2. \n 2. Non-deterministically choose a valuation for \u03d5\n 3. If \u03d5 is falsifiable accept, if not, reject\n</code></pre>\n\n<p>To show that DNF VALID is coNP-hard I think that I need to show that a language that is NP-complete can be reduced in polynomial time to the complement of DNF VALID, but I\'m not sure with which language to choose, and I could really use some help on how to go forth with the reduction. </p>\n', 'ViewCount': '45', 'Title': 'Showing that DNF VALID is coNP-hard', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-11T06:47:22.733', 'LastEditDate': '2014-04-11T06:47:22.733', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '23666', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16655', 'Tags': '<complexity-theory><reductions><co-np>', 'CreationDate': '2014-04-10T18:09:27.833', 'Id': '23654'}