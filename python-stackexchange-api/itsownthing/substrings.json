{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Say I have an LR grammar <em>G</em> and a string <em>w</em>. I know that I can check if <em>w</em> is in the language of <em>G</em> in linear time. But what if <em>w</em> itself is not in the language of <em>G</em>, but I want to find all substrings of <em>w</em> that are in the language of <em>G</em>? And can I get parse trees for those substrings? What would be the time complexity for these things?</p>\n', 'ViewCount': '91', 'Title': 'Given an LR grammar G and a string w, is it possible to quickly find all substrings in w that are in L(G)?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-22T18:34:46.167', 'LastEditDate': '2012-09-12T12:15:54.237', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'oskarkv', 'PostTypeId': '1', 'Tags': '<formal-grammars><parsing><substrings>', 'CreationDate': '2012-08-08T15:52:55.883', 'Id': '3512'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1105', 'Title': 'Fast k mismatch string matching algorithm', 'LastEditDate': '2012-09-29T20:37:46.053', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '3011', 'FavoriteCount': '2', 'Body': '<p>I am looking for a fast k-mismatch string matching algorithm. Given a pattern string P of length m, and a text string T of length n, I need a fast (linear time) algorithm to find all positions where P matches a substring of T with at most k mismatches. This is different from the k-differences problem (edit distance). A mismatch implies the substring and the pattern have a different letter in at most k positions. I really only require k=1 (at most 1 mismatch), so a fast algorithm for the specific case of k=1 will also suffice. The alphabet size is 26 (case-insensitive english text), so space requirement should not grow too fast with the size of the alphabet (eg., the FAAST algorithm, I believe, takes space exponential in the size of the alphabet, and so is suitable only for protein and gene sequences).</p>\n\n<p>A dynamic programming based approach will tend to be O(mn) in the worst case, which will be too slow. I believe there are modifications of the Boyer-Moore algorithm for this, but I am not able to get my hands on such papers. I do not have subscription to access academic journals or publications, so any references will have to be in the public domain.</p>\n\n<p>I would greatly appreciate any pointers, or references to freely available documents, or the algorithm itself for this problem. </p>\n', 'Tags': '<algorithms><reference-request><strings><string-metrics><substrings>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-04T09:58:32.560', 'CommentCount': '3', 'AcceptedAnswerId': '4855', 'CreationDate': '2012-09-29T19:47:41.390', 'Id': '4797'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<blockquote>\n  <p><strong>Substring Diff</strong><br>\n  Given two strings of length $n$, $P = p_1\\dots p_n$ and $Q = q_1 \\dots q_n$, we define $M(i, j, L)$ as the number of\n  mismatches between $p_i \\dots p_{i+L-1}$ and $q_j \\dots q_{j+L-1}$. In set\n  notation, $M(i, j, L)$ refers to the size of the set $\\{0 \\leq x &lt; L \\mid p_{i + x} \\neq q_{j + x}\\}$.</p>\n  \n  <p>Given an integer $K$, your task is to find the maximum length $L$ such\n  that there exists pair of indices $(i,j)$ for which we have $M(i, j, L) \\leq K$. Of course, we should also have $i + L - 1 \\leq n$ and $j + L - 1 \\leq n$.</p>\n  \n  <p><strong>Constraints</strong></p>\n  \n  <ul>\n  <li>$0 \\leq K \\leq |P|$</li>\n  <li>Both $P$ &amp; $Q$ would have the same length</li>\n  <li>The size of each of the string would be at the max <strong>1500</strong> </li>\n  <li>All characters in $P$ and $Q$ are lower-case English letters.</li>\n  </ul>\n</blockquote>\n\n<p>The recursive function will have the form:</p>\n\n<pre><code>longest(string1, string2, allowed_mismatches) = \n    {\n        ... (something :P )\n    }\n</code></pre>\n\n<p>The state space then has size $K^3$. With an upper bound on $K$ of 1500, the running time and space usage will be terrible... So direct dynamic programming will not work without some additional property to reduce the state space.</p>\n\n<p>Ideas?</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>Using the ideas suggested by both Yuval and Vor, I came up with the following solution that works like a charm, running in $O(K^2)$ time and using $K$ space.</p>\n\n<pre><code>def longest_range_min_sum(str1, str2, start1, start2, slice_size, max_sum):\n    longest = 0\n    i = 0\n    running_sum = 0\n    while i + longest &lt; slice_size:\n        if str1[start1 + i + longest] != str2[start2 + i + longest]:\n            running_sum += 1\n        if running_sum &gt; max_sum:\n            if str1[start1 + i] != str2[start2 + i]:\n                running_sum -= 1\n            i += 1\n        else:\n            longest += 1\n    return longest\n\nimport sys\n\ndata = sys.stdin.readlines()\nnum_cases = int(data.pop(0))\nfor ignore in xrange(num_cases):\n    max_mismatches, str1, str2 = data.pop(0).split()\n    max_mismatches = int(max_mismatches)\n    m = n = len(str1)\n    longest = 0\n    for i in xrange(m + n + 1):\n        if i &gt; n:\n            slice_size = m - (i - n)\n        else:\n            slice_size = min(i, m)\n        if slice_size == 0:\n            continue\n        end1 = max(m, m - i)\n        if i &gt; n:\n            end1 = m - (i - n)\n        start1 = end1 - slice_size\n        end2 = min(i, n)\n        start2 = end2 - slice_size\n        #print zeros_and_ones \n        #print str1[start1:end1], ' - ', str2[start2:end2]\n        longest_in_sub = longest_range_min_sum(str1, str2, start1, start2, slice_size, max_mismatches)\n        #print longest_in_sub\n        longest = max(longest, longest_in_sub)\n    print longest\n</code></pre>\n", 'ViewCount': '578', 'Title': 'Dynamic programming table for finding similar substrings is too large', 'LastEditorUserId': '3101', 'LastActivityDate': '2012-10-19T07:02:46.443', 'LastEditDate': '2012-10-19T07:02:46.443', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '5002', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3101', 'Tags': '<strings><dynamic-programming><substrings>', 'CreationDate': '2012-10-10T10:21:57.203', 'Id': '4994'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>So I have a fun little problem. It will take a minute to explain, but the situation is conceptually very simple. Suppose you have a string of characters, which is interpreted as groups of one or more contiguous characters. This is for run length encoding or something. For example:</p>\n\n<blockquote>\n  <p>zz22344a is two z's, two 2's, one 3, two 4's, and one a.</p>\n</blockquote>\n\n<p>Once you've parsed the original string, you retain only the characters and sizes in an array.</p>\n\n<pre><code>struct Run { char whatChar; int length; }\n\nRun* runArrayVar;\n\nvoid parseIntoArray(char* sourceChars);   // creates runArrayVar\n</code></pre>\n\n<p>I won't put the implementation of parseIntoArray() here because it's trivial to do with a loop, but I'll assume that arrays are null-terminated, although in the problem they don't have to be. Here is the problem part. I want to implement a function like this:</p>\n\n<pre><code>void alterArray(char* newSourceChars, int changedOffset,\n                int changedLength, int changedCharsAdded);\n</code></pre>\n\n<p>This responds to a change in the source text. Included is the new text, the beginning and length of the altered area, and for reference, how many extra characters were added. For example, take the original <code>zz22344a</code>. If the substring <code>223</code> was pasted over with <code>23_44</code>, then the new string would be <code>zz23_4444a</code> and the new array would be two <code>z</code>'s, one <code>2</code>, one <code>3</code>, one <code>_</code>, four <code>4</code>'s, and one <code>a</code>.</p>\n\n<p>I could get the new <code>runArrayVar</code> naively by just calling <code>parseIntoArray</code>, but I want to be less naive: I want to step through and only change the parts of <code>runArrayVar</code> that need to be changed. Finding the first changed element is pretty easy; skip through until you find one that overlaps <code>changedOffset</code> (you need to test one extra char after the element). After that it gets dicey and I can't figure it out. Take the above example:</p>\n\n<p><code>zz</code> needs to be re-checked because the character right after it might have been changed to a <code>z</code>. It wasn't, so it remains <code>zz</code>. Now we're at offset 2.</p>\n\n<p><code>22</code> is rechecked, and it turned into 2. So OK. Now we're at offset 3.</p>\n\n<p><code>3</code> is rechecked, and it's the same. So we're at offset 4.</p>\n\n<p><code>44</code> is rechecked, and apparently turned into an underscore. So we're at offset 5.</p>\n\n<p>At this point we're still looking at characters that have changed, and we're at <code>4444</code>. According to the previous logic, <code>a</code> turned into <code>4444</code>. OK. Now we're past the characters that have changed, and our array still has an element with one a left over. I can keep parsing and terminate the array when I hit the end of the string, but suppose that <code>a</code> was actually a million <code>a</code>s in a row. The algorithm should be able to reason that it doesn't have to do any more work and terminate. If you look at the example, there is nothing you could have changed that particular section into that would influence the <code>a</code>.</p>\n\n<p>This is difficult. I've tried it a lot of different ways and I can't figure out exactly when the algorithm needs to terminate. Please let me know if you have any ideas!</p>\n", 'ViewCount': '81', 'Title': 'Rechecking contiguous characters (as in run length encoding)', 'LastEditorUserId': '5417', 'LastActivityDate': '2013-01-25T16:18:15.193', 'LastEditDate': '2013-01-25T16:18:15.193', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4657', 'Tags': '<strings><substrings>', 'CreationDate': '2012-11-19T17:20:42.823', 'Id': '6770'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I want to be able to locate a substring in a string allowing for a specified number of mismatches, insertions and deletions - and at the same time know how many mismatches, insertions and deletions were used for any match.</p>\n\n<p>Using brute force backtrack I can find the matches, but I cannot guarantee that the match was produced using the fewest permutations possible.</p>\n\n<p>Using dynamic programming I can find the matches and guarantee that the match was produced using the fewest permutations possible, but I cannot specify a number of allowed mismatches, insertion and deletions - only a total edit distance.</p>\n', 'ViewCount': '243', 'Title': 'Fuzzy string matching algorithm with allowed events?', 'LastEditorUserId': '19', 'LastActivityDate': '2013-01-27T23:12:52.733', 'LastEditDate': '2012-12-01T05:00:57.040', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4810', 'Tags': '<algorithms><dynamic-programming><strings><substrings>', 'CreationDate': '2012-11-30T10:52:00.527', 'FavoriteCount': '1', 'Id': '7040'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a question that I still struggle with.\nIt would be really appreciated if you guys could give me some hints.</p>\n\n<p>Here is the problem : \nAssume that $a[1\\dots n]$ is an array of $n$ positive real numbers.\nLet $\\alpha &gt;0$ and $\\beta &gt;0$</p>\n\n<ul>\n<li><p>a subarray $a_1$ with $m$ elements of $a[1 \\dots n]$ is called increasing if $\\frac{a_1[i]}{a_1[j]}\\geq \\alpha$, for all $i&gt;j$ and $1 \\leq i, j \\leq m$.</p></li>\n<li><p>a subarray $a_2$ with $k$ elements of $a[1 \\dots n]$ is called decreasing if $\\frac{a_2[i]}{a_2[j]}\\leq \\beta$, for all $i&gt;j$ and $1 \\leq i, j \\leq k$.</p></li>\n</ul>\n\n<p>Question : write a program to find all increasing/decreasing subarrays of $a[1 \\dots n]$ ?\nthanks so much for your help.</p>\n', 'ViewCount': '226', 'Title': 'Find all increasing/decreasing sub array', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-05-01T17:04:54.940', 'LastEditDate': '2013-01-01T14:07:41.843', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5258', 'Tags': '<algorithms><substrings>', 'CreationDate': '2013-01-01T03:12:53.483', 'Id': '7668'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>We commonly create sub-groups of strings in one particular algorithm implementation. I just want to know in CS literature is there any standard name for such kind of grouping. For e.g.</p>\n\n<pre><code>Hello World! This is May from the dairy farm.\n</code></pre>\n\n<p>Strings with sub-groups of two:</p>\n\n<pre><code>Hello World!\nWorld! This\nThis is\nis May\n...\n</code></pre>\n', 'ViewCount': '36', 'Title': 'terminology for grouping words in a string?', 'LastActivityDate': '2013-01-01T13:34:35.417', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7675', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2374', 'Tags': '<terminology><strings><substrings>', 'CreationDate': '2013-01-01T13:08:48.753', 'Id': '7674'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This <a href="http://www.cs.utexas.edu/~moore/best-ideas/string-searching/index.html">page</a> about Knuth-Moriss-Pratt Algorithm compared to Boyer-Moore describes a possible case where the Boyer-Moore algorithm suffers from small skip distance while KMP could perform better.<br>\nI\'m looking for a good example (text,pattern) that can clearly demonstrate this case.</p>\n', 'ViewCount': '504', 'Title': 'An example where Knuth-Morris-Pratt Algorithm is faster than Boyer-Moore?', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-03-20T19:23:37.120', 'LastEditDate': '2013-02-10T14:23:12.430', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '736', 'Tags': '<algorithms><substrings><matching>', 'CreationDate': '2013-02-10T10:41:28.470', 'Id': '9635'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given s as a string of some alphabet, what is the best known algorithm to compute a corresponding automaton that accepts any string that contains s?</p>\n\n<p>I am mostly intrested of the lowest time complexity so if you tell me what is the best known complexity in O notation to build an automaton for a string that would be just as good.</p>\n', 'ViewCount': '256', 'Title': 'Automaton for substring matching', 'LastEditorUserId': '1033', 'LastActivityDate': '2013-07-02T07:49:31.180', 'LastEditDate': '2013-07-01T12:02:13.157', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1033', 'Tags': '<automata><finite-automata><strings><substrings>', 'CreationDate': '2013-07-01T10:48:25.027', 'Id': '13009'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>From what I have come to understand, the best way to implement it is to use the suffix  array $S$ of the string $w$ and its LCP-array (Longest Common Prefix) $L$.</p>\n\n<p>The answer can be obtained by </p>\n\n<p>$$ \\sum_{i=1}^{|w|} \\left( |S[i]| -L[i-1] \\right).$$</p>\n\n<p>What I don't get is how and why is this working?</p>\n\n<p>I would be very grateful if someone explained this.</p>\n", 'ViewCount': '914', 'Title': 'Number of distinct substrings in a string', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-07-19T07:11:22.433', 'LastEditDate': '2013-07-19T07:11:22.433', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13241', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9073', 'Tags': '<algorithms><data-structures><strings><substrings><suffix-array>', 'CreationDate': '2013-07-07T19:30:34.867', 'Id': '13140'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>We are given an array $a[1 \\ldots n]$ with all $a[i]&gt;0$.</p>\n\n<p>Now we need to find how many distinct sums can be formed from its subarrays (where a subarray is a contiguous range of the array, i.e., $a[j\\ldots k]$ for some $j,k$, the sum is the sum of all of the elements of the subarray). For example, if $a=[1,2,1]$, then the answer is 4: we can form $ 1,2,3,4$.</p>\n\n<p>I know how to count the number of distinct sums in $O(n^2)$ time.</p>\n\n<p>Furthermore, I have come to realise this is similar to the classical problem where we need to find the number of distinct substrings of a string. I was thinking of the possibility of constructing a suffix array and solving it in a similar fashion (in $O(n)$ time). But I have not been able to figure out how to modify that to work here. For example, if we use suffix array for $a=[1,2,1]$ we will get 5 cases instead of the four acceptable ones. Is this possible to do this using suffix arrays or am I thinking in the wrong direction?</p>\n\n<p>Also there is one more direction I have been thinking in. Divide and conquer. Like if I divide the array into two parts every time until it is reduced to a single element. A single element can have one sum. Now if we combine two single elements, It can be done in two ways: if both single ranges have same element then we get 2 different sums, or if both have different elements we get 3 different sums. But I am not being able to generalize this for merging arrays of length greater than 1. Is it possible to merge two m size arrays and get the answer in $O(m)$?</p>\n', 'ViewCount': '262', 'Title': 'Counting number of sums from contiguous subarrays of an array', 'LastEditorUserId': '683', 'LastActivityDate': '2013-07-14T08:29:17.840', 'LastEditDate': '2013-07-14T08:29:17.840', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8622', 'Tags': '<arrays><substrings><suffix-array>', 'CreationDate': '2013-07-13T20:31:03.527', 'FavoriteCount': '1', 'Id': '13262'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>One naive approach in solving <em>multiple pattern matching</em> problem is to call <em>single pattern matching</em> procedure on each of the pattern.</p>\n\n<p>There <strong>must</strong> be some drawbacks in this approach, given the variety of multiple pattern matching algorithms such as Aho Cornsick algorithm, which prove to be more efficient.</p>\n\n<p>So what are the drawbacks on this straightforward yet naive approach? In what scenario is this algorithm doing unnecessary works?</p>\n', 'ViewCount': '40', 'Title': 'Drawbacks of repeating a single pattern matching procedure for many patterns', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-03T07:09:50.597', 'LastEditDate': '2013-10-04T06:33:51.647', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4662', 'Tags': '<algorithms><search-algorithms><strings><substrings>', 'CreationDate': '2013-10-01T18:24:30.603', 'Id': '14739'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to create a regular expression that will generate the following language under the {a,b,c} alphabet:\nall words that do not contain the substring "bbc"</p>\n\n<p>I am having a really hard time understanding how to approach this question. I have done several other questions where a certain substring must be excluded, but this one really messes with my logic.</p>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '83', 'ClosedDate': '2013-11-08T23:00:27.200', 'Title': 'A little help with regular expressions', 'LastActivityDate': '2013-12-09T10:40:08.243', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11200', 'Tags': '<formal-languages><regular-expressions><substrings>', 'CreationDate': '2013-11-05T12:22:33.267', 'Id': '16735'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '178', 'Title': 'Algorithm Request: "Shortest non-existing substring over given alphabet"', 'LastEditDate': '2014-02-21T18:13:37.423', 'AnswerCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14918', 'FavoriteCount': '1', 'Body': "<p>I'm looking for an (efficient) algorithm to solve the following problem:</p>\n\n<blockquote>\n  <p>Given a string $S$ and a set of characters $M$, find the shortest string composed only of characters in $M$ that is <em>not</em> contained in $S$.</p>\n</blockquote>\n\n<p>Try as I might, I can't seem to map this problem to any of the standard CS string problems.</p>\n", 'Tags': '<algorithms><data-structures><strings><substrings>', 'LastEditorUserId': '14918', 'LastActivityDate': '2014-02-22T09:38:12.063', 'CommentCount': '3', 'AcceptedAnswerId': '21901', 'CreationDate': '2014-02-21T17:58:42.620', 'Id': '21896'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>How different are string matching and integer matching in terms of time complexity?</p>\n\n<p>I'm asking this especially in relation to Rabin Karp algorithm. Why is it faster to compute hash code for every substring and check for equality of hashcode with the hashcode of the given string than the naive method of just checking if amy of the substrings match with the given string?</p>\n", 'ViewCount': '45', 'Title': 'string matching vs integer matching', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-11T00:18:50.563', 'LastEditDate': '2014-03-10T20:58:37.677', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22485', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15506', 'Tags': '<algorithms><strings><substrings>', 'CreationDate': '2014-03-10T18:51:36.317', 'Id': '22480'}},