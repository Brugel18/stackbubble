{'ViewCount': '2489', 'Title': 'Does there exist a priority queue with $O(1)$ extracts?', 'LastEditDate': '2012-03-19T19:11:15.323', 'AnswerCount': '9', 'Score': '25', 'PostTypeId': '1', 'OwnerUserId': '92', 'FavoriteCount': '6', 'Body': '<p>There are a great many data structures that implement the priority-queue interface:</p>\n\n<ul>\n<li>Insert: insert an element into the structure</li>\n<li>Get-Min: return the smallest element in the structure</li>\n<li>Extract-Min: remove the smallest element in the structure</li>\n</ul>\n\n<p>Common data structures implementing this interface are (min)<a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29">heaps</a>.</p>\n\n<p>Usually, the (amortized) running times of these operations are:</p>\n\n<ul>\n<li>Insert: $\\mathcal{O}(1)$ (sometimes $\\mathcal{O}(\\log n)$)</li>\n<li>Get-Min: $\\mathcal{O}(1)$</li>\n<li>Extract-Min: $\\mathcal{O}(\\log n)$</li>\n</ul>\n\n<p>The <a href="http://en.wikipedia.org/wiki/Fibonacci_heap">Fibonacci heap</a> achieves these running times for example. Now, my question is the following:</p>\n\n<blockquote>\n  <p>Is there a data structure with the following (amortized) running times?</p>\n</blockquote>\n\n<ul>\n<li>Insert: $\\mathcal{O}(\\log n)$</li>\n<li>Get-Min: $\\mathcal{O}(1)$</li>\n<li>Extract-Min: $\\mathcal{O}(1)$</li>\n</ul>\n\n<p>If we can construct such a structure in $\\mathcal{O}(n)$ time given sorted input, then we can for instance find line intersections on pre-sorted inputs with $o\\left(\\frac{n}{\\log n}\\right)$ intersections strictly faster than if we use the \'usual\' priority queues.</p>\n', 'Tags': '<data-structures><amortized-analysis><priority-queues>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-01-04T21:08:37.440', 'CommentCount': '4', 'AcceptedAnswerId': '537', 'CreationDate': '2012-03-19T14:31:46.663', 'Id': '524''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>A <a href="http://en.wikipedia.org/wiki/Fibonacci_heap#Summary_of_running_times">Fibonnaci Heap</a> supports the following operations:</p>\n\n<ul>\n<li><code>insert(key, data)</code> : adds a new element to the data structure</li>\n<li><code>find-min()</code> : returns a pointer to the element with minimum key</li>\n<li><code>delete-min()</code> : removes the element with minimum key</li>\n<li><code>delete(node)</code> : deletes the element pointed to by <code>node</code></li>\n<li><code>decrease-key(node)</code> : decreases the key of the element pointed to by <code>node</code></li>\n</ul>\n\n<p>All non-delete operations are $O(1)$ (amortized) time, and the delete operations are $O(\\log n)$ amortized time.</p>\n\n<p>Are there any implementations of a priority queue which  also support<code>increase-key(node)</code> in $O(1)$ (amortized) time?</p>\n', 'ViewCount': '926', 'Title': 'Priority queue with both decrease-key and increase-key operations', 'LastActivityDate': '2012-03-30T02:38:44.623', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '887', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '71', 'Tags': '<data-structures><priority-queues>', 'CreationDate': '2012-03-29T21:06:21.303', 'FavoriteCount': '3', 'Id': '880''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': u'<p>I have a high interest in priority-queues (E.g., see my answers on: <a href="http://cs.stackexchange.com/q/524">Does there exist a priority queue with $O(1)$ extracts?</a>), and was wondering if there is a priority-queue or similar data-structure where you can sort by multiple values?</p>\n\n<p>For example, if I wanted to sort by <code>numval</code> and sort by <code>strval</code>, and be able to get the highest (G\xf6del numbering for str) in $\\mathcal{O}(1)$.</p>\n\n\n\n<pre><code>struct Node {\n    int numval;\n    std::string strval;\n};\n</code></pre>\n\n<p>Easily I can think to just maintain two priority-queues, but this would require twice the memory.</p>\n\n<p>Is there a better way?</p>\n', 'ViewCount': '214', 'Title': 'Queue that can sort by multiple priorities?', 'LastActivityDate': '2012-07-05T13:37:54.173', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1120', 'Tags': '<data-structures><asymptotics><efficiency><priority-queues><memory-management>', 'CreationDate': '2012-07-05T13:37:54.173', 'FavoriteCount': '2', 'Id': '2629''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In terms of asymptotic space and time complexity, what is the most efficient priority-queue?\nSpecifically I am looking for priority queues which minimize the complexity of inserts, it\'s ok if deletes are a little slower.</p>\n\n<p><sub> If you\'re looking for a survey of priority-queues which minimises complexity of deletes over inserts, see: <a href="http://cs.stackexchange.com/q/524">Does there exist a priority queue with $O(1)$ extracts?</a>. </sub></p>\n', 'ViewCount': '816', 'Title': 'Most efficient known priority queue for inserts', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-05T08:59:24.467', 'LastEditDate': '2012-09-25T21:29:08.723', 'AnswerCount': '5', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1120', 'Tags': '<data-structures><time-complexity><priority-queues>', 'CreationDate': '2012-07-19T15:49:47.360', 'Id': '2824''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Is there an algorithm to perform batch processing in the increase-key operation? Let us say, a binary heap (min-heap) is used. In the normal increase-key function, if we perform increase key on one node, then we have to traverse paths from the node towards the children to re balance the heap. If we want to increase the keys of five nodes in the heap, we need to call the increase-key function five times. Is it possible to call only one increase-key function and perform increase-key on five nodes simultaneously?</p>\n', 'ViewCount': '217', 'Title': 'Batch processing in increase-key function using binary heap', 'LastEditorUserId': '472', 'LastActivityDate': '2012-08-15T11:00:10.347', 'LastEditDate': '2012-08-14T12:08:17.190', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2460', 'Tags': '<algorithms><data-structures><parallel-computing><concurrency><priority-queues>', 'CreationDate': '2012-08-14T00:39:37.677', 'FavoriteCount': '1', 'Id': '3163''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>First, consider this simple problem --- design a data structure of <em>comparable</em> elements that behaves just like a stack (in particular, push(), pop() and top() take constant time), but can also return its min value in $O(1)$ time, without removing it from the stack. This is easy by maintaining a second stack of min values.</p>\n\n<p>Now, consider the same problem, where the stack is replaced by a queue. This seems impossible because one would need to keep track of $\\Theta(n^2)$ values (min values between elements $i$ and $j$ in the queue). True or false ?</p>\n\n<p>Update: $O(1)$ amortized time is quite straightforward as explained in one of the answers (using two min-stacks). A colleague pointed out to me that one can de-amortize such data structures by performing maintenance operations proactively. This is a little tricky, but seems to work.</p>\n', 'ViewCount': '378', 'Title': 'Lower bounds: queues that return their min elements in $O(1)$ time', 'LastEditorUserId': '5189', 'LastActivityDate': '2013-01-04T15:12:38.933', 'LastEditDate': '2012-12-26T18:06:43.007', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6467', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5189', 'Tags': '<data-structures><priority-queues><lower-bounds>', 'CreationDate': '2012-10-18T05:16:22.060', 'Id': '6146''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I was asked a question on how to use a pair of Queues to create a Stack and how to use a pair of Stacks to create a Queue. Any thoughts on how I would do this? Right now I don't even know where to start.</p>\n", 'ViewCount': '97', 'Title': 'Using Queues for a Stack and Stacks for a Queue', 'LastActivityDate': '2012-10-19T00:44:19.440', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4261', 'Tags': '<data-structures><priority-queues><stack>', 'CreationDate': '2012-10-18T21:43:10.067', 'Id': '6155''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I have a some objects with priority that is compound type and is only <a href="http://en.wikipedia.org/wiki/Partial_ordering" rel="nofollow">partially ordered</a>. I need to select the objects in order of this priority (i.e. yield <em>minimal</em> item each time). But rather than arbitrarily completing the order, I would prefer if the queue was stable in a sense that if there is more than one minimal element, it should return the oldest first.</p>\n\n<p>Is there any heap data structure that would work with partial ordering? Or a modification of regular priority queue to work with it? Common choice for the algorithm I need is simple binary or 4-ary heap, but that does not work with partial ordering.</p>\n\n<p>The priority values support:</p>\n\n<ol>\n<li>Partial ordering using operation $\\preccurlyeq$. It\'s partial ordering, so it\'s possible that $a \\preccurlyeq b$ is false and $b \\preccurlyeq a$ is also false. I write $a \\not\\lesseqgtr b$ in that case.</li>\n<li>Finding <a href="http://en.wikipedia.org/wiki/Infimum" rel="nofollow">infima</a> (glb) and suprema (lub). $\\inf(x_i)$ is the maximal $y$ such that $y \\preccurlyeq x_i$. Calculating the infimum of $n$ values takes $O(n)$ time. <strong>Infimum</strong> (and supremum) <strong>of every set exists.</strong></li>\n<li>A linear extension for the partial ordering could be defined. Using it for the priority queue is the easy way out as the algorithm does work that way. But the order affects performance and the order of insertion looks like it should be best in avoiding worst cases.</li>\n</ol>\n\n<p>Additionally the algorithm that I want to use this in needs to know infimum of all priorities in the queue.</p>\n\n<p>The priorities have some real-world meaning, but are subject to change, so it does not seem viable to rely on other properties they could have.</p>\n\n<hr>\n\n<p>Note: Binary heaps don\'t work with partial ordering. Assume a binary heap with $a$, $b$ and $c$, where $a \\preccurlyeq c$ and $a \\not\\lesseqgtr b$ and $a \\not\\lesseqgtr c$. They are positioned in that order, so</p>\n\n<pre><code>     a (0)\n   /   \\\n b (1)   c (2)\n</code></pre>\n\n<p>now <em>d</em> is inserted. Next free position is 3, the left child of $b$, so we get</p>\n\n<pre><code>        a (0)\n      /   \\\n    b (1)   c (2)\n  /\nd (3)\n</code></pre>\n\n<p>If $d \\preccurlyeq a$ (which implies $d \\preccurlyeq c$ from transitivity, but does not say anything about $d$ and $b$) and $d \\not\\lesseqgtr b$, then $d$ does not get swapped with $b$, because it\'s not less. But it actually is less than $a$, but it\'s not compared with it, so now the main heap invariant does not hold; top is not minimal.</p>\n\n<p>I suspect a forest of heaps somewhat in style of binomial heap could be made to work.  Basically it\'s important to always compare new values with root and only link together comparable elements. It would make the trees in the forest randomly sized and thus make the complexity dependent on number of mutually incomparable sets in the heap. I somewhat suspect the complexity can\'t be fixed (we have to keep comparing until we hit a comparable element) I might have missed something, so I am leaving this open.</p>\n\n<hr>\n\n<p>Note: The ordering is <em>partial</em> and while there are ways to define a linear extensions for it, adding a timestamp and using it as secondary criterion is <em>not</em> one of them. Suppose we assigned the timestamp $t(a)$ for each $a$ and defined the ordering $\\preccurlyeq\'$ as $a \\preccurlyeq\' b$ iff $a \\preccurlyeq b$ or\n($b \\not\\preccurlyeq a$ and $t(a) \\le t(b)$.\nThen suppose we have distinct $a$, $b$, $c$, such that $t(a) \\le t(b) \\le t(c)$ and $c \\le a$. Then $a \\preccurlyeq\' b$ and $b \\preccurlyeq\' c$, but $c \\preccurlyeq\' a$, so the relation is not transitive and therefore is not an ordering at all. This kind of extending only works for weak orderings, but not partial ones.</p>\n\n<hr>\n\n<p><strong>Edit:</strong> I realized that not only is infimum of any set defined, but I actually need to be able to get infimum of elements currently in the queue efficiently. So I am now contemplating whether adding special nodes containing infima of subtrees to some common heap structure would help.</p>\n', 'ViewCount': '248', 'Title': 'Priority queue for partially ordered priorities with infima', 'LastEditorUserId': '5417', 'LastActivityDate': '2013-11-22T02:40:43.357', 'LastEditDate': '2013-01-25T12:46:47.207', 'AnswerCount': '6', 'CommentCount': '6', 'Score': '13', 'OwnerDisplayName': 'Jan Hudec', 'PostTypeId': '1', 'OwnerUserId': '5417', 'Tags': '<data-structures><priority-queues>', 'CreationDate': '2013-01-09T07:52:10.410', 'Id': '7890''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>In many discussions of binary heap, normally only decrease-key is listed as supported operation for a min-heap. For example, CLR chapter 6.1 and <a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29" rel="nofollow">this wikipedia page</a>. Why isn\'t increase key normally listed for min-heap? I imagine it is possible to do that in O(height) by iteratively swapping the increased element (x) with the minimum of its children, until none of its children is bigger than x.</p>\n\n<p>e.g.</p>\n\n<pre><code>IncreaseKey(int pos, int newValue)\n{\n   heap[pos] = newValue;\n   while(left(pos) &lt; heap.Length)\n   {\n      int smallest = left(pos);\n      if(heap[right(pos)] &lt; heap[left(pos)])\n         smallest = right(pos);\n      if(heap[pos] &lt; heap[smallest])\n      { \n         swap(smallest, pos);\n         pos= smallest;\n      }\n      else return;\n   }   \n}\n</code></pre>\n\n<p>Is the above correct? If not, why? If yes, why isn\'t increase key listed for min-heap?</p>\n', 'ViewCount': '3873', 'Title': 'Increase-key and decrease-key in a binary min-heap', 'LastActivityDate': '2013-03-03T22:31:44.110', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7105', 'Tags': '<algorithms><data-structures><heaps><priority-queues>', 'CreationDate': '2013-03-02T11:08:39.657', 'FavoriteCount': '2', 'Id': '10203''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have developed two existing data structures and I want to see their performances over a certain algorithm. In this case I use Dijkstra's algorithm with binary and Fibonacci heaps. Just to ask, if I have 100 to 1000 number of vertices in the tested sparse digraphs, how many times should I execute my program for a single n vertices? How do I know that the empirical differences in performance that I've obtained between data structures are not due to chance?</p>\n", 'ViewCount': '69', 'Title': 'performance between the data structures', 'LastEditorUserId': '4736', 'LastActivityDate': '2013-04-29T09:50:43.620', 'LastEditDate': '2013-04-29T09:50:43.620', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7956', 'Tags': '<data-structures><priority-queues><performance><empirical-research>', 'CreationDate': '2013-04-29T04:33:05.927', 'Id': '11651''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I have recently learned about various randomized algorithms for load balancing. The model is always that there are $m$ balls and $n$ bins and the balls arrive one at a time. The task is to minimize the maximum load of any bin.  However there is something I don't understand.</p>\n\n<p>Why not just keep a priority queue of the loads of the bins and allocate any new ball to the bin with the lowest current load?  This seems to give you the optimal load without any complications.</p>\n", 'ViewCount': '227', 'Title': 'Load balancing. Why not use priority queues?', 'LastActivityDate': '2013-05-20T20:16:53.273', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12169', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8271', 'Tags': '<priority-queues><online-algorithms>', 'CreationDate': '2013-05-20T19:39:14.903', 'Id': '12165''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': "<p>I'm looking for a data structure that can work as a priority queue with reasonable maintenance complexities (like $O(\\log n)$ for insertion and deletion) and that has a theoretical unbounded limit for its number of elements (like a tree structure, that is bounded only by the computer's available memory, and unlike a traditional heap, that uses an static array, which is too costly to augment).</p>\n\n<p>The reason is that I'm implementing a program that makes use of a priority queue and I don't know <em>a priori</em> how many elements I'm going to insert in this queue at once, so sometimes I'm out of space to add another element.</p>\n\n<p>There is no way to estimate this number, and to create a huge array to support a static type of queue is a terrible option, as maybe not even a half of it will be used and I'll be short on memory to allocate other objects.</p>\n\n<p>I've heard of something like a <em>Dynamic Heap</em> (or something in the like) that is some sort of linked list of arrays, whose elements are dynamically allocated when needed, but I'm not sure this is the best strategy to follow, moreover, I would like to know if there were other options.</p>\n\n<hr>\n\n<p>Just for the record, I'm implementing a Branch-and-Bound algorithm for solving a linear integer optimization problem, with each node stored on the queue being the abstraction of an active node on the algorithm. The number of active nodes cannot be estimated at any time, so a theoretically unbounded queue would help a lot.</p>\n", 'ViewCount': '166', 'Title': 'Priority queue with ubounded number of elements (i.e., with dynamic storage)', 'LastEditorUserId': '8399', 'LastActivityDate': '2013-06-13T14:11:06.613', 'LastEditDate': '2013-06-13T02:16:56.120', 'AnswerCount': '3', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8399', 'Tags': '<data-structures><efficiency><priority-queues>', 'CreationDate': '2013-06-12T14:29:55.157', 'Id': '12637''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'ViewCount': '3687', 'Title': 'Heap - Give an $O(n \\lg k)$ time algorithm to merge $k$ sorted lists into one sorted list', 'LastEditDate': '2013-06-24T19:13:31.113', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7678', 'FavoriteCount': '1', 'Body': "<p>Most probably, this question is asked before. It's from CLRS (2nd Ed) problem 6.5-8 -- </p>\n\n<blockquote>\n  <p>Give an $O(n \\lg k)$ time algorithm to merge $k$ sorted lists into one sorted list, where $n$ is the total number of elements in all the input lists. (Hint: Use a min-heap for $k$-way merging.)</p>\n</blockquote>\n\n<p>As there are $k$ sorted lists and total of $n$ values, let us assume each list contains $\\frac{n}{k}$ numbers, moreover each of the lists are sorted in strictly ascending order, and the results will also be stored in the ascending order. </p>\n\n<p>My pseudo-code looks like this --</p>\n\n<pre><code>    list[k]   ; k sorted lists\n    heap[k]   ; an auxiliary array to hold the min-heap\n    result[n] ; array to store the sorted list\n    for i := 1 to k                 ; O(k)\n    do\n        heap[i] := GET-MIN(list[i]) ; pick the first element \n                                    ; and keeps track of the current index - O(1)\n    done\n    BUILD-MIN-HEAP(heap) ; build the min-heap - O(k)\n    for i := 1 to n\n    do\n        array[i] := EXTRACT-MIN(heap)   ; store the min - O(logk)\n        nextMin := GET-MIN(list[1])     ; get the next element from the list 1 - O(1)\n        ; find the minimum value from the top of k lists - O(k)\n        for j := 2 to k                 \n        do\n            if GET-MIN(list[j]) &lt; nextMin\n                nextMin := GET-MIN(list[j]) \n        done\n        ; insert the next minimum into the heap - O(logk)\n        MIN-HEAP-INSERT(heap, nextMin)\n    done\n</code></pre>\n\n<p>My overall complexity becomes $O(k) + O(k) + O(n(k + 2 \\lg k)) \\approx O(nk+n \\lg k) \\approx O(nk)$. I could not find any way to avoid the $O(k)$ loop inside the $O(n)$ loop to find the next minimum element from k lists. Is there any other way around? How to get an $O(n \\lg k)$ algorithm?</p>\n", 'Tags': '<algorithms><algorithm-analysis><heaps><priority-queues>', 'LastEditorUserId': '7678', 'LastActivityDate': '2013-06-24T20:38:10.317', 'CommentCount': '0', 'AcceptedAnswerId': '12854', 'CreationDate': '2013-06-24T06:20:18.200', 'Id': '12853''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>Some priority queues, like the <a href="https://en.wikipedia.org/wiki/Leftist_tree" rel="nofollow">height-based leftist tree</a> (or <a href="http://www.cse.ohio-state.edu/~gurari/course/cis680/cis680Ch8.html" rel="nofollow">here</a>) support merging in $\\mathcal O\\left(\\log n\\right)$ time.</p>\n\n<p>I am looking for a priority queue that merges in (expected|average|amortized|worst-case) <em>sub-linear</em> time, but also has the following properties:</p>\n\n<ul>\n<li>Elements are unique</li>\n<li><code>peek</code> and <code>pop</code> should work in (expected|average|amortized|worst-case) <em>sub-linear</em> time</li>\n</ul>\n\n<p>Is this impossible?</p>\n', 'ViewCount': '210', 'Title': 'Priority queue with unique elements and sublinear time merge?', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-11-04T02:12:44.287', 'LastEditDate': '2013-11-01T03:36:00.840', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><data-structures><trees><priority-queues>', 'CreationDate': '2013-11-01T03:30:02.627', 'FavoriteCount': '2', 'Id': '16611''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}{'Body': '<p>I am now preparing for a test in my algorithms course and I have stumbled upon a question about a data structure which seems too trivial for me, but is probably not trivial at all.</p>\n\n<p>The question is:</p>\n\n<blockquote>\n  <p>Let a "minimum stack" be a data structure that supports the following functions:</p>\n  \n  <ol>\n  <li><p>Creating a new empty data structure.</p></li>\n  <li><p>Inserting element X.</p></li>\n  <li><p>Returning the newest element and removing it from the data structure.</p></li>\n  <li><p>Returning the minimal element (the element with the smallest value). (without removing it)</p></li>\n  <li><p>Changing the minimal element\'s value to k. (Hint: say T is the number of elements added after the minimal element).</p></li>\n  </ol>\n</blockquote>\n\n<p>Now, I have thought about using a linked list which is isomorphic to an actual stack, hence elements can be added and removed only from the tail, but scanning the list from head to tail is possible.</p>\n\n<p>I\'ve checked and all the functions except 4 and 5 turn out to be O(1), but 4 turns out to be O(n) at best, and 5 turns out to be O(T).</p>\n\n<p>My question is: How can I do 4 in O(1) time, so that all the other functions are also O(1)?\nI am not looking for full answers, just hints that will guide me to a full answer.</p>\n', 'ViewCount': '43', 'Title': '"Minimum Stack"', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T12:04:06.387', 'LastEditDate': '2014-03-29T12:04:06.387', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14724', 'Tags': '<data-structures><priority-queues><stack>', 'CreationDate': '2014-03-29T08:33:27.600', 'Id': '23216''color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2}