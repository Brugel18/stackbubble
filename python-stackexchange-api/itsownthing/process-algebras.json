{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A drink dispenser requires the user to insert a coin ($\\bar c$), then press one of three buttons: $\\bar d_{\\text{tea}}$ requests a cup of tea $e_{\\text{tea}}$, ditto for coffee, and $\\bar r$ requests a refund (i.e. the machine gives back the coin: $\\bar b$). This dispenser can be modeled by the following <a href="http://en.wikipedia.org/wiki/Calculus_of_communicating_systems" rel="nofollow">CCS</a> process:</p>\n\n<p>$$ M \\stackrel{\\mathrm{def}}= c.(d_{\\text{tea}}.\\bar e_{\\text{tea}}.M + d_{\\text{coffee}}.\\bar e_{\\text{coffee}}.M + r.\\bar b.M)$$</p>\n\n<p>A civil war raises the price of coffee to two coins, while the price of tea remains one coin. We want a modified machine that delivers coffee only after two coins, and acquiesces to a refund after either one or two coins. How can we model the modified machine with a CCS process?</p>\n', 'ViewCount': '151', 'Title': 'CCS process for a drink dispenser with two different prices', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-17T17:42:36.120', 'LastEditDate': '2013-09-17T17:42:36.120', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '446', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<logic><concurrency><modelling><process-algebras><ccs>', 'CreationDate': '2012-03-17T00:49:38.620', 'Id': '444'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>To my knowledge, there are three major process algebras that have inspired a vast range of research into formal models of concurrency. These are:</p>\n\n<ul>\n<li>CCS and $\\pi$-calculus both by Robin Milner</li>\n<li>CSP by Tony Hoare and</li>\n<li>ACP by Jan Bergstra and Jan Willem Klop</li>\n</ul>\n\n<p>All three seem to have to this day a quite active following and vast amounts of research has been done on them.</p>\n\n<blockquote>\n  <p>What are the key similarities and differences of these approaches? \n  Why has research in process algebra diverged instead of converged, in the sense that there is no one universal model to unify the field? </p>\n</blockquote>\n', 'ViewCount': '334', 'Title': 'Similarities and differences in major process algebras', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-27T21:07:13.243', 'LastEditDate': '2012-03-26T05:23:03.690', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '31', 'Tags': '<logic><concurrency><process-algebras>', 'CreationDate': '2012-03-17T13:58:59.003', 'FavoriteCount': '2', 'Id': '465'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '627', 'Title': 'When are two simulations not a bisimulation?', 'LastEditDate': '2012-03-27T03:06:25.847', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '2', 'Body': '<p>Given a <a href="http://en.wikipedia.org/wiki/State_transition_system">labelled transition system</a> $(S,\\Lambda,\\to)$, where $S$ is a set of states, $\\Lambda$ is a set of labels, and $\\to\\subseteq S\\times\\Lambda\\times S$ is a ternary relation. As usual, write $p \\stackrel\\alpha\\rightarrow q$ for $(p,\\alpha,q)\\in\\to$. The labelled transition $p\\stackrel\\alpha\\to q$ denotes that the system in state $p$ changes state to $q$ with label $\\alpha$, meaning that $\\alpha$ is some observable action that causes the state change.</p>\n\n<p>Now a  relation $R \\subseteq S \\times S$ is a called a <em>simulation</em> iff\n$$ \\forall (p,q)\\in R, \r\n   \\text{ if } p \\stackrel\\alpha\\rightarrow p&#39;\r\n   \\text{ then } \\exists q&#39;, \\;\r\n   q \\stackrel\\alpha\\rightarrow q&#39; \\text{ and } (p&#39;,q&#39;)\\in R.\r\n$$</p>\n\n<p>One LTS is said to <em>simulate</em> another if there exists a simulation relation between them. </p>\n\n<p>Similarly, a relation $R \\subseteq S \\times S$ is a <em>bisimulation</em> iff $\\forall (p,q)\\in R,$ \n$$ \r\n\\begin{array}{l}\r\n   \\text{ if } p \\stackrel\\alpha\\rightarrow p&#39;\r\n   \\text{ then } \\exists q&#39;, \\;\r\n   q \\stackrel\\alpha\\rightarrow q&#39; \\text{ and } (p&#39;,q&#39;)\\in R\r\n\\text{ and } \\\\\r\n\\text{ if } q \\stackrel\\alpha\\rightarrow q&#39;\r\n   \\text{ then } \\exists p&#39;, \\;\r\n   p \\stackrel\\alpha\\rightarrow p&#39; \\text{ and } (p&#39;,q&#39;)\\in R.\r\n\\end{array}\r\n$$</p>\n\n<p>Two LTSs are said to be bisimilar iff there exists a bisimulation between their state spaces.</p>\n\n<p>Clearly these two notions are quite related, but they are not the same.</p>\n\n<blockquote>\n  <p>Under what conditions is it the case that an LTS simulates another and vice versa, but that the two LTSs are not bisimilar?</p>\n</blockquote>\n', 'Tags': '<programming-languages><formal-methods><semantics><process-algebras>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-24T21:05:13.533', 'CommentCount': '0', 'AcceptedAnswerId': '548', 'CreationDate': '2012-03-20T16:28:13.400', 'Id': '541'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '126', 'Title': 'Late and Early Bisimulation', 'LastEditDate': '2012-03-27T03:01:00.267', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '31', 'FavoriteCount': '1', 'Body': '<p>This is a follow up to my earlier questions on <a href="http://cs.stackexchange.com/q/525/31">coinduction</a> and <a href="http://cs.stackexchange.com/q/541/31">bisimulation</a>.</p>\n\n<p>A relation  $R \\subseteq S \\times S$ on the states of an LTS is a <em>bisimulation</em> iff $\\forall (p,q)\\in R,$ \n$$ \r\n\\begin{array}{l}\r\n   \\text{ if } p \\stackrel\\alpha\\rightarrow p&#39;\r\n   \\text{ then } \\exists q&#39;, \\;\r\n   q \\stackrel\\alpha\\rightarrow q&#39; \\text{ and } (p&#39;,q&#39;)\\in R\r\n\\text{ and } \\\\\r\n\\text{ if } q \\stackrel\\alpha\\rightarrow q&#39;\r\n   \\text{ then } \\exists p&#39;, \\;\r\n   p \\stackrel\\alpha\\rightarrow p&#39; \\text{ and } (p&#39;,q&#39;)\\in R.\r\n\\end{array}\r\n$$</p>\n\n<p>This is a very powerful and very natural notion, after you come to appreciate it. But it\'s not the only notion of bisimulation. In special circumstances, such as in the context of the <a href="http://en.wikipedia.org/wiki/%CE%A0-calculus" rel="nofollow">$\\pi$-calculus</a>, other notions such as open, branching, weak, barbed, late and early bisimulation exist, though I do not fully appreciate the differences. But for this question, I want to limit focus just two notions.</p>\n\n<blockquote>\n  <p>What are <em>late</em> and <em>early</em> bisimulation and why would I use one of these notions instead of standard bisimulation?</p>\n</blockquote>\n', 'Tags': '<programming-languages><formal-methods><semantics><process-algebras>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T03:01:00.267', 'CommentCount': '2', 'AcceptedAnswerId': '624', 'CreationDate': '2012-03-21T15:58:38.290', 'Id': '614'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this finite-state process with the corresponding labeled transition system: </p>\n\n<p><img src="http://i.stack.imgur.com/mxLLU.png" alt="enter image description here"></p>\n\n<p>The FSP is: </p>\n\n<pre><code>MAKER = (kochen -&gt; fertig -&gt; MAKER).\nUSER = (fertig -&gt; essen -&gt; USER). \n\n||MAKER_USER = (USER||MAKER).\n</code></pre>\n\n<p>Why is <code>essen</code> possible after the second <code>kochen</code>? <code>USER</code> needs to have <code>fertig</code> in order to able to <code>essen</code> right? </p>\n', 'ViewCount': '168', 'Title': 'LTS of this simple FSP', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-27T15:36:33.043', 'LastEditDate': '2012-07-16T23:31:50.067', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1877', 'Tags': '<automata><finite-automata><process-algebras>', 'CreationDate': '2012-07-15T00:33:08.300', 'Id': '2744'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Does any one know how to implement the simulation relation on two <a href="https://en.wikipedia.org/wiki/State_transition_system" rel="nofollow">labelled transition systems</a> (LTS)? </p>\n\n<p>I know how to do it for branching bi-simulation. The signature refinement theorem is used for that purpose which has the time complexity of $O(n^3)$ on cyclic LTSs. Is the signature refinement technique useful for simulation also?</p>\n\n<p>Is there any binary relation called branching simulation? Any idea how to implement it?</p>\n\n<p>What I would like to do is to write a program such that:</p>\n\n<ul>\n<li>Input: Given two labelled transition systems with silent steps</li>\n<li>Output1: Does one simulates the other one?</li>\n<li>Output2: Are they bisimilar?</li>\n<li>Output3: Are they branching bisimilar?</li>\n<li>Output4: Does one branching simulate the other one?</li>\n</ul>\n\n<p>The following illustrates the definitions of the above relations:</p>\n\n<ol>\n<li><p>simulate: An LTS ($L_1$) simulates another LTS ($L_2$) if there exists a binary relation $R$ over the states of the two transition systems such that every transition of $L_2$ can be matched by a transition of $L_1$. Note that simulation is not an equivalence relation.</p></li>\n<li><p>bisimilar: An LTS ($L_1$) and an LTS ($L_2$) are said to be bisimular if there exists a relation $R$ between the states of these transition systems such that both $R$ and $R^{-1}$ are simulations. Note that bisimularity is an equivalence relation.  </p></li>\n<li><p>branching bisimilarity: is same as bisimilarity but transition systems may have silent steps. Those silent steps ($\\tau$ actions) that do not change the behavior of the process are eliminated. Note that branching bisimilarity is an equivalence relation.</p></li>\n<li><p>branching similarity: I actually have never seen the definition of branching similarity in any context, but it should be the same as similarity. However, the transition systems may have the silent steps.</p></li>\n</ol>\n\n<p>The paper <a href="http://dx.doi.org/10.1016/S1571-0661%2805%2980099-4" rel="nofollow">Distributed Branching Bisimulation Reduction of State Spaces</a> by S. Blom and S. Orzan explains an algorithm to reduce the size of an LTS with respect to branching bisimilarity. The signature refinement theorem is used for that purpose. How it works is roughly as follows: </p>\n\n<p>the algorithm starts by constructing a partition (a set of blocks) of states and terminates once the partition is stable. In a stable partition, two states are branching bisimilar if they belong to the same block. </p>\n\n<p>The above algorithm can also be used to verify whether two LTSs are branching bisimilar or bisimilar. How it works is as follows:</p>\n\n<p>Let LTS, $L_3 = L_1 \\cup L_2$, then if after branching reduction, using the above algorithm, the initial states of $L_1$ and $L_2$ both belong to the same block then they are branching bisimular. The above algorithm has time complexity $O(n^3)$ and space complexity $O(n^2)$.</p>\n\n<p>Question: How can I do the same with branching simulate and simulate relations? </p>\n', 'ViewCount': '132', 'Title': 'How to implement simulation on two LTSs?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-03T21:55:49.257', 'LastEditDate': '2012-08-02T06:34:09.370', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2333', 'Tags': '<automata><formal-methods><process-algebras>', 'CreationDate': '2012-07-31T23:51:35.737', 'FavoriteCount': '1', 'Id': '2976'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We are given a labelled directed graph, where both vertices (or states) and edges (or transitions) have labels. Informally, two states are bisimilar when they have the same label and they can simulate each other\'s transitions. On the states the two states evolve to, the same again is true.</p>\n\n<p>More formally, a binary relation $R \\subseteq S \\times S$ is a <a href="http://en.wikipedia.org/wiki/Simulation_preorder" rel="nofollow">simulation</a> iff $\\forall (p,q) \\in R$</p>\n\n<ul>\n<li>$p$ and $q$ have the same label, and</li>\n<li>if $p \\overset{a}{\\longrightarrow} p\'$ then $\\exists q\', q \\overset{a}{\\longrightarrow} q\'$ and $(p\',q\') \\in R$.</li>\n</ul>\n\n<p>A relation $R$ is a <a href="http://en.wikipedia.org/wiki/Bisimulation" rel="nofollow">bisimulation</a> iff $R$ and $R^{-1}$ are simulations. The largest bisimulation on the given system is called the <em>bisimilarity relation</em>. </p>\n\n<p>There are algorithms for finding the bisimilarity relation, that run in $O(m \\log n)$ time and $O(m+n)$ space, where $n$ is the number of states and $m$ the number of transitions. An example is the Paige-Tarjan RCP algorithm from 1987.</p>\n\n<p>However, consider a simpler problem. Instead of finding all the bisimulations, I just want to find a few of them. Can it be done faster than in loglinear time? If so, how? For example, let\'s say one is given two states $p,q \\in S$ such that they have the same label and they can make the same transitions. What I find problematic is to check that the states they lead to are once again bisimulations. In other words, one could also ask if there is a quick way to decide if two given states are a bisimulation.</p>\n', 'ViewCount': '78', 'Title': 'How to quickly find a few bisimulations on a given labelled digraph?', 'LastActivityDate': '2012-11-16T00:20:57.640', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6691', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<algorithms><graph-theory><process-algebras>', 'CreationDate': '2012-11-15T22:52:59.997', 'FavoriteCount': '1', 'Id': '6690'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading on concurrent processes and algorithms which find infinite processes by searching the process graph recursively. </p>\n\n<p>Most of the material I have found is not for beginners. I am looking for references / algorithms that can help me understand:</p>\n\n<ol>\n<li>What are process graphs?</li>\n<li>How to search for infinite processes in these graphs?</li>\n</ol>\n\n<p>Thanks in advance</p>\n', 'ViewCount': '57', 'Title': 'Process graphs and finding infinite processes', 'LastActivityDate': '2013-02-20T09:10:02.277', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '9962', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6854', 'Tags': '<reference-request><concurrency><process-algebras>', 'CreationDate': '2013-02-13T01:34:04.573', 'Id': '9727'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>CSP is used for the description and representation of concurrent systems, how it is used in practice (theoretically and programmatically)? </p>\n\n<p>What are the application areas (other than concurrent and parallel systems) where it is used?</p>\n', 'ViewCount': '62', 'Title': 'What are some of the practical applications of CSP process algebra?', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-09T20:03:21.613', 'LastEditDate': '2013-03-09T06:31:40.010', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10408', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4817', 'Tags': '<process-algebras>', 'CreationDate': '2013-03-09T01:05:57.950', 'Id': '10398'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>At 15:30 in <a href="http://www.infoq.com/presentations/clojure-core-async" rel="nofollow">this talk</a>  (p13 of <a href="http://qconsf.com/system/files/presentation-slides/Clojure.pdf" rel="nofollow">this presentation here</a>) Rich Hickey mentions the formalisms available for reasoning about Communicating Sequential Processes. He then goes on to mention that these haven\'t yet been applied to Clojure\'s core.async. </p>\n\n<p>The only reference I know of for CSP is <a href="http://www.usingcsp.com/cspbook.pdf" rel="nofollow">Hoare\'s book</a>. I can see some examples of <a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes#Algebraic_operators" rel="nofollow">formalisms to describe CSP here</a>. </p>\n\n<p>Suppose I wanted to do the most basic of CSP as per Rob Pike\'s presentation in Go (slide 43 <a href="http://talks.golang.org/2012/concurrency.slide#43" rel="nofollow">of this</a>). </p>\n\n<pre><code>var (\n    Web = fakeSearch("web")\n    Image = fakeSearch("image")\n    Video = fakeSearch("video")\n)\n\ntype Search func(query string) Result\n\nfunc fakeSearch(kind string) Search {\n        return func(query string) Result {\n              //time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond)\n              return Result(fmt.Sprintf("%s result for %q\\n", kind, query))\n        }\n}\n</code></pre>\n\n<p><strong>How would I express this as an Algebraic statement? What benefit would it give me?</strong></p>\n\n<p>Taking a stab at it - I get</p>\n\n<p><code>(Web &rarr; P) &Pi; (Search &rarr; Q)  &Pi; (Video &rarr; R)</code></p>\n\n<p>Which tells me that the Search process can choose to interact with Web or Video depending on which environment the Search Process chooses to communicate with. </p>\n\n<p><strong>Assumptions</strong></p>\n\n<p>I\'m told that you can\'t do this in pure CSP because of the timer. For an answer I\'m happy to  assume we\'ll ignore the timer part of this. </p>\n', 'ViewCount': '45', 'Title': "How to express Rob Pike's classic Go Code presentation in Hoare's CSP Algebra?", 'LastActivityDate': '2013-12-30T13:02:34.043', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19375', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<concurrency><process-algebras><threads>', 'CreationDate': '2013-12-30T06:41:12.887', 'Id': '19372'}