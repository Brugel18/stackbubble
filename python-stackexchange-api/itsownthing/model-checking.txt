{'Body': '<p>Assume I have two formulae $\\Phi$ and $\\Psi$ (over the same set of atomic propositions $AP$) in <a href="http://en.wikipedia.org/wiki/Computation_tree_logic" rel="nofollow">CTL</a>. We have that $\\Phi \\equiv \\Psi$ iff $Sat_{TS}(\\Phi) = Sat_{TS}(\\Psi)$ for all transition systems $TS$ over $AP$.</p>\n\n<p>Given that there are infinitely many transition systems, it\'s impossible to check them all. I thought about using PNF (Positive Normal Form, allowing negation only next to literals) because judging from its name it should give me the same formula for $\\Phi$ as for $\\Psi$ iff they are equivalent, but I\'m not convinced this works in all cases (you could say, I\'m not convinced PNF is actually a normal form).</p>\n\n<p>For example, take $\\forall \\mathrm{O} \\forall \\lozenge \\Phi_0 \\stackrel{?}{\\equiv} \\forall \\lozenge \\forall \\mathrm{O} \\Phi_0$ (where $\\mathrm{O}$ is the <code>next</code> operator and $\\lozenge$ is the <code>eventually</code> operator). I\'m looking for a way do do this by hand.</p>\n', 'ViewCount': '284', 'Title': 'How can I decide manually whether two CTL formulae are equivalent?', 'LastEditorUserId': '26', 'LastActivityDate': '2013-06-09T13:33:37.627', 'LastEditDate': '2012-03-22T18:25:12.003', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '26', 'Tags': '<logic><model-checking>', 'CreationDate': '2012-03-21T16:09:34.530', 'Id': '616'}{'Body': u'<p>I have a problem with the proof for constructing a GNBA (<a href="https://en.wikipedia.org/wiki/Generalized_B%C3%BCchi_automaton" rel="nofollow">generalized nondeterministic B\xfcchi automaton</a>) for a <a href="https://en.wikipedia.org/wiki/Linear_temporal_logic" rel="nofollow">LTL formula</a>:</p>\n\n<p><strong>Theorem:</strong> For any  LTL formula $\\varphi$ there exists a GNBA $G_{\\varphi}$ over alphabet $2^{AP}$ such that:</p>\n\n<ol>\n<li><p>$\\operatorname{Word}(\\varphi)=L_{\\omega}(G_{\\varphi})$.</p></li>\n<li><p>$G_{\\varphi}$ can be costructed in time and space $2^{O(|\\varphi|)}$, where $|\\varphi|$ is the size of $\\varphi$.</p></li>\n<li><p>The number of accepting states of $G_{\\varphi}$ is bounded above by $O(|\\varphi|)$.</p></li>\n</ol>\n\n<p>My problem lies in the proof of (2), that is, in the proof it says that the number of states in $G_{\\varphi}$ is bounded by  $2^{|\\operatorname{subf}(\\varphi)|}$ but since $|\\operatorname{subf}(\\varphi)| \\leq 2\\cdot|\\varphi|$ (where $\\operatorname{subf}(\\varphi)$ is the set of all subformulae) the number of states is bounded by  $2^{O(|\\varphi|)}$. </p>\n\n<p>But why does $|\\operatorname{subf}(\\varphi)| \\leq 2\\cdot|\\varphi|$ hold? </p>\n', 'ViewCount': '75', 'Title': 'Time to construct a GNBA for LTL formula', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-30T12:27:09.250', 'LastEditDate': '2012-06-30T12:27:09.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2533', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1999', 'Tags': '<logic><automata><formal-methods><model-checking><linear-temporal-logic>', 'CreationDate': '2012-06-28T17:27:44.363', 'Id': '2531'}{'Body': u'<p>I wanted ask if you know an algorithm to find the witness for $EU(\\phi_1,\\phi_2)$ (CTL formula "Exist Until")  using BDDs (<a href="http://en.wikipedia.org/wiki/Binary_decision_diagram" rel="nofollow">Binary Decision Diagram</a>). In pratice you should use the fixed point for calculating $EU(\\phi_1,\\phi_2)$, that is:</p>\n\n<p>$\\qquad \\displaystyle EU(\\phi_1,\\phi_2)=\\mu.Q (\\phi_2 \\vee (\\phi_1 \\wedge EX Q)) $</p>\n\n<p>Unwinding the recursion, we get:</p>\n\n<p>$\\qquad \\displaystyle \\begin{align}\n  Q_0 &amp;= \\textrm{false} \\\\\n  Q_1 &amp;= \\phi_2 \\\\\n  Q_2 &amp;= \\phi_2 \\vee (\\phi_1 \\wedge EX \\phi_2) \\\\\n  \\ \\vdots\n\\end{align}$</p>\n\n<p>and so on.</p>\n\n<p>To generate a witness (path) we can do a forward reachability check within the sequence of $Q_i\u2019s$, that is find a path</p>\n\n<p>$\\qquad \\displaystyle \\pi= s_1 \\rightarrow s_2 \\rightarrow \\cdots \\rightarrow s_n$ </p>\n\n<p>such that $s_i \\in Q_{n-i} \\cap R(s_{i-1})$ (where $R(s_{i-1})= \\{ s \\mid R(s_{i-1},s) \\}$ and $R(s_{i-1},s$) is the transition from $s_{i-1}$ to $s$ ) where $s_0 \\in Q_n $ and $s_n \\in Q_1=\\phi_2$. </p>\n\n<p>How you can do this with BDDs?</p>\n', 'ViewCount': '108', 'Title': 'Witness for the $EU(\\phi_1,\\phi_2)$ using BDDs', 'LastEditorUserId': '472', 'LastActivityDate': '2012-07-12T14:44:09.257', 'LastEditDate': '2012-07-09T21:24:33.637', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '2695', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1999', 'Tags': '<formal-methods><model-checking>', 'CreationDate': '2012-07-07T15:58:13.927', 'Id': '2641'}{'Body': '<p>I am teaching myself program verification and am currently learning <a href="http://en.wikipedia.org/wiki/Proof_assistant" rel="nofollow">proof assistants</a>. I have the book <a href="http://www.cambridge.org/gb/knowledge/isbn/item2327697/?site_locale=en_GB" rel="nofollow">Handbook of Practical Logic and Automated Reasoning</a> which gives the proofs necessary for the understanding of such a system, but more importantly for me it also gives an implementation of the necessary algorithms as <a href="http://www.cl.cam.ac.uk/~jrh13/atp/index.html" rel="nofollow">OCAML source</a>.</p>\n\n<p>I know that some of the tools listed in <a href="http://en.wikipedia.org/wiki/List_of_model_checking_tools" rel="nofollow">Wikipedia: Model Checking tools</a> and <a href="http://anna.fi.muni.cz/yahoda/" rel="nofollow">YAHODA: Verifications Tools Database</a> are open source, but I also prefer it when the theory, proofs, algorithms and source code are presented at the same time reinforcing each other, and in a progression building up to a final application.</p>\n\n<p>Is there such a book for model checking?</p>\n\n<p>EDIT </p>\n\n<p>I may have found what I am looking for in <a href="http://www.springer.com/computer/theoretical+computer+science/book/978-1-4471-4128-0" rel="nofollow">Mathematical Logic for Computer Science</a> with <a href="http://code.google.com/p/mlcs/" rel="nofollow">Prolog source</a>. As I don\'t have the book, does anyone know if this book fits the requirement?</p>\n', 'ViewCount': '76', 'Title': 'Looking for a book that derives and constructs a model checking application', 'LastEditorUserId': '268', 'LastActivityDate': '2012-07-29T02:07:34.563', 'LastEditDate': '2012-07-28T21:16:21.650', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2931', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<reference-request><formal-methods><proof-assistants><model-checking>', 'CreationDate': '2012-07-27T13:10:10.487', 'Id': '2923'}{'Body': '<p>Consider the following specification technique.</p>\n\n<p>A specification consists of a finite set of triples $\\langle C, A, C\' \\rangle$,\nwhere $A$ is the name of an action and $C, C\'$ are conditions, that is,\npropositional formulas over propositional variables.</p>\n\n<p>Example rules (in a more suggestive notation):</p>\n\n<ul>\n<li>$C_1 \\wedge \\neg(C_2 \\vee C_3) \\stackrel{A_1}{\\longrightarrow} C_1 \\wedge \\neg C_2$</li>\n<li>$C_1 \\vee C_3 \\stackrel{A_2}{\\longrightarrow} C_2 \\vee C_3$</li>\n</ul>\n\n<p>Each triple specifies an event together with its preconditions and postconditions:\nthe semantics can be defined by saying that the system being described has a state space consisting of the set of possible truth value assignments to the propositional variables, and that the actions may take the system from any state in which the precondition of a rule for that action holds to any state in which the postcondition of that same rule holds.</p>\n\n<p>This formalism, or a restriction (e.g. no negation in formulas, or only Horn clauses) will only suit my purposes if software exists that can answer questions such as</p>\n\n<ul>\n<li>Given a condition, which events may happen?</li>\n<li>Given a condition, may it lead to deadlock (a condition in which no event can happen)?</li>\n<li>Given a condition, will it <em>never</em> lead to deadlock?</li>\n<li>Do deadlock conditions exist at all?</li>\n<li>Given a condition, which events can never happen?</li>\n</ul>\n\n<p>in under a second.</p>\n\n<p>My question: what to Google for?</p>\n\n<p>Does this formalism have a name?\nCan it be converted to one for which equivalent problems have been studied?\nI\'m thinking of safe Petri nets, for which I\'ve found <a href="http://www.imsc.res.in/~kamal/old/pc1safe.pdf" rel="nofollow">some</a> <a href="http://people.cs.aau.dk/~srba/courses/MCS-07/safePN-atva04.pdf" rel="nofollow">papers</a>, Hoare logic, dynamic logic, no doubt there is more.</p>\n\n<p>Does such software exist?  How do I Google for it?</p>\n', 'ViewCount': '60', 'Title': 'Spot the formalism (some kind of process logic)', 'LastEditorUserId': '917', 'LastActivityDate': '2012-10-19T17:53:22.403', 'LastEditDate': '2012-10-19T17:53:22.403', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '917', 'Tags': '<logic><model-checking><linear-temporal-logic><hoare-logic>', 'CreationDate': '2012-10-19T17:47:54.750', 'Id': '6174'}{'Body': "<p>I apologies if my title is vague, I'm trying to apply CTL/LTL model-checking on some system written in java, however, I still don't understand how to reach a result using either of the approaches mentioned. Do I model my LTS/write specification and use a tool like SPIN to validate that or? I'm mainly looking for a point at a direction that will help me in making a start.</p>\n\n<p>Again sorry but I made this thread after so much frustration searching for an explanation to my problem.</p>\n\n<p>Thank you</p>\n", 'ViewCount': '59', 'Title': 'applying CTL/LTL model-checking on some system', 'LastActivityDate': '2013-02-25T21:50:44.457', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10104', 'Score': '0', 'OwnerDisplayName': 'Meldar', 'PostTypeId': '1', 'OwnerUserId': '7069', 'Tags': '<model-checking><concurrency><program-verification>', 'CreationDate': '2013-02-21T13:21:01.257', 'Id': '10103'}{'Body': '<p>Let $x=(x_1,\\dots,x_n)$ and $y=(y_1,\\dots,y_n)$ be $n$-vectors of boolean variables.  I have a boolean predicate $Q(x,y)$ on $x,y$.  I give my friend Priscilla $Q(x,y)$.  In response, she gives me $P(x)$, a boolean predicate on $x$, and she claims that</p>\n\n<p>$$P(x) \\equiv \\exists y . Q(x,y),$$</p>\n\n<p>or in other words, that</p>\n\n<p>$$\\forall x . [P(x) \\Leftrightarrow \\exists y . Q(x,y)].$$</p>\n\n<p>I would like to verify her claim somehow.  How can Priscilla help me verify this claim?</p>\n\n<p>You can assume that both $P$ and $Q$ are represented as CNF formulas, and that they\'re not too large (polynomial size, or something).</p>\n\n<p>In an ideal world, it\'d be awesome if I could reduce the problem of verifying this claim to SAT: I have a SAT solver, and it\'d be great if I can use the SAT solver to verify this claim.  However, I\'m pretty sure that it\'s not going to be possible to formulate the problem of verifying this claim directly as a SAT instance; <a href="http://cstheory.stackexchange.com/q/11022/5038">testing the validity of a 2QBF formula</a> is almost certainly harder than SAT.  (The $\\Leftarrow$ direction is easy to formulate as a SAT instance, but the $\\Rightarrow$ direction is hard because it inherently involves two alternating quantifiers.)</p>\n\n<p>But suppose Priscilla could give me some additional evidence to support her claim.  Is there some additional evidence or witness Priscilla could give me, which would make it easy for me to verify her claim?  In particular, is there some additional evidence or witness she could give me, which would make it easy for me to formulate the problem of verifying her claim as an instance of SAT (which I can then apply my SAT solver to)?</p>\n\n<p>One unusual aspect of my setting is that I\'m assuming (heuristically) that I have an oracle for SAT.  If you like complexity theory, you can think about it this way: I am taking the role of a machine that can compute things in $P^{NP}$ (i.e., in $\\Delta^P_2$), and I\'m looking to verify Priscilla\'s claim using an algorithm in $P^{NP}$.  My thanks to mdx for this way of thinking about things.</p>\n\n<hr>\n\n<p>My motivation/application: I\'m looking to do formal verification of a system (e.g., symbolic model checking), and a key step in the reasoning involves quantifier elimination (i.e., starting from $Q$, obtain $P$).  I\'m hoping for some clean way to verify that the quantifier elimination was done correctly.</p>\n\n<p>If there\'s no solution that works for all possible $P,Q$, feel free to suggest a solution that is "sound but not complete", i.e., a technique that for many $P,Q$ lets me verify the claimed equivalence. (Even if it fails to verify the claim on some $P,Q$ that do satisfy the claim, I can still try this as a heuristic, as long as it never inappropriately claims to have verified a false claim.  On any given $P,Q$, it might work, or it might not; if it doesn\'t work, I\'m no worse off than where I started.)</p>\n', 'ViewCount': '109', 'Title': 'Verify correctness of quantifier elimination, using SAT', 'LastEditorUserId': '755', 'LastActivityDate': '2013-10-09T00:35:46.483', 'LastEditDate': '2013-10-07T02:09:21.303', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<logic><satisfiability><first-order-logic><software-verification><model-checking>', 'CreationDate': '2013-10-04T20:40:24.817', 'FavoriteCount': '2', 'Id': '14816'}{'Body': '<p>Here is a simple transition system of beverage vending machine:\n<img src="http://i.stack.imgur.com/bgJM8.png" alt="beverage vending machine"> </p>\n\n<p>The exemplary execution fragments can look like this:</p>\n\n<p><img src="http://i.stack.imgur.com/F0kPo.png" alt="enter image description here"></p>\n\n<p>Now, imagine we have multi-process TS where processes are identical and communicate over channels. I don\'t understand the semantics of how to present an execution fragment that runs across multiple processes. Should I specify the whole execution in one line? If yes how do I denote that the state belongs to some certain process? Or maybe I present execution fragment on each process in the separate line? I\'d love to see a "meta-example" of how that could look like. </p>\n\n<p>I am referring to this specific <a href="http://www-i2.informatik.rwth-aachen.de/i2/fileadmin/user_upload/documents/MC11/sheet02.pdf" rel="nofollow">exercise sheet</a>, task 3.) b). The figures are from the book "Principles of Model Checking" by Christel Baier and Joost-Pieter Katoen p. 22 and p. 25.  </p>\n', 'ViewCount': '65', 'Title': 'Example of execution fragment of multi-process transition system', 'LastActivityDate': '2013-10-08T17:15:44.600', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10582', 'Tags': '<formal-languages><automata><model-checking><denotational-semantics>', 'CreationDate': '2013-10-08T17:15:44.600', 'Id': '14915'}{'Body': '<p><strong>Background:</strong><br>\nIn the book of <a href="http://is.ifmo.ru/books/_principles_of_model_checking.pdf" rel="nofollow">Principle of Model Checking (Section 9.2, Page 701)</a>, the semantics of the <code>until</code> modality is defined over some time-divergent path $\\pi \\in s_0 \\Rightarrow^{d_0} s_1 \\Rightarrow^{d_1} \\cdots \\Rightarrow^{d_{i-1}} s_i \\Rightarrow^{d_i} \\cdots$ as follows:</p>\n\n<p>(We can skip the formal definition at your first reading.)<br>\n$\\pi \\models \\Phi \\cup^{J} \\Psi \\iff$<br>\n$\\exists i \\ge 0. s_i + d \\models \\Psi \\textrm{ for some } d \\in [0,d_i] \\textrm{ with } \\sum_{k=0}^{i-1}d_k + d \\in J \\textrm{ and }$\n$\\forall j \\le i. s_j + d\' \\models \\Phi \\lor \\Psi \\textrm{ for any } d\' \\in [0,d_j] \\textrm{ with } \\sum_{k=0}^{j-1} d_k + d\' \\le \\sum_{k=0}^{i-1} d_k + d$.</p>\n\n<blockquote>\n  <p>Intuitively, time-divergent path $\\pi \\in s_0 \\Rightarrow^{d_0} s_1 \\Rightarrow^{d_1} \\cdots \\Rightarrow^{d_{i-1}} s_i \\Rightarrow^{d_i} \\cdots$ satisfies $\\Phi \\cup^{J} \\Psi$ whenever at some time point in $J$, a state is reached satisfying $\\Psi$ and at all previous time instants <strong>$\\Phi \\lor \\Psi$</strong> holds.</p>\n</blockquote>\n\n<p>However, in the book of Model Checking by E.M. Clarke (Section 16.3, Page 256), the semantics of the <code>until</code> modality is given as follows:</p>\n\n<blockquote>\n  <p>$s \\models E[\\Phi \\cup_{[a,b]} \\Psi]$ if and only if there exists a path $\\pi = s_0 s_1 s_2 \\cdots$ starting at $s = s_0$ and some $i$ such that $a \\le i \\le b$ and $s_i \\models \\Psi$ and for all $j &lt; i, s_j \\models \\Phi$.</p>\n</blockquote>\n\n<p>As indicated, the second definition is stricter than the first one in that it does not allow the case of $\\lnot \\Phi \\land \\Psi$ before reaching a state satisfying $\\Psi$.</p>\n\n<p><strong>Problem:</strong>    </p>\n\n<blockquote>\n  <ol>\n  <li>Why are there two different <code>until</code> ($\\cup$) semantics in Timed Computation Tree Logic (TCTL)?</li>\n  <li>Which one is more official?</li>\n  </ol>\n</blockquote>\n', 'ViewCount': '45', 'Title': 'Why are there two different `until` ($\\cup$) semantics in Timed Computation Tree Logic?', 'LastActivityDate': '2013-12-29T07:05:45.310', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4911', 'Tags': '<formal-languages><formal-methods><model-checking>', 'CreationDate': '2013-12-28T09:23:35.717', 'Id': '19338'}{'Body': "<p>In my project, there is one important step to automatically verify a timed automata with TCTL formulae. I briefly surveyed the tool UPPAAL that provides a GUI to construct a timed automata and to specify CTL formulae. However, I didn't find the api to invoke.</p>\n\n<p>Is there any tools with api provided for verifying TCTL formulae over timed automata can be imported into my project? Such that I can automatically send the timed automata and the TCTL formulae to the tool and get the satisfaction result.</p>\n\n<p>And, the tool UPPAAL can only verify a CTL subset of TCTL over a timed automata. On this constraint, if I want to verify a TCTL formula with interval constraint $\\Phi$ (such as $\\exists (\\Phi_1 U^J \\Phi_2)$), I have to extend each location $l$ of the automata with an extra clock $z$, and verify each state $l\\{z:=0\\}\\models \\exists (\\Phi_1 U (z\\in J \\wedge \\Phi_2))$. And I have to wrap a CTL detection algorithm for nested formulae. Is there any tool can directly verify TCTL formulae over a timed automata?</p>\n", 'ViewCount': '35', 'Title': 'Is there any open-source tools for verifying TCTL formulae over timed automata can be imported into my project?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:42:29.790', 'LastEditDate': '2014-01-15T08:42:29.790', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12457', 'Tags': '<formal-methods><model-checking><software-verification>', 'CreationDate': '2014-01-15T06:12:27.823', 'Id': '19739'}{'Body': '<p>I am learning about temporal logic and model checking systems. One conceptual exercise that I am struggling with is how to create a transition system which satisfies only <em>one</em> of two given properties, when one is in LTL and one is in CTL. For example:</p>\n\n<ul>\n<li>Find a transition system that satisfies only one of the following two properties: $FGp$, $AFEGp$</li>\n<li>Find a transition system that satisfies only one of the following two properties: $FGp$, $EFEGp$</li>\n<li>Find a transition system that satisfies only one of the following two properties: $GFp$, $AGEFp$</li>\n</ul>\n\n<p>How should I begin when trying to reason about these types of problems? In general, is it easier to design transition systems for LTL properties or CTL properties? Or does it depend on the situation?</p>\n\n<p>Any insight would be appreciated!</p>\n', 'ViewCount': '48', 'Title': 'Transition systems that satisfy LTL but not CTL, and vice versa', 'LastEditorUserId': '12914', 'LastActivityDate': '2014-01-17T23:04:29.320', 'LastEditDate': '2014-01-17T23:04:29.320', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12914', 'Tags': '<logic><linear-temporal-logic><model-checking>', 'CreationDate': '2014-01-17T07:50:25.933', 'Id': '19777'}{'Body': '<p>Specifications in <a href="http://en.wikipedia.org/wiki/Kripke_structure_%28model_checking%29" rel="nofollow">Kripke structures</a> are verified by Computation tree logic (CTL). However, refering to <a href="http://en.wikipedia.org/wiki/Computation_tree_logic" rel="nofollow">this Wikipedia article</a> the CTL-operators are relative to a <em>current state</em>. So, when we want to verify if <code>EF q</code> is satisfied in a Kripke structure</p>\n\n<p>Do we only need to check if <code>EF q</code> holds starting from the starting state oder do we need to check if <code>EF q</code> holds starting from every state?</p>\n', 'ViewCount': '53', 'Title': 'Computation tree logic and Kripke structures', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-01T20:45:50.520', 'LastEditDate': '2014-02-01T20:45:50.520', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '20193', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12502', 'Tags': '<logic><model-checking><temporal-logic>', 'CreationDate': '2014-02-01T17:01:58.490', 'Id': '20191'}{'Body': '<p>I am learning aobut model checking, and I am having some trouble conceptualizing what ample sets are for partial order reduction. I don\'t fully understand why they need to satisfy <a href="http://en.wikipedia.org/wiki/Partial_order_reduction#Ample_sets" rel="nofollow">these four conditions</a> and what do these conditions mean? Also what is the difference between an ample set for a state and an enabled set for the same state in a transition system.</p>\n\n<p>Could someone give me a simple example of a transition system, and then define the ample sets for each state in that example state space? Any insight would be much appreciated.</p>\n\n<p>Thanks!</p>\n', 'ViewCount': '12', 'Title': 'Ample sets for partial order reduction?', 'LastActivityDate': '2014-03-07T21:55:16.377', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12914', 'Tags': '<model-checking>', 'CreationDate': '2014-03-07T21:55:16.377', 'Id': '22381'}