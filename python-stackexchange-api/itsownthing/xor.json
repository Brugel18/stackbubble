{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '337', 'Title': 'How can I find minimum number required to add to sequence such that their xor becomes zero', 'LastEditDate': '2012-07-04T08:50:11.117', 'AnswerCount': '3', 'Score': '5', 'OwnerDisplayName': 'ArG0NaUt', 'PostTypeId': '1', 'OwnerUserId': '2368', 'FavoriteCount': '1', 'Body': '<p>Given a sequence of natural numbers, you can add any natural number to any number in the sequence such that their xor becomes zero. My goal is to minimize the sum of added numbers.</p>\n\n<p>Consider the following examples :</p>\n\n<ol>\n<li><p>For $1, 3$ the answer is $2$;  adding $2$ to $1$ we get $3 \\oplus 3=0$.</p></li>\n<li><p>For $10, 4, 5, 1$ the answer is $6$;  adding $3$ to $10$ and $3$ to $8$ we get $13 \\oplus 4 \\oplus 8 \\oplus 1 = 0$.</p></li>\n<li><p>For $4, 4$ the answer is $0$, since $4 \\oplus 4 = 0$.</p></li>\n</ol>\n\n<p>I tried working on binary representations of sequence number but it got so complex. I want to know if there is any simple and efficient way to solve this problem.</p>\n', 'Tags': '<algorithms><integers><xor>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-03T08:55:47.557', 'CommentCount': '1', 'CreationDate': '2012-06-30T05:10:32.913', 'Id': '2590'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to solve a problem:</p>\n\n<p>I have 11 ciphers encoded with the same key.\nMy aim is to decode target cipher.</p>\n\n<p>If I do xor C1, C2 (<strong>ciphers encoded with the same key</strong>) I do get M1 xor M2 (where M1, M2 are plain text messages).</p>\n\n<p>Please say what to do next. I don't understand how to get plain texts from M1 xor M2</p>\n\n<p><strong>UPD:</strong> it's a two time pad (i.e. the same key has been use more than one time)</p>\n", 'ViewCount': '573', 'Title': 'One time pad, get plaintext using ciphers encoded with the same key', 'LastEditorUserId': '4639', 'LastActivityDate': '2012-12-23T10:32:19.413', 'LastEditDate': '2012-11-18T14:04:32.200', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4639', 'Tags': '<cryptography><encryption><xor>', 'CreationDate': '2012-11-18T11:07:56.430', 'FavoriteCount': '1', 'Id': '6740'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '135', 'Title': 'Minimizing the full adder - where did this XOR come from?', 'LastEditDate': '2013-02-17T20:00:31.630', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6921', 'FavoriteCount': '1', 'Body': "<p>When minimizing the full adder, I don't understand why $A(\\bar{B}\\bar{C} + BC)$ reduces to $A\\overline{(B\\oplus{C})}.$</p>\n\n<p>$(\\bar{B}\\bar{C} + BC)\\to (B\\oplus{C})$ is partially decipherable, but why is $(B\\oplus{C})$ inverted to $\\overline{(B\\oplus{C})}?$</p>\n\n<hr>\n\n<p>Full adder simplification:</p>\n\n<p>$\n\\bar{A}\\bar{B}C + \\bar{A}B\\bar{C} + A\\bar{B}\\bar{C} + ABC \\\\\n= \\bar{A}(\\bar{B}C + B\\bar{C}) + A(\\bar{B}\\bar{C} + BC) \\\\\n= \\bar{A}(B\\oplus{C}) + A(\\overline{B\\oplus{C}}) \\\\\n= A\\oplus{(B\\oplus{C})}\n$</p>\n\n<hr>\n\n<h3>Could you help me out?</h3>\n\n<p>PS: I hope that this is the correct subforum of StackExchange to ask this (perhaps <em>Electrical Engineering</em> is the proper venue). I couldn't find appropriate tags on <em>either</em> site.</p>\n", 'Tags': '<binary-arithmetic><xor>', 'LastEditorUserId': '6921', 'LastActivityDate': '2013-02-17T20:11:58.480', 'CommentCount': '6', 'AcceptedAnswerId': '9869', 'CreationDate': '2013-02-17T19:43:33.377', 'Id': '9866'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<h2>Operator - Generalized Symmetric Difference</h2>\n\n<p>If you take binary xor and generalize it to other radices\nyou can do so by the absolute value of the difference of each\nelement in a radix vector.\nHowever this doesn\'t have the same properties as the binary\nsymmetric differene.\nThe reason is that in throwing away the "sign" of the difference\nwe are unable to reconstruct an operaand given the result and the other\nas we can in binary xor. So we lose the nice property</p>\n\n<p>ABA = B</p>\n\n<p>However we keep other nice properties like</p>\n\n<p>A0 = A</p>\n\n<p>AA = 0</p>\n\n<p>There is a way to maintain this property. However, as far as I can tell\nit involves emitting 3 vectors for any result. The first vector is the usual\nsymmetric difference, the other two vectors are binary vectors of equal length\nto the first that record the sign of the result, one such vector for each\norder of the operands, on being the binary complement of the other. In this way, an original operand can be recovered, given the result and the other opernad, AND that other operands "sign" vector.</p>\n\n<p>For example :</p>\n\n<p>Say we have 2 base 10 vectors corresponding to the numbers 1137 and 9284, what i\ns the xor of these two numbers in base 10?</p>\n\n<pre><code>        7  3  1  1              4  8  2  9\n\n\n        4  8  2  9              7  3  1  1\n\nSigned\nResult  3 -5 -1 -8             -3  5  1  8\n\nSign\nVector  0  1  1  1              1  0  0  0\n\nSymmetric\nDifference              3 5 1 8\n</code></pre>\n\n<p>Recover 1137 given 8153 and 9284</p>\n\n<pre><code>3  5  1  8\n+  -  -  -\n4  8  2  9\n\n7  3  1  1\n</code></pre>\n\n<p>My question is : is there a better construction of generalized symmetric difference in any radix > 2 such that we don\'t need to \'remember the sign\' ? </p>\n', 'ViewCount': '59', 'Title': 'How to construct this generalized xor without needing an extra vector?', 'LastActivityDate': '2013-02-20T13:14:33.073', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4602', 'Tags': '<discrete-mathematics><xor>', 'CreationDate': '2013-02-20T11:31:37.153', 'Id': '9964'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '48', 'Title': 'Odd Parity Function', 'LastEditDate': '2014-04-24T00:22:03.467', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16983', 'Body': "<p>I am trying to define a Odd Parity Function that takes three 1 bit inputs and will output a 1 if the 3 bits are odd as a Boolean function.</p>\n\n<pre><code>1 1 0 = 0\n1 0 0 = 1\n0 0 0 = 0\n1 1 1 = 1\n</code></pre>\n\n<p>I understand this has a relationship to XOR as I can define this with 2 parameter as </p>\n\n<pre><code>X xor Y = (XY')+(X'Y)\n</code></pre>\n\n<p>My assumption is the function will look like this</p>\n\n<pre><code>(X xor Y) xor Z = (((XY')+(X'Y))Z')+(((XY')+(X'Y))'Z)\n</code></pre>\n\n<p><strong>Can this function be simplifed?</strong></p>\n", 'ClosedDate': '2014-04-23T16:48:44.533', 'Tags': '<logic><boolean-algebra><xor>', 'LastEditorUserId': '16983', 'LastActivityDate': '2014-04-24T00:22:03.467', 'CommentCount': '5', 'AcceptedAnswerId': '24040', 'CreationDate': '2014-04-22T12:18:42.813', 'Id': '24025'}},