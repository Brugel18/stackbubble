384_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>$$ (\\neg A \\wedge \\neg C) \\vee (\\neg A \\wedge D) \\vee (\\neg A \\wedge B) \\vee (\\neg B \\wedge \\neg C) $$\ncan simplify down to\xa0\n$$ (\\neg A \\wedge D) \\vee (\\neg A \\wedge B) \\vee (\\neg B \\wedge \\neg C) $$\nI've computed the truth tables for the two expressions, and they're the same. But I'm supposed to prove it without using truth tables. What law(s) am I supposed to use?</p>\n", 'ViewCount': '71', 'Title': 'Laws to simplify a boolean formula', 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-08T12:22:48.427', 'LastEditDate': '2013-12-10T11:11:10.393', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11819', 'Tags': '<boolean-algebra>', 'CreationDate': '2013-12-05T00:54:50.923', 'Id': '18623'},384_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>A popcount order of a two bit vector {1,1}=3 can be given by:</p>\n\n<p>{{1, 1}, {1, 0, 1}, {1, 1, 0}, {1, 0, 0, 1}, {1, 0, 1, 0}, {1, 1, 0, 0}, {1, \u2028  0, 0, 0, 1}, {1, 0, 0, 1, 0}, {1, 0, 1, 0, 0}}</p>\n\n<p>and as a sequence of integers:</p>\n\n<p>{1, 2, 4, 8, 16, 32, 64, 128, 256}</p>\n\n<p>We are basically just shifting bits...</p>\n\n<p>A Mathematica code for it is:</p>\n\n<p>HammingCycle[x0_] := Module[\n  {x = x0, t = BitOr[x0, (x0 - 1)] + 1},\n  out = BitOr[t, BitShiftRight[BitAnd[t, -t]/BitAnd[x, -x], 1] - 1]\n  ]</p>\n\n<p>where the input is an integer, for example 3 in the above...\nThe sequence is a lexicographic order as well.\nIs it possible to get a function f(n) where I could get non-recursively a given value in the order? For example, f(5)=16...</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-02-16T18:13:46.110', 'Title': 'Popcount Orders and Lexicographic Orders', 'LastEditorUserId': '14685', 'LastActivityDate': '2014-02-15T02:28:21.357', 'LastEditDate': '2014-02-15T01:20:20.353', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14685', 'Tags': '<boolean-algebra>', 'CreationDate': '2014-02-15T01:11:44.743', 'Id': '21652'},384_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am currently studying model theory and I am trying to decide if a clause is a Horn Clause. I know that a Horn Clause is a clause with at most one positive literal, but there are some clauses that it is not easy to decide whether they are Horn or not.</p>\n\n<p>E.g.,</p>\n\n<pre><code>(P-&gt;Q)-&gt;W\n</code></pre>\n\n<p>Is there any way to decide whether this clause is Horn or not, or do I have to make further calculations in order to bring it to a Disjunction form?</p>\n', 'ViewCount': '29', 'Title': 'Recognizing Horn clauses', 'LastEditorUserId': '755', 'LastActivityDate': '2014-02-26T06:30:08.947', 'LastEditDate': '2014-02-26T06:30:08.947', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '21951', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13168', 'Tags': '<logic><artificial-intelligence><boolean-algebra>', 'CreationDate': '2014-02-23T14:25:18.280', 'Id': '21944'},384_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Reading this <a href="http://classes.soe.ucsc.edu/cmps102/Spring10/lect/17/SAT-3SAT-and-other-red.pdf" rel="nofollow">http://classes.soe.ucsc.edu/cmps102/Spring10/lect/17/SAT-3SAT-and-other-red.pdf</a>, I came to know that reducing a clause $C_i$ from a $SAT$ instance containing more than 3 literals to a $3-SAT$ instance is done this way,</p>\n\n<p>Suppose $C_1$ is $\\{x_1, x_2, x_3, x_4\\}$. It\'s equivalent representation in 3-literal clauses is,</p>\n\n<p>$C_{3-SAT} = \\{\\{x_1, x_2, y_1\\},\\{\\bar{y_1}, x_3,x_4\\}\\}$</p>\n\n<p>The issue lies here. Assume for $C_1$, all the literals are $False$ except for $x_2$.\nFor $C_{3-SAT}$, the first clause would indeed be $True$, but the boolean value for the second clause depends on the choice of $y_1$. What if we chose $y_1 = True$? then, $C_{3-SAT}$ will be $False$, yet $C_1$ is $True$, realizing a false reduction.</p>\n', 'ViewCount': '185', 'Title': 'Issue understanding the reduction of SAT to 3-SAT in poly time', 'LastActivityDate': '2014-02-26T13:45:34.337', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22053', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15072', 'Tags': '<algorithms><np-complete><satisfiability><3-sat><boolean-algebra>', 'CreationDate': '2014-02-26T13:28:05.573', 'FavoriteCount': '1', 'Id': '22052'},384_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $X_1,\\dots,X_n$ be $n$ boolean variables.  I have an unknown predicate $P(X_1,\\dots,X_n)$ on these boolean variables.  Of course, I can view the predicate as a function $f_P : \\{0,1\\}^n \\to \\{0,1\\}$ that maps a vector of $n$ boolean values to the truth value of this predicate on those inputs.</p>\n\n<p>Now I have a truth table of pairs $(x_1,y_1), \\dots, (x_m,y_m)$, and I want to find a predicate $P$ that is consistent with these pairs and that is as "simple" as possible.  In particular, I have two variants of the problem:</p>\n\n<p><strong>Problem 1.</strong> Given $(x_1,y_1), \\dots, (x_m,y_m)$, find a predicate $P$ such that (1) it agrees with the entire truth table (i.e., for all $i$, $f_P(x_i)=y_i$), and (2) out of all such predicates, the complexity of $P$ is minimized.</p>\n\n<p><strong>Problem 2.</strong> Given $(x_1,y_1), \\dots, (x_m,y_m)$ and a threshold $t$, find a predicate $P$ such that (1) $P$ agrees with at least a $t/m$ fraction of the truth table (i.e., there are at least $t$ values of $i$ such that $f_P(x_i)=y_i$), and (2) out of all such predicates, the complexity of $P$ is minimized.</p>\n\n<p>Are there any algorithms for solving either of these problems, in a way that is more efficient than enumerating all predicates?</p>\n\n<p>Of course, to make the problem well-posed, we must agree on a definition of the complexity of a predicate.  Here I can see any number of realistic complexity metrics.  One metric might be that, when we express $P$ as a formula in boolean logic, the length of that formula.  Another might be the number of operators in that formula, or the nesting depth of the formula.  I am interested in any and all algorithms for any plausible notion of complexity.</p>\n\n<p>This can be viewed as a kind of learning problem, where Occam\'s razor suggests that low-complexity predicates are a priori more likely than high-complexity predicates.</p>\n', 'ViewCount': '30', 'Title': 'Boolean formula that agrees with most truth assignments', 'LastActivityDate': '2014-02-28T03:52:00.653', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<optimization><logic><formal-methods><learning-theory><boolean-algebra>', 'CreationDate': '2014-02-28T03:52:00.653', 'FavoriteCount': '1', 'Id': '22122'},384_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Given Boolean variable Xij that represents whether dog i is kept in\n  kennel j.</p>\n  \n  <p>Encode in CNF clauses:</p>\n  \n  <p>Dogs that cannot be kept together must be kept in separate kennels</p>\n</blockquote>\n\n<p>Here is what I came up with, given m dogs and n kennels (I am new with notation):</p>\n\n<pre><code>(i through m) AND (r through m) AND (j through n)  (!Xij AND !Xrj)\n</code></pre>\n\n<p>What I'm trying to say <strong>at most one</strong> of those dogs that can't be together is in kennel j</p>\n\n<p>also, </p>\n\n<blockquote>\n  <p>Dogs that need be kept together must be kept in the same kennel</p>\n</blockquote>\n\n<pre><code>(i through m) AND (r through m) AND (j through n)  (Xij AND Xrj)\n</code></pre>\n\n<p>What I'm trying to say is that those dogs i and r have to be in same kennel j</p>\n\n<p>Do these satisfy for CNF clauses?</p>\n\n<p>Any help is really appreciated.</p>\n", 'ViewCount': '22', 'Title': 'Are these CNF clauses for at most one and the same correct?', 'LastActivityDate': '2014-04-06T19:59:02.637', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15116', 'Tags': '<logic><artificial-intelligence><first-order-logic><boolean-algebra>', 'CreationDate': '2014-04-06T19:59:02.637', 'FavoriteCount': '1', 'Id': '23483'},384_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '48', 'Title': 'Odd Parity Function', 'LastEditDate': '2014-04-24T00:22:03.467', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16983', 'Body': "<p>I am trying to define a Odd Parity Function that takes three 1 bit inputs and will output a 1 if the 3 bits are odd as a Boolean function.</p>\n\n<pre><code>1 1 0 = 0\n1 0 0 = 1\n0 0 0 = 0\n1 1 1 = 1\n</code></pre>\n\n<p>I understand this has a relationship to XOR as I can define this with 2 parameter as </p>\n\n<pre><code>X xor Y = (XY')+(X'Y)\n</code></pre>\n\n<p>My assumption is the function will look like this</p>\n\n<pre><code>(X xor Y) xor Z = (((XY')+(X'Y))Z')+(((XY')+(X'Y))'Z)\n</code></pre>\n\n<p><strong>Can this function be simplifed?</strong></p>\n", 'ClosedDate': '2014-04-23T16:48:44.533', 'Tags': '<logic><boolean-algebra><xor>', 'LastEditorUserId': '16983', 'LastActivityDate': '2014-04-24T00:22:03.467', 'CommentCount': '5', 'AcceptedAnswerId': '24040', 'CreationDate': '2014-04-22T12:18:42.813', 'Id': '24025'},384_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I just read "Boole\'s Algebra Isn\'t Boolean Algebra" by Theodore Halperin (behind a paywall <a href="http://link.springer.com/chapter/10.1007/978-94-015-9385-4_4#page-1" rel="nofollow">here</a>). I don\'t have a strong background in abstract algebra, so, frankly, the paper is a bit over my head but the gist of it is as follows: the algebra developed by Boole in the 19th century has some strange properties. Boole interprets every term in an expression as representing a set and restricts the domain of valid expressions on the basis of relationships between the underlying sets. In particular, he asserts that the expression $x + y$ is valid iff $x$ and $y$ represent disjoint sets, and $x - y$ is valid iff the intersection of $x$ and $y$ is nonempty. He also defines an operation $w = \\frac x y$ such that $w$ has many solutions. Halperin goes to great lengths to construct a commutative ring that satisfies Boole\'s constraints. </p>\n\n<p>I think that there might be a nice, intuitive, graph-theoretic interpretation of Boole\'s algebra where we can say something like "Given a complex expression in Boole\'s algebra, $\\Phi = \\{\\phi_1, \\phi_2\\, \\dots, \\phi_n\\}$, we can construct a (di)graph $G$ such that $\\Phi$ is valid if and only if $G$ has some property $P$." </p>\n\n<p>For example, to test if $X + Y$ is valid, we could do something like the following:</p>\n\n<p>Let $G$ be a graph. Let $V(G) = X \\cup Y \\cup \\{v_X, v_Y\\}$, i.e. make a vertex for every element of the underlying set, plus a vertex for each term in the expression. Then define </p>\n\n<p>$$E(G) = \\{uv_X \\mid u \\in X \\} \\cup \\{uv_Y \\mid u \\in Y \\}$$</p>\n\n<p>and let $\\partial(G)$ be the set of all valid bonds formed by subsets of $V(G)$. It follows that $X + Y$ is valid if and only if $|\\partial(G)| = 2$. </p>\n\n<p>From there, I\'m not sure how to go about forming graphs for complex expressions like $\\frac {y(x + z)} {z^2 + 1}$ by composing simpler graphs. I imagine that there is literature about representing Boolean algebra on graphs, but I haven\'t been able to find it. </p>\n\n<p>Does anyone have an elegant interpretation? Or a pointer to relevant literature that might get me started?</p>\n\n<p>EDIT: I can\'t find the article for free anywhere, but <a href="http://en.wikipedia.org/wiki/The_Laws_of_Thought" rel="nofollow">wikipedia</a> touches on the issues: </p>\n\n<blockquote>\n  <p>In places, Boole talks of terms being interpreted by sets, but he also\n  recognises terms that cannot always be so interpreted, such as the\n  term 2AB...Such terms he classes uninterpretable\n  terms...uninterpretable terms cannot be the ultimate result of\n  equational manipulations from meaningful starting formulae.</p>\n</blockquote>\n\n<p>Halperin\'s paper shows that his algebra is isomorphic to "a commutative ring with unit having no additive or multiplicative nilpotents." I think, for that reason, that it will require heavier machinery to represent than normal Boolean logic operations.</p>\n', 'ViewCount': '42', 'Title': "Finding a graph-theoretic representation of expressions in Boole's algebra", 'LastEditorUserId': '16612', 'LastActivityDate': '2014-04-25T19:14:45.803', 'LastEditDate': '2014-04-25T19:14:45.803', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16612', 'Tags': '<graph-theory><logic><boolean-algebra>', 'CreationDate': '2014-04-24T20:14:30.220', 'FavoriteCount': '1', 'Id': '24088'},384_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I don't understand how to solve this system of equations: <br>\n$$\n!(x_1 = x_2) * ((x_1\\ *\\ !x_3) + (!x_1\\ *\\ x_3)) = 0 \\\\\n!(x_2 = x_3) * ((x_2\\ *\\ !x_4) + (!x_2\\ *\\ x_4)) = 0 \\\\\n\\dots\\\\\n!(x_8 = x_9) * ((x_8\\ *\\ !x_{10}) + (!x_8\\ *\\ x_{10}) ) = 0\n$$\nQuestion: The response does not need to enumerate all the different sets of variables \n$x_1, x_2, \\dots x_{10}$ in which made \u200b\u200bthis system of equations.</p>\n\n<p>As Answer You need to specify the number of such sets.</p>\n", 'ViewCount': '25', 'ClosedDate': '2014-05-03T23:48:02.273', 'Title': 'Systems of equations in Boolean Algebra', 'LastEditorUserId': '13107', 'LastActivityDate': '2014-05-03T16:55:45.693', 'LastEditDate': '2014-05-03T16:54:27.787', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17297', 'Tags': '<boolean-algebra>', 'CreationDate': '2014-05-03T08:55:57.440', 'Id': '24351'}