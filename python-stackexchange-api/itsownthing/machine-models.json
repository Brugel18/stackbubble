{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>When reporting algorithmic complexity of an algorithm, one assumes the underlying computations are performed on some abstract machine (e.g. RAM) that approximates a modern CPU. Such models allow us to report time and space complexity of algorithms. Now, with the spread out of <a href="http://en.wikipedia.org/wiki/GPGPU">GPGPUs</a>, one wonders whether there are well known models where one can take into account power consumption as well.</p>\n\n<p>GPUs are well known to consume considerable amount of power and certain instructions fall into different categories of power consumption based on their complexity and location on the sophisticated chip. Hence instructions, from an energy of view, are not of unit (or even fixed) cost. A trivial extension would be assigning weights to operation cost, but I\'m looking for a powerful model where an operation/instruction might cost <em>non-constant</em> units of energy, e.g. polynomial amount (or even more complex e.g.: function of time elapsed since start of the algorithm; or taking into account probability of failure of cooling system, which will heat up the chips, and slow down the clock frequency etc.)</p>\n\n<p>Are there such models where non-trivial costs and faults can be incorporated?</p>\n', 'ViewCount': '144', 'Title': 'Is there an abstract machine that can capture power consumption?', 'LastEditorUserId': '48', 'LastActivityDate': '2012-03-26T15:00:28.613', 'LastEditDate': '2012-03-13T02:52:43.603', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '281', 'Score': '9', 'OwnerDisplayName': 'user20', 'PostTypeId': '1', 'Tags': '<complexity-theory><computer-architecture><power-consumption><machine-models>', 'CreationDate': '2012-03-13T00:48:16.690', 'Id': '271'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>The question is exercise 1.9 from Arora-Barak's book <em>Computational Complexity \u2014 A Modern Approach</em>:</p>\n\n<hr>\n\n<p>Define a RAM Turing machine to be a Turing machine that has random access memory. We formalize this as follows: The machine has an infinite array A that is initialized to all blanks. It accesses this array as follows. One of the machine's work tapes is designated as the address tape. Also the machine has two special alphabet symbols denoted by R and W and an additional state we denote by q_access. Whenever the machine enters q_access, if its address tape contains 'i'R (where 'i' denotes the binary representation of i) then the value A[i] is written in the cell next to the R symbol. If its tape contains 'i'Wa (where a is some symbol in the machine's alphabet) then A[i] is set to the value a.</p>\n\n<p>Show that if a Boolean function $f$ is computable within time $T(n)$ (for some time constructible $T$) by a RAM TM, then is is in $\\mathrm{DTIME}(T(n)^2)$.</p>\n\n<hr>\n\n<p>The trivial solution by using an additional tape recording pairs (address,value) turns out to be in $\\mathrm{DTIME}(T(n)^3)$, since that tape can be of size $O(T(n)^2)$ with $O(T(n))$ pairs while the address of each pair can be of size $O(T(n))$.</p>\n", 'ViewCount': '225', 'Title': 'Prove that a boolean function computable in T(n) by a RAM machine is in DTIME(T(n)^2)', 'LastEditorUserId': '41', 'LastActivityDate': '2012-09-16T14:05:18.777', 'LastEditDate': '2012-08-17T14:04:18.113', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2121', 'Tags': '<complexity-theory><turing-machines><machine-models><simulation>', 'CreationDate': '2012-07-10T08:35:08.447', 'FavoriteCount': '1', 'Id': '2666'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Let $f$ be a fixed time-constructable function.</p>\n\n<p>The classical universal simulation result for TMs (Hennie and Stearns, 1966) states that there is a two-tape TM $U$ such that given</p>\n\n<ul>\n<li>the description of a TM $\\langle M \\rangle$, and</li>\n<li>an input string $x$,</li>\n</ul>\n\n<p>runs for $g(|x|)$ steps and returns $M$'s answer on $x$. And $g$ can be taken to be any function in $\\omega(f(n)\\lg f(n))$.</p>\n\n<p>My questions are:</p>\n\n<blockquote>\n  <ol>\n  <li><p>What is the best known simulation result on a single tape TM? Does the result above also still hold?</p></li>\n  <li><p>Is there any improvement on [HS66]? Can we simulate TMs on a two-tape TM for $f(n)$ steps in a faster way? \n  Can we take $g(n)$ to be in $\\omega(f(n))$ in place of $\\omega(f(n)\\lg f(n))$?</p></li>\n  </ol>\n</blockquote>\n", 'ViewCount': '278', 'Title': 'Universal simulation of Turing machines', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-16T13:15:01.727', 'LastEditDate': '2012-08-16T11:33:15.097', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '3220', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '41', 'Tags': '<complexity-theory><reference-request><turing-machines><machine-models><simulation>', 'CreationDate': '2012-07-23T15:49:05.823', 'Id': '2878'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '389', 'Title': 'How to show two models of computation are equivalent?', 'LastEditDate': '2012-08-13T22:04:59.613', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2499', 'FavoriteCount': '1', 'Body': "<p>I'm seeking explanation on how one could prove that two models of computation are equivalent. I have been reading books on the subject except that equivalence proofs are omitted. I have a basic idea about what it means for two models of computation to be equivalent (the automata view: if they accept the same languages). Are there other ways of thinking about equivalence? If you could help me understand how to prove that the Turing-machine model is equivalent to lambda calculus, that would be sufficient.</p>\n", 'Tags': '<computability><turing-machines><lambda-calculus><computation-models><machine-models>', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-21T22:54:00.330', 'CommentCount': '5', 'AcceptedAnswerId': '3162', 'CreationDate': '2012-08-13T21:03:50.690', 'Id': '3154'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have a question and I haven't been able to figure out the answer yet. I need to do the on-line simulation of a two-head tape Turing machine using single-head tape(s). I've found some online articles for the fact that one single-head tape doesn't suffice for this problem and the simulation should be done using two single-head tapes, but I haven't been able to present an accurate simulation of two-head TM using these single-head tapes. Are there any thoughts on how to do so? Thanks,</p>\n", 'ViewCount': '198', 'Title': 'On-line simulation of a two-head tape Turing machine using single-head tape(s)', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T00:40:34.167', 'LastEditDate': '2012-09-13T06:43:33.710', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'Parsa Rastegari', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models><simulation>', 'CreationDate': '2012-09-13T00:29:00.457', 'Id': '3526'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I saw a RAM model diagram that displayed an input tape, output tape, the program (read-only), the instruction pointer, and the memory registers. However, when I look at questions of time complexity, it is relevant how much time the program needs to spend on one action. Say you want to read one integer symbol from the read tape, add it to an integer from a memory register, and then squish the result into the write tape cell, and then move the read head one to the right and the write head one to the left. How much time or how many moves did I just waste?</p>\n', 'ViewCount': '82', 'Title': 'What constitutes one operation/cycle/move in the RAM model?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-16T21:23:57.300', 'LastEditDate': '2012-09-15T13:06:08.960', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '4574', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2835', 'Tags': '<algorithms><time-complexity><algorithm-analysis><machine-models>', 'CreationDate': '2012-09-15T04:38:07.633', 'Id': '3557'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '527', 'Title': 'What piece am I missing to turn this idea into a programming language?', 'LastEditDate': '2013-07-20T09:50:34.237', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2161', 'FavoriteCount': '2', 'Body': '<p>I\'ve been doing some reading (I\'ll name drop along the way) and have selected a few scattered ideas that I think could be cobbled together into a nifty esoteric programming language. But I\'m having some difficulty assembling the parts.</p>\n\n<p>Kleene\'s Theorem states: Any Regular Set can be recognized by some Finite-State Machine (Minsky 4.3).</p>\n\n<p>Minsky\'s Theorem 3.5: Every Finite-State machine is equivalent to, and can be "simulated by", some neural net.</p>\n\n<p>"There is a natural way to represent any forest as a binary tree." (Knuth, v1, 333).</p>\n\n<p>And according to Bentley (Programming Pearls, p.126) a binary tree can be encoded as a flat array.</p>\n\n<p>So I\'m imagining an array of bit-fields (say 4 bits so it can easily be worked with in hexadecimal). Each field indicates a type of automaton, and the positions of the array encode (via an intermediary binary tree representation) a forest which approximates (? missing piece ?) the power of a graph.</p>\n\n<p>I\'m somewhat bewildered by the possibilities of automaton sets to try, and of course the fun Universal Automata require three inputs (I worked up an algorithm inspired by Bentley to encode a ternary tree implicitly in a flat array, but it feels like the wrong direction). So I\'d appreciate any side-bar guidance on that. Current best idea: the normal set: and or xor not nand nor, with remaining bits used for threshold weights on the inputs.</p>\n\n<p>So the big piece I\'m missing is a formalism for applying one of these nibble-strings to a datum. Any ideas or related research I should look into?</p>\n\n<hr>\n\n<p><em>Edit:</em> My theoretical support suggests that the type of computations will probably be limited to RL acceptors (and maybe generators, but I haven\'t thought that through).</p>\n\n<p>So, I tried to find an example to flesh this out. The C <code>int isdigit(int c)</code> function performs a logical computation on (in effect) a bit-string. Assuming ASCII, where the valid digits are <code>0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39</code>, so bit 7 must be off, bit 6 must be off, bit 5 must be on, and bit 4 must be on: these giving us the 0x30 prefix; then bit 3 must be off (0-7) or if bit 3 is on, bit 2 must be off and bit 1 must be off (suppressing A-F), and don\'t care about bit 0 (allowing 8 and 9). If you represent the input <em>c</em> as a bit-array (<code>c[0]</code>..<code>c[7]</code>), this becomes</p>\n\n<pre><code>~c[7] &amp; (~c[6] &amp; (c[5] &amp; (c[4] &amp; (~c[3] | (~c[2] &amp; ~c[1])))))\n</code></pre>\n\n<p>Arranging the operators into a tree (colon (:) represents a wire since pipe (|) is logical or),</p>\n\n<pre><code>c[7]  6   5   4   3   2   1   0\n ~    ~   :   :   ~   ~   ~   :\n    &amp;     :   :   :     &amp;\n       &amp;      :      |\n           &amp;        :  \n                &amp;\n</code></pre>\n\n<p>My thought based on this is to insert "input lead" tokens into the tree which receive the values of the input bit assigned in a left-to-right manner. And I also need a <em>ground</em> or <em>sink</em> to explicitly ignore certain inputs (like c[0] above).</p>\n\n<p>This leads me to make NOT (~) a binary operator which negates the left input and simply absorbs right input. And in the course of trying this, I also realized the necessity for a ZERO token to build masks (and to provide dummy input for NOTs).</p>\n\n<p>So the new set is: &amp;(and) |(or) ^(xor) ~(not x, sink y) 0(zero) I(input)</p>\n\n<p>So the tree becomes (flipping up for down)</p>\n\n<pre><code>                 ^\n           &amp;           &amp;\n       &amp;       |      I 0\n     &amp;   I  ~     &amp;\n   &amp;   I   I 0  ~   ~\n ~   ~         I 0 I 0\nI 0 I 0\n=   =  = = =   =   =  =\n7   6  5 4 3   2   1  0 \n</code></pre>\n\n<p>Which encodes into the array (skipping the "forest&lt;=>tree" part, "_" represents a blank)</p>\n\n<pre><code>_ ^ &amp; &amp; &amp; | I 0 &amp; I ~ &amp; _ _ _ _ &amp; I _ _ I 0 ~ ~ _\n  _ _ _ _ _ _ _ ~ ~ _ _ _ _ _ _ _ _ _ _ I 0 I 0 _\n  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ I 0 I 0 \n</code></pre>\n\n<p>The tree->array encoding always put the root in array(1) so with zero-indexed array, there\'s a convenient blank at the beginning that could be used for linkage, I think.</p>\n\n<p>With only 6 operators, I suppose it could be encoded in octal.</p>\n\n<p>By packing a forest of trees, we could represent a chain of acceptors each applied on the next input depending on the result of the previous.</p>\n', 'Tags': '<programming-languages><finite-automata><arrays><neural-networks><machine-models>', 'LastEditorUserId': '2161', 'LastActivityDate': '2013-11-29T03:20:30.750', 'CommentCount': '6', 'AcceptedAnswerId': '4623', 'CreationDate': '2012-09-19T19:58:45.397', 'Id': '4618'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>What differences and relationships are between randomized algorithms and nondeterministic algorithms?</p>\n\n<p>From Wikipedia</p>\n\n<blockquote>\n  <p>A <strong>randomized algorithm</strong> is an algorithm which employs a degree of\n  randomness as part of its logic. The algorithm typically uses\n  uniformly random bits as an auxiliary input to guide its behavior, in\n  the hope of achieving good performance in the "average case" over all\n  possible choices of random bits. Formally, the algorithm\'s performance\n  will be a random variable determined by the random bits; thus either\n  the running time, or the output (or both) are random variables.</p>\n  \n  <p>a <strong>nondeterministic algorithm</strong> is an algorithm that can exhibit\n  different behaviors on different runs, as opposed to a deterministic\n  algorithm. There are several ways an algorithm may behave differently\n  from run to run. A <strong>concurrent algorithm</strong> can perform differently on\n  different runs due to a race condition. A <strong>probabalistic algorithm</strong>\'s\n  behaviors depends on a random number generator. An algorithm that\n  solves a problem in nondeterministic polynomial time can run in\n  polynomial time or exponential time depending on the choices it makes\n  during execution.</p>\n</blockquote>\n\n<p>Are randomized algorithms and probablistic algorithms the same concept? </p>\n\n<p>If yes, so are randomized algorithms just a kind of nondeterministic algorithms?</p>\n', 'ViewCount': '1555', 'Title': 'Differences and relationships between randomized and nondeterministic algorithms?', 'LastEditorUserId': '31', 'LastActivityDate': '2014-02-02T18:42:47.173', 'LastEditDate': '2014-01-23T10:11:12.273', 'AnswerCount': '4', 'CommentCount': '7', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '336', 'Tags': '<algorithms><terminology><randomized-algorithms><machine-models><nondeterminism>', 'CreationDate': '2012-10-11T05:19:33.520', 'FavoriteCount': '5', 'Id': '5008'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '172', 'Title': 'Classfication of randomized algorithms', 'LastEditDate': '2012-10-22T00:56:03.857', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '336', 'FavoriteCount': '3', 'Body': '<p>From <a href="http://en.wikipedia.org/wiki/Randomized_algorithm">Wikipedia</a> about randomized algorithms</p>\n\n<blockquote>\n  <p>One has to distinguish between <strong>algorithms</strong> that use the random\n  input to reduce the expected running time or memory usage, but always\n  terminate with a correct result in a bounded amount of time, and\n  <strong>probabilistic algorithms</strong>, which, depending on the random input, have a chance of producing an incorrect result (Monte Carlo\n  algorithms) or fail to produce a result (Las Vegas algorithms) either\n  by signalling a failure or failing to terminate.</p>\n</blockquote>\n\n<ol>\n<li>I was wondering how the first kind of "<strong>algorithms</strong> use the random\ninput to reduce the expected running time or memory usage, but\nalways  terminate with a correct result in a bounded amount of time?</li>\n<li>What differences are between it and Las Vegas algorithms which may\nfail to produce a result?</li>\n<li>If I understand correctly,  probabilistic algorithms and randomized algorithms are not the same concept. Probabilistic algorithms are just one\nkind of randomized algorithms, and the other kind is those use the\nrandom  input to reduce the expected running time or memory usage,\nbut always  terminate with a correct result in a bounded amount of\ntime?</li>\n</ol>\n', 'Tags': '<algorithms><terminology><randomized-algorithms><nondeterminism><machine-models>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-04-07T14:10:29.767', 'CommentCount': '0', 'AcceptedAnswerId': '6222', 'CreationDate': '2012-10-22T00:53:00.617', 'Id': '6221'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>How can one show that a machine with a three dimensional memory arranged in an infinite grid can be simulated by a single-tape Turing machine? I'd imagine there's some sort of mapping possible from three dimensional coordinates to single coordinates (eg. (0,0,0) -> 0, (1,0,0) -> 1, (-1,0,0) -> 2, ...) but I can't figure it out. Or maybe there's some clever way to separate the points using special symbols. Either way, I'm at a loss.</p>\n", 'ViewCount': '151', 'Title': 'Robustness of Turing Machines - 3 dimensional case', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-03T16:59:08.593', 'LastEditDate': '2012-11-03T05:45:57.907', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'OwnerDisplayName': 'Sebastian', 'PostTypeId': '1', 'Tags': '<turing-machines><simulation><machine-models>', 'CreationDate': '2012-11-02T00:06:38.447', 'Id': '6454'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '209', 'Title': 'Mathematical model on which current computers are built', 'LastEditDate': '2012-11-07T10:38:26.373', 'AnswerCount': '2', 'Score': '6', 'OwnerDisplayName': 'user5507', 'PostTypeId': '1', 'OwnerUserId': '947', 'Body': '<p>It is said that "The Turing machine is not intended as practical computing technology, but rather as a hypothetical device representing a computing machine. Turing machines help computer scientists understand the limits of mechanical computation." [Wikipedia]</p>\n\n<p>So on which model current machines are built?</p>\n', 'Tags': '<turing-machines><computer-architecture><machine-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-08T00:47:15.140', 'CommentCount': '0', 'AcceptedAnswerId': '6530', 'CreationDate': '2012-11-07T01:50:09.030', 'Id': '6528'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to figure out how a pushdown automata (PDA), which we know uses a stack (LIFO) can be simulated by a queue (FIFO). I understand that in a regular PDA, we only have access to the top most element which can be popped. When we push something, it goes to the top of the stack. </p>\n\n<p>In a queue, as I understand, elements get "pushed" to the top, but pop from the bottom. Thus, first in first out. </p>\n\n<p>In a stack (LIFO) PDA, let\'s say we push \'a\'. It\'s at the top of the stack, and when we pop, we pop \'a\' since it is at the top. </p>\n\n<p>In a queue (FIFO) PDA, when we push \'a\', it is at the top, but when we pop, it will be from the bottom of the queue and thus it will not be \'a\' (assuming the size is greater than 2).</p>\n\n<p>So how can we simulate a regular PDA which uses a stack, with a FIFO (queue) PDA?</p>\n', 'ViewCount': '401', 'Title': 'How can one simulate a PDA with a FIFO queue PDA?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-29T16:46:40.480', 'LastEditDate': '2012-11-29T16:46:40.480', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '7004', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4767', 'Tags': '<automata><pushdown-automata><machine-models>', 'CreationDate': '2012-11-29T00:21:40.543', 'Id': '7003'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>If we limit a turing machine so that it is not allowed to write the symbol that it reads would it reduce its power?</p>\n\n<p>For example: $( State, A, State, Z, DIRECTION)$</p>\n\n<p>$A$ cannot be the same symbol as $Z$.  </p>\n', 'ViewCount': '188', 'Title': 'Does forcing TMs to change all symbols they read change their power?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-11T22:41:56.343', 'LastEditDate': '2012-12-04T23:16:30.893', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7164', 'Score': '7', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<computability><turing-machines><machine-models>', 'CreationDate': '2012-12-04T20:48:56.857', 'Id': '7162'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was reading about Universal Turing Machines.</p>\n\n<p>I see that the matching lemma states, that between two symbols X and Y, if there are only 1-s and blanks, then a TM exists, which can count the number of ones.</p>\n\n<p>This is used to match strings of ones between two tapes.</p>\n\n<p>Now I wonder, would there also be a TM or a method of implementation of a TM which can match two strings? To me it intuitively appears, that inifinitely many symbols implies infinitely many states for the machine, and an example workflow may look like:\nfound symbol X, enter state stateX, exit stateX to state readnextchar if again X was found on the second tape.</p>\n\n<p>Would that not mean an infinitely long transition table? or is there an way to represent a table in a smaller way? </p>\n\n<p>if the symbols are represented via some kind of place value system, e.g. decimal, binary, would that shorten the transition table length?</p>\n', 'ViewCount': '61', 'Title': 'Matching Lemma with infinitely many symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-20T11:05:17.633', 'LastEditDate': '2013-03-20T10:56:13.753', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10642', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5203', 'Tags': '<turing-machines><machine-models>', 'CreationDate': '2013-03-19T22:41:09.000', 'Id': '10627'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Can a two-stack PDA accept language $L=\\{a^nb^mc^nd^m \\mid n \\geq m\\}$, which has no context-free grammar?</p>\n\n<p>I don't believe this has a context-free grammar, but please correct me if I'm wrong.</p>\n", 'ViewCount': '397', 'Title': 'Can a two-stack PDA accept language $a^nb^mc^nd^m$ which is not context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:15:49.030', 'LastEditDate': '2013-04-02T07:15:49.030', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '10894', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><automata><machine-models>', 'CreationDate': '2013-03-29T13:13:58.140', 'Id': '10892'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I\'ve been reading about hypercube connection template for parallel algorithms. The general scheme is explained in <a href="http://www.mcs.anl.gov/~itf/dbpp/text/node124.html#SECTION04310000000000000000" rel="nofollow"><em>Designing and Building Parallel Programs</em> by Ian Foster</a> and it\'s pretty clear.</p>\n\n<p>What I don\'t understand is how it\'s applied on the merge sort <a href="http://www.mcs.anl.gov/~itf/dbpp/text/node127.html" rel="nofollow">in \xa711.4</a> The point I\'m most interested is the <code>parallel_merge</code> function in the pseudocode, i.e. parallel merge algorithm.</p>\n\n<p>The point I\'m most interested is the <code>parallel_merge</code> function in the pseudocode, i.e. parallel merge algorithm.</p>\n\n<pre><code>procedure parallel_mergesort(myid, d, data, newdata)\nbegin\n  data = sequential_mergesort(data)\n  for dim = 1 to d\n    data = parallel_merge(myid, dim, data)\n  endfor\n  newdata = data\nend\n</code></pre>\n\n<p>Please, explain to me step by step, assuming we have an array of twelve elements $(3,1,5,7,4,2,8,9,4,2,7,5)$ and we\'ve broken this data to four processors like this: </p>\n\n<p>$\\qquad ((3,1,5),(7,4,2),(8,9,4),(2,7,5))$. </p>\n\n<p>What data will have each process after each iteration? I understand why we use the hybercube template in this algorithm, but why do we have exactly $i$ compare-exchanges at the $i$-th level? I mean, when $i=1$, we compare-exchange data from processes $1-2, 3-4, .. P-1, P$. That\'s not $1$, that\'s $P/2$? Do I misunderstand something?</p>\n', 'ViewCount': '282', 'Title': 'Parallel merge sort using hypercube connection template', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T20:43:03.117', 'LastEditDate': '2013-04-10T20:43:03.117', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'OwnerDisplayName': u'\u0418\u0433\u043e\u0440\u044c \u041c\u043e\u0440\u043e\u0437\u043e\u0432', 'PostTypeId': '1', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><parallel-computing><machine-models>', 'CreationDate': '2013-04-10T18:14:08.597', 'Id': '11205'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '144', 'Title': 'Which theoretical parallel model is closest to CUDA?', 'LastEditDate': '2013-11-19T12:33:52.610', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '7617', 'FavoriteCount': '1', 'Body': '<p>Which theoretical parallel model is closest to CUDA/OpenCL programming model?</p>\n\n<p>For example, it fits at some degree to the generic Parallel Random Access Machine (PRAM) model. However, that is too generic, since it makes abstraction of various memory access latencies and synchronization issues.</p>\n\n<p>My question is which is the theoretical model that CUDA architecture fits closest (having in mind the hierarchical parallelism of threads and blocks of threads that cooperate)?</p>\n', 'Tags': '<parallel-computing><machine-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-19T12:33:52.610', 'CommentCount': '0', 'AcceptedAnswerId': '11806', 'CreationDate': '2013-05-05T13:21:27.837', 'Id': '11805'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given a PDA $P=(Q,\\sum,\\delta,q_0,F)$ construct formally a TM that accepts $L(P)$.</p>\n\n<p>My idea is to construct a Turing machine with 2 tapes, one for the input and the other for the stack. Also to add $q_a$ for accept and $q_r$ for reject and to send to $q_a$ if the TM stops on states in $F$ and send to $q_r$ otherwise.</p>\n\n<p>But I am having a trouble to define new the transition function for the TM: $\\delta_M$.</p>\n', 'ViewCount': '114', 'Title': 'construct a TM from a PDA', 'LastActivityDate': '2013-05-25T05:27:49.823', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12264', 'Score': '0', 'OwnerDisplayName': 'David', 'PostTypeId': '1', 'OwnerUserId': '15890', 'Tags': '<machine-learning><turing-machines><machine-models>', 'CreationDate': '2013-05-24T12:13:01.970', 'Id': '12263'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm not sure if one can compare the two, mainly because what I've read so far, I didn't quite understand, but what are the key differences between these 2 engines?</p>\n", 'ViewCount': '80', 'Title': 'Difference between Analytical and Difference Engines', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:41:29.027', 'LastEditDate': '2013-06-10T09:41:29.027', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'Eduard Luca', 'PostTypeId': '1', 'Tags': '<terminology><history><machine-models>', 'CreationDate': '2013-05-27T03:18:39.130', 'FavoriteCount': '1', 'Id': '12552'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>If Turing Machines are the automata equivalent of the $\\lambda$ calculus, what is the automaton equivalent of the $\\pi$ calculus? I suppose it would be some class of automata that resembled a Turing Machine, but with support for communication channels or signals of some type, but I'm not sure, and would appreciate some direction.</p>\n", 'ViewCount': '153', 'Title': u'Automaton equivalent of the \u03c0 calculus?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-27T21:21:29.893', 'LastEditDate': '2013-09-17T17:40:08.220', 'AnswerCount': '2', 'CommentCount': '11', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<automata><concurrency><machine-models><pi-calculus>', 'CreationDate': '2013-07-05T02:12:24.763', 'FavoriteCount': '3', 'Id': '13091'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '94', 'Title': 'Which computational model is used to analyse the runtime of matrix multiplication algorithms?', 'LastEditDate': '2014-02-03T11:42:45.030', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2091', 'FavoriteCount': '1', 'Body': '<p>Although I have already learned something about the asymptotic runtimes of matrix multiplication algorithms (Strassen\'s algorithm and similar things), I have never found any explicit and satisfactory reference to a model of computation, which is used to measure this complexity. In fact, I have found three possible answers, neither of which seems to me as absolutely satisfactory:</p>\n\n<ul>\n<li><a href="http://en.wikipedia.org/wiki/Computational_complexity_of_mathematical_operations" rel="nofollow">Wikipedia</a> says that the model used here is the Multitape Turing Machine. This does not seem to make much sense to me, since in the analysis of matrix multiplication, scalar multiplication is supposed to have a constant time complexity. This is not the case on Turing Machines.</li>\n<li>Some texts describe the complexity only vaguely as the number of arithmetic operations used. However, what <em>exactly</em> are arithmetic operations in this context? I suppose that addition, multiplication, and probably subtraction. But what about division, integer division, remainder, etc.? And what about bitwise operations - how do they fit into this setting?</li>\n<li>Finally, I have recently discovered an article, which uses the <a href="http://en.wikipedia.org/wiki/Blum%E2%80%93Shub%E2%80%93Smale_machine" rel="nofollow">BSS machine</a> as the model of computation. However, this also seems little bit strange to me, since for, e.g., integer matrices, it does not make much sense to me to disallow operations such as, e.g., integer division.</li>\n</ul>\n\n<p>I would be grateful to anyone, who could help me to sort these things out.</p>\n', 'Tags': '<algorithm-analysis><runtime-analysis><matrices><machine-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T15:33:24.143', 'CommentCount': '7', 'AcceptedAnswerId': '20255', 'CreationDate': '2014-02-03T08:48:07.433', 'Id': '20245'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>For instance, the tape on a Turing machine is infinite, where as we usually only have a finite amount of available memory.  Secondly Turing machines are not really convenient IMHO for proving things about everyday algorithms on an everyday computer.</p>\n\n<p>I want a model that makes computations in a ring, namely $\\Bbb{Z}_p\\times \\dots \\times \\Bbb{Z}_p = (\\Bbb{Z}_p)^k$, where $p$ is prime (for a good reason... later on that).  Since that's what bytes on a computer look like they look like values in $\\Bbb{Z}_8$ and even some of the instructions on those bytes on modern computers cause wrap around that looks like that of $\\Bbb{Z}_8$.  It's obvious to me that any computation on my home PC can be done with computations in said ring.  But of course I'd have to prove that formally if I wrote a paper.  I can already write conditional assignments of a memory slot (element of $\\Bbb{Z}_p$), as the value of a polynomial in $\\Bbb{Z}_p[x_1, \\dots, x_k]$.</p>\n\n<p>It's hard to find literature on this, but to me it seems so obvious that this is a nice approach and I'm shocked that no one's considered this yet.  Or have they?  Links please...</p>\n", 'ViewCount': '247', 'ClosedDate': '2014-04-16T17:11:48.760', 'Title': 'Is there a model of computation, that tries to be realistic?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-16T12:18:13.993', 'LastEditDate': '2014-04-16T12:18:13.993', 'AnswerCount': '1', 'CommentCount': '11', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12373', 'Tags': '<reference-request><machine-models>', 'CreationDate': '2014-04-16T01:23:50.533', 'Id': '23840'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '123', 'Title': 'Can a Multi-Tape Turing Machine have an infinite number of tapes?', 'LastEditDate': '2014-04-23T05:59:30.583', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16915', 'FavoriteCount': '1', 'Body': u"<p>So if k is the number of tapes, is a multi-tape Turing machine allowed to have k = \u221e tapes.</p>\n\n<p>I'd assume not since this would give an infinite transition function?</p>\n", 'Tags': '<turing-machines><machine-models>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-23T05:59:30.583', 'CommentCount': '2', 'AcceptedAnswerId': '23948', 'CreationDate': '2014-04-19T17:43:23.410', 'Id': '23936'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I recently discussed with a friend about a website that proposed regex challenges, mainly matching a group a of words with a special property. He was looking for a regex that matches strings like <code>||||||||</code> where the number of <code>|</code> is prime. I immediatly told him that won\'t ever work because if such a language was regular, the translation of pumping lemma would gives the fact that for a prime $p$ large enough, it exists $k \\leq p$ such that $p + nk$ is prime for all $n \\geq -1$, and well this is not likely to be the case at all (repartition of primes, triviality of such an unknown and crushing property, ...)</p>\n\n<p>But then someone came with the solution : NOT MATCHING <code>(||+?)\\1+</code>\nThis expression tries to match the capture group (that can be <code>||</code>,<code>|||</code>,<code>||||</code> and so on of $k \\geq 2$ occurences of <code>|</code>) $n \\geq 2$ times. If it matches, it means that the number represented by the string is divisible by $k$, and hence is not prime. Otherwise, it is.</p>\n\n<p>And I felt stupid, because it became obvious that grouping and backreference allows regex to be actually a lot more expressive than...regular expression, in the theoritical sense. Now they even added lookarounds and other operators I didn\'t know about when I used to do real regex.</p>\n\n<p>According to Wikipedia, it is even more expressive that languages generated by a context-free grammar. So here is my question :</p>\n\n<ul>\n<li>can we represent any algebraic language (generated from a context-free grammar) with modern regular expression engines </li>\n<li>is there a more general description, or at least an upper bound on the complexity of what kind of languages can be described by a modern regex ?</li>\n</ul>\n\n<p>More pragmatically, is there any serious theory behind it or are we just adding any new features as it comes each time it seems implementable to the initial block of real regular expressions based on finite automata ?</p>\n\n<p>I know that "modern regex" isn\'t very specific while the question is, but I mean at least with backreferences, and possibly more. Of course, if you have partial anwsers assuming certain restrictions on this "modern regex" language, feel free to post it.</p>\n', 'ViewCount': '62', 'Title': 'Expressiveness of modern regular expressions', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-04-22T18:30:26.273', 'LastEditDate': '2014-04-22T18:30:26.273', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '16992', 'Tags': '<formal-languages><machine-models>', 'CreationDate': '2014-04-22T15:48:24.010', 'Id': '24031'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>You have a Turing machine that only processes input on the form $0^*$. If it is given an input without 0's, it will simply halt without accepting or do anything else. Is it Turing Complete?</p>\n\n<p>The set $0^*$ is countably infinite, since you can make the bijective function $f(x) : 0^* \u2192 \\mathbb{N} $:</p>\n\n<p>$f(x) = length(x)$</p>\n\n<p>Where $length(x)$ is the length of the string (so you treat them as Peano Numbers). </p>\n\n<p>I understand that the set of all programs (the programs that a Turing machine can run) are countable, and that the set of a Turing machines are also countable. But, can the set of string that the Turing machine can process (with no guarantees of halting) only be countably infinite (as in this case), or does it have to be uncountable? </p>\n\n<p>My understanding of undecidable problems with regards to Turing machines is that they arise because there are languages that have a cardinality strictly greater than the natural numbers, e.g. $B^*$, where $B = \\{0,1\\}$, which has a cardinality equal to the real numbers. It seems to me that, although you can encode any integer with the language $0^*$, you can't encode an arbitrary language. The problem is: how can you encode recursively enumerable languages when all you have is unary notation? If this is indeed impossible (though I have a feeling it is possible; I can't see how the representation of numbers should be a fundamental hindrance), then it turns out that this particular Turing machine is <em>not</em> Turing Complete (or maybe you would say that it is not really a Turing machine). </p>\n", 'ViewCount': '71', 'Title': 'Is a Turing Machine that only takes strings of the form $0^*$ Turing Complete?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-26T16:01:25.943', 'LastEditDate': '2014-04-26T16:01:25.943', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24128', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11089', 'Tags': '<turing-machines><turing-completeness><machine-models>', 'CreationDate': '2014-04-26T11:11:45.313', 'Id': '24125'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was studying the proof of Ackermann function being recursive, but not primitive recursive, and a question hit me: "So what?". Why does it matter? What is the significance of primitive recursive functions?</p>\n', 'ViewCount': '97', 'Title': 'What is the significance of primitive recursive functions?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-27T21:35:16.937', 'LastEditDate': '2014-04-27T19:41:56.967', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '24154', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7410', 'Tags': '<terminology><computability><machine-models>', 'CreationDate': '2014-04-27T15:59:40.287', 'Id': '24152'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '46', 'Title': 'Coq --- non-terminating programs', 'LastEditDate': '2014-05-02T21:29:44.843', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8508', 'FavoriteCount': '1', 'Body': "<p>People usually say Coq does not allow writing non-terminating functions. I have a question regarding that.</p>\n\n<p>Does Coq allow writing exactly <strong>all</strong> terminating functions? In other words, what are the completeness and soundness properties of Coq's procedure for checking well-foundness of fixpoint definitions?</p>\n", 'ClosedDate': '2014-05-02T21:31:13.660', 'Tags': '<machine-models><coq>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T21:29:44.843', 'CommentCount': '1', 'AcceptedAnswerId': '24323', 'CreationDate': '2014-05-02T18:30:57.583', 'Id': '24321'}}