{'ViewCount': '635', 'Title': 'Does cooperative scheduling suspend processes when they perform an  I/O operation?', 'LastEditDate': '2012-04-07T13:42:43.093', 'AnswerCount': '4', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '40', 'FavoriteCount': '0', 'Body': '<p>Many operating systems references say that with cooperative (as opposed to preemptive) multitasking, a process keeps the CPU until it explicitly voluntarily suspends itself.  If a running process performs an I/O request that cannot be immediately satisfied (e.g., requests a key stroke that is not yet available), does the scheduler suspend it, or does it really keep the CPU until the request can be serviced?</p>\n\n<p>[Edited to replace "blocks on i/o" with "performs an I/O request that cannot be immediately satisfied."]</p>\n', 'Tags': '<operating-systems><process-scheduling>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-09T22:15:05.277', 'CommentCount': '2', 'AcceptedAnswerId': '12', 'CreationDate': '2012-03-06T19:17:48.460', 'Id': '5'}{'Body': "<p>In a round-robin scheduler, adding a process multiple times to the process list is a cheap way to give it higher priority.</p>\n\n<p>I wonder how practical an approach this might be. What benefit does it have over other techniques such as giving the process a longer time slice (benefit: less switching time) or maintaining a separate list of high-priority processes. In particular, how does listing a process multiple times influence fairness and reactivity?</p>\n\n<p>(From exercise 2.16 in Andrew Tanenbaum's <em>Operating Systems: Design and Implementation</em> 1st ed.)</p>\n", 'ViewCount': '501', 'Title': 'Round-robin scheduling: allow listing a process multiple times?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-26T18:06:08.697', 'LastEditDate': '2012-04-07T13:42:29.833', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '392', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<operating-systems><process-scheduling>', 'CreationDate': '2012-03-11T21:39:01.683', 'Id': '226'}{'Body': '<p>There are different queues of processes (in an operating system):</p>\n\n<p><em>Job Queue:</em> Each new process goes into the job queue. Processes in the job queue reside on mass storage and await the allocation of main memory.</p>\n\n<p><em>Ready Queue:</em> The set of all processes that are in main memory and are waiting for CPU time is kept in the ready queue.</p>\n\n<p><em>Waiting (Device) Queues:</em> The set of processes waiting for allocation of certain I/O devices is kept in the waiting (device) queue.</p>\n\n<p>The short-term scheduler (also known as CPU scheduling) selects a process from the ready queue and yields control of the CPU to the process.</p>\n\n<p>In my lecture notes the long-term scheduler is partly described as maintaining a queue of new processes waiting to be admitted into the system. </p>\n\n<p>What is the name of the queue the long-term scheduler maintains? When it admits a process to the system is the process placed in the ready queue?    </p>\n', 'ViewCount': '1749', 'Title': 'Which queue does the long-term scheduler maintain?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-04T05:30:51.123', 'LastEditDate': '2012-04-22T16:10:28.683', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1115', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '935', 'Tags': '<operating-systems><terminology><process-scheduling>', 'CreationDate': '2012-04-07T06:24:48.613', 'Id': '1106'}{'Body': '<p>For the following jobs: </p>\n\n<p><img src="http://i.stack.imgur.com/rwOBN.png" alt="job table"></p>\n\n<p>The <strong>average wait time</strong> would be using a FCFS algorithm:</p>\n\n<p>(6-6)+(7-2)+(11-5)+(17-5)+(14-1) -> 0+5+6+10+13 -> 34/5 = 7 (6.8)</p>\n\n<p>What would the <strong>average turnaround time</strong> be? </p>\n', 'ViewCount': '8299', 'Title': 'What is the average turnaround time?', 'LastActivityDate': '2014-04-30T15:21:50.527', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1279', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '935', 'Tags': '<algorithms><operating-systems><process-scheduling><scheduling>', 'CreationDate': '2012-04-14T13:25:49.020', 'Id': '1270'}{'ViewCount': '1291', 'Title': 'What is meant by interrupts in the context of operating systems?', 'LastEditDate': '2012-05-18T07:45:37.680', 'AnswerCount': '4', 'Score': '7', 'OwnerDisplayName': 'user28694', 'PostTypeId': '1', 'OwnerUserId': '3017', 'Body': '<p>I\'ve decided to read <a href="http://rads.stackoverflow.com/amzn/click/0470128720" rel="nofollow">Operating Systems Concepts</a> by Silberschatz, Galvin Gagne (8th edition) over the summer. I\'ve gotten to a topic that\'s confusing me - interrupts and their role as it relates to operating systems. </p>\n\n<p>The text says that an operating system will begin a first process such as "init" and then wait for an "event" to occur and this event is usually signaled by an interrupt. The text also says that the interrupt can come from either the hardware or the software. How does this work, in a little more detail? Is the operating system driven by interrupts? </p>\n\n<p>I am just looking for some big picture understanding. </p>\n', 'Tags': '<operating-systems><computer-architecture><process-scheduling>', 'LastEditorUserId': '1541', 'LastActivityDate': '2012-05-18T07:45:42.593', 'CommentCount': '0', 'AcceptedAnswerId': '1701', 'CreationDate': '2012-05-05T21:03:18.007', 'Id': '1700'}{'Body': u'<p>I was reading <strong>Linux Kernel Development</strong> by Robert Love, where I came across this</p>\n\n<blockquote>\n  <p>Linux takes an interesting approach to thread support: It does not\n  differentiate between threads and normal processes.To the kernel, all\n  processes are the same\u2014 some just happen to share resources.</p>\n</blockquote>\n\n<p>I do not know much about OSs (aspire to know more) and kernels and hence the above quote raised a question about thread implementations in different OSs(at least the popular ones like Windows, Linux and Unix).</p>\n\n<p>Can someone please explain the different techniques for providing thread-support in an OS? ( and optionally contrast them)</p>\n', 'ViewCount': '512', 'Title': 'How are threads implemented in different OSs?', 'LastEditorUserId': '59', 'LastActivityDate': '2012-06-07T23:11:00.057', 'LastEditDate': '2012-06-07T23:11:00.057', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '59', 'Tags': '<operating-systems><process-scheduling><threads>', 'CreationDate': '2012-06-07T07:07:14.337', 'Id': '2248'}{'Body': '<p>There are three processes in line, $P_0$, $P_1$ and $P_2$.</p>\n\n<ol>\n<li><p>$P_0$ registered and executes</p></li>\n<li><p>$P_0$ I/O blocked</p></li>\n<li><p>so $P_1$ executes</p></li>\n<li><p>$P_1$ I/O blocked</p></li>\n<li><p>$P_0$ executes. ??</p></li>\n</ol>\n\n<p>After $P_1$ must come $P_2$ that is what FCFS (First-Come-First-Serve) is about.</p>\n\n<p>So anyone please explain why is $P_0$ coming again? $P_0$ should be in the tail of ready queue after servicing I/O.</p>\n\n<hr>\n\n<blockquote>\n  <p>Or does the process completing an I/O return to the TOP of the Ready\n  Queue instead of the bottom in FCFS?</p>\n</blockquote>\n\n<hr>\n\n<h2><a href="http://www.ontko.com/moss/sched/user_guide.html" rel="nofollow">The link</a></h2>\n\n<p><em><strong>The scheduling.conf</em></strong></p>\n\n<pre><code>// # of Process \nnumprocess 4\n\n// mean deivation\nmeandev 2000\n\n// standard deviation\nstanddev 0\n\n// process    # I/O blocking\nprocess 500\nprocess 500\nprocess 500\nprocess 500\n\n// duration of the simulation in milliseconds\nruntime 10000\n</code></pre>\n\n<p><em><strong>The Summary-Processes</em></strong></p>\n\n<pre><code>Process: 0 registered... (2000 500 0 0)\nProcess: 0 I/O blocked... (2000 500 500 500)\nProcess: 1 registered... (2000 500 0 0)\nProcess: 1 I/O blocked... (2000 500 500 500)\nProcess: 0 registered... (2000 500 500 500)  --&gt; why p0 it should be p2 w.r.t FCFS\nProcess: 0 I/O blocked... (2000 500 1000 1000)\nProcess: 1 registered... (2000 500 500 500)\nProcess: 1 I/O blocked... (2000 500 1000 1000)\nProcess: 0 registered... (2000 500 1000 1000)\nProcess: 0 I/O blocked... (2000 500 1500 1500)\nProcess: 1 registered... (2000 500 1000 1000)\nProcess: 1 I/O blocked... (2000 500 1500 1500)\nProcess: 0 registered... (2000 500 1500 1500)\nProcess: 0 completed... (2000 500 2000 2000)\nProcess: 1 registered... (2000 500 1500 1500)\nProcess: 1 completed... (2000 500 2000 2000)\nProcess: 2 registered... (2000 500 0 0)\nProcess: 2 I/O blocked... (2000 500 500 500)\nProcess: 3 registered... (2000 500 0 0)\nProcess: 3 I/O blocked... (2000 500 500 500)\nProcess: 2 registered... (2000 500 500 500)\nProcess: 2 I/O blocked... (2000 500 1000 1000)\nProcess: 3 registered... (2000 500 500 500)\nProcess: 3 I/O blocked... (2000 500 1000 1000)\nProcess: 2 registered... (2000 500 1000 1000)\nProcess: 2 I/O blocked... (2000 500 1500 1500)\nProcess: 3 registered... (2000 500 1000 1000)\nProcess: 3 I/O blocked... (2000 500 1500 1500)\nProcess: 2 registered... (2000 500 1500 1500)\nProcess: 2 completed... (2000 500 2000 2000)\nProcess: 3 registered... (2000 500 1500 1500)\nProcess: 3 completed... (2000 500 2000 2000)\n</code></pre>\n\n<p><em><strong>The Summary-Results</em></strong></p>\n\n<pre><code>Scheduling Type: Batch (Nonpreemptive)\nScheduling Name: First-Come First-Served\nSimulation Run Time: 8000\nMean: 2000\nStandard Deviation: 0\nProcess #   CPU Time        IO Blocking     CPU Completed   CPU Blocked\n0           2000 (ms)       500 (ms)        2000 (ms)       3 times\n1           2000 (ms)       500 (ms)        2000 (ms)       3 times\n2           2000 (ms)       500 (ms)        2000 (ms)       3 times\n3           2000 (ms)       500 (ms)        2000 (ms)       3 times\n</code></pre>\n', 'ViewCount': '689', 'ClosedDate': '2013-11-09T13:12:49.210', 'Title': 'First-Come-First-Serve scheduling algorithm - what happens to process after returning from I/O? where does it go in the queue', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T00:09:47.220', 'LastEditDate': '2013-07-04T22:09:09.530', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'OwnerDisplayName': 'Doopy Doo', 'PostTypeId': '1', 'Tags': '<operating-systems><process-scheduling>', 'CreationDate': '2012-10-19T14:01:19.533', 'Id': '6209'}{'Body': '<p>I would like to know what impacts does a scheduling algorithm say Round Robin of FIFO have on a Operating system. I understand the a scheduling algorithm has the processes run in burst then switch between one another. But what does this mean for an OS. All i can figure out is that the OS has to keep track of which process is running, see if its done/completed its operation, chose/switch to another process and run it for a given time. Am I missing the obvious here? It does not really seam to me that a scheduling algorithm really affect the OS per say but the CPU hardware.</p>\n', 'ViewCount': '386', 'Title': 'Scheduling algorithms and quantum time', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T18:43:37.563', 'LastEditDate': '2012-11-01T22:37:29.953', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'MNM', 'PostTypeId': '1', 'Tags': '<operating-systems><process-scheduling>', 'CreationDate': '2012-11-01T13:05:31.500', 'Id': '6432'}{'Body': '<p>What would be the process state in a multi threaded process, in which threads are in different states (running, waiting, blocked etc)</p>\n', 'ViewCount': '101', 'Title': 'Process state in multi threaded process', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-09T07:57:00.760', 'LastEditDate': '2012-11-09T07:57:00.760', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4508', 'Tags': '<terminology><operating-systems><process-scheduling><threads>', 'CreationDate': '2012-11-08T10:47:53.373', 'Id': '6558'}{'ViewCount': '73', 'Title': 'What mechanisms prevent a process from taking over the processor forever?', 'LastEditDate': '2013-01-31T19:25:51.833', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6598', 'FavoriteCount': '0', 'Body': '<p>Suppose a process keeps running code (e.g. an infinite loop). How can other programs take over? What prevents the process from remaining active forever?</p>\n', 'Tags': '<operating-systems><process-scheduling>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-02-01T00:39:25.167', 'CommentCount': '2', 'AcceptedAnswerId': '9374', 'CreationDate': '2013-01-31T13:24:04.120', 'Id': '9354'}{'Body': '<p>I am finding it difficult to clearly differentiate between Multiprogramming and Multitasking.</p>\n\n<p>My primary source has been <a href="http://en.wikipedia.org/wiki/Computer_multitasking" rel="nofollow">Wikipedia</a>, but the WP article seems to be a little at odds with some less reputable sources (like my college professor).</p>\n\n<p>As I read WP, <em>multiprogramming</em> is a rudimentary way of increasing CPU throughput, by context-switching when a process waits for I/O.</p>\n\n<blockquote>\n  <p>Multiprogramming doesn\'t give any guarantee that a program will run in a timely manner. Indeed, the very first program may very well run for hours without needing access to a peripheral. </p>\n</blockquote>\n\n<p><em>Cooperative Time-sharing</em>, synonymous with <em>Cooperative Multitasking</em>, is an improvement on multiprogramming (with which it is not synonymous). The CPU context-switches regularly to give the impression of simultaneous execution, but processes are still required to yield - and poorly designed programs can starve the rest of the system.</p>\n\n<p><em>Preemptive Multitasking</em> takes more aggressive control of scheduling, giving priority to some processes over others, etc.</p>\n\n<ol>\n<li>Is this overview correct? If not is that because WP is incorrect or because I read WP wrong?</li>\n<li>Why do some sources seem to conflate multiprogramming and multitasking? </li>\n</ol>\n', 'ViewCount': '7123', 'Title': 'What is the difference between Multiprogramming and Multitasking', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-17T20:59:46.423', 'LastEditDate': '2013-03-26T11:56:51.257', 'AnswerCount': '3', 'CommentCount': '6', 'AcceptedAnswerId': '10811', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7421', 'Tags': '<terminology><process-scheduling>', 'CreationDate': '2013-03-26T11:49:56.370', 'Id': '10801'}{'Body': '<p>As I understand the <em>convoy effect</em>, in the context of vehicular traffic in a road system. A slow moving group of vehicles passes through the system, slowing traffic even in areas which were not directly affected by the convoy.</p>\n\n<p>How does this apply in the context of CPU scheduling? It does not seem to be an analogous situation.</p>\n', 'ViewCount': '3155', 'Title': 'The convoy effect in process scheduling', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-16T09:18:33.377', 'LastEditDate': '2013-04-15T07:22:01.517', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7421', 'Tags': '<operating-systems><process-scheduling>', 'CreationDate': '2013-04-15T04:39:00.593', 'Id': '11325'}{'Body': '<p>Whats the diffrence between Disk scheduling and process scheduling? I mean i know the roles of disks and processes, but it seems to me they both have the same aim. to reduce monopolies, they even both share similar algorithms like first come first serve. Am i right?</p>\n', 'ViewCount': '814', 'Title': 'Disk scheduling and process scheduling', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-05-06T13:25:25.903', 'LastEditDate': '2013-05-06T11:59:45.810', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '11827', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8054', 'Tags': '<operating-systems><process-scheduling>', 'CreationDate': '2013-05-06T06:38:57.250', 'Id': '11820'}{'Body': "<p>The problem is a scheduling problem with n jobs and k machines. Each job i can be started at any time, but its duration is not exactly known except a time span interval. For example, a job may take anything from 5 mins to 10 mins. The list of jobs and their duration interval is given to the scheduler and the aim is to minimize the time all jobs would be finished. \nIn interval scheduling, the job start and end time is given and the length is fixed. Here, the job can start and end anytime (should be done in whole though) but its duration (length) is not exactly known.</p>\n\n<p>I searched the literature for this problem but couldn't find it. Is there any keywords I can use or any reference for this problem? Is it well-defined?</p>\n", 'ViewCount': '159', 'Title': 'A variant of job assignment (scheduling) problem with variable time span', 'LastActivityDate': '2013-08-02T19:50:55.893', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8995', 'Tags': '<optimization><scheduling><process-scheduling><assignment-problem>', 'CreationDate': '2013-07-03T18:47:45.597', 'Id': '13066'}{'Body': "<p>An OS contains 10 identical processes that were initiated at the same time.Each process contains 15 identical requests. Each request consume 20 msec of CPU time.A request is followed by an I/O operation which consumes 10 msec.The CPU scheduling overhead is 2 msec. The system uses Round Robin scheduling with the time quantum of 10 msec.</p>\n\n<p>Q1) What is the response time of 1st request of last process ? \n  A) 210 msec  B) 140 msec  c) 230 msec  D) 240 msec</p>\n\n<p>Q2) The subsequent request of the processes receives a response times of \n A) 110 msec  B) 220 msec  C) 230 msec  D) 240 msec</p>\n\n<p>Ans: Q1) D</p>\n\n<pre><code> Q2) C\n</code></pre>\n\n<p>What I thought : </p>\n\n<p>For 1 process, there are 15 request so \n15 * ( 20 + 10) = 450 msec  But all answers are so small than this approach. So no need to think about further i.e. CPU overhead then 2nd...3rd...processes. </p>\n\n<p>Here my problem is I didn't get the concept behind this question properly. CPU overhead ( i.e context switching ) will take place between 10 processes or each process's 15 request.\nSo please tell how this scenario will work. </p>\n\n<p>I didn't get the meaning of 2nd question. </p>\n", 'ViewCount': '60', 'Title': 'processes response time confusion', 'LastEditorUserId': '9343', 'LastActivityDate': '2013-11-12T08:21:02.980', 'LastEditDate': '2013-11-12T05:00:57.927', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9343', 'Tags': '<operating-systems><memory-management><process-scheduling><threads>', 'CreationDate': '2013-11-11T18:54:01.780', 'Id': '17919'}{'Body': '<p>What bad things can occur when the lengths of the time slices in a multitasking system are too small? What can happen when they are too big?  How should the length of the time slice be chosen?</p>\n', 'ViewCount': '114', 'Title': 'What happens when time slices are too short or too long?', 'LastEditorUserId': '755', 'LastActivityDate': '2013-12-04T01:48:02.900', 'LastEditDate': '2013-12-04T01:48:02.900', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18576', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11723', 'Tags': '<operating-systems><process-scheduling>', 'CreationDate': '2013-12-01T01:14:30.103', 'Id': '18496'}{'ViewCount': '145', 'Title': 'Exponential averaging for SJF CPU scheduling', 'LastEditDate': '2014-01-24T18:48:46.530', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13062', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p>Calculate the exponential averaging with $T_1 = 10$, $\\alpha=0.5$ and the algorithm is SJF with previous runs as $8,7,4,16$.</p>\n  \n  <ol>\n  <li>9 </li>\n  <li>8 </li>\n  <li>7.5 </li>\n  <li>None</li>\n  </ol>\n</blockquote>\n\n<p>I am getting 4. None as the answer. </p>\n\n<p>But it is given that 3. 7.5 is the correct answer.\nI think I am missing something here.</p>\n\n<p>Because I only used the formula, $S_{n + 1}{}{}{}{} = a(T_n) + (1-a)*S_n$.</p>\n', 'Tags': '<operating-systems><process-scheduling>', 'LastEditorUserId': '13107', 'LastActivityDate': '2014-03-13T10:56:43.757', 'CommentCount': '5', 'AcceptedAnswerId': '19949', 'CreationDate': '2014-01-23T13:14:11.970', 'Id': '19911'}{'Body': '<p>I have been faced with a problem where three concurrent processes <strong>X</strong>, <strong>Y</strong> ,<strong>Z</strong> execute three different code segments that access and update certain shared variables. Before entering the respective code segments :</p>\n\n<ul>\n<li><p>Process X executes the P operation on semaphores a,b and c;</p></li>\n<li><p>Process Y executes the P operation on semaphores b,c and d;</p></li>\n<li><p>Process Z executes the P operation on semaphores c,d and a.</p></li>\n</ul>\n\n<p>After completing the execution of its code segment, each process invokes the V operation (i.e, signal) on its three semaphores. All semaphores are binary semaphores initialized to one. </p>\n\n<p>How do I recognise a deadlock-free order of invoking the P operations by the processes ? For illustration, the given examples are the following</p>\n\n<ol>\n<li>X: P(a)P(b)P(c) Y:P(b)P(c)P(d) Z:P(c)P(d)P(a)</li>\n<li>X: P(b)P(a)P(c) Y:P(b)P(c)P(d) Z:P(a)P(c)P(d)</li>\n<li>X: P(b)P(a)P(c) Y:P(c)P(b)P(d) Z:P(a)P(c)P(d)</li>\n<li>X: P(a)P(b)P(c) Y:P(c)P(b)P(d) Z:P(c)P(d)P(a)</li>\n</ol>\n', 'ViewCount': '45', 'Title': 'How to build/recognise a deadlock-free order of resources', 'LastEditorUserId': '13107', 'LastActivityDate': '2014-02-16T12:38:56.143', 'LastEditDate': '2014-02-15T16:47:27.490', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21666', 'Score': '0', 'OwnerDisplayName': u'\u0110\u0113\u0113pak Sh\xe3rm\xe3', 'PostTypeId': '1', 'Tags': '<process-scheduling><deadlocks>', 'CreationDate': '2014-02-15T06:46:20.643', 'Id': '21665'}