24_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '198', 'Title': 'Characterization of lambda-terms that have union types', 'LastEditDate': '2012-03-07T11:03:44.950', 'AnswerCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '3', 'Body': '<p>Many textbooks cover intersection types in the lambda-calculus. The typing rules for intersection can be defined as follows (on top of the simply typed lambda-calculus with subtyping):</p>\n\n<p>$$\r\n\\dfrac{\\Gamma \\vdash M : T_1 \\quad \\Gamma \\vdash M : T_2}\r\n      {\\Gamma \\vdash M : T_1 \\wedge T_2}\r\n      (\\wedge I)\r\n\\qquad\\qquad\r\n\\dfrac{}\r\n      {\\Gamma \\vdash M : \\top}\r\n      (\\top I)\r\n$$</p>\n\n<p>Intersection types have interesting properties with respect to normalization:</p>\n\n<ul>\n<li>A lambda-term can be typed without using the $\\top I$ rule iff it is strongly normalizing.</li>\n<li>A lambda-term admits a type not containing $\\top$ iff it has a normal form.</li>\n</ul>\n\n<p>What if instead of adding intersections, we add unions?</p>\n\n<p>$$\r\n\\dfrac{\\Gamma \\vdash M : T_1}\r\n      {\\Gamma \\vdash M : T_1 \\vee T_2}\r\n      (\\vee I_1)\r\n\\qquad\\qquad\r\n\\dfrac{\\Gamma \\vdash M : T_2}\r\n      {\\Gamma \\vdash M : T_1 \\vee T_2}\r\n      (\\vee I_2)\r\n$$</p>\n\n<p>Does the lambda-calculus with simple types, subtyping and unions have any interesting similar property? How can the terms typable with union be characterized?</p>\n', 'Tags': '<lambda-calculus><type-theory><logic>', 'LastEditorUserId': '68', 'LastActivityDate': '2012-03-08T10:06:42.440', 'CommentCount': '2', 'AcceptedAnswerId': '116', 'CreationDate': '2012-03-07T02:07:40.470', 'Id': '62'},24_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider an inductive type which has some recursive occurrences in a nested, but strictly positive location. For example, trees with finite branching with nodes using a generic list data structure to store the children.</p>\n\n<pre><code>Inductive LTree : Set := Node : list LTree -&gt; LTree.\n</code></pre>\n\n<p>The naive way of defining a recursive function over these trees by recursing over trees and lists of trees does not work. Here\'s an example with the <code>size</code> function that computes the number of nodes.</p>\n\n<pre><code>Fixpoint size (t : LTree) : nat := match t with Node l =&gt; 1 + (size_l l) end\nwith size_l (l : list LTree) : nat := match l with\n    | nil =&gt; 0\n    | cons h r =&gt; size h + size_l r\n  end.\n</code></pre>\n\n<p>This definition is ill-formed (error message excerpted):</p>\n\n<pre><code>Error:\nRecursive definition of size_l is ill-formed.\nRecursive call to size has principal argument equal to\n"h" instead of "r".\n</code></pre>\n\n<p>Why is the definition ill-formed, even though <code>r</code> is clearly a subterm of <code>l</code>? Is there a way to define recursive functions on such a data structure?</p>\n\n<hr>\n\n<p>If you aren\'t fluent in Coq syntax: <code>LTree</code> is an inductive type corresponding to the following grammar.</p>\n\n<p>$$\\begin{align}\r\n  \\mathtt{LTree} ::= &amp; \\\\\r\n  \\vert &amp; \\mathtt{list}(\\mathtt{LTree}) \\\\\r\n\\end{align}$$</p>\n\n<p>We attempt to define the <code>size</code> function by induction over trees and lists. In OCaml, that would be:</p>\n\n<pre><code>type t = Node of t list\nlet rec size = function Node l -&gt; 1 + size_l l\nand size_l = function [] -&gt; 0\n                    | h::r -&gt; size h + size_l r\n</code></pre>\n', 'ViewCount': '481', 'Title': 'Recursive definitions over an inductive type with nested components', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-29T18:24:01.597', 'LastEditDate': '2012-03-29T18:24:01.597', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<logic><coq><type-theory><recursion><proof-assistants>', 'CreationDate': '2012-03-07T17:38:37.210', 'Id': '104'},24_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '404', 'Title': 'What is beta equivalence?', 'LastEditDate': '2012-04-22T16:20:23.093', 'AnswerCount': '2', 'Score': '9', 'OwnerDisplayName': 'atticae', 'PostTypeId': '1', 'OwnerUserId': '594', 'FavoriteCount': '2', 'Body': '<p>In the script I am currently reading on the lambda calculus, beta equivalence is defined as this:</p>\n\n<blockquote>\n  <p>The $\\beta$-equivalence $\\equiv_\\beta$ is the smallest equivalence that contains $\\rightarrow_\\beta$.</p>\n</blockquote>\n\n<p>I have no idea what that means. Can someone explain it in simpler terms? Maybe with an example?</p>\n\n<p>I need it for a lemma following from the Church-Russer theorem, saying</p>\n\n<blockquote>\n  <p>If M $\\equiv_\\beta$ N then there is a L with M $\\twoheadrightarrow_\\beta$ L and N $\\twoheadrightarrow_\\beta$ L.</p>\n</blockquote>\n', 'Tags': '<logic><terminology><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T16:20:23.093', 'CommentCount': '1', 'AcceptedAnswerId': '635', 'CreationDate': '2012-03-21T18:42:56.037', 'Id': '634'},24_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am working on an expression based language of ML genealogy, so it naturally needs type inference >:)</p>\n\n<p>Now, I am trying to extend a constraint-based solution to the problem of inferring types, based on a simple implementation in EOPL (Friedman and Wand), but they elegantly side-step algebraic datatypes.</p>\n\n<p>What I have so far works smoothly; if an expression <code>e</code> is <code>a + b</code>, <code>e : Int</code>, <code>a : Int</code> and <code>b : Int</code>. If <code>e</code> is a match,</p>\n\n<pre><code>match n with\n  | 0 -&gt; 1\n  | n' -&gt; n' * fac(n - 1)`, \n</code></pre>\n\n<p>I can rightly infer that the <code>t(e) = t(the whole match expression)</code>, <code>t(n) = t(0) = t(n')</code>, <code>t(match) = t(1) = t(n' * fac(n - 1)</code> and so on...</p>\n\n<p>But I am very unsure when it comes to algebraic datatypes. Suppose a function like filter:</p>\n\n<pre><code>let filter pred list =\n  match list with\n    | Empty -&gt; Empty\n    | Cons(e, ls') when pred e -&gt; Cons (e, filter ls')\n    | Cons(_, ls') -&gt; filter \n</code></pre>\n\n<p>For the list type to remain polymorphic, Cons needs to be of type <code>a * a list -&gt; a list</code>. So, in establishing these constraints, I obviously need to look up these types of my algebraic constructors - the problem I now have is the 'context-sensitivity' of multiple uses of algebraic constructors - how do I express in my constraint equations that the <code>a</code> in each case needs to be the same?</p>\n\n<p>I am having trouble finding a general solution to this, and I am unable to find much literature on this. Whenever I find something similar - expression based language with constraint-based type inference - they stop just short of algebraic datatypes and polymorphism.</p>\n\n<p>Any input is much appreciated!</p>\n", 'ViewCount': '214', 'Title': 'Constraint-based Type Inference with Algebraic Data', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-20T10:07:16.937', 'LastEditDate': '2012-04-06T23:30:01.300', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '979', 'Tags': '<programming-languages><type-theory><functional-programming><inductive-datatypes><typing>', 'CreationDate': '2012-04-06T23:09:22.253', 'Id': '1092'},24_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I would like to know whether a universally-quantified type $T_a$: $$T_a = \\forall X: \\left\\{ a\\in X,f:X\u2192\\{T, F\\} \\right\\}$$ is a sub-type, or special case, of an existentially-quantified type $T_e$ with the same signature: $$T_e = \\exists X: \\left\\{ a\\in X,f:X\u2192\\{T, F\\} \\right\\}$$</p>\n\n<p>I\'d say "yes": If something is true "for all X" ($\\forall X$), then it must also be true "for some X" ($\\exists X$). That is, a statement with \'$\\forall$\' is simply a more restricted version of the same statement with \'$\\exists$\': $$\u2200X, P(X) \\overset?\\implies \u2203X, P(X).$$</p>\n\n<p>Am I wrong somewhere?</p>\n\n<blockquote>\n  <p><strong>Background: Why am I asking this?</strong></p>\n  \n  <p>I am studying existential types in order to understand why and how <a href="http://theory.stanford.edu/~jcm/papers/mitch-plotkin-88.pdf">"Abstract [Data] Types Have Existential Type"</a>. I cannot get a good grasp of this concept from theory alone; I need concrete examples, too.</p>\n  \n  <p>Unfortunately, good code examples are hard to find because most programming languages have only limited support for existential types. (For instance, <a href="http://www.haskell.org/haskellwiki/Existential_type">Haskell\'s <code>forall</code></a>, or <a href="http://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html">Java\'s <code>?</code> wildcards</a>.) On the other hand, universally-quantified types are supported by many recent languages via "generics".</p>\n  \n  <p>What\'s worse, <em>generics seems to easily get mixed up with existential types</em>, too, making it even harder to tell apart existential from universal types. <em>I\'m curious why this mix-up occurs so easily.</em> An answer to this question might explain it: If universal types are indeed only a special case of existential types, then it\'s no wonder that generic types, e.g. Java\'s <code>List&lt;T&gt;</code>, can be interpreted either way.</p>\n</blockquote>\n', 'ViewCount': '225', 'Title': 'Are universal types a sub-type, or special case, of existential types?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-13T21:58:00.160', 'LastEditDate': '2012-04-20T10:20:47.280', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '12', 'OwnerDisplayName': 'stakx', 'PostTypeId': '1', 'Tags': '<logic><type-theory><typing>', 'CreationDate': '2012-01-02T12:55:49.437', 'FavoriteCount': '1', 'Id': '1382'},24_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Most of us know the correspondence between <a href="http://en.wikipedia.org/wiki/Combinatory_logic" rel="nofollow">combinatory logic</a> and <a href="http://en.wikipedia.org/wiki/Lambda_calculus" rel="nofollow">lambda calculus</a>. But I\'ve never seen (maybe I haven\'t looked deep enough) the equivalent of "typed combinators", corresponding to the simply typed lambda calculus. Does such thing exist? Where could one find information about it?</p>\n', 'ViewCount': '218', 'Title': 'Is there a typed SKI calculus?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T15:47:46.390', 'LastEditDate': '2012-05-14T15:47:16.223', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1818', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1300', 'Tags': '<logic><reference-request><lambda-calculus><type-theory>', 'CreationDate': '2012-05-13T01:39:47.143', 'Id': '1816'},24_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '267', 'Title': 'Simple explanation as to why certain computable functions cannot be represented by a typed term?', 'LastEditDate': '2012-05-26T14:40:07.843', 'AnswerCount': '3', 'Score': '7', 'OwnerDisplayName': 'ixtmixilix', 'PostTypeId': '1', 'OwnerUserId': '1693', 'FavoriteCount': '1', 'Body': '<p>Reading the paper <a href="ftp://ftp.cs.ru.nl/pub/CompMath.Found/lambda.pdf">An Introduction to the Lambda Calculus</a>, I came across a paragraph I didn\'t really understand, on page 34 (my italics):</p>\n\n<blockquote>\n  <p>Within each of the two paradigms there are several versions of typed\n  lambda calculus. In many important systems, especially those a la\n  Church, it is the case that terms that do have a type always possess a\n  normal form. By the unsolvability of the halting problem this\n  implies that not all computable functions can be represented by a\n  typed term, see Barendregt (1990), Theorem 4.2.15. This is not so bad\n  as it sounds, because in order to find such computable functions that\n  cannot be represented, one has to stand on one\'s head. For example in\n  2, the second order typed lambda calculus, only those partial\n  recursive functions cannot be represented that happen to be total,\n  but not provably so in mathematical analysis (second order\n  arithmetic).</p>\n</blockquote>\n\n<p>I am familiar with most of these concepts, but not the concept of a partial recursive function, nor the concept of a provably total function. However, this is not what I am interested in learning.</p>\n\n<p>I am looking for a simple explanation as to why certain computable functions cannot be represented by a typed term, as well as to why such functions can only be found \'by standing on one\'s head.\'</p>\n', 'Tags': '<computability><logic><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-27T11:43:59.000', 'CommentCount': '0', 'CreationDate': '2012-05-25T17:39:06.803', 'Id': '2092'},24_7:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '338', 'Title': 'How to read typing rules?', 'LastEditDate': '2012-05-29T17:09:34.050', 'AnswerCount': '3', 'Score': '7', 'OwnerDisplayName': 'suls', 'PostTypeId': '1', 'OwnerUserId': '1745', 'FavoriteCount': '1', 'Body': '<p>I started reading more and more language research papers. I find it very interesting and a good way to learn more about programming in general. However, there usually comes a section where I always struggle with (take for instance part three of <a href="http://math.andrej.com/wp-content/uploads/2012/03/eff.pdf">this</a>) since I lack the theoretical background in computer science: Type Rules.</p>\n\n<p>Are there any good books or online resources available to get started in this area? <a href="http://en.wikipedia.org/wiki/Type_rules">Wikipedia</a> is incredibly vague and doesn\'t really help a beginner.</p>\n', 'Tags': '<logic><reference-request><terminology><type-theory>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-29T19:29:45.030', 'CommentCount': '2', 'AcceptedAnswerId': '2160', 'CreationDate': '2012-05-29T07:18:09.443', 'Id': '2155'},24_8:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '549', 'Title': 'Categorisation of type systems (strong/weak, dynamic/static)', 'LastEditDate': '2012-06-10T10:37:44.360', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '1808', 'FavoriteCount': '5', 'Body': '<p>In short: how are type systems categorised in academic contexts; particularly, where can I find reputable sources that make the distinctions between different sorts of type system clear?</p>\n\n<p>In a sense the difficulty with this question is not that I can\'t find an answer, but rather that I can find too many, and none stand out as correct. The background is I am attempting to improve an article on the Haskell wiki about <a href="http://www.haskell.org/haskellwiki/Typing">typing</a>, which currently claims the following distinctions:</p>\n\n<ul>\n<li>No typing: The language has no notion of types, or from a typed perspective: There is exactly one type in the language. Assembly language has only the type \'bit pattern\', Rexx and Tk have only the type \'text\', core MatLab has only the type \'complex-valued matrix\'.</li>\n<li>Weak typing: There are only few distinguished types and maybe type synonyms for several types. E.g. C uses integer numbers for booleans, integers, characters, bit sets and enumerations.</li>\n<li>Strong typing: Fine grained set of types like in Ada, Wirthian languages (Pascal, Modula-2), Eiffel</li>\n</ul>\n\n<p>This is entirely contrary to my personal perception, which was more along the lines of:</p>\n\n<ul>\n<li>Weak typing: Objects have types, but are implicitly converted to other types when the context demands it. For example, Perl, PHP and JavaScript are all languages in which <code>"1"</code> can be used in more or less any context that <code>1</code> can.</li>\n<li>Strong typing: Objects have types, and there are no implicit conversions (although overloading may be used to simulate them), so using an object in the wrong context is an error. In Python, indexing an array with a string or float throws a TypeError exception; in Haskell it will fail at compile time.</li>\n</ul>\n\n<p>I asked for opinions on this from other people more experienced in the field than I am, and one gave this characterisation:</p>\n\n<ul>\n<li>Weak typing: Performing invalid operations on data is not controlled or rejected, but merely produces invalid/arbitrary results.</li>\n<li>Strong typing: Operations on data are only permitted if the data is compatible with the operation.</li>\n</ul>\n\n<p>As I understand it, the first and last characterisations would call C weakly-typed, the second would call it strongly-typed. The first and second would call Perl and PHP weakly-typed, the third would call them strongly-typed. All three would describe Python as strongly-typed.</p>\n\n<p>I think most people would tell me "well, there is no consensus, there is no accepted meaning of the terms". If those people are wrong, I\'d be happy to hear about it, but if they are right, then how <em>do</em> CS researchers describe and compare type systems? What terminology can I use that is less problematic?</p>\n\n<p>As a related question, I feel the dynamic/static distinction is often given in terms of "compile time" and "run time", which I find unsatisfactory given that whether or not a language is compiled is not so much a property of that language as its implementations. I feel there should be a purely-semantic description of dynamic versus static typing; something along the lines of "a static language is one in which every subexpression can be typed". I would appreciate any thoughts, particularly references, that bring clarity to this notion.</p>\n', 'Tags': '<reference-request><programming-languages><type-theory>', 'LastEditorUserId': '1808', 'LastActivityDate': '2013-03-24T16:37:01.173', 'CommentCount': '6', 'AcceptedAnswerId': '2402', 'CreationDate': '2012-06-09T15:07:40.477', 'Id': '2301'},24_9:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\u2019m working on a compiler for a concatenative language and would like to add type inference support. I understand Hindley\u2013Milner, but I\u2019ve been learning the type theory as I go, so I\u2019m unsure of how to adapt it. Is the following system sound and decidably inferable?</p>\n\n<p>A term is a literal, a composition of terms, a quotation of a term, or a primitive.</p>\n\n<p>$$ e ::= x \\:\\big|\\: e\\:e \\:\\big|\\: [e] \\:\\big|\\: \\dots $$</p>\n\n<p>All terms denote functions. For two functions $e_1$ and $e_2$, $e_1\\:e_2 = e_2 \\circ e_1$, that is, juxtaposition denotes reverse composition. Literals denote niladic functions.</p>\n\n<p>The terms other than composition have basic type rules:</p>\n\n<p>$$\n\\dfrac{}{x : \\iota}\\text{[Lit]} \\\\\n\\dfrac{\\Gamma\\vdash e : \\sigma}{\\Gamma\\vdash [e] : \\forall\\alpha.\\:\\alpha\\to\\sigma\\times\\alpha}\\text{[Quot]}, \\alpha \\text{ not free in } \\Gamma\n$$</p>\n\n<p>Notably absent are rules for application, since concatenative languages lack it.</p>\n\n<p>A type is either a literal, a type variable, or a function from stacks to stacks, where a stack is defined as a right-nested tuple. All functions are implicitly polymorphic with respect to the \u201crest of the stack\u201d.</p>\n\n<p>$$\n\\begin{aligned}\n\\tau &amp; ::= \\iota \\:\\big|\\: \\alpha \\:\\big|\\: \\rho\\to\\rho \\\\\n\\rho &amp; ::= () \\:\\big|\\: \\tau\\times\\rho \\\\\n\\sigma &amp; ::= \\tau \\:\\big|\\: \\forall\\alpha.\\:\\sigma\n\\end{aligned}\n$$</p>\n\n<p>This is the first thing that seems suspect, but I don\u2019t know exactly what\u2019s wrong with it.</p>\n\n<p>To help readability and cut down on parentheses, I\u2019ll assume that $a\\:b = b \\times (a)$ in type schemes. I\u2019ll also use a capital letter for a variable denoting a stack, rather than a single value.</p>\n\n<p>There are six primitives. The first five are pretty innocuous. <code>dup</code> takes the topmost value and produces two copies of it. <code>swap</code> changes the order of the top two values. <code>pop</code> discards the top value. <code>quote</code> takes a value and produces a quotation (function) that returns it. <code>apply</code> applies a quotation to the stack.</p>\n\n<p>$$\n\\begin{aligned}\n\\mathtt{dup} &amp; :: \\forall A b.\\: A\\:b \\to A\\:b\\:b \\\\\n\\mathtt{swap} &amp; :: \\forall A b c.\\: A\\:b\\:c \\to A\\:c\\:b \\\\\n\\mathtt{pop} &amp; :: \\forall A b.\\: A\\:b \\to A \\\\\n\\mathtt{quote} &amp; :: \\forall A b.\\: A\\:b \\to A\\:(\\forall C. C \\to C\\:b) \\\\\n\\mathtt{apply} &amp; :: \\forall A B.\\: A\\:(A \\to B) \\to B \\\\\n\\end{aligned}\n$$</p>\n\n<p>The last combinator, <code>compose</code>, ought to take two quotations and return the type of their concatenation, that is, $[e_1]\\:[e_2]\\:\\mathtt{compose} = [e_1\\:e_2]$. In the statically typed concatenative language <a href="http://www.cat-language.com/" rel="nofollow">Cat</a>, the type of <code>compose</code> is very straightforward.</p>\n\n<p>$$\n\\mathtt{compose} :: \\forall A B C D.\\: A\\:(B \\to C)\\:(C \\to D) \\to A\\:(B \\to D)\n$$</p>\n\n<p>However, this type is too restrictive: it requires that the production of the first function <em>exactly match</em> the consumption of the second. In reality, you have to assume distinct types, then unify them. But how would you write that type?</p>\n\n<p>$$ \\mathtt{compose} :: \\forall A B C D E. A\\:(B \\to C)\\:(D \\to E) \\to A \\dots $$</p>\n\n<p>If you let $\\setminus$ denote a <em>difference</em> of two types, then I <em>think</em> you can write the type of <code>compose</code> correctly.</p>\n\n<p>$$\n\\mathtt{compose} :: \\forall A B C D E.\\: A\\:(B \\to C)\\:(D \\to E) \\to A\\:((D \\setminus C)\\:B \\to ((C \\setminus D)\\:E))\n$$</p>\n\n<p>This is still relatively straightforward: <code>compose</code> takes a function $f_1 : B \\to C$ and one $f_2 : D \\to E$. Its result consumes $B$ atop the consumption of $f_2$ not produced by $f_1$, and produces $D$ atop the production of $f_1$ not consumed by $f_2$. This gives the rule for ordinary composition.</p>\n\n<p>$$\n\\dfrac{\\Gamma\\vdash e_1 : \\forall A B.\\: A \\to B \\quad \\Gamma\\vdash e_2 : \\forall C D. C \\to D}{\\Gamma\\vdash e_1 e_2 : ((C \\setminus B)\\:A \\to ((B \\setminus C)\\:D))}\\text{[Comp]}\n$$</p>\n\n<p>However, I don\u2019t know that this hypothetical $\\setminus$ actually corresponds to anything, and I\u2019ve been chasing it around in circles for long enough that I think I took a wrong turn. Could it be a simple difference of tuples?</p>\n\n<p>$$\n\\begin{align}\n\\forall A. () \\setminus A &amp; = () \\\\\n\\forall A. A \\setminus () &amp; = A \\\\\n\\forall A B C D. A B \\setminus C D &amp; = B \\setminus D \\textit{ iff } A = C \\\\\n\\text{otherwise} &amp; = \\textit{undefined}\n\\end{align}\n$$</p>\n\n<p>Is there something horribly broken about this that I\u2019m not seeing, or am I on something like the right track? (I\u2019ve probably quantified some of this stuff wrongly and would appreciate fixes in that area as well.)</p>\n', 'ViewCount': '240', 'Title': 'Type inference with product types', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-13T19:17:41.510', 'LastEditDate': '2012-06-12T18:08:36.097', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '2346', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1821', 'Tags': '<programming-languages><logic><compilers><type-theory><type-checking>', 'CreationDate': '2012-06-11T04:14:50.140', 'Id': '2326'},24_10:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '202', 'Title': 'What is the type theory judgement symbol?', 'LastEditDate': '2012-06-22T09:49:43.210', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1642', 'FavoriteCount': '1', 'Body': '<p>In type theory judgements are often presented with the following syntax:</p>\n\n<p><img src="http://i.stack.imgur.com/7V5r2.png" alt="enter image description here"></p>\n\n<p>My question is what is that symbol in the middle called? All the papers I\'ve found seem to use an image rather than a unicode character so I can\'t look it up. I\'ve also not found any type-theory reference which says what that symbol is (they explain what it means however).</p>\n\n<p>So what character is that symbol and what is its proper name?</p>\n', 'Tags': '<logic><terminology><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-22T09:49:43.210', 'CommentCount': '5', 'AcceptedAnswerId': '2439', 'CreationDate': '2012-06-21T18:47:51.477', 'Id': '2437'},24_11:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '512', 'Title': 'Does there exist a Turing complete typed lambda calculus?', 'LastEditDate': '2012-07-09T08:50:19.440', 'AnswerCount': '1', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '2096', 'FavoriteCount': '2', 'Body': '<p>Do there exist any Turing complete typed lambda calculi? If so, what are a few examples?</p>\n', 'Tags': '<computability><lambda-calculus><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-09T08:50:19.440', 'CommentCount': '0', 'AcceptedAnswerId': '2639', 'CreationDate': '2012-07-06T23:16:05.897', 'Id': '2638'},24_12:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>At work I\u2019ve been tasked with inferring some type information about a dynamic language. I rewrite sequences of statements into nested <code>let</code> expressions, like so:</p>\n\n<pre><code>return x; Z            =&gt;  x\nvar x; Z               =&gt;  let x = undefined in Z\nx = y; Z               =&gt;  let x = y in Z\nif x then T else F; Z  =&gt;  if x then { T; Z } else { F; Z }\n</code></pre>\n\n<p>Since I\u2019m starting from general type information and trying to deduce more specific types, the natural choice is refinement types. For example, the conditional operator returns a union of the types of its true and false branches. In simple cases, it works very well.</p>\n\n<p>I ran into a snag, however, when trying to infer the type of the following:</p>\n\n<pre><code>function g(f) {\n  var x;\n  x = f(3);\n  return f(x);\n}\n</code></pre>\n\n<p>Which is rewritten to:</p>\n\n<pre><code>\\f.\n  let x = undefined in\n    let x = f 3 in\n      f x\n</code></pre>\n\n<p>HM would infer $\\mathtt{f} : \\mathtt{Int} \\to \\mathtt{Int}$ and consequently $\\mathtt{g} : (\\mathtt{Int} \\to \\mathtt{Int}) \\to \\mathtt{Int}$. The actual type I want to be able to infer is:</p>\n\n<p>$$\\mathtt{g} : \\forall \\tau_1 \\tau_2. \\:(\\mathtt{Int} \\to \\tau_1 \\land \\tau_1 \\to \\tau_2) \\to \\tau_2$$</p>\n\n<p>I\u2019m already using functional dependencies to resolve the type of an overloaded <code>+</code> operator, so I figured it was a natural choice to use them to resolve the type of <code>f</code> within <code>g</code>. That is, the types of <code>f</code> in all its applications together uniquely determine the type of <code>g</code>. However, as it turns out, fundeps don\u2019t lend themselves terribly well to variable numbers of source types.</p>\n\n<p>Anyway, the interplay of polymorphism and refinement typing is problematic. So is there a better approach I\u2019m missing? I\u2019m currently digesting \u201cRefinement Types for ML\u201d and would appreciate more literature or other pointers.</p>\n', 'ViewCount': '147', 'Title': 'Inferring refinement types', 'LastEditorUserId': '41', 'LastActivityDate': '2012-08-02T06:20:29.877', 'LastEditDate': '2012-08-02T06:20:29.877', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2980', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '1821', 'Tags': '<programming-languages><logic><type-theory><type-inference>', 'CreationDate': '2012-07-26T23:18:16.810', 'Id': '2919'},24_13:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '255', 'Title': 'Why classes implicitly derive from only the Object Class?', 'LastEditDate': '2012-08-07T08:17:37.153', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2385', 'FavoriteCount': '2', 'Body': '<p>I do not have any argument opposing why we need only a single universal class. However why not we have two universal classes, say an Object and an AntiObject Class. In nature and in science we find the concept of duality - like Energy &amp; Dark Energy; Male &amp; Female; Plus &amp; Minus; Multiply &amp; Divide; Electrons &amp; Protons; Integration &amp; Derivation; and in set theory. There are so many examples of dualism that it is a philosophy in itself. In programming itself we see Anti-Patterns which helps us to perform work in contrast to how we use Design patterns. I am not sure, but the usefulness of this duality concept may lie in creating garbage collectors that create AntiObjects that combine with free or loose Objects to destruct themselves, thereby releasing memory. Or may be AntiObjects work along with Objects to create a self-modifying programming language - that allows us to create a safe self modifying code, do evolutionary computing using genetic programming, do hiding of code to prevent reverse engineering. </p>\n\n<p>We call it object-oriented programming. Is that a limiting factor or is there something fundamental I am missing in understanding the formation of programming languages?</p>\n', 'Tags': '<programming-languages><type-theory><object-oriented>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-19T21:14:54.720', 'CommentCount': '8', 'AcceptedAnswerId': '3068', 'CreationDate': '2012-08-07T07:38:44.630', 'Id': '3067'},24_14:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>It was brought to my attention that the cost of type inference in a functional language like OCaml can be very high. The claim is that there is a sequence of expressions such that for each expression the length of the corresponding type is exponential on the length of the expression.</p>\n\n<p>I devised the sequence below. My question is: do you know of a sequence with more concise expressions that achieves the same types?</p>\n\n<pre><code># fun a -&gt; a;;\n- : 'a -&gt; 'a = &lt;fun&gt;\n# fun b a -&gt; b a;;\n- : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &lt;fun&gt;\n# fun c b a -&gt; c b (b a);;\n- : (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'c = &lt;fun&gt;\n# fun d c b a -&gt; d c b (c b (b a));;\n- : ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'd\n= &lt;fun&gt;\n# fun e d c b a -&gt; e d c b (d c b (c b (b a)));;\n- : (((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n   ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'e\n= &lt;fun&gt;\n# fun f e d c b a -&gt; f e d c b (e d c b (d c b (c b (b a))));;\n- : ((((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n     (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n    ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'e -&gt; 'f) -&gt;\n   (((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n    (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'd -&gt; 'e) -&gt;\n   ((('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'c -&gt; 'd) -&gt;\n   (('a -&gt; 'b) -&gt; 'b -&gt; 'c) -&gt; ('a -&gt; 'b) -&gt; 'a -&gt; 'f\n= &lt;fun&gt;\n</code></pre>\n", 'ViewCount': '332', 'Title': 'Concise example of exponential cost of ML type inference', 'LastEditorUserId': '4554', 'LastActivityDate': '2012-11-11T20:23:32.303', 'LastEditDate': '2012-11-11T19:48:39.593', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '8', 'OwnerDisplayName': 'mrrusof', 'PostTypeId': '1', 'OwnerUserId': '4554', 'Tags': '<lambda-calculus><type-theory><functional-programming><type-inference><type-checking>', 'CreationDate': '2012-11-11T14:01:45.770', 'Id': '6617'},24_15:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '257', 'Title': 'How can SML infer types like this?', 'LastEditDate': '2013-02-02T13:58:58.873', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1590', 'FavoriteCount': '0', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Standard_ML" rel="nofollow">Wikipedia says</a>:</p>\n\n<pre><code>fun factorial n = \n    if n = 0 then 1 else n * factorial (n-1) \n</code></pre>\n\n<blockquote>\n  <p>A Standard ML compiler is required to infer the static type int -> int of this function\n  without user-supplied type annotations. I.e., it has to deduce that n\n  is only used with integer expressions, and must therefore itself be an\n  integer, and that all value-producing expressions within the function\n  return integers.</p>\n</blockquote>\n\n<p>I don\'t understand how a compiler could infer this. It sounds like SML is essentially solving the halting problem for the <code>factorial</code> function, and showing that it only halts on positive integer inputs. </p>\n\n<p>Am I missing something?</p>\n', 'Tags': '<compilers><functional-programming><type-theory><type-inference>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-25T06:37:00.357', 'CommentCount': '0', 'AcceptedAnswerId': '9411', 'CreationDate': '2013-02-01T23:24:31.383', 'Id': '9407'},24_16:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '490', 'Title': 'How are programming languages and foundations of mathematics related?', 'LastEditDate': '2013-02-15T00:34:04.040', 'AnswerCount': '2', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '268', 'FavoriteCount': '3', 'Body': '<p>Basically I am aware of three foundations for math</p>\n\n<ol>\n<li>Set theory</li>\n<li>Type theory</li>\n<li>Category theory</li>\n</ol>\n\n<p>So in what ways are programming languages and foundations of mathematics related?</p>\n\n<p>EDIT</p>\n\n<p>The original question was "Programming languages based on foundations of math" </p>\n\n<p>with the added paragarph of</p>\n\n<p>And implementations of theory<br>\n1. Type theory in <a href="http://coq.inria.fr/">Coq</a><br>\n2. Set theory in <a href="http://c2.com/cgi/wiki?SetlLanguage">SETL</a><br>\n3. Category theory in <a href="http://www.haskell.org/haskellwiki/Category_theory">Haskell</a></p>\n\n<p>Based on a suggestion this was changed to "How are programming languages and foundations of mathematics related"</p>\n\n<p>Since this is one of those questions were I did not know enough about what I was asking but wanted to learn something, I am modifing the question to make it more valuable for learning and others, yet leaving the details in so as not to make the <a href="http://cs.stackexchange.com/a/9763/268">current answer</a> by Andrej Bauer seem off topic.</p>\n\n<p>Thanks for all the comments and the answer so far, I am learning from them.</p>\n', 'Tags': '<programming-languages><history><type-theory><category-theory>', 'LastEditorUserId': '699', 'LastActivityDate': '2013-02-15T00:37:33.880', 'CommentCount': '2', 'AcceptedAnswerId': '9763', 'CreationDate': '2013-02-14T00:48:23.320', 'Id': '9756'},24_17:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p><strong>Edit:</strong> My original question referred to <em>nonconstructive</em> and <em>constructive</em> definitions of function types.  I changed the terminology in the question and the title to <em>semantic</em> and <em>syntactic</em>, which the answer indicates is the correct terminology for this distinction.</p>\n\n<p>I can recall two ways of defining functions in set theory and programming languages with set-theoretic foundations.  The function type $\\tau \\to \\sigma$ can be defined <em>semantically</em> as the set of all maps from $\\tau$ to $\\sigma \\cup \\{\\bot\\}$, i.e., all objects $f$ such that if $x \\in \\tau$ then $f(x) \\in \\sigma \\cup \\{\\bot\\}$.  Alternatively, the function type $\\tau \\to \\sigma$ can be defined <em>syntactically</em> as the set of all terms in a given language whose type is $\\tau \\to \\sigma$ (possibly modulo some equivalence relationship).  As a programmer, I work with the latter definition, but I often pretend that I'm working with the former definition.</p>\n\n<p>What are the differences between the inhabitants of $\\tau \\to \\sigma$ according to the two definitions above?  For instance, are uncomputable functions included in the first but not the second definition?</p>\n\n<p>To be precise, I'm interested in the situation where terms are strongly typed, functions are side effect free and may be nonterminating, and functions are equal iff, for all inputs, they both diverge or both return the same value.</p>\n", 'ViewCount': '184', 'Title': 'What is the difference between the semantic and syntactic views of function types?', 'LastEditorUserId': '2488', 'LastActivityDate': '2013-04-25T18:44:42.253', 'LastEditDate': '2013-04-25T18:44:42.253', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11422', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2488', 'Tags': '<terminology><programming-languages><type-theory>', 'CreationDate': '2013-04-19T18:53:30.153', 'Id': '11413'},24_18:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m working on a type system with extensible records, similar to ones explained in "<a href="http://web.cecs.pdx.edu/~mpj/pubs/polyrec.html" rel="nofollow">A Polymorphic Type System for Extensible Records and Variants - Benedict R. Gaster and Mark P. Jones</a>" and "<a href="http://research.microsoft.com/pubs/65409/scopedlabels.pdf" rel="nofollow">Extensible records with scoped labels - Daan Leijen</a>",</p>\n\n<p>I already have a working implementation but I followed a completely different path for implementation(for example, I didn\'t use kinds, instead I used different variables with different types, this also helped me add arbitrary properties to variables, like absent label list). Now I want to implement it like explained in this two papers,</p>\n\n<p>And the problem is, I can\'t see how can fields and rows with "absent" specifiers can be implemented. Both papers using a simple type constant for record update operations, but types or kinds are not allowing specifying field labels, or absent field names in row variables.</p>\n\n<p>So can anyone help me understand how can field labels and absent fields can be specified in simple kind/type system explained in these two papers?</p>\n\n<p>Thanks in advance.</p>\n\n<p>EDIT: To clarify things,</p>\n\n<p>Here\'s a language of kinds and types described in papers mentioned above: (in haskell syntax)</p>\n\n<pre><code>data Kind = KStar | KRow | KFun Kind Kind\n\ndata Type = TCon Typeconstant\n          | TVar Typevar\n          | TAp Type Type -- type application\n</code></pre>\n\n<p>What I meant to say was I couldn\'t see a way to encode row types with this language. ie. there is no way to encode type of this function:</p>\n\n<pre><code>row_extend r = r.a = 10\n</code></pre>\n\n<p>Because there is now way to tell in types that this function adds or updates \'a field with label <code>a</code>\'.</p>\n\n<p>I can\'t give types to record operations in this language(given as Haskell code above).</p>\n', 'ViewCount': '108', 'Title': 'Encoding row types', 'LastEditorUserId': '5209', 'LastActivityDate': '2013-04-28T10:44:55.337', 'LastEditDate': '2013-04-28T10:44:55.337', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5209', 'Tags': '<type-theory><type-inference><type-checking>', 'CreationDate': '2013-04-27T21:13:14.737', 'FavoriteCount': '1', 'Id': '11613'},24_19:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I think of type as a range of values that the variable can take whereas the rest is known constant or does not matter. Variables (instances or objects), which share common properties, are considered to belong to the same type/kind/class. That is, the type properties are constant across the type. The type is actually a common property of a class of objects (variables). The variables have a variable part, which may change, making them flipping from one subtype to the other. However, the same applies to subtypes: subtypes also share a common constant property.</p>\n\n<p>I may describe a class by a circle in Vienn Diagramm. Its subspheres would be types or variables. I think that the variable means that it has some fixed part, its type, and variable part, which make it variable and not constant. The constants or values would be an elementary point in the diagramm. </p>\n\n<p>For instance, integer is a subtype of real. Integer variable means that it can take concrete values within the range of the integer area. Similarly, boolean variables, taking only values 0 and 1, are subtype of integer. But, what is a constant 1? Is it a real or integer or boolean variable or it is a specific type, instances of which have a common property: they have a value of 1? Is it a known treatment?</p>\n\n<p>My interest stems from the practice: how can I save memory fixing the common part of variables in a language processing framework?</p>\n', 'ViewCount': '86', 'Title': 'Is constant a variable or subtype?', 'LastActivityDate': '2013-05-31T10:52:28.827', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<type-theory><type-inference><inductive-datatypes>', 'CreationDate': '2013-05-30T10:01:44.873', 'Id': '12372'},24_20:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '360', 'Title': 'What makes type inference for dependent types undecidable?', 'LastEditDate': '2013-10-09T18:44:37.213', 'AnswerCount': '1', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '8685', 'FavoriteCount': '1', 'Body': '<p>I have seen it mentioned that dependent type systems are not inferable, but are checkable. I was wondering if there is a simple explanation of why that is so, and whether or not there is there a limit of "dependency" where types can be indexed by values, below which type inference is possible and above which it is not?</p>\n', 'Tags': '<undecidability><type-theory><type-inference><dependent-types>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:37.213', 'CommentCount': '2', 'AcceptedAnswerId': '12957', 'CreationDate': '2013-06-15T15:35:18.983', 'Id': '12691'},24_21:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I often see claims that modern functional strictly-typed languages are 'safer' than others. These statement mostly linked with type systems and their ability to explicitly express the following sources of pitfalls:</p>\n\n<ul>\n<li>Alternatives in function result. Maybe and Either datatypes vs. exceptions and null-pointers in C++-like languages.</li>\n<li>Access to mutable state (possibly inconsistent behavior over time). State datatype in Haskell vs. variables in C++-like languages.</li>\n<li>Performing IO. IO datatype in Haskell vs. just doing things in C++-like languages.</li>\n</ul>\n\n<p>Haskell compiler is able to warn programmer when he doesn't properly handle theses kinds risky operations.</p>\n\n<p>Althought pitfalls above are definitely the most common ones I can see much more, for example:</p>\n\n<ul>\n<li>Unexpected resource consumption. Memory or CPU, the former is common for Haskell AFAIK.</li>\n<li>System-level failure. Like crashing process or pulled plug.</li>\n<li>Unexpected execution time for IO, timing violation.</li>\n</ul>\n\n<p>Is there languages, libraries or at least models which allow to express risks from the second set and yield a warning when they are not handled?</p>\n", 'ViewCount': '178', 'Title': 'What kinds of programming pitfalls modern languages are able to express?', 'LastActivityDate': '2013-07-06T03:11:55.510', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '13102', 'Score': '3', 'OwnerDisplayName': 'CheatEx', 'PostTypeId': '1', 'OwnerUserId': '8753', 'Tags': '<programming-languages><type-theory>', 'CreationDate': '2013-06-17T20:28:53.947', 'Id': '12759'},24_22:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In Type Theory if one allows Type to be a member of itself, it makes the theory inconsistent. I understand it by analogy to Russel's paradox in Set Theory, but would prefer to see it done in Type Theory. Is there a short example of the equivalent in Type Theory?</p>\n", 'ViewCount': '176', 'Title': 'Example of a false proposition when assuming Type : Type', 'LastActivityDate': '2013-06-27T23:12:55.163', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12933', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8685', 'Tags': '<type-theory>', 'CreationDate': '2013-06-27T15:25:42.773', 'FavoriteCount': '1', 'Id': '12929'},24_23:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I hope my question makes sense: Starting with the premise that the untyped $\\lambda $ calculus is equivalent in power to a Turing machine, to what in a Turing machine does adding types to the $\\lambda $ calculus correspond? Is there some kind of automaton analog to typing, whether static or dynamic?</p>\n', 'ViewCount': '123', 'Title': 'To what does typing correspond in a Turing Machine?', 'LastActivityDate': '2013-07-09T03:05:03.767', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<turing-machines><lambda-calculus><type-theory><church-turing-thesis>', 'CreationDate': '2013-07-08T05:47:39.780', 'FavoriteCount': '2', 'Id': '13158'},24_24:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am reading about dependent types theory in the <a href="http://homotopytypetheory.org/book/" rel="nofollow">Homotopy Type Theory</a> online book. </p>\n\n<p>In section 1.3 of the <em>Type Theory</em> chapter, it introduces the notion of hierarchy of <em>Universes</em>: $\\mathcal{U}_0 : \\mathcal{U}_1 : \\mathcal{U}_2 : \\cdots$, where</p>\n\n<blockquote>\n  <p>every universe $\\mathcal{U}_i$ is an element of the next universe $\\mathcal{U}_{i+1}$. Moreover, we assume that our universes are cumulative, that is that all the elements of the $i^{\\mathrm{th}}$ universe are also elements of\n  the $(i+1)^{\\mathrm{th}}$ universe.</p>\n</blockquote>\n\n<p>Yet, when I look at the formation rules for the various types in appendix A, at first glance, if a universe appears above the bar as a premise, the same universe appears below. For instance for the coproduct types formation rule:</p>\n\n<p>$$\\dfrac{\\Gamma \\vdash A : \\mathcal{U}_i \\quad \\Gamma \\vdash B : \\mathcal{U}i}{\\Gamma \\vdash A + B : \\mathcal{U}_i}(+\\mbox{-}FORM)$$</p>\n\n<p>So my question is why is a hierarchy necessary? <strong>Under what circumstances do you need to jump from a universe to one higher in the hierarchy?</strong> It is really not obvious to me how given any combination of $A_m: \\mathcal{U}_i$, you can end up with a type $B$ that is <strong>not</strong> in $\\mathcal{U}_i$. In more details: the formation rules in sections of the appendix A.2.4, A.2.5, A.2.6, A.2.7, A.2.8, A.2.9, A.2.10, A.3.2, either mention $\\mathcal{U}_i$ in the premise and judgement, or just in the judgement. </p>\n\n<p>The book also hints that there is a formal way to assign universes: </p>\n\n<blockquote>\n  <p>If there is any doubt about whether an\n  argument is correct, the way to check it is to try to assign levels consistently to all universes appearing in it.</p>\n</blockquote>\n\n<p><strong>What is the process for assigning levels consistently?</strong></p>\n\n<p><a href="http://cs.stackexchange.com/questions/12929/example-of-a-false-proposition-when-assuming-type-type">$\\mathcal{U}:\\mathcal{U}$ would lead to the Russell paradox</a>.\nAvoiding the Russell paradox is explicitly mentioned in the book (page 24). It also goes into more details page 54, 55 that is uses \u201cRussell-style universes\u201d rather than \u201cTarski-style universes\u201d. So at a very high level, I take for granted that the theory wants to avoid the paradox. Unfortunately I don\'t have the background to make sense of out that directly. What I am after in this question, is really just scratching the surface by getting some examples of things in $\\mathcal{U}_j$ and not in $\\mathcal{U}_i$ for $j &gt; i$ and may be anything else that give me a feel for how the hierarchies work. </p>\n', 'ViewCount': '172', 'Title': 'Universes in dependent type theory', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:44:30.993', 'LastEditDate': '2013-10-09T18:44:30.993', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '13296', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9179', 'Tags': '<type-theory><homotopy-type-theory><dependent-types>', 'CreationDate': '2013-07-15T13:01:16.747', 'Id': '13285'},24_25:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>From the Introduction section of Homotopy Type Theory book:</p>\n\n<blockquote>\n  <p>Type theory was originally invented by Bertrand Russell ... It was later developed as a rigorous formal system in its own right(under tha name "$\\lambda$-calculus").</p>\n</blockquote>\n\n<p>Can anyone explain me this sentence? I\'m having trouble seeing $\\lambda$-calculus as a type system.</p>\n\n<p>(also in the same paragraph, $\\lambda$-calculus called as "Church\'s type system")</p>\n', 'ViewCount': '127', 'Title': 'lambda calculus as a type theory', 'LastActivityDate': '2013-08-12T06:52:18.220', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '13717', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5209', 'Tags': '<lambda-calculus><type-theory>', 'CreationDate': '2013-08-11T20:01:40.917', 'Id': '13712'},24_26:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I recently realized that there is some sort of relation between Russellian type theory and type systems, as found e.g. in Haskell. Actually, some of the notation for types in Haskell seems to have precursors in type theory. But, IMHO, Russell motivation in 1908 was to avoid Russell's paradox, and I am not sure how that is related to type systems in computer science. Is Russell's paradox in one form or another something that we would have to worry about, for example, if we didn't have a good type system in a given language? </p>\n", 'ViewCount': '485', 'Title': 'Type theory and type systems', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-16T19:21:41.250', 'LastEditDate': '2013-08-15T10:17:26.157', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '9667', 'Tags': '<programming-languages><type-theory>', 'CreationDate': '2013-08-15T00:09:23.097', 'FavoriteCount': '1', 'Id': '13749'},24_27:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Most specifically, his use of small epsilon introduced at the end of section 1 of "Types, Abstraction and Parametric Polymorphism" is throwing me, but in general I would like references to symbols in the Type and Logical Relations literature.</p>\n', 'ViewCount': '51', 'Title': 'Looking for cheat sheet to J.C. Reynolds symbols', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T10:46:17.957', 'LastEditDate': '2013-08-27T10:46:17.957', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13957', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9831', 'Tags': '<terminology><reference-request><type-theory><abstract-data-types>', 'CreationDate': '2013-08-27T03:17:11.390', 'Id': '13954'},24_28:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I understand that $\\Pi$ types are generalizations of functions and can be interpreted similar to $\\forall$ in logic. I also know that $\\Sigma$ types are generalizations of tuples and can be interpreted similar to $\\exists$ in logic. But whereas I find it easy to imagine $\\Pi$ type examples by thinking in Haskell, I am having a hard time thinking of good examples of $\\Sigma$ types. Is there a particular "canonical" $\\Sigma$ type that gives a good indication of how it can be interpreted as existence when the type is thought of as a proof? </p>\n', 'ViewCount': '101', 'Title': 'Example of existence proof in dependent typing?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-09T18:45:26.560', 'LastEditDate': '2013-10-09T18:45:26.560', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9918', 'Tags': '<type-theory><dependent-types>', 'CreationDate': '2013-08-31T16:15:52.920', 'Id': '14060'},24_29:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>What would be the best introduction to Per Martin-L\xf6fs ideas about type theory? I've looked at some lectures from the Oregon PL summer school, but I'm still sort of puzzled by the following question:</p>\n\n<p><em>What is a type?</em></p>\n\n<p>I know what a set is, since you can define them by the usual ZF axioms and they have a very intuitive concrete model; just think of a basket filled with stuff. However, I've yet to see a reasonable definition of a type and I was wondering if there is some source that would distill this idea for dummy.</p>\n", 'ViewCount': '320', 'Title': u'Intro to Martin-L\xf6f type theory', 'LastActivityDate': '2013-10-03T06:29:23.547', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '14686', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '10394', 'Tags': '<logic><type-theory>', 'CreationDate': '2013-09-29T16:38:12.663', 'FavoriteCount': '2', 'Id': '14674'},24_30:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am looking into Hindler-Milney type system and I am trying to add support for\nthe pair type. In Pierces book, he introduces special language constructs for creation of pairs and getting their elements.</p>\n\n<p>What I am interested in is the following. What if I don't introduce new constructs, yet use special functions with this signatures: </p>\n\n<p>$$pair: \\alpha \\rightarrow \\beta \\rightarrow \\alpha \\times \\beta $$ </p>\n\n<p>$$proj1: \\alpha \\times \\beta \\rightarrow \\alpha$$ </p>\n\n<p>$$proj2: \\alpha \\times \\beta \\rightarrow \\beta $$</p>\n\n<p>If I use Wand's algorithm for type inference, after collecting all equations between type expressions and solving it a bit, I get the following equation\nfor $((pair\\; 2\\;) 4): \\tau$:</p>\n\n<p>$$\\alpha \\rightarrow \\beta \\rightarrow \\alpha \\times \\beta = Int \\rightarrow Int \\rightarrow \\tau$$</p>\n\n<p>It seems to me that the unification algorithm should infer at the end that $\\tau = Int \\times Int$. Is this true? </p>\n\n<p>Do I really need a special construct for pairs? Is there something conceptually wrong with this? Probably their is, so it would be great if someone could point me out. </p>\n\n<p>Note that I would also prefer using special constructs as that way looks cleaner and easier to program with; this question is just for my complete understanding of the subject.</p>\n", 'ViewCount': '51', 'Title': 'Type inference of pair (product) types', 'LastActivityDate': '2013-10-02T20:49:19.097', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14759', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<type-theory><type-inference><unification>', 'CreationDate': '2013-10-02T15:57:00.007', 'Id': '14754'},24_31:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '111', 'Title': "does godel's incompleteness theorem shed any light on dynamic vs typed languages?", 'LastEditDate': '2013-10-06T02:54:59.880', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1800', 'Body': '<p>I\'m clojure user myself. I\'m trying really hard to learn haskell and to better understand the type system. However, I feel that trying to \'type\' everything is quite restrictive when the problem or the data is less defined.</p>\n\n<p>I intuitively feel that godel\'s incompleteness theorem offers some insight into the typed/untyped debate. What are some simple problems that may trip up the typing system but not untyped ones?</p>\n\n<hr>\n\n<p>According to <a href="http://en.wikipedia.org/wiki/Type_theory" rel="nofollow">http://en.wikipedia.org/wiki/Type_theory</a>. "The types of type theory were invented by Bertrand Russell in response to his discovery that Gottlob Frege\'s version of naive set theory was afflicted with Russell\'s paradox. This theory of types features prominently in Whitehead and Russell\'s Principia Mathematica. It avoids Russell\'s paradox by first creating a hierarchy of types, then assigning each mathematical (and possibly other) entity to a type. Objects of a given type are built exclusively from objects of preceding types (those lower in the hierarchy), thus preventing loops."</p>\n\n<p>Godel\'s theorem invalidated Principia Mathematica. What consequence does it have on Type Theory.</p>\n', 'ClosedDate': '2013-10-28T20:59:58.373', 'Tags': '<type-theory>', 'LastEditorUserId': '1800', 'LastActivityDate': '2013-10-08T01:57:12.500', 'CommentCount': '5', 'AcceptedAnswerId': '14803', 'CreationDate': '2013-10-03T22:20:25.500', 'Id': '14799'},24_32:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>While studying for a test in my OOP course, I came upon this question which had an answer I didn\'t really understand. The question is as follows (translated):</p>\n\n<p>The programming language "Sava" is similar to Java in every way except in the following: </p>\n\n<ol>\n<li>It\'s structurally typed</li>\n<li>When overriding a method the argument can be contravariant and the return type can be covariant.  </li>\n</ol>\n\n<p>Given the following class and interface, is the following assignment legal?</p>\n\n<pre><code>  interface I{\n    boolean equals(I i){\u2026}\n  } \n\n  class C{\n    boolean equals(C c){\u2026}\n  }\n\nI i = new C();\n</code></pre>\n\n<p>The answer that was given to this question was:\nThe assignment isn\'t legal. The equals method in C changes the paramater in a covariant way and so it doesn\'t match the equals method in I.</p>\n\n<p>At first I thought the professor forgot to add "Implements I" but the answer also stated the following:\nAnswers that refereed to the fact that C doesn\'t implement I weren\'t accepted because given that it\'s a Structurally Typed language it doesn\'t matter if it were a subtype. </p>\n\n<p>I\'m not sure I understand how we can refer to these methods as covariant / contravariant if there is no relation of subtyping between C and I. </p>\n\n<p>Can anyone clear this up for me?</p>\n', 'ViewCount': '112', 'Title': 'Java, strong typing, covariance and contra-variance', 'LastActivityDate': '2013-10-17T16:29:03.723', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10801', 'Tags': '<type-theory><java>', 'CreationDate': '2013-10-16T20:52:01.983', 'Id': '16148'},24_33:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I program in Python, which is a well-known dynamically typed language. I understand dynamic typing to mean mainly that "operations" (in a loose sense) in the language are either allowed or denied (raise an exception) based on the type of their operands, and that this type-checking is deferred as long as possible. My question is this: if that is what a fair characterization of dynamic languages, <strong>what would happen if the run-time type checking was removed</strong>?</p>\n\n<p>It seems to me that if you want to make a meaningful distinction between a dynamically typed language like Python and an <em>untyped</em> language, you would have to define what actually would happen in the untyped language in situations in which the type system of a dynamic language would take action. For example, in Python, if I attempt to subtract an Integer from a String, e.g., "spam" - 5, I receive a TypeError. If that\'s what makes Python dynamically typed, what would an "untyped Python" do in that situation?</p>\n', 'ViewCount': '212', 'Title': 'What would dynamically-typed languages actually do if type enforcement was removed?', 'LastActivityDate': '2013-11-13T19:37:58.013', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '17996', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<programming-languages><type-theory><type-checking>', 'CreationDate': '2013-11-13T15:48:41.380', 'Id': '17987'},24_34:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I always see that people in the fields consider confusing vectors with positions as a severe error <a href="http://math.stackexchange.com/questions/384927">in one</a> and <a href="http://gamedev.stackexchange.com/a/62789/35556">n dimensions</a>. Recently I have also <a href="http://stackoverflow.com/questions/19952551">encoutered a timedelta type in Python</a>. By increadably inadequate reaction and severe punishment, I realize that people in the fields taboo answering why is the difference.</p>\n\n<p>Might be the computer scientists are different and can tell the principal difference among the types. Does time differece has different nature from the datetime? Does <code>a = b-c</code> has the same nature as the <code>b</code> and <code>c</code>? In which case do you introduce a new type? Why do <a href="http://stackoverflow.com/questions/19952551/why-dont-we-have-intdelta-a-qustin-about-timedelta#comment29699311_19952607">they say that <code>a</code> has the same type in case of int</a> but not in case of time or position? </p>\n\n<p>Is this related to dimensional analysis?  It seems like dimensional analysis would say that <code>a</code> has the same unit of measurement (and therefore the type) as the <code>b</code> and <code>c</code> in <code>a=b-c</code>.  Is this correct?</p>\n', 'ViewCount': '78', 'Title': 'Type for difference of two absolute values', 'LastEditorUserId': '2879', 'LastActivityDate': '2013-11-29T21:53:57.000', 'LastEditDate': '2013-11-29T21:53:57.000', 'AnswerCount': '1', 'CommentCount': '12', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<type-theory>', 'CreationDate': '2013-11-29T12:19:34.340', 'Id': '18466'},24_35:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>On <a href="http://en.wikipedia.org/wiki/Pizza_%28programming_language%29" rel="nofollow">this page describing the precursor to the Scala language</a> - the pizza language - they refer to it having both case classes and <a href="http://en.wikipedia.org/wiki/Pattern_matching" rel="nofollow">pattern matching</a> - and then imply that these taken together provide <a href="http://en.wikipedia.org/wiki/Algebraic_data_type" rel="nofollow">algebraic types</a>. </p>\n\n<p>Is this the case? To provide algebraic types - do you combine <a href="http://en.wikipedia.org/wiki/Scala_%28programming_language%29#Case_classes_and_pattern_matching" rel="nofollow">case classes and pattern matching</a>?</p>\n', 'ViewCount': '33', 'Title': 'Are Algebraic types just the combination of case classes and pattern matching?', 'LastActivityDate': '2013-12-07T10:26:16.887', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18712', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<type-theory><pattern-recognition><abstract-data-types>', 'CreationDate': '2013-12-07T10:12:33.263', 'Id': '18711'},24_36:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="http://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/" rel="nofollow">Some claim</a> that dynamically typed languages are in reality statically typed, unityped languages. This would imply to me that this one type should be expressible as a static, finite type expression, so can anyone provide such an expression? You can make whatever assumptions you need to make about the base types in the language, but please make sure the language would support types of unbounded size, e.g., lists, recursive types. It would also be nice if it supported records and variants, but whatever helps to illustrate the point will work. I\'m also assuming that the language will be required to support some form of sum type, right?</p>\n', 'ViewCount': '57', 'Title': 'If dynamically typed languages are truly statically typed, unityped languages, what is the (finite) type expression of the one type?', 'LastActivityDate': '2014-02-07T21:24:14.177', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<programming-languages><type-theory><typing>', 'CreationDate': '2013-12-11T00:05:49.997', 'Id': '18847'},24_37:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '441', 'Title': 'What were the research outcomes of the Univalent Foundations Program year (Homotopy Type Theory)', 'LastEditDate': '2013-12-15T05:57:58.050', 'AnswerCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1709', 'FavoriteCount': '2', 'Body': u'<p>The Institute for Advanced Study <a href="http://homotopytypetheory.org/events/" rel="nofollow">has had</a> a year-long special program devoted to the <a href="http://homotopytypetheory.org/" rel="nofollow">Univalent Foundations Program</a>. </p>\n\n<p>At the end of this they have produced a <a href="http://homotopytypetheory.org/book/" rel="nofollow">book</a> and a <a href="https://github.com/HoTT/HoTT" rel="nofollow">code repository</a>. </p>\n\n<p>At the end of this we see a blog entry in Scientific American claiming:</p>\n\n<p><em>...it could provide a new, self-contained foundation for all of mathematics.</em></p>\n\n<p>Now this is a bold claim. By contrast I can see humbler claims such as a simple proof in Agda <a href="http://brianmckenna.org/blog/plus_equals_even_take_2" rel="nofollow">that the sum of two odds is always an even</a>. </p>\n\n<p>My question is: <strong>What novel research did these guys actually produce at the end of the year?</strong> All the article indicates is that they wrote some code in Agda. Is it just that we have a new view of Martin-L\xf6f type theory with some applications?</p>\n\n<p><strong>Assumptions</strong></p>\n\n<ul>\n<li>I understand the broader ideas of Martin-L\xf6f type theory as it relates to the isomorphism between Types and Proofs. </li>\n</ul>\n', 'Tags': '<homotopy-type-theory>', 'LastEditorUserId': '1709', 'LastActivityDate': '2013-12-15T07:37:40.813', 'CommentCount': '3', 'AcceptedAnswerId': '19004', 'CreationDate': '2013-12-15T05:23:21.830', 'Id': '19001'},24_38:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the introduction of the book by B.Jacobs, "Categorical Logic and Type Theory" (it\'s online <a href="http://synrc.com/publications/cat/Category%20Theory/Categorical%20Logic/Jacobs%20B.%20Categorical%20Logic%20and%20Type%20Theory.pdf" rel="nofollow">here</a>), he classifies type systems into three general flavours: Simply typed ones, depended typed (term depended types) and polymorphic types (type depended types). He says also there are also mix types. </p>\n\n<p>Now if you start out with a dependently types theory and introduce transitive universes, hence forcing types on the level of terms, are you automatically speaking of a polymorphic type system then?</p>\n', 'ViewCount': '31', 'Title': 'Does types being terms imply your dependend theory is considered polymorphic?', 'LastActivityDate': '2013-12-16T23:43:06.890', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19054', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2695', 'Tags': '<type-theory><dependent-types>', 'CreationDate': '2013-12-16T23:07:20.903', 'Id': '19053'},24_39:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>In the pre-history of dependent type theory, Per Martin L\xf6f\nintroduced a calculus that is in some sense the simplest dependent\ntype theory and the most general form of impredicative polymorphism.\nIt is often referred to as <strong><em>Type:Type</em></strong> because the kind <strong><em>Type</em></strong> is\nitself of type <strong><em>Type</em></strong>.  Unfortunately, it is inconsistent as a\nlogic. This was discovered by Girard in his famous dissertation [1],\nwho managed to express the Burali-Forti paradox in <strong><em>Type:Type</em></strong>.\nVarious people have analysed, generalised and simplified Girard's\nanalysis, see e.g. [2, 3]. This analysis seems to involve showing that\nnon-terminating terms can be typed.</p>\n\n<p>I have a question about non-termination: do we get non-normalisation <strong><em>at\nthe level of types</em></strong>? By that I mean, is there a type $T$ such that the\nreduction relation $\\rightarrow$ used, explicitly or implicitly, to\ndefine equality of types, gives rise to an infinite reduction sequence\n$$\n   T \\rightarrow T' \\rightarrow T'' \\rightarrow \\cdots?\n$$</p>\n\n<p>[1] J.-Y.. Girard, Une extension de l'interpretation fonctionelle de\nG\xf6del a l'analyse.</p>\n\n<p>[2] T. Coquand, A New Paradox in Type Theory.</p>\n\n<p>[3] A. J. C. Hurkens, A Simplification of Girard's Paradox.</p>\n", 'ViewCount': '68', 'Title': u"Non-termination of types in Martin-L\xf6f's Type:Type?", 'LastEditorUserId': '2887', 'LastActivityDate': '2013-12-19T12:26:08.823', 'LastEditDate': '2013-12-19T12:26:08.823', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19072', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<type-theory><functional-programming><dependent-types><curry-howard>', 'CreationDate': '2013-12-17T14:11:17.690', 'Id': '19065'},24_40:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I see how objects in a category stand for types, but where do I find the terms and more specifically the rules which tell me which of them are allowed? When I e.g. consider a <a href="http://en.wikipedia.org/wiki/Cartesian_closed_categories#Definition" rel="nofollow">Cartesian closed category</a> as model of a type theory, how are term constructors represented? </p>\n\n<p>I guess this is the same as asking how do I know or specify appropriately what the homsets of this category are, which I assume are in bijection with the lambda terms. The Curry\u2013Howard\u2013Lambek correspondence as presented at the end of the Wikipedia page <a href="http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="nofollow">Curry\u2013Howard\u2013Lambek correspondence</a> presents all terms conventionally as in a type theory, but if I start out with a category, the model, then I must have specified them in a more algebraic sense. </p>\n\n<p>And once given, does the model also represent $\\beta$ and $\\eta$ conversion? I actually read on the (quite too high level for me) <a href="http://ncatlab.org/nlab/show/syntactic+category" rel="nofollow">nLab</a> that morphisms relate to substitutions. Then I guess the lambda terms are somehow elements of the objects.</p>\n', 'ViewCount': '81', 'Title': 'What do functions look like, if I stated out with the categoical model of my type theory?', 'LastEditorUserId': '1329', 'LastActivityDate': '2013-12-18T09:07:40.443', 'LastEditDate': '2013-12-18T07:30:07.547', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19089', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2695', 'Tags': '<lambda-calculus><type-theory><category-theory>', 'CreationDate': '2013-12-17T22:59:56.883', 'Id': '19074'},24_41:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd like to have this feature in my application programming language (which these days, is Scala), but when I went to learn more about it on the internets, I realized I don't know the name of it.  I'm talking about the ability to do this (in Scala-ish pseudocode):</p>\n\n<pre><code>// Define some types that correspond to table rows in relational DB\nclass User \n   val id: Int\n   val name: String\n   val email: String\n   val created: DateTime\n\nclass Comment\n   val id: Int\n   val text: String\n   val userId: Int\n   val created: DateTime\n\n// Call a select/join query function\nval list = select c.id, c.text, u.name\n           from comments c join user u on c.userId = u.id ...\n</code></pre>\n\n<p>And then <code>list</code> gets a type of something like <code>List[R]</code> where <code>R</code> is an unnamed record type with properties <code>id</code>, <code>text</code>, <code>name</code>, or maybe <code>c.id</code>,<code>c.text</code>,<code>u.name</code>.  </p>\n\n<p>Some languages, like Scala, support you writing that select function so it returns a tuple type <code>(Int, String, String)</code>, but not a type with <em>named</em> fields.  </p>\n\n<p>Is there a name for that?</p>\n", 'ViewCount': '46', 'Title': "In type systems, is there a name for SQL's way of cutting and combining record types into new types?", 'LastEditorUserId': '268', 'LastActivityDate': '2013-12-20T18:10:56.257', 'LastEditDate': '2013-12-19T23:13:15.347', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19162', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12246', 'Tags': '<type-theory><type-checking><notation>', 'CreationDate': '2013-12-19T23:07:48.913', 'Id': '19134'},24_42:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Philip Wadler has written a <a href="http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf" rel="nofollow">brilliant paper</a> called \'Theorems for Free\'. The big idea is that you can use types to reason about your program, and even prove simple theorems about your program. </p>\n\n<p>We see these ideas about types applied in the Haskell language. </p>\n\n<p>At very roughly the same time period - we have an <a href="http://en.wikipedia.org/wiki/Design_by_contract" rel="nofollow">idea from Betrand Meyer called \'Design By Contract\'</a>- which is most notably implemented in the <a href="http://en.wikipedia.org/wiki/Eiffel_%28programming_language%29" rel="nofollow">Eiffel Language</a>. This has the following features:</p>\n\n<ul>\n<li>routine preconditions</li>\n<li>routine postconditions</li>\n<li>class invariants</li>\n<li>check instructions (like assert)</li>\n<li>loop invariants</li>\n</ul>\n\n<p>The idea behind Design by Contract is <em>software designers should define formal, precise and verifiable interface specifications for software components, which extend the ordinary definition of abstract data types with preconditions, postconditions and invariants.</em></p>\n\n<p>Now many claim that using \'Types\' in your programs leads to \'more correct programs\' (via the <a href="http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="nofollow">Howard Curry Correspondence</a>).  From what I can see - even the most advanced use of <a href="http://www.infoq.com/presentations/scala-idris" rel="nofollow">Dependent Typing in Idris and Scala</a> is limited to Sum Types and list lengths (correct me if I\'m wrong). </p>\n\n<p>By contrast - the power of \'Design By Contract\' in establishing the correctness of my program is more general and more powerful. (Albeit not necessarily at compile-time - but at test time). I can for example establish in my banking program that all deposits are positive, and all reported account balances are positive. </p>\n\n<p>The point being - types have a fascinating future of possibilities, and are enormously powerful and compile time - but right now their practical application seems limited. </p>\n\n<p>My question is: <strong>is design by contract of more general application than using theorems from types to reason about the correctness of my program at present?</strong> (Or are we just talking about two different things)</p>\n', 'ViewCount': '79', 'Title': "Is Wadler's 'Theorems for Free' as general as Design By Contract for establishing correctness?", 'LastActivityDate': '2014-02-05T22:30:30.147', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21332', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1709', 'Tags': '<type-theory><curry-howard>', 'CreationDate': '2013-12-19T23:14:12.743', 'Id': '19135'},24_43:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Say I have Simply typed lambda calculus, and add an assignment rule:</p>\n\n<pre><code>&lt;identifier&gt; : &lt;type&gt; = &lt;abstraction&gt;\n</code></pre>\n\n<p>Where <code>&lt;identifier&gt;</code> is the name of the function, <code>&lt;type&gt;</code> is the function type and <code>&lt;abstraction&gt;</code> is the abstraction to be assigned to the identifier. </p>\n\n<p>Then I add a typing rule that says that when you see an assignment such as the above, you use a temporary type context, in which the declared type (the one in <code>&lt;identifier&gt; : &lt;type&gt;</code>) is associated with the identifier, to type check <code>&lt;abstraction&gt;</code> and then make sure the declared type equals the abstraction\'s type.</p>\n\n<p>And finally I add another rule that would let me have a list of assignments on top of a lambda term which is the one I\'d evaluate, such that all these assignments would be added to the global scope before the term is evaluated.</p>\n\n<p>Seems to me that this alone would make it Turing complete since I\'d be able to do stuff like:</p>\n\n<pre><code>stackoverflow: NUM -&gt; NUM = \u03bbn:NUM.(stackoverflow n)\n(stackoverflow 0)\n</code></pre>\n\n<p>And at the same time, everything I can define in this language would be "well typed" in the sense that it wouldn\'t be able to define infinite types (I wouldn\'t be able to define the Y combinator).</p>\n\n<p>So my questions are, is this really Turing complete? And, am I missing something when I say everything would be "well typed" (like for instance, I could define the Y combinator in a way I haven\'t yet realized or is there any gotcha in this type system)?</p>\n', 'ViewCount': '63', 'Title': 'Would adding recursive named functions to Simply typed lambda calculus make it Turing complete?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-22T17:08:16.207', 'LastEditDate': '2013-12-22T17:08:16.207', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '19193', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><recursion><type-theory><turing-completeness><typing>', 'CreationDate': '2013-12-22T05:19:44.457', 'Id': '19187'},24_44:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m reading about this algorithm while writing an implementation, and see that, as long as every variable is bound, you\'ll always get either atomic types or types where the arguments will determine the final type, such as <code>t1 -&gt; t1</code> or <code>(t1 -&gt; t2) -&gt; (t1 -&gt; t2)</code>. </p>\n\n<p>I cannot think of a way you\'d get something like <code>t1 -&gt; t2</code> or simply <code>t1</code>, which I understand would mean the algorithm is broken since there would be no way to determine the actual type of the expression. How do you know you\'ll never get a type such as these "broken" ones as long as every variable is bound?</p>\n\n<p><strong>EDIT</strong> Seems that you can get these "broken" types in ML, but I\'m asking about lambda calculus.</p>\n', 'ViewCount': '97', 'Title': 'Why will the Hindley-Milner algorithm never yield a type like t1 -> t2?', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-01-01T17:44:44.103', 'LastEditDate': '2014-01-01T17:44:44.103', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '19431', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><type-theory><typing><type-inference>', 'CreationDate': '2014-01-01T03:28:39.107', 'Id': '19430'},24_45:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know that <a href="https://en.wikipedia.org/wiki/Idris_%28programming_language%29" rel="nofollow">Idris</a> has dependent types but isn\'t turing complete. What can it not do by giving up Turing completeness, and is this related to having dependent types?</p>\n\n<p>I guess this is quite a specific question, but I don\'t know a huge amount about dependent types and related type systems.</p>\n', 'ViewCount': '236', 'Title': 'What can Idris not do by giving up Turing completeness?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-18T14:35:33.427', 'LastEditDate': '2014-01-08T10:31:43.087', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12668', 'Tags': '<computability><programming-languages><type-theory><dependent-types>', 'CreationDate': '2014-01-08T09:57:09.923', 'FavoriteCount': '1', 'Id': '19577'},24_46:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've just now studied about covariance and contravariance in static languages (more specifically C#). This concept is rather clear to me, however I'm in doubt on how this applies to dynamic languages like Python.</p>\n\n<p>Since Python is duck typed (or structural typed) it seems to me that there is not even a notion of variance and covariance in this language?</p>\n\n<p>If I'm not mistaking, things like contravariance and covariance are checked at compile-time in a language like C#, this is possible because a variable has a type, and the value it is bound to has a type as well and these have to match or be co(ntra)- or invariant. However, since there is no notion of typing at compile-time with a language like Python I don't know how to apply this concept.</p>\n\n<p>Any thoughts?</p>\n\n<p>My thoughts: The concept of covariance means that whenever we expect a type of X, any subclass of X will do as well. So, in Python this doesn't come up, because there is no type check to do this. The only check that happens is wether or not the object has the necessary implementations by means of methods and attributes.</p>\n\n<p>In C# for example where we have a method:</p>\n\n<pre><code>void DoStuff(Person p)\n{\n    p.Dance();\n};\n</code></pre>\n\n<p>We could very well call this method with an instance of a Student (if this is a subclass of Person).</p>\n\n<p>Now, in Python, we could very well pass in a Bird object that would not be related to Person in any way in the inheritance hierarchy(except it would also inherit from object), as long as this bird implements <code>Dance()</code>.</p>\n\n<p>This is why I'm asking about this concept. From what I understand Python is covariant and contravariant in.. well, everything?</p>\n", 'ViewCount': '62', 'Title': 'Can parameters be contra- or covariant in Python?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T19:44:37.653', 'LastEditDate': '2014-01-09T16:02:15.860', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21327', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12703', 'Tags': '<programming-languages><type-theory>', 'CreationDate': '2014-01-09T14:44:25.267', 'Id': '19598'},24_47:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In another <a href="http://cs.stackexchange.com/q/19767/268">question</a> about Lambda Calculus, Andrej Bauer made the comment:</p>\n\n<blockquote>\n  <p>Lambda calculi of various forms are formal systems. They consist of\n  abstract syntax (for terms and for types, if present), judgments\n  (typing judgments and equations), and rules of inference. They are not\n  programming languages (unless we prescribe operational semantics) and\n  neither is it the case that a type system equals a program that checks\n  types. So I think this whole question is a bit misdirected, still. Of\n  course, an important aspect of a type system is how to implement it on\n  a computer, which brings in questions about algorithms, etc. But a\n  priori, the type system has none of that.</p>\n</blockquote>\n\n<p>I understand most of this, but I cannot wrap a logical understanding around:</p>\n\n<blockquote>\n  <p>neither is it the case that a type system equals a program that checks types.</p>\n</blockquote>\n\n<p>My understanding of a type system is that it is a set of rules in a formal system used to determine if a type is valid in a context and that those rules, via implementation, are used to establish the validity of a use of a type in a context in a programming language. </p>\n\n<p>However the statement has me thinking there is no connection, or that there is more meaning to the statement but I don\'t see the details to separate a type system from a program or make a logical connection between the two so that the statement makes sense.</p>\n\n<p>What is the relation between a type system and a program?</p>\n', 'ViewCount': '65', 'Title': 'How is a type system related to a progam?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T21:46:04.050', 'LastEditDate': '2014-01-17T21:44:52.757', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '21329', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<programming-languages><type-theory><typing><type-checking>', 'CreationDate': '2014-01-17T18:35:03.183', 'Id': '19789'},24_48:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '52', 'Title': 'Are references of any use without updating?', 'LastEditDate': '2014-01-22T15:39:16.083', 'AnswerCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5291', 'FavoriteCount': '1', 'Body': '<p>Almost all type-theoretical treatments of references that I\'ve studied introduce references as accompanied with at least three operations (sometimes including the fourth):</p>\n\n<ol>\n<li>Construction (allocation): $ \\text{ref } e $</li>\n<li>Elimination (dereferencing): $ !e $</li>\n<li>Updating: $ e_1 := e_2 $</li>\n<li>(not as common) Destruction (deallocation): $ \\text{free } e $</li>\n</ol>\n\n<p>My question is this: Would references be of any use without updating (construct #3 above)? If so, what would be a common use? Does the ability to use updates with references lend any more "power" to a language? You can answer assuming either the presence or absence of construct #4 above; if it affects your answer, please explain how.</p>\n', 'Tags': '<programming-languages><type-theory>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-05T21:57:35.170', 'CommentCount': '2', 'AcceptedAnswerId': '19894', 'CreationDate': '2014-01-22T14:27:38.203', 'Id': '19892'},24_49:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '143', 'Title': 'Define a list using only the Hindley-Milner type system', 'LastEditDate': '2014-01-30T20:26:58.877', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '10401', 'FavoriteCount': '3', 'Body': u'<p>I\'m working on a small lambda calculus compiler that has a <a href="http://codereview.stackexchange.com/questions/38763/is-this-implementation-of-the-hindley-milner-algorithm-correct">working Hindley-Milner type inference system</a> and now also supports recursive let\'s (not in the linked code), which I understand <a href="http://cs.stackexchange.com/questions/19187/would-adding-recursive-named-functions-to-simply-typed-lambda-calculus-make-it-t">should be enough to make it Turing complete</a>. </p>\n\n<p>The problem now is I have no idea how to make it support lists, or whether it already does support them and I just need to find a way to encode them. I\'d like to be able to define them without having to add new rules to the type system.</p>\n\n<p>The easiest way I can think of a list of <code>x</code> is as something that is either <code>null</code> (or the empty list), or a pair that contains both an <code>x</code> and a list of <code>x</code>. But to do this I need to be able to define pairs and or\'s, which I believe are the product and the sum types.</p>\n\n<p>Seems that I can define pairs this way:</p>\n\n<pre><code>pair = \u03bbabf.fab\nfirst = \u03bbp.p(\u03bbab.a)\nsecond = \u03bbp.p(\u03bbab.b)\n</code></pre>\n\n<p>Since <code>pair</code> would have the type <code>a -&gt; (b -&gt; ((a -&gt; (b -&gt; x)) -&gt; x))</code>, after passing, say, an <code>int</code> and a <code>string</code>, it\'d yield something with type <code>(int -&gt; (string -&gt; x)) -&gt; x</code>, which would be the representation of a pair of <code>int</code> and <code>string</code>. What bothers me here is that if that represents a pair, why is that not logically equivalent to, nor implies the proposition <code>int and string</code>?. However, is equivalent to <code>(((int and string) -&gt; x) -&gt; x)</code>, as if I could only have product types as parameters to functions. <a href="http://mathoverflow.net/a/151319">This answer</a> seem to address this problem, but I have no idea what the symbols he uses mean. Also, if this does not really encode a product type, is there anything I can do with product types I couldn\'t do with my definition of pairs above (considering I can also define n-tuples the same way)? If not, wouldn\'t this contradict the fact that you cannot express (AFAIK) conjunction using only implication?</p>\n\n<p>Also, how about the sum type? Can I somehow encode it using only the function type? If so, would this be enough to define lists? Or else, is there any other way to define lists without having to extend my type system? And if not, what changes would I need to make if I want to keep it as simple as possible?</p>\n\n<p>Please keep in mind that I\'m a computer programmer but not a computer scientist nor a mathematician and pretty bad at reading math notation.</p>\n\n<p><strong>Edit:</strong>  I\'m not sure what\'s the technical name of what I have implemented so far, but all I have is basically the code I\'ve linked above, which is a constraint generation algorithm that uses the rules for applications, abstractions and variables taken from the Hinley-Milner algorithm and then a unification algorithm that gets the principal type. For instance, the expression <code>\\a.a</code> will yield the type <code>a -&gt; a</code>, and the expression <code>\\a.(a a)</code> will throw an occurs check error. On top of this, there is not exactly a <code>let</code> rule but a function that seems to have the same effect that lets you define recursive global functions like this pseudo-code:</p>\n\n<pre><code>GetTypeOfGlobalFunction(term, globalScope, nameOfFunction)\n{\n    // Here \'globalScope\' contains a list of name-value pair where every value is of class \'ClosedType\', \n    // meaning their type will be cloned before unified in the unification algorithm so that they can be used polymorphically \n    tempType = new TypeVariable() // Assign a dummy type to `tempType`, say, type \'x\'.\n    // The next line creates an scope with everything in \'globalScope\' plus the \'nameOfFunction = tempType\' name-value pair\n    tempScope = new Scope(globalScope, nameOfFunction, tempType) \n    type = TypeOfTerm(term, tempScope) // Calculate the type of the term \n    Unify(tempType, type)\n    return type\n    // After returning, the code outside will create a \'ClosedType\' using the returned type and add it to the global scope.\n}\n</code></pre>\n\n<p>The code basically gets the type of the term as usual, but before unifying, it adds the name of the function being defined with a dummy type into the type scope so that it can be used from within itself recursively. </p>\n\n<p><strong>Edit 2:</strong> I just realized that I\'d also need recursive types, which I don\'t have, to define a list like I want.</p>\n', 'Tags': '<lambda-calculus><type-theory><type-inference>', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-02-03T12:07:00.370', 'CommentCount': '4', 'AcceptedAnswerId': '20151', 'CreationDate': '2014-01-29T22:45:04.833', 'Id': '20088'},24_50:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '99', 'Title': 'What are the difference between and consequences of using type parameters and type indexes?', 'LastEditDate': '2014-01-30T11:09:05.900', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '8612', 'FavoriteCount': '1', 'Body': "<p>In type theories, like Coq's, we can define a type with parameters, like this:</p>\n\n<pre><code>Inductive ListP (Element : Type) : Type\n  := NilP  : ListP Element\n   | ConsP : Element -&gt; ListP Element -&gt; ListP Element.\n</code></pre>\n\n<p>Alternatively, we can define a type with an index, like this:</p>\n\n<pre><code>Inductive ListI : Type -&gt; Type\n  := NilI  : forall t, ListI t\n   | ConsI : forall t, t -&gt; ListI t -&gt; ListI t.\n</code></pre>\n\n<p>My questions are:</p>\n\n<ul>\n<li>Are these fundamentally different or fundamentally the same?</li>\n<li>What are the consequences of using one over the other?</li>\n<li>When is it preferable to use one over the other?</li>\n</ul>\n", 'Tags': '<type-theory><dependent-types>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T18:09:57.497', 'CommentCount': '0', 'AcceptedAnswerId': '20115', 'CreationDate': '2014-01-30T09:44:19.307', 'Id': '20100'},24_51:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>the standard List type in Coq can be expressed as:</p>\n\n<pre><code>Inductive List (A:Set) : Set :=\n  nil : List A\n| cons : A -&gt; List A -&gt; List A.\n</code></pre>\n\n<p>as I understand, W-type express a well-founded tree of elements of this type. so, what if <code>nil</code> is not qualified by <code>A</code>? i.e. we have:</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil : List A</code> </p>\n</blockquote>\n\n<p>instead of</p>\n\n<blockquote>\n  <p>for all <code>A: Set</code> <code>nil A: List A</code></p>\n</blockquote>\n\n<p>is this a correct W-type? can I express this in Coq?</p>\n', 'ViewCount': '38', 'Title': 'Is this a well founded inductive type? Can I express this in Coq?', 'LastActivityDate': '2014-02-16T08:07:20.807', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21693', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9922', 'Tags': '<type-theory><dependent-types><coq><inductive-datatypes>', 'CreationDate': '2014-02-14T17:40:00.397', 'Id': '21639'},24_52:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Could somebody explain the difference between dependent types and refinement types? As I understand it, a refinement type contains all values of a type fulfilling a predicate. Is there a feature of dependent types which distinguishes them? </p>\n\n<p>If it helps, I came across Refined types via the Liquid Haskell project, and dependent types via Coq and Agda. That said, I'm looking for an explanation of how the theories differ. </p>\n", 'ViewCount': '59', 'Title': 'Dependent types vs refinement types', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T05:57:58.417', 'LastEditDate': '2014-02-17T10:00:36.913', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<terminology><programming-languages><type-theory><functional-programming><dependent-types>', 'CreationDate': '2014-02-17T07:54:50.867', 'Id': '21728'},24_53:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've noticed that some languages include a logic engine as part of their type system (e.g. Shen, Typed Clojure).</p>\n\n<p>Other languages have a much more direct type checking algorithm (e.g. Haskell / Hindley-Milner).</p>\n\n<p>What specific features of a type system make it necessary to include a logic engine?</p>\n", 'ViewCount': '110', 'Title': 'When do type systems start needing a logic engine?', 'LastActivityDate': '2014-02-21T08:09:15.760', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6771', 'Tags': '<programming-languages><compilers><type-theory>', 'CreationDate': '2014-02-21T07:23:09.553', 'FavoriteCount': '1', 'Id': '21879'},24_54:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Has anyone ever actually written a system (software or detailed explanation on paper with simple examples) that generates computer programs?  I input $Prime(x) \\wedge x&lt;10$ and it creates a program that lists the prime numbers less than 10.  $Prime(x)$ is simply defined as \n$$1&lt;x \\wedge \\not\\exists A\\; s.t. 1&lt;A \\wedge A&lt;x \\wedge x=A\\times B,\\mbox{ with }\nA,B\\in \\mathbb{N}$$\nProfessors say they can but nobody gives actual complete examples.</p>\n', 'ViewCount': '191', 'Title': 'Has Anyone Actually Created a System that Writes Computer Programs from specification?', 'LastEditorUserId': '988', 'LastActivityDate': '2014-03-04T20:59:31.517', 'LastEditDate': '2014-03-04T20:51:13.270', 'AnswerCount': '4', 'CommentCount': '8', 'Score': '11', 'OwnerDisplayName': 'Charlie', 'PostTypeId': '1', 'Tags': '<logic><type-theory><coq><proof-assistants>', 'CreationDate': '2014-03-02T17:08:50.310', 'Id': '22241'},24_55:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m not sure if this is the correct place to ask this kind of a question, but here goes:</p>\n\n<p>I\'m doing my own reading of the Principles of Program Analysis book, and i\'m having trouble understanding some priciples from Chapter 5 - Type and Effect Systems.</p>\n\n<p>In the book (page 286) there is an example:</p>\n\n<p><img src="http://i.stack.imgur.com/glFcH.png" alt="enter image description here"></p>\n\n<p>I can not understand, why do they start with the expression fun<sub>F</sub> f x => ... \nIs this maybe <strong>guessing</strong> the values of the types of the bound variables <strong>f</strong> and <strong>x</strong>, we just assume that <strong>f</strong> is of type function that takes a function and returns a function, and that <strong>x</strong> is of type function (because it seems about right)?</p>\n\n<p>After that we have to determine the type of the function body, so we move to f (fn<sub>Y</sub> y => y). From the assumed types, we infer the type <strong>f</strong> (the top bottom rule in the image), and then we move to: fn<sub>Y</sub> y => y, and it is streightforward that the type of that expression is <strong>t -> t</strong> (a function that returns the same type that it was given).</p>\n\n<p><img src="http://i.stack.imgur.com/wTKD0.png" alt="enter image description here"></p>\n\n<p>Now that we know this, we can determine the type of the function application  f (fn<sub>Y</sub> y => y) as <strong>t -> t</strong>.</p>\n\n<p>Then again we move up to determine the type of <strong>fun<sub>F</sub> ...</strong> which accoring to the rules for recursive functions is streight-forward (the same type as for <strong>f</strong> in the assumed typed enviroment)..</p>\n\n<p>Then we move to the in body: g (fn<sub>Z</sub> => z). g\'s type has already been determined immediatly above, so we move to fn<sub>Z</sub> => z which is the same as for fn<sub>Y</sub>. And in the end we get that the whole expression has the type: <strong>t -> t</strong>.</p>\n\n<p>What i\'m asking is: is this the correct trail of thought? Or i\'m i missing the point somewhere? </p>\n\n<p>I\'m not sure about the guessing part, why did we start where we did, why not more simply with variable y or somewhere else? The rest of the chapter heavily depends on the proper understanding of these concepts, and i would like to understand this.</p>\n\n<p>In general, I would be grateful if somebody could point me out to a book or something that, in more details explains type systems.</p>\n\n<p>Thank you!</p>\n', 'ViewCount': '22', 'Title': 'Type systems understanding problems', 'LastActivityDate': '2014-03-08T11:52:43.490', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15414', 'Tags': '<type-theory>', 'CreationDate': '2014-03-08T11:52:43.490', 'Id': '22394'},24_56:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have a few small questions about section 2.4 ("Rule induction") in <a href="https://www.cs.cmu.edu/~rwh/plbook/book.pdf" rel="nofollow">Practical Foundations for Programming Languages</a> (p. 19).</p>\n\n<p>(1) In the rule induction principles for <code>nat</code>,</p>\n\n<blockquote>\n  <p>To show P(a nat) whenever a nat, it is enough to show:\n  (1) P(zero nat).\n  (2) for every a, if (a nat and) P(a nat), then P(succ(a) nat).</p>\n</blockquote>\n\n<p>why is the bracketed "(<em>a</em> <code>nat</code> and)" clause necessary (and similarly for <code>tree</code>)?  This seems "natural" - we shouldn\'t need to prove things about syntactic entities that don\'t define <code>nat</code>s - but doesn\'t appear in the definition given of property <em>P</em> "respecting the rules" defining <code>nat</code>/<code>tree</code> (also on p. 19), which is how the rule induction principle is defined.  In the proof of Lemma 2.1, the extra "<em>a</em> nat and" part has become part of the definition of the property <em>P</em> - what\'s going on here?</p>\n\n<p>(2) I don\'t understand the induction step of Lemma 2.1 (<code>succ(a) nat</code> implies <code>a nat</code>).  If I were doing this proof, I\'d just invert the rules for <code>nat</code> right away, or, using Harper\'s property <em>P</em>, say: If <code>succ(a)</code> is of form <code>succ(b)</code>, then by injectivity, <code>a</code> equals <code>b</code>, hence <code>b nat</code> as <code>a nat</code>, but injectivity hasn\'t been proven yet.  It seems instead that Harper applies the induction hypothesis about <code>a</code> directly to <code>succ(a)</code> - I must be missing something.</p>\n\n<p>(3) In a more naive framework, Lemma 2.3 would just follow from sufficiency of the <code>= nat</code> relation rules ("inversion"), but I don\'t know how to write down a proof in this style.  Why is induction even needed?</p>\n\n<p>I\'m sorry if these questions seem like nitpicking, but Martin-L\xf6f/LF feels very foreign to me.  If I squint and pretend I\'m doing everything in a more "traditional" operational semantics, I can read other parts of the book (with slightly different proofs), but I feel I\'m missing the point in doing so.</p>\n\n<p>If these questions are too tedious to answer individually, are there other references on doing semantics in this style?</p>\n', 'ViewCount': '47', 'Title': "Rule induction principles in Harper's PFPL", 'LastEditorUserId': '15757', 'LastActivityDate': '2014-03-21T16:34:29.187', 'LastEditDate': '2014-03-21T16:34:29.187', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15757', 'Tags': '<type-theory><semantics><induction><operational-semantics>', 'CreationDate': '2014-03-17T03:10:30.117', 'Id': '22690'},24_57:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve just read in a <a href="http://lambda-the-ultimate.org/node/4875#comment-78361" rel="nofollow">discussion about dynamic typing</a></p>\n\n<blockquote>\n  <p>Reflective towers is an open problem for statically typed languages.</p>\n</blockquote>\n\n<p>What are reflective towers? </p>\n\n<p>I think it might be related to reflection, but I\'m not sure.</p>\n\n<p>If you create an example, I would prefer Java.</p>\n', 'ViewCount': '34', 'Title': 'What is an reflective tower?', 'LastActivityDate': '2014-03-18T18:05:06.900', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2914', 'Tags': '<type-theory><reflection>', 'CreationDate': '2014-03-18T16:00:15.037', 'Id': '22760'},24_58:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to verify the type for the lambda expression: $\\lambda f.\\lambda x.f (f x)$</p>\n\n<p>My method gives me: $(a\\rightarrow c)\\rightarrow b\\rightarrow c$</p>\n\n<p>Im trying to define it in Haskell (on Hugs) like this: </p>\n\n<pre><code>h= \\f x -&gt; f (f x)\n</code></pre>\n\n<p>When i call the :type comamnd it gives me:</p>\n\n<pre><code>(a -&gt; a) -&gt; a -&gt; a\n</code></pre>\n\n<p>Is mi function correctly defined in Haskell?, or my method gives me a wrong result?</p>\n', 'ViewCount': '27', 'Title': 'Verify the type of a lambda expression', 'LastActivityDate': '2014-03-19T17:51:33.670', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '22815', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12923', 'Tags': '<lambda-calculus><type-theory>', 'CreationDate': '2014-03-19T03:11:41.567', 'Id': '22791'},24_59:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the <a href="http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus" rel="nofollow">Wikipedia article on Simply Typed Lambda Calculus</a> (among other places), there is a notion of a "term constant".  This is particularly notable in the production grammar given:</p>\n\n<p><img src="http://i.stack.imgur.com/4b722.png" alt="enter image description here"></p>\n\n<p>In this production grammar, the <code>c</code> is the term constant.  I am new to the simply typed variant of lambda calculus -- I do not understand what role this constant plays in the overall computations of STLC.  Can anyone give some examples of how the term constant is used and explain its general purpose?</p>\n', 'ViewCount': '37', 'Title': 'Role of Term Constants in Simply Typed Lambda Calculus', 'LastActivityDate': '2014-03-24T16:06:35.497', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '22965', 'Score': '0', 'OwnerDisplayName': 'BlackVegetable', 'PostTypeId': '1', 'OwnerUserId': '14648', 'Tags': '<type-theory><lambda-calculus>', 'CreationDate': '2014-03-22T19:06:16.520', 'Id': '22964'},24_60:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm wondering if there is a way to extend Hinley-Milner's type system to allow polymorphic types without the need of a let construct, by adding an intersection type (as Dan pointed out) that represents the possible types of a function type.</p>\n\n<p>Say I have this expression:</p>\n\n<p>$\\lambda x.\\lambda y.(x\\ (x\\ y))$</p>\n\n<p>While running the type inference algorithm, I'd normally, after looking at the expression $(x\\ y)$, assign to $x$ some type $Y \\rightarrow A$, where $Y$ is the type of $y$ and $A$ is whatever $x$ returns. Then, since $x$ also takes $(x\\ y)$ which has the type $A$, I replace $Y$ with $A$, such that the type of $x$ becomes $A \\rightarrow A$ and give to the whole thing the type $(A \\rightarrow A) \\rightarrow (A \\rightarrow A)$.</p>\n\n<p>But what if I, instead of replacing $Y$ with $A$ when I see $(x\\ (x\\ y))$, add a new type to $x$, say, $A \\rightarrow B$, such that the final type is $((Y \\rightarrow A) \\wedge (A \\rightarrow B)) \\rightarrow (Y \\rightarrow B)$, which is also a tautology and seems like a better representation of what the function does.</p>\n\n<p>Now say I give to this abstraction the term $\\lambda n.n$ like this:</p>\n\n<p>$(\\lambda x.\\lambda y.(x\\ (x\\ y))\\ \\lambda n.n)$</p>\n\n<p>Since $\\lambda n.n$ has the type $N \\rightarrow N$, I'd need to unify $N \\rightarrow N$ with $((Y \\rightarrow A) \\wedge (A \\rightarrow B))$. So I instantiate two copies of $N \\rightarrow N$, say $N_1 \\rightarrow N_1$ and $N_2 \\rightarrow N_2$, and unify $N_1 \\rightarrow N_1$ with $Y \\rightarrow A$ and $N_2 \\rightarrow N_2$ with $A \\rightarrow B$. Because $A$ would be equal to $N_1$ on one side and equal to $N_2$ on the other side, $N_1$, $Y$, $A$ and $B$ are all equal to $N_2$, so the type $Y \\rightarrow B$ becomes $N_2 \\rightarrow N_2$, which is consistent with the expression you'd get after evaluating the lambda term.</p>\n\n<p>With this type system I should be able to type things like this:</p>\n\n<p>$(\\lambda i.\\lambda x.\\lambda y.((i\\ x)\\ (i\\ y))\\ \\lambda n.n)$</p>\n\n<p>But these examples are simple, and it becomes a pain to type something like:</p>\n\n<p>$(\\lambda x.\\lambda y.(x\\ (x\\ y))\\ \\lambda x.\\lambda y.(x\\ (x\\ y)))$</p>\n\n<p>I'm having trouble trying to figure out what the actual rules of this system would be, like what would you do if you'd have to unify two intersection types (or whether that situation is even possible). </p>\n\n<p>So my question is, am I moving towards a type system that already exists? If yes, which one? If not, is this because my type system wouldn't meet the requirements of a type system (such as being decidable)?</p>\n", 'ViewCount': '33', 'Title': 'Does there exist a type system for a non-let-polymorphic lambda calculus?', 'LastEditorUserId': '10401', 'LastActivityDate': '2014-03-31T16:54:26.607', 'LastEditDate': '2014-03-31T16:54:26.607', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10401', 'Tags': '<lambda-calculus><type-theory><type-inference>', 'CreationDate': '2014-03-30T07:48:34.587', 'Id': '23249'},24_61:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m taking a graduate course on the theory of functional programming, based on Paul Taylor\'s "Practical Foundations of  Mathematics." I understand the statement of Tarski\'s theorem about how for any $\\omega$-compelte poset $X$, and any $\\omega$-continuous function $T:X\\rightarrow X$, that $T$ has a fixed point which is the join of (The statement and proof can be found <a href="http://www.paultaylor.eu/~pt/prafm/html/s33.html" rel="nofollow">here</a>).</p>\n\n<p>What I want to know is, how is this applicable, other than being a proof that the Y-combinator exists? It just seems to me that it says "we can use recursion to build a function that is defined for all natural numbers", where we could use some other recursive type for numbers. Doesn\'t the existence of the Y-combinator show the same thing?</p>\n', 'ViewCount': '73', 'Title': "What does Tarski's Fixed-Point theorem give us that that Y-Combinator does't", 'LastActivityDate': '2014-04-04T19:32:29.183', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<lambda-calculus><recursion><type-theory><partial-order><lattices>', 'CreationDate': '2014-04-04T19:16:13.043', 'Id': '23431'},24_62:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm looking for a type inference algorithm for a language I'm developing, but I couldn't find one that suits my needs because they usually are either:</p>\n\n<ul>\n<li>\xe0 la Haskell, with polymorphism but no ad-hoc overloading</li>\n<li>\xe0 la C++ (auto) in which you have ad-hoc overloading but functions are monomorphic</li>\n</ul>\n\n<p>In particular my type system is (simplifying) (I'm using Haskellish syntax but this is language agnostic):</p>\n\n<pre><code>data Type = Int | Double | Matrix Type | Function Type Type\n</code></pre>\n\n<p>And I've got an operator * which has got quite some overloads:</p>\n\n<pre><code>Int -&gt; Int -&gt; Int\n(Function Int Int) -&gt; Int -&gt; Int\nInt -&gt; (Function Int Int) -&gt; (Function Int Int)\n(Function Int Int) -&gt; (Function Int Int) -&gt; (Function Int Int)\nInt -&gt; Matrix Int -&gt; Matrix Int\nMatrix Int -&gt; Matrix Int -&gt; Matrix Int\n(Function (Matrix Int) (Matrix Int)) -&gt; Matrix Int -&gt; Matrix Int\n</code></pre>\n\n<p>Etc... </p>\n\n<p>And I want to infer possible types for</p>\n\n<pre><code>(2*(x =&gt; 2*x))*6\n(2*(x =&gt; 2*x))*{{1,2},{3,4}}\n</code></pre>\n\n<p>The first is <code>Int</code>, the second <code>Matrix Int</code>.</p>\n\n<p>Example (that doesn't work):</p>\n\n<pre><code>{-# LANGUAGE OverlappingInstances, MultiParamTypeClasses,\n  FunctionalDependencies, FlexibleContexts,\n  FlexibleInstances, UndecidableInstances #-}\n\nimport qualified Prelude\nimport Prelude hiding ((+), (*))\nimport qualified Prelude\n\nnewtype WInt = WInt { unwrap :: Int }\n\nliftW f a b = WInt $ f (unwrap a) (unwrap b)\n\nclass Times a b c | a b -&gt; c where\n(*) :: a -&gt; b -&gt; c\n\ninstance Times WInt WInt WInt where\n(*) = liftW (Prelude.*)\n\ninstance (Times a b c) =&gt; Times a (r -&gt; b) (r -&gt; c) where\nx * g = \\v -&gt; x * g v\n\ninstance Times (a -&gt; b) a b where\nf * y = f y\n\ntwo = WInt 2\nsix = WInt 6\n\ntest :: WInt\ntest = (two*(\\x -&gt; two*x))*six\n\nmain = undefined\n</code></pre>\n", 'ViewCount': '47', 'Title': 'Type inference + overloading', 'LastEditorUserId': '508', 'LastActivityDate': '2014-04-23T17:59:09.350', 'LastEditDate': '2014-04-23T17:59:09.350', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'OwnerDisplayName': 'miniBill', 'PostTypeId': '1', 'OwnerUserId': '508', 'Tags': '<type-theory><type-inference>', 'CreationDate': '2014-04-19T15:32:41.113', 'Id': '23963'},24_63:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I am trying to extend an existing UTP theory package(Isabelle/UTP) by introducing a new type for use in encoding a custom framework built on UTP. <code>MkName</code> is a type constructor, <code>fset</code> basically restricts <code>VAR</code> to finite sets. The type <code>@{term "UTYPE"}</code> consists of the set of types which, according to the typing relation, have at least one defined value. <code>WF_PREDICATE_OVER</code> calculates all predicates which satisfy the given argument(alphabet). <code>\u03c0 p = snd(WF_ALPHA_PREDICATE)</code> . <code>&lt;_&gt;\u21e9f</code> is <code>Rep</code> function for <code>fset</code>.  <code>\u03b9\u03c0 p = snd(WF_ALPHA_PREDICATE)</code></p>\n\n<pre><code>(*--------- from Isabelle/UTP package -------*)\n\ndefinition fsets :: "\'a set set" where "fsets = Collect finite"\ntypedef \'a fset = "fsets :: \'a set set"  by (auto simp add:fsets_def)\nnotation Rep_fset ("&lt;_&gt;\u21e9f")    \n\nclass DEFINED = fixes Defined   :: "\'a \u21d2 bool" ("D")\ndefinition "UTYPES (x::\'a itself) = {t. \u2203 v :: \'a. v :\u21e9u t \u2227 D v}"\ntypedef \'VALUE UTYPE = "UTYPES TYPE(\'VALUE)"    \n\ndatatype NAME = MkName string nat\n\ntype_synonym \'VALUE VAR = "NAME \xd7 \'VALUE UTYPE \xd7 bool"\ndefinition VAR :: "\'VALUE VAR set" where "VAR = UNIV"\n\ntype_synonym \'VALUE ALPHABET = "(\'VALUE VAR) fset"\ntype_synonym \'VALUE ALPHA_PREDICATE = "(\'VALUE ALPHABET) \xd7 \'VALUE WF_PREDICATE"\n\ntype_synonym \'VALUE BINDING = "(\'VALUE VAR) \u21d2 \'VALUE"\ntypedef \'VALUE WF_BINDING   = "WF_BINDING :: \'VALUE BINDING set"\ntypedef \'VALUE WF_PREDICATE = "UNIV :: \'VALUE WF_BINDING set set"\n\ndefinition WF_ALPHA_PREDICATE :: "\'VALUE ALPHA_PREDICATE set" where\n    "WF_ALPHA_PREDICATE = {(a,p) | a p . p \u2208 WF_PREDICATE_OVER &lt;a&gt;\u21e9f}"\n\ntypedef \'a WF_ALPHA_PREDICATE = "WF_ALPHA_PREDICATE :: \'a ALPHA_PREDICATE set"\n\n\n(*--------- My Code -------*)\ntype_synonym \'VALUE LA_PREDICATE = "(\'VALUE ALPHABET) \xd7 (\'VALUE WF_ALPHA_PREDICATE)"\n\ndefinition WF_LA_PREDICATE :: "\'VALUE LA_PREDICATE set" where\n"WF_LA_PREDICATE = {(a::\'VALUE ALPHABET, p::\'VALUE WF_ALPHA_PREDICATE) | a p . \n       (\u03c0 p) \u2208 WF_PREDICATE_OVER (VAR - &lt;a&gt;\u21e9f) }" \n\ntypedef \'VALUE WF_LA_PREDICATE = "WF_LA_PREDICATE :: \'VALUE LA_PREDICATE set"\n\nlift_definition Exists1 ::\n  "\'VALUE ALPHABET \u21d2 \'VALUE WF_LA_PREDICATE \u21d2 \'VALUE WF_LA_PREDICATE" is\n  "\u03bb a p . ( \u03b1 p, \u2203\u21e9\u03b1 Abs_fset(VAR) -\u21e9f a .  \u03b9\u03c0 p)"\n</code></pre>\n\n<p>The lift definition results in the following error.</p>\n\n<p>Lifting failed for the following types:\nRaw type:  (NAME \xd7 \'a UTYPE \xd7 bool) fset \xd7 \'a WF_ALPHA_PREDICATE\nAbstract type:  \'VALUE WF_LA_PREDICATE</p>\n\n<p>Reason:\n  The <em>quotient type</em> "\'VALUE WF_LA_PREDICATE" and the <em>quotient type pattern</em> "?\'a WF_LA_PREDICATE"  don\'t match.</p>\n\n<p>What would be a valid definition for Exists1???\nWhat is the syntax I\'m writing wrong? </p>\n', 'ViewCount': '25', 'ClosedDate': '2014-04-29T22:32:36.733', 'Title': "Isabelle : quotient type and quotient type pattern don't match", 'LastActivityDate': '2014-04-29T14:15:04.437', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '17180', 'Tags': '<formal-languages><type-theory><functional-programming><type-inference><type-checking>', 'CreationDate': '2014-04-29T14:15:04.437', 'Id': '24223'}