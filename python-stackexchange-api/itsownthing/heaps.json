2830:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How many different max-heaps can I form using a list of $n$ integers. </p>\n\n<p>Example: \nlist [1,2,3,4]</p>\n\n<p>and max-heap is <code>4 3 2 1</code>  or </p>\n\n<pre><code>    4\n   / \\\n  3   2\n /\n1\n</code></pre>\n\n<p>other possible max-heap is <code>4 2 3 1</code></p>\n\n<pre><code>    4 \n   / \\\n  2   3 \n /\n1\n</code></pre>\n', 'ViewCount': '569', 'Title': 'How many max heaps are there?', 'LastEditorUserId': '2205', 'LastActivityDate': '2014-01-27T20:52:32.243', 'LastEditDate': '2012-11-20T08:21:15.937', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6458', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '244', 'Tags': '<graph-theory><data-structures><combinatorics><binary-trees><heaps>', 'CreationDate': '2012-11-02T18:19:35.187', 'Id': '6456'},2831:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose a <strong>build</strong> max-heap operation runs bubble down over a heap. How does its amortized cost equal $O(n)$?</p>\n', 'ViewCount': '1518', 'Title': "How can I prove that a build max heap's amortized cost is $O(n)$?", 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-18T07:58:21.743', 'LastEditDate': '2012-11-18T07:58:21.743', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '6659', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<data-structures><runtime-analysis><heaps>', 'CreationDate': '2012-11-14T03:58:41.463', 'Id': '6655'},2832:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a <strong>max heap</strong> with <strong>extract-max</strong> operation.</p>\n\n<p>The basic version takes $2 \\log n$ steps.\nHow can I make it in $\\log n + \\log\\log n$\nand how in $\\log n + \\log\\log\\log n $?</p>\n\n<p>I thought of putting $-\\infty$ on the heap root but not really sure what to do with it as it can go anywhere.</p>\n\n<p>To be more precise, steps are considered only compares between array item values. I\'m reading <a href="http://en.wikipedia.org/wiki/Introduction_to_Algorithms" rel="nofollow">CLRS</a> Chapter 6 (<strong>MAX-HEAPIFY</strong> and <strong>HEAP-EXTRACT-MAX</strong>).</p>\n', 'ViewCount': '341', 'Title': 'Extract Max for a max-heap in $\\log n + \\log\\log n$', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:22:14.673', 'LastEditDate': '2013-05-24T03:22:14.673', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4618', 'Tags': '<data-structures><heaps>', 'CreationDate': '2012-11-16T19:40:15.313', 'FavoriteCount': '1', 'Id': '6698'},2833:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I think I\'m confused about deletion in heaps, and since I have an exam today, I\'m looking for your help to correct me.</p>\n\n<p>I will post photos since it will makes it a bit more clear.</p>\n\n<p>Note(forget about deleting the root)</p>\n\n<p><img src="http://i.stack.imgur.com/USyPs.png" alt="enter image description here"></p>\n\n<p>What I understand is that , heaps only deletes the root element or the top. So, I made 2 solutions and I\'m kindly asking which solution is the correct one.</p>\n\n<p><img src="http://i.stack.imgur.com/9sKUA.png" alt="enter image description here"></p>\n\n<p>Q:the heapness will be violated, I will have to replace it by the rightmost element bottom down right? (32)\n<img src="http://i.stack.imgur.com/SX3Kc.png" alt="enter image description here"></p>\n', 'ViewCount': '2434', 'Title': 'Deletion in min/max heaps', 'LastActivityDate': '2013-05-22T20:40:52.947', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '7000', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4781', 'Tags': '<data-structures><heaps>', 'CreationDate': '2012-11-28T09:41:54.687', 'Id': '6990'},2834:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '326', 'Title': 'Determine whether the $k^{th}$ smallest element in max-heap is greater than a given number', 'LastEditDate': '2012-12-06T06:00:55.747', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4878', 'FavoriteCount': '1', 'Body': '<p>A set of numbers is stored in a <strong>max-heap</strong>. We want to find an algorithm with $O(k)$ time complexity to check if $k^{th}$ <strong>smallest</strong> element is greater than an arbitrary given number.</p>\n', 'Tags': '<algorithms><data-structures><heaps>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-24T13:40:07.560', 'CommentCount': '11', 'AcceptedAnswerId': '7660', 'CreationDate': '2012-12-05T09:27:05.190', 'Id': '7173'},2835:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In <a href="http://en.wikipedia.org/wiki/Fibonacci_heap" rel="nofollow">Fibonacci heaps</a>, we keep a mark field for every node in the heap. Initially all the nodes are unmarked. Once a node is deleted, its parent is marked. If a node is deleted and its parent is already marked, the parent will be cut and inserted into the root list. I just wonder what the purpose of marking is? What happens if we cut the parent just the first time without marking it? Does it change the time complexity of the operations? How?</p>\n', 'ViewCount': '275', 'Title': 'What is the purpose of Mark field in Fibonacci Heaps?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-19T09:58:56.557', 'LastEditDate': '2012-12-19T09:58:56.557', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7510', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1672', 'Tags': '<data-structures><heaps><amortized-analysis>', 'CreationDate': '2012-12-19T08:11:04.093', 'Id': '7505'},2836:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need help figuring the potential function for a max heap so that extract max is completed in $O(1)$ amortised time. I should add that I do not have a good understanding of the potential method. </p>\n\n<p>I know that the insert function should "pay" more in order to reduce the cost of the extraction, and this has to be in regards to the height of the heap (if $ \\lfloor \\log(n) \\rfloor $ gives the height of the heap should the insert be $2\\log(n)$ or $ \\sum_{k=1}^n 2\\log(k) $)</p>\n', 'ViewCount': '783', 'Title': 'Potential function binary heap extract max O(1)', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-14T20:34:01.887', 'LastEditDate': '2013-01-14T20:34:01.887', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7901', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5384', 'Tags': '<data-structures><runtime-analysis><heaps><amortized-analysis>', 'CreationDate': '2013-01-11T23:41:04.057', 'Id': '7894'},2837:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was studying binomial heaps and its time analysis. Are there any inputs that cause DELETE-MIN, DECREASE-KEY, and DELETE to run in $\\Omega(\\log n)$ time for a binomial heap rather than $O(\\log n)$?</p>\n', 'ViewCount': '243', 'Title': 'Input that causes an operation on a binomial heap to run in $\\Omega(\\log n)$ time?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-01-16T08:30:16.393', 'LastEditDate': '2013-01-16T08:30:16.393', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6438', 'Tags': '<algorithms><data-structures><lower-bounds><heaps>', 'CreationDate': '2013-01-16T02:01:40.263', 'Id': '8955'},2838:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to prove/disprove two statements. I just want to make sure with you I'm on the right line.</p>\n\n<p>These are the following statements:</p>\n\n<p><strong>Preface :</strong> Let A[n] be an array of min-heap (a min-heap represented by an array], whereas all the elements in the heap are different from each other. \nLet i and j be two indexes in the range : $0 \\le i, j \\le n-1$.</p>\n\n<p><em><strong>Prove or disprove :</em></strong> </p>\n\n<ol>\n<li>If $i &lt; j $ then $A[i] &lt; A[j]$</li>\n<li>If $A[i] &lt; A[j] $ then $i &lt; j$</li>\n</ol>\n\n<p>I believe I managed to disprove both of them using the following heap:</p>\n\n<p>$\\qquad [2, 6, 7, 11, 14, 13, 12, 12, 13,15, 16, 71, 72, 13, 81]$</p>\n\n<p>For:</p>\n\n<ol>\n<li><p>Simply plug in the following indexes: $i = 4$ and $j = 13$. </p>\n\n<p>So $i &lt; j$ but $A[i] &gt; A[j]$.</p></li>\n<li><p>Simply plug in the following indexes: $i = 13$ and $j = 4$.</p>\n\n<p>So $A[i] &lt; A[j]$ but $i &gt; j$.</p></li>\n</ol>\n\n<p>Am I missing something here? Or It is really that easy?</p>\n", 'ViewCount': '209', 'Title': 'MinHeap represented by an array - two simple statements', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-03T10:26:59.710', 'LastEditDate': '2013-02-03T10:26:59.710', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9445', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<data-structures><binary-trees><arrays><heaps>', 'CreationDate': '2013-02-03T08:44:32.337', 'Id': '9444'},2839:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I would like to find the height of a d-ary heap. Assuming you have an Array that starts indexing at $1$ we have the following:</p>\n\n<p>The parent of a node $i$ is given by: $\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor$</p>\n\n<p>The $d$ children of a parent at node $i$ are given by: $di-d+1, di-d+2,\\ldots di+1$</p>\n\n<p>The height of a heap (which is slightly different than the height of a binary search tree) is a longest path from the root to a leaf. A longest path will always be from the last node in the heap to the root, but how do I calculate this longest path?</p>\n\n<p>My first Idea is to setup a recurrence relation for the height of the tree:</p>\n\n<p>\\begin{equation}\nh(1) = 0\\\\\nh(i) = h\\left(\\left\\lfloor\\frac{i+1}{d}\\right\\rfloor\\right)+1 \n\\end{equation}</p>\n\n<p>This seems overly-complicated and I feel like the answer is much more simple. Is there a better way to find the height of a $d-$ary heap?</p>\n', 'ViewCount': '567', 'Title': 'Finding the height of a d-ary heap', 'LastEditorUserId': '6815', 'LastActivityDate': '2013-02-19T09:44:45.017', 'LastEditDate': '2013-02-18T23:01:14.800', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '9929', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6815', 'Tags': '<data-structures><recurrence-relation><heaps>', 'CreationDate': '2013-02-18T22:44:05.470', 'Id': '9914'},28310:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1157', 'Title': 'Is search a binary heap operation?', 'LastEditDate': '2013-02-24T16:24:27.193', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Barry Fruitman', 'PostTypeId': '1', 'OwnerUserId': '7007', 'Body': '<p>According to the <a href="http://en.wikipedia.org/wiki/Binary_heap" rel="nofollow">Wikipedia page</a>, search is "not an operation" on binary heaps (see complexity box at top-right).</p>\n\n<p>Why not? Binary heaps may not be sorted, but they are ordered, and a full graph traversal can find any object in $O(n)$ time, no?</p>\n\n<p>Is the page wrong or am I?</p>\n', 'Tags': '<data-structures><search-algorithms><heaps>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-24T16:24:27.193', 'CommentCount': '1', 'AcceptedAnswerId': '10052', 'CreationDate': '2013-02-24T07:37:18.370', 'Id': '10049'},28311:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The time complexity of merge (union) operation is said to be $O(\\lg (n_1 + n_2))$, where $n_1$ and $n_2$ are the numbers of elements in the merged heaps, respectively. I do not understand this - the algorithm has to go through all the elements of both rightmost paths of the original heaps - lengths of these paths are bound by $O(\\lg n_1)$ and $O(\\lg n_2)$. That makes $O(\\lg n_1 + \\lg n_2)$ in total, which is $O(\\lg (n_1 n_2))$. Where am I making a mistake in my assumptions?</p>\n\n<p>Arbitrary delete operation - the complexity should be $O(\\lg n)$, where $n$ is the size of the heap. But after the deletion, the algorithm has to go through all the nodes from the parent of the deleted node to the root and correct the Leftist property, and the lenght of this path is bound by $O(n)$. Again, where am I wrong?</p>\n', 'ViewCount': '116', 'Title': 'Leftist heap - determining time complexity', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-24T16:22:09.107', 'LastEditDate': '2013-02-24T16:22:09.107', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7009', 'Tags': '<data-structures><runtime-analysis><heaps>', 'CreationDate': '2013-02-24T15:50:20.213', 'Id': '10056'},28312:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In many discussions of binary heap, normally only decrease-key is listed as supported operation for a min-heap. For example, CLR chapter 6.1 and <a href="http://en.wikipedia.org/wiki/Heap_%28data_structure%29" rel="nofollow">this wikipedia page</a>. Why isn\'t increase key normally listed for min-heap? I imagine it is possible to do that in O(height) by iteratively swapping the increased element (x) with the minimum of its children, until none of its children is bigger than x.</p>\n\n<p>e.g.</p>\n\n<pre><code>IncreaseKey(int pos, int newValue)\n{\n   heap[pos] = newValue;\n   while(left(pos) &lt; heap.Length)\n   {\n      int smallest = left(pos);\n      if(heap[right(pos)] &lt; heap[left(pos)])\n         smallest = right(pos);\n      if(heap[pos] &lt; heap[smallest])\n      { \n         swap(smallest, pos);\n         pos= smallest;\n      }\n      else return;\n   }   \n}\n</code></pre>\n\n<p>Is the above correct? If not, why? If yes, why isn\'t increase key listed for min-heap?</p>\n', 'ViewCount': '3873', 'Title': 'Increase-key and decrease-key in a binary min-heap', 'LastActivityDate': '2013-03-03T22:31:44.110', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7105', 'Tags': '<algorithms><data-structures><heaps><priority-queues>', 'CreationDate': '2013-03-02T11:08:39.657', 'FavoriteCount': '2', 'Id': '10203'},28313:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a heap where both child nodes of the root are 10, and I\'d like to perform an operation to remove the min value 9.</p>\n\n<p>I proceed to replacing the root with its next of kin, 18. However when I bubble down, I am unsure of which direction to take.</p>\n\n<p><img src="http://i.stack.imgur.com/os1CS.jpg" alt="enter image description here"></p>\n', 'ViewCount': '83', 'Title': 'When two siblings in a heap are equal, how do you bubble down?', 'LastActivityDate': '2013-04-04T05:16:59.423', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<data-structures><heaps>', 'CreationDate': '2013-04-04T02:16:26.417', 'FavoriteCount': '1', 'Id': '11008'},28314:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What are the steps to perform bottom-up heap construction on a short sequence, like <code>1, 6, 7, 2, 4</code>?</p>\n\n<p>At this <a href="http://www.apl.jhu.edu/Classes/605202/felikson/lectures/L8/L8.html" rel="nofollow">link</a> there are instructions on how to do for a list of size 15, but I can\'t [necessarily] apply the same process to a list of 5 items (my trouble is that 5 is not enough to provide a complete tree).</p>\n', 'ViewCount': '1791', 'Title': 'How to perform bottom-up construction of heaps?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:13:59.233', 'LastEditDate': '2013-04-21T14:13:12.463', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4348', 'Tags': '<data-structures><heaps>', 'CreationDate': '2013-04-19T20:54:00.357', 'Id': '11415'},28315:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3687', 'Title': 'Heap - Give an $O(n \\lg k)$ time algorithm to merge $k$ sorted lists into one sorted list', 'LastEditDate': '2013-06-24T19:13:31.113', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7678', 'FavoriteCount': '1', 'Body': "<p>Most probably, this question is asked before. It's from CLRS (2nd Ed) problem 6.5-8 -- </p>\n\n<blockquote>\n  <p>Give an $O(n \\lg k)$ time algorithm to merge $k$ sorted lists into one sorted list, where $n$ is the total number of elements in all the input lists. (Hint: Use a min-heap for $k$-way merging.)</p>\n</blockquote>\n\n<p>As there are $k$ sorted lists and total of $n$ values, let us assume each list contains $\\frac{n}{k}$ numbers, moreover each of the lists are sorted in strictly ascending order, and the results will also be stored in the ascending order. </p>\n\n<p>My pseudo-code looks like this --</p>\n\n<pre><code>    list[k]   ; k sorted lists\n    heap[k]   ; an auxiliary array to hold the min-heap\n    result[n] ; array to store the sorted list\n    for i := 1 to k                 ; O(k)\n    do\n        heap[i] := GET-MIN(list[i]) ; pick the first element \n                                    ; and keeps track of the current index - O(1)\n    done\n    BUILD-MIN-HEAP(heap) ; build the min-heap - O(k)\n    for i := 1 to n\n    do\n        array[i] := EXTRACT-MIN(heap)   ; store the min - O(logk)\n        nextMin := GET-MIN(list[1])     ; get the next element from the list 1 - O(1)\n        ; find the minimum value from the top of k lists - O(k)\n        for j := 2 to k                 \n        do\n            if GET-MIN(list[j]) &lt; nextMin\n                nextMin := GET-MIN(list[j]) \n        done\n        ; insert the next minimum into the heap - O(logk)\n        MIN-HEAP-INSERT(heap, nextMin)\n    done\n</code></pre>\n\n<p>My overall complexity becomes $O(k) + O(k) + O(n(k + 2 \\lg k)) \\approx O(nk+n \\lg k) \\approx O(nk)$. I could not find any way to avoid the $O(k)$ loop inside the $O(n)$ loop to find the next minimum element from k lists. Is there any other way around? How to get an $O(n \\lg k)$ algorithm?</p>\n", 'Tags': '<algorithms><algorithm-analysis><heaps><priority-queues>', 'LastEditorUserId': '7678', 'LastActivityDate': '2013-06-24T20:38:10.317', 'CommentCount': '0', 'AcceptedAnswerId': '12854', 'CreationDate': '2013-06-24T06:20:18.200', 'Id': '12853'},28316:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If we have $n$ elements $s_1, \\dots, s_n$ and build a kind of treap (tree-heap) out of it. Each $s_k$ has a priority, which is an integer in $\\{ 1, 2, 3 \\dots, \\lceil \\log n \\rceil\\}$. Since the priorities will have duplicates, I just want the treap the verify that for each node $s_k$, all the nodes in its right and left subtrees have smaller priority. </p>\n\n<p>Is there a way to find the expected depth of this tree?</p>\n', 'ViewCount': '96', 'Title': 'Expected depth of modified kind of treap', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T09:06:30.243', 'LastEditDate': '2013-09-18T09:06:30.243', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10186', 'Tags': '<algorithm-analysis><data-structures><search-trees><heaps>', 'CreationDate': '2013-09-17T21:35:36.280', 'Id': '14391'},28317:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So given an input of lets say 10 strings, what way can we input these so we get the best or worst case for these two given sorts?</p>\n\n<pre><code>Heap sort:\nbest case - nlogn\nworst case - nlogn\n\nQuick sort:\nbest case - nlogn\nworst case - n^2\n</code></pre>\n\n<p>Where I get confused on these two is:</p>\n\n<ul>\n<li><strong>heap</strong>- Since the best and worst case are the same does it not matter\nthe input order? The number of comparisons and assignments will\nalways be the same? I imagine in a heap sort it may be the same since\nthe real work is done in the insertion, but the sorting only uses the\nremoval of the max/min heap? Is that why?</li>\n<li><strong>quick sort</strong>- This one I don't know for sure. I'm not sure what the\nbest case and worst case situations are for this. If its a already\nsorted list of 10 strings for example wouldn't we always have to\nchoose the same amount of pivots to get complete the recursive\nalgorithm? Any help on this explanation would really help.</li>\n</ul>\n", 'ViewCount': '416', 'Title': 'Best and worse case inputs for heap sort and quick sort?', 'LastEditorUserId': '9550', 'LastActivityDate': '2013-11-26T21:03:49.457', 'LastEditDate': '2013-11-26T18:52:40.720', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11638', 'Tags': '<algorithms><complexity-theory><sorting><heaps>', 'CreationDate': '2013-11-26T17:43:11.983', 'Id': '18391'},28318:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was trying to understand the concept of Max-Heap. And to my understanding its a complete binary tree and each parent has a value greater than its children.The example I was going though had the following array which it said was a Max-Heap.</p>\n\n<pre><code>BookArray [] = {45,10,11,3,2,7,9,1,0}\n</code></pre>\n\n<p>I then decided to shuffle the elements (so they are no longer in binary heap) and got this.</p>\n\n<pre><code>Shuffled[] = {11,1,0,7,9,3,2,10,45}\n</code></pre>\n\n<p>I then decided to write a program that would sort the elements in the array in Min-Heap\nso I got this array</p>\n\n<pre><code>Sorted[] = {45,11,3,10,7,0,2,1,9}\n</code></pre>\n\n<p>My question is if my sorted array is also a valid max-heap ? since my array does not match the bookArray</p>\n', 'ViewCount': '34', 'Title': 'Is this a proper Max Heap Data Structure', 'LastEditorUserId': '2421', 'LastActivityDate': '2014-03-22T19:19:23.603', 'LastEditDate': '2014-03-22T18:30:06.260', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22943', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2421', 'Tags': '<data-structures><binary-trees><heaps>', 'CreationDate': '2014-03-22T17:50:21.793', 'Id': '22941'},28319:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I've been given the following question and I've been finding it hard to give a good answer:</p>\n\n<p>Prove or disprove: given a max-heap with n distinct elements, using Extract-Max to extract n/2 of the elements takes \u03a9(nlogn) time.</p>\n\n<p>Because the heap contains distinct elements, I'm lead to believe the claim is true: I've tried to create heaps with distinct elements such that Extract-Max would take O(1) for n/2 extractions, but just couldn't do it. So, in order to prove the claim, I've tried to prove another claim that could help - that in a heap with distinct elements, Extract-Max would take \u03a9(logn) except for maybe the first few times, but couldn't prove it either.</p>\n\n<p>Does anyone have a nice way to prove/disprove this?</p>\n", 'ViewCount': '42', 'Title': 'Complexity of using Extract-Max to extract n/2 elements from a max-heap with n distinct elements', 'LastEditorUserId': '17072', 'LastActivityDate': '2014-04-25T13:03:50.300', 'LastEditDate': '2014-04-25T13:03:50.300', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17072', 'Tags': '<heaps>', 'CreationDate': '2014-04-25T12:32:27.563', 'FavoriteCount': '1', 'Id': '24101'},28320:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a binary min-heap, size n, and I want to delete a number of\nelements, identified by some predicate.</p>\n\n<p>Any algorithm needs at least n tests of the predicate (preferably,\n<em>exactly</em> n), so the interesting performance metrics are the number of\nmoves of elements, and the number of additional tests of the\npredicate.</p>\n\n<p>One possible way is to first delete elements from the corresponding\narray, using a single pass to delete elements and compact the array.\nAnd then rebuild the heap from the array. Both steps are O(n). But as\nfar as I understand, the rebuild step can need n moves of elements\neven if only one or two elements are deleted, if they are at unlucky\npositions in the array.</p>\n\n<p>I wonder if there's some good algorithm which</p>\n\n<ul>\n<li><p>needs O(n) element moves in the worst case</p></li>\n<li><p>needs few extra tests of the predicate, say total n + O(log n) tests\nin the worst case</p></li>\n<li><p>needs a lot fewer then n element moves in the special cases that\nonly a few elements are deleted, or only a few elements are kept.</p></li>\n</ul>\n", 'ViewCount': '29', 'Title': "What's a good algorithm for deleting multiple elements in a heap?", 'LastActivityDate': '2014-04-30T19:31:57.630', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '17212', 'Tags': '<heaps>', 'CreationDate': '2014-04-30T11:16:14.693', 'Id': '24254'},28321:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m studying binomial heaps in anticipation for my finals and the <a href="http://en.wikipedia.org/wiki/CLRS" rel="nofollow">CLRS</a> book tells me that insertion in a binomial heap takes $\\Theta(\\log n)$ time. So given an array of numbers it would take $\\Theta(n\\log n)$ time to convert it a a binomial heap. To me that seems a bit pessimistic and like a naive implementation. Does anyone know of a method/implementation that can convert an array of numbers to a binary heap in $\\Theta(n)$ time?</p>\n', 'ViewCount': '46', 'Title': 'efficient binomial heap', 'LastActivityDate': '2014-05-03T15:47:26.787', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '24356', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15826', 'Tags': '<algorithms><algorithm-analysis><heaps>', 'CreationDate': '2014-05-03T14:47:09.500', 'Id': '24355'}