{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '649', 'Title': 'What are the conditions for a NFA for its equivalent DFA to be maximal in size?', 'LastEditDate': '2012-03-15T10:17:50.310', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '1', 'Body': "<p>We know that DFAs are equivalent to NFAs in expressiveness power; there is also a known algorithm for converting NFAs to DFAs (unfortunately I do now know the inventor of that algorithm), which in worst case gives us $2^S$ states, if our NFA had $S$ states.</p>\n\n<p>My question is: what is determining the worst case scenario?</p>\n\n<hr>\n\n<p>Here's a transcription of an algorithm in case of ambiguity:</p>\n\n<p>Let $A = (Q,\\Sigma,\\delta,q_0,F)$ be a NFA. We construct a DFA $A&#39; = (Q&#39;,\\Sigma,\\delta&#39;,q&#39;_0,F&#39;)$ where </p>\n\n<ul>\n<li>$Q&#39; = \\mathcal{P}(Q)$, </li>\n<li>$F&#39; = \\{S \\in Q&#39; | F \\cap S \\neq \\emptyset \\}$,</li>\n<li>$\\delta&#39;(S,a) =\\bigcup_{s \\in S} (\\delta(s,a) \\cup \\hat \\delta(s,\\varepsilon))$, and</li>\n<li>$q&#39;_0 = \\{q_0\\} \\cup \\hat \\delta(q_0, \\varepsilon)$,</li>\n</ul>\n\n<p>where $\\hat\\delta$ is the extended transition function of $A$.</p>\n", 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-27T10:45:27.090', 'CommentCount': '1', 'AcceptedAnswerId': '131', 'CreationDate': '2012-03-08T10:20:46.940', 'Id': '130'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '510', 'Title': 'A sufficient and necessary condition about regularity of a language', 'LastEditDate': '2012-03-15T11:35:19.527', 'AnswerCount': '5', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '51', 'FavoriteCount': '1', 'Body': '<blockquote>\n  <p>Which of the following statements is correct?   </p>\n  \n  <ol>\n  <li>sufficient and necessary conditions about regularity of a language exist but not discovered yet.</li>\n  <li><p>There\'s no sufficient and necessary condition about regularity of a\n  language.</p></li>\n  <li><p>Pumping lemma is a necessary condition for non-regularity of a\n      language.</p></li>\n  <li>Pumping lemma is a sufficient condition for non-regularity of a\n  language.</li>\n  </ol>\n</blockquote>\n\n<p>I know <a href="http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages#Converse_of_lemma_not_true" rel="nofollow">#(4) is correct and #(3) is false</a> because "the converse of this statement is not true: a language that satisfies these conditions may still be non-regular", but what can be said about (1) and (2)?</p>\n', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-15T11:35:19.527', 'CommentCount': '6', 'AcceptedAnswerId': '162', 'CreationDate': '2012-03-09T13:03:34.620', 'Id': '156'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '539', 'Title': 'What are the possible sets of word lengths in a regular language?', 'LastEditDate': '2012-03-10T15:16:58.000', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Given a language $L$, define the length set of $L$ as the set of lengths of words in $L$:\n$$\\mathrm{LS}(L) = \\{|u| \\mid u \\in L \\}$$</p>\n\n<p>Which sets of integers can be the length set of a regular language?</p>\n', 'Tags': '<formal-languages><computability><regular-languages><finite-automata>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-10T15:16:58.000', 'CommentCount': '2', 'AcceptedAnswerId': '175', 'CreationDate': '2012-03-09T16:46:44.240', 'Id': '164'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm working on a parser for a C-style language, and for that parser I need the regular expression that matches C-style /**/ comments. Now, I've found this expression on the web:</p>\n\n<pre><code>/\\*([^\\*]*\\*+[^\\*/])*([^\\*]*\\*+|[^\\*]*\\*/\n</code></pre>\n\n<p>However, as you can see, this is a rather messy expression, and I have no idea whether it actually matches exactly what I want it to match.</p>\n\n<p>Is there a different way of (rigorously) defining regular expressions that are easy to check by hand that they are really correct, and are then convertible ('compilable') to the above regular expression?</p>\n", 'ViewCount': '845', 'Title': 'Deriving the regular expression for C-style /**/ comments', 'LastEditorUserId': '95', 'LastActivityDate': '2013-03-20T16:37:17.823', 'LastEditDate': '2012-03-13T21:36:26.030', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '312', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<compilers><parsers><regular-languages>', 'CreationDate': '2012-03-13T14:00:00.143', 'Id': '311'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I came across this figure which shows that context-free and regular languages are (proper) subsets of efficient problems (supposedly $\\mathrm{P}$). I perfectly understand that efficient problems are a subset of all decidable problems because we can solve them but it could take a very long time. </p>\n\n<p>Why are <em>all</em> context-free and regular languages efficiently decidable? Does it mean solving them will not take a long time (I mean we know it without more context)?</p>\n\n<p><img src="http://i.stack.imgur.com/xdEBQ.jpg" alt="enter image description here"></p>\n', 'ViewCount': '1486', 'Title': 'Are all context-free and regular languages efficiently decidable?', 'LastEditorUserId': '51', 'LastActivityDate': '2012-03-13T17:33:24.600', 'LastEditDate': '2012-03-13T17:33:24.600', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><regular-languages><context-free><efficiency>', 'CreationDate': '2012-03-13T15:59:26.123', 'Id': '315'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '228', 'Title': 'Is this language defined using twin primes regular?', 'LastEditDate': '2012-03-14T15:49:25.680', 'AnswerCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '147', 'FavoriteCount': '2', 'Body': '<p>Let</p>\n\n<p>$\\qquad L = \\{a^n \\mid \\exists_{p \\geq n}\\ p\\,,\\ p+2 \\text{ are prime}\\}.$</p>\n\n<p>Is $L$ regular?</p>\n\n<p>This question looked suspicious at the first glance and I\'ve realized that it is connected with the <a href="https://en.wikipedia.org/wiki/Twin_prime">twin prime conjecture</a>. My problem is that the conjecture has not been resolved yet, so I am not sure how can I proceed with deciding that the language is regular. </p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-14T20:25:40.660', 'CommentCount': '2', 'AcceptedAnswerId': '377', 'CreationDate': '2012-03-14T15:42:01.860', 'Id': '376'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>Note this is a question related to study in a CS course at a university, it is NOT homework and can be found <a href="http://www.cs.ucf.edu/~dmarino/ucf/transparency/cot4210/exam/">here</a> under Fall 2011 exam2.</em></p>\n\n<p>Here are the two questions I\'m looking at from a past exam.  They seem to be related, the first:</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{CFG}} = \\{ &lt; \\! G \\! &gt; \\mid G \\text{ is a Context Free Grammar with } |\\mathcal{L}(G)|&lt;\\infty \\} $</p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{CFG}}$ is a decidable language.   </p>\n</blockquote>\n\n<p>and...</p>\n\n<blockquote>\n  <p>Let </p>\n  \n  <p>$\\qquad \\mathrm{FINITE}_{\\mathrm{TM}} = \\{ &lt; \\! M\\!&gt; \\mid M \\text{ is a Turing Machine with } |\\mathcal{L}(M)|&lt;\\infty \\}$ </p>\n  \n  <p>Prove that $\\mathrm{FINITE}_{\\mathrm{TM}}$ is an undecidable language.   </p>\n</blockquote>\n\n<p>I am a bit lost on how to tackle these problems, but I have a few insights which I think may be in the right direction.  The first thing is that I am aware of is that the language $A_{\\mathrm{REX}}$, where </p>\n\n<blockquote>\n  <p>$\\qquad A_{\\mathrm{REX}} = \\{ &lt;\\! R, w \\!&gt; \\mid R \\text{ is a regular expression with } w \\in\\mathcal{L}(R)\\}$</p>\n</blockquote>\n\n<p>is a decidable language (proof is in Michael Sipser\'s <i>Theory of Computation</i>, pg. 168).  The same source also proves that a Context Free Grammar can be converted to a regular expression, and vice versa.  Thus $A_{\\mathrm{CFG}}$, must also be decidable as it can be converted to a regular expression.  This, and the fact that $A_{\\mathrm{TM}}$ is <b>un</b>-decidable, seems to be related to this problem.</p>\n\n<p>The only thing I can think of is passing G to Turing machines for $A_{\\mathrm{REX}}$ (after converting G to a regular expression) and $A_{\\mathrm{TM}}$.  Then accepting if G does and rejecting if G doesn\'t.  As $A_{\\mathrm{TM}}$ is undecidable, this will never happen.  Somehow I feel like I\'m making a mistake here, but I\'m not sure of what it is.  Could someone please lend me a hand here? </p>\n', 'ViewCount': '639', 'Title': 'Decidablity of Languages of Grammars and Automata', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T02:52:20.370', 'LastEditDate': '2012-03-27T02:52:20.370', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '629', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><computability><context-free><regular-languages><turing-machines>', 'CreationDate': '2012-03-21T20:07:51.783', 'Id': '627'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Write $\\bar n$ for the decimal expansion of $n$ (with no leading <code>0</code>). Let $a$ and $b$ be integers, with $a &gt; 0$. Consider the language of multiples of $a$ plus a constant:</p>\n\n<p>$$M = \\{ \\overline{a\\,x+b} \\mid x\\in\\mathbb{N} \\}$$</p>\n\n<p>Is $M$ regular? context-free?</p>\n\n<p>(Contrast with <a href="http://cs.stackexchange.com/questions/641/language-of-the-graph-of-an-affine-function">Language of the graph of an affine function</a>)</p>\n\n<p><sub> I think this would make a good homework question, so answers that start with a hint or two and explain not just how to solve the question but also how to decide what techniques to use would be appreciated. </sub></p>\n', 'ViewCount': '522', 'Title': 'Language of the values of an affine function', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-20T16:01:38.250', 'LastEditDate': '2012-03-22T09:26:48.400', 'AnswerCount': '5', 'CommentCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<formal-languages><context-free><regular-languages><integers>', 'CreationDate': '2012-03-22T01:54:55.207', 'FavoriteCount': '1', 'Id': '640'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Write $\\bar n$ for the decimal expansion of $n$ (with no leading <code>0</code>). Let <code>:</code> be a symbol distinct from any digit. Let $a$ and $b$ be integers, with $a &gt; 0$. Consider the language of solutions of the Diophantine equation $y=ax+b$:</p>\n\n<p>$$L = \\{ \\bar{x} \\mathtt: \\bar{y} \\mid y = a\\,x + b \\}$$</p>\n\n<p>Is $L$ regular? context-free?</p>\n\n<p>(Contrast with <a href="http://cs.stackexchange.com/questions/640/language-of-the-multiples-of-an-integer">Language of the values of an affine function</a>)</p>\n\n<p><sub>(Follows on <a href="http://cs.stackexchange.com/questions/618/how-can-solutions-of-a-diophantine-equation-be-expressed-as-a-language">How can solutions of a Diophantine equation be expressed as a language?</a>)</sub></p>\n\n<p><sub> I think this would make a good homework question, so answers that start with a hint or two and explain not just how to solve the question but also how to decide what techniques to use would be appreciated. </sub></p>\n', 'ViewCount': '158', 'Title': 'Language of the graph of an affine function', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-22T19:27:05.530', 'LastEditDate': '2012-03-22T15:52:06.720', 'AnswerCount': '3', 'CommentCount': '7', 'AcceptedAnswerId': '667', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '39', 'Tags': '<formal-languages><regular-languages><context-free><integers>', 'CreationDate': '2012-03-22T01:55:17.983', 'Id': '641'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is it true that the set $\\{ 0^{n^2} \\mid n \\in\\mathbb{N} \\}$ is not regular because it does not grow linearly?</p>\n\n<blockquote>\n  <p>Regular sets are called regular because if you have a regular set then you can always pump it up (pumping lemma) in regular intervals and get other things in the set. They string out at very linear intervals. That's why anything that grows in other than linear intervals is not regular.</p>\n</blockquote>\n\n<p>Therefore, $\\{ a^{n^2} b^n \\mid n \\in\\mathbb{N} \\}$ is not regular, right? Also, I know that $\\{ a^n b^n \\mid n \\in\\mathbb{N} \\}$ is not regular, but what about $\\{ a^{cn} b^{dn} \\mid n \\in\\mathbb{N} \\}$ for any integer coefficients $c$ and $d$?</p>\n", 'ViewCount': '91', 'Title': 'Regular sets have linear growth?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-04-03T18:03:34.037', 'LastEditDate': '2012-04-03T18:00:52.383', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '922', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-04-03T17:38:06.640', 'Id': '1006'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to use pumping lemma to prove that $L = \\{(01)^m 2^m \\mid m \\ge0\\}$ is not regular.</p>\n\n<p>This is what I have so far: Assume $L$ is regular and let $p$ be the pumping length, so $w = (01)^p 2^p$. Consider any pumping decomposition $w = xyz$ such that  $|y| &gt;0$ and $|xy| \\le p$.</p>\n\n<p>I'm not sure what to do next.</p>\n\n<p>Am I on the right track? Or am I way off?</p>\n", 'ViewCount': '1479', 'Title': 'Using Pumping Lemma to prove language is not regular', 'LastEditorUserId': '31', 'LastActivityDate': '2012-04-04T15:06:30.917', 'LastEditDate': '2012-04-04T09:40:24.787', 'AnswerCount': '3', 'CommentCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '934', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-04-04T06:45:22.807', 'FavoriteCount': '1', 'Id': '1027'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '11911', 'Title': 'How to prove that a language is not regular?', 'LastEditDate': '2013-06-06T13:54:20.203', 'AnswerCount': '5', 'Score': '26', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '21', 'Body': '<p>We learned about the class of regular languages $\\mathrm{REG}$. It is characterised by any one concept among regular expressions, finite automata and left-linear grammars, so it is easy to show that a given language is regular.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for all regular expressions (or for all finite automata, or for all left-linear grammars) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n\n<p><em><sup>This is intended to be a reference question collecting usual proof methods and application examples. See <a href="http://cs.stackexchange.com/q/265/98">here</a> for the same question on context-free languages.</sup></em></p>\n', 'Tags': '<formal-languages><regular-languages><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-07-01T12:50:16.730', 'CommentCount': '4', 'AcceptedAnswerId': '1033', 'CreationDate': '2012-04-04T10:30:32.163', 'Id': '1031'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '399', 'Title': 'Number of words in the regular language $(00)^*$', 'LastEditDate': '2012-04-04T20:15:01.173', 'AnswerCount': '3', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '92', 'FavoriteCount': '2', 'Body': '<p><a href="http://en.wikipedia.org/wiki/Regular_language#The_number_of_words_in_a_regular_language">According to Wikipedia</a>, for any regular language $L$ there exist constants $\\lambda_1,\\ldots,\\lambda_k$ and polynomials $p_1(x),\\ldots,p_k(x)$ such that for every $n$ the number $s_L(n)$ of words of length $n$ in $L$ satisfies the equation </p>\n\n<p>$\\qquad \\displaystyle s_L(n)=p_1(n)\\lambda_1^n+\\dots+p_k(n)\\lambda_k^n$.</p>\n\n<p>The language $L =\\{ 0^{2n} \\mid n \\in\\mathbb{N} \\}$ is regular ($(00)^*$ matches it). $s_L(n) = 1$ iff n is even, and $s_L(n) = 0$ otherwise.</p>\n\n<p>However, I can not find the $\\lambda_i$ and $p_i$ (that have to exist by the above). As $s_L(n)$ has to be differentiable and is not constant, it must somehow behave like a wave, and I can\'t see how you can possibly do that with polynomials and exponential functions without ending up with an infinite number of summands like in a Taylor expansion. Can anyone enlighten me?</p>\n', 'Tags': '<formal-languages><regular-languages><combinatorics><word-combinatorics>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-04-15T14:41:18.683', 'CommentCount': '3', 'AcceptedAnswerId': '1040', 'CreationDate': '2012-04-04T15:53:43.390', 'Id': '1039'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '428', 'Title': 'Number of words of a given length in a regular language', 'LastEditDate': '2012-04-05T02:09:41.130', 'AnswerCount': '2', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '39', 'FavoriteCount': '1', 'Body': '<p>Is there an algebraic characterization of the number of words of a given length in a regular language?</p>\n\n<p><a href="http://en.wikipedia.org/wiki/Regular_language#The_number_of_words_in_a_regular_language">Wikipedia</a> states a result somewhat imprecisely:</p>\n\n<blockquote>\n  <p>For any regular language $L$ there exist constants $\\lambda_1,\\,\\ldots,\\,\\lambda_k$ and polynomials $p_1(x),\\,\\ldots,\\,p_k(x)$\n  such that for every $n$ the number $s_L(n)$ of words of length $n$ in $L$ satisfies the equation\n  $s_L(n)=p_1(n)\\lambda_1^n+\\dotsb+p_k(n)\\lambda_k^n$.</p>\n</blockquote>\n\n<p>It\'s not stated what space the $\\lambda$\'s live in ($\\mathbb{C}$, I presume) and whether the function is required to have nonnegative integer values over all of $\\mathbb{N}$. I would like a precise statement, and a sketch or reference for the proof.</p>\n\n<p>Bonus question: is the converse true, i.e. given a function of this form, is there always a regular language whose number of words per length is equal to this function?</p>\n\n<p><sub> This question generalizes <a href="http://cs.stackexchange.com/questions/1039/question-about-the-number-of-words-in-a-regular-language">Question about the number of words in a regular language</a> </sub>  </p>\n', 'Tags': '<formal-languages><regular-languages><word-combinatorics>', 'LastEditorUserId': '41', 'LastActivityDate': '2013-09-22T06:53:52.867', 'CommentCount': '7', 'AcceptedAnswerId': '14481', 'CreationDate': '2012-04-04T20:13:16.497', 'Id': '1045'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/640/language-of-the-values-of-an-affine-function">Language of the values of an affine function</a>  </p>\n</blockquote>\n\n\n\n<p>Let $C_n = \\{x\\mid x \\text{ is a binary number that is a multiple of } n\\}$. Show that for each $n$, the language $C_n$ is regular.</p>\n\n<p>Just provide a generic recipe (i.e., a formal definition for arbitrary $n$).</p>\n', 'ViewCount': '96', 'ClosedDate': '2012-04-05T14:34:36.797', 'Title': 'Multiples of n is a regular language', 'LastEditorUserId': '157', 'LastActivityDate': '2012-04-05T03:20:45.850', 'LastEditDate': '2012-04-05T03:20:45.850', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'OwnerDisplayName': 'user8978', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-04-05T02:59:27.360', 'Id': '1050'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '535', 'Title': 'How to prove regular languages are closed under left quotient?', 'LastEditDate': '2012-04-18T05:56:10.247', 'AnswerCount': '1', 'Score': '8', 'OwnerDisplayName': 'corium', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '1', 'Body': '<p>L is a regular language over the alphabet $\\sum = \\{a,b\\}$. The left quotient of L regarding $w \\in \\sum^*$ is the language \n$$w^{-1} L := \\{v: wv \\in L\\}$$</p>\n\n<p>How can I prove that $w^{-1}$ L is regular?</p>\n', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T05:56:10.247', 'CommentCount': '0', 'AcceptedAnswerId': '1327', 'CreationDate': '2012-04-17T20:58:50.560', 'Id': '1326'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '6747', 'Title': 'How to prove a language is regular?', 'LastEditDate': '2013-06-06T13:56:25.667', 'AnswerCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '4', 'Body': '<p>There are many methods to prove that <a href="http://cs.stackexchange.com/q/1031/157">a language is not regular</a>, but what do I need to do to prove that some language <em>is</em> regular?</p>\n\n<p>For instance, if I am given that $L$ is regular, \nhow can I prove that the following $L&#39;$ is regular, too?</p>\n\n<p>$\\qquad \\displaystyle L&#39; := \\{w \\in L: uv = w \\text{ for } u \\in \\Sigma^* \\setminus L \\text{ and } v \\in \\Sigma^+ \\}$</p>\n\n<p>Can I draw a nondeterministic finite automaton to prove this?</p>\n', 'Tags': '<formal-languages><regular-languages><automata><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-09-20T17:34:26.467', 'CommentCount': '4', 'AcceptedAnswerId': '1333', 'CreationDate': '2012-04-18T05:21:31.750', 'Id': '1331'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In my computability class we were given a practice final to go over and I'm really struggling with one of the questions on it.</p>\n\n<blockquote>\n  <p>Prove the following statement:</p>\n  \n  <p>If $L_1$ is a regular language, then so is</p>\n  \n  <p>$L_2 = \\{ uv |$ $u$ is in $L_1$ or $v$ is in $L_1 \\}$.</p>\n</blockquote>\n\n<p>You can't use the pumping lemma for regular languages (I think), so how would you go about this? I'm inclined to believe that it's false because if $u$ is in $L_1$, what if $v$ is non-regular? Then it would be impossible to write a regular expression for it. The question is out of 5 marks though and that doesn't seem like enough of an answer for it.</p>\n", 'ViewCount': '301', 'Title': 'Proving a specific language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-22T12:07:26.237', 'LastEditDate': '2012-04-22T12:07:26.237', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'user1217222', 'PostTypeId': '1', 'OwnerUserId': '16846', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-04-21T16:17:21.963', 'Id': '1414'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '597', 'Title': 'Words that have the same right- and left-associative product', 'LastEditDate': '2012-04-24T06:17:40.090', 'AnswerCount': '4', 'Score': '7', 'OwnerDisplayName': 'Ismael Mezquino', 'PostTypeId': '1', 'OwnerUserId': '1217', 'FavoriteCount': '1', 'Body': '<p>I have started to study non deterministic automata using the book of <a href="https://en.wikipedia.org/wiki/Introduction_to_Automata_Theory,_Languages,_and_Computation" rel="nofollow">Hopcroft and Ullman</a>. I\'m stuck in a problem that I found very interesting:</p>\n\n<blockquote>\n  <p>Give a non deterministic finite automaton accepting all the strings that\n  have the same value when evaluated left to right as right to left by\n  multiplying according to the following table:</p>\n  \n  <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \r\n    \\times &amp; a &amp; b &amp; c \\\\\r\n    \\hline \r\n    a &amp; a &amp; a &amp; c \\\\\r\n    b &amp; c &amp; a &amp; b \\\\\r\n    c &amp; b &amp; c &amp;a\r\n   \\end{array}$</p>\n</blockquote>\n\n<p>So if we have the string $abc$,<br>\nthe product from left to right is $(a \\times b) \\times c=a \\times c=c$ and<br>\nthe product from right to left is $a \\times (b \\times c)=a \\times b=a$</p>\n\n<p>So $abc$ should not be acceptable for the automata. To me its obvious that any string $aa^*$ or $bb^*$ or $cc^*$ is an aceptable string (their right and left evaluation work on the same partial strings). It is easy to give an NFA that describes the left to right evaluation but the problem is that if the machine try to compute the <em>right to left</em> evaluation I think it needs to know the length of the string (so infinite memory is necessary).</p>\n\n<p>So how can a non deterministic automata evaluate from right to left in order to compare with the left to right evaluation?</p>\n', 'Tags': '<formal-languages><automata><regular-languages><finite-automata><nondeterminism>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-25T17:11:22.873', 'CommentCount': '0', 'AcceptedAnswerId': '1479', 'CreationDate': '2012-04-23T18:12:11.180', 'Id': '1467'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I'm really struggling with the pumping lemma.  I think most of my problems come from not understanding how you can and can't split the string in a pumping lemma question.  Here is an example, take the problem prove that $L = \\{w | w$ contains more $0$'s than $1$'s over the language $\\{0,1\\} \\}$ is not regular via the pumping lemma.</p>\n\n<p>So I choose the string $01^{p}0^{p}$.  Since this is a regular language pumping lemma problem I know that: </p>\n\n<ol>\n<li>for each $i &gt; 0, xy^{i}z \\in A$,</li>\n<li>$|y^{i}| &gt; 0$, and</li>\n<li>$|xy| &lt; p$</li>\n</ol>\n\n<p>I am little uncertain about other possibilites though, such as if $x$, or $z$ can be null (obviously $y$ can't by condition 2).  I assume that this isn't possible since I don't think the preceding or trailing whitespace is considered part of the string, but I'm not sure.  <strong>Is it possible for $x$ or $z$ to be null?</strong></p>\n", 'ViewCount': '122', 'Title': 'Null Characters and Splitting the String in the Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-23T22:21:55.283', 'LastEditDate': '2012-04-23T22:21:55.283', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1470', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '603', 'Tags': '<formal-languages><regular-languages><proof-techniques><pumping-lemma>', 'CreationDate': '2012-04-23T19:29:10.360', 'Id': '1469'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Here's a conjecture for regular expressions:</p>\n\n<blockquote>\n  <p>For regular expression $R$, let the length $|R|$ be the number of symbols in it,\n  ignoring parentheses and operators. E.g. $|0 \\cup 1| = |(0 \\cup 1)^*| = 2$</p>\n  \n  <p><strong>Conjecture:</strong> If $|R| &gt; 1$ and $L(R)$ contains every string of length $|R|$ or less, then $L(R) = \\Sigma^*$.</p>\n</blockquote>\n\n<p>That is, if $L(R)$ is 'dense' up to $R$'s length, then $R$ actually generates everything.</p>\n\n<p>Some things that may be relevant:</p>\n\n<ol>\n<li>Only a small part of $R$ is needed to generate all strings. For example in binary, $R = (0 \\cup 1)^* \\cup S$ will work for any $S$.</li>\n<li>There needs to be a Kleene star in $R$ at some point. If there isn't, it will miss some string of size less than $|R|$. </li>\n</ol>\n\n<p>It would be nice to see a proof or counterexample. Is there some case where it's obviously wrong that I missed? Has anyone seen this (or something similar) before?  </p>\n", 'ViewCount': '296', 'Title': '"Dense" regular expressions generate $\\Sigma^*$?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-19T21:45:29.463', 'LastEditDate': '2012-04-26T06:49:15.443', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1512', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '1245', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-04-26T04:17:35.663', 'Id': '1511'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd love your help with the following question:</p>\n\n<blockquote>\n  <p>Let $G$ be context free grammar in the <strong>Chomksy normal form</strong> with $k$\n  variables.</p>\n  \n  <p>Is the language $B = \\{ w \\in L(G) : |w| &gt;2^k \\}$ regular ?</p>\n</blockquote>\n\n<p>What is it about the amount of variables and the Chomsky normal form that is supposed to help me solve this question? I tried to look it up on the web, but besides information about the special form itself, I didn't find an answer to my question.</p>\n\n<p>The answer for the question is that $B$ might be regular.</p>\n", 'ViewCount': '275', 'Title': 'Chomsky normal form and regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-27T15:37:47.150', 'LastEditDate': '2012-04-27T15:37:47.150', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1532', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'CreationDate': '2012-04-27T12:13:32.993', 'Id': '1525'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I would like your help with the following question:</p>\n\n<blockquote>\n  <p>Let $L$ be a language, and operator $A(L)=\\{\\,ww^Rw \\mid w \\in L\\ \\wedge\\ |w| \\lt 2007\\,\\}$ where $x^R$ is the  reversed string of $x$. Which of the\n  following statements are correct?</p>\n  \n  <ol>\n  <li>If $L$ is regular so $A(L)$ is regular.</li>\n  <li>If $L$ is a CFL which is not regular then $A(L)$ is CFL which is not regular.</li>\n  <li>If $L$ is a CFL which is not regular, then $A(L)$ is a CFL which may or may not be regular.</li>\n  <li>If $L$ is not a CFL then $A(L)$ is not CFL.</li>\n  </ol>\n</blockquote>\n\n<p>What does the fact that $|w|&lt; 2007$ help me with the decision? \nFor (2) I can choose $O^n1^n$ and I get that $0^n1^{2n}0^{2n}1^n$, which is not regular, but for (3),(4) I can't find an examples to refute it. The answer is 3, but I can't understand why, since $A(L)= ww^R \\circ  w$  but $ww^R$ is not regular.</p>\n", 'ViewCount': '180', 'Title': 'Closure against the operator $A(L)=\\{ww^Rw \\mid w \\in L \\wedge |w| \\lt 2007\\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-28T09:52:19.380', 'LastEditDate': '2012-04-28T09:52:19.380', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '1537', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2012-04-27T18:59:52.513', 'Id': '1536'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd really love your help with the following:</p>\n\n<p>For <em>any</em> fixed $L_2$ I need to decide whether there is closure under the following operators:</p>\n\n<ol>\n<li><p>$A_r(L)=\\{x \\mid \\exists  y \\in L_2 : xy \\in L\\}$</p></li>\n<li><p>$A_l(L)=\\{x \\mid \\exists  y \\in L : xy \\in L_2\\}$.</p></li>\n</ol>\n\n<p>The relevant options are:</p>\n\n<ol>\n<li><p>Regular languages are closed under $A_l$ resp. $A_r$, for any language $L_2$ </p></li>\n<li><p>For some languages $L_2$, regular languages are closed under $A_l$ resp. $A_r$, and for some languages $L_2$, regular languages are not closed under $A_l$ resp. $A_r$.</p></li>\n</ol>\n\n<p>I believed that the answer for (1) should be (2), because when I get a word in $w \\in L$ and $w=xy$ I can build an automaton that can guess where $x$ turning to $y$, but then it needs to verify that $y$ belongs to $L_2$ and if it won't be regular, how would it do that?<br>\nThe answer for that is (1).</p>\n\n<p>What should I do in order to analyze those operators correctly and to determine if the regular languages are closed under them or not?</p>\n", 'ViewCount': '517', 'Title': 'Closure against right quotient with a fixed language', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-29T11:50:36.987', 'LastEditDate': '2012-04-29T11:50:36.987', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '1554', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-04-28T10:33:42.823', 'Id': '1547'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I prove that the language that the operator $A$ defines for regular language $L$ is a context free language.</p>\n\n<p>$A(L)= \\{ w_1w_2: |w_1|=|w_2|$ and $w_1, w_2^R \\in L \\}$, where $x^R$ is the reversed form of $x$. </p>\n\n<p>I understand that since $L$ is regular so does $L^R$.also on my way for a CFG I can reach $w_1$ by the CFG of $L$ concatenation with the one of $L^R$ for making $w_2$. so far I have a CFG, but what promises me that $|w_1|=|w_2|$? how can I generate a grammar that will also keep that in addition to the other conditions?</p>\n', 'ViewCount': '253', 'Title': 'Why does $A(L)= \\{ w_1w_2: |w_1|=|w_2|$ and $w_1, w_2^R \\in L \\}$ generate a context free language for regular $L$?', 'LastEditorUserId': '1183', 'LastActivityDate': '2012-05-03T07:50:41.343', 'LastEditDate': '2012-05-01T08:07:29.893', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '1593', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'CreationDate': '2012-04-30T16:31:10.080', 'Id': '1592'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I read <a href="http://cs.stackexchange.com/questions/1027/using-pumping-lemma-to-prove-language-is-not-regular">on the site</a> on how to use the pumping lemma but still I don\'t what is wrong with way I\'m using it for proving that the following language is not a regular language:</p>\n\n<p>$L = \\{a^ib^jc^k \\mid \\text{if } i=1 \\text{ then } j=k \\}$</p>\n\n<p>for $i\\neq1$ the language is obviously regular but in the case which $i=1$ , we get that the language is $a^1b^nc^n$, now for every division $w=xyz$ such that $|y|&gt;0 , |xy|&lt; p$ where p is the pumping constant I get the word $a^1b^pc^p$ would be out of the language. since  $|xy|&lt; p$\n, $y$ may contains only $a&#39;s$ or $b&#39;s$ or both. if $x= \\epsilon$ and $y=a$, pump it once and you\'re out of the language, if it contains only $b&#39;s$, pump it once and your\'e out of the language, and if it contains both, pump it and you\'re out of the language again.</p>\n\n<p>so, why does this language considered as not regular and cannot be proved for its irregularity by the pumping lemma? please point out my mistake.  </p>\n', 'ViewCount': '1107', 'Title': 'Irregularity of $\\{a^ib^jc^k \\mid \\text{if } i=1 \\text{ then } j=k \\}$', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-09T13:23:03.370', 'LastEditDate': '2012-05-09T13:23:03.370', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '1678', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-05-01T16:26:23.790', 'Id': '1616'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Consider this example (taken from this document: <a href="http://www.cs.nott.ac.uk/~txa/g51mal/notes-3x.pdf" rel="nofollow">Showing that language is not regular</a>):</p>\n\n<p>$$L = \\{1^n \\mid n\\text{ is even}\\} $$</p>\n\n<p>According to the Pumping Lemma, a language $L$ is regular if :</p>\n\n<ul>\n<li>$y \\ne \u03b5$</li>\n<li>$|xy| \\lt n$</li>\n<li>$\\forall k \\in N, xy^kz \\in L$</li>\n</ul>\n\n<p>In the above example, $n$ must be even. Suppose we have $n = 4$, we can express: $$xy^kz$$ such that: $x = 1$, $z = 1$, and with $k = 2$, we have $y^k = y^2 = 11$, so we get the string $1111$. However, since all $k$ must be satisfied, if $k = 1$, the string is $111$, it does not belong to $L$. Yet, I was told that the above example is a regular language. How can it be?</p>\n', 'ViewCount': '1940', 'Title': 'Why is this example a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-10T14:46:55.897', 'LastEditDate': '2012-05-10T14:46:55.897', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '1707', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1134', 'Tags': '<formal-languages><regular-languages><proof-techniques>', 'CreationDate': '2012-05-07T03:45:04.323', 'Id': '1706'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Lets $L_z \\ := \\{ a^i b^i c^i : 0 \\leq i &lt; z \\}$</p>\n\n<p>$\\{a,b,c\\} \\in \\sum^*$</p>\n\n<p>there is a DFA with $\\frac{z(z+1)}{2}+1$ states - How can I prove this?</p>\n\n<p>And I need largest possible number $n_z$, for which i can prove that every NFA, which accepts $L_z$, have $n_z$ states, at least!</p>\n\n<p>But first I need to show that $n_z = \\frac{z(z+1)}{2}$\n right?</p>\n', 'ViewCount': '249', 'Title': 'DFA with limited states', 'LastEditorUserId': '41', 'LastActivityDate': '2014-01-19T15:56:15.823', 'LastEditDate': '2012-05-08T23:09:26.217', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '1743', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-05-08T22:59:08.823', 'Id': '1740'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '309', 'Title': 'Non-regular Languages?', 'LastEditDate': '2012-05-09T14:33:33.083', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1133', 'Body': u'<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Why $L_a$ and  $L_b$  are not reguluar?</p>\n\n<p>$L_a = \\{ e^i f^{n-i} g^j h^{n-j} : n \\in N, 1 \\leq i, j \\leq n \\}$. </p>\n\n<p>$L_b= \\{nm^{i_1} nm^{i_2}...bn^{i_z}: z \\in N, (i_1,...,i_n) \\in N^z, 1 \\leq j \\leq z, i_j \u2260 j \\}$.</p>\n', 'ClosedDate': '2012-05-09T19:58:17.077', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-10T02:21:47.107', 'CommentCount': '8', 'AcceptedAnswerId': '1756', 'CreationDate': '2012-05-09T13:39:25.267', 'Id': '1753'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '546', 'Title': "Why is a regular language called 'regular'?", 'LastEditDate': '2012-05-14T15:15:21.780', 'AnswerCount': '2', 'Score': '20', 'PostTypeId': '1', 'OwnerUserId': '1434', 'FavoriteCount': '3', 'Body': '<p>I have just completed the first chapter of the <a href="http://www-math.mit.edu/~sipser/book.html"><em>Introduction to the Theory of Computation</em></a> by <em>Michael Sipser</em> which explains the basics of finite automata. </p>\n\n<p>He defines a regular language as anything that can be described by a finite automata. But I could not find where he explains why a regular language is called "regular?"  What is the origin of the term "regular" in this context?</p>\n\n<p>NOTE: I am a novice so please try to explain in simple terms!</p>\n', 'Tags': '<formal-languages><regular-languages><terminology><finite-automata><history>', 'LastEditorUserId': '1298', 'LastActivityDate': '2012-05-14T15:15:21.780', 'CommentCount': '1', 'AcceptedAnswerId': '1772', 'CreationDate': '2012-05-10T02:07:18.947', 'Id': '1771'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My answer : (0+1)* 0 (0+1)* 0 (0+1)*</p>\n\n<p>Why is this incorrect? Can somebody explain to me what the correct answer is and why?</p>\n', 'ViewCount': '1105', 'Title': 'Regular expression for all strings with at least two 0s over alphabet {0,1}', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T14:54:41.603', 'LastEditDate': '2012-05-14T14:54:41.603', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '1444', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-05-10T16:38:29.590', 'Id': '1778'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose that $L(M) = L$ where $M$ is a $TM$ that moves only to the right side.</p>\n\n<p>I need to Show that $L$ is regular.</p>\n\n<p>I'd relly like some help, I tried to think of any way to prove it but I didn't reach to any smart conclusion. what is it about the only side right moves and the regularity? </p>\n", 'ViewCount': '216', 'Title': '$L(M) = L$ where $M$ is a $TM$ that moves only to the right side so $L$ is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-14T14:56:52.800', 'LastEditDate': '2012-05-14T14:56:52.800', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '1784', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><turing-machines>', 'CreationDate': '2012-05-10T20:04:18.130', 'Id': '1779'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m looking for intuition about when a language is regular and when it is not. For example, consider:</p>\n\n<p>$$ L = \\{ 0^n 1^n \\mid n \\geq 1 \\} = \\{ 01, 0011, 000111, \\ldots \\}$$</p>\n\n<p>which is not a regular language. Intuitively it seems a very simple language, there doesn\'t seem to be anything complicated going on. What is the difference between $L$ and a regular language like:</p>\n\n<p>$$L\' = \\{ w \\mid w \\text{ does not contain } 11 \\} = \\{0,10\\}^*\\cdot (1 \\mid \\varepsilon).$$</p>\n\n<p>I know how to <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">prove that $L$ is not regular</a>, using the Pumping Lemma. Here I am looking for <strong>intuition</strong> about what makes a language regular.</p>\n', 'ViewCount': '524', 'Title': 'Why is $L= \\{ 0^n 1^n | n \\geq 1 \\}$ not regular language?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-05-22T20:37:44.957', 'LastEditDate': '2012-05-22T20:37:44.957', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '5', 'Tags': '<formal-languages><regular-languages><intuition>', 'CreationDate': '2012-05-14T02:35:11.657', 'Id': '1830'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p><a href="http://en.wikipedia.org/wiki/Pumping_lemma_for_regular_languages">Wikipedia</a> has the following definition of the pumping lemma for regular langauges...</p>\n\n<blockquote>\n  <p>Let $L$ be a regular language. Then there exists an integer $p$ \u2265 1\n  depending only on $L$ such that every string $w$ in $L$ of length at\n  least $p$ ($p$ is called the "pumping length") can be written as $w$ =\n  $xyz$ (i.e., $w$ can be divided into three substrings), satisfying the\n  following conditions:</p>\n  \n  <ol>\n  <li>|$y$| \u2265 1</li>\n  <li>|$xy$| \u2264 $p$</li>\n  <li>for all $i$ \u2265 0, $xy^iz$ \u2208 $L$</li>\n  </ol>\n</blockquote>\n\n<p>I do not see how this is satisfied for a simple finite regular language. If I have an alphabet of {$a,b$} and regular expression $ab$ then $L$ consists of just the one word which is $a$ followed by $b$. I now want to see if my regular language satisfies the pumping lemma...</p>\n\n<p>As nothing repeats in my regular expression the value of $y$ must be empty so that condition 3 is satisifed for all $i$. But if so then it fails condition 1 which says $y$ must be at least 1 in length! </p>\n\n<p>If instead I let $y$ be either $a$, $b$ or $ab$ then it will satisfy condition 1 but fail condition 3 because it never actually repeats itself.</p>\n\n<p>I am obviously missing something mind blowingly obvious. Which is?</p>\n', 'ViewCount': '1218', 'Title': 'Pumping lemma for simple finite regular languages', 'LastActivityDate': '2012-05-15T05:09:27.543', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1434', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2012-05-15T04:47:54.747', 'FavoriteCount': '1', 'Id': '1847'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '727', 'Title': 'Relation between simple and regular grammars', 'LastEditDate': '2012-05-20T21:41:35.507', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1563', 'FavoriteCount': '1', 'Body': '<p>I am reading "An Introduction to Formal Languages and Automata" written by Peter Linz and after reading the first five chapters I face below problem with\nsimple and regular (especially right linear) grammars which are very similar to each other.</p>\n\n<p>What relation exists between these? What is the difference?\nCan you create (non-deterministic) finite automata for simple grammars (obviously without using a stack)?</p>\n', 'Tags': '<regular-languages><automata><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-21T21:29:04.513', 'CommentCount': '1', 'AcceptedAnswerId': '1968', 'CreationDate': '2012-05-20T21:03:35.607', 'Id': '1958'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '985', 'Title': 'Prove that regular languages are closed under the cycle operator', 'LastEditDate': '2012-05-22T07:23:51.960', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '2', 'Body': u"<p>I've got in a few days an exam and have problems to solve this task.</p>\n\n<p>Let $L$ be a regular language over the alphabet $\\Sigma$. We have the operation \n$\\operatorname{cycle}(L) = \\{ xy \\mid x,y\\in \\Sigma^* \\text{ and } yx\\in L\\}$\nAnd now we should show that $\\operatorname{cycle}(L)$ is also regular.</p>\n\n<p>The reference is that we could construct out of a DFA $D=(Q,\\Sigma,\\delta, q_0, F)$ with $L(D) = L$ a $\\epsilon$-NFA $N$ with $L(N) = \\operatorname{cycle}(L)$ and  $2 \xb7 |Q|^2 + 1$ states. </p>\n", 'Tags': '<formal-languages><regular-languages><finite-automata><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T08:35:34.333', 'CommentCount': '2', 'AcceptedAnswerId': '1989', 'CreationDate': '2012-05-22T05:28:58.017', 'Id': '1986'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '336', 'Title': 'Is there a context free, non-regular language $L$, for which $L^*$ is regular?', 'LastEditDate': '2012-05-25T21:02:11.603', 'AnswerCount': '1', 'Score': '6', 'OwnerDisplayName': 'ybz', 'PostTypeId': '1', 'OwnerUserId': '4832', 'Body': '<p>I know that there are non-regular languages, so that $L^*$ is regular, but all examples I can find are context-sensitive but not context free.</p>\n\n<p>In case there are none how do you prove it?</p>\n', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-25T21:02:11.603', 'CommentCount': '1', 'AcceptedAnswerId': '2083', 'CreationDate': '2012-01-08T15:33:04.230', 'Id': '2081'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Given a language $L = \\{a^pb^{2p} \\mid p \\ge 1\\}$, how could I show, using the Pumping Lemma that $L$ is not regular?</p>\n', 'ViewCount': '42', 'ClosedDate': '2012-06-04T08:25:58.397', 'Title': 'Show that a language is not regular using the Pumping Lemma', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-04T23:28:19.053', 'LastEditDate': '2012-06-04T23:28:19.053', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1738', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-06-04T02:01:08.937', 'Id': '2216'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This standard definition of pumping lemma from Wikipedia.</p>\n\n<blockquote>\n  <p>Let $L$ be a regular language. Then there exists an integer $p\\ge  1$ (depending only on $L$) such that every string $w$ in $L$ of length at least $p$ ($p$ is called the "pumping length") can be written as $w = xyz$ (i.e., $w$ can be divided into three substrings), satisfying the following conditions: </p>\n  \n  <ol>\n  <li>$|y| \\ge 1$  </li>\n  <li>$|xy| \\le p$ and  </li>\n  <li>for all $i \\ge 0$, $xy^iz \\in L$.<br>\n  $y$ is the substring that can be pumped (removed or repeated any number of times, and the resulting string is always in $L$).  </li>\n  </ol>\n</blockquote>\n\n<p>What confuses me about the definition of pumping lemma are two requirements: $|y| \\ge 1$  and $i \\ge 0$, $xy^iz$. The way I read it, that we are required to have $y$ length be equal to one or great, and at the same time, we can completely skip it, since $i \\ge 0$, i.e. effectively  $|y| = 0 $.\nIntuitively, it makes sense that we should be able to skip $y$ and still have string be in $L$.  </p>\n', 'ViewCount': '143', 'Title': 'Length of mid part of the string in Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-19T23:21:13.503', 'LastEditDate': '2012-06-13T10:05:01.987', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1758', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-06-13T07:56:54.557', 'FavoriteCount': '1', 'Id': '2357'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '475', 'Title': 'How to feel intuitively that a language is regular', 'LastEditDate': '2012-06-16T16:14:26.113', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '1877', 'FavoriteCount': '2', 'Body': '<p>Given a language $ L= \\{a^n b^n c^n\\}$, how can I say directly, without looking at production rules, that this language is not regular?</p>\n\n<p>I could use pumping lemma but some guys are saying just looking at the grammar that this is not regular one. How is it possible?</p>\n', 'Tags': '<formal-languages><regular-languages><pumping-lemma><intuition>', 'LastEditorUserId': '851', 'LastActivityDate': '2012-06-22T14:12:38.223', 'CommentCount': '5', 'AcceptedAnswerId': '2396', 'CreationDate': '2012-06-16T15:32:24.460', 'Id': '2393'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to proof that if $L_1 \\subset L_2$ and $L_1$ is not regular then $L_2$ it not regular. This is my proof. Is it valid? </p>\n\n<p>Since $L_1$ is not regular, there does not exists a finite automata $M_1$ such that $L_1$ is the language of $M_1$. Pick $x\\in L_1$. So $x \\in L_2$ and suppose that $L_2$ is regular. Then there exists a finite automata $M_2$ such that $L_2$ is the language of $M_2$. Since $x \\in L_2$ and $L_2$ is regular, there exists a state $s\\in S$ such that from the initial state in $M_2$ there is a path $x$ to this final state $s$. Since this holds for all $x \\in L_1$, we can construct a finite automata which language is $L_1$, so $L_1$ is regular, so we reached a contradiction, so $L_2$ is not regular.</p>\n\n<p>Can this be done easier?</p>\n', 'ViewCount': '463', 'Title': 'Are supersets of non-regular languages also non-regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-06-29T12:06:06.380', 'LastEditDate': '2012-06-28T16:53:23.070', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata><check-my-proof>', 'CreationDate': '2012-06-28T16:24:12.253', 'Id': '2528'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>Let $L_1$ be regular, $L_1 \\cap L_2$ regular, $L_2$ not regular. Show that $L_1 \\cup L_2$ is not regular or give a counterexample.</p>\n</blockquote>\n\n<p>I tried this: Look at $L_1 \\backslash (L_2 \\cap L_1)$. This one is regular. I can construct a finite automata for this ($L_1$ is regular, $L_2 \\cap L_1$ is regular, so remove all the paths (finite amount) for $L_1 \\cap L_2$ from the finite amount of paths for $L_1$. So there is a finite amount of paths left for this whole thing. This thing is disjoint from $L_2$, but how can I prove that the union of $L_1 \\backslash (L_1 \\cap L_2)$ (regular) and $L_2$ (not regular) is not regular?</p>\n', 'ViewCount': '2072', 'Title': 'Proof that union of a regular and a not regular language is not regular', 'LastEditorUserId': '667', 'LastActivityDate': '2014-04-19T06:24:37.110', 'LastEditDate': '2012-07-17T18:05:14.560', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1998', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-06-28T20:00:17.477', 'Id': '2537'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I wanted to ask if someone can help me to construct a regular expression over the alphabet $\\{a,b,x\\}$ for the language $L$ which is constituted by all strings containing an odd number of $a$'s, and in which between each pair of consecutive $a$'s there is an even number of $b$'s (and an arbirtary number of $x$'s).</p>\n\n<p>For example, $babbxbbxabbxaabxxbax \\in L$, $bab \\in L$, while $abba \\notin L$ and $abbbaa \\notin L$.</p>\n\n<p>What is the approach?</p>\n", 'ViewCount': '183', 'Title': 'A regular expression for a given formal language', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-10T21:20:38.263', 'LastEditDate': '2012-07-09T09:46:21.820', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '2650', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1011', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-07-09T06:59:11.900', 'Id': '2649'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '138', 'Title': 'regular expression given the language', 'LastEditDate': '2012-07-16T23:36:19.187', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2125', 'FavoriteCount': '1', 'Body': '<p>The language is:\n$$\nL = \\{ (a^n) (b^m) \\mid n + m = 3k, k \\ge 0 \\}\n$$</p>\n\n<p>My attempt at an answer:\n$$\n(a \\cup b)^{3k}\n$$</p>\n\n<p>This will work if the a OR b can change for each instance in the string that is (3k) long. If not, what can I do to fix this?</p>\n', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T23:36:19.187', 'CommentCount': '4', 'AcceptedAnswerId': '2670', 'CreationDate': '2012-07-10T15:19:01.010', 'Id': '2669'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '880', 'Title': 'Are regular expressions $LR(k)$?', 'LastEditDate': '2012-07-18T00:50:56.043', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'Andrea Tucci', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '1', 'Body': '<p>If I have a Type 3 Grammar, it can be represented on a pushdown automaton (without doing any operation on the stack) so I can represent regular expressions by using context free languages. But can I know if a type 3 grammar is $LR(1)$, $LL(1)$, $SLR(1)$, etc. without constructing any parse tables?</p>\n', 'Tags': '<formal-languages><regular-languages><formal-grammars><parsers><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T00:50:56.043', 'CommentCount': '0', 'AcceptedAnswerId': '2715', 'CreationDate': '2012-07-11T12:26:59.840', 'Id': '2713'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I just came across an exercise which is to find a regular expression for the following automata, such that the regular expression and the automata generate the same language.</p>\n\n<p><img src="http://i.stack.imgur.com/4Zk9t.png" alt="NFA"></p>\n\n<p>One solution presents the following expression:</p>\n\n<p>$\\qquad \\displaystyle r_A = a^+b^+(c\\mid ca^*b^+)^*$</p>\n\n<p>However, can this be true? I think not, because the all words created from the regular expression will have at least one $b$ in it, whereas the automata accepts words without $b$, such as $aaa$.</p>\n\n<p>What is your opinion?</p>\n', 'ViewCount': '214', 'Title': 'Does this regular expression equal this automata?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-23T07:39:49.723', 'LastEditDate': '2012-07-23T07:39:49.723', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1413', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'CreationDate': '2012-07-21T13:37:50.370', 'Id': '2851'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Assume $L$ is a regular language over an ordered alphabet.  Is the language built by taking every word in $L$ and sorting it always a regular language?</p>\n', 'ViewCount': '213', 'Title': 'Are regular languages closed under sort?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-23T11:22:45.557', 'LastEditDate': '2012-07-23T03:13:48.003', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2862', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2242', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-07-22T23:51:05.643', 'Id': '2861'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The problem, coming from an interview question, is:</p>\n\n<blockquote>\n  <p>You have a stream of incoming numbers in range 0 to 60000 and you have\n  a function which will take a number from that range and return the\n  count of occurrence of that number till that moment. Give a suitable\n  Data structure/algorithm to implement this system.</p>\n</blockquote>\n\n<p>The stream is infinite, so if fixed size data structures re used, i.e. primitive types in Java or C, they will overflow. So there is the need to use data structures that have a size that grows over time. As pointed by the interviewer, the memory occupied by those data structures will diverge.</p>\n\n<p>The model of computation is a Turing machine with three tapes:</p>\n\n<ul>\n<li>infinite read-only one-way input tape;</li>\n<li>constant space bounded read-write two way work tape;</li>\n<li>infinite write-only one-way output tape.</li>\n</ul>\n\n<p>The main reason to choose the model above is that in the real world there is virtually no limit to the quantity of input that can be acquired using a keyboard or a network connection. Also, there is virtually no limit to the quantity of information that can be displayed on amonitor over time. But memory is limited and expensive.</p>\n\n<p>I modeled the problem as the problem to recognize the language L of all couples (number,number of occurrences so far).</p>\n\n<p>As a corollary of the Theorem 3.13 in Hopcroft-Ullman I know that every language recognized by a constant space bounded machine is regular.</p>\n\n<p>But, in any given moment, the language L is a finite language, because the number of couples to be recognized is finite: 60001. So I can\'t use the pumping lemma for regular languages to prove that such language is not regular.</p>\n\n<p>Is there a way I can complete my proof?</p>\n\n<p>The original question is <a href="http://stackoverflow.com/questions/11708957/find-the-count-of-a-particular-number-in-an-infinite-stream-of-numbers-at-a-part">here</a>.</p>\n', 'ViewCount': '198', 'Title': 'Counting with constant space bounded TMs', 'LastEditorUserId': '851', 'LastActivityDate': '2012-07-30T11:41:01.430', 'LastEditDate': '2012-07-30T11:41:01.430', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '2951', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '851', 'Tags': '<regular-languages><turing-machines><finite-automata><space-complexity><streaming-algorithm>', 'CreationDate': '2012-07-29T16:44:46.170', 'Id': '2948'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Repost from Stack Overflow:</p>\n\n<p>I'm going through past exams and keep coming across questions that I can't find an answer for in textbooks or on google, so any help would be much appreciated.</p>\n\n<p>The question I'm having problems with at the moment is as follows:  </p>\n\n<blockquote>\n  <p>Given a regular expression (a|bb)*, derive an estimate of the cost in time for \n  converting it to a corresponding NFA and a DFA. Your answer should refer to\n  the size of the regular expression.</p>\n</blockquote>\n\n<p>A similar question from another year is:</p>\n\n<blockquote>\n  <p>Given that, for the above example, you know the size of the original regular\n  expression, |r| and the size of the input string |x|, explain how you would calculate the cost in time for constructing and running the NFA versus constructing\n  and running an equivalent DFA.</p>\n</blockquote>\n\n<p>The resulting NFA for (a|bb)* has 9 states, while the DFA has 4. Even knowing this, I have no idea how to approach the question.</p>\n", 'ViewCount': '819', 'Title': 'Cost in time of constructing and running an NFA vs DFA for a given regex', 'LastActivityDate': '2012-08-09T21:15:55.073', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3094', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2386', 'Tags': '<regular-languages><automata><finite-automata><compilers>', 'CreationDate': '2012-08-07T09:36:46.857', 'Id': '3071'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Show that $L=\\{a^{n^2} | n \\geq 0\\}$ is not regular</p>\n</blockquote>\n\n<p>Hey guys. I'm taking a CS class and this stuff is really new to me so bear with me. \nI tried to look if I get some contradiction by using the pumping lemma for regular languages and I worked it out like this:</p>\n\n<blockquote>\n  <p>Suppose $L$ is regular. Then there must be a natural number $m$ for all words $z$ in $L$ with length $|z| \\geq m$ and there exists a decomposition $z = uvw, |uv| \\leq m, |v| &gt; 0$, so that $u(v^i)w$ is in the language for any $i \\geq 0$.</p>\n  \n  <p>Consider the string $a^{m^2}$. </p>\n  \n  <p>Then $uv = a^{k^2} = a^{x+y}$, for some $k \\leq m$ and $x = (k-1)^2$.<br>\n  Then $v = a^y = a^{2k-1}$.</p>\n  \n  <p>Let $i = 2$. Then $u(v^2)w = a^{x+2y}$. But $\\sqrt{x+2y}$ is not necessarily a natural number -> Contradiction! Hence, $L$ can not be regular.</p>\n</blockquote>\n\n<p>Well, I know that this way is unnecessarily complicated and you can prove it differently (I already know the most simple solution). But my question here is: Is my proof valid as well or does it contain any flaw? Is it formally correct? </p>\n\n<p>I appreciate any feedback! Thanks!</p>\n", 'ViewCount': '1082', 'Title': 'Proof that $a^{n^2}$ is not regular', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-26T01:08:54.560', 'LastEditDate': '2012-08-07T18:43:38.207', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'OwnerDisplayName': 'Tobias Hoffmann', 'PostTypeId': '1', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2012-08-06T23:27:36.000', 'Id': '3075'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>What I mean by a "symbolic regular expression" (if there already is a different name for this I\'m not aware of it) is a regular expression that may include exponents that are symbolic arithmetic expressions.  </p>\n\n<p>Example 1: $a^k|b^*$ means "either $k$ copies of $a$ or zero or more copies of $b$".<br>\nExample 2: $a^{k+1}|a^k$ means "either $k$ or $k+1$ copies of $a$".</p>\n\n<p>What I\'d like to do is disambiguate such regular expressions.  I know that to disambiguate a normal regular expression, you can convert it to an NFA, then a DFA, then back to a regular expression.</p>\n\n<p>The problem is not completely straightforward.  For example, $a^k|a^j$ is ambiguous if $j=k$ and unambiguous otherwise.  Thus, the appropriate output would be, for example,\n$$a^k \\text{ if } k=j, \\qquad a^k|a^j \\text{ otherwise.}$$</p>\n\n<p>Does anyone know if there has been anything written about this problem?</p>\n', 'ViewCount': '135', 'Title': 'How to disambiguate symbolic regular expressions', 'LastActivityDate': '2012-08-09T22:51:51.757', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2242', 'Tags': '<formal-languages><reference-request><regular-languages><regular-expressions><ambiguity>', 'CreationDate': '2012-08-09T22:51:51.757', 'Id': '3112'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to show that </p>\n\n<p>$\\qquad \\displaystyle S = \\{(10^p)^m \\mid p \\geq 0, m \\geq 0\\}$</p>\n\n<p>is not a regular language using pumping lemma.</p>\n\n<p>Can I multiply the product of the powers and express it to: $S = \\{ 1^m 0^{pm} \\mid \\dots \\}$ and apply the pumping lemma where I pump 1's then say that the language doesn't accept the new string? </p>\n", 'ViewCount': '162', 'Title': 'Pumping Lemma: is it valid to "multiply the product of powers" in this case?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-15T18:46:39.087', 'LastEditDate': '2012-08-14T23:41:26.947', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'thokthak', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2012-03-20T03:46:48.117', 'Id': '3190'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '5374', 'Title': 'How to show that a "reversed" regular language is regular', 'LastEditDate': '2013-03-06T13:33:29.817', 'AnswerCount': '4', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2576', 'FavoriteCount': '2', 'Body': '<p>I\'m stuck on the following question:</p>\n\n<p>"Regular languages are precisely those accepted by finite automata. Given this fact, show that if the language $L$ is accepted by some finite automaton, then $L^{R}$ is also accepted by some finite; $L^{R}$ consists of all words of $L$ reversed."</p>\n', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'LastEditorUserId': '2100', 'LastActivityDate': '2013-10-03T14:07:16.580', 'CommentCount': '13', 'AcceptedAnswerId': '3253', 'CreationDate': '2012-08-18T15:54:03.993', 'Id': '3251'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$$L=\\{a^n \\mid \\text{\\(n\\) is even}\\}$$</p>\n\n<p>This is regular but fails in the pumping Lemma.</p>\n\n<p>Assuming $m=4$, $w=aaaaaa$, $|w|=6$ (even).\nLet $w=xyz$,\n$x=a$,\n$y=aaa$.\nWe have $|y|&gt;0$ and $|xy| \\le m$.</p>\n\n<p>Let $w_i=xy^iz$.\nFor $i=2$,\n$w_2=xy^2z=aaaaaaaaa$.\n$|w_2|=9$ therefore it is not regular.</p>\n\n<p>Where am I going wrong?</p>\n', 'ViewCount': '668', 'Title': 'Pumping Lemma for regular language for $a^n$ where $n$ is even fails', 'LastEditorUserId': '41', 'LastActivityDate': '2013-01-18T12:56:53.010', 'LastEditDate': '2012-08-30T04:59:09.197', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '2', 'OwnerDisplayName': 'Raj', 'PostTypeId': '1', 'Tags': '<regular-languages><automata><finite-automata><pumping-lemma>', 'CreationDate': '2012-08-24T05:02:20.050', 'Id': '3330'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Construct an NFA over $\\{0, 1\\}$ whose language contains only words that do not end with $10$.</p>\n</blockquote>\n\n<p>This is one of the first problems in the book, so it's supposedly easy. I just can't figure it out. It's easy using a DFA, but I'm not so sure using an NFA. Maybe I'm not understanding a particular concept in the NFA.</p>\n", 'ViewCount': '398', 'Title': 'NFA for binary words that do not end in 10', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-30T16:21:24.157', 'LastEditDate': '2012-08-30T15:48:21.640', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user10537', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><automata><finite-automata>', 'CreationDate': '2012-08-30T01:16:20.547', 'FavoriteCount': '0', 'Id': '3368'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When converting a DFA to a regular expression using the <a href="http://cs.stackexchange.com/a/2395">transitive closure method</a>, what is the significance of state $k$ and what values $k$ takes? If $k$ represents the intermediate states then what are the values for $k$? That is while applying the method, for which value of $k$ should we stop finding the regular expressions?</p>\n', 'ViewCount': '162', 'Title': 'What is the purpose of k in the transitive closure method?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T07:51:30.237', 'LastEditDate': '2012-09-03T07:51:30.237', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2699', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2012-09-01T07:18:00.917', 'Id': '3384'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '129', 'Title': "Compute 'insertable' letters in a regular language", 'LastEditDate': '2012-09-03T19:54:55.990', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2714', 'FavoriteCount': '1', 'Body': '<p>Let $L$ a regular language and define the <em><a href="https://en.wikipedia.org/wiki/Subsequence" rel="nofollow">subsequence</a> closure</em> of $L$ as</p>\n\n<p>$\\qquad \\displaystyle S(L) = \\{ w \\mid \\exists w\' \\in L.\\ w \\text{ subsequence of } w\'\\}$.</p>\n\n<p>The problem I want to solve is to find for such subsequences $w \\in S(L)$ which letters can be inserted into them so that the result is also in $S(L)$. Formally:</p>\n\n<blockquote>\n  <p>Given $w_1\\dots w_n \\in S(L)$, output all pairs $(i,a) \\in \\{0,\\dots,n\\} \\times \\Sigma$ for which $w_1 \\dots w_{i} a w_{i+1} \\dots w_n \\in S(L)$.</p>\n</blockquote>\n\n<p>Consider, for instance, the language$\\{ab, abc, abcc\\}$. The string $b$ is in $S(L)$ and inserting $a$ at the beginning -- corresponding to $(0,a)$ -- yields $ab \\in S(L)$. On the other hand, the string $cb$ is not in $S(L)$; there is no way to convert it to a language string by insertion.</p>\n\n<p>Using this language, if the input string is $b$ the possible insertions I am looking for are $(0,a)$ and $(1,c)$ at the end. If the input string is $bc$ the possible insertions are $(0,a), (1,c)$ and $(2,c)$.</p>\n\n<p>The use of this algorithm is in a user interface: the user builds strings belonging to the language starting from an empty string and adding one character at a time in different positions. At each step the UI prompts the user with all the possible valid letters in all the possible insertion positions.</p>\n\n<p>I have a working naive algorithm that involves a lot of back-tracking, and it is way too slow even in relatively simple cases. I was wondering if there is something better, or -- failing that -- if there are any available studies of this problem.</p>\n', 'Tags': '<algorithms><regular-languages><finite-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-04T20:40:39.843', 'CommentCount': '5', 'AcceptedAnswerId': '3424', 'CreationDate': '2012-09-02T19:55:58.830', 'Id': '3404'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is homework and I'm looking for a push in the right direction. Proofs were never something I was properly taught, so now they're kind of a weak point.</p>\n\n<p>Here's the problem:</p>\n\n<blockquote>\n  <p>The following grammar generates numbers in binary notation ($C$ is the\n  start symbol):</p>\n  \n  <p>$\\qquad \\begin{align}C &amp;\\to C 0 \\mid A 1 \\mid 0 \\\\\n                       A &amp;\\to B 0 \\mid C 1 \\mid 1 \\\\\n                       B &amp;\\to A 0 \\mid B 1\n          \\end{align}$</p>\n  \n  <ol>\n  <li><p>Prove that the alternating sums of the digits of the generated\n  numbers are multiples of $3$. The alternating sum of $w=w_0\\dots w_n$ is defined as $\\sum_{i=0}^n (-1)^i \\cdot w_i$. As an example, $C$\n  generates $1001$ via $C \\Rightarrow A1 \\Rightarrow B01 \\Rightarrow A001 \\Rightarrow 1001$ with alternating sum of $0$;\n  clearly, $0$ is a multiple of $3$.</p></li>\n  <li><p>Prove that all such numbers (i.e.,\n  numbers whose alternating sum is a multiple of 3) are generated by the\n  grammar.</p></li>\n  </ol>\n</blockquote>\n\n<p>I'm thinking I need to show that the grammar can only generate strings which are made up of repeated subsequences of digits which always add up to 0, 3, or -3. But I'm not sure how to show that it can only generate those three subsequences.</p>\n\n<p>I also have worked out these thoughts:</p>\n\n<ul>\n<li><p>Consider that any even number of consecutive 1s is irrelevant, as they cancel each other out.</p></li>\n<li><p>Consider that all zeros are in of themselves irrelevant, as they add nothing.</p></li>\n<li><p>Consider then that the only relevant pattern is that of alternating 1s and zeros, and where this pattern starts and ends.</p></li>\n</ul>\n", 'ViewCount': '795', 'Title': 'Proving a grammar only generates words whose alternating digit sums is are multiples of three', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T11:59:01.517', 'LastEditDate': '2012-09-03T07:35:35.117', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2716', 'Tags': '<formal-languages><regular-languages><formal-grammars><proof-techniques>', 'CreationDate': '2012-09-02T20:45:42.667', 'Id': '3406'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I want to prove that the complement of $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties.</p>\n\n<p>I understand pumping lemma can be used to prove that $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not a regular language. I also understand regular languages are closed under complement operation. However, does that also imply that a non-regular language's complement is also non-regular?</p>\n", 'ViewCount': '779', 'Title': 'Prove that the complement of  $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-12T19:48:30.280', 'LastEditDate': '2012-09-28T11:33:15.257', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '2978', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-09-26T20:53:42.597', 'FavoriteCount': '1', 'Id': '4752'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can anyone tell me what is the difference between the following regular expressions: $(0^*1^*)^*$ and $(0+1)^*$ ? To me they look like generating the same string.</p>\n', 'ViewCount': '274', 'Title': 'Difference between regular expressions: $(0^*1^*)^*$ and $(0+1)^*$', 'LastEditorUserId': '157', 'LastActivityDate': '2012-09-28T09:32:52.047', 'LastEditDate': '2012-09-28T09:32:52.047', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4766', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2987', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2012-09-27T14:16:45.693', 'Id': '4761'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '472', 'Title': 'Is $(a^nb^m)^r$ regular?', 'LastEditDate': '2012-10-02T17:43:02.980', 'AnswerCount': '1', 'Score': '7', 'OwnerDisplayName': 'Exci', 'PostTypeId': '1', 'OwnerUserId': '3034', 'Body': "<p>I took my theory of computation exams a few weeks ago, and this was one of the questions:</p>\n\n<blockquote>\n  <p>Assume language $L=\\{(a^nb^m)^r \\mid n,m,r\\ge 0\\}$ </p>\n  \n  <p>Is L regular? If yes provide a regular expression or an automaton for it.</p>\n</blockquote>\n\n<p>After I briefly asked him the answer after the exam, it appears it really is regular (I believe he said the expression is the simple $(a^*b^*)^*$). However I cannot seem to understand why that is. The way I see it, its concatenating $a^nb^m$ <strong>r</strong> times, like this:</p>\n\n<blockquote>\n  <p>$a^nb^ma^nb^ma^nb^m...a^nb^ma^nb^m$, </p>\n</blockquote>\n\n<p>which isn't regular since there is no way for an automaton to recall <strong>n</strong> and <strong>m</strong> every time. Where am I at fault here?</p>\n\n<p>EDIT: I talked to the professor again, he admitted it was a mistake. The language is indeed not regular.</p>\n", 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T17:43:02.980', 'CommentCount': '4', 'AcceptedAnswerId': '4838', 'CreationDate': '2012-10-01T13:02:27.980', 'Id': '4837'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can you show that the Language accepted by an NFA and the reverse NFA is the same?</p>\n\n<p>For a language $L$, there is an $L^R=\\{ w^R \\mid w \\in L\\}$</p>\n\n<p>Let's say that $w^R$ is the string obtained by reversing the string $w$.</p>\n\n<p>I know that it involves using induction on the length of the input, but I would really appreciate some help.</p>\n", 'ViewCount': '339', 'Title': 'How do you prove that two languages are equivalent?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-02T22:29:06.833', 'LastEditDate': '2012-10-02T20:02:27.660', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3040', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-10-02T18:37:35.743', 'Id': '4845'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p><sup>(edit: the question was ambiguous. The following is it's non-trivial interpretation) </sup></p>\n\n<p>I need to <code>Find a regular grammar that generates the set of all real numbers in C (programming Language)</code></p>\n\n<ol>\n<li>How do I know how the C programming language defines a real number?</li>\n<li>How can I find a <em>regular</em> grammar for such numbers?</li>\n</ol>\n", 'ViewCount': '587', 'ClosedDate': '2012-10-10T20:09:06.560', 'Title': 'Find a regular grammar that generates the set of all real numbers in C', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-19T17:26:29.650', 'LastEditDate': '2012-10-09T07:14:53.170', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3095', 'Tags': '<regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2012-10-08T03:12:37.733', 'Id': '4939'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im trying to prove that the following language is not regular.\n$$\\text{Notprime} = \\{a^n \\text{where \\(n\\) isn\'t prime}\\}\n  = \\{\\epsilon, a, aaaa, aaaaaa, aaaaaaaa, \\ldots\\}$$</p>\n\n<p>Heres what I have:</p>\n\n<p>"If Notprime were regular, then its complement would be regular also. However, the complement of Notprime is the language Prime, hence Notprime is non-regular." </p>\n\n<p>Is this the right way of proving it? Any help is appreciated!</p>\n', 'ViewCount': '499', 'Title': 'Prove that the language of non-prime numbers written in unary is not regular', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-09T22:46:52.467', 'LastEditDate': '2012-10-09T22:35:33.397', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '4986', 'Score': '4', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2012-10-09T22:26:18.387', 'Id': '4984'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to find CFG's that generate a regular language over the alphabet {a b}</p>\n\n<p>I believe I got this one right: All strings that end in b and have an <strong>even</strong> number of b's in total:</p>\n\n<p>$\\qquad S \\to SS \\\\\n\\qquad S \\to YbYb \\mid \\varepsilon \\\\\n\\qquad Y \\to aY \\mid \\varepsilon$</p>\n\n<p>However, Im not sure how to accomplish this with an odd number of <em>b</em>'s.</p>\n\n<p>So for example, how could I find a CFG that generates all strings that end in b and have an <strong>odd</strong> number of b's in total: So far I have this,</p>\n\n<p>$\\qquad S \\to SS \\\\\n \\qquad S \\to YYb \\mid \\varepsilon \\\\\n \\qquad Y \\to abY \\mid baY \\mid \\varepsilon$</p>\n\n<p>But this can generate abababb so it's incorrect and Im stumped at this point. </p>\n", 'ViewCount': '286', 'Title': 'Context Free Grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T13:47:53.540', 'LastEditDate': '2012-10-22T13:45:18.583', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '6164', 'Score': '1', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<regular-languages><formal-grammars><context-free>', 'CreationDate': '2012-10-19T06:49:34.393', 'Id': '6163'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '209', 'Title': 'If $L$ is a regular language, how to prove $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$ is also regular?', 'LastEditDate': '2013-04-07T12:25:29.787', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3146', 'FavoriteCount': '2', 'Body': "<blockquote>\n  <p>If $L$ is a regular language, prove that the language\n  $L_1 = \\{ uv \\mid u \\in L, |v| =2 \\}$\n  is also regular.</p>\n</blockquote>\n\n<p>My idea: $L$ can be represented as a DFA and then you could add 2 consecutive transitions from every final state for the letters of $v$, creating a new NFA diagram. Is that correct? I'm not sure how to make this a formal proof.</p>\n", 'Tags': '<regular-languages><automata><finite-automata><closure-properties><check-my-answer>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T12:25:29.787', 'CommentCount': '3', 'AcceptedAnswerId': '6281', 'CreationDate': '2012-10-24T05:09:01.860', 'Id': '6279'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can one formally prove</p>\n\n<p>$L \\cdot L^{*} = L^{+}$</p>\n\n<p>It looks obvious to me since with the concatenation you get rid of $\\varepsilon$, but I cannot think of a formal proof through induction or something.</p>\n', 'ViewCount': '102', 'Title': 'How to prove $L \\cdot L^{*} = L^{+}$', 'LastActivityDate': '2012-10-31T01:59:17.723', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '6398', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4403', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-10-30T18:00:23.283', 'Id': '6391'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a>  </p>\n</blockquote>\n\n\n\n<p>Show that $L_2=\\{a^nb^k|n\\not= k-1\\}$ is not regular by Pumping Lemma.</p>\n', 'ViewCount': '38', 'ClosedDate': '2012-10-31T06:35:19.720', 'Title': 'Show that a language is not regular by Pumping Lemma', 'LastActivityDate': '2012-10-31T05:13:17.603', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3146', 'Tags': '<formal-languages><automata><regular-languages><pumping-lemma>', 'CreationDate': '2012-10-31T05:13:17.603', 'Id': '6400'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been studying for an exam I have tomorrow, and I was looking through some previous sample exam questions, when I came across this problem:</p>\n\n<blockquote>\n  <p>Give a non-regular language $L$ such that $L \\cup L^R$ is regular.</p>\n</blockquote>\n\n<p>I've been sitting here and thinking and thinking, and I can't seem to come up with a situation where this is valid. I've determined a few things based on my understanding of non-regular languages, as well as the problem itself:</p>\n\n<ul>\n<li>$L$ must be infinite.</li>\n<li>$L$ must involve some kind of counting.</li>\n<li>$L$ must contain multiple letters (i.e. it cannot be composed of entirely $a$s).</li>\n</ul>\n\n<p>Given this, I went through a few basic possibilities:</p>\n\n<ul>\n<li>$a^ib^i$ : This would result in $L \\cup L^R$ being irregular also.</li>\n<li>$(ab)^i(ba)^i$ (or something else palindromic) : Again, this would result in $L \\cup L^R$ being irregular also. (Any palindrome would, as $L = L^R$.)</li>\n<li>$a^pb^q$ (where $p$ and $q$ are prime) : This, too, would result in $L \\cup L^R$ being irregular also, though it would be a very much broader language, which I think is a step in the right direction.</li>\n</ul>\n\n<p>After I got this far, I think the key is in creating some language that, when unioned with itself, forms something akin to $a^*b^*$ or $(ab)^*$. The broader the words within the language, the easier it seems to define. But I can't seem to quite wrap my head around doing this.</p>\n\n<p>Does anyone have a hint/spoiler or possible solution to this?</p>\n\n<p><em>(NB: My professor does not post solutions.)</em></p>\n", 'ViewCount': '169', 'Title': 'Find non-regular $L$ such that $L \\cup L^R$ is regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-01T14:28:03.440', 'LastEditDate': '2012-11-01T14:28:03.440', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '6421', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2827', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-11-01T05:15:17.320', 'Id': '6418'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I\'ve been scratching my head over this problem for a couple of days now.  Given some language $A$ and $B$ that is regular, show that the language $L$ which consists of all strings in $A$ whose length is equal to some string in $B$ is a regular language.</p>\n\n<p>In equation form:</p>\n\n<p>$$L = \\{x \\in A \\mid \\exists y \\in B \\text{ s.t. } |x| = |y| \\}$$</p>\n\n<p>My initial thought was to try and come up with some DFA for both languages $A$ and $B$ and map the two states to each other and hopefully get a 1:1 ratio that way I can generate a new DFA which proves that $L$ is regular.  But then I realized that $A$ and $B$ don\'t have to be over the same set of symbols.  </p>\n\n<p>I think the correct way to solve this is to use the closure properties of regular language, but I\'m not sure of how to begin/use the properties for "lengths" of strings instead of strings themselves.  </p>\n\n<p>Could someone point me in the right direction?</p>\n', 'ViewCount': '255', 'Title': 'Proving the language which consists of all strings in some language is the same length as some string in another language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-08T04:07:41.613', 'LastEditDate': '2012-11-05T08:20:14.120', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4463', 'Tags': '<formal-languages><regular-languages><finite-automata><proof-techniques><closure-properties>', 'CreationDate': '2012-11-05T05:52:51.367', 'Id': '6484'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have some questions regarding acceptance of a language by DFA</p>\n\n<ol>\n<li>Whether more that one dfa accept a language  </li>\n<li>Whether a dfa can accept more than one language</li>\n</ol>\n', 'ViewCount': '305', 'Title': 'Language acceptance by DFA', 'LastActivityDate': '2012-11-10T02:32:03.653', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '6594', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<automata><regular-languages><finite-automata>', 'CreationDate': '2012-11-10T01:29:26.060', 'Id': '6590'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m unclear about the use of the phrases "infinite" language or "finite" language in computer theory.</p>\n\n<p>I think the root of the trouble is that a language like $L=\\{ab\\}^*$ is <strong>infinite</strong> in the sense that it can generate an infinite (but countable) number of strings. Yet, it can still be recognized by a <strong>finite</strong> state automaton. </p>\n\n<p>It also doesn\'t help that the Sipser book doesn\'t really make this distinction (at least as far as I can tell). A question about infinite/finite languages and their relationship to regular languages came up in a sample exam.</p>\n', 'ViewCount': '3132', 'Title': 'Infinite Language vs. finite language', 'LastEditorUserId': '157', 'LastActivityDate': '2012-11-12T16:08:33.073', 'LastEditDate': '2012-11-11T00:49:47.817', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4547', 'Tags': '<formal-languages><terminology><regular-languages>', 'CreationDate': '2012-11-10T23:43:32.613', 'FavoriteCount': '2', 'Id': '6609'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p><strong>Possible Duplicate:</strong><br>\n  <a href="http://cs.stackexchange.com/questions/4752/prove-that-the-complement-of-0n1n-mid-n-geq-0-is-not-regular-using">Prove that the complement of  $\\{0^n1^n \\mid n \\geq{} 0\\}$ is not regular using closure properties</a>  </p>\n</blockquote>\n\n\n\n<p>Is $L=\\{ a^nb^m \\mid n,m \\ge 0, n\\ne m\\}$ a regular language?  </p>\n\n<p>I think it is but can\'t prove it.</p>\n', 'ViewCount': '324', 'ClosedDate': '2012-11-19T22:15:48.150', 'Title': 'Is $\\{a^nb^m \\mid n,m\\ge 0, n\\ne m\\}$ regular or not?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-11-14T21:30:01.330', 'LastEditDate': '2012-11-14T14:32:35.997', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4586', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-11-14T06:00:37.603', 'Id': '6656'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m constructing a <a href="http://en.wikipedia.org/wiki/Deterministic_finite_automaton" rel="nofollow">deterministic finite automata</a> (DFA) for a language of all strings defined over $\\{0,1\\}$ whose length is even and number of $1$s is odd. I constructed each DFA separately and then combined:</p>\n\n<p><img src="http://i.stack.imgur.com/rKHhw.png" alt="dfas and their union"></p>\n\n<ul>\n<li>Is the given procedure for combining DFAs correct?<br>\n<strong>EDIT:</strong> Originally wrote union; actually taking the intersection.</li>\n<li>Would someone suggest material on constructing DFAs<br>\ngiven restrictions on length and number of $0$s or $1$s?</li>\n</ul>\n\n<p>According to link given by Merbs, I have developed this FA. <img src="http://i.stack.imgur.com/ZMnEl.png" alt="enter image description here"> <br/> This FA does not accept a language of even length.</p>\n', 'ViewCount': '1097', 'Title': 'Is this intersection of DFAs correct?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:12:19.483', 'LastEditDate': '2013-05-24T03:12:19.483', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '7108', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2766', 'Tags': '<automata><regular-languages><finite-automata>', 'CreationDate': '2012-11-25T19:04:26.350', 'Id': '6893'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to study for an exam and having difficulty with the following practice questions. Any help would be appreciated.</p>\n\n<ol>\n<li>Give a language $L$ such that $L$ is not recursive but $\\text{prefix}(L)$ is regular.</li>\n<li>Give two languages $L_1$ and $L_2$, such that $L_1$ and $L_2$ are not recursive, but $L_1\\cap L_2$ is recursive.</li>\n<li>Give a language $L$ such that $L$ is regular but $\\text{unary}(L)$ is not context-free.</li>\n</ol>\n", 'ViewCount': '119', 'Title': 'Recursive and regular languages', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-27T21:28:14.270', 'LastEditDate': '2012-11-27T20:39:13.353', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4767', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2012-11-27T20:16:52.957', 'Id': '6965'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>Let $P$ be a regular language and $Q$ be a context-free language such\n  that $Q \\subseteq P$(For example, let $P =  a^*b^*$ and $Q = \\{ a^nb^n | n \\ge 0\\}$). Then which of the following is always regular?</p>\n  \n  <ol>\n  <li>$P \\cap Q$</li>\n  <li>$P - Q$</li>\n  <li>$\\Sigma^* - Q$</li>\n  <li>$\\Sigma^* - P$</li>\n  </ol>\n</blockquote>\n\n<p><strong>Option 1</strong> <br>\n$P \\cap Q = Q$ as $P \\subseteq Q$. Thus $P \\cap Q$ is context-free.</p>\n\n<p><strong>Option 2</strong> <br>\nI was not able to generally reason here. I used the example mentioned in the question.<br>\nLet  $P =  a^*b^* $ and $Q = \\{ a^nb^n | n \\ge 0\\}$. <br>\n$P - Q = \\{a^nb^m | n \\neq m\\}$ which is not regular but only context-free.</p>\n\n<p><strong>Option - 3</strong><br>\nLet $\\Sigma = \\{ a, b\\}$ and $Q = \\{ a^nb^n | n \\ge 0\\}$. <br>\nAgain $\\Sigma^* - Q =  \\{a^nb^m | n \\neq m\\} $ which is not regular but only  context-free.</p>\n\n<p>Thus, the 4th option must be right, $\\Sigma^* - P$ is regular. I am however unable to understand this result intuitively. Could somebody explain?</p>\n', 'ViewCount': '104', 'Title': 'Closure properties of languages', 'LastEditorUserId': '2980', 'LastActivityDate': '2012-12-27T06:01:51.860', 'LastEditDate': '2012-12-27T06:01:51.860', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7119', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2980', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2012-12-03T09:28:15.073', 'Id': '7118'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given languages $L_1,L_2$, defines $X(L_1,L_2)$ by</p>\n\n<p>$\\qquad X(L_1,L_2) = \\{w \\mid w \\not\\in L_1 \\cup L_2 \\}$</p>\n\n<p>If $L_1$ and $L_2$ are regular, how can we show that $X(L_1,L2)$ is also regular?</p>\n', 'ViewCount': '140', 'LastEditorDisplayName': 'user3115', 'Title': 'Show that the language of strings not in the union of two regular languages is regular', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T19:17:11.917', 'LastEditDate': '2012-12-12T19:17:11.917', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2012-12-06T01:56:03.217', 'Id': '7202'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '597', 'Title': 'Proofs using the regular pumping lemma', 'LastEditDate': '2012-12-07T18:53:34.130', 'AnswerCount': '3', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4918', 'FavoriteCount': '0', 'Body': '<p>I have two questions:</p>\n\n<ol>\n<li><p>I consider the following language \n$$L_1= \\{ w\\in \\{0,1\\}^* \\mid \\not \\exists u\\in \\{0,1\\}^* \\colon w= uu^R\\}.$$\nIn other words $w$ is not palindrome with even length. I proved that this language is NOT regular by proving that its complement is not regular. My question is how to prove it using the pumping lemma without using going over the complement.</p></li>\n<li><p>Let\n$$L_2=\\{w\\in\\{0,1\\}^* \\mid \\text{$w$ has same number of 101 substrings and 010 substrings}\\}. $$  I proved that this language is not regular by using equivalence classes. How I can prove it using the pumping lemma?</p></li>\n</ol>\n\n<p>Thanks alot for edit:)</p>\n', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'LastEditorUserId': '4918', 'LastActivityDate': '2012-12-08T11:56:42.303', 'CommentCount': '2', 'AcceptedAnswerId': '7252', 'CreationDate': '2012-12-07T18:16:08.453', 'Id': '7235'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the following language:\n$$ L_1=\\{uu^rv \\mid u,v\\in\\{0,1\\}^+\\}.$$\nthat means that neither $u$ nor $v$ can be $\\varepsilon$. As usual $u^r$ refers to $u$ reflected.</p>\n\n<p>I think that this language is not regular, but i am not sure. Any ideas? </p>\n', 'ViewCount': '222', 'Title': 'Is this language regular?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-09T18:26:17.210', 'LastEditDate': '2012-12-09T16:36:03.470', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '7272', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4918', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2012-12-09T16:32:14.680', 'Id': '7271'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Show that for $l(n) = \\log \\log n$, it holds that $\\text{DSPACE}(o(l)) = \\text{DSPACE}(O(1))$.</p>\n\n<p>It's well known fact in Space Complexity, but how to show it explicitly?</p>\n", 'ViewCount': '285', 'Title': 'Space complexity below $\\log\\log$', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-13T15:09:01.203', 'LastEditDate': '2012-12-13T15:09:01.203', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7378', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4799', 'Tags': '<complexity-theory><regular-languages><space-complexity><lower-bounds>', 'CreationDate': '2012-12-13T10:57:13.230', 'Id': '7372'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I find <a href="http://theory.stanford.edu/~trevisan/cs172/ps04.pdf" rel="nofollow">this</a>,\nbut I can\'t complete it, is there any other solution for it?</p>\n', 'ViewCount': '363', 'Title': 'How can I prove that the language of a read-only Turing machines is regular?', 'LastEditorUserId': '3016', 'LastActivityDate': '2012-12-23T07:25:44.860', 'LastEditDate': '2012-12-16T20:00:37.947', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4486', 'Tags': '<regular-languages><turing-machines>', 'CreationDate': '2012-12-15T16:34:01.977', 'Id': '7412'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two regular languages $L_1$ and $L_2$, we define a new language </p>\n\n<p>$$L=\\{w_1w_2\\mid \\text{ there exist two words } x,y \\text{ such that } xw_1\\in L_1, w_2y\\in L2\\}$$</p>\n\n<p>How do I show that $L$ is regular with equivalence classes?</p>\n\n<p>My assignment allows the use of closure properties that all regular languages hold, but I cannot use $\\text{rank} (L)$, as in show a limit to the number of equivalence class.</p>\n\n<p>Can someone lead me in the right direction? </p>\n', 'ViewCount': '214', 'Title': 'Proving regularity via equivalence classes', 'LastEditorUserId': '39', 'LastActivityDate': '2012-12-19T05:17:59.307', 'LastEditDate': '2012-12-15T21:16:08.037', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5074', 'Tags': '<automata><regular-languages><finite-automata><proof-techniques>', 'CreationDate': '2012-12-15T20:27:22.903', 'FavoriteCount': '1', 'Id': '7419'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to create a DFA that can recognize strings with alphabet $\\{a,b,c\\}$ where $a$ and $c$ appear even number of times and where $b$ appears odd number of times.</p>\n\n<p>I am wondering that this may only be expressed with other methods such as Turing machine or context-free languages.</p>\n\n<p>You might find it fun to think of the solution.</p>\n', 'ViewCount': '199', 'Title': 'Does this DFA have a solution?', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-12-16T16:29:32.997', 'LastEditDate': '2012-12-16T16:29:32.997', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7430', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5079', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2012-12-16T04:36:17.710', 'Id': '7429'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is well known that regular languages are characterized by the Myhill-Nerode equivalence. For language $L$ over $\\Sigma^*$ define the equivalence $x\\sim_L y$ over $\\Sigma^*$ iff for all $z\\in\\Sigma^*$ we have $xz\\in L \\iff yz\\in L$. Then $L$ is regular iff $\\sim_L$ is of finite index, i.e., has a finite number of equivalence classes.</p>\n\n<p>I know that the relation can be used to show that some languages are <em>not</em> regular, by indicating infinitely many strings that are not equivalent. </p>\n\n<p>My question: can we easily use Myhill-Nerode to show closure properties of regular languages? Or should we use the "syntactic congruence" of languages? </p>\n\n<p>As an example for prefix it is easy, as $x\\sim_L y$ implies $x\\sim_{\\mbox{pref}(L)} y$.  But how do we handle suffix, concatenation, star, mirror?</p>\n', 'ViewCount': '161', 'Title': 'Myhill-Nerode and closure properties', 'LastActivityDate': '2012-12-16T20:08:40.920', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<regular-languages><closure-properties>', 'CreationDate': '2012-12-16T17:09:42.133', 'Id': '7441'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I went through a question asking me to categorize the following grammar.</p>\n\n<p>$$S \u2192 AA, S \u2192 AB, A \u2192 a, A\u2192BB, B \u2192 b, B \u2192 e$$</p>\n\n<p>From the production rules, clearly it is Context-Free. But it accepts a finite set of strings.\n$\\{e, a, aa, ab, abb, ba, bba, b, bb, bbb, bbbb\\}$\nwhich is regular language.</p>\n\n<p>So, is the above grammar regular? Though it does not follow from the rules.</p>\n\n<p>Basically my question is: <strong>Is the grammar $\\{S \u2192 AA, A \u2192 a\\}$ regular?.</strong></p>\n', 'ViewCount': '134', 'Title': 'Is this a regular grammar?', 'LastActivityDate': '2012-12-18T16:26:54.387', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7487', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4422', 'Tags': '<regular-languages><formal-grammars><context-free>', 'CreationDate': '2012-12-18T11:07:06.653', 'Id': '7486'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Trivially decidable problem is one in which the problem is a known property of the language/grammar. So  <strong>intersection of two regular languages is regular should be trivially decidable</strong>? But it is given as not trivially decidable.</p>\n', 'ViewCount': '249', 'Title': 'Is the intersection of two regular languages regular?', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-25T21:16:11.313', 'LastEditDate': '2012-12-25T21:16:11.313', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '7534', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4763', 'Tags': '<regular-languages><undecidability><decision-problem>', 'CreationDate': '2012-12-18T14:08:00.077', 'Id': '7488'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need some help with the following problem: $L$ - regular language and i have to prove that the language $P$ = {$\\alpha$| $\\beta\\alpha\\gamma \\in L$, $\\beta,\\gamma \\in (A)^*$} is regular. In other words $P$ is the language of all parts of words from $L$.   </p>\n\n<p>Thanks a lot!</p>\n', 'ViewCount': '66', 'Title': u'Regularity of \u201cmiddles\u201d of words from regular language', 'LastEditorUserId': '3011', 'LastActivityDate': '2012-12-24T22:25:40.707', 'LastEditDate': '2012-12-24T22:25:40.707', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7589', 'Score': '1', 'OwnerDisplayName': 'user54060', 'PostTypeId': '1', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2012-12-23T11:59:42.723', 'Id': '7588'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I need help with the following question:</p>\n\n<p>Order the following formalisms according to their expressive power:\nplacing A before B means that any language definable by A is definable\nby B. Also state which, if any, of them are equivalent.</p>\n\n<pre><code>\u2022 Turing Machines (TM)\n\u2022 Regular expressions (reg.exp.)\n\u2022 Turing Machines with multiple tapes (TM+)\n\u2022 Pushdown Automata (PDA)\n\u2022 Nondeterministic Finite Automata with \u01eb-transitions (NFA\u01eb)\n\u2022 Nondeterministic Finite Automata (NFA)\n\u2022 LR(1) grammars\n\u2022 Nondeterministic Turing Machines (NTM)\n\u2022 Deterministic Pushdown Automata (DPDA)\n\u2022 Deterministic Finite Automata (DFA)\n\u2022 Context-free Grammars (CFG)\n</code></pre>\n\n<p>Is this the correct answer ? I have a exam next week and need to know If my answer is correct.</p>\n\n<pre><code>NFAe=NFA=DFA=Reg.exp, LR(1)-Grammar=DPDA, CFG=PDA, TM=NTM=TM+\n</code></pre>\n\n<p>Thanks in advance </p>\n', 'ViewCount': '173', 'Title': 'Formal Languages - Expressive power of Formalisms', 'LastActivityDate': '2013-01-01T22:35:50.987', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '7683', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><regular-languages><context-free><regular-expressions><pushdown-automata>', 'CreationDate': '2013-01-01T22:22:24.913', 'Id': '7682'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need some help with deciding if a given language is regular, context-free or not context-free.</p>\n\n<p>Lets' say I have the following languages over the alphabet $\\mathcal{A} = \\{a,b,c,d\\}$:\n$$ \\begin{align}\n  L_1 &amp;= \\{ w \\in \\mathcal{A}^* \\mid \\text{\\(\\#a(w)\\) is even and \\(\\#b(w) = 1 \\mathrel{\\mathrm{mod}} 3\\)  and  \\(w \\not\\in \\mathcal{A}^* abc \\mathcal{A}^* \\)} \\} \\\\\n  L_2 &amp;= \\{ w \\in \\mathcal{A}^* \\mid \\text{\\(\\#a(w)\\) is even and \\(\\#b(w) \\lt \\#c(w)\\)} \\} \\\\\n  L_3 &amp;= \\{ w \\in \\mathscr{A}^* \\mid \\#a(w) \\lt \\#b(w) \\lt \\#c(w) \\} \\\\\n\\end{align} $$</p>\n\n<p>This is my solution:</p>\n\n<p>$L_1 = L_4 \\cap L_5 \\cap L_6$ where\n$$ \\begin{align}\n  L_4 &amp;= \\{ w \\mid \\text{\\(w\\) does not have a substring \\(abc\\)} \\} \\\\\n  L_5 &amp;= \\{ w \\mid \\#a(w) \\text{ is even} \\} \\\\\n  L_6 &amp;= \\{ w \\mid \\#b(w) = 1 \\mathrel{\\mathrm{mod}} 3 \\} \\\\\n\\end{align} $$</p>\n\n<p>A DFA can be constructed for $L_5$, because $L_5$ does not need infinite memory, so $L_5$ is regular. For $L_6$ the same reasoning as above. And for $L_4$ we can construct a DFA that simply does not accept $abc$, hence regular.</p>\n\n<p>$L_1$ is regular because regular languages are closed under intersection.</p>\n\n<p>For $L_2$ we can divide the language thus: $L_2 = L_5 \\cap L_7$ where</p>\n\n<p>$$ \\begin{align}\n  L_5 &amp;= \\{ w \\mid \\#a(w) \\text{ is even} \\} \\\\\n  L_7 &amp;= \\{ w \\mid \\#b(w) \\lt \\#c(w) \\} \\\\\n\\end{align} $$</p>\n\n<p>We now that a DFA can be constructed for $L_5$, hence $L_5$ is regular.\n$L_7$ is context-free because we can construct a PDA where the stack counts the number of $a$s and $b$s.</p>\n\n<p>$L_2$ is hence context-free because the intersection of a regular language and a context-free language result in a context-free language.</p>\n\n<p>For $L_3$ we can see that it's not context-free because where are limited to 1 stack.</p>\n\n<p>Is my reasoning right?</p>\n", 'ViewCount': '255', 'Title': 'Deciding whether a Language is Context-free/Regular/Non Context-Free', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-25T13:29:45.240', 'LastEditDate': '2013-03-26T12:54:48.303', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-01-03T14:34:12.090', 'Id': '7732'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1416', 'Title': 'Explaining why a grammar is not LL(1)', 'LastEditDate': '2014-01-04T15:36:22.460', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4658', 'FavoriteCount': '1', 'Body': u'<p>I need some help with explaining why a grammar is not LL(1).</p>\n\n<p>Let us take the following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp; aB \\mid bA \\mid \\varepsilon \\\\\nA \\rightarrow &amp; aS \\mid bAA \\\\\nB \\rightarrow &amp; b \\\\\n\\end{align}\n$$</p>\n\n<p>This is my attempt:</p>\n\n<p>For the grammar to be LL(1) it is a necessary condition that for any strings $c_1\u03b3$ and $c_2\u03b2$, derivable from $S \\rightarrow aB$ and $A \\rightarrow aS$ respectively, we have $c_1 \\ne c_2$. </p>\n\n<p>But, $S \\rightarrow aB$ and $A \\rightarrow aS$, hence $c_1 = c_2$ and the grammar is not LL(1).</p>\n\n<p>Is my reasoning right?</p>\n\n<p>Thanks in advance.</p>\n', 'Tags': '<formal-languages><regular-languages><context-free><pushdown-automata>', 'LastEditorUserId': '10637', 'LastActivityDate': '2014-01-04T15:36:22.460', 'CommentCount': '1', 'AcceptedAnswerId': '7789', 'CreationDate': '2013-01-04T16:14:19.883', 'Id': '7761'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a language is defined such that<br>\n$L = (0+1)^{\\ast}$   if $\\mathsf{P} = \\mathsf{NP}$ and $\\emptyset$   otherwise</p>\n\n<p>Then $L$ is a regular language if $\\mathsf{P} = \\mathsf{NP}$, otherwise it is the empty langauge. \nTherefore $\\mathsf{P} = \\mathsf{NP}$ , $L$ is recursive (being regular), but is $L$ still recursive if $\\mathsf{P} \\neq \\mathsf{NP}$?</p>\n', 'ViewCount': '150', 'Title': 'Recusively Enumerable or Recursive dependent on whether P=NP', 'LastEditorUserId': '157', 'LastActivityDate': '2013-01-10T11:51:40.033', 'LastEditDate': '2013-01-10T06:57:26.673', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'OwnerDisplayName': 'Arjun J Rao', 'PostTypeId': '1', 'OwnerUserId': '5418', 'Tags': '<computability><regular-languages><p-vs-np>', 'CreationDate': '2013-01-10T01:41:26.263', 'Id': '7859'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A true/false question: If a DFA $M$ contains a self-loop on some state $q$, then $M$ must accept an infinite language.</p>\n\n<p>The answer is "false". I\'ve read <a href="http://cs.stackexchange.com/questions/6609/infinite-language-vs-finite-language">this question</a>, but I\'m still wondering why $M$ does not necessarily accept an infinite language. Isn\'t the language $b^*$ infinite? Don\'t all self-loops look like $b^*$?</p>\n', 'ViewCount': '474', 'Title': 'Do self-loops in DFA cause infinite languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-17T13:36:18.223', 'LastEditDate': '2013-01-17T13:36:18.223', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '8983', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-01-17T07:53:01.867', 'Id': '8982'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$L_1=\\{a^ku \\mid u \\in \\{a,b\\}^* $ and $u$ contains at least $k$ a\'s, for $k\\geq 1\\}$.</p>\n\n<p>If it is regular, I haven\'t found its regular expression or any closure property to prove it.</p>\n\n<p>If not, it seems pumping theorem holds for it...</p>\n\n<p>Also, what about the language where the above "at least" is changed to "at most"?</p>\n', 'ViewCount': '249', 'Title': 'Is this language regular or not?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-21T16:29:46.853', 'LastEditDate': '2013-01-17T16:57:42.763', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6455', 'Tags': '<formal-languages><regular-languages><regular-expressions><pumping-lemma>', 'CreationDate': '2013-01-17T15:40:17.740', 'FavoriteCount': '1', 'Id': '8991'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>First, I have tried to build a DFA over the alphabet $\\sum = \\{0,\\dots, 9\\}$ that accepts all decimal representations of natural numbers divisible by 3, which is quite easy because of the digit sum. For this I choose the states $Q = \\mathbb{Z}/3\\mathbb{Z}\\cup\\{q_0\\}$ ($q_0$ to avoid the empty word), start state $q_0$, accept states $\\{[0]_3\\}$ and $\\delta(q, w) =\\begin{cases} [w]_3 &amp;\\mbox{if } q = q_0 \\\\\n[q + w]_3 &amp; \\mbox{else } \\end{cases}$</p>\n\n<p>Of course, it doesn't work that way for natural numbers divisible by 43. For 43 itself, I would end in $[7]_{43}$, which wouldn't be an accepting state. Is there any way I can add something there or do you have other suggestions on how to do this? Thanks.</p>\n", 'ViewCount': '486', 'Title': 'DFA that accepts decimal representations of a natural number divisible by 43', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-20T15:16:39.223', 'LastEditDate': '2013-01-20T15:13:05.993', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'Zlatansbraten', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-01-19T23:50:17.853', 'FavoriteCount': '1', 'Id': '9049'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The basic idea is to have one or more symbol that clearly indicate the end. For example:</p>\n\n<p>Non-ambiguous:</p>\n\n<blockquote>\n  <p>$ab^*c$<br>\n  $(a|b)c$<br>\n   $ab^+c$<br>\n   $ab?c$<br>\n   $a(b|c)$<br>\n   $c(ab)^*ccc$<br>\n   $acc^*d$<br>\n   $abc|bcd$  </p>\n</blockquote>\n\n<p>Ambiguous:</p>\n\n<blockquote>\n  <p>$abc^*$<br>\n  $abc^+$<br>\n  $abc?$<br>\n  $acc^*$ or $ac^*c$</p>\n</blockquote>\n\n<p>An alternative definition of a non-ambiguous ending would be that the corresponding DFA can have multiple final states, but none of them can have a outgoing transition.</p>\n', 'ViewCount': '194', 'Title': 'Is there a name/interest for regular languages that have a non-ambiguous ending?', 'LastEditorUserId': '1053', 'LastActivityDate': '2013-01-25T16:19:20.677', 'LastEditDate': '2013-01-25T15:20:19.237', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '9094', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1053', 'Tags': '<regular-languages><finite-automata><regular-expressions><ambiguity>', 'CreationDate': '2013-01-22T12:50:22.110', 'Id': '9091'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an alphabet $A = \\{b,B\\}$ and I'm asked to write down the <strong>pattern</strong> of the regular expression $(\\epsilon|bb|b)(B|bb)(b|\\epsilon|b)$. What does the question actually want me to do? I'm not sure. Does it want me to give the possible patterns that can be formed with $b$ and $B$? But then surely the question would not have been phrased the way it is. </p>\n\n<p>I'm just confused about what I need to do here and what is expected of the answer. If anyone could give an example it would be very helpful.</p>\n\n<p>Note: This is not the original question, I changed and simplified it.</p>\n", 'ViewCount': '97', 'Title': 'What is meant by "give pattern of a regular expression"', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T13:03:04.673', 'LastEditDate': '2013-01-24T12:52:30.853', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '9149', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6542', 'Tags': '<formal-languages><terminology><regular-languages><regular-expressions>', 'CreationDate': '2013-01-24T12:03:56.200', 'Id': '9132'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Supposing we have two grammars which define the same languge: regular one and LALR(1) one.</p>\n\n<p>Both regular and LALR(1) algorithms are O(n) where n is input length.</p>\n\n<p>Regexps are usually preferred for parsing regular languages. Why? Is there a formal proof (or maybe that's obvious) that they are faster?</p>\n", 'ViewCount': '125', 'Title': 'Regular vs LALR(1): what is faster', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-26T18:03:37.970', 'LastEditDate': '2013-01-26T18:03:37.970', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6564', 'Tags': '<regular-languages><efficiency><parsers>', 'CreationDate': '2013-01-25T23:42:16.297', 'Id': '9159'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '370', 'Title': "How come {ww} isn't regular when {uv | |u|=|v|} is?", 'LastEditDate': '2013-01-26T19:42:01.027', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'henry', 'PostTypeId': '1', 'OwnerUserId': '6576', 'Body': u'<p>As we know, using the pumping lemma, we can easily prove the language $L = \\{ w w \\mid w \\in \\{a,b\\}^* \\}$ is not a regular language.</p>\n\n<p>However, the language $L_1 = \\{ w_1 w_2 \\mid |w_1| = |w_2| \\}$ is a regular language. Because we can get the DFA like below, </p>\n\n<pre><code>DFA:  \n\n--\u25ba((even))------a,b---------\u25ba(odd)  \n      \u25b2                         |  \n      |--------a,b--------------| \n</code></pre>\n\n<p>My question is, $L = \\{ w w \\mid w \\in \\{a,b\\}^* \\}$ also has the even length of strings ($|w|=|w|$, definitely), so $L$ still can have some DFA like the one above. How come is it not a regular language?</p>\n', 'Tags': '<regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-27T05:20:46.897', 'CommentCount': '5', 'AcceptedAnswerId': '9176', 'CreationDate': '2013-01-26T16:53:57.553', 'Id': '9175'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '105', 'Title': "What's the reason for the second condition of the pumping lemma(s)?", 'LastEditDate': '2013-03-14T15:38:40.960', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5291', 'FavoriteCount': '1', 'Body': '<p>For a language $L$ with pumping length $p$, and a string $s\\in L$, the pumping lemmas are as follows:</p>\n\n<p><strong>Regular version</strong>:\nIf $|s| \\geq p$, then $s$ can be written as $xyz$, satisfying the following conditions:</p>\n\n<ol>\n<li>$|y|\\geq 1$</li>\n<li>$|xy|\\leq p$</li>\n<li>$ \\forall i\\geq 0: xy^iz\\in L$</li>\n</ol>\n\n<p><strong>Context-free version</strong>:\nIf $|s| \\geq p$, then $s$ can be written as $uvxyz$, satisfying the following conditions:</p>\n\n<ol>\n<li>$|vy|\\geq 1$</li>\n<li>$|vxy|\\leq p$</li>\n<li>$ \\forall i\\geq 0: uv^ixy^iz\\in L$</li>\n</ol>\n\n<p>My question is this: <strong>Why do we have condition 2 in the lemma (for either case)?</strong> I understand that condition 1 essentially says that the "pumpable" (meaning nullable or arbitrarily repeatable) substring has to have some nonzero length, and condition 3 says that the pumpable substring can be repeated arbitrarily many times without deriving an invalid string (with respect to $L$). I\'m not sure what the second condition means or why it is important. Is there a simple but meaningful example to illustrate its importance?</p>\n', 'Tags': '<regular-languages><context-free><pumping-lemma>', 'LastEditorUserId': '2100', 'LastActivityDate': '2013-03-14T15:38:40.960', 'CommentCount': '0', 'AcceptedAnswerId': '9275', 'CreationDate': '2013-01-29T07:06:16.453', 'Id': '9269'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a language $L$ with pumping length $p$, and a string $s\\in L$, the pumping lemmas are as follows:</p>\n\n<p><strong>Regular version</strong>:\nIf $|s| \\geq p$, then $s$ can be written as $xyz$, satisfying the following conditions:</p>\n\n<ol>\n<li>$|y|\\geq 1$</li>\n<li>$|xy|\\leq p$</li>\n<li>$ \\forall i\\geq 0: xy^iz\\in L$</li>\n</ol>\n\n<p><strong>Context-free version</strong>:\nIf $|s| \\geq p$, then $s$ can be written as $uvxyz$, satisfying the following conditions:</p>\n\n<ol>\n<li>$|vy|\\geq 1$</li>\n<li>$|vxy|\\leq p$</li>\n<li>$ \\forall i\\geq 0: uv^ixy^iz\\in L$</li>\n</ol>\n\n<p>My question is this: <strong>Can someone give a concise and clear explanation of how regularity (context-freeness) imply the first and second conditions above?</strong> The pumping length is determined by (finite) properties (finite number of states or finite properties of production rules, respectively), the third properties guarantee that a state (production rule) can be skipped or repeated arbitrarily many times, but where do the first and second conditions originate? How are they justified?</p>\n', 'ViewCount': '127', 'Title': 'Where do the length restrictions of the pumping lemma come from?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-18T22:42:40.240', 'LastEditDate': '2013-01-30T20:26:09.033', 'AnswerCount': '4', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2013-01-30T19:10:37.243', 'Id': '9323'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Speaking in terms of automata and regular languages, how would it be possible for a string repeating some $w$ twice equal a string repeating that same $w$ thrice? That is, why is the language</p>\n\n<p>$\\qquad L = \\{w \\in \\Sigma^ * \\mid ww = www\\}$</p>\n\n<p>not empty? The only thing I can think of is $w = abab, ww = abababab, www = abababababab$, but I don't think this is correct.</p>\n", 'ViewCount': '5901', 'Title': 'How can $ww = www$ hold for any word $w$?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T13:49:11.747', 'LastEditDate': '2013-02-02T13:49:11.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '9401', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-02-01T16:48:32.013', 'Id': '9396'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '103', 'Title': 'Regular expression for binary words with few zeros', 'LastEditDate': '2013-02-03T10:21:39.150', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'Jay Satish Teli', 'PostTypeId': '1', 'OwnerUserId': '6687', 'Body': '<p>What is the regular expression for the set of binary strings with the property that</p>\n\n<ol>\n<li>every $0$ is followed by <em>exactly</em> $m$ times $1$ and </li>\n<li>every $0$ is preceded by <em>at least</em> $n$ times $1$? </li>\n</ol>\n\n<p>$m$ and $n$ are integers.</p>\n', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-04T13:35:30.713', 'CommentCount': '2', 'AcceptedAnswerId': '9448', 'CreationDate': '2013-02-03T02:25:16.703', 'Id': '9442'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is the homework question:</p>\n\n<blockquote>\n  <p>$ \\{w \\in \\{a, b, c\\}^* : \\text{(no symbol occurs twice in succession in w)}\\} $</p>\n</blockquote>\n\n<p>This is my answer:</p>\n\n<blockquote>\n  <p>$$\\{((abc)^*| (acb)^*| (ab)^* | (ac)^*)^* | (bac)^* | (bca)^* | (ba)^* | (bc)^*)^* | ((cab)^* | (cba)^* | (ca)^* | (cb)^*)^* | ((\\epsilon +a) | (\\epsilon + b) | (\\epsilon+c)) \\}\n $$</p>\n</blockquote>\n\n<p>Is there a way to simplify this expression?</p>\n', 'ViewCount': '170', 'Title': 'Simplifying regular expressions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-05T10:17:32.417', 'LastEditDate': '2013-02-05T10:17:32.417', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6667', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2013-02-04T22:00:56.437', 'Id': '9492'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the context free grammar:</p>\n\n<p>$$S \\rightarrow aSb \\mid aSa \\mid bSa \\mid bSb \\mid \\varepsilon$$</p>\n\n<p>It could generate regular language, which means it can be converted to a right linear grammar. Is there a general rule to convert CFG into a RLG? If there is no general rule, could you please show me how to convert this CFG to a RLG?</p>\n', 'ViewCount': '792', 'Title': 'How to convert a context free grammar (could generate regular language) to a right-linear grammar', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:16:35.967', 'LastEditDate': '2013-05-24T03:15:42.197', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6576', 'Tags': '<regular-languages><context-free><formal-grammars>', 'CreationDate': '2013-02-06T13:40:06.713', 'Id': '9542'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the language $\\lbrace (aaaaa)^n aa (aaaaa)^n \\mid n \\in \\mathbb{N} \\rbrace$ regular? It looks like I need infinitely many states so it is not regular.</p>\n', 'ViewCount': '132', 'Title': 'Is $(aaaaa)^n aa (aaaaa)^n$ a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-11T21:20:39.350', 'LastEditDate': '2013-02-11T12:04:30.787', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6807', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-02-11T11:00:21.433', 'FavoriteCount': '1', 'Id': '9670'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For example, I know that the non-regular language $a^nb^n$ is in $AC^0$. I would like to know more examples like this.</p>\n', 'ViewCount': '148', 'Title': 'Which non-regular languages are in $AC^0$?', 'LastActivityDate': '2013-02-13T00:40:15.447', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '9720', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '6817', 'Tags': '<complexity-theory><regular-languages><circuits>', 'CreationDate': '2013-02-12T12:32:20.147', 'FavoriteCount': '0', 'Id': '9704'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<ol>\n<li>Is every language with a finite number of strings regular?</li>\n<li>Is the language of all strings regular?</li>\n</ol>\n\n<p>I am new to this topic and got confused. Can any one please help me with this?</p>\n', 'ViewCount': '220', 'Title': 'Is every language with a finite number of strings regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T07:40:04.690', 'LastEditDate': '2013-02-15T07:40:04.690', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6875', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-02-14T15:29:44.697', 'Id': '9773'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For regular languages $R, S$ and $T$, which of the following are true?</p>\n\n<ol>\n<li>$R \\cup S = S \\cup R$</li>\n<li>$(R \\cup S) \\cdot T = RT \\cup ST  $</li>\n<li>$R^* \\cdot S^* = (R \\cup S)^*$</li>\n</ol>\n', 'ViewCount': '56', 'Title': 'Regular language properties', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T07:38:26.373', 'LastEditDate': '2013-02-15T07:38:26.373', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6875', 'Tags': '<formal-languages><regular-languages><sets>', 'CreationDate': '2013-02-14T16:39:40.447', 'Id': '9775'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '305', 'Title': 'Is $A$ regular if $A^{2}$ is regular?', 'LastEditDate': '2013-02-17T09:57:18.313', 'AnswerCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4752', 'FavoriteCount': '3', 'Body': '<p>If $A^2$ is regular, does it follow that $A$ is regular?</p>\n\n<p>My attempt on a proof:</p>\n\n<blockquote>\n  <p>Yes, for contradiction assume that $A$ is not regular.  Then $A^2 = A \\cdot A$. </p>\n  \n  <p>Since concatenation of two non-regular language is not regular $A^2$ cannot be regular.  This contradicts our assumption.  So $A$ is regular.  So if $A^2$ is regular then $A$ is regular.</p>\n</blockquote>\n\n<p>Is the proof correct?</p>\n\n<p>Can we generalize this to $A^3$, $A^4$, etc...?  And also if $A^*$ is regular then $A$ need not be regular?</p>\n\n<p>Example: $A=\\lbrace 1^{2^i} \\mid i \\geq 0\\rbrace$ is not regular but $A^*$ is regular.</p>\n', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-17T19:46:06.063', 'CommentCount': '4', 'AcceptedAnswerId': '9832', 'CreationDate': '2013-02-16T07:41:52.540', 'Id': '9829'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If I have an infinite language $L$ which fulfills the Pumping lemma for regular languages, does $L^*$ also fulfill the same conditions?</p>\n', 'ViewCount': '70', 'Title': 'Is pumping lemma for regular languages "closed" against Kleene star?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T15:04:08.253', 'LastEditDate': '2013-02-16T15:04:08.253', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6885', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-02-16T12:20:29.337', 'Id': '9834'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to determine if the following languages are regular / context free and to explain.  Please help me with that.</p>\n\n<p>$$L_1 = \\{ a^{i_{1}}b a^{i_{2}}b a^{i_{3}}b a^{i_{4}}b a^{i_{5}}b\na^{i_{6}}b a^{i_{7}}b a^{i_{8}}b a^{i_{9}}b a^{i_{10}}b \\mid i_1 &gt; i_2\n&gt; i_3 &gt; i_4 &gt; i_5 &gt; i_6 &gt; i_7 &gt; i_8 &gt; i_9 &gt; i_{10} ; i_1 &lt; 100 \\}$$</p>\n\n<p>$$L_2 = \\{ a^{i_{1}}b a^{i_{2}}b a^{i_{3}}b a^{i_{4}}b a^{i_{5}}b\na^{i_{6}}b a^{i_{7}}b a^{i_{8}}b a^{i_{9}}b a^{i_{10}}b \\mid i_1 &gt; i_2\n&gt; i_3 &gt; i_4 &gt; i_5 &gt; i_6 &gt; i_7 &gt; i_8 &gt; i_9 &gt; i_{10} ; i_2 &lt; 100 \\}$$</p>\n\n<p>$$L_3 = \\{ a^{i_{1}}b a^{i_{2}}b a^{i_{3}}b a^{i_{4}}b a^{i_{5}}b\na^{i_{6}}b a^{i_{7}}b a^{i_{8}}b a^{i_{9}}b a^{i_{10}}b \\mid i_1 &gt; i_2\n&gt; i_3 &gt; i_4 &gt; i_5 &gt; i_6 &gt; i_7 &gt; i_8 &gt; i_9 &gt; i_{10} ; i_3 &lt; 100 \\}$$</p>\n', 'ViewCount': '87', 'Title': 'Regular and context free languages', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T15:15:18.507', 'LastEditDate': '2013-02-16T15:15:18.507', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-3', 'PostTypeId': '1', 'OwnerUserId': '6885', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-02-16T12:33:05.323', 'Id': '9835'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '431', 'Title': 'Is there an efficient test for if an NFA accepts a subset of another NFA?', 'LastEditDate': '2014-04-03T11:58:31.807', 'AnswerCount': '3', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2253', 'FavoriteCount': '3', 'Body': "<p>So, I know that testing if a regular language $R$ is a subset of regular language $S$ is decidable, since we can convert them both to DFAs, compute $R \\cap \\bar{S}$, and then test if this language is empty.</p>\n\n<p>However, since this requires converting to DFAs, it's possible that the DFAs, and thus the testing algorithm, will be exponential in terms of the number of states in the input NFAs.</p>\n\n<p>Is there a known way to do this in polynomial time? Has this problem in general been proved Co-NP complete? </p>\n\n<p>Note that the problem is in Co-NP since a word accepted by $R$ but not by $S$ would be a polynomial certifier that $R \\not \\subseteq S $.</p>\n\n<p>EDIT: this is incorrect, as there is no guarantee that such a word would be polynomial in the number of states.</p>\n", 'Tags': '<algorithms><regular-languages><automata><np-complete><decision-problem>', 'LastEditorUserId': '15050', 'LastActivityDate': '2014-04-03T11:58:31.807', 'CommentCount': '5', 'AcceptedAnswerId': '9955', 'CreationDate': '2013-02-20T06:11:51.547', 'Id': '9954'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '417', 'Title': 'If $L$ is a subset of $\\{0\\}^*$, then how can we show that $L^*$ is regular?', 'LastEditDate': '2013-02-21T19:19:14.377', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '6977', 'FavoriteCount': '1', 'Body': '<p>Say, $L \\subseteq \\{0\\}^*$. Then how can we prove that $L^*$ is regular?</p>\n\n<p>If $L$ is regular, then of course $L^*$ is also regular. If $L$ is finite, then it is regular and again $L^*$ is regular.\nAlso I have noticed that, for $L = \\{0^p \\mid p \\text{ is a prime}\\}$, $L$ is not regular, $L \\subseteq \\{0\\}^*$ and $L^*$ is regular.</p>\n\n<p>But how to show this for any subset $L$ of $\\{0\\}^*$ ?</p>\n', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-21T23:18:20.877', 'CommentCount': '0', 'AcceptedAnswerId': '10018', 'CreationDate': '2013-02-21T17:20:50.127', 'Id': '10013'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '392', 'Title': 'How to apply the pumping lemma to $\\{0^m 1^n \\mid 2n \\leq m \\leq 3n, m,n \\geq 0 \\}$?', 'LastEditDate': '2013-02-25T18:08:15.837', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'FavoriteCount': '1', 'Body': "<p>I'm not really sure the how you would go about proving this language isn't regular with the pumping lemma:</p>\n\n<p>$L= \\{0^m 1^n | 2n \\leq m \\leq 3n, m,n \\geq 0   \\}$</p>\n\n<p>Does this indicate that $S = 2$, so we start by by using a string $\\geq 2$?</p>\n", 'Tags': '<regular-languages><proof-techniques><pumping-lemma>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-25T18:08:15.837', 'CommentCount': '10', 'AcceptedAnswerId': '10072', 'CreationDate': '2013-02-21T19:38:51.083', 'Id': '10019'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do we find all equivalence classes of $\\mathsf{R_L}$ for a language? </p>\n\n<p>Say I\'m trying to look for all equivalent classes for the regular language $\\mathsf{L}$ is $011(0+1)^*011$.</p>\n\n<p>Here\'s an example they give us in the book\n<a href="http://books.google.com/books?id=VEHYzv0GHt8C&amp;pg=PA73&amp;lpg=PA73&amp;dq=ding+du+example+2.51&amp;source=bl&amp;ots=P8gAls0z7f&amp;sig=HIsMb7rcD3hKZHYzi8fYZsyrLQ8&amp;hl=en&amp;sa=X&amp;ei=5N0nUfSoJ6We2gWOv4HYDQ&amp;ved=0CDMQ6AEwAA" rel="nofollow">http://books.google.com/books?id=VEHYzv0GHt8C&amp;pg=PA73&amp;lpg=PA73&amp;dq=ding+du+example+2.51&amp;source=bl&amp;ots=P8gAls0z7f&amp;sig=HIsMb7rcD3hKZHYzi8fYZsyrLQ8&amp;hl=en&amp;sa=X&amp;ei=5N0nUfSoJ6We2gWOv4HYDQ&amp;ved=0CDMQ6AEwAA</a></p>\n\n<p>ps\nThe relation $\\mathsf{R_L}$ is an equivalent relation.\n$\\mathsf{R_L}$ on $\\Sigma^* as:$\n$xRy$ iff $(\\forall w)[xw \\in \\mathsf{L} \\Leftrightarrow yw \\in \\mathsf{L}]$</p>\n', 'ViewCount': '425', 'Title': 'DFA Minimization: Finding all equivalence classes of $\\mathsf{R_L}$ for language $011(0+1)^*011$', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-02-22T21:11:15.843', 'LastEditDate': '2013-02-22T21:07:31.420', 'AnswerCount': '1', 'CommentCount': '19', 'AcceptedAnswerId': '10030', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-02-22T19:56:41.727', 'Id': '10029'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m doing an exercise in my <a href="http://rads.stackoverflow.com/amzn/click/0073191469" rel="nofollow">book</a>, the question is to find a string of minimum length in $\\{a, b\\}^*$ not in the language corresponding to the given regular expression.</p>\n\n<p>a. $b^*(ab)^*a^*$</p>\n\n<p>My answer: $aab$</p>\n\n<p>b. $(a^* + b^*)(a^* + b^*)(a^* + b^*)$</p>\n\n<p>My answer: $abab$</p>\n\n<p>c. $a^*(baa^*)^*b^*$</p>\n\n<p>My answer: $bba$</p>\n\n<p>d. $b^*(a + ba)^*b^*$</p>\n\n<p>My answer: $abba$</p>\n\n<p>I came up with my answers by trial and error. I don\'t know for sure if these are the shortest possible strings. Is the best method trial and error, or would there be some better algorithmic way?</p>\n', 'ViewCount': '246', 'Title': 'String of minimum length in $\\{a, b\\}^*$ not in a regular expression', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-06T18:54:15.723', 'LastEditDate': '2013-04-06T18:54:15.723', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10065', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><regular-languages><regular-expressions><check-my-answer>', 'CreationDate': '2013-02-24T20:23:54.390', 'Id': '10064'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the grammar</p>\n\n<p>$\\qquad S \\to 1A0A \\mid 0A \\mid \\varepsilon$</p>\n\n<p>a right-linear grammar? $A$ is a nonterminal here, $0$ and $1$ are terminals.</p>\n\n<p>I know $0A$ is right-linear but what about $1A0A$?</p>\n\n<p>Trying to construct a right-linear grammar for language $10(0+1)^*10$.</p>\n', 'ViewCount': '155', 'Title': 'Constructing right-linear grammar', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-02-27T12:56:06.467', 'LastEditDate': '2013-02-27T12:56:06.467', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10075', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><formal-grammars>', 'CreationDate': '2013-02-25T02:21:38.463', 'Id': '10074'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '135', 'Title': 'Is The Following Language Regular?', 'LastEditDate': '2013-02-28T00:14:10.330', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Body': '<p>Let $L_{1}$ and $L_{2}$ be 2 languages over the same alphabet $\\Sigma$.  </p>\n\n<p>$$A(L_1,L_2)=\\{x\\in \\Sigma^*|\\exists y,z\\in L_2\\text{ such that } yxz\\in L_1\\}$$</p>\n\n<p>Assume that $L_{1}$ is regular and $L_{2}$ is context-free. The language $A(L_{1},L_{2})$:</p>\n\n<ol>\n<li>is always a regular language</li>\n<li>is always not a regular language</li>\n<li>can sometimes be a regular language</li>\n<li>cannot be context free</li>\n</ol>\n\n<p>They say that the correct answer is 1.</p>\n', 'ClosedDate': '2013-03-01T08:12:00.193', 'Tags': '<formal-languages><regular-languages><automata><context-free><finite-automata>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-03-01T03:38:56.220', 'CommentCount': '4', 'AcceptedAnswerId': '10163', 'CreationDate': '2013-02-27T23:51:15.260', 'Id': '10147'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1427', 'Title': 'DFA to regular expression conversion', 'LastEditDate': '2013-03-02T00:16:02.467', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '1', 'Body': '<p>I was looking at the question <a href="http://cs.stackexchange.com/questions/2016/how-to-convert-finite-automata-to-regular-expressions">How to convert finite automata to regular expressions?</a> to convert DFA to regex.</p>\n\n<p>The question, I was trying to solve is:</p>\n\n<p><img src="http://i.stack.imgur.com/e7YPr.jpg" alt="enter image description here"></p>\n\n<p>I have got the following equations:</p>\n\n<p>$Q_0=aQ_0 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>$Q_1=aQ_1 \\cup bQ_1 \\cup \\epsilon$</p>\n\n<p>When solved, we will get $Q_0=a^*b(a \\cup b)^* \\cup\\ \\epsilon$</p>\n\n<p>But my doubt is that, in the DFA starting state is also the final state so, even if we dont give any $b$, it will be accepted, if we give some $a$. But in the regex we have $b$, instead of $b^*$. Why is it so? Is it because,we have that regex $\\cup$ $\\epsilon$ ?</p>\n', 'Tags': '<regular-languages><automata><finite-automata><regular-expressions>', 'LastEditorUserId': '947', 'LastActivityDate': '2013-03-02T01:00:05.917', 'CommentCount': '2', 'AcceptedAnswerId': '10184', 'CreationDate': '2013-03-01T17:26:49.227', 'Id': '10180'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My question: do the non-regular languages have closure properties? For example, if the reverse of L is non-regular, then L is non-regular ? thank you :-) </p>\n', 'ViewCount': '1305', 'Title': 'Are the non-regular languages closed under reverse, union, concatenation, etc?', 'LastEditorUserId': '4287', 'LastActivityDate': '2013-03-03T01:36:10.540', 'LastEditDate': '2013-03-03T01:36:10.540', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7107', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-03-02T12:03:38.260', 'FavoriteCount': '1', 'Id': '10205'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $\\operatorname{value}(x)$ be the result when the symbols of $x$ are multiplied from left to right according to\n <p>$\\qquad \\displaystyle\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; a &amp; c \\\\\n    b &amp; c &amp; a &amp; b \\\\\n    c &amp; b &amp; c &amp; a\n   \\end{array}$</p></p>\n\n<p> Is $L=\\{xy \\mid |x|=|y| \\land \\operatorname{value}(x) = \\operatorname{value}(y)\\}$ regular?</p>\n\n<p> Is $L=\\{xy \\mid \\operatorname{value}(x)= \\operatorname{value}(y)\\}$ regular?</p>\n', 'ViewCount': '143', 'Title': 'Are these two languages regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-05T07:03:47.100', 'LastEditDate': '2013-03-05T07:03:47.100', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7135', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-03-04T06:58:57.633', 'Id': '10251'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is the question:</p>\n\n<p>Show that $L = \\{0^m1^n : m &gt; 1, n &gt; 1, n &lt; m \\}$ is not regular.</p>\n\n<p>I am not sure what superscripts mean in this situation? Does it mean something like this:</p>\n\n<p>$0^5 = 00000$ or $1^7 = 1111111$.</p>\n', 'ViewCount': '53', 'Title': 'Formal Language Syntax', 'LastEditorUserId': '683', 'LastActivityDate': '2013-03-06T23:44:22.213', 'LastEditDate': '2013-03-06T19:32:26.397', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '10331', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<formal-languages><regular-languages><automata>', 'CreationDate': '2013-03-06T19:26:52.783', 'Id': '10329'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a regular language $L$, can we say anything about its complement $\\overline L$? One thing that is trivial to say is that the DFA's for both languages are equal in size as complementing the language is simply a matter of changing all accepting states into rejecting states and vice-versa. Are there any other things to conclude? Is there anything one can say about the number of states of a (minimal) NFA?</p>\n", 'ViewCount': '272', 'Title': 'Can we say anything about the complement of a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-12T10:28:18.477', 'LastEditDate': '2013-03-12T10:28:18.477', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'OwnerDisplayName': 'FUZxxl', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<regular-languages><finite-automata><closure-properties>', 'CreationDate': '2013-03-11T14:18:52.303', 'Id': '10458'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '578', 'Title': 'Show that the Kleene star of any unary language is regular', 'LastEditDate': '2013-03-17T00:28:59.150', 'AnswerCount': '1', 'Score': '3', 'OwnerDisplayName': 'Martin', 'PostTypeId': '1', 'OwnerUserId': '8978', 'Body': "<p>An exercise asks me to show that the Kleene star of any unary language $L$ is regular. $E$ is the alphabet, $E = \\{ 1 \\}$</p>\n\n<p>Here's my reasoning :</p>\n\n<ul>\n<li>$L$ is regular $\\implies$ $L^*$ is regular (closure property)</li>\n<li>$L$ is not regular\n<ul>\n<li>$L$ contains the word of length 1 $\\implies$ $L^* = E^* \\cup \\{\\epsilon\\}$ $\\implies$ $L^*$ is regular (since $E^*$ is regular, and the union of two regular languages is regular)</li>\n<li>$L$ does not contain the word of length 1 -> ... ?</li>\n</ul></li>\n</ul>\n\n<p>This is where I'm stuck. I don't know what to do if $L$ does not contain the word of length 1. I do not think that there exists a relation between $L^*$ and $(L \\text{ complement})^*$.</p>\n\n<p>Does anyone have any idea to continue this proof ? Thank you.</p>\n", 'ClosedDate': '2013-03-17T09:21:32.963', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-17T00:28:59.150', 'CommentCount': '0', 'AcceptedAnswerId': '10556', 'CreationDate': '2013-03-16T14:52:57.753', 'Id': '10555'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '98', 'Title': 'Deciding whether a given language is regular', 'LastEditDate': '2013-03-16T19:59:08.193', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'Yotam', 'PostTypeId': '1', 'OwnerUserId': '7303', 'Body': "<p>I am struggling with a homework assignment. This next question seems to be pretty easy, once I get what I feel like I'm missing now. Anyway, here goes:</p>\n\n<blockquote>\n  <p>Decide if the following language is regular or not and prove your\n  claim.</p>\n  \n  <p>$$L=\\{a^{i_{1}}ba^{i_{2}}ba^{i_{3}}ba^{i_{4}}ba^{i_{5}}ba^{i_{6}}ba^{i_{7}}b|i_{1}&gt;i_{2}&gt;i_{3}&gt;i_{4}&gt;i_{5}&gt;i_{6}&gt;i_{7};i_{1}&lt;100\\}$$</p>\n</blockquote>\n\n<p>So, how do I go about doing so? Is there a thumb rule that might help? I was trying to use the pumping lemma to prove that it is not regular, but couldn't do it. I'm not even sure it really is not regular.</p>\n\n<p>Any suggestions? </p>\n", 'ClosedDate': '2013-03-17T18:08:26.427', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-16T19:59:08.193', 'CommentCount': '4', 'AcceptedAnswerId': '10559', 'CreationDate': '2013-03-16T17:56:32.230', 'Id': '10557'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading the proof of pumping lemma from Sipser\'s book. I couldn\'t understand certain things mentioned there.</p>\n\n<p><img src="http://i.stack.imgur.com/OEUAS.jpg" alt="pumping lemma proof"></p>\n\n<p>In the second paragraph he has written, "because $r_l$ occurs among first $p+1$ places, we have $l \\le p+1$". Here, does $l$ denotes the number of states visited?</p>\n\n<p>Also he wrote  "We know that $j \\neq l$, so $|y| &gt; 0$; and $l \\le p+1$; so $|xy| \\le p$"</p>\n\n<p>What I didn\'t understand is</p>\n\n<ol>\n<li><p>$j \\neq l$ </p></li>\n<li><p>$j \\neq l$, so $|y| &gt; 0$ </p></li>\n<li><p>$l \\le p+1$; so $|xy| \\le p$</p></li>\n</ol>\n', 'ViewCount': '135', 'Title': 'Pumping Lemma for regular languages proof doubt - Sipser Book', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-17T18:20:36.850', 'LastEditDate': '2013-03-17T18:20:36.850', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10579', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<regular-languages><automata><pumping-lemma>', 'CreationDate': '2013-03-17T12:24:12.517', 'Id': '10577'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Why is $A(L) = \\{x \\in L \\mid x = x^R \\}$ context-free if $L$ is a regular language? </p>\n\n<p>Trying to understand the approach to determining whether a regular language is context-free.</p>\n', 'ViewCount': '128', 'Title': 'Why is the subset of palindromes of a regular language context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-21T10:30:15.167', 'LastEditDate': '2013-03-21T10:28:57.977', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '10677', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2013-03-21T02:15:36.403', 'Id': '10675'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '405', 'Title': 'Star free language vs. regular language', 'LastEditDate': '2013-03-27T15:46:17.093', 'AnswerCount': '3', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7410', 'FavoriteCount': '2', 'Body': u'<p>I was wondering, since $a^*$ is itself a star-free language, is there a regular language that is not a star-free language? Could you give an example?</p>\n\n<hr>\n\n<p><em>(from <a href="http://en.wikipedia.org/wiki/Star-free_language#cite_ref-Law235_1-0" rel="nofollow">wikipdia</a>)</em> Lawson defines star-free languages as:</p>\n\n<blockquote>\n  <p>A regular language is said to be star-free if it can be described by a regular expression constructed from the letters of the alphabet, the empty set symbol, all boolean operators \u2013 including complementation \u2013 and concatenation but no Kleene star.</p>\n</blockquote>\n\n<hr>\n\n<p>Here is the proof of $a^*$ being star-free:</p>\n\n<blockquote>\n  <p>$\\emptyset$ is star-free $\\Longrightarrow$<br>\n  $\\Sigma^*=\\bar{\\emptyset}$ is star-free $\\Longrightarrow$<br>\n  $A\\subseteq\\Sigma\\Rightarrow\\Sigma^*A\\Sigma^*$ is star-free $\\Longrightarrow$<br>\n  $A\\subseteq\\Sigma\\Rightarrow\\ A^*=\\overline{\\Sigma^*\\overline{A}\\Sigma^*}$ is star-free</p>\n</blockquote>\n', 'Tags': '<formal-languages><regular-languages><automata>', 'LastEditorUserId': '7410', 'LastActivityDate': '2013-08-16T16:56:08.473', 'CommentCount': '0', 'AcceptedAnswerId': '10769', 'CreationDate': '2013-03-25T11:21:07.097', 'Id': '10768'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have two regular languages <em>A</em> and <em>B</em>, and I want to determine whether there is any pair of strings, <em>a</em> in <em>A</em> and <em>b</em> in <em>B</em>, such that (<em>a</em>&nbsp;<em>b</em>) is a prefix of a string in (<em>A</em>&nbsp;<em>B</em>) and the left-most match of <em>B</em> in (<em>a</em>&nbsp;<em>b</em>) includes one or more characters from <em>a</em>.</p>\n\n<p>Raphael\'s formulation is good:</p>\n\n<blockquote>\n  <p>Given two regular language A, B, is there a (non-empty) prefix of a word b in B that is a suffix of a word in A so that the rest of b is a prefix of another word in B?</p>\n</blockquote>\n\n<h1>Example</h1>\n\n<p>For example, let\'s say I have two regular languages, one which describes some properly escaped HTML text, and one which describes an end tag:</p>\n\n<pre><code>A := ([^&amp;&lt;&gt;] | [&amp;] [a-z] [a-z0-9]+ [;])*;\nB := "&lt;/title";\n</code></pre>\n\n<p>By inspection, I can tell that there is no string (<em>a</em>&nbsp;<em>b</em>) in (<em>A</em>&nbsp;<em>B</em>) such that the first match of <em>B</em> includes characters from <em>a</em> because <code>"&lt;"</code> is a prefix of <em>B</em> which cannot occur as a suffix of <em>A</em>.</p>\n\n<p>But given a different grammar:</p>\n\n<pre><code>A\' := (A | "&lt;![CDATA[" ("]"? "&gt;" | "]"* [^\\]&gt;])* "]]&gt;")*;\nB\' := "&lt;/title" ([^&gt;\\"] | [\\"] [^\\"]* [\\"])* "&gt;";\n</code></pre>\n\n<p>then there are strings</p>\n\n<pre><code>a = \'&lt;![CDATA[&lt;/title "]]&gt;"\';\nb = \'&lt;/title&gt;\';\n</code></pre>\n\n<p>where (<em>A</em>&nbsp;<em>B</em>) matches <code>\'&lt;![CDATA[&lt;/title "]]&gt;"&lt;/title&gt;\'</code> and the left-most match of <em>B</em> is <code>\'&lt;/title "]]&gt;"&lt;/title&gt;\'</code> which includes a non-empty suffix of <em>a</em> : <code>\'&lt;/title "]]&gt;"\'</code>.</p>\n\n<h1>Motivation</h1>\n\n<p><em>A</em> in my situation describes the output of an encoder/sanitizer that is derived from a grammar, so an untrusted input is fed to the encoder/sanitizer and I know the output matches <em>A</em> by construction.</p>\n\n<p><em>B</em> is a limit condition in a larger grammar that describes how parsers determine where a chunk of an embedded language ends so they can hand it off to a parser for the embedded language.</p>\n\n<p>My end goal is to be able to determine when I can optimize away runtime checks that ensure that it is safe to embed a particular encoded string.  For these examples, it would be safe to optimize out the first check, but not the second.</p>\n\n<hr>\n\n<p>Is this a solved problem?  Does it have a name?  Any pointers appreciated.</p>\n', 'ViewCount': '76', 'Title': 'For regular languages A and B, determine whether B might match early in (A B)', 'LastEditorUserId': '1298', 'LastActivityDate': '2013-03-28T18:43:58.467', 'LastEditDate': '2013-03-28T18:43:58.467', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><regular-languages><regular-expressions><parsers>', 'CreationDate': '2013-03-27T21:11:15.627', 'Id': '10852'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm reading my textbook and it claims that the regular expression $c^*(b \\cup (ac)^*)^*$ defines the language $L$ over $\\{a,b,c\\}$ which consists of <strong>all</strong> strings that do not contain the substring $bc$. </p>\n\n<p>However, I'm failing to see how that language would contain strings such as $bbbaaa$ or $aaabbb$. Am I missing something or is that regular expression incorrect? The expression I come up with was $ \\left( \\left( \\left( a \\cup b \\right) ^*a \\right) ^* \\left( c \\cup a \\right) ^* \\right) ^*b^* $</p>\n", 'ViewCount': '109', 'Title': "Does $c^*(b \\cup (ac)^*)^*$ define all strings over $\\{a,b,c\\}$ that don't contain the substring $bc$", 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T11:22:02.750', 'LastEditDate': '2013-03-28T10:36:10.927', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '10867', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7461', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-03-28T03:33:26.653', 'Id': '10857'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This question is on the GRE Computer Science test booklet (not homework). I tried applying closure properties of regular languages but no success.</p>\n\n<p>Suppose $L$ is a regular language over $\\Sigma = \\{0, 1\\}$. Show that the language </p>\n\n<p>$\\qquad L' = \\{w \\in L \\mid |w| \\in 2\\mathbb{N}\\}$ </p>\n\n<p>is also regular.</p>\n\n<p>What I find surprising is that the booklet mentions that the language $\\{w \\in L \\mid |w| = 2^k, k \\in \\mathbb{N}\\}$ is not necessarily a regular language. </p>\n", 'ViewCount': '460', 'Title': 'Proof that regular languages are closed against taking the even-length subset', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-01T23:26:38.987', 'LastEditDate': '2013-04-02T08:16:56.630', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '5', 'OwnerDisplayName': 'Dmitrii I.', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-03-30T22:49:33.747', 'Id': '10927'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I know every regular language is Turing-acceptable, but does that imply it is Turing-decidable?</p>\n', 'ViewCount': '537', 'Title': 'Is every regular language Turing-decidable, and how can we prove this?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-03T07:10:25.113', 'LastEditDate': '2013-04-03T07:10:25.113', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10973', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<terminology><computability><regular-languages><decision-problem>', 'CreationDate': '2013-04-02T13:51:03.390', 'Id': '10971'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to write a regular expression that accepts any odd binary number not preceded by a 0. the best I can come up with is $1(0\\cup1)^*1$, but that doesn't match just 1. The best it matches is 11.</p>\n", 'ViewCount': '286', 'Title': 'Regular expression for odd binary numbers without leading zeros', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-03T07:42:55.550', 'LastEditDate': '2013-04-03T07:15:35.700', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '10989', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6569', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-04-02T23:29:28.500', 'Id': '10983'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $L$ be a regular language.<br>\nIs the language $L_2 = \\{y : \\exists x,z\\ \\ s.t.|x|=|z|\\ and\\ xyz \\in L \\}$ regular?</p>\n\n<p>I know it\'s very similar to the <a href="http://cs.stackexchange.com/questions/7588/regularity-of-middles-of-words-from-regular-language">question here</a>, but the catch is that it\'s not a simple substring of a word in a regular language, but rather an "exact middle" - we have to count the prefix and suffix length.</p>\n\n<p>Therefore, I assume it\'s not regular, but I couldn\'t find a way to prove it. I also couldn\'t think of any way to modify the NFA of $L$ to accept $L_2$.</p>\n', 'ViewCount': '145', 'Title': 'Regularity of the exact middle of words from a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-04T23:21:21.383', 'LastEditDate': '2013-04-04T23:21:21.383', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7577', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-04-04T15:05:08.010', 'FavoriteCount': '1', 'Id': '11018'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to brush up on my regular grammar knowledge to prepare for an interview, and I just am not able to solve this problem at all. This is NOT for homework, it is merely me trying to solve this.</p>\n\n<p>I want to give a regular grammar for the language of the finite automaton whose screenshot is below, please help me, and if you can, a step by step answer would be of great assistance. Thank you!\n<img src="http://i.stack.imgur.com/y3WlZ.png" alt="screenshot"></p>\n', 'ViewCount': '186', 'Title': 'Giving a regular grammar for the language', 'LastEditorUserId': '917', 'LastActivityDate': '2013-04-05T11:50:25.610', 'LastEditDate': '2013-04-05T11:50:25.610', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'OwnerDisplayName': 'CSTHEORY', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-04-04T16:09:45.593', 'Id': '11024'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm a bit confused as to how to represent the Chomsky form for the language L that generates all strings with the alphabet {a}</p>\n\n<p>My approach was</p>\n\n<pre><code>S -&gt; AB | e\nA -&gt; a\n</code></pre>\n\n<p>Now here's the part I'm confused, how do I represent B? If B -> a then I get only even strings, if B -> e then it's not in normal form. :| Any help would be appreciated. </p>\n", 'ViewCount': '30', 'Title': 'Chomsky form for language of single alphabet member', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T11:19:25.227', 'LastEditDate': '2013-04-07T11:19:25.227', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11062', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7600', 'Tags': '<formal-languages><regular-languages><formal-grammars><normal-forms>', 'CreationDate': '2013-04-05T16:11:19.500', 'Id': '11061'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this problem:</p>\n\n<blockquote>\n  <p>Let $L_1$ and $L_2$ be two regular languages.  Show that $L_3 = \\{xx^r : x \\in L_1, x^r \\in L_2 \\}$ is a context-free language.</p>\n</blockquote>\n\n<p>I am unsure how to prove that some language is context-free. Could someone please provide the steps?</p>\n', 'ViewCount': '90', 'Title': 'Proving $\\{xx^R \\mid x\\in L_1, x^R\\in L_2\\}$ is context-free', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-12T07:21:14.713', 'LastEditDate': '2013-04-12T02:45:42.930', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11242', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-04-11T20:45:46.487', 'Id': '11240'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>$L = \\{a^i b^j a^k \\ | \\ k &gt; i + j\\}$</p>\n  \n  <p>Use the pumping lemma to show that this language cannot be accepted by an FA.</p>\n</blockquote>\n\n<p><strong>Proof:</strong></p>\n\n<p>Suppose $L$ can be accepted by an FA.</p>\n\n<p>Suppose a string $s = xyz \\in L$, where</p>\n\n<p>$$\\begin{align} \n&amp;x=a^n \\\\\n&amp;y=b \\\\\n&amp;z=a^{n+2} \n\\end{align}\n$$.</p>\n\n<p>Then a string $t = a^n b^i a^{n+2}$ should also be in $L$ for $i \\ge 0$, $n+i&lt;n+2$ and should also be accepted by an FA. But if $i=3$,</p>\n\n<p>$$\\begin{align} n+i = n + 3 \\\\&gt;n + 2 \\end{align}$$</p>\n\n<p>and $t \\not \\in L$, which is a contradiction. Thus, $L$ cannot be accepted by an FA.</p>\n\n<hr>\n\n<p>Is this proof thorough? I am worried about the line $n+i&lt;n+2$, because it doesn't work for all values of $i$. Should I pick a string that works for all possible cases?</p>\n", 'ViewCount': '201', 'Title': 'Using pumping lemma to show $L = \\{a^i b^j a^k \\ | \\ k > i + j\\}$ cannot be accepted by an FA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-15T11:33:14.773', 'LastEditDate': '2013-04-15T11:33:14.773', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11318', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4689', 'Tags': '<formal-languages><regular-languages><pumping-lemma><check-my-answer>', 'CreationDate': '2013-04-14T19:11:26.940', 'Id': '11317'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a regular language $L$, let $c_n(L)$ be the number of words in $L$ of length $n$. Using Jordan canonical form (applied to the unannotated transition matrix of some DFA for $L$), one can show that for large enough $n$,\n$$ c_n(L) = \\sum_{i=1}^k P_i(n) \\lambda_i^n, $$\nwhere $P_i$ are complex polynomials and $\\lambda_i$ are complex "eigenvalues". (For small $n$, we may have additional terms of the form $C_k[n=k]$, where $[n=k]$ is $1$ if $n=k$ and $0$ otherwise. These correspond to Jordan blocks of size at least $k+1$ with eigenvalue $0$.)</p>\n\n<p>This representation seems to imply that if $L$ is infinite then asymptotically, $c_n(L) \\sim C n^k \\lambda^n$ for some $C,\\lambda&gt;0$. However, this is patently false: for the language $L$ over $\\{0,1\\}$ of all words of even length, $c_{2n}(L) = 2^{2n}$ but $c_{2n+1}(L) = 0$. This suggests that for some $d$ and for all $a \\in \\{0,\\ldots,d-1\\}$, either $c_{dm+a}(L) = 0$ for large enough $m$ or $c_{dm+a} \\sim C_a (dm+a)^{k_a} \\lambda_a^{dm+a}$. This is proved in <a href="http://algo.inria.fr/flajolet/Publications/FlSe02.ps.gz">Flajolet &amp; Sedgewick</a> (Theorem V.3), who attribute the proof to Berstel.</p>\n\n<p>The proof provided by Flajolet and Sedgewick is somewhat technical; so technical, in fact, that they only sketch it. I attempted a more elementary proof using Perron-Frobenius theory. We can regard the transition graph of the DFA as a digraph. If the digraph is primitive then the result follows almost directly from the Perron-Frobenius theorem. If the digraph is irreducible but imprimitive with index $r$, then by considering the "$r$th power" of the DFA (each transition corresponds to $r$ symbols), we get the same result. The difficult case is when the digraph is reducible. We can reduce to the case of a path of strongly connected components, and then we get the result by estimating sums of the form\n$$ \\sum_{m_1+\\cdots+m_k=m} \\prod_{i=1}^k \\lambda_i^{m_i}. $$\n(Each such sum corresponds to a particular way of accepting a word, going through the different components in a certain way.) This sum, in turn, can be estimated by pinpointing the largest term, which corresponds to $m_i \\propto \\log \\lambda_i$. For every eigenvalue which is repeated $r$ times, we get an extra factor of $\\Theta(m^{r-1})$.</p>\n\n<p>The proof has its rough edges: in the reducible case, we need to pass from terms asymptotic to $C \\lambda_i^m$ to the sum mentioned above, and then we need to estimate the sum.</p>\n\n<p>The proof by Flajolet and Sedgewick is perhaps simpler, but less elementary. Its starting point is the rational generating function of $c_n(L)$, and it involves induction on the number of pole magnitudes (!). The basic idea is that all eigenvalues of maximal modulus are roots of unity (if normalized by their modulus), due to a (moderately easy) theorem of Berstel. Choosing an appropriate $d$ and looking at words of length $dm+a$, all these eigenvalues become real. Considering the partial fraction expansion, we get that if the eigenvalue of maximal modulus "survives", then it determines the asymptotics, which are of the form $Cn^k\\lambda^n$. Otherwise, we find a new rational generating function which corresponds just to words of this length (using an Hadamard product), and repeat the argument. The aforementioned quantity keeps decreasing, and so eventually we find the desired asymptotics; $d$ might have to grow in the process, to reflect everything that happens in the inductive steps.</p>\n\n<blockquote>\n  <p>Is there a simple and elementary proof for the asymptotic property of $c_n(L)$?</p>\n</blockquote>\n', 'ViewCount': '449', 'Title': 'Asymptotics of the number of words in a regular language of given length', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-27T16:50:23.943', 'LastEditDate': '2013-04-16T09:30:24.363', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '22', 'PostTypeId': '1', 'OwnerUserId': '683', 'Tags': '<formal-languages><reference-request><regular-languages><asymptotics><combinatorics>', 'CreationDate': '2013-04-16T01:37:16.013', 'FavoriteCount': '6', 'Id': '11350'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '173', 'Title': 'Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular', 'LastEditDate': '2013-04-30T15:54:36.220', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7492', 'FavoriteCount': '1', 'Body': "<p>Prove that $L_1$ is regular if $L_2$, $L_1L_2$, $L_2L_1$ are regular.</p>\n\n<p>These are the things that I would use to start.</p>\n\n<ul>\n<li>As $L_1L_2$ is regular, then the homomorphism $h(L_1L_2)$ is regular.</li>\n<li>Let $h(L_1) = L_2$ and $h(L_2) = L_1$, then $h(L_1L_2) = L_2L_1$ is regular (we already know that) or $h(L_2) = \\epsilon$ and we get $L_1$</li>\n<li>By reflexing, $L_1L_2 = (L_2L_1)^{R}$, same result.</li>\n</ul>\n\n<p>But i don't know how to, for example, intersect something that gives me $L_1$ in order to preserve closure and finally $L_1$ be regular.</p>\n\n<p>Any help?</p>\n", 'Tags': '<regular-languages><finite-automata><proof-techniques><closure-properties>', 'LastEditorUserId': '472', 'LastActivityDate': '2013-04-30T15:54:36.220', 'CommentCount': '0', 'AcceptedAnswerId': '11596', 'CreationDate': '2013-04-27T03:06:35.000', 'Id': '11592'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The regular expression $a^{3}b^{+}$ is indeed regular because we can define an automata $M$. But I see that $\\mathcal{L} = \\{a^{3}b^{n}, n \\geq 1\\}$ may generate the same strings, but using the pumping lemma with constant $N$ for a substring $\\alpha\\beta = a^{3}b^{t},|\\alpha\\beta| \\leq N$, let $\\alpha = a$ and $\\beta = a^{2}b^{t}$, therefore $\\gamma = b^{N-t}$, and when $k = 0$, $\\sigma = \\alpha \\beta^{0} \\gamma = \\alpha \\gamma = ab^{N-t}$, which doesn't belong to $\\mathcal{L}$ and the language isn't regular.</p>\n\n<p>So, is really the regex equal to $\\mathcal{L}$? or am I pumping wrong?</p>\n", 'ViewCount': '62', 'Title': 'Is the language $a^{3}b^{+}$ the same as $\\{a^{3}b^{n}, n \\geq 1\\}$ ? and what is the result of pumping this?', 'LastActivityDate': '2013-04-28T04:30:58.543', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11621', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7492', 'Tags': '<regular-languages><finite-automata><regular-expressions><pumping-lemma>', 'CreationDate': '2013-04-28T03:39:32.733', 'FavoriteCount': '1', 'Id': '11619'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '307', 'Title': 'Without using pumping lemma, can we determine if $A =\\{ww \\mid w \\in \\{0,1\\}^* \\}$ is non regular?', 'LastEditDate': '2013-05-03T17:47:26.473', 'AnswerCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6980', 'FavoriteCount': '0', 'Body': "<p>Without using pumping lemma, can we prove $A =\\{ww \\mid w \\in \\{0,1\\}^* \\}$ is non regular?</p>\n\n<p>Is $L= \\{w \\mid w \\in \\{0,1\\}^* \\}$ non regular? I'm thinking of using concatenation to prove the former isn't regular. If L is non regular then so is LL</p>\n", 'Tags': '<regular-languages>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-02-20T17:44:26.913', 'CommentCount': '1', 'AcceptedAnswerId': '11760', 'CreationDate': '2013-05-03T14:21:29.843', 'Id': '11759'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $\\mbox{bin}(n)$ denote the binary representation of an integer $n$.  Let $L = \\{ \\mbox{bin}(n^2) \\mid n \\in \\mathbb{N} \\}$.</p>\n\n<blockquote>\n  <p>Is $L$ a regular language?</p>\n</blockquote>\n\n<p>I think one can prove that $L$ is not regular by using the pumping lemma, but I don't know how to use it here.</p>\n", 'ViewCount': '259', 'Title': 'Is the language of binary representation of perfect squares regular?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-05-05T16:48:05.990', 'LastEditDate': '2013-05-05T08:33:29.370', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '7', 'OwnerDisplayName': 'user15735', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-05-03T17:53:37.580', 'FavoriteCount': '3', 'Id': '11770'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>(This is the problem 1.56 from Michael Sipser' Introduction to the theory of computation )</p>\n\n<p>Let<br>\n$A_k(S)= \\{ w |w \\text{ is the k-basis representation}$<br>\n$\\text{ without leading 0 of some natural number in the set S}\\} $</p>\n\n<p>Example : $A_2 (\\{3,5\\}) = \\{11,101\\} $</p>\n\n<p>Let the statement $ P = \\exists S \\text{, a set of natural number where} A_2(S) \\text{ is regular and }A_3(S) \\text{ isn't.}   $ </p>\n\n<p>Is $P$ true ?</p>\n\n<hr>\n\n<p>I think that $P$ is false.</p>\n\n<p>Let's consider two case :  </p>\n\n<p>$S$ is finite :</p>\n\n<p>Write a (possibly very long) regular expression which is the union of all of the k-basis representation strings of the numbers in $S$ no matter what $k$ is.</p>\n\n<p>$S$ is infinite :</p>\n\n<p>Construct a NFA $N$ that recognize $A_k(S)$ with :<br>\n$\\text{For each symbol }e\\in\\Sigma\\smallsetminus 0, \\space$\n$\\delta(q_{initial},e) = q_{begin},\\space q_{begin} \\in F $\n$\\text{For each symbol }e\\in\\Sigma,\\space \\delta(q_{begin},e) = q_e ,\\space \\delta(q_e,\\varepsilon) = q_{begin},\\space q_e \\in F  $</p>\n\n<p>Am i correct ? (I think I'm not but I'm stuck with this, maybe I don't get the definition of $A$ correctly ).</p>\n", 'ViewCount': '148', 'Title': 'k-basis representation of natural numbers', 'LastEditorUserId': '8031', 'LastActivityDate': '2013-06-04T03:32:09.350', 'LastEditDate': '2013-05-04T18:41:14.090', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8031', 'Tags': '<regular-languages>', 'CreationDate': '2013-05-04T16:52:33.147', 'FavoriteCount': '1', 'Id': '11776'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Let $L$ be a regular language. Prove that:</p>\n  \n  <ol>\n  <li><p>$L_{+--}=\\left\\{w: \\exists_u |u|=2|w| \\wedge wu\\in L\\right\\}$ </p></li>\n  <li><p>$L_{++-}=\\left\\{w: \\exists_u 2|u|=|w| \\wedge wu\\in L \\right\\}$</p></li>\n  <li><p>$L_{-+-}=\\left\\{w:\\exists_{u,v} |u|=|w|=|v| \\wedge uwv\\in L\\right\\}$</p></li>\n  </ol>\n  \n  <p>are regular and:</p>\n  \n  <ol>\n  <li>$L_{+-+}=\\left\\{ uv:\\exists_w |u|=|w|=|v| \\wedge uwv\\in L \\right\\}$ </li>\n  </ol>\n  \n  <p>is not regular.</p>\n</blockquote>\n\n<p>Seems very hard to me. I suppose 1-3 are similar (but I may be wrong), but I don't know how to approach. General idea is usually to modify finite state machine for $L$ to accept other language. But those constructions are often very sophisticated and I still can't come up with it alone.</p>\n", 'ViewCount': '231', 'Title': 'Proving that language is regular or not regular', 'LastActivityDate': '2013-05-05T03:23:51.873', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '11792', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '8041', 'Tags': '<regular-languages>', 'CreationDate': '2013-05-04T22:38:26.607', 'FavoriteCount': '1', 'Id': '11785'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can we design a regular expressions without particular substrings.\nThe goal of this is to create language <code>L</code> which won't contain a particular substring (i.e. 110)</p>\n\n<p>for the case of a regular expression without substring $110$, I Was thinking of: $\\require{cancel}\\cancel{(101)^*+}(010)^*+(10)^*+(\\cancel{1}1)^*+(\\cancel{0}0)^*+(01)^*$ but is that over excessive?</p>\n\n<p>Then for example, I crossed out (101)* because obviously if you have two of those 101101, a subset of that will be 110, which we don't want.</p>\n\n<h3>Notes:</h3>\n\n<p>Question has been edited since it gained attention in the past few days. Also see comment for justification.</p>\n", 'ViewCount': '3292', 'Title': 'Regular expression for the strings without a particular substring', 'LastEditorUserId': '6980', 'LastActivityDate': '2014-01-31T12:46:01.967', 'LastEditDate': '2014-01-31T12:46:01.967', 'AnswerCount': '4', 'CommentCount': '7', 'AcceptedAnswerId': '11791', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-05-04T23:46:05.660', 'Id': '11787'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am converting NFA <b>with $\\varepsilon$-moves </b> to the NFA <b>without </b> $\\varepsilon$-null moves. I understand that if, there is a $\\varepsilon$-move between, $q_i$ and $q_j$, then all edges from $q_j$ have to be repeated from $q_i$. And if the $q_j$ is a final state, then $q_i$ will also be a final state.</p>\n\n<p>But, if $q_j$ does not contain any transition, i.e., there are no edges starting from $q_j$, then what has to be done? </p>\n', 'ViewCount': '673', 'Title': 'How to convert NFA with null moves to NFA without null moves?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-05-16T16:06:25.040', 'LastEditDate': '2013-05-14T06:58:57.550', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8155', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-05-14T05:56:21.350', 'Id': '12003'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Where can I find a proof of this? Thanks!</p>\n', 'ViewCount': '918', 'Title': 'Proof that the regular languages are closed under string homomorphism', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-10-03T14:16:12.663', 'LastEditDate': '2013-05-16T02:20:15.170', 'AnswerCount': '3', 'CommentCount': '4', 'Score': '2', 'OwnerDisplayName': 'user16022', 'PostTypeId': '1', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-05-14T01:07:04.453', 'FavoriteCount': '2', 'Id': '12017'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was wondering when languages which contained the same number of instances of two substrings would be regular. I know that the language containing equal number of 1s and 0s is not regular, but is a language such as $L$, where $L$ = $\\{ w \\mid$ number of instances of the substring "001" equals the number of instances of the substring "100" $\\}$ regular? Note that the string "00100" would be accepted.</p>\n\n<p>My intuition tells me it isn\'t, but I am unable to prove that; I can\'t transform it into a form which could be pumped via the pumping lemma, so how can I prove that? On the other hand, I have tried building a DFA or an NFA or a regular expression and failed on those fronts also, so how should I proceed? I would like to understand this in general, not just for the proposed language.</p>\n', 'ViewCount': '249', 'Title': 'Is the language of words containing equal number of 001 and 100 regular?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-06-01T15:26:45.267', 'LastEditDate': '2013-05-30T23:55:28.277', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '8257', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-05-19T21:07:17.520', 'Id': '12139'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Question:The set of all first names given to children born in New Zealand in 1996</p>\n\n<p>I think this language is regular because every element in the set can be a accept state</p>\n\n<p>How can I prove if the language is regular?</p>\n', 'ViewCount': '65', 'Title': 'Regular language proving', 'LastEditorUserId': '157', 'LastActivityDate': '2013-05-25T00:56:19.277', 'LastEditDate': '2013-05-25T00:56:19.277', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8341', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-05-24T22:06:59.133', 'Id': '12256'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is it theoretically possible to have a nondeterministic finite state machine without any initial state or does it need at least one initial state?</p>\n', 'ViewCount': '122', 'Title': 'Nondeterministic finite state machine without any initial state possible', 'LastActivityDate': '2013-05-29T15:15:48.100', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '8414', 'Tags': '<formal-languages><regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2013-05-28T18:27:39.930', 'Id': '12338'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '171', 'Title': 'What does the R superscript notation mean in regular/formal languages?', 'LastEditDate': '2013-06-02T03:05:54.667', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8482', 'FavoriteCount': '1', 'Body': "<p>What does the capital R superscript notation mean in regular languages?  I am working on a homework assignment and don't recall my professor mentioning what the what the R superscript means.  For example in this syntax:</p>\n\n<p>$L = \\{ww^R\\mid w \\in \\Sigma^{\\ast} \\}$</p>\n", 'Tags': '<formal-languages><regular-languages><formal-grammars><notation>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-02T03:05:54.667', 'CommentCount': '0', 'AcceptedAnswerId': '12422', 'CreationDate': '2013-06-02T02:11:28.330', 'Id': '12421'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $L$ be a star-free language over finite alphabet $\\Sigma$.  A <em>substitution</em> will be a map $\\sigma : \\Sigma \\to \\mathcal{P}(\\Sigma^*)$.  It seems obvious that if $\\sigma(a)$ is star-free for every $a \\in \\Sigma$, then $\\sigma(L)$ will be star-free.<br>\n($\\sigma(L) = \\{ w_1 ... w_n | w_i \\in \\sigma(a_i) \\land a_1 \\ldots a_n \\in L \\}$)\nTake a star-free regular expression for $L$, and substitute star-free expressions for $L_i$\nfor each $a_i$ in that expression.  The result will still be a star-free expression.</p>\n\n<p>Now, my question is this: why is the following not a counterexample?\n$\\Sigma = \\{ 0, 1 \\}$. $L = 1^*$ and $\\sigma(1) = 0^* 1 0^* 1 0^*$.\nBoth of these languages are star-free:\n$L = L( (\\emptyset^c 0 \\emptyset^c )^c )$ and similar tricks can be given to show that $\\sigma(1)$ is star-free.</p>\n\n<p>Now, the reason it seems like a counterexample: a word in $L$ contains only 1s. The substitution replaces each 1 with a word from a language whose words contain exactly 2 1s.\nSo won't $\\sigma(L)$ be the set of words with an even number of 1s, which is known to be non-star-free?</p>\n\n<p>(Note: my proof suggestion of closure under substitution is a bit sketchy.  The star-free expression for $1^*$ only has 0s in it.  But I could then substitute \nthe star-free expression for $\\sigma(1)$ under a complement, no?)</p>\n", 'ViewCount': '78', 'Title': 'Closure of Star-Free Languages under Substitution', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:40:43.930', 'LastEditDate': '2013-06-10T09:40:43.930', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12550', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8590', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-06-08T21:54:25.707', 'Id': '12546'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Or at least generate a set of strings that one NFA accepts, so I can feed it into the other NFA.  If I do a search through every path of the NFA, will that work?  Although that will take a long time.</p>\n', 'ViewCount': '149', 'Title': 'Is there a way to test if two NFAs accept the same language?', 'LastActivityDate': '2013-06-11T18:47:24.080', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '12625', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '8184', 'Tags': '<algorithms><regular-languages><finite-automata>', 'CreationDate': '2013-06-11T17:23:26.430', 'FavoriteCount': '1', 'Id': '12624'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>It is known that the language of words containing equal number of 0 and 1 is not regular, while the language of words containing equal number of 001 and 100 is regular (<a href="http://cs.stackexchange.com/questions/12139/is-the-language-of-words-containing-equal-number-of-001-and-100-regular">see here</a>).</p>\n\n<p>Given two words $w_1,w_2$, is it decidable if the language of words containing equal number of $w_1$ and $w_2$ is regular?</p>\n', 'ViewCount': '255', 'Title': 'Is it decidable if a language described by number of occurences is regular?', 'LastActivityDate': '2013-06-21T05:51:58.577', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '667', 'Tags': '<regular-languages><undecidability>', 'CreationDate': '2013-06-17T16:24:02.703', 'FavoriteCount': '1', 'Id': '12718'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '141', 'Title': 'Are HTML and CSS regular languages?', 'LastEditDate': '2013-06-24T17:18:01.450', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8839', 'FavoriteCount': '1', 'Body': '<p>I have a question whether or not CSS and HTML are regular languages.</p>\n\n<p>I believe CSS is a regular language, since it should be possible to create a regular expression to match the structure of CSS.</p>\n\n<p>However, I believe that HTML is <strong>not</strong> a regular language since you have nested attributes that could be defined recursively.</p>\n', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-06-24T17:18:01.450', 'CommentCount': '7', 'AcceptedAnswerId': '12869', 'CreationDate': '2013-06-24T14:45:41.140', 'Id': '12867'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Given $m,n\\in\\mathbb{N}$, finite alphabet $A=\\{a,b,c\\}$, and $L=\\{(a^m,a^n)\\}^*=\\{(a^{mk},a^{nk})|k\u2208N\\}\\subseteq A^*\\times A^*$. \nIs this binary language $L$ regular over $A(2,\\$)$ (i.e. $\\{A\u222a\\{\\$\\}\\}\\times \\{A\u222a\\{\\$\\}\\}\\setminus \\{\\$,\\$\\}$)? </p>\n\n<p>For example, is this binary language $L=\\{(a^3,a^7)\\}^*=\\{(a^{3k},a^{7k})|k\u2208N\\}=\\{(a^3,a^7),(a^6,a^{14}),(a^{9},a^{21})(a^{12},a^{28})...\\}$ regular over $A(2,\\$)$?</p>\n\n<p>An illustration of the difference between binary regular language and unitary regular language: Let $L=\\{(w,w')\\mid w\\in L^1,w'\\in L^2\\text{, and }L^1,L^2\\text{ are  unitary  languages}\\}$ be a binary language, the length of $w$ and $w'$ maybe not all the same (suppose some $|w|&gt;|w'|$). Firstly, we must add \\$'s behind $w'$ such that all $|w|=|w'\\$...|$, then we get a new language $L^{\\$}$. And we will say $L$ is regular if and only if $L^{\\$}$ is regular (i.e. there is exist a finite binary automaton to recognize $L^{\\$}$).</p>\n\n<p>And if the binary language $L$ can be showed as finite regular binary languages with the operations: union, intersection, complement, concatenation, $L$ is also regular.</p>\n", 'ViewCount': '161', 'Title': 'Binary regular language?', 'LastEditorUserId': '8880', 'LastActivityDate': '2013-06-28T06:31:56.503', 'LastEditDate': '2013-06-26T13:51:18.613', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '8880', 'Tags': '<regular-languages><automata>', 'CreationDate': '2013-06-26T06:36:30.927', 'FavoriteCount': '0', 'Id': '12906'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Could anyone help me please to find who was the first person who has proved that the language of all borderless words is not regular and when was that? Could you mention the reference, please?</p>\n\n<p>A word $w$ has a border $u$ if $u$ is both prefix and suffix of $w$ (and $u$ does not equal $\\lambda$ or $w$). </p>\n', 'ViewCount': '75', 'Title': 'The language of all borderless words', 'LastEditorUserId': '4287', 'LastActivityDate': '2013-07-04T08:10:49.713', 'LastEditDate': '2013-07-02T13:59:18.573', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8954', 'Tags': '<regular-languages><pumping-lemma><word-combinatorics>', 'CreationDate': '2013-07-02T10:05:46.077', 'Id': '13035'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I solve $\\mathcal{O}$-notations without using Java or any other programming language?</p>\n\n<p>I only want to use pen and paper.</p>\n', 'ViewCount': '325', 'ClosedDate': '2013-07-17T09:17:35.527', 'Title': "How to do Big 'O' notations", 'LastEditorUserId': '16189', 'LastActivityDate': '2014-03-27T17:04:35.730', 'LastEditDate': '2014-03-27T17:04:35.730', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '9210', 'Tags': '<algorithms><formal-languages><terminology><regular-languages><asymptotics>', 'CreationDate': '2013-07-17T05:51:43.213', 'Id': '13305'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For a language L we define:  </p>\n\n<p>$\\qquad A(L) = \\{ x \\in L \\mid \\text{ no proper prefix of x is in L} \\} $</p>\n\n<p>Are regular / context free languages closed under this operation ?</p>\n\n<p>For regular languages I thought about taking the DFA that accepts the language L and create a new NFA by making all accepting states sinks (so the only way of being accepted by the automata is that when reading the last letter we reach an accepting state for the first time).</p>\n\n<p>Can't we make the same thing with a pushdown automata for context free languages ?</p>\n\n<p>Edit (as Raphael pointed out, the example below is wrong):</p>\n\n<p>But here is a strange language that I think implies the opposite:<br>\n$L = \\{ 0^{i}1^{j}2^{n} \\mid i \\le n \\ \\text{ or }\\ j \\le n \\} $<br>\n$A(L) = \\{ 0^{i}1^{j}2^{n} \\mid n = \\min(i,j) \\} $</p>\n\n<p>$L$ is context free but $A(L)$ isn't. Obviously, at least one of the things I wrote above is wrong. Anyone have any clue what is going on here ?</p>\n", 'ViewCount': '404', 'Title': 'Are regular and context free languages closed against making them prefix-free?', 'LastEditorUserId': '7068', 'LastActivityDate': '2013-07-22T19:55:09.470', 'LastEditDate': '2013-07-22T18:20:01.553', 'AnswerCount': '2', 'CommentCount': '7', 'AcceptedAnswerId': '13389', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7068', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'CreationDate': '2013-07-22T13:54:58.530', 'Id': '13388'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Recently an interesting question was asked and subsequently deleted.</p>\n\n<p>For a regular language $L$, its <em>DFA complexity</em> is the size of the minimal DFA accepting it, and its <em>NFA complexity</em> is the size of the minimal NFA accepting it. It is well-known that there is an exponential separation between the two complexities, at least when the size of the alphabet is unbounded. Indeed, consider the language $L_n$ over the alphabet $\\{1,\\ldots,n\\}$ consisting of all words <em>not</em> containing all symbols. Using the Myhill-Nerode theorem it is easy to calculate the DFA complexity $2^n$. On the other hand, the NFA complexity is only $n$ (if multiple initial states are allowed; otherwise it is $n+1$).</p>\n\n<p>The deleted question concerned the <em>DFA covering complexity</em> of a language, which is the minimal $C$ such that $L$ can be written as the (not necessarily disjoint) union of languages of DFA complexity at most $C$. The DFA covering complexity of $L_n$ is only $2$.</p>\n\n<blockquote>\n  <p>Is there an exponential separation between NFA complexity and DFA covering complexity?</p>\n</blockquote>\n', 'ViewCount': '108', 'Title': 'Exponential separation between NFAs and DFAs in the presence of unions', 'LastActivityDate': '2013-07-27T11:42:51.633', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '13465', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '683', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-07-27T11:42:51.633', 'Id': '13464'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is a practice problem for a midterm in a class I'm taking:</p>\n\n<blockquote>\n  <p>Given a regular language $L$, describe formally a Turing machine that recognize $L$. </p>\n</blockquote>\n\n<p>I'm not sure how I should do that.</p>\n", 'ViewCount': '440', 'Title': 'How can a Turing Machine recognize a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T15:30:56.463', 'LastEditDate': '2013-07-30T10:26:40.687', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<turing-machines><regular-languages><automata><finite-automata><simulation>', 'CreationDate': '2013-07-29T19:45:40.207', 'Id': '13500'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '22', 'Title': 'Complement of non-deterministic finite automation', 'LastEditDate': '2013-08-02T15:20:44.810', 'AnswerCount': '0', 'Score': '2', 'OwnerDisplayName': 'Unni', 'PostTypeId': '1', 'FavoriteCount': '0', 'Body': u'<p>Given an NFA, is there a way to \u201ctake its complement\u201d and obtain an NFA that recognizes the complement language?</p>\n', 'ClosedDate': '2013-08-04T23:26:34.703', 'Tags': '<regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-02T15:20:44.810', 'CommentCount': '2', 'CreationDate': '2013-07-15T06:12:30.940', 'Id': '13572'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '218', 'Title': 'Finding maximal factorization of regular languages', 'LastEditDate': '2013-08-10T18:28:15.740', 'AnswerCount': '1', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1382', 'FavoriteCount': '3', 'Body': u"<p>Let language $\\mathcal{L} \\subseteq \\Sigma^*$ be regular.</p>\n\n<p>A factorization of $\\mathcal{L}$ is a maximal pair $(X,Y)$ of sets of words with</p>\n\n<ul>\n<li>$X \\cdot Y \\subseteq \\mathcal{L}$</li>\n<li>$X  \\neq \\emptyset \\neq Y$,</li>\n</ul>\n\n<p>where $X \\cdot Y = \\{xy$ | $x \\in X, y \\in Y\\}$.</p>\n\n<p>$(X,Y)$ is maximal if for each pair $(X',Y') \\neq (X,Y)$ with $X'\\cdot Y' \\subseteq \\mathcal{L} $ either $X \\not \\subseteq X'$ or $Y \\not \\subseteq Y'$.</p>\n\n<p>Is there a simple procedure to find out which pairs are maximal?</p>\n\n<p>Example:</p>\n\n<p>Let $\\mathcal{L} = \\Sigma^\u2217ab \\Sigma^\u2217$. The set $F = \\{u, v, w\\}$ is computed: </p>\n\n<ul>\n<li><p>$u =(\\Sigma^\u2217, \\Sigma^\u2217ab\\Sigma^\u2217)$</p></li>\n<li><p>$v = (\\Sigma^\u2217a\\Sigma^\u2217, \\Sigma^\u2217b\\Sigma^\u2217)$</p></li>\n<li><p>$w = (\\Sigma^\u2217ab\\Sigma^\u2217, \\Sigma^\u2217) $</p></li>\n</ul>\n\n<p>where $\\Sigma = \\{a,b\\}$.</p>\n\n<p>Another example:</p>\n\n<p>$\\Sigma = \\{a, b\\}$ and $\\mathcal{L} = \\Sigma^*a\\Sigma$\nFactorization set $F = \\{q, r, s, t\\}$ with</p>\n\n<ul>\n<li><p>$q = (\\Sigma^*, \\mathcal{L})$</p></li>\n<li><p>$r = (\\Sigma^*a, \\Sigma + \\mathcal{L})$</p></li>\n<li><p>$s = (\\Sigma^*aa, \\epsilon + \\Sigma + \\mathcal{L})$</p></li>\n<li><p>$t = (\\mathcal{L}, \\epsilon + \\mathcal{L}) $</p></li>\n</ul>\n", 'Tags': '<algorithms><regular-languages><optimization>', 'LastEditorUserId': '755', 'LastActivityDate': '2013-08-12T07:32:56.617', 'CommentCount': '9', 'AcceptedAnswerId': '13713', 'CreationDate': '2013-08-05T16:12:02.770', 'Id': '13617'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am looking for references for the following problem: \nI have a very special class of regular languages and my aim is to express (and to justify my conjecture) that this class itself is very small in some way (as a subset of the regular languages) and that the languages contained in this class are rather "bloated". </p>\n\n<p>For the latter point, I could prove that all languages in the class have a large diameter with respect to many common metrics on strings. However, I want to consider the following: Given a language from the class, we know it has a large diameter, but does it also have a large "volume" (that is, measure), or put differently, if I choose randomly a finite word, is there anything meaningful to say about how "probable" it is that the word belongs to the language? Of course, we can lift the problem: Picking a random language, how probable is it to get a language in the class?</p>\n\n<p>Are there any references or standard approaches for looking at classes of (regular) languages from this point of view (or is this considered as generally uninteresting)?</p>\n', 'ViewCount': '113', 'Title': 'Measures and probability in formal language theory', 'LastActivityDate': '2013-08-07T07:33:27.500', 'AnswerCount': '2', 'CommentCount': '11', 'AcceptedAnswerId': '13652', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><regular-languages><probability-theory>', 'CreationDate': '2013-08-06T12:18:54.883', 'FavoriteCount': '1', 'Id': '13631'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For my Bachelor\'s thesis, I consider the class of languages recognized by symmetrical DFAs, that is, deterministic (complete) finite automata satisfying the following condition: </p>\n\n<p>Let $A$ be a complete DFA over the alphabet $\\Sigma$. If, for every $a\\in \\Sigma$ and every transition $u \\stackrel{a}{\\longrightarrow}v$ in $A$, there is a transition $v \\stackrel{a}{\\longrightarrow}u$ in $A$, we call $A$ a <em>symmetrical</em> DFA (<em>SDFA</em>). If $A$ is not complete, we call it a <em>partial</em> SDFA. We can regard an SDFA as an undirected, labeled graph in a natural way. </p>\n\n<p>I could find an algebraic characterization of the class of languages recognized by (complete as well as partial) SDFAs and deduce some closure properties. However, neither me nor my supervisor are aware of previous results concerning this particular class of regular languages (barring results like Reingold\'s $\\mathsf{SL = L}$ which might seem related). </p>\n\n<p>Motivated by a <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory?noredirect=1#comment29176_13631">comment</a> that J.-E. Pin passed on <a href="http://cs.stackexchange.com/questions/13631/measures-and-probability-in-formal-language-theory">a related question I asked</a>, my question is now:</p>\n\n<blockquote>\n  <p>Are there results concerning these automata?</p>\n</blockquote>\n', 'ViewCount': '130', 'Title': 'Results on the languages recognized by undirected DFAs', 'LastActivityDate': '2013-08-16T06:31:23.137', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13760', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '7486', 'Tags': '<formal-languages><reference-request><regular-languages><finite-automata>', 'CreationDate': '2013-08-15T10:27:23.167', 'Id': '13759'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If the set of regular languages is closed under the concatenation operation and is also closed under the reverse operation ($x^R$ is the reverse of $x$) then is the language generated by $$\\{ww^R|w\\in\\Sigma^*\\}$$ for some input alphabet $\\Sigma$, also regular? If not, why not?</p>\n\n<p>I've been trying to find a proof for this using the pumping lemma, but it seems that selecting any substring towards the middle of the string being pumped could also be of the form $\\{ww^R|w\\in\\Sigma^*\\}$, causing the original string to remain in its original form.</p>\n\n<p>Here's a try:</p>\n\n<p>$\\textbf{Theorem:}$ The language, $A$, generated by $\\{ww^R|w\\in\\Sigma^*\\}$ is not regular.</p>\n\n<p>$\\textbf{Proof:}$ Assume $A$ is regular (We will use the Pumping Lemma for Regular Languages to show a contradiction). Let the input string $s$ be $ww^R$ and let $p = |w|$.</p>\n\n<p>When splitting $s$ into substrings $x, y, z$ such that $s=xyz$ we see that $xy$ must be a substring of $w$ by the third condition of the Pumping Lemma ($|xy|\\le p$).</p>\n\n<p>By the first condition of the Pumping Lemma, we see that all strings of the form $xy^iz$ must be in $A$ for all $i \\ge 0$. Taking $i$ to be zero, we obtain the string $xw^R$. $|x| &lt; |w^R|$ so $xy^0z \\notin A$.</p>\n\n<p>QED? What if $xw^R$ can still be split so that for some substring $k$, $kk^R = xw^R$?</p>\n\n<p>I think I may be overthinking this but it's really bugging me.</p>\n", 'ViewCount': '629', 'Title': 'Is the language that accepts strings concatenated with their reverse regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T20:59:40.083', 'LastEditDate': '2013-08-22T14:52:13.693', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '13806', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9727', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2013-08-18T21:36:02.120', 'Id': '13804'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I do not understand the proof for this. I know that every word in $(A^*)^*$ is made up of words from $A^*$, and that this is made up from words in $A$. But how does this help with showing that $(A^*)^*$ is a subset of $A^*$.</p>\n', 'ViewCount': '84', 'Title': 'Show that A** subset of A*, where A is a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-26T13:32:58.017', 'LastEditDate': '2013-08-26T08:27:54.990', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '13919', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-08-25T02:20:16.007', 'Id': '13918'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>For a language to be regular it needs to be recognized by DFA/NFA.</p>\n\n<p>Let $L = \\{ xy^rzyx^r \\mid |x| , |y|, |z| \\ge 1 \\}$ over the alphabet $\\{0,1\\}$.</p>\n\n<p>$x^r$ means the reverse of $x$.</p>\n\n<p>A DFA has no memory, so how can it handle the reverse check?</p>\n', 'ViewCount': '126', 'Title': 'Why is this language involving reversal regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T10:48:00.090', 'LastEditDate': '2013-08-27T10:48:00.090', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '13959', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9851', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-08-27T07:32:03.760', 'Id': '13956'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If you could include your thought process in determining why it's regular it would help me a lot.</p>\n\n<ul>\n<li><p>$L_1 = (0^*(10)^*11)$</p></li>\n<li><p>$L_2 = \\{ \\langle M \\rangle \\mid M \\text{ is a Turing machine that halts on all inputs from }L_1 \\}$</p></li>\n<li><p>$L_3 = \\{ x \\in \\{0,1\\}^* \\mid \\exists y \\in L_2. xy \\in L_1 \\}$</p></li>\n</ul>\n\n<p>Why is $L_3$ regular? It's a set of strings, I need to determine if there's a DFA that can accept it. Do I even care about $L_2$ and $L_1$ in this case?</p>\n", 'ViewCount': '99', 'Title': 'Why is this language regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-27T11:33:04.927', 'LastEditDate': '2013-08-27T11:19:56.530', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '13971', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9844', 'Tags': '<formal-languages><computability><regular-languages>', 'CreationDate': '2013-08-27T08:42:44.590', 'Id': '13960'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><em>This is a homework question, so I am only looking for hints.</em></p>\n\n<p>I got a question in an assignment which states :</p>\n\n<blockquote>\n  <p>Design a DFA that accepts strings having 1 as the 4th character from the end, on the alphabet {0,1}</p>\n</blockquote>\n\n<p>I have been at this for a few hours now, and I think that designing such a DFA is not possible. However, I am not sure how to move forward in this direction to write up a somewhat formal proof. </p>\n\n<p>So, what should I try to do to prove or disprove my hypothesis?</p>\n', 'ViewCount': '1136', 'Title': 'Designing a DFA that accepts strings such that nth character from last satisfies condition', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-29T22:28:11.637', 'LastEditDate': '2013-08-29T14:39:17.470', 'AnswerCount': '4', 'CommentCount': '3', 'AcceptedAnswerId': '14021', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2044', 'Tags': '<formal-languages><regular-languages><finite-automata>', 'CreationDate': '2013-08-29T01:49:33.573', 'Id': '14008'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given a regular language $L$ over a unary alphabet $\\Sigma = \\{ a \\}$.</p>\n\n<p>How to decide whether there are two words $w,w' \\in L$ such that\nthe length of $w$ is relatively prime to the length of $w'$ ?</p>\n", 'ViewCount': '146', 'Title': 'Finding two words of lengths that are relatively prime in a regular language?', 'LastActivityDate': '2013-09-03T18:53:48.563', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9963', 'Tags': '<regular-languages><finite-automata><decision-problem>', 'CreationDate': '2013-09-03T16:03:03.457', 'Id': '14106'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to figure out the result of the concatenation among different language types (regular, context free, ...). I think the result strongly depends on the nature of the languages which will be concatenated, but I have some doubts on determining the category the result belongs to. Maybe troughout an example it will be easier to solve all my doubts and let you understand better the nature of my question. For instance, let $L = \\left \\{ 0^{n}\\cdot 1^{n} \\mid n \\geq 0 \\right \\}$ and $L^{R} = \\left \\{ 1^{n}\\cdot 0^{n} \\mid n \\geq 0 \\right \\}$</p>\n\n<p>Those two languages are obviosly not regular (it's easy to apply the Pumping Lemma here)\nbut what happens if I define this result language $L{}' = L \\cdot \\left \\{ 0, 1 \\right \\}^{*} \\cdot L^{R}$</p>\n\n<p>I think it should be still not regular, since we can apply again the pumping lemma by letting be $p$ the length of the pumping and $w=0^{p}1^{2p}0^{p}$, w is in $L'$. The contination is easily.</p>\n\n<p>But is it good to consider that w of $L'$? </p>\n", 'ViewCount': '56', 'Title': 'Concatenation among different language types', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-06T09:50:31.623', 'LastEditDate': '2013-09-06T08:52:51.910', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9989', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2013-09-05T11:29:43.487', 'Id': '14145'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '299', 'Title': 'Determine if this language is regular', 'LastEditDate': '2013-09-06T16:06:37.390', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '9819', 'FavoriteCount': '1', 'Body': "<p>Let $L = \\{xyx \\mid \\text{ for some }x,y \\in \\{0,1\\}^+\\}$. Is this language regular?</p>\n\n<p>So I was trying to construct a DFA, but I don't how to do this with this language.</p>\n", 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-06T16:06:37.390', 'CommentCount': '4', 'AcceptedAnswerId': '14170', 'CreationDate': '2013-09-06T01:42:17.333', 'Id': '14159'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Part (a): Let $L = \\{x \\in \\{0,1\\}^* \\mid  \\#0(x) \\neq 4\\times\\#1(x)\\}$, where $\\#0(x)$ means the number of 0 in string $x$ and $\\#1(x)$ means the number of 1 in string $x$.</p>\n\n<p>So I want to use the pumping lemma. But I'm having a hard time choosing a string so that I can show that it is not regular.</p>\n\n<p>I've been thinking about how I could use something like the string, s, = $0^{3p}1^p$. But I do not see how you use that fact (I would like to show that xyyz would equal $0^{4p}1^p$). This route seems unfruitful. So any help would be nice.</p>\n\n<p>Part (b): Let $L = \\{x \\in \\{0,1\\}^* \\mid \\exists k \\in \\mathbb{N}, \\#0(x) + \\#1(x) = 2k\\}$. </p>\n\n<p>Again stuck on this problem. My original approach was to leverage the fact that the parity is the same on the 0s and 1s (if one is even, then so does the other and vice versa. Same for odd parity.)</p>\n\n<p>Again, this does not seem to be working.</p>\n", 'ViewCount': '142', 'Title': 'Decide if L is regular or not and argue it. Trying to use Pumping Lemma', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-10T14:22:35.517', 'LastEditDate': '2013-09-09T10:25:55.990', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '14182', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9819', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-09-07T01:03:54.217', 'Id': '14180'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we have some regular language $L$, then can we say that $$L_{half} = \\{w : \\text{for some } z \\in L, x \\in \\Sigma^*, z = wx \\wedge |w| = |x| \\} $$ \nis also regular? </p>\n\n<p>I have a 'feeling' that it is, but I can't sketch a proof for it.</p>\n", 'ViewCount': '119', 'ClosedDate': '2013-09-09T10:16:05.103', 'Title': 'Is $L_{half} = \\{w : \\text{for some } z \\in L, x \\in \\Sigma^*, z = wx \\wedge |w| = |x| \\} $ regular?', 'LastActivityDate': '2013-09-07T15:07:27.570', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14195', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<regular-languages><automata>', 'CreationDate': '2013-09-07T13:40:56.200', 'Id': '14192'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've come across this problem in my studies, and I've abstracted it to the more general case here.</p>\n\n<p>Given a finite alphabet, what is a regular expression that matches all strings over the alphabet, except one particular finite substring?</p>\n\n<p>As an example:</p>\n\n<p>Given $\\Sigma = \\{a, b, c\\}$</p>\n\n<p>What is a regular expression that matches all of $\\Sigma$ except the substring $\nba$?</p>\n\n<p>What I really want is simply $\\Sigma^* - ba$. </p>\n", 'ViewCount': '594', 'Title': 'What is a regular expression that matches all strings over the alphabet except a particular substring?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T15:00:48.047', 'LastEditDate': '2013-09-16T07:17:29.020', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10092', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-09-12T02:24:16.167', 'Id': '14274'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '184', 'Title': 'Prove or disprove whether L is regular', 'LastEditDate': '2013-09-16T08:18:17.317', 'AnswerCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Body': "<p>Let $\\Sigma = \\{0,1\\}$. For every word $w \\in \\Sigma^*$, let $|w|_0$ and $|w|_1$ denote the count of 0's and 1's, respectively, in $w$. Let $L$ be the language\n$$L = \\{ w \\in \\Sigma^* \\mid |w|_0 \\gt |w|_1 + 2 \\text{ or } |w|_1 \\gt |w|_0 + 2\\}$$\nProve or disprove whether $L$ is regular.</p>\n", 'ClosedDate': '2013-09-16T08:21:43.223', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T08:18:17.317', 'CommentCount': '2', 'AcceptedAnswerId': '14324', 'CreationDate': '2013-09-15T06:14:55.630', 'Id': '14323'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Given languages X, Y and Z, each with alphabet, define X/Y/Z \n as:</p>\n\n<pre><code>     X/Y/Z = { w \u2208 \u03a3* | \u2203u \u2208 Y and \u2203v \u2208 Z; such that wuv \u2208 X }.\n</code></pre>\n\n<p>Prove that if X is context-free, and Y and Z are regular, then X/Y/Z\nis context-free.</p>\n', 'ViewCount': '140', 'Title': 'Prove that X/Y/Z is context-free', 'LastActivityDate': '2013-09-16T15:40:05.847', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2013-09-15T12:23:15.787', 'FavoriteCount': '0', 'Id': '14333'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Suppose I have a DFA recognizing a regular language $L$, how do I prove that \n$$\\text{lefthalf}(L)= \\{ w_1 \\mid \\exists w_2 \\in \\Sigma^* ,w_1w_2 \\in L \\land \\|w_1\\| = \\|w_2\\| \\}$$ is also a regular language?</p>\n', 'ViewCount': '86', 'ClosedDate': '2013-09-18T09:23:28.010', 'Title': 'Proving that a derived language is regular', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-18T09:19:49.913', 'LastEditDate': '2013-09-18T09:19:49.913', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10191', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-09-18T03:02:09.353', 'Id': '14397'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to learn about applying the pumping lemma and I'm not really sure how to go about proving this language isn't regular with the pumping lemma:</p>\n\n<p>$L= \\{0^n 1^m \\space | \\space m \\equiv 0 \\space mod \\space n, \\space n \\geq 2 \\}$</p>\n\n<p>Now I realize that the condition $m \\equiv 0 \\space mod \\space n$, is essentially saying that $m$ is some multiple of $n$. Is it possible that could you go about proving that $L$ is not regular in the way that you can prove that $L = \\{0^n 1^n\\}$ is not regular since $m$ is a multiple of $n$, since $m = kn$ (where $k$ is some integer)?</p>\n\n<p><em><strong>Updated:</em></strong></p>\n\n<p>-- My attempt at the proof:</p>\n\n<p>If the language $L$ is regular, then by the pumping lemma $\\exists \\space p \\space | \\space \\forall s \\in L \\cap \\Sigma ^{\\geq p}  $.</p>\n\n<p>Next by the pumping lemma $\\exists x, y, z : s = xyz$, where $s$ is a string such that:</p>\n\n<p>(1) $|y|\\geq1$</p>\n\n<p>(2) $|xy|\\leq p$</p>\n\n<p>(3) $\\forall i\\geq0, xy^iz \\in L$</p>\n\n<p>Now suppose we let $m = kp$, where $k$ is some integer, let the string $s = 0^p 1^{kp}, s\\in L$ and $|s|\\geq p$. By the pumping lemma the decomposition of $s$ is defined by $s = xyz$. Now we show that $\\forall x, y, z$ that (1)-(3) do not hold.</p>\n\n<p>If (1) and (2) hold, then $s=0^p1^{kp} = xyz$, with $|xy|\\leq p$ and $|y|\\geq 1$.</p>\n\n<p>So $x = 0^u, y=0^v, z=0^w1^{kp}$</p>\n\n<p>$u+v \\leq p$, $v \\geq 1 $, $w \\geq 0$</p>\n\n<p>$u+v+w = kp$</p>\n\n<p>But (3) fails for $i=2$ since $xy^2z = 0^u0^v0^v0^w1^{kp} = 0^{u+2v+w}1^{kp} \\not\\in L$ since $u+2v+w \\neq kp $</p>\n\n<p>Hence $L$ is <em>not</em> a regular language.</p>\n\n<p>Is this the correct way to go about this proof?</p>\n", 'ViewCount': '347', 'Title': 'Proving the language $L= \\{0^n 1^m \\space | \\space m \\equiv 0 \\space mod \\space n, \\space n \\geq 2 \\}$ is not regular using the pumping lemma', 'LastEditorUserId': '9912', 'LastActivityDate': '2013-09-20T21:10:22.973', 'LastEditDate': '2013-09-20T21:10:22.973', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '14454', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9912', 'Tags': '<regular-languages><proof-techniques><pumping-lemma>', 'CreationDate': '2013-09-19T23:03:21.863', 'Id': '14453'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is the question I am asked and I am currently proving it using proof by contradiction something like this:</p>\n\n<ul>\n<li>Let's take some language <strong>L</strong> which is non regular.</li>\n<li>Let's assume compliment of L i.e. $(L^c)$ is regular.</li>\n<li><p>Since we know that regular languages are closed under complementation, complementation of $(L^c)$, i.e. $(L^c)^c$ must be regular.</p></li>\n<li><p>Now  $(L^c)^c$ is  $L$ means $L$ is regular which contradicts the assumption.</p></li>\n<li>So, our assumption that $L^c$ is regular must be false.</li>\n<li>Hence, we can prove that $L^c$ is not regular.</li>\n</ul>\n\n<p>Is this a correct approach to deduce?</p>\n\n<p>Using same result I have to state true/false for the following two statements and support by giving proof.</p>\n\n<ul>\n<li><p>The class of non regular languages is closed under union.</p></li>\n<li><p>The class of non regular languages is closed under intersection.</p></li>\n</ul>\n\n<p>How do I solve these two statements using the result above? Any hints would be helpful.</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '1158', 'Title': 'Is the class of non regular languages is closed under complementation?', 'LastActivityDate': '2013-09-20T07:45:16.030', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10086', 'Tags': '<regular-languages><closure-properties>', 'CreationDate': '2013-09-20T07:45:16.030', 'Id': '14462'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>An NFA $M$ contains a cycle if there is a state $q$ and a string $x$ such that if $M$ is in state $q$ and reads string $x$, $M$ can return to state $q$. Prove:</p>\n\n<p>If $M$ recognizes an infinite language, then $M$ has a cycle.</p>\n', 'ViewCount': '66', 'ClosedDate': '2013-09-23T07:30:02.960', 'Title': 'If $M$ recognizes an infinite language, then $M$ has a cycle', 'LastActivityDate': '2013-09-23T00:43:28.777', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2013-09-23T00:42:55.103', 'Id': '14541'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In my descriptive complexity class, we've been asked to find a formula that characterises the language $(aa)^*$ (over the alphabet $\\{a\\}$) with a first order formula over the language $\\{&lt;, P_a\\}$.</p>\n\n<p>This was the first class, so I will recall what we've learned to be sure that I understood. To a $L$-formula $\\phi$ we associate a language $\\mathcal L(\\phi)$ which is the class of all $L$-structures in which $\\phi$ is valid.</p>\n\n<p>In my case, we then are looking for a $\\{&lt;, P_a\\}$-formula for which words of even length are models. I guess I have to say in $\\phi$ that $&lt;$ is a total order, so that I can interpret the models as words, and that $\\forall x, P_a(x)$ to say that all points are labelled as 'a'. But how to say that there has to be an even number of points in the model? The definition of having an even number of points seems recursive, so I get the impression that a formula for $(aa)^*$ should be of infinite length in first-order logic..</p>\n", 'ViewCount': '115', 'Title': 'Characterising $(aa)^*$ in first order logic', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-23T11:22:12.363', 'LastEditDate': '2013-09-23T07:23:27.313', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '14548', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '10157', 'Tags': '<formal-languages><regular-languages><logic><first-order-logic>', 'CreationDate': '2013-09-23T06:16:13.087', 'Id': '14545'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>$L = \\{ \\langle M \\rangle \\mid \\text{there is at least one input string on which the \\(M\\) does not halt} \\}$</p>\n\n<p>Here, for a Turing machine $M$, the notation $\\langle M \\rangle$ denotes an encoding, over some alphabet, of the code of the Turing machine. To which of the following language classes does $L$ belong?</p>\n\n<ol>\n<li>Regular.</li>\n<li>Context-free but not Regular.</li>\n<li>Recursive but not Context-free.</li>\n<li>Recursively enumerable but not recursive.</li>\n<li>Not recursively enumerable.</li>\n</ol>\n', 'ViewCount': '145', 'Title': 'Class of the language of Turing machines that loop on at least one input', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-26T10:10:34.713', 'LastEditDate': '2013-09-26T10:10:34.713', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10145', 'Tags': '<regular-languages><turing-machines><turing-completeness>', 'CreationDate': '2013-09-26T02:21:15.667', 'FavoriteCount': '1', 'Id': '14615'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am currently studying the pumping lemma for regular languages and I am trying to come up with an example where even if the language can be pumped it is not regular. \nWhich condition of the lemma should be broken such that I can find a language like that?</p>\n', 'ViewCount': '37', 'ClosedDate': '2013-09-29T18:31:33.740', 'Title': 'Pumping a Language does not imply regular', 'LastEditorUserId': '39', 'LastActivityDate': '2013-09-28T12:01:23.383', 'LastEditDate': '2013-09-28T12:01:23.383', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10376', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2013-09-28T11:20:58.553', 'Id': '14653'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In some paper I read, </p>\n\n<blockquote>\n  <p>A theoretical worst case study shows that a single regular\n  expression of length $n$ can be expressed as an NFA with $O(n)$\n  states. When the NFA is converted into a DFA, it may generate\n  O($\\Sigma^n$) states. The processing complexity for each character in the inpuyt it $O(1)$ in a DFA, but is $O(n^2)$ for an NFA when all $n$ states are active at the same time.</p>\n</blockquote>\n\n<p>Please explain how NFA has at its maximum just $n$ states and its equivalent DFA has at most $O(\\Sigma^n)$ states?</p>\n', 'ViewCount': '92', 'Title': 'NFA and DFA storage cost', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-04T06:39:01.737', 'LastEditDate': '2013-10-04T06:39:01.737', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4624', 'Tags': '<regular-languages><automata><finite-automata><descriptive-complexity>', 'CreationDate': '2013-10-02T16:31:25.310', 'Id': '14755'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $\\Sigma$ and $\\Delta$ be alphabets. Consider a\nfunction $\\varphi: \\Sigma \\rightarrow \\Delta^*$. Extend $\\varphi$ to\na function from $\\Sigma^* \\rightarrow \\Delta^*$ such that:\n\\begin{eqnarray*}\n\\varphi(\\varepsilon) &amp; = &amp; \\varepsilon \\\\\n\\varphi(w\\sigma ) &amp; = &amp; \\varphi(w)\\varphi(\\sigma ), \\textrm{ for any }\nw \\in  \\Sigma ^*, \\sigma  \\in  \\Sigma\n\\end{eqnarray*}\nAny function $\\varphi:\\Sigma^* \\rightarrow \\Delta^*$ defined in this way\nfrom a function $\\varphi: \\Sigma \\rightarrow \\Delta^*$ is called a\n<strong>homomorphism</strong>. We can extend this definition to languages as follows:\nfor any language $L$ and homomorphism $\\varphi$, let \n$$\\varphi(L)=\\{\\varphi(w) : w\\in L\\}.$$</p>\n\n<p>Are regular languages are closed under inverse homomorphism?</p>\n', 'ViewCount': '381', 'Title': 'Are regular languages closed under inverse homomorphism?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-04T18:57:57.430', 'LastEditDate': '2013-10-04T18:57:57.430', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-10-03T14:21:55.540', 'Id': '14785'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to make a regular grammar for this language:</p>\n\n<p><img src="http://i.stack.imgur.com/obVZM.gif" alt="enter image description here"></p>\n\n<p>Where the alphabet is $ \\Sigma $ = $\\{a,b,c\\}$</p>\n\n<p>It seemed like it would go well with a right-linear grammar.  This may be disastrously wrong, but here\'s how I started:</p>\n\n<p>$S \\to aA$</p>\n\n<p>$A \\to aA | cB $</p>\n\n<p>$B \\to bC | C $</p>\n\n<p>$C \\to cD |$ $\\lambda$</p>\n\n<p>$D \\to cC$</p>\n\n<p>EDIT:\nCorrected for errors. Added $D$ for regular grammar.</p>\n', 'ViewCount': '71', 'Title': 'Making a regular grammar for this language', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-05T21:58:33.130', 'LastEditDate': '2013-10-05T21:58:33.130', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14836', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><regular-languages><formal-grammars>', 'CreationDate': '2013-10-05T19:10:54.813', 'Id': '14832'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to figure out how to build a regular expression for a language that doesn't contain strings that contain $101$ or $001$. The alphabet is defined as $\\{0, 1\\}$. I'm stuck on trying to figure out the DFA. Any help would be appreciated.</p>\n", 'ViewCount': '747', 'Title': 'Regular expression for a string not containing a set of substrings', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-10-31T15:35:25.667', 'LastEditDate': '2013-10-31T15:35:25.667', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '14838', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2013-10-05T20:26:40.050', 'Id': '14837'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>We define a <em>regular tree language</em> as in the book <a href="http://tata.gforge.inria.fr/" rel="nofollow">TATA</a>: It is the set of trees accepted by a non-deterministic finite tree automaton (Chapter 1) or, equivalently, the set of trees generated by a regular tree grammar (Chapter 2). Both formalisms hold close resemblances to the well-known string analogues.</p>\n\n<blockquote>\n  <p>Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?</p>\n</blockquote>\n\n<p>Obviously there are tree languages such that the height of a tree is linear in its size; and in the book <a href="http://algo.inria.fr/flajolet/Publications/books.html" rel="nofollow">Analytic Combinatorics</a> it is shown e.g. that binary trees of size $n$ have average height $2\\sqrt{ \\pi n}$. If I understand Proposition VII.16 (p.537) of the mentioned book correctly, then there is a wide subset of regular tree languages that have average height of $\\Theta(\\sqrt{n})$, namely those in which the tree language is also a <em>simple variety of trees</em> fulfilling some extra conditions.</p>\n\n<p>So I was wondering whether there is a regular tree language showing a different average height or if there is a true dichotomy for regular tree languages.</p>\n', 'ViewCount': '316', 'Title': 'Is there a regular tree language in which the average height of a tree of size $n$ is neither $\\Theta(n)$ nor $\\Theta(\\sqrt{n})$?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-10-18T08:11:24.593', 'LastEditDate': '2013-10-18T08:11:24.593', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '10734', 'Tags': '<formal-languages><regular-languages><combinatorics><trees><tree-grammars>', 'CreationDate': '2013-10-14T14:19:09.910', 'FavoriteCount': '4', 'Id': '16073'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m referring to regular expressions as language: \\begin{equation*}\n \\Sigma = \\{ ``a", ``b", ``(", ``)", ``*", ... \\}\n\\end{equation*} and \\begin{equation*}\n L = \\Sigma^* \\text{, which form a legal regular expression}\n\\end{equation*} I am not referring to their computational power. I did some research, but wasn\'t able to find anything relevant. Intuitively, I would imagine they\'re context-free, but am not sure how to attempt a proof.</p>\n\n<p>I am trying to use this as a lemma, so a reference, or recommendation for how to attempt a proof would be extremely helpful.</p>\n', 'ViewCount': '98', 'Title': 'Where in the Chomsky Hierarchy are Regular Expressions as a language?', 'LastActivityDate': '2013-10-15T19:40:06.070', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16110', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10596', 'Tags': '<formal-languages><reference-request><regular-languages>', 'CreationDate': '2013-10-15T19:28:55.387', 'Id': '16109'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$$ L = \\{a^ib^jc^k \\mid i,j,k &gt; 0 \\text{ and } i+k&gt;j\\} $$</p>\n\n<p>I say it's not regular. Proof by pumping lemma:\nFind a string $xy^iz$ that is not in $L$ (respecting the constraints).\nLet $w=x^py^pz^p$.</p>\n\n<p>Let $i=2$.\n$x^p(y^py^p)z^p$ is not in $L$. </p>\n\n<p>Thus $L$ is not regular.</p>\n\n<p>Is this proof correct?</p>\n", 'ViewCount': '204', 'Title': 'Is this pumping lemma proof correct?', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-16T00:28:05.830', 'LastEditDate': '2013-10-15T23:39:20.643', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '16116', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10713', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2013-10-15T23:21:45.640', 'Id': '16114'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m confused about a solution I saw about the following language not being regular:\\begin{equation*}\n  L=\\{0^n ~1 ~2^n : n &gt;0\\}\n\\end{equation*} The example solution said that $L$ was "the same as":\\begin{equation*}\n L\'=\\{0^n1^n : n &gt; 0 \\}\n\\end{equation*} so it wasn\'t regular. I understand why $L\'$ isn\'t regular, but I don\'t understand how $L$ is the same as $L\'$. How can you eliminate that middle symbol?</p>\n', 'ViewCount': '34', 'Title': 'Removing constant symbols from language to prove irregularity', 'LastActivityDate': '2013-10-16T01:41:14.637', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16124', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10596', 'Tags': '<regular-languages>', 'CreationDate': '2013-10-16T01:11:01.820', 'Id': '16122'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the non-deterministic finite automaton A: (in below figure)</p>\n\n<p><strong>1> convert this NFA to DFA</strong></p>\n\n<p><strong>2> Find if there are equivalent states of your DFA</strong></p>\n\n<p><strong>3> Minimize the DFA of &lt;2> if possible</strong></p>\n\n<p><img src="http://i.stack.imgur.com/t4wPn.png" alt="enter image description here"></p>\n\n<p>This is what i have got so far</p>\n\n<p><img src="http://i.stack.imgur.com/ifnyf.jpg" alt="enter image description here"></p>\n\n<p><img src="http://i.stack.imgur.com/vd5qh.png" alt="enter image description here"></p>\n\n<p><strong>4> further question: Prove that the DFA in &lt;3> recogniese the intended language L.</strong></p>\n\n<p>I got stuck on this question, since the language says that <strong>"every occurrence of a is preceded by and followed by an occurrence of b"</strong>\nthis means: </p>\n\n<p>L = {x bab)^n y |  x,y belongs to {b,empty}^n   where n is natural number}</p>\n\n<p>In this case: the language can be:   <strong>bbb.....bbbb bab ... bab bbb....bbbb</strong></p>\n\n<p>But for my &lt;3> DFA, the occurrence of a can appear without preceded by an occurrence of b.</p>\n\n<p>I hope if there is anyone can point out my mistake.</p>\n\n<p>many thanks</p>\n', 'ViewCount': '242', 'Title': 'DFA / NFA Regular Languages', 'LastEditorUserId': '10788', 'LastActivityDate': '2013-10-16T15:34:04.297', 'LastEditDate': '2013-10-16T15:34:04.297', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10788', 'Tags': '<regular-languages>', 'CreationDate': '2013-10-16T13:55:15.587', 'Id': '16137'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Show that every context-free language over a unary alphabet is regular.</p>\n', 'ViewCount': '162', 'Title': 'Unary Context Free Languages are Regular', 'LastActivityDate': '2013-10-21T16:34:43.723', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10285', 'Tags': '<regular-languages><context-free>', 'CreationDate': '2013-10-21T14:30:01.653', 'Id': '16293'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm interested in finite state automata which have the capacity to require repetition.  That is, the machine may be in a state in which the next character may be any character from set $S$, but, whatever character there is, it must be repeated 3 times.  Or it may be in a different state, which requires a character from set $T$ repeated twice.</p>\n\n<p>I could in theory make a different state for each character in set S, and for each character in set T.  But that overcomplicates things and obscures the pattern - it can be any character in set S, but the same character must be repeated.</p>\n\n<p>Is there any standard approach to this? I'm interested both in terminology and in practical code.</p>\n\n<hr>\n\n<p>Motivation: I do not know the full makeup of the set $S$ or $T$.  I'd like to be able to communicate effectively about the FSM, draw state diagrams, and do implementation, without having to define $S$ or $T$.  In fact, $S$ and $T$ change based on the scenario.  (Now, given a character, it's trivial to tell if it's part of $S$ or $T$ \u2014 but, a priori, it's impossible to enumerate them.)</p>\n\n<p>At the least, I'd like a good way to draw a state diagram for these types of machines.  Perhaps I should use a standard FSM with some type of annotation? Could state charts help with this?</p>\n", 'ViewCount': '85', 'Title': 'Recognizing finite state machines with repetition', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-24T19:06:19.023', 'LastEditDate': '2013-10-23T04:04:41.797', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10923', 'Tags': '<algorithms><regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2013-10-22T23:13:36.837', 'Id': '16343'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I show that this language is not regular?</p>\n\n<p>$$\n    L = \\{a^n (ca)^m b^{n+1} \\mid m \\ge 0 , n \\ge 0 \\}\n$$</p>\n\n<p>This is my attempted solution:</p>\n\n<p>Assuming the pumping number to be <em>$p$</em> and making <em>$m=0$</em></p>\n\n<p>the language reduces to $a^p b^{p+1}$ so  $s=a^p b^{p+1}$</p>\n\n<p>let $s=xyz$ where $y$ is not $\\epsilon \\\\$</p>\n\n<p>$y=a^k$; $0 \\lt k&lt;=p$</p>\n\n<p>$x=a^q$; $0 \\lt= q \\lt p$</p>\n\n<p>$z=a^{p-k-q}b^{n+1}$</p>\n\n<p>so with this definitions, $xyyz$ cannot be part of the language since this would be written as</p>\n\n<p>$xyyz$=$a^qa^ka^ka^{p-k-q}b^{p+1}$ = $a^{k+p}b^{p+1}$ which means there is always an extra $a$ which is not in the original language.</p>\n\n<p>Is this approach correct ?</p>\n', 'ViewCount': '20', 'ClosedDate': '2013-10-23T14:19:51.047', 'Title': 'How to show that a languge is not regular', 'LastEditorUserId': '10569', 'LastActivityDate': '2013-10-23T15:17:53.777', 'LastEditDate': '2013-10-23T15:17:53.777', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10569', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2013-10-23T14:08:05.800', 'Id': '16364'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am taking an undergraduate CS Theory course and the material on finite automata and regular languages is being taught in a non-traditional manner. Instead of using regular expressions, the closure properties of regular languages, the pumping lemma etc, to show that a language is or is not regular, all of our proofs and examples for identifying regular languages use the Myhill-Nerode theorem and boolean matrices as defined below.</p>\n\n<p>Let $L = \\{w_1, w_2, ...\\}$ be a set of words over some alphabet $\\Sigma$ and let $T_L$ be a matrix with entries $t_{ij}$ where</p>\n\n<p>$$ t_{ij} =\n\\left\\{\n \\begin{array}{ll}\n  1  &amp; \\mbox{if } w_iw_j \\in L \\\\\n  0  &amp; \\mbox{otherwise}\n \\end{array}\n\\right.\n$$</p>\n\n<p><strike>Then by Myhill-Nerode, L is non-regular iff all rows of $T_L$ are distinct.</strike></p>\n\n<p><strong>Correction:</strong> Then by Myhill-Nerode, $L$ is non-regular iff $T_L$ has an infinite number of distinct rows. </p>\n\n<p>My question is, are there any readily available books, papers, or lecture notes that lean heavily on this technique and are appropriate for undergrads?</p>\n', 'ViewCount': '90', 'Title': 'Undergrad resources for identifying regular languages with Myhill-Nerode matrices', 'LastEditorUserId': '10980', 'LastActivityDate': '2013-10-26T20:25:02.053', 'LastEditDate': '2013-10-26T20:25:02.053', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10980', 'Tags': '<regular-languages><finite-automata><education><matrices>', 'CreationDate': '2013-10-25T22:43:27.700', 'FavoriteCount': '1', 'Id': '16434'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Having the grammar <code>G = (V,P,S)</code> with variable <code>V = {S,A}</code> over the alphabet <code>{a,b}</code> with the rules:</p>\n\n<blockquote>\n  <p>S->aA </p>\n  \n  <p>A->Sbb|b</p>\n</blockquote>\n\n<p>How can i recognize which kind of grammar is this? I think that\'s not "regular expression" because in the second rule there are 2 letters (bb) instead of one, so i think it\'s a "context free" grammar. Am i right?</p>\n', 'ViewCount': '45', 'Title': 'Which grammar is this?', 'LastEditorUserId': '7955', 'LastActivityDate': '2013-10-26T14:03:25.130', 'LastEditDate': '2013-10-26T13:35:09.680', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16444', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7955', 'Tags': '<regular-languages><context-free><regular-expressions>', 'CreationDate': '2013-10-26T13:15:25.583', 'Id': '16443'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know how to use the pumping lemma to do so, but I don't think that can be used for this language:</p>\n\n<p>$$L = \\{x \\in \\{0,1\\}^* : \\text{no prefix of $x$ has more $1$'s than $0$'s}\\}. $$</p>\n\n<p>What other method can I use to prove this?</p>\n", 'ViewCount': '62', 'ClosedDate': '2013-10-28T07:26:12.150', 'Title': 'Prove language is not regular?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-10-28T05:01:55.250', 'LastEditDate': '2013-10-28T05:00:25.010', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11006', 'Tags': '<regular-languages><proof-techniques>', 'CreationDate': '2013-10-27T19:45:56.497', 'Id': '16482'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m currently studying compilers and am having some issues with understanding regular sets. For example, lets say I had a set of binary strings, (0, 1). Would all integers that are even and positive be considered part of a regular set? Lets say I have that same set, but instead of being even, they are divisible by 5, would it still be a regular set?</p>\n\n<p>I\'ve been looking at <a href="http://www.cs.uky.edu/~lewis/texts/theory/automata/reg-sets.pdf" rel="nofollow">this helpful guide</a> I found online, but I\'m still confused about what can be defined as a regular set.</p>\n', 'ViewCount': '71', 'Title': 'What can be defined as a Regular Set', 'LastEditorUserId': '98', 'LastActivityDate': '2013-10-28T07:26:56.920', 'LastEditDate': '2013-10-28T07:26:56.920', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11008', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-10-28T02:13:44.947', 'Id': '16485'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$\\tau$ be a transformation that, applied to a word of $\\Sigma_a^\\star$, replaces each character with a word from a possibly different $\\Sigma_b^\\star$ and concatenates the resulting words. For instance, given a $\\tau$ with the following translation table:</p>\n\n<pre><code>A -&gt; AA\nB -&gt; AB\nC -&gt; BA\nD -&gt; BB\n</code></pre>\n\n<p>$\\tau(ABC)=AAABBA$ and $\\tau(DACB)=BBAABAAB$. Note that the words may not all have the same length. A translation table such as</p>\n\n<pre><code>A -&gt; FOO\nB -&gt; BAR\nC -&gt; BAZ\nD -&gt; QUUX\n</code></pre>\n\n<p>is also valid.</p>\n\n<p>Now, is $\\{w'|w\\in L\\land w'=\\tau(w)\\}$ regular iff $L$ is a regular language as well?</p>\n", 'ViewCount': '79', 'ClosedDate': '2013-10-29T12:30:33.997', 'Title': 'Does a language stay regular if you re-encode the input?', 'LastActivityDate': '2013-10-28T20:11:05.297', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '16501', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<regular-languages>', 'CreationDate': '2013-10-28T13:29:34.783', 'Id': '16496'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am interested in what sort of metrics are there that try to give a measure of how complex a given graph is, what are the corresponding algorithms, and what is their time complexity. A short description or list of relevant paper would be great.</p>\n\n<p>It might help to say that I have two graphs and I want to somehow tell which one is ``more complex." I will use this metric as a heuristic, so I would like to try various metrics on empirical data. (It might help even more if I say that those graphs represent two FSMs.)</p>\n', 'ViewCount': '88', 'Title': 'Metrics and algorithms for complexity of a graph', 'LastActivityDate': '2013-11-05T19:40:41.493', 'AnswerCount': '3', 'CommentCount': '3', 'AcceptedAnswerId': '16518', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8508', 'Tags': '<graphs><regular-languages><time-complexity>', 'CreationDate': '2013-10-28T20:28:08.857', 'FavoriteCount': '1', 'Id': '16512'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In my homework we're given the following problem:\nDetermine whether the context-free language described by the following grammar is regular, showing all the reasoning steps:</p>\n\n<p>S -> T T | U</p>\n\n<p>T -> 0 T | T 0 | #</p>\n\n<p>U -> 0 U 0 0 | #.</p>\n\n<p>My teacher says the pound sign (#) is just a delimiter that is in the alphabet and not epsilon.</p>\n\n<p>I understand the order of operations here is to go from CFG --> CFL --> RL (if possible).<br>\nMy problem is that I don't know how to provide a CFL given a CFG, and further, determine whether a CFL is regular.</p>\n\n<p>So to ask the questions: </p>\n\n<p>how do you provide a context-free language (CFL) given a context-free grammar (CFG)?</p>\n\n<p>how do you determine if a context-free language (CFL) is also a regular language (RL)?</p>\n", 'ViewCount': '194', 'Title': 'Determining whether a context-free language (CFL) described by a given grammar is regular (RL)', 'LastActivityDate': '2013-11-03T10:46:39.410', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11142', 'Tags': '<regular-languages><context-free>', 'CreationDate': '2013-11-03T07:35:17.580', 'Id': '16666'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How to prove that if a language A is not regular then A* isn't regular either?</p>\n\n<p>I have tried the usual methods with no result.</p>\n", 'ViewCount': '157', 'Title': 'Is the class of non-regular languages closed against Kleene star?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-04T19:22:08.677', 'LastEditDate': '2013-11-04T19:22:08.677', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11166', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-11-04T07:58:34.270', 'Id': '16695'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have an assignment where i need to create a Turing machine that decides an infinite language $L\\subset \\{0,1\\}^*$ for which all $L'\\subseteq L$, if $|L'|=\\infty$, then $L'$ is not a regular language.</p>\n\n<p>I think this is not possible due to Rice's Theorem. It's not possible to tell for a Turing Machine if a language is regular or not.</p>\n\n<p>Moreover, on any given input, the machine can loop so it cannot decide an infinite language $L$.</p>\n\n<p>Is this the right answer? It seems too easy to be the answer... Any input would be appreciable. Thanks in advance.</p>\n", 'ViewCount': '311', 'Title': 'Can a Turing Machine decide only non-regular languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-08T11:27:53.427', 'LastEditDate': '2013-11-08T11:27:53.427', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '16786', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10888', 'Tags': '<formal-languages><regular-languages><turing-machines><automata>', 'CreationDate': '2013-11-05T17:52:50.853', 'Id': '16745'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I had a question on an assignment where we were supposed to write a regular expression for a language where every $a$ in $w$ is immediately preceded and followed by a $b$. My answer was $\\epsilon + (b + bab)^*$. The teacher pointed out that my answer makes an $a$ surrounded by at least two $b$s, which isn't correct. I can't for the life of me figure out how to fix it to make it correct. Can anyone help?</p>\n", 'ViewCount': '55', 'Title': "Regular expression for the language where every a is surrounded by b's", 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-12T17:56:34.657', 'LastEditDate': '2013-11-12T17:56:34.657', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '17934', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10884', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2013-11-11T19:55:17.943', 'Id': '17924'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the language with alphabet: $\\{a, b, c\\}$\nDraw an NFA or DFA for all the strings that have exactly twice substrings $ab$ and at least on $c$.\nI\'m stuck with "exactly twice $ab$". Can somebody give me some ideas. It\'s also very good if you can suggest me the regular expression of this statement.</p>\n', 'ViewCount': '399', 'Title': 'NFA or DFA for strings the contain exactly twice substring ab?', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-11-13T16:08:45.447', 'LastEditDate': '2013-11-12T09:47:18.353', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11326', 'Tags': '<formal-languages><regular-languages><finite-automata><regular-expressions>', 'CreationDate': '2013-11-12T03:43:29.253', 'Id': '17942'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I wonder how I can go about proving that if a language L is decidable in o(nlog(n)) then L must be regular.</p>\n\n<p>I should probably mention that by "decidable" I mean "being decidable by single-tape deterministic turing machine".  </p>\n\n<p>Thanks and regards\nGuillermo</p>\n', 'ViewCount': '68', 'Title': 'Time Complexity of Regular Languages', 'LastActivityDate': '2013-11-13T05:09:30.110', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '17978', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11348', 'Tags': '<regular-languages><time-complexity>', 'CreationDate': '2013-11-13T01:39:47.040', 'Id': '17975'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have seen this question: <a href="http://cs.stackexchange.com/questions/2713/are-regular-expressions-lrk">Are regular expressions $LR(k)$?</a> and my question is slightly related.</p>\n\n<p>Suppose I have a regular expression:\nRE=(a*a*)?(a*a*)</p>\n\n<p>and I convert it to a grammar:\nG ::= A B\nA ::= C | (empty)\nC ::= D D\nD ::= aD | empty\nB ::= D D</p>\n\n<p>Can an LALR(1) parser such as Bison generate matches such that I can perform actions such as recording captures, etc... If so, is the cost linear in the size of the input?</p>\n\n<p>If not, is the lower bound on this operation the cost of simulating an NFA generated by the regular expression? I know that DFAs can\'t perform sub-match captures.</p>\n', 'ViewCount': '21', 'Title': 'Can regular expression captures be matched by a CFG being simulated by an $LR(k)$ parser?', 'LastActivityDate': '2013-11-14T05:00:11.847', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5331', 'Tags': '<regular-languages><context-free><regular-expressions><parsers>', 'CreationDate': '2013-11-14T05:00:11.847', 'Id': '18005'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Is there an algorithm/systematic procedure to test whether a language is regular?</p>\n\n<p>In other words, given a language specified in algebraic form (think of something like $L=\\{a^n b^n : n \\in \\mathbb{N}\\}$), test whether the language is regular or not.  Imagine we are writing a web service to help students with all their homeworks; the user specifies the language, and the web service responds with "regular",  "not regular", or "I don\'t know".  (We\'d like the web service to answer "I don\'t know" as infrequently as possible.)  Is there any good approach to automating this?  Is this tractable?  Is it decidable (i.e., is it possible to guarantee that we never need to answer "I don\'t know")?  Are there reasonably efficient algorithms for solving this problem, and be able to provide an answer other than "don\'t know" for many/most languages that are likely to arise in practice?</p>\n\n<p>The classic method for proving that a language is not regular is the pumping lemma.  However, it looks like requires manual insight at some point (e.g., to choose the word to pump), so I\'m not clear on whether this can be turned into something algorithmic.</p>\n\n<p>A classic method for proving that a language is regular would be to use the  Myhill\u2013Nerode theorem to derive a finite-state automaton.  This looks like a promising approach, but it does requires the ability to perform basic operations on languages in algebraic form.  It\'s not clear to me whether there\'s a systematic way to symbolically perform all of the operations that may be needed, on languages in algebraic form.</p>\n\n<hr>\n\n<p>To make this question well-posed, we need to decide how the user will specify  the language.  I\'m open to suggestions, but I\'m thinking something like this:</p>\n\n<p>$$L = \\{E : S\\}$$</p>\n\n<p>where $E$ is a word-expression and $S$ is a system of linear inequalities over the length-variables, with the following definitions:</p>\n\n<ul>\n<li><p>Each of $x,y,z,\\dots$ is a word-expression.  (These represent variables that can take on any word in $\\Sigma^*$.)</p></li>\n<li><p>Each of $x^r,y^r,z^r,\\dots$ is a word-expression.  (Here $x^r$ represents the reverse of the string $x$.)</p></li>\n<li><p>Each of $a,b,c,\\dots$ is a word-expression.  (Implicitly, $\\Sigma=\\{a,b,c,\\dots\\}$, so $a,b,c,\\dots$ represent a single symbol in the underlying alphabet.)</p></li>\n<li><p>Each of $a^\\eta,b^\\eta,c^\\eta,\\dots$ is a word-expression, if $\\eta$ is a length-variable.</p></li>\n<li><p>The concatenation of word-expressions is a word-expression.</p></li>\n<li><p>Each of $m,n,p,q,\\dots$ is a length-variable.  (These represent variables that can take on any natural number.)</p></li>\n<li><p>Each of $|x|,|y|,|z|,\\dots$ is a length-variable.  (These represent the length of a corresponding word.)</p></li>\n</ul>\n\n<p>This seems broad enough to handle many of the cases we see in textbook exercises.  Of course, you can substitute any other textual method of specifying a language in algebraic form, if you have a better suggestion.</p>\n', 'ViewCount': '209', 'Title': 'Algorithm to test whether a language is regular', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-17T20:52:53.740', 'LastEditDate': '2013-11-14T22:53:44.637', 'AnswerCount': '1', 'CommentCount': '13', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><formal-languages><regular-languages><decision-problem>', 'CreationDate': '2013-11-14T07:13:17.670', 'FavoriteCount': '1', 'Id': '18010'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve been struggling with this problem for quite a while now and every explanation I have managed to find doesn\'t seem to correctly solve it.</p>\n\n<p>We have the language L = {$ { a^{2^n} \\ | \\ n \\ge 0 } $} and we need to prove that it is not regular by use of the pumping lemma.</p>\n\n<p>(i.e. L is words whose length is a power of 2: a, aa, aaaa, aaaaaaaa etc.)</p>\n\n<p>I appreciate the concept of the proof so here we go:</p>\n\n<p>Assuming regularity of L and using the Pumping Lemma, we have $ {a^{2^p}} = {xyz}$ where:</p>\n\n<p>a) ${y &gt; 0}$</p>\n\n<p>b) ${|xy| \\le p}$</p>\n\n<p>c) $xy^iz \\in L \\ \\forall \\ i \\ge 0$</p>\n\n<p>(also $ |xyz|\\ = 2^p \\ge p$)</p>\n\n<p>(notice both x and z can be empty)</p>\n\n<p>I choose $ i = 2$ to get $xy^2z$ so (since $y&gt;0$) $|xy^2z| &gt; 2^p$</p>\n\n<p>I understand that the next step is trying to prove  that $|xy^2z| &lt; 2^{p+1}$ so that the final result is $2^p &lt; |xy^2z| &lt; 2^{p+1}$ and so $xy^2z$ cannot be an element of L.</p>\n\n<p>However if $|y| = p$ and so $|x| = 0,\\  |z| = 0$ then this is not possible as taking $y^2$ is just doubling the length of the word which makes another word that fits the language.</p>\n\n<p>Am I missing something important? I have found proofs on multiple web pages (see below) that just seem to assume y cannot be of length p but as far as I can see this isn\'t the case.</p>\n\n<p><a href="http://cs.geneseo.edu/~baldwin/csci342/fall2012/0928pump.html" rel="nofollow">http://cs.geneseo.edu/~baldwin/csci342/fall2012/0928pump.html</a>\n<a href="http://www.cse.buffalo.edu/courses/cse396/content/hwSol-5.pdf" rel="nofollow">http://www.cse.buffalo.edu/courses/cse396/content/hwSol-5.pdf</a></p>\n\n<p>Thanks very much in advance and please let me know if there is anything I should clarify.</p>\n', 'ViewCount': '170', 'Title': 'Proving L = {$ { a^{2^n} \\ | \\ n \\ge 0 } $} is not regular by use of Pumping Lemma', 'LastEditorUserId': '11408', 'LastActivityDate': '2013-11-15T23:51:29.120', 'LastEditDate': '2013-11-15T23:51:29.120', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18059', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '11408', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2013-11-15T22:36:06.700', 'Id': '18058'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This sub-problem is motivated by <a href="http://cs.stackexchange.com/q/18010/755">Algorithm to test whether a language is regular</a>.</p>\n\n<p>Suppose we have two languages $L_1,L_2$ that are expressed in "algebraic" form, as formalized below.  I want to determine whether $L_1 = L_2$.</p>\n\n<p>Is this decidable?  If yes, can anyone suggest an algorithm for this?  If not, can anyone suggest a semi-algorithm (one that returns "equal", "not equal", or "I\'m not sure"; where we want it to return "not sure" as rarely as possible).</p>\n\n<p>Motivation: A solution to this sub-problem would be helpful for solving <a href="http://cs.stackexchange.com/q/18010/755">Algorithm to test whether a language is regular</a></p>\n\n<hr>\n\n<p><strong>Algebraic form.</strong> Here\'s one possible definition of what I mean by a representation of a language in algebraic form.  Such a language is given by</p>\n\n<p>$$L = \\{E : S\\}$$</p>\n\n<p>where $E$ is a word-expression and $S$ is a system of linear inequalities over the length-variables, with the following definitions:</p>\n\n<ul>\n<li><p>Each of $x,y,z,\\dots$ is a word-expression.  (These represent variables that can take on any word in $\\Sigma^*$.)</p></li>\n<li><p>Each of $x^r,y^r,z^r,\\dots$ is a word-expression.  (Here $x^r$ represents the reverse of the string $x$.)</p></li>\n<li><p>Each of $a,b,c,\\dots$ is a word-expression.  (Implicitly, $\\Sigma=\\{a,b,c,\\dots\\}$, so $a,b,c,\\dots$ represent a single symbol in the underlying alphabet.)</p></li>\n<li><p>Each of $a^\\eta,b^\\eta,c^\\eta,\\dots$ is a word-expression, if $\\eta$ is a length-variable.</p></li>\n<li><p>The concatenation of word-expressions is a word-expression.</p></li>\n<li><p>Each of $m,n,p,q,\\dots$ is a length-variable.  (These represent variables that can take on any natural number.)</p></li>\n<li><p>Each of $|x|,|y|,|z|,\\dots$ is a length-variable.  (These represent the length of a corresponding word.)</p></li>\n</ul>\n\n<p>My goal is something rich enough to capture many of the examples we see in textbook exercises.  (Feel free to suggest modifications to this formalization if it makes the equality-testing problem easier while still remaining expressive enough to capture many of the examples we see in textbooks.)</p>\n\n<hr>\n\n<p><strong>Some easier cases.</strong> If the original problem is too hard, here are some sub-cases that would still be interesting:</p>\n\n<ul>\n<li><p>If $L_1,L_2$ are two languages specified in "algebraic" form as above, and $L_1\\ne L_2$, let $d(L_1,L_2)$ denote the length of the shortest word that is an element of one of $L_1,L_2$ but not the other.  Can we upper-bound $d(L_1,L_2)$ as a function of the length of the descriptions of $L_1,L_2$?  Is it guaranteed to always be polynomial? at most singly-exponential?</p>\n\n<p>Motivation: If we could prove it is always polynomial, this might help us exhibit a witness that $L_1 \\ne L_2$.</p></li>\n<li><p>If we omit the reversal operation (we do not allow $x^r,y^r,\\dots$), does the problem become easier?</p></li>\n</ul>\n', 'ViewCount': '77', 'Title': 'Test whether two languages are equal, when give in algebraic form', 'LastActivityDate': '2013-11-16T03:08:21.470', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<algorithms><formal-languages><regular-languages><decision-problem>', 'CreationDate': '2013-11-16T03:08:21.470', 'Id': '18062'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm working on some questions to bone up on my knowledge of DFA's for a computing class and I've run across the following problem that is giving me some issues. If we have some \nDFA M = (Q, \u03a3, \u03b4, q0, F) and some other DFA M' = (Q, \u03a3, \u03b4, q0, F') where F is a proper subset of F', are the following relations possible or not between the two produced languages?</p>\n\n<p>1) L(M) \u2282 L(M')</p>\n\n<p>2) L(M) \u2283 L(M')</p>\n\n<p>My current theory is that the first one is not possible, due to the fact that the first machine has more finish states than the other, thus the language must be larger and cannot be subset to M'. This would of course mean that the second relationship is possible, since M must contain M'. Am I on the right track here and if so, how could I prove this?</p>\n", 'ViewCount': '58', 'Title': "Comparing DFA's produced languages", 'LastActivityDate': '2013-11-21T03:46:02.853', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11521', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-11-21T03:46:02.853', 'Id': '18214'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$L$ is a regular language and $w$ is any word, not necessarily in $L$. We define the set as</p>\n\n<p>$$L/w = \\{x \\in \\Sigma ^* \\mid xw \\in L\\}.$$</p>\n\n<p>Show that $L/w$ is regular.</p>\n\n<p>I'm really struggling with this one. I know its going to come on my final next week.</p>\n", 'ViewCount': '60', 'Title': 'L is a regular language and w is any word, not necessarily in L. Show that L is regular', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-12-26T12:35:35.627', 'LastEditDate': '2013-11-26T09:54:13.487', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11632', 'Tags': '<regular-languages><formal-grammars>', 'CreationDate': '2013-11-26T09:43:52.243', 'Id': '18369'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Suppose that G is a context-free grammar. How can I show that \u201cIs L(G) regular?\u201d is undecidable. Also, prove that L is always context-free but is regular if and only if L(G) = \u03a3\u2217. </p>\n\n<p>This is what I have so far</p>\n\n<p>Let N be some language that is known to be context-free but not regular (for example, {a^nb^n | n \u2265 0}). Consider the language L = N#\u03a3\u2217 \u222a \u03a3\u2217#L(G), where # is some symbol that is not in L(G) or N. </p>\n\n<p>Where to? I just know my prof is going to put this on my exam :s.</p>\n', 'ViewCount': '159', 'Title': u'Showing Context Free Grammars that are regular if and only if L(G) = \u03a3\u2217.', 'LastActivityDate': '2013-11-26T17:32:23.990', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11632', 'Tags': '<regular-languages><context-free>', 'CreationDate': '2013-11-26T09:55:58.867', 'Id': '18370'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My doubt is based on the relation between regular grammar and regular languges </p>\n\n<p>$S \\to Sa\\ |\\ a$ produces the regular language $a^+$ but this grammar is not type-3 grammar of Chomsky classification. So am I correct in stating that this is not a regular grammar even when it produces regular language?</p>\n', 'ViewCount': '64', 'Title': 'Regular Grammar and Regular Language', 'LastEditorUserId': '9612', 'LastActivityDate': '2013-12-04T11:03:34.137', 'LastEditDate': '2013-12-04T10:51:21.977', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18604', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8533', 'Tags': '<regular-languages>', 'CreationDate': '2013-12-01T15:07:13.237', 'Id': '18503'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given the following multiplication table how could one construct an NFA such that it accepts all strings that have a certain product (say a) ? </p>\n\n<p>The string "abcb" would be evaluated as (a(b(cb))) = a</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; a &amp; c \\\\\n    b &amp; c &amp; a &amp; b \\\\\n    c &amp; b &amp; c &amp;a\n   \\end{array}</p>\n\n<p>I tried to take the transpose of the above matrix:</p>\n\n<p>\\begin{array}{c|ccc} \n    \\times &amp; a &amp; b &amp; c \\\\\n    \\hline \n    a &amp; a &amp; c &amp; b \\\\\n    b &amp; a &amp; a &amp; c \\\\\n    c &amp; c &amp; b &amp; a\n   \\end{array}</p>\n\n<p>And build an NFA for that. I then reversed all the transitions, but I don\'t think that works.</p>\n', 'ViewCount': '72', 'Title': 'NFA for right left multiplication', 'LastActivityDate': '2013-12-02T04:34:35.407', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11741', 'Tags': '<regular-languages><finite-automata><nondeterminism><multiplication>', 'CreationDate': '2013-12-01T20:37:27.720', 'Id': '18509'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have a question to find out that L = {a^(2k)|k>=1} is regular. I know that it is regular set but I was looking to find out if pumping lemma is satisfying or not. So I tried it as -</p>\n\n<pre><code>Let # of states in the FA be n &amp; I select the string w = a^2n\nNow let xyz = w\nxy = a^n\ny = a^m | m is odd number\nnow x(y^2)z = a^(n-m)(a^2m)(a^n) \n= a(2n+m) does not belong to L\n</code></pre>\n\n<p>which says this regular set doesn't satisfy pumping property. Please let me know if I am doing something wrongly.</p>\n\n<p>Thanks in advance.</p>\n", 'ViewCount': '38', 'ClosedDate': '2013-12-03T17:48:28.990', 'Title': 'Pumping Lemma for regular language', 'LastActivityDate': '2013-12-02T01:48:28.927', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18518', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11750', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2013-12-02T01:36:59.560', 'Id': '18517'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '134', 'Title': 'Partition an infinite regular language into 2 disjoint infinite regular languages', 'LastEditDate': '2013-12-05T18:01:50.127', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '11713', 'FavoriteCount': '1', 'Body': "<p>Given any infinite regular language $L$, how can I prove that $L$ can be partitioned into 2 disjoint infinite regular languages $L_1, L_2$? That is: $L_1 \\cup L_2 = L$, $L_1 \\cap L_2 = \\varnothing$, and $L_1$ and $L_2$ are both both infinite and regular.</p>\n\n<p>So far, I thought of:</p>\n\n<ol>\n<li><p>using the pumping lemma such that \n$$ \\begin{gather}\n  L_1 &amp;= \\{ xy^nz \\mid \\text{\\(n\\) is even} \\} \\\\\n  L_2 &amp;= \\{ xy^mz \\mid \\text{\\(m\\) is odd} \\} \\\\\n\\end{gather} $$\nbut couldn't prove that they are dijoint or covering $L$ completely. </p></li>\n<li><p>Using the regular language partitions $\\Sigma^*$ into dijoint equivalence classes, but I haven't figured out how to determine if an equivalence class is regular or infinite.</p></li>\n</ol>\n", 'Tags': '<formal-languages><regular-languages><finite-automata>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-05T18:01:50.127', 'CommentCount': '0', 'AcceptedAnswerId': '18613', 'CreationDate': '2013-12-04T14:40:00.883', 'Id': '18610'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So I recently had a problem where I had to create a regular language. After consulting my professor on my solution he told me it was close to correct but to check my definition of a regular language. I am somewhat lost on why my solution is not regular?</p>\n\n<p><img src="http://i.stack.imgur.com/CTosd.png" alt="solution"></p>\n\n<p>From my understanding it meets the requirements of being a right regular language since there is only one non-terminal on the right side of the expression and the non-terminal is the rightmost symbol on the right side of the expression. Are pipe symbols not allowed?</p>\n', 'ViewCount': '79', 'Title': 'Why is this not a regular language', 'LastEditorUserId': '11820', 'LastActivityDate': '2013-12-05T10:04:41.513', 'LastEditDate': '2013-12-05T01:45:19.807', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '18627', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11820', 'Tags': '<regular-languages><context-free><automata>', 'CreationDate': '2013-12-05T01:09:19.733', 'Id': '18624'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given $A,B$ regular languages with $A \\prec B$. Prove the existence of $C\\in L_{\\text{regular}}$ so that: $A \\prec C \\prec B$.</p>\n\n<p>Here, $A\\prec B$ stands for: $A\\subset B $ and $B\\setminus A $ is infinite.  </p>\n\n<p>I tried to go for: $C=\\overline{B} \\cup A$ and some other options but it didn't work out.</p>\n", 'ViewCount': '93', 'Title': 'Prove the existence of regular $C$ so that: $A \\prec C \\prec B $', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-12-06T00:27:44.990', 'LastEditDate': '2013-12-06T00:27:44.990', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '18654', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11841', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2013-12-05T15:55:23.273', 'Id': '18646'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to figure out if there exists a DFA $M$ with $k+2$ states (for every $k\\in \\mathbb{N}$ ) so that every automaton which accepts $L(M)^R$ has at least $2^k$ states.<br>\nI am trying to find an example of such a DFA, any help?</p>\n', 'ViewCount': '66', 'Title': 'Is there a DFA with $k+2$ states which its reverse has $2^k$ states', 'LastActivityDate': '2013-12-06T01:03:55.337', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '18655', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11841', 'Tags': '<regular-languages><automata><finite-automata>', 'CreationDate': '2013-12-05T16:27:34.630', 'Id': '18648'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '147', 'Title': 'Synchronizing sequence and Synchronizable DFA', 'LastEditDate': '2013-12-07T01:48:28.913', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11841', 'FavoriteCount': '1', 'Body': '<p>I am trying to prove problem 1.59 in Sipser\'s book: <em>Introduction to the theory of computation , 2nd Edition.</em></p>\n\n<blockquote>\n  <p>Let $M=(Q,\\Sigma,\\delta,q_0,A)$ be a DFA and let $q\'$ be a state of $M$ called its "home". A <strong>Synchronizing sequence</strong> for $M$ and $q\'$ is a string $s\\in \\Sigma^*$ where $\\delta (q,s)=q\'$ for every $q\\in Q$. (We actually have extended $\\delta$ to strings so that $\\delta(q,s)$ equals the state where $M$ ends up when $M$ starts at state $q$ and reads input $s$).</p>\n  \n  <p>Say that $M$ is <strong>Synchronizable</strong> if it has a synchronizing sequence for some state $q\'$.</p>\n  \n  <p>Prove that, if $M$ is a $k$-state synchronizable DFA, then it has a synchronizing sequence of length at most $k^3$. Moreover, can you improve upon this bound?  </p>\n</blockquote>\n\n<p>I\'m more interested in proving that the synchronized sequence is of length of at most $k^3$ then trying to improve upon this bound.  </p>\n\n<p>I tried to prove (with no success) that there exists $w\\in \\Sigma^*$ which $|w| \\leq k^2 $ so that: $\\delta(q_1,w)=\\delta(q_2,w)$ for two distinct states in $M$: $q_1,q_2\\in Q$ (thus, $w$ can be read from two states in the automaton and get to the same final state).<br>\nIf I prove it, I could construct a word $w$ which will be a synchronizing sequence in $M$ and $|w|\\leq k^3$ as required.  </p>\n\n<p>Any suggestions?</p>\n', 'Tags': '<regular-languages><automata><finite-automata>', 'LastEditorUserId': '11841', 'LastActivityDate': '2013-12-07T02:40:56.123', 'CommentCount': '1', 'AcceptedAnswerId': '18704', 'CreationDate': '2013-12-06T18:56:27.920', 'Id': '18692'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Like the title says, we have the alphabet $\\Sigma = \\{a,b,c\\}$ and the question is asking for the regular expression of the language $L$ that has the property that all strings in $L$ have at least two consecutive $a$'s but no consecutive $b$'s. </p>\n\n<p>By attempt at a solution was this, where $aaa^+$ stands for $aaa(aaa)^*$:</p>\n\n<p>$$(a+c)^*aaa^+(a+c)^*b(a+c)^* + (a+c)^*b(a+c)^*aaa^+(a+c)^*$$</p>\n\n<p>but I know this is wrong since we never get an instance of consecutive $b$'s. Can someone point me in the right direction?</p>\n", 'ViewCount': '142', 'Title': "Regex for the language over $\\{a,b,c\\}$ that contain at least two $a$'s but no two consecutive $b$'s", 'LastActivityDate': '2013-12-07T11:52:03.477', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18702', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11892', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2013-12-07T00:49:53.050', 'Id': '18701'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If L is regular and M is non regular; then L.M is necessarily not regular. Is this true or false? And why?</p>\n\n<p>I feel its false</p>\n', 'ViewCount': '60', 'Title': 'Regular concat with non regular', 'LastActivityDate': '2013-12-09T21:55:13.610', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11927', 'Tags': '<regular-languages>', 'CreationDate': '2013-12-08T15:21:46.033', 'Id': '18751'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m a little confused by <a href="http://en.wikipedia.org/wiki/Regular_Language" rel="nofollow">Wikipedia\'s definition of a regular language</a>:</p>\n\n<blockquote>\n  <p>The collection of regular languages over an alphabet $\\Sigma$ is defined recursively as follows:</p>\n  \n  <ul>\n  <li>The empty language $\\emptyset$ is a regular language.</li>\n  <li>For each $a \\in \\Sigma$ ($a$ belongs to $\\Sigma$), the singleton language ${a}$ is a regular language.</li>\n  <li>If $A$ and $B$ are regular languages, then $A \\cup B$ (union), $A \\cdot B$ (concatenation), and $A^\\ast$ (Kleene star) are regular languages.</li>\n  <li>No other languages over $\\Sigma$ are regular.</li>\n  </ul>\n</blockquote>\n\n<p>This seems defines a regular language as any set that contains a finite number of unique elements, though the set can be countably infinite (it\'s worth noting that the article doesn\'t explicitly state that $\\left\\vert{\\Sigma}\\right\\vert$ is finite in the definition), i.e., a regular language is any set $S$</p>\n\n<p>$$\n\\left\\vert{S}\\right\\vert \\le \\left\\vert{\\infty}\\right\\vert, {S} \\in \\Sigma \\\\  \n\\left\\vert{\\Sigma}\\right\\vert \\lt \\left\\vert{\\infty}\\right\\vert\n$$</p>\n\n<p>I think this is correct because the union, concatenation or Kleene star of a singleton that is part of a finite set or the empty set must be also part of that set, even when operated on recursively. </p>\n\n<p>It\'s been a fair while since I did any maths, and even longer since I\'ve touched set theory. Have I completely misread Wikipedia\'s definition? If so, how? If I haven\'t how is a regular language different from my definition?</p>\n', 'ViewCount': '92', 'Title': 'Definition of a regular language', 'LastActivityDate': '2013-12-08T21:31:20.787', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11934', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2013-12-08T20:31:03.053', 'Id': '18758'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How could we prove the following modified Pumping Lemma:Let the language L has an infinite number of words, then there are words $x,y,z \\epsilon \\Sigma ^{*}$, so that $|xz|\\leq |\\Sigma_{k}|$, and each word $xy^{(i)}z, i\\geq0 $ is in L.\nCould you give me a hint how to begin?</p>\n', 'ViewCount': '73', 'Title': 'Modified Pumping Lemma', 'LastActivityDate': '2013-12-16T02:18:59.620', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '11889', 'Tags': '<regular-languages>', 'CreationDate': '2013-12-09T21:25:06.067', 'Id': '18791'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I did see a lot of nice and informative questions, articles on inter-net and on StackOverflow itself, of-course. But I found all the questions or articles following a specific rule or a pattern to explain the topic. I mean, when a question was asked on NFA, DFA or Regular Expression, a solution was presented to the question abiding by the theorems / rules of these topics (Theory of Computation).</p>\n\n<p>But what I feel is that, as most of the questions on DFA/NFA are of the type \n"Design an NFA...." or "design a DFA..." , I feel that developing/Designing DFA/NFA must be an ART. </p>\n\n<p>And where there is ART I feel there is an intuition. If these problems involve "DESIGNING" something ,then everyone must have their own way (of-course not going out-of-the-way of theorems or rules as such) of solving or attacking these problems. One should have developed a thinking process (over the years of practise) to solve these problems.</p>\n\n<p>So I would like all the experts over this Site to share their knowledge (preferably in simple words) how they think over the problems (simple ones) of these topics.</p>\n\n<p>I would like to elaborate the question with a simple example.</p>\n\n<blockquote>\n  <p>Let F be the language of all strings over {0,1} that do not contain a pair of 1s that\n  are separated by an odd number of symbols. Give the state diagram of a DFA with\n  five states that recognizes F . </p>\n</blockquote>\n\n<p>Or maybe this:</p>\n\n<blockquote>\n  <p>Design an NFA to find a 4-state NFA for the complement of F.</p>\n</blockquote>\n\n<p>These questions are from the Sipser\'s book and I have also found the solutions for them myself. </p>\n\n<p>I just want to know , how one can develop an intuition for solving the problems?</p>\n', 'ViewCount': '215', 'ClosedDate': '2013-12-13T08:23:17.523', 'Title': 'How to approach NFA design questions intuitively?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-12T09:39:34.433', 'LastEditDate': '2013-12-12T09:39:34.433', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11125', 'Tags': '<regular-languages><finite-automata><education>', 'CreationDate': '2013-12-12T07:26:32.340', 'Id': '18913'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Is the following language regular?</p>\n\n<blockquote>\n  <p>$$L = \\{x \\in \\{a, b\\}^* \\mid \\text{in every prefix \\(w\\) of \\(x\\), } 0 \\le |w|_a \u2212 |w|_b \\le 2\\}$$</p>\n  \n  <p>If so, give a DFA for it with as few states as possible. If you claim that it is\n  not regular give a pumping lemma proof that it is not regular.</p>\n</blockquote>\n\n<p>I\'m doing exam prep and have tried pumping this to no avail. I think I created a DFA that works but I\'m not entirely sure because pumping similar examples (i.e. if the number of a\'s is strictly greater than b\'s) yielded results that are not regular. Is my DFA correct? Or is there something I can pump that will fail the lemma?</p>\n\n<p><img src="http://i.stack.imgur.com/m51eT.png" alt="DFA"></p>\n', 'ViewCount': '176', 'Title': "Language where every prefix has almost equal a's and b's", 'LastEditorUserId': '9612', 'LastActivityDate': '2014-02-17T19:58:36.680', 'LastEditDate': '2013-12-26T09:58:57.370', 'AnswerCount': '4', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11632', 'Tags': '<regular-languages>', 'CreationDate': '2013-12-17T22:19:16.957', 'Id': '19073'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>a^2n b^(2n+1) is a regular language. \nI am not able to decompose it in xyz so that I can pump any power of y as per pumping lemma. Please help me out.</p>\n', 'ViewCount': '49', 'ClosedDate': '2014-01-03T06:37:14.837', 'Title': 'Regular language using pumping lemma', 'LastActivityDate': '2014-01-02T17:37:23.983', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11804', 'Tags': '<regular-languages>', 'CreationDate': '2014-01-02T16:09:41.307', 'Id': '19457'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>As I have studied, deciding regularity of context-free languages is undecidable.</p>\n\n<p>However, we can test for regularity using the Myhill\u2013Nerode theorem which provides a necessary and sufficient condition. So the problem should be decidable.</p>\n\n<p>Where is my mistake?</p>\n', 'ViewCount': '151', 'Title': 'Why is deciding regularity of a context-free language undecidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-05T17:18:35.267', 'LastEditDate': '2014-01-04T18:39:42.627', 'AnswerCount': '1', 'CommentCount': '14', 'AcceptedAnswerId': '19500', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '12569', 'Tags': '<formal-languages><computability><regular-languages><undecidability>', 'CreationDate': '2014-01-03T12:37:01.957', 'Id': '19482'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><a href="https://github.com/gurgeh/CodeSpace">This Github repo</a> hosts a very cool project where the creator is able to, give an integer sequence, predict the most likely next values by searching the smallest/simplest programs that output that integer sequence. I was trying to approach the same idea using lambda-calculus instead of a stack-based language, but I was stuck on the enumeration of valid programs on LC\'s grammar.</p>\n\n<p>Anyway, what is the field studying that kind of idea and how can I grasp the current state-of-art?</p>\n', 'ViewCount': '94', 'Title': 'What is the field studying the search and generation of computer programs?', 'LastActivityDate': '2014-01-12T11:12:54.350', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '11547', 'Tags': '<algorithms><complexity-theory><formal-languages><computability><regular-languages>', 'CreationDate': '2014-01-09T20:37:06.207', 'Id': '19605'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given two sets $A,B$ of strings over alphabet $\\Sigma$, can we compute the smallest deterministic finite-state automaton (DFA) $M$ such that $A \\subseteq L(M)$ and $L(M) \\subseteq \\Sigma^*\\setminus B$?</p>\n\n<p>In other words, $A$ represents a set of positive examples.  Every string in $A$ needs to be accepted by the DFA.  $B$ represents a set of negative examples.  No string in $B$ should be accepted by the DFA.</p>\n\n<p>Is there a way to solve this, perhaps using <a href="https://en.wikipedia.org/wiki/DFA_minimization">DFA minimization</a> techniques?  I could imagine creating a DFA-like automaton that has three kinds of states: accept states, reject states, and "don\'t-care" states (any input that ends in a "don\'t-care" state can be either accepted or rejected).  But can we then find a way to minimize this to an ordinary DFA?</p>\n\n<p>You could think of this as the problem of learning a DFA, given positive and negative examples.</p>\n\n<p>This is inspired by  <a href="http://cs.stackexchange.com/q/19686/755">Is regex golf NP-Complete?</a>, which asks a similar questions for regexps instead of DFAs.</p>\n', 'ViewCount': '158', 'Title': 'Smallest DFA that accepts given strings and rejects other given strings', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-15T08:31:57.547', 'LastEditDate': '2014-01-13T12:59:49.750', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '19693', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<regular-languages><automata><finite-automata><machine-learning>', 'CreationDate': '2014-01-13T09:37:38.647', 'Id': '19687'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I understand the restrictions, because a regular language is expressive enough to allow all types of tokens. And even if some context is needed in many languages to tokenize properly, they all seem to be "approximately" regular languages.</p>\n\n<p>Yet I would be interested if any attempt in any programming language, possibly esoteric language, has been taken to completely eschew the conventional division between type-3 lexers and type-2 parser.</p>\n', 'ViewCount': '33', 'Title': 'Has there been a lexer that takes in much more than a regular language?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-20T14:35:25.787', 'LastEditDate': '2014-01-20T09:14:37.250', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4289', 'Tags': '<reference-request><regular-languages><compilers>', 'CreationDate': '2014-01-19T23:12:01.723', 'Id': '19837'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know that the language $\\{a^m b^n | n\\neq m\\}$ satisfies the pumping lemma, but it's still not regular (I have to count the # of a's and b's). \nHow can I formally prove it?</p>\n", 'ViewCount': '99', 'ClosedDate': '2014-01-24T17:17:44.213', 'Title': 'Proof that {$a^m b^n$ | m!=n} is not regular', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-24T17:19:13.437', 'LastEditDate': '2014-01-24T17:19:13.437', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13098', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-01-24T14:09:48.383', 'Id': '19940'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I have this question about if the decidability of an regular expression and would appreciate if someone can check my answer and see if it makes sense, and if not, what is missing.</p>\n\n<blockquote>\n  <p>Be A = {(R)|R it is a regular expression that describes a language containing at least a w string that has 111 as a substring (that it is, w=x111y to some x and some y)}. Show that A it is decidible</p>\n</blockquote>\n\n<p>Answer: Create a turing machine P, this machine receives a pair where R is the regular expression in question and W is the set of all the strings of the form x111y. P converts R into a NFA called NFAR. It sends the pair to a TM N that acts as a subrotine of it. N will convert NFAR into a DFA called DFAR. Then inside this machine N, there is a turing machine M inside it, also acting as a subrotine. It sends the pair to M. When M receives its input, it will first determines whether it properly represents a DFA DFAR an a set of strings W. If not, it will reject, and as a result, so will N and then P. Otherwise, It will start to simulate DFAR over the first string w(i) of W (where i=0,1,2... n\xb0 last input string). If DFAR accepts, M halts in the accept state, and so will N and then P. Otherwise M will continue to loop through all the strings of W. If it reaches the last w(i) and it is not accepted, M will halt in the refect state and so will N and then P.</p>\n\n<p>My fear is that the number of strings to be tested is infinite, so M could enter in a loop?</p>\n', 'ViewCount': '52', 'Title': 'Decidability of an regular expression', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:29:41.253', 'LastEditDate': '2014-01-25T16:29:41.253', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13113', 'Tags': '<computability><regular-languages><undecidability>', 'CreationDate': '2014-01-24T23:42:36.657', 'Id': '19952'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have two questions about how to use pumping lemma for regular languages to show that two languages are not regular. I would appreciate if someone can confirm if my answers make sense, and if not, what needs to be done</p>\n\n<p>1) Prove that the following languages aren't regular. You can use the pumping lemma and the closing of the class of the regular languages under union, intersection and complement.</p>\n\n<p>a) $L_1 = \\{w \\in \\{0,1\\}^* \\mid w  \\text{ is not a palindrome}\\}$</p>\n\n<p><strong>My solution</strong>: Pick up w as the string $010010$. $x = \\varepsilon$, $y = 01$ and $z = 0010$. By the pumping lemma the string $xyyz$ should also be regular. However $xyyz = 01010010$ which is not a palindrome. So, by contradiction, $L_1$ is not a regular language.</p>\n\n<p>b) $L_2 = \\{ wtw \\mid w,t \\in \\{0,1\\}^* \\}$</p>\n\n<p><strong>My solution</strong>. Pick up w as the string $0101$ and pick up $t=011$ as the other string. So $wtw= 0101\\ 011\\ 0101$ which belongs to $\\{0,1\\}$. By the pumping lemma, the string $xyyz$ should also be regular. However, choosing $y=110$ of $010\\ 0|11\\ 0|0101$, the string $0101\\ 011\\ 110\\ 0101$ is produced which cannot be generated by $wtw$. So, by contradiction, $L_2$ is not a regular language.</p>\n\n<p>Many thanks to any help.</p>\n", 'ViewCount': '15', 'ClosedDate': '2014-01-25T16:42:58.197', 'Title': 'Pumping lemma with two r languages', 'LastEditorUserId': '9612', 'LastActivityDate': '2014-01-25T13:44:52.967', 'LastEditDate': '2014-01-25T13:44:52.967', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13113', 'Tags': '<regular-languages>', 'CreationDate': '2014-01-24T23:50:05.733', 'Id': '19953'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've been watching lectures from Coderisland on YouTube about finite state machines, DFAs and NFAs, and in one discussion he talks about how to use the pumping lemma to show how a language is not regular. I don't know quite how to apply the lemma and want to understand if I'm doing it right. If I had something like:</p>\n\n<p><strong>w</strong> = {a<sup>n</sup>b<sup>k</sup>, n =/= k}</p>\n\n<p>am I correct in that I can say that:</p>\n\n<p><strong>h</strong> = {a<sup>n</sup>b<sup>n + r</sup>, r > 0} is a subset of <strong>w</strong>, and thus if I show by the lemma that <strong>h</strong> is not regular, that <strong>w</strong> must not be regular since <strong>h</strong> is a subset of <strong>w</strong>.</p>\n\n<p>The way I would show this is as follows:</p>\n\n<ol>\n<li>h = xyz</li>\n<li>|xy| &lt;= n</li>\n<li>x = a<sup>n-r</sup></li>\n<li>y = a<sup>r</sup></li>\n<li>z = b<sup>n + r</sup></li>\n<li>xyz = a<sup>n-r</sup>a<sup>r</sup>b<sup>n + r</sup></li>\n<li>xy<sup>2</sup>z = a<sup>n-r</sup>a<sup>2r</sup>b<sup>n + r</sup> = a<sup>n + r</sup>b<sup>n + r</sup></li>\n</ol>\n\n<p>Thus <strong>h</strong> cannot be regular since a<sup>n + r</sup>b<sup>n + r</sup> is not of the form {a<sup>n</sup>b<sup>n + r</sup>, r > 0}, and since <strong>h</strong> is not regular <strong>w</strong> must not be regular, since <strong>h</strong> is an element of <strong>w</strong>.</p>\n\n<p>Have I applied it correctly? I understand how to apply it for an easy language like {a<sup>n</sup>b<sup>n</sup>}, because I can apply the lemma directly to this language, but the only way I could think of for my language was to create a subset that belongs to my language, and apply the lemma to that.</p>\n\n<p>If I haven't applied it correctly, is there a way to show that my language is not regular (or regular), using another lemma, or perhaps with closure properties?</p>\n\n<p>This is a really awesome topic, even if I don't understand the pumping lemma fully, I'm excited to explore it further!</p>\n", 'ViewCount': '71', 'Title': 'Is this the correct way to use the pumping lemma?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T11:38:01.893', 'LastEditDate': '2014-01-26T11:38:01.893', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13139', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-01-26T05:49:22.287', 'Id': '19985'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $A$ be some alphabet.</p>\n\n<p>$A$ itself is a regular language.</p>\n\n<p>$E = A^*$ is regular language over $A$. $E$ is a superset of all languages over $A$, regular or otherwise, i.e $E$ contains every possible string from symbols of $A$.</p>\n\n<p>Now let $L$ be some regular language over $A$.</p>\n\n<p>What is $\\tilde{L} = L \\cdot E$ ? More specifically, how $\\tilde{L}$ and $E$ relate to each other? Are they equal? Is one subset of the other? Something else?</p>\n\n<p>Source of the confusion is the following reasoning: closure under concatenation says that $\\tilde{L}$ is a regular language and therefore $\\tilde{L} \\subseteq E$  (according to the above). On the other hand $\\tilde{L}$ seems to contain strings $E$ does not, i.e. those that are formed by concatenating non-empty string from both languages.</p>\n\n<p>Obviously this is wrong. What is going on here?</p>\n', 'ViewCount': '80', 'Title': 'Regular language concatenation with superset', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-29T18:36:17.587', 'LastEditDate': '2014-01-29T17:16:31.227', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '20075', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12837', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-01-29T16:10:18.927', 'Id': '20069'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know that <code>(1 + 0)*</code> is the set of all bit strings; but isn't  <code>1* + 0*</code> the same thing?</p>\n", 'ViewCount': '797', 'Title': 'Difference between 1* + 0* and (1 + 0)*', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T13:43:32.987', 'LastEditDate': '2014-02-03T09:31:45.900', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '20236', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<formal-languages><terminology><regular-languages><regular-expressions>', 'CreationDate': '2014-02-03T03:58:32.153', 'Id': '20235'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>There is something in the pumping lemma that I do not quite understand, namely if $s$ is at least of length $p$, then we could split it to $xyz$ such that the following conditions are met:</p>\n\n<ol>\n<li>For each $i \\geq 0$, $x(y^i)z \\in A$</li>\n<li>$|y| &gt; 0$</li>\n<li>$|xy| \\leq p$</li>\n</ol>\n\n<p>But if $i = 0$ then $|y|$ cannot be strictly greater than $0$. Isn't condition 1 contradicting condition 2? Isn't $y^0 = \\varepsilon$?</p>\n", 'ViewCount': '72', 'Title': u'How can both |y| = 0 and y\u2070 = \u03b5 hold in the Pumping lemma?', 'LastEditorUserId': '13175', 'LastActivityDate': '2014-02-05T12:45:29.647', 'LastEditDate': '2014-02-04T14:29:29.727', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13175', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-02-04T05:08:56.827', 'Id': '21277'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '80', 'Title': 'Proving that {0^{2^k}} is not regular with the Myhill-Nerode theorem', 'LastEditDate': '2014-02-12T20:26:14.113', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13139', 'Body': "<p>My language is the repetition of 0 to a length that's a power of 2:</p>\n\n<p>$L = \\{ 0^k \\ni k=2^n, n \\geq 1 \\}$</p>\n\n<p>I want to know how to prove that this language is not regular. I have attempted the proof below, but think it may be incorrect due to my potentially wrong assumption that the Myhill-Nerode theorem allows me to break up a regular language in the following way:</p>\n\n<p>$j, p = 2^h$ for 2 distinct values of $h$, $h \\in \\mathbb{N}$:</p>\n\n<p>$a = 0^{j/2}$</p>\n\n<p>$b = 0^{p/2}$</p>\n\n<p>$c = 0^{j/2}$</p>\n\n<p>$ac = 0^{j/2}0^{j/2} = 0^j$ is in my language since $j$ is of the form $2^n$</p>\n\n<p>$bc = 0^{p/2}0^{j/2}$ is not guaranteed to be in my language for every $p$ and $j$, since $j \\ne p$</p>\n\n<p>Thus my language must not be regular since $ac$ is in it but $bc$ is not.</p>\n\n<p>Did I apply the Myhill-Nerode correctly? If not, what do I need to change in my proof?</p>\n", 'ClosedDate': '2014-02-16T17:54:49.657', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-02-12T20:42:17.610', 'CommentCount': '3', 'AcceptedAnswerId': '21578', 'CreationDate': '2014-02-04T21:48:54.480', 'Id': '21301'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>CFG can specify structure of sentences but Regular grammar can only specify strings sequentially. Is it because DFA has only one bit memory?</p>\n', 'ViewCount': '63', 'ClosedDate': '2014-02-05T08:02:49.107', 'Title': 'Why CFG can specify structure of sentence but Regular grammar cannot?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-06T16:05:53.983', 'LastEditDate': '2014-03-06T16:05:53.983', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<regular-languages><context-free><formal-grammars><strings>', 'CreationDate': '2014-02-05T01:52:36.737', 'Id': '21306'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In general, how can we go about proving that union of two languages as non regular. In this case, the individual languages can be proved as non regular using pumping lemma. How can we apply pumping lemma to union of two languages ?</p>\n', 'ViewCount': '133', 'ClosedDate': '2014-02-06T10:25:42.827', 'Title': u'Prove that the language L = {a^(m+n) b^m a^n | m, n \u2265 0} \u222a {a^m b^n a^(m+n) | m, n \u2265 0} is not regular', 'LastEditorUserId': '55', 'LastActivityDate': '2014-02-06T03:30:57.917', 'LastEditDate': '2014-02-06T03:30:57.917', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'littlecegian', 'PostTypeId': '1', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2014-02-05T09:09:29.763', 'Id': '21348'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm working on homework for my formal languages and automata course. The text we are using is the first edition of Hopcroft and Ullman (1979). </p>\n\n<p>Specifically, I'm unsure how to justify that my regular expression for exercise 2.10 (c) is correct. The question asks for a regular expression for the set of all strings <strong>not</strong> containing the substring 101 (over the alphabet $\\{0, 1\\}$). Additionally, it asks for justification that the regular expression you write is correct. </p>\n\n<p>I came up with the regular expression \n$$0^*1^*0^* + (1 + 00 + 000)^* + 0^+1^+0^+.$$</p>\n\n<p>As for the justification, what exactly are they looking for?</p>\n", 'ViewCount': '69', 'ClosedDate': '2014-02-23T08:31:47.153', 'Title': 'Proving a regular expression is correct', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-09T22:51:10.453', 'LastEditDate': '2014-02-09T22:51:10.453', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14510', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-02-08T21:35:14.527', 'Id': '21458'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>My language is the repetition of 0 to a length that's a power of 2:</p>\n\n<p>$L = \\{ 0^k \\mid k=2^n, n \\geq 1 \\}$</p>\n\n<p>I want to know how to use the Myhill-Nerode theorem to show that this language is not regular.</p>\n\n<p>This is my first attempt at doing this although I am confident that I am wrong:</p>\n\n<p>$j, p = 2^h$ for 2 distinct values of $h$, $h \\in \\mathbb{N}$:</p>\n\n<p>$a = 0^{j/2}$</p>\n\n<p>$b = 0^{p/2}$</p>\n\n<p>$c = 0^{j/2}$</p>\n\n<p>$ac = 0^{j/2}0^{j/2} = 0^j$ is in my language since $j$ is of the form $2^n$</p>\n\n<p>$bc = 0^{p/2}0^{j/2}$ is not guaranteed to be in my language for every $p$ and $j$, since $j \\ne p$</p>\n\n<p>Thus my language must not be regular since $ac$ is in it but $bc$ is not.</p>\n", 'ViewCount': '41', 'Title': 'How do I use the Myhill-Nerode theorem to show that a language is not regular?', 'LastEditorUserId': '9612', 'LastActivityDate': '2014-02-11T11:07:04.730', 'LastEditDate': '2014-02-11T11:07:04.730', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13139', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-02-10T17:56:08.263', 'Id': '21499'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a question regarding regular languages. Given that $L_1$ and $L_2$ are non-regular languages, can a regular language $L$ exist so it is a subset of $L_2$ and $L_1$ subset of $L$?</p>\n\n<p>To be more specific:</p>\n\n<p>$\\qquad L_1 \\subset L \\subset L_2$</p>\n\n<p>for $L_1, L_2$ non-regular Languages.</p>\n', 'ViewCount': '61', 'Title': 'Are there regular languages between every two non-regular languages?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-12T07:56:10.523', 'LastEditDate': '2014-02-12T07:56:10.523', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '21534', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13168', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-02-11T17:32:23.910', 'Id': '21531'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am having hard time solving the following problem.</p>\n\n<blockquote>\n  <p>Are there any languages for which\n  $$\n\\overline{L^*} = (\\overline{L})^*\n$$</p>\n</blockquote>\n\n<p>Assuming $\\emptyset^* = \\emptyset$, if I consider $\\Sigma = \\{a\\}$ and L = $\\Sigma^*$, I get that $L^* = L$ and that $\\overline{L^*} = \\emptyset$. For the right side I get $\\overline{L} = \\emptyset$ and $(\\overline{L})^* = \\emptyset$. Thus, both sides are equal. </p>\n\n<p>Is it true that $\\emptyset^* = \\emptyset$?</p>\n', 'ViewCount': '118', 'Title': 'Do Kleene star and complement commute?', 'LastEditorUserId': '14587', 'LastActivityDate': '2014-02-23T20:11:13.703', 'LastEditDate': '2014-02-23T20:11:13.703', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21549', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14587', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-02-11T23:09:29.767', 'Id': '21544'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following context-free language:</p>\n\n<pre><code>S -&gt; ASa | b\nA -&gt; aA | a\n</code></pre>\n\n<p>I don't understand why this is not regular. I first said that it's generated by the regular expression <code>a+ba+</code>. The following is regular however</p>\n\n<pre><code>S -&gt; ASa | b\nA -&gt; aA | e\n</code></pre>\n\n<p>e stands for the empty string. I don't understand their differences.</p>\n", 'ViewCount': '67', 'Title': 'Context-free language and regular expressions', 'LastActivityDate': '2014-02-14T12:23:00.497', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '12066', 'Tags': '<regular-languages><context-free><regular-expressions>', 'CreationDate': '2014-02-14T09:43:23.857', 'Id': '21629'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I know that each regular language can be generated by a CFG.\nThis makes, in one sense at least: context-free languages more general than regular languages.</p>\n\n<p>Are there known results about the 'complexity' of regular languages in the CFG context? For example, is it true that every regular language can be generated by an unambiguous LL(1) grammar?  Or is something similar true?</p>\n\n<p>The general question above comes from the attempts I made to build a 'simple' grammar generating $L=\\{(ab)^i|(ba)^i : i\\geq 0\\}$.\nNone of the grammars I could build were 'simple'.</p>\n", 'ViewCount': '75', 'Title': 'Complexity of CFG grammar for a regular language', 'LastEditorUserId': '755', 'LastActivityDate': '2014-02-16T07:57:05.730', 'LastEditDate': '2014-02-16T07:57:05.730', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14695', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2014-02-15T13:36:39.660', 'Id': '21663'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need help constructing a Left Linear grammar for the language</p>\n\n<p>$L = \\{ a^n b^m c^p \\mid n\\geq 2, m\\geq 3, p\\geq 4 \\}$</p>\n\n<p>Here is what I have so far, I know :</p>\n\n<p>$N = \\{S\\}$</p>\n\n<p>$T = \\{ a, b, c \\}$</p>\n\n<p>$P = \\{$</p>\n\n<p>$S \\rightarrow Pcccc$</p>\n\n<p>$P \\rightarrow Pc$</p>\n\n<p>$P \\rightarrow M$</p>\n\n<p>$M \\rightarrow Mbbb$</p>\n\n<p>$M \\rightarrow Mb$</p>\n\n<p>$M \\rightarrow N$</p>\n\n<p>$N \\rightarrow Naa$</p>\n\n<p>$N\\rightarrow a$</p>\n\n<p>$\\}$</p>\n\n<p>I need help figuring out the productions. I am not sure if I am doing it right.</p>\n', 'ViewCount': '40', 'Title': 'Left Linear Grammar: How to construct?', 'LastEditorUserId': '1636', 'LastActivityDate': '2014-02-17T07:07:05.667', 'LastEditDate': '2014-02-17T06:41:17.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14744', 'Tags': '<formal-languages><regular-languages><formal-grammars>', 'CreationDate': '2014-02-17T05:23:46.860', 'Id': '21722'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '100', 'Title': 'Prove that languages which contain words whose lengths are multiples of a constant are regular', 'LastEditDate': '2014-02-18T08:49:52.853', 'AnswerCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14596', 'FavoriteCount': '0', 'Body': '<p>This is a problem involving the theory of regular languages.  I am stuck on this problem and do not know how to solve this type of problem.  </p>\n\n<blockquote>\n  <p>Prove that the language $B_n = \\{ a^k \\mid k \\text{ is a multiple of } n \\}$ is a regular language for any $n \\ge 1$.</p>\n</blockquote>\n\n<p>Let me describe my thoughts thus far:  It is easy to show that for $n=1$, we have $B_1 = \\{a\\}$.</p>\n\n<p>In other words, a regular expression can easily be built for the value of $n=1$, and thus for any $k$.</p>\n', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-02-18T15:02:52.500', 'CommentCount': '2', 'AcceptedAnswerId': '21747', 'CreationDate': '2014-02-18T00:53:50.407', 'Id': '21746'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $L = \\{a^n \\mid n \\ge 0\\}$, where $a^0 = \\epsilon$ and $a^n = a^{n-1}a$ for all $n \\ge 1$.</p>\n\n<p>Thus $L$ consists of sequences of $a$ of all lengths, including a sequence\nof length $0$. Let $L_2$ be any infinite subset of $L$. I need to show there always exists a DFA to recognize $L_2^*$. </p>\n\n<p>If $L_2$ is a finite subset it is very obvious as $L_2$ would be a DFA and hence by Kleene closure $L_2^*$ would be recognized by a DFA. But I am unable to get it for infinite subset as $L_2$ may not be expressed as DFA when, e.g., string lengths are prime.</p>\n', 'ViewCount': '165', 'Title': 'Kleene star of an infinite unary language always yields a regular language', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-18T16:47:56.060', 'LastEditDate': '2014-02-18T16:47:56.060', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '21775', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13212', 'Tags': '<formal-languages><regular-languages><closure-properties>', 'CreationDate': '2014-02-18T14:05:22.823', 'Id': '21765'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Describe a regular language that cannot be accepted by any DFA that has only three states.</p>\n</blockquote>\n\n<p>I'm not really sure where to start on this and was wondering if someone could give me some tips or advice. I understand that the pumping lemma can be used to prove a language is not regular, but in this case, it should be a regular language. If anyone has any thoughts it would be appreciated.</p>\n", 'ViewCount': '512', 'Title': 'Regular language not accepted by DFA having at most three states', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-30T02:24:06.250', 'LastEditDate': '2014-03-29T11:53:14.010', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '14857', 'Tags': '<formal-languages><regular-languages><finite-automata><pumping-lemma>', 'CreationDate': '2014-02-19T22:05:01.387', 'FavoriteCount': '1', 'Id': '21826'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Context-free grammars, as well as other types of grammars, can naturally\nassociate structure with the strings of the defined language, for\nexample tree structures in the case of context-free language.</p>\n\n<p>What kind of structural features can be thus described by regular grammars,\nand associated with the strings of the language.</p>\n\n<p>One answer is of course that it can associate a non-terminals with\neach prefix (or suffix) of the string. That sorts the prefixes (or\nsuffixes) into sets that may intersect, depending on the grammar.\nBut what else would you see?</p>\n\n<p>related question : <a href="http://cs.stackexchange.com/questions/21306">Why CFG can specify structure of sentence but Regular grammar cannot?</a></p>\n', 'ViewCount': '38', 'Title': 'What kind of structural features of strings can be described by regular grammars?', 'LastActivityDate': '2014-02-20T16:22:49.207', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars><syntax-trees>', 'CreationDate': '2014-02-20T16:22:49.207', 'Id': '21852'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am struggling with this question for a very long time and just can\'t find the flaw. So I am given a false Theorem:</p>\n\n<blockquote>\n  <p>The language ${awwa \\mid w \\in {a,b}^* }% is regular.</p>\n</blockquote>\n\n<p>Well, that part is obvious, we can prove it using the pumping lemma.</p>\n\n<p>The question I am asked is to find the flaw in the "proof" for this theorem:</p>\n\n<blockquote>\n  <p>Let</p>\n  \n  <p>$\\qquad L_1 = \\{ aw \\mid w \\in \\{a,b\\}^* \\}$</p>\n  \n  <p>$\\qquad L_1^R = \\{ aw \\mid w \\in \\{a,b\\}^* \\}$</p>\n  \n  <p>Let $L_2 = L_1 L_1^R = \\{ awwa \\mid w \\in \\{a,b\\}^*\\}$ be even-length palindromes that begin and end with an $a$.\n  Since $L_1$ is regular, and the class of regular languages is closed under reversal and concatenation, we conclude $L_2$ is also regular.</p>\n</blockquote>\n\n<p>Can you find the flaw? I could build a DFA for $L_1$ and $L_1^R$, so I know they are regular. And regular languages are closed under reversal and concatenation.</p>\n\n<p>But, however, $L_2$ is still not regular, so where is the mistake in the "proof"?</p>\n', 'ViewCount': '83', 'Title': 'A flawed theorem about regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-21T11:50:18.730', 'LastEditDate': '2014-02-21T11:50:18.730', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14896', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-02-21T01:27:47.970', 'Id': '21868'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm struggling a bit to understand two of the problems we were given in class. Could someone look over my work and maybe give me a few hints?</p>\n\n<p>State whether the following languages are regular or not and prove your answer.\n$$\\{0^n1^m \\mid m \\geq 0 \\text{ and } n = 2m+1\\}$$\n$$\\{0^a1^b0^c \\mid 0 \\leq a \\leq b \\leq c \\leq 100\\}$$</p>\n\n<p>The first one appears to me as non-regular as $m$ is not finite. Then to prove that it is not regular, I used the pumping lemma method with $0^P1^\\frac{P-1}{2}$ as the string. </p>\n\n<p>For the second language, I'm not really sure if it is regular or not. I can't come up with a DFA/NFA/RegExp for it nor can I figure out how to apply the pumping lemma method to it. Is it safe to use $0^P1^P0^P$ as the string and say that if $Y$ where $Y = 0^k, 1 \\leq k \\leq P$ is appears more than once (i.e. $XYYZ$), the resulting string is not in the language and thus the language is not regular?</p>\n\n<p>Edit: I'm sorry if this question seems elementary. I've already read through most of the posts pertaining to this topic and some things were unclear to me. I was asking for someone to look over my work and make sure I followed the correct procedures. For instance, I'm still confused on the second question. The pumping lemma I used makes it seem like it is not regular but at the same time it is finite. Does that mean I used pumping lemma incorrectly? In what way did I use it incorrectly?</p>\n", 'ViewCount': '43', 'ClosedDate': '2014-02-23T10:20:00.590', 'Title': 'Proving a language is regular or non-regular', 'LastEditorUserId': '14950', 'LastActivityDate': '2014-02-23T22:41:04.843', 'LastEditDate': '2014-02-23T22:41:04.843', 'AnswerCount': '0', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14950', 'Tags': '<regular-languages><pumping-lemma>', 'CreationDate': '2014-02-23T01:36:29.023', 'Id': '21935'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose $L1, L2$ are both regular languages and $A1, A2$ are their corresponding DFA's.\nHow can I construct a new DFA for the regular language $L1 \\cup L2$?</p>\n", 'ViewCount': '53', 'Title': "Given 2 regular languages and their DFA's, how to construct the DFA of the union?", 'LastActivityDate': '2014-02-24T20:35:30.693', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '22001', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14999', 'Tags': '<regular-languages><finite-automata>', 'CreationDate': '2014-02-24T20:04:23.093', 'Id': '22000'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Here is the problem:</p>\n\n<p>Prove the single-tape TM that cannot write on the portion of the tape containing the input string recognize only regular language. </p>\n\n<p>My idea is to prove that this particular TM is equivalent to DFA. </p>\n\n<p>Using this TM to simulate DFA is very straightforward. </p>\n\n<p>However, when I want to use this DFA to simulate TM, I encounter the problem. For the TM transition $\\delta(q,a)=(q',a,R)$, DFA can simulate definitely by reading tape to the right and doing the same state transition. </p>\n\n<p>For $\\delta(q,a)=(q',a,L)$, I cannot figure out how to use this DFA or NFA to simulate the left move because the DFA only reads to left and has no stack or something to store.</p>\n\n<p>Should I consider another way? Could anyone give me some hints? Thanks. </p>\n", 'ViewCount': '56', 'Title': 'Prove Single-Tape and Non-write Turing Machine can Only Recognize Regular Language?', 'LastActivityDate': '2014-02-27T06:41:33.020', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14400', 'Tags': '<formal-languages><computability><regular-languages><turing-machines><automata>', 'CreationDate': '2014-02-27T06:41:33.020', 'Id': '22082'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm studying for my exam and I came across the following exam question from last year, the only way I know how to solve this is build a regex that accounts for all six different series of letters so for example to recognize a string that has the letters a,b and c occur in that order:</p>\n\n<p>$(a+b+c)^*a(a+b+c)^*b(a+b+c)^*c$</p>\n\n<p>The question:\nGive a regular expression r over the alphabet A = {a, b, c} such that the\nlanguage determined by r consists of all strings that contain at least one occurrence of each symbol in A. Brie\ufb02y explain your answer.</p>\n", 'ViewCount': '114', 'Title': 'Regular expression to show that all strings contain each symbol atleast once', 'LastActivityDate': '2014-03-03T23:35:17.363', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22243', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15249', 'Tags': '<regular-languages><regular-expressions>', 'CreationDate': '2014-03-03T23:04:17.677', 'Id': '22242'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Suppose we have two language</p>\n\n<pre><code>L = {0^n|n&gt;=0}\nM = {1^n|n&gt;=0}\n</code></pre>\n\n<p>We know both of these are regular languages.</p>\n\n<p>Will L.M (concatenation) be a regular language? Please explain your answer and if yes then what will be its expression?</p>\n\n<p>Thanks for any help in advance.</p>\n\n<p>Adding to it, we know that language {o^n1^n|n>=0} isn't a regular language</p>\n", 'ViewCount': '55', 'ClosedDate': '2014-03-08T06:42:09.453', 'Title': 'Concatenation of regular languages', 'LastEditorUserId': '9550', 'LastActivityDate': '2014-03-06T03:26:05.600', 'LastEditDate': '2014-03-04T08:37:41.347', 'AnswerCount': '4', 'CommentCount': '4', 'Score': '-3', 'PostTypeId': '1', 'OwnerUserId': '15253', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-03-04T02:37:25.230', 'Id': '22250'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I am working on a pumping lemma question and trying to prove that the following is not regular, but I can't finish the proof, if someone can help me it will be great.</p>\n\n<p>So I am given this language: \n$L = \\{ a^n | n = 3^k , k\u22650 \\}$ .\nOk. I choose $w = a^{3^m}$. I know for sure that $y = a^t$ ($y$ must be any number or $a$'s), where $t\u22651$. $x = a^{(3^m)-t}$ and $y = a^t$. I pump twice, so $i =2$ and  $xy = a^{(3^m)+t}$.</p>\n\n<p>Now, is this enough to finish the proof? What is my $xyz$? and how do I prove that my $w$ is not in the language?\nThank you so much for whoever decide to help me out!</p>\n", 'ViewCount': '65', 'ClosedDate': '2014-03-08T06:42:50.470', 'Title': u'Pumping lemma on {a^n | n=3^k} \u2014 help finishing the proof', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-06T18:51:30.940', 'LastEditDate': '2014-03-06T18:51:30.940', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15347', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'CreationDate': '2014-03-06T15:21:03.270', 'Id': '22341'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '51', 'Title': 'Using the pumping lemma for a proof by contradiction', 'LastEditDate': '2014-03-07T07:15:01.397', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15365', 'FavoriteCount': '0', 'Body': u"<p>I'm trying to prove that the set of even-length strings with the two middle symbols being equal cannot be accepted by finite automata.  I can explain why it cannot be accepted intuitively, but I'm having trouble with the proof.  Our symbols are {a, b}.</p>\n\n<p>I allowed L = $\\{(ab)^{*{\\frac{n}{2} - 1}} aa (ab)^{*{\\frac{n}{2} - 1}}\\}$.  I know the format of the language is wonky, and will be talking to my professor about it tomorrow.  For the proof, I allowed $\\frac{n}{2} - 1$ to be the combination of symbols before and after the two elements.  So, using the Pumping Lemma's condition that |uv|\u2264 n, I allowed $u = \\frac{n}{2} -1$  and $v = n^2$ (for aa); this is obviously greater than n, but I'm having trouble understanding how to choose $u$ and $v$.  Is my assignment for these parameters correct?</p>\n", 'ClosedDate': '2014-04-01T22:08:50.070', 'Tags': '<formal-languages><regular-languages><pumping-lemma>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-07T07:15:01.397', 'CommentCount': '5', 'CreationDate': '2014-03-06T22:45:34.737', 'Id': '22356'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '36', 'Title': 'Proving a language is not a regular language but a context free language', 'LastEditDate': '2014-03-17T23:09:15.107', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': "<p>I have the languages $L_1$ and $L_2$ such that $L_1 = \\{a^nba^n :n \\in N\\}$ and $L_2 =\\{a,b\\}^*\\setminus L_1$.</p>\n\n<p>I want to prove that $L_2$ is not a regular language. I know that to prove that $L_2$ is not a regular language I can use the pumping lemma but I'm unsure about the details.</p>\n\n<p>I also want to prove that $L_2$ is a context free language. Do I need a Push Down Automaton that accepts the language to prove that $L_2$ is a context free language? If so, what would this Push-Down Automaton look like?</p>\n", 'ClosedDate': '2014-03-18T07:47:52.957', 'Tags': '<formal-languages><regular-languages><context-free><pushdown-automata>', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-03-17T23:28:09.877', 'CommentCount': '1', 'AcceptedAnswerId': '22731', 'CreationDate': '2014-03-17T22:36:34.083', 'Id': '22727'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '56', 'Title': 'Complexity of Languages', 'LastEditDate': '2014-03-25T04:27:11.867', 'AnswerCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>1) Find language $L_1 \\subseteq L_2 \\subseteq L_3$ such that both $L_1$ and $L_3$ are not context-free languages, but $L_2$ is a regular language.</p>\n\n<p>2) Find language $L_1 \\subseteq L_2 \\subseteq L_3$ such that both $L_1$ and $L_3$ are regular languages but $L_2$ is not context-free.</p>\n\n<p>I understand that context-free grammars are strictly more powerful than regular expressions and any language that can be generated using regular expressions can be generated by a context-free grammar. I am also aware that there are languages that can be generated by a context-free grammar that cannot be generated by any regular expression. </p>\n', 'ClosedDate': '2014-03-18T08:13:19.247', 'Tags': '<formal-languages><regular-languages><context-free>', 'LastEditorUserId': '15798', 'LastActivityDate': '2014-03-25T04:27:11.867', 'CommentCount': '8', 'CreationDate': '2014-03-18T04:58:43.450', 'Id': '22747'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '47', 'Title': 'If neither $L_1$ nor $L_2$ are context free then is $L_1 \\cup L_2$ also not a context free language?', 'LastEditDate': '2014-03-18T21:37:36.353', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>If two regular languages $L_1$ and $L_2$ are both <strong>not</strong> context free languages then is $L_1 \\cup L_2$ also <strong>not</strong> a context free?</p>\n\n<p>I am aware that if $L_1$ and $L_2$ are context free languages then the language $L_1 \\cap L_2$ is also context free but cannot quite connect the dots. If someone could help out that would be great.</p>\n', 'ClosedDate': '2014-03-19T00:05:02.747', 'Tags': '<formal-languages><regular-languages><context-free>', 'LastEditorUserId': '15798', 'LastActivityDate': '2014-03-18T23:07:04.487', 'CommentCount': '2', 'AcceptedAnswerId': '22774', 'CreationDate': '2014-03-18T21:09:11.070', 'Id': '22772'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I was wondering if this language is context-free:</p>\n\n<p>$L = \\{ x \\in \\{ 0, 1 \\}^* : |x| = 2^n $ for some natural number n $\\}$ </p>\n\n<p>I know that this language is not regular because it fails the pumping lemma for regular languages but that does not necessarily mean it is not context-free. I'm not sure whether to use the pumping lemma for context-free languages to show that this is not context free or to provide context-free grammar to show that it is context free.</p>\n\n<p>I've tried creating a context-free grammar to generate this language but ran into trouble which makes me believe that this language is not context-free, but I am still unsure.</p>\n\n<p>If someone could point me in the right direction that would be greatly appreciated.</p>\n", 'ViewCount': '48', 'Title': 'Is $L = \\{ x \\in \\{ 0, 1 \\}^* : |x| = 2^n $ for some natural number n $\\}$ context free?', 'LastEditorUserId': '15798', 'LastActivityDate': '2014-03-20T04:21:16.400', 'LastEditDate': '2014-03-20T04:11:22.023', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22851', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2014-03-20T03:57:01.143', 'Id': '22850'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm having trouble generating the set of strings, which a regular expressions describe.\nA typical regular expression can look like this:</p>\n\n<pre><code>[atom_0] atom_1 (atom_2 | atorm_3 | ... | atom_n-1) &lt;var&gt; [atom_n]\n</code></pre>\n\n<p>Or any other combination of the following:</p>\n\n<pre><code>[], means, that the atom inside of it can be omitted\n(), one of the atoms (seperated by | (stands for OR)) inside the braces can be chosen \n&lt;&gt;, variable.\natom, it can be thought as a constant, which is hard coded.\n</code></pre>\n\n<p>For example: </p>\n\n<pre><code>The [yellow] (dog | cat) named &lt;animalName&gt;\n</code></pre>\n\n<p>This expression describes the following set of strings:</p>\n\n<pre><code>The yellow dog named &lt;animalName&gt;;\nThe yellow cat named &lt;animalName&gt;;\nThe dog named &lt;animalName&gt;;\nThe cat named &lt;animal Name&gt;;\n</code></pre>\n\n<p>The strings can vary, depending on the variable <code>&lt;animalName&gt;</code>, but say, we have two names for <code>&lt;variableName&gt;</code> : <code>Petsy</code> and <code>Rony</code>, then w'll have:</p>\n\n<pre><code>The yellow dog named Petsy;\nThe yellow cat named Petsy;\nThe dog named Petsy;\nThe cat named Petsy;\nThe yellow dog named Rony;\nThe yellow cat named Rony;\nThe dog named Rony;\nThe cat named Rony;\n</code></pre>\n\n<p>Right now, I'm thinking that I could build a tree (or graph) from the expression and then a DFS or BFS can do the job.</p>\n\n<p>Any comments or document/article references would be helpful to me.</p>\n", 'ViewCount': '67', 'Title': 'Generating all strings that a regular expressions describe', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T22:34:20.143', 'LastEditDate': '2014-03-22T11:24:02.187', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '22936', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15992', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-03-22T08:30:22.847', 'Id': '22931'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '59', 'Title': 'If $L_1$ is regular and $L_1 \\cap L_2$ context-free, is $L_2$ always context-free?', 'LastEditDate': '2014-03-24T11:49:13.320', 'AnswerCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': '<p>If $L_1$ is a regular language and $L_1 \\cap L_2$ is a context-free language, does it mean that $L_2$ is a context-free language too?</p>\n\n<p>I attempted to prove that $L_2$ was not required to be context-free by the following: If $L_1 = \\{ a^n \\}$ and $L_2 = \\{ a^nb^nc^n \\} $ then $L_1 \\cap L_2 = \\{ a^n \\}$ which is context-free. </p>\n\n<p>Is this a counterexample to show that $L_2$ is not required to be context-free? If not, then do you have any suggestions?</p>\n', 'ClosedDate': '2014-03-25T18:31:23.090', 'Tags': '<formal-languages><regular-languages><context-free><closure-properties>', 'LastEditorUserId': '31', 'LastActivityDate': '2014-03-24T11:49:13.320', 'CommentCount': '3', 'CreationDate': '2014-03-24T09:23:43.800', 'Id': '22991'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to show that for any language $L \\subseteq \\{ a \\}^* $, $L$ satisfies the pumping lemma for context free languages if and only if it satisfies the pumping lemma for regular languages.</p>\n\n<p>I know that every regular language is also a context free language so I tried to show that direction of the proof first but ran into some difficulties. </p>\n\n<p>Is there a more logical approach to this? Would I have to show that the conditions for both the pumping lemma for regular languages and the pumping lemma for context free grammars are equivalent for this language? </p>\n', 'ViewCount': '62', 'Title': 'Show that the pumping lemmas for context-free and regular languages are equivalent for unary languages', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-26T17:35:18.490', 'LastEditDate': '2014-03-26T08:47:34.693', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '23091', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15798', 'Tags': '<formal-languages><regular-languages><context-free><pumping-lemma>', 'CreationDate': '2014-03-26T06:50:32.380', 'Id': '23064'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I want to prove that a language is not $\\omega$-regular. </p>\n\n<p>The language I\'m working with can be defined as:</p>\n\n<p>$$L = \\{ a_1 \\dots a_n x^\\omega ~ | ~ n &gt; 0, a_1 \\dots a_n \\in L^\\prime \\}$$</p>\n\n<p>where $L^\\prime$ is a specific non regular language (I omit the definition $L^\\prime$ because I think it is of no help for my problem), $a_i$ are symbols in $L^\\prime$ alphabet and $x$ is any symbol not in $L^\\prime$ alphabet.</p>\n\n<p>I\'m aware of several proof techniques for proving a language is not regular (see e.g. <a href="http://cs.stackexchange.com/questions/1031/how-to-prove-that-a-language-is-not-regular">How to prove that a language is not regular?</a> ). </p>\n\n<p>Are there similar proof techniques for proving that a language is not $\\omega$-regular?</p>\n', 'ViewCount': '54', 'Title': u'Proving that the continuation of a non-regular language is not \u03c9-regular', 'LastEditorUserId': '14441', 'LastActivityDate': '2014-03-29T23:41:34.323', 'LastEditDate': '2014-03-29T23:41:34.323', 'AnswerCount': '1', 'CommentCount': '10', 'AcceptedAnswerId': '23235', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14441', 'Tags': '<formal-languages><regular-languages><proof-techniques><buchi-automata>', 'CreationDate': '2014-03-29T18:56:27.080', 'Id': '23227'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '73', 'Title': 'Is the language $\\{ a^pb^q \\mid p, q \\text{ are prime} \\}$ regular?', 'LastEditDate': '2014-03-31T18:52:02.587', 'AnswerCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '16317', 'Body': '<p>I am interested to know whether that language $$\nL = \\{ a^pb^q \\mid p, q \\text{ are prime} \\}\n$$ is regular. How do you prove that it is not regular?</p>\n', 'ClosedDate': '2014-03-31T11:40:37.320', 'Tags': '<formal-languages><regular-languages>', 'LastEditorUserId': '683', 'LastActivityDate': '2014-03-31T18:52:02.587', 'CommentCount': '2', 'AcceptedAnswerId': '23291', 'CreationDate': '2014-03-31T10:15:30.917', 'Id': '23290'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let A = $(Q, \\Sigma, \\delta, S, F)$ be a deterministic finite automaton associated with the language \n$L \\subseteq \\Sigma^*$ </p>\n\n<blockquote>\n  <p>$L' = \\{y \\in \\Sigma^*:\\exists x\\in L. |x| = |y|\\}$ </p>\n  \n  <p>$L \\subseteq L'$</p>\n</blockquote>\n\n<p>How do I show that there exist a NDFA associated with L' ? </p>\n", 'ViewCount': '35', 'Title': 'NDFA associated with language L', 'LastActivityDate': '2014-04-06T10:16:11.893', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16431', 'Tags': '<regular-languages><finite-automata><nondeterminism>', 'CreationDate': '2014-04-04T01:31:52.257', 'Id': '23407'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need a regular language $ L\\subseteq \\{0,1\\}^{*} $ so that $unary(L)$ is not context free.</p>\n\n<p>unary of $L$ is defined by:\n$$unary(L) = \\{0^{1x}  : x \\in L  \\}$$</p>\n\n<p>Example $L = \\{0, 11\\} $ $\\rightarrow  unary(L) = \\{00, 0000000\\}$ </p>\n\n<p>Any help would be great.</p>\n', 'ViewCount': '45', 'ClosedDate': '2014-04-07T06:08:51.163', 'Title': 'a regular language so that $unary(L) \\notin $Context Free Languages', 'LastActivityDate': '2014-04-06T21:26:39.920', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23486', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16502', 'Tags': '<formal-languages><regular-languages><context-free>', 'CreationDate': '2014-04-06T20:06:32.793', 'Id': '23484'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In my computation book by Sipser, he says that since every language that can be decided in time $o(n \\log n)$ is regular, then that can be used to show $TIME(n \\log (\\log n))\\setminus TIME(n)$ must be the empty set. Can anyone show me why this is?</p>\n\n<p>both $TIME(n\\log(\\log n))$ and $TIME(n)$ are regular. I think that only means we can subtract the two sets and the result will still be regular. I just dont understand how its possible to subtract the collection of $O(n\\log(\\log n))$ time TM decidable languages from the collection of $O(n)$ time TM decidable languages and get the empty set. These two collections are not equal so I feel like there will be something left over</p>\n', 'ViewCount': '100', 'Title': u'Why is TIME(n log (log n)) \\ TIME(n) = \u2205?', 'LastEditorUserId': '31', 'LastActivityDate': '2014-04-13T15:30:31.163', 'LastEditDate': '2014-04-13T15:30:31.163', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23726', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<complexity-theory><regular-languages><time-complexity><complexity-classes>', 'CreationDate': '2014-04-13T01:15:28.793', 'Id': '23721'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In proving Parikh's Theorem, my Theory of Computer Science textbook defines a linear set as:</p>\n\n<p>$u_0 + \\langle u_1, \\dots, u_m \\rangle = \\{u_0 + a_1u_1 + \\dots + a_mu_m \\mid a_1, \\dots, a_m \\in \\mathbb{N}\\}$ where $u_i$ are vectors of natural numbers.</p>\n\n<p>and a semi-linear set as a union of finitely many linear sets. It goes on to say ''For every semilinear set $S \\subset N^k$, it is not hard to construct a regular set $R \\subset \\Sigma^*$ such that $\\psi(R) = S$'' (where $\\psi$ is the Parikh map, taking strings over an alphabet $\\Sigma$ to vectors where the first entry is the number of the first letter, the second entry is the number of the second letter, etc. So $\\psi(\\{a, ab, ba, aaa\\})) = \\{(1), (1, 1), (3)\\}$.)</p>\n\n<p>I was trying to think why regular languages would be semi-linear instead of just linear, and it seems like the + (or) operation in regular expressions is to blame. Is this correct: are languages described by regular expressions which use only concatenation and $^*$ linear?</p>\n", 'ViewCount': '38', 'Title': 'Regular expressions and semi-linear sets', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-14T04:01:26.270', 'LastEditDate': '2014-04-14T02:45:44.470', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '23775', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15627', 'Tags': '<formal-languages><regular-languages><regular-expressions>', 'CreationDate': '2014-04-14T01:59:01.303', 'Id': '23768'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am confused regarding the statements provided by one of our faculty regarding \n   "Is it compulsory that every infinite set is non regular \n    though every finite set is a regular set".\nProviding this  example:</p>\n\n<blockquote>\n  <p>$$L= \\{ 0^n 1^n | n&gt;=0 \\} $$     its  formal as $\\Sigma=\\{0,1\\}$ and\n  thus we\'ve a formal meaning as $\\{\\epsilon,01,0011,000111,....\\}$</p>\n\n<pre><code>                               no. of 0\'s = no. of 1\'s \n</code></pre>\n</blockquote>\n\n<p>The above language should be a non-regular as we need to keep track the value of \'n\' in order to make it a equal no, of 0\'s &amp; 1\'s and FA has no memory.</p>\n\n<p>or am i mistaken.</p>\n\n<p>Please, provide some oxygen regarding this confusion.thank you.</p>\n', 'ViewCount': '428', 'Title': 'Is it compulsory that every infinite set be non regular?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-14T11:16:09.610', 'LastEditDate': '2014-04-14T07:52:31.777', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23777', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10564', 'Tags': '<formal-languages><regular-languages>', 'CreationDate': '2014-04-14T04:45:36.133', 'Id': '23776'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '109', 'Title': 'Proving a language (ir)regular (standard methods have failed)', 'LastEditDate': '2014-04-19T21:26:37.113', 'AnswerCount': '1', 'Score': '7', 'OwnerDisplayName': 'James', 'PostTypeId': '1', 'OwnerUserId': '16922', 'FavoriteCount': '1', 'Body': "<p>I'm currently trying to prove a language regular (for personal amusement). The language is:</p>\n\n<p><em>The language containing all numbers in ternary that have even bit-parity when encoded in binary.</em></p>\n\n<p>Now, I've currently tried a few different approaches that have not led me to any success. I've tried using the pumping lemma (couldn't find anything to pump on), Myhill-Nerode (similar) and even counted the number of strings of each length for which the statement is true (my intuition is that it checks out with a probabilistic argument).</p>\n\n<p>Are their any other approaches that might help here, or are there any intuitions that might be helpful? At this point, my best guess is that the language is not regular, but I don't seem to be able to come up with an explanation.</p>\n", 'Tags': '<formal-languages><regular-languages><arithmetic>', 'LastEditorUserId': '39', 'LastActivityDate': '2014-04-21T10:31:58.500', 'CommentCount': '3', 'AcceptedAnswerId': '23982', 'CreationDate': '2014-04-19T13:47:36.470', 'Id': '23944'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I came across this notation and I don't know the meaning of it, or if it's a typo:  $\\{$ some set $\\}^{+}$</p>\n\n<p>What does the + mean, i.e., the plus operator applied to a set?</p>\n", 'ViewCount': '75', 'Title': 'What does $\\{$ a set $\\}^{+}$ mean in the context of languages?', 'LastEditorUserId': '755', 'LastActivityDate': '2014-04-25T15:37:18.733', 'LastEditDate': '2014-04-25T15:37:18.733', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24095', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '16480', 'Tags': '<formal-languages><terminology><regular-languages><sets>', 'CreationDate': '2014-04-25T05:27:11.613', 'Id': '24094'}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>i posted this on mathematics stack exchange <a href="http://math.stackexchange.com/questions/772617/induction-proof-for-kleene-star">here</a> before i realised this one existed.</p>\n\n<p>i am going through some past exam paper questions on regular languages for some revision, and i am having a bit of trouble with converting general ideas into formal mathematical proofs.</p>\n\n<p>the question is: <strong>given regular expression $S$, prove formally that $S^* = (S^*)^*$</strong></p>\n\n<p><strike>intuitively i can tell that because $S^*$ is an infinite set, then concatenating any number of elements from that infinite set, to that same infinite set, still yields an infinite set of the same size; ie. anything that is in $(S^*)^*)$ must also be in $S^*$.</strike></p>\n\n<p>(EDIT: thanks to David Richerby for pointing out this is wrong)</p>\n\n<p>my problem is expressing this in a formal proof. here is what i have worked through so far (it is a bit all over the place and just a collection of ways to express the problem mostly)</p>\n\n<p>$S^* = (S^*)^*$</p>\n\n<p>this implies:</p>\n\n<p>$S^* \\subseteq (S^*)^*$ <strong>and</strong> $S^* \\supseteq (S^*)^*$</p>\n\n<p>if we assume that there exists $w_k$ such that $w_k \\in S^*$</p>\n\n<p>then the base case for the proof is:</p>\n\n<p>$k = 0$   $(w_k = \\epsilon)$ (empty word, always in $S^*$ and $(S^*)^*$ by definition)</p>\n\n<p>$k = 1$   $(w_k \\in S^*)$</p>\n\n<p>and that\'s kind of where my ability to reason ends.</p>\n\n<p>i think the rest of it will be something like:</p>\n\n<p>$w_{k+1} = w_kx$</p>\n\n<p>ie. $w_k$ concatenated with $x$ where $x \\in S^*$</p>\n\n<p>but how can i show that $w_{k+1} \\in (S^*)^*$</p>\n\n<p>any help to push me in the right direction would be greatly appreciated..</p>\n', 'ViewCount': '52', 'Title': 'induction proof for kleene star', 'LastEditorUserId': '17142', 'LastActivityDate': '2014-04-29T06:05:16.453', 'LastEditDate': '2014-04-29T06:05:16.453', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17142', 'Tags': '<regular-languages><proof-techniques><induction>', 'CreationDate': '2014-04-28T11:28:50.607', 'Id': '24182'}