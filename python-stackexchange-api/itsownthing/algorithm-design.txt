{'Body': '<p>Suppose we have a set $S = \\{ a_1,a_2,a_3,\\ldots , a_N \\}$ of $N$ coders.</p>\n\n<p>Each Coders has rating $R_i$ and the number of gold medals $E_i$, they had won so far.</p>\n\n<p>A Software Company wants to hire exactly three  coders to develop an application.</p>\n\n<p>For hiring three coders, they developed the following strategy:</p>\n\n<ol>\n<li>They first arrange the coders in ascending order of ratings and descending order of gold medals.</li>\n<li>From this arranged list, they select the three of the middle coders.\nE.g., if the arranged list is $(a_5,a_2,a_3,a_1,a_4)$ they select $(a_2,a_3,a_1)$ coders.</li>\n</ol>\n\n<p>Now we have to help company by writing a program  for this task.</p>\n\n<p><strong>Input:</strong></p>\n\n<p>The first line contains $N$, i.e. the number of coders.</p>\n\n<p>Then the second line contains the ratings $R_i$ of $i$th coder.</p>\n\n<p>The third line contains the number of gold medals bagged by the $i$th coder.</p>\n\n<p><strong>Output:</strong></p>\n\n<p>Display only one line that contains the sum of gold medals earned by the three coders the company will select.</p>\n', 'ViewCount': '169', 'Title': 'Efficiently selecting the median and elements to its left and right', 'LastEditorUserId': '31', 'LastActivityDate': '2012-04-13T08:30:58.127', 'LastEditDate': '2012-04-13T08:30:58.127', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '1232', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '1001', 'Tags': '<algorithms><algorithm-design>', 'CreationDate': '2012-04-12T17:12:28.240', 'Id': '1231'}{'Body': '<p>Given an array $a_1,\\ldots,a_n$ of natural numbers $\\leq k$, where $k$ is a constant, I want to answer in $O(1)$ queries of the form: "how many times does $m$ appear in the array between indices $i$ and $j$"?</p>\n\n<p>The array should be preprocessed in linear time. In particular I\'d like to know if there\'s a reduction to Range Minimum Query.</p>\n\n<hr>\n\n<p>This is equivalent to RMQ in the case where $k=1$ and you want to query the number of ones within an interval. So we can use <a href="http://en.wikipedia.org/wiki/Range_Queries#Statement_Of_The_Problem">it</a>.<br>\n<sup>I couldn\'t answer my own question because of limits of SE.</sup></p>\n', 'ViewCount': '187', 'Title': 'Preprocess an array for counting an element in a slice (reduction to RMQ?)', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-20T05:42:23.280', 'LastEditDate': '2012-05-19T10:49:02.503', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '1942', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '1504', 'Tags': '<algorithms><arrays><algorithm-design>', 'CreationDate': '2012-05-18T22:36:42.753', 'Id': '1918'}{'Body': '<p>Dynamic programming can reduce the time needed to perform a recursive algorithm. I know that dynamic programming can help reduce the time complexity of algorithms. Are the general conditions such that if satisfied by a recursive algorithm would imply that using dynamic programming will reduce the time complexity of the algorithm? When should I use dynamic programming?</p>\n', 'ViewCount': '1373', 'Title': 'When can I use dynamic programming to reduce the time complexity of my recursive algorithm?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-25T11:10:59.523', 'LastEditDate': '2012-05-25T11:10:59.523', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '9', 'PostTypeId': '1', 'OwnerUserId': '1634', 'Tags': '<algorithms><dynamic-programming><efficiency><algorithm-design>', 'CreationDate': '2012-05-24T22:26:27.710', 'FavoriteCount': '1', 'Id': '2057'}{'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Subsumption_architecture" rel="nofollow">subsumption architecture</a>, proposed by Rodney Brooks in 1986, is a "bottom-up" approach, in which robots are designed using simple hierarchical models.  These models build upon and subsume the lower modules to form a final product.  For example, a robot can be given a "find opening" module which is subsumed by a more abstract "find doorway" module, which is then itself subsumed by an "exit the playing field" module.</p>\n\n<p>Now, obviously, in a more "object-oriented" design, we could have started the design with the "exit the playing field module", but for sake of argument, assume some of the more primitive components (as "functions") will likely get reused in other higher concepts.</p>\n\n<p>Realizing that implementing this robot in a procedural language (or a functional one, for that matter) could be the simplest, but is it counterproductive to try to conceive of a subsumption architecture-based robot in an object-oriented programming paradigm? (realizing also that it\'s perhaps difficult to weigh a software engineering paradigm against a robotics one)  To obtain a solution, is there some form of "adapter" that can be implemented for increasing the effectiveness of using what may be two conflicting paradigms? </p>\n', 'ViewCount': '105', 'Title': 'Can bottom-up architectures be effectively programmed in top-down paradigms?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-07T08:22:06.383', 'LastEditDate': '2012-08-07T08:22:06.383', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '2945', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '88', 'Tags': '<programming-languages><artificial-intelligence><algorithm-design><object-oriented>', 'CreationDate': '2012-07-28T05:25:40.627', 'Id': '2938'}{'ViewCount': '11355', 'Title': 'What is the novelty in MapReduce?', 'LastEditDate': '2012-08-04T09:11:58.820', 'AnswerCount': '4', 'Score': '39', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '16', 'Body': u'<p>A few years ago, <a href="https://en.wikipedia.org/wiki/Mapreduce">MapReduce</a> was hailed as revolution of distributed programming. There have also been <a href="http://craig-henderson.blogspot.de/2009/11/dewitt-and-stonebrakers-mapreduce-major.html">critics</a> but by and large there was an enthusiastic hype. It even got patented! [1]</p>\n\n<p>The name is reminiscent of <code>map</code> and <code>reduce</code> in functional programming, but when I read (Wikipedia)</p>\n\n<blockquote>\n  <p><strong>Map step:</strong> The master node takes the input, divides it into smaller sub-problems, and distributes them to worker nodes. A worker node may do this again in turn, leading to a multi-level tree structure. The worker node processes the smaller problem, and passes the answer back to its master node.</p>\n  \n  <p><strong>Reduce step:</strong> The master node then collects the answers to all the sub-problems and combines them in some way to form the output \u2013 the answer to the problem it was originally trying to solve.</p>\n</blockquote>\n\n<p>or [2] </p>\n\n<blockquote>\n  <p><strong>Internals of MAP:</strong> [...] MAP splits up the input value into words. [...] MAP is meant to associate each given key/value pair of the input with potentially many intermediate key/value pairs.</p>\n  \n  <p><strong>Internals of REDUCE:</strong> [...] [REDUCE] performs imperative aggregation (say, reduction): take many values, and reduce them to a single value.</p>\n</blockquote>\n\n<p>I can not help but think: this is <a href="https://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">divide &amp; conquer</a> (in the sense of Mergesort), plain and simple! So, is there (conceptual) novelty in MapReduce somewhere, or is it just a new implementation of old ideas useful in certain scenarios?</p>\n\n<hr>\n\n<ol>\n<li><a href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=/netahtml/PTO/srchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=7,650,331.PN.&amp;OS=PN/7,650,331&amp;RS=PN/7,650,331"> US Patent 7,650,331: "System and method for efficient large-scale data processing "</a> (2010)</li>\n<li><a href="http://dx.doi.org/10.1016/j.scico.2007.07.001">Google\u2019s MapReduce programming model \u2014 Revisited</a> by R. L\xe4mmel (2007)</li>\n</ol>\n', 'Tags': '<algorithms><distributed-systems><parallel-computing><algorithm-design>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-11T04:57:53.957', 'CommentCount': '4', 'AcceptedAnswerId': '3020', 'CreationDate': '2012-08-03T14:04:19.350', 'Id': '3019'}{'Body': '<p>Assume a map-reduce program has $m$ mappers and $n$ reducers ($m &gt; n$). The output of each mapper is partitioned according to the key value and all records having the same key value go into the same partition (within each mapper), and then each partition is sent to a reducer. Thus there might be a case in which there are two partitions with the same key from two different mappers going to 2 different reducers. How to prevent this from occurring? That is, how to send all partitions (from different mappers) with the same key to the same reducer?</p>\n', 'ViewCount': '189', 'Title': 'How partitioning in map-reduce work?', 'LastActivityDate': '2012-12-04T19:29:25.950', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4868', 'Tags': '<distributed-systems><parallel-computing><algorithm-design>', 'CreationDate': '2012-12-04T17:54:20.870', 'FavoriteCount': '1', 'Id': '7159'}{'Body': '<p>Is it common to try to improve an algorithm by decomposing its action on a topological piece of data (e.g. graphs, geometric data) into a series of steps, each of which only makes a local change/perturbation in a confined neighborhood of the data while fixing the rest?</p>\n\n<p>One benefit of this "breakdown" is improved conceptual understanding, and it also facilitates induction proofs (possibly based on invariants that are preserved by each step). Does this "decomposition" have a name in algorithm design? The idea might be similar to Divide and Conquer.</p>\n\n<p>One might say that every individual step in an algorithm, like deleting an edge or labeling a vertex of a graph, is small enough to be considered "local", but I\'m talking more about the "decomposition" in a higher-level description, like how truncating a polyhedron is local but sorting a list is not (even though at the lowest level, comparisons, insertions and deletions are local).</p>\n\n<p><strong>Examples of decomposing into local transformations</strong></p>\n\n<ul>\n<li><p>Augustin Cauchy\'s proof of his <a href="http://en.wikipedia.org/wiki/Cauchy%27s_theorem_%28geometry%29" rel="nofollow">Rigidity Theorem</a> relied on his "<a href="http://www.cs.mcgill.ca/~cs507/projects/1998/sfreel/cauchylemma.html" rel="nofollow">Arm Lemma</a>" that opened up a convex planar chain by sequentially opening at each vertex. Although his proof was found to be wrong, he decomposed the opening algorithm into a series of "local opening moves", and he tried to prove that each local move preserved convexity of the chain. By induction, convexity would still hold after iterating over all vertices.</p></li>\n<li><p>The <em>pivot algorithm</em> for <a href="http://en.wikipedia.org/wiki/Self-avoiding_walk" rel="nofollow">self-avoiding walks</a> (SAW) transforms a SAW into another by rotating or reflecting part of the original SAW. <a href="http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo" rel="nofollow">Markov Chain Monte Carlo</a> can employ this transformation as a transition between SAW states to sample the space of SAWs.</p></li>\n<li><p>As an application of the above, one technique of <a href="http://en.wikipedia.org/wiki/Protein_folding#Computational_methods_for_studying_protein_folding" rel="nofollow">protein folding prediction</a> is to force an amino acid chain into several known protein structures, choose the one with the lowest energy (due to intermolecular forces), then let the chosen structure "relax" into a configuation with lower energy. Relaxation involves the prescription of a few "local moves", where small parts of the chain can "wriggle around" (e.g. subchains pivoting around their ends), and random wriggles are allowed for a period of time to let the chain "stabilize". Modelling the chain as an SAW allows pivots to be used as a "wriggle".</p></li>\n</ul>\n', 'ViewCount': '171', 'Title': 'Decomposing an Algorithm into Local Transformations/Perturbations', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-13T22:04:18.290', 'LastEditDate': '2013-12-13T13:27:28.013', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '11678', 'Tags': '<algorithms><terminology><reference-request><algorithm-design>', 'CreationDate': '2013-11-28T08:34:39.540', 'Id': '18438'}