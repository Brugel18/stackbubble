{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3821', 'Title': 'Language theoretic comparison of LL and LR grammars', 'LastEditDate': '2013-06-06T14:05:27.163', 'AnswerCount': '1', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '13', 'Body': '<p>People often say that <a href="https://en.wikipedia.org/wiki/LR_parser">LR(k)</a> parsers are more powerful than <a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a> parsers. These statements are vague most of the time; in particular, should we compare the classes for a fixed $k$ or the union over all $k$? So how is the situation really? In particular, I am interested in how LL(*) fits in.</p>\n\n<p>As far as I know, the respective sets of grammars LL and LR parsers accept are orthogonal, so let us talk about the languages generated by the respective sets of grammars. Let $LR(k)$ denote the class of languages generated by grammars that can be parsed by an $LR(k)$ parser, and similar for other classes.</p>\n\n<p>I am interested in the following relations:</p>\n\n<ul>\n<li>$LL(k) \\overset{?}{\\subseteq} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{\\subseteq} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{=} LL(*)$</li>\n<li>$LL(*) \\overset{?}{\\circ} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n</ul>\n\n<p>Some of these are probably easy; my goal is to collect a "complete" comparison. References are appreciated.</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T14:05:27.163', 'CommentCount': '2', 'AcceptedAnswerId': '48', 'CreationDate': '2012-03-07T00:32:31.947', 'Id': '43'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3042', 'Title': 'How does one know which notation of time complexity analysis to use?', 'LastEditDate': '2013-06-06T14:12:06.230', 'AnswerCount': '3', 'Score': '41', 'PostTypeId': '1', 'OwnerUserId': '110', 'FavoriteCount': '18', 'Body': '<p>In most introductory algorithm classes, notations like $O$ (Big O) and $\\Theta$ are introduced, and a student would typically learn to use one of these to find the time complexity.</p>\n\n<p>However, there are other notations, such as $o$, $\\Omega$ and $\\omega$. Are there any specific scenarios where one notation would be preferable to another?</p>\n', 'Tags': '<algorithms><terminology><asymptotics><landau-notation><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2014-04-01T22:12:52.083', 'CommentCount': '1', 'AcceptedAnswerId': '61', 'CreationDate': '2012-03-07T01:42:10.933', 'Id': '57'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I've not gone much deep into CS. So, please forgive me if the question is not good or out of scope for this site.</p>\n\n<p>I've seen in many sites and books, the big-O notations like $O(n)$ which tell the time taken by an algorithm. I've read a few articles about it, but I'm still not able to understand how do you calculate it for a given algorithm.</p>\n", 'ViewCount': '7841', 'Title': 'How to come up with the runtime of algorithms?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T16:07:12.323', 'LastEditDate': '2013-06-06T16:07:12.323', 'AnswerCount': '5', 'CommentCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '132', 'Tags': '<algorithms><algorithm-analysis><runtime-analysis><reference-question>', 'CreationDate': '2012-03-10T12:03:19.397', 'FavoriteCount': '11', 'Id': '192'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '7833', 'Title': 'How to prove that a language is not context-free?', 'LastEditDate': '2013-06-06T13:59:18.867', 'AnswerCount': '5', 'Score': '39', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '16', 'Body': '<p>We learned about the class of context-free languages $\\mathrm{CFL}$. It is characterised by both <a href="https://en.wikipedia.org/wiki/Context-free_grammar">context-free grammars</a> and <a href="https://en.wikipedia.org/wiki/Pushdown_automata">pushdown automata</a> so it is easy to show that a given language is context-free.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for <em>all</em> grammars (or automata) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n', 'Tags': '<formal-languages><context-free><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-12-04T20:04:21.587', 'CommentCount': '0', 'AcceptedAnswerId': '276', 'CreationDate': '2012-03-12T23:57:46.817', 'Id': '265'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '767', 'Title': 'Sorting functions by asymptotic growth', 'LastEditDate': '2013-06-06T16:01:40.233', 'AnswerCount': '5', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '776', 'FavoriteCount': '12', 'Body': '<p>Assume I have a list of functions, for example </p>\n\n<p>$\\qquad n^{\\log \\log(n)},  2^n, n!, n^3, n \\ln n, \\dots$</p>\n\n<p>How do I sort them asymptotically, i.e. after the relation defined by</p>\n\n<p>$\\qquad f \\leq_O g \\iff f \\in O(g)$,</p>\n\n<p>assuming they are indeed pairwise comparable (see also <a href="http://cs.stackexchange.com/questions/1780/are-the-functions-always-asymptotically-comparable">here</a>)? Using the definition of $O$ seems awkward, and it is often hard to prove the existence of suitable constants $c$ and $n_0$.</p>\n', 'Tags': '<asymptotics><landau-notation><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-11-19T13:21:17.813', 'CommentCount': '1', 'AcceptedAnswerId': '827', 'CreationDate': '2012-03-27T15:47:31.160', 'Id': '824'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '11911', 'Title': 'How to prove that a language is not regular?', 'LastEditDate': '2013-06-06T13:54:20.203', 'AnswerCount': '5', 'Score': '26', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '21', 'Body': '<p>We learned about the class of regular languages $\\mathrm{REG}$. It is characterised by any one concept among regular expressions, finite automata and left-linear grammars, so it is easy to show that a given language is regular.</p>\n\n<p>How do I show the opposite, though? My TA has been adamant that in order to do so, we would have to show for all regular expressions (or for all finite automata, or for all left-linear grammars) that they can not describe the language at hand. This seems like a big task!</p>\n\n<p>I have read about some pumping lemma but it looks really complicated.</p>\n\n<p><em><sup>This is intended to be a reference question collecting usual proof methods and application examples. See <a href="http://cs.stackexchange.com/q/265/98">here</a> for the same question on context-free languages.</sup></em></p>\n', 'Tags': '<formal-languages><regular-languages><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-07-01T12:50:16.730', 'CommentCount': '4', 'AcceptedAnswerId': '1033', 'CreationDate': '2012-04-04T10:30:32.163', 'Id': '1031'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '6747', 'Title': 'How to prove a language is regular?', 'LastEditDate': '2013-06-06T13:56:25.667', 'AnswerCount': '5', 'Score': '14', 'PostTypeId': '1', 'OwnerUserId': '1133', 'FavoriteCount': '4', 'Body': '<p>There are many methods to prove that <a href="http://cs.stackexchange.com/q/1031/157">a language is not regular</a>, but what do I need to do to prove that some language <em>is</em> regular?</p>\n\n<p>For instance, if I am given that $L$ is regular, \nhow can I prove that the following $L&#39;$ is regular, too?</p>\n\n<p>$\\qquad \\displaystyle L&#39; := \\{w \\in L: uv = w \\text{ for } u \\in \\Sigma^* \\setminus L \\text{ and } v \\in \\Sigma^+ \\}$</p>\n\n<p>Can I draw a nondeterministic finite automaton to prove this?</p>\n', 'Tags': '<formal-languages><regular-languages><automata><proof-techniques><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-09-20T17:34:26.467', 'CommentCount': '4', 'AcceptedAnswerId': '1333', 'CreationDate': '2012-04-18T05:21:31.750', 'Id': '1331'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '665', 'Title': 'Dealing with intractability: NP-complete problems', 'LastEditDate': '2013-06-06T14:11:05.583', 'AnswerCount': '6', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '1219', 'FavoriteCount': '8', 'Body': '<p>Assume that I am a programmer and I have an NP-complete problem that I need to solve it. What methods are available to deal with NPC problems? Is there a survey or something similar on this topic?</p>\n', 'Tags': '<algorithms><reference-request><np-complete><efficiency><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T14:11:05.583', 'CommentCount': '4', 'AcceptedAnswerId': '1481', 'CreationDate': '2012-04-24T03:28:23.417', 'Id': '1477'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1389', 'Title': 'How can we assume that basic operations on numbers take constant time?', 'LastEditDate': '2013-09-10T22:18:05.507', 'AnswerCount': '6', 'Score': '31', 'OwnerDisplayName': 'user742', 'PostTypeId': '1', 'FavoriteCount': '15', 'Body': "<p>Normally in algorithms we do not care about comparison, addition, or subtraction of numbers -- we assume they run in time $O(1)$.  For example, we assume this when we say that comparison-based sorting is $O(n\\log n)$, but when numbers are too big to fit into registers, we normally represent them as arrays so basic operations require extra calculations per element.</p>\n\n<p>Is there a proof showing that comparison of two numbers (or other primitive arithmetic functions) can be done in $O(1)$? If not why are we saying that comparison based sorting is $O(n\\log n)$?</p>\n\n<hr>\n\n<p><em>I encountered this problem when I answered a SO question and I realized that my algorithm is not $O(n)$ because sooner or later I should deal with big-int, also it wasn't pseudo polynomial time algorithm, it was $P$.</em></p>\n", 'Tags': '<algorithms><complexity-theory><algorithm-analysis><time-complexity><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-10T22:18:05.507', 'CommentCount': '2', 'AcceptedAnswerId': '1661', 'CreationDate': '2012-05-03T00:06:31.453', 'Id': '1643'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>There are lots of attempts at proving either $\\mathsf{P} = \\mathsf{NP} $ or $\\mathsf{P} \\neq \\mathsf{NP}$, and naturally many people think about the question, having ideas for proving either direction.</p>\n\n<p>I know that there are approaches that have been proven to not work, and there are probably more that have a history of failing. There also seem to be so-called <em>barriers</em> that many proof attemps fail to overcome. </p>\n\n<p>We want to avoid investigating into dead-ends, so what are they?</p>\n', 'ViewCount': '6113', 'Title': 'How not to solve P=NP?', 'LastEditorUserId': '6716', 'LastActivityDate': '2014-03-26T03:42:53.937', 'LastEditDate': '2013-06-06T14:08:25.930', 'AnswerCount': '5', 'CommentCount': '5', 'Score': '41', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><reference-request><history><p-vs-np><reference-question>', 'CreationDate': '2012-05-17T01:24:29.327', 'FavoriteCount': '24', 'Id': '1877'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '14352', 'Title': 'How to convert finite automata to regular expressions?', 'LastEditDate': '2014-03-22T11:29:26.503', 'AnswerCount': '4', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '18', 'Body': '<p>Converting regular expressions into (minimal) NFA that accept the same language is easy with standard algorithms, e.g. <a href="http://en.wikipedia.org/wiki/Thompson%27s_construction_algorithm" rel="nofollow">Thompson\'s algorithm</a>. The other direction seems to be more tedious, though, and sometimes the resulting expressions are messy.</p>\n\n<p>What algorithms are there for converting NFA into equivalent regular expressions? Are there advantages regarding time complexity or result size?</p>\n\n<p><sup>This is supposed to be a reference question. Please include a general decription of your method as well as a non-trivial example.</sup></p>\n', 'Tags': '<algorithms><formal-languages><finite-automata><regular-expressions><reference-question>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-22T11:29:26.503', 'CommentCount': '2', 'AcceptedAnswerId': '2389', 'CreationDate': '2012-05-23T08:19:27.003', 'Id': '2016'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In computer science, we have often have to solve <a href="http://en.wikipedia.org/wiki/Recurrence_relation">recurrence relations</a>, that is find a <strong>closed form</strong> for a recursively defined sequence of numbers. When considering runtimes, we are often interested mainly in the sequence\'s <a href="http://en.wikipedia.org/wiki/Asymptotic_analysis"><strong>asymptotic</strong> growth</a>.</p>\n\n<p>Examples are </p>\n\n<ol>\n<li><p>The runtime of a tail-recursive function stepping downwards to $0$ from $n$ whose body takes time $f(n)$:</p>\n\n<p>$\\qquad \\begin{align}\n  T(0) &amp;= 0 \\\\\n  T(n+1) &amp;= T(n) + f(n)    \n \\end{align}$</p></li>\n<li><p>The <a href="http://en.wikipedia.org/wiki/Fibonacci_sequence">Fibonacci sequence</a>:</p>\n\n<p>$\\qquad \\begin{align}\n  F_0 &amp;= 0 \\\\\n  F_1 &amp;= 1 \\\\\n  F_{n+2} &amp;= F_n + F_{n+1}    \n \\end{align}$</p></li>\n<li><p>The number of <a href="http://en.wikipedia.org/wiki/Dyck_language">Dyck words</a> with $n$ parenthesis pairs:</p>\n\n<p>$\\qquad\\begin{align}\n    C_0 &amp;= 1 \\\\ \n    C_{n+1}&amp;=\\sum_{i=0}^{n}C_i\\,C_{n-i}\n  \\end{align}$</p></li>\n<li><p>The mergesort runtime recurrence on lists of length $n$:</p>\n\n<p>$\\qquad \\begin{align}\n  T(1) &amp;= T(0) = 0 \\\\\n  T(n) &amp;= T(\\lfloor n/2\\rfloor) + T(\\lceil n/2\\rceil) + n-1\n \\end{align}$</p></li>\n</ol>\n\n<p>What are methods to solve recurrence relations? We are looking for</p>\n\n<ul>\n<li>general methods and</li>\n<li>methods for a significant subclass</li>\n</ul>\n\n<p>as well as</p>\n\n<ul>\n<li>methods that yield precise solutions and</li>\n<li>methods that provide (bounds on) asymptotic growth.</li>\n</ul>\n\n<p><sup>This is supposed to become a reference question. Please post one answer per method and provide a general description as well as an illustrative example.</sup></p>\n', 'ViewCount': '1536', 'Title': 'Solving or approximating recurrence relations for sequences of numbers', 'LastEditorUserId': '6716', 'LastActivityDate': '2014-04-24T15:41:56.573', 'LastEditDate': '2013-06-06T16:02:38.220', 'AnswerCount': '8', 'CommentCount': '1', 'Score': '27', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<asymptotics><proof-techniques><combinatorics><recurrence-relation><reference-question>', 'CreationDate': '2012-07-17T18:31:38.607', 'FavoriteCount': '27', 'Id': '2789'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Ok, I have been a computer nerd for many many years. I can program in quite a few languages, and I can even build them.  I sat down with a buddy the other day and asked how a computer actually takes electricity and does something with it, and we just couldnt figure it out, and Google wasn't much help either.</p>\n\n<p>I mean, how does a computer take a constant flow of electricity and turn it into 1's and 0's and then actually do something with those 1's and 0's like turn a light on for 15 seconds?</p>\n\n<p>I understand gates (and/or/nor/nand) and a little about diodes, resistors and transistors but i figured this would be the perfect place to have it explained in true laymens terms!</p>\n\n<p>Can anybody point me in the right direction or give me a brief explanation?</p>\n", 'ViewCount': '1212', 'Title': 'How does a computer work?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-18T21:11:34.387', 'LastEditDate': '2013-06-06T16:03:33.617', 'AnswerCount': '5', 'CommentCount': '4', 'Score': '17', 'PostTypeId': '1', 'OwnerUserId': '2703', 'Tags': '<computer-architecture><education><reference-question>', 'CreationDate': '2012-09-01T17:11:12.853', 'FavoriteCount': '14', 'Id': '3390'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>In my Computing Theory course, a lot of our problems involve using induction on the length of the input string to prove statements about finite automata.  I understand mathematical induction, however when strings come into play I get real tripped up.  I\'d really appreciate it if someone would go through the process of making such a proof step by step.</p>\n\n<p>Here\'s an example problem (Exercise 2.2.10 from Hopcroft and Ullman 3rd Edition):</p>\n\n<blockquote>\n  <p>Consider the DFA with the following transition table:</p>\n\n<pre>\n        0    1\n       ________\n-> A |  A    B\n  *B |  B    A\n</pre>\n  \n  <p>Informally describe the language accepted by this DFA, and prove by induction on the length of an input string that your description is correct.</p>\n</blockquote>\n\n<p>This is an answered problem in the book, so I\'m not looking for someone to do my homework.  I just need someone to explain it to me straight.</p>\n\n<p><strong>Book\'s Answer:</strong>\n(taken from <a href="http://infolab.stanford.edu/~ullman/ialcsols/sol2.html" rel="nofollow">here</a>)</p>\n\n<blockquote>\n  <p>The automaton tells whether the number of 1\'s seen is even (state A) or odd (state B), accepting in the latter case. It is an easy induction on |w| to show that dh(A,w) = A if and only if w has an even number of 1\'s.\n  Basis: |w| = 0. Then w, the empty string surely has an even number of 1\'s, namely zero 1\'s, and \u03b4-hat(A,w) = A.</p>\n  \n  <p>Induction: Assume the statement for strings shorter than w. Then w = za, where a is either 0 or 1.</p>\n  \n  <ul>\n  <li><p><strong>Case 1:</strong> a = 0. If w has an even number of 1\'s, so does z. By the inductive hypothesis, \u03b4-hat(A,z) = A. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then so does z. By the inductive hypothesis, \u03b4-hat(A,z) = B, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  <li><p><strong>Case 2:</strong> a = 1. If w has an even number of 1\'s, then z has an odd number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = B. The transitions of the DFA tell us \u03b4-hat(A,w) = A. If w has an odd number of 1\'s, then z has an even number of 1\'s. By the inductive hypothesis, \u03b4-hat(A,z) = A, and the transitions of the DFA tell us \u03b4-hat(A,w) = B. Thus, in this case as well, \u03b4-hat(A,w) = A if and only if w has an even number of 1\'s.</p></li>\n  </ul>\n</blockquote>\n\n<p>I understand how to prove things like $\\sum_{i=0}^{n}i = \\frac{n(n+1)}{2}$ using induction.  I\'m just confused by how this works with building strings.  I\'m confused by the bolded parts.  I don\'t understand how they are come up with/how it actually proves what is accepted/how it is inductive.</p>\n\n<p>\u03b4-hat is the extended transition function, by the way.</p>\n', 'ViewCount': '1544', 'Title': 'How do I write a proof using induction on the length of the input string?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T17:30:34.120', 'LastEditDate': '2014-02-02T17:30:34.120', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '4907', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '3082', 'Tags': '<automata><finite-automata><proof-techniques><reference-question><induction>', 'CreationDate': '2012-10-06T19:00:18.360', 'Id': '4905'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>It might sound like a stupid question but I'm really curious to know how a computer knows that $1&lt;2$? Also, how does a computer know that the order of integer is $1,2,3,4,5,\\ldots$ and alphabet is A,B,C,D,...? Is it somewhere stored in the hardware or does the operating system provide this kind of information?</p>\n", 'ViewCount': '1872', 'Title': 'How does the computer determine whether a number is smaller or greater than another?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-10-18T13:34:24.403', 'LastEditDate': '2013-06-06T16:05:51.050', 'AnswerCount': '7', 'CommentCount': '2', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '4824', 'Tags': '<computer-architecture><reference-question>', 'CreationDate': '2012-12-01T09:09:39.713', 'FavoriteCount': '5', 'Id': '7074'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '11016', 'Title': 'In basic terms, what is the definition of P, NP, NP-Complete, and NP-Hard?', 'LastEditDate': '2013-06-06T14:06:56.640', 'AnswerCount': '5', 'Score': '56', 'PostTypeId': '1', 'OwnerUserId': '6569', 'FavoriteCount': '54', 'Body': "<p>I'm in a course about computing and complexity, and am unable to understand what these terms mean. All I know is that np is a subset of np complete which is a subset of np hard... but I have no idea what they actually mean. Wikipedia isn't much help either as the explanations are still a bit too high level.</p>\n", 'Tags': '<complexity-theory><terminology><p-vs-np><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2014-04-16T09:27:50.623', 'CommentCount': '4', 'AcceptedAnswerId': '9566', 'CreationDate': '2013-02-06T20:38:08.297', 'Id': '9556'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1040', 'Title': 'How to show that a function is not computable?', 'LastEditDate': '2013-06-06T16:06:21.617', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '5', 'Body': "<p>I know that there exist a Turing Machine, if a function is computable. Then how to show that the function is <em>not</em> computable or there aren't any Turing Machine for that. Is there anything like a Pumping lemma?</p>\n", 'Tags': '<computability><proof-techniques><undecidability><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-08-07T07:04:22.880', 'CommentCount': '4', 'AcceptedAnswerId': '11289', 'CreationDate': '2013-04-10T02:38:54.367', 'Id': '11181'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In computability and complexity theory (and maybe other fields), reductions are ubiquitous. There are many kinds, but the principle remains the same: show that one problem $L_1$ is at least as hard as some other problem $L_2$ by mapping instances from $L_2$ to solution-equivalent ones in $L_1$. Essentially, we show that any solver for $L_1$ can also solve $L_2$ if we allow it to use the reduction function as preprocessor.</p>\n\n<p>I have performed my share of reductions over the years, and something keeps bugging me. While every new reduction requires a (more or less) creative construction, the task can feel repetitive. Is there a pool of canonical methods?</p>\n\n<p>What are techniques, patterns and tricks one can regularly employ for constructing reduction functions?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '548', 'LastEditorDisplayName': 'user742', 'Title': 'What are common techniques for reducing problems to each other?', 'LastActivityDate': '2014-01-17T18:09:43.470', 'LastEditDate': '2013-05-15T10:15:37.360', 'AnswerCount': '4', 'CommentCount': '0', 'Score': '16', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<complexity-theory><computability><reductions><proof-techniques><reference-question>', 'CreationDate': '2013-04-10T21:31:03.203', 'FavoriteCount': '10', 'Id': '11209'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Specifying formal languages by giving formal grammars is a frequent task: we need grammars not only to describe languages, but also to parse them, or even <a href="http://scholar.google.com/scholar?q=secondary%20structure%20prediction%20stochastic%20grammars" rel="nofollow">do proper science</a>. In all cases, it is important that the grammar at hand is <em>correct</em>, that is generates exactly the desired words.</p>\n\n<p>We can often argue on a high-level why the grammar is an adequate representation of the desired language, omitting a formal proof. But what if we are in doubt or need a formal proof for some reason? What are techniques we can apply?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '417', 'Title': 'How to show that L = L(G)?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T13:55:49.570', 'LastEditDate': '2013-06-06T13:55:49.570', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<formal-languages><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-04-14T19:02:14.270', 'Id': '11315'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>It seems that on this site, people will often correct others for confusing "algorithms" and "problems." What are the difference between these? How do I know when I should be considering algorithms and considering problems? And how do these relate to the concept of a language in formal language theory?</p>\n', 'ViewCount': '453', 'Title': 'What is the difference between an algorithm, a language and a problem?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-15T20:11:23.283', 'LastEditDate': '2013-08-08T10:47:58.127', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '2253', 'Tags': '<algorithms><complexity-theory><formal-languages><terminology><reference-question>', 'CreationDate': '2013-08-08T06:10:27.963', 'FavoriteCount': '6', 'Id': '13669'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>There are <a href="http://cs.stackexchange.com/q/265/755">many techniques</a> to prove that a language is <em>not</em> context-free, but how do I prove that a language <em>is</em> context-free?</p>\n\n<p>What techniques are there to prove this?  Obviously, one way is to exhibit a context-free grammar for the language.  Are there any systematic techniques to find a context-free grammar for a given language?</p>\n\n<p>For regular languages, there <em>are</em> <a href="http://cs.stackexchange.com/q/1331/755">systematic ways</a> to derive a regular grammar / finite-state automaton: for instance, the Myhill-Nerode theorem provides one way.  Is there any corresponding technique for context-free languages?</p>\n\n<hr>\n\n<p>My motivation here is to (hopefully) build up a reference question that contains a list of techniques that are often helpful, when trying to prove that a given language is context-free.  Since we have many questions here that are special cases of this, it would be nice if we could document the general approach or general techniques that one can use when facing this sort of problem.</p>\n', 'ViewCount': '156', 'Title': 'How to prove that a language is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T19:22:09.170', 'LastEditDate': '2014-01-17T22:55:11.557', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-12-02T04:18:45.460', 'FavoriteCount': '1', 'Id': '18524'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>There are lots of <a href="/questions/tagged/algorithm-analysis" class="post-tag" title="show questions tagged &#39;algorithm-analysis&#39;" rel="tag">algorithm-analysis</a> questions around. Many are similar, for instance those asking for an analysis of nested loops or divide &amp; conquer algorithms, but most answers seem to be tailor-made.</p>\n\n<p>On the other hand, the answers <a href="http://cs.stackexchange.com/questions/192/how-to-come-up-with-the-runtime-of-algorithms">to another general question</a> explain the larger picture (in particular regarding asymptotic analysis) with some examples, but not how to get your hands dirty.</p>\n\n<p>Is there a structured, general method for analysing algorithms?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a> that can be used to point beginners to; hence its broader-than-usual scope. Please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '2051', 'Title': 'Is there a system behind the magic of algorithm analysis?', 'LastActivityDate': '2014-04-10T15:08:23.810', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '32', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<algorithms><algorithm-analysis><proof-techniques><reference-question>', 'CreationDate': '2014-04-09T12:59:52.003', 'FavoriteCount': '30', 'Id': '23593'}},