{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p><a href="http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29" rel="nofollow">Reflection</a> is a common mechanism for accessing and changing the structure of a program at run-time, found in many dynamic programming languages such as Smalltalk, Ruby and Python, and in impoverished form in Java and (hence) Scala. Functional languages such as LISP and Scheme also support a good reflect framework. </p>\n\n<p>Modern languages support concurrency, either by adding threads on top of the existing language constructs, or by designing from the ground up with concurrency in mind.</p>\n\n<p>My question is: </p>\n\n<blockquote>\n  <p>What models of reflection for the concurrency aspects in concurrent languages (multi-threaded, actor-based, active-object-based) exist? </p>\n</blockquote>\n', 'ViewCount': '164', 'Title': 'Reflection on Concurrency', 'LastEditorUserId': '31', 'LastActivityDate': '2012-03-16T23:43:47.517', 'LastEditDate': '2012-03-12T19:34:39.557', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '31', 'Tags': '<programming-languages><semantics><concurrency><reflection>', 'CreationDate': '2012-03-12T16:55:45.647', 'FavoriteCount': '1', 'Id': '246'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m looking for a simple calculus that supports reasoning about <a href="http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29">reflection</a>, namely, the introspection and manipulation of running programs.</p>\n\n<blockquote>\n  <p>Is there an untyped $\\lambda$-calculus extension that enables one to convert $\\lambda$-terms into a form that can be syntactically manipulated and then subsequently evaluated?</p>\n</blockquote>\n\n<p>I imagine that the calculus has two main additional terms:</p>\n\n<ul>\n<li>$\\mathtt{reflect}\\ v$: takes $v$ and produces a representation of $v$ amendable to\nsyntactic manipulation.</li>\n<li>$\\mathtt{eval}\\ v$: takes a syntactic representation of a term and evaluates it.</li>\n</ul>\n\n<p>In order to support reflection, a syntactic representation of terms is required. It would look something like:</p>\n\n<ul>\n<li>$\\lambda x.e$ would be represented as a term $(\\mathsf{LAM}\\ R(e))$, where\n$R(e)$ is the reflected version of $e$,</li>\n<li>$e\\ e\'$ would be represented as term $(\\mathsf{APP}\\ R(e)\\ R(e\'))$, and</li>\n<li>$x$ would be represented as $(\\mathsf{VAR}\\ x)$.</li>\n</ul>\n\n<p>With this representation, pattern matching could be used to manipulate terms.</p>\n\n<p>But we run into a problem. $\\mathtt{reflect}$ and $\\mathtt{eval}$ need to be encoded as terms, as does pattern matching. Dealing with this seems to be straightforward,\nadding $\\mathsf{REFLECT}$, $\\mathsf{EVAL}$ and $\\mathsf{MATCH}$, but will I need to add other terms to support the manipulation of these?</p>\n\n<p>There are design choices that need to be made. What should the $R(-)$ function alluded to above do with \nthe body of $\\mathtt{reflect}$ and $\\mathtt{eval}$? Should $R(-)$ transform the body or\nnot?</p>\n\n<p>As I am not so much interested in studying reflection itself -- the calculus would serve as a vehicle for other research -- I do not want to reinvent the wheel.</p>\n\n<blockquote>\n  <p>Are there any existing calculi that match what I have just described?</p>\n</blockquote>\n\n<p>As far as I can tell, calculi such as MetaML, suggested in a comment, go a long way, but they do not include the ability to pattern match and deconstruct code fragments that have already been built.</p>\n\n<p>One thing I would like to be able to do is the following:</p>\n\n<ul>\n<li>$\\mathtt{let}\\ x=\\lambda y.y\\ \\mathtt{in}\\ \\mathtt{reflect}\\ x \n\\to (\\mathsf{LAM}\\ (\\mathsf{VAR}\\ y)\\ (\\mathsf{VAR}\\ y))$</li>\n</ul>\n\n<p>And then perform pattern matching on the result to build a completely different\nexpression. </p>\n\n<p>This is certainly not a conservative extension to the $\\lambda$-calculus and the meta-theory is likely to be ugly, but this is kind of the point for my application. I want to break $\\lambda$-abstractions apart.</p>\n', 'ViewCount': '284', 'Title': '$\\lambda$-calculus with reflection', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-27T06:09:52.923', 'LastEditDate': '2012-07-16T23:37:11.120', 'AnswerCount': '2', 'CommentCount': '8', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '31', 'Tags': '<logic><lambda-calculus><semantics><reflection>', 'CreationDate': '2012-07-12T11:26:19.763', 'FavoriteCount': '2', 'Id': '2707'}}{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'ve just read in a <a href="http://lambda-the-ultimate.org/node/4875#comment-78361" rel="nofollow">discussion about dynamic typing</a></p>\n\n<blockquote>\n  <p>Reflective towers is an open problem for statically typed languages.</p>\n</blockquote>\n\n<p>What are reflective towers? </p>\n\n<p>I think it might be related to reflection, but I\'m not sure.</p>\n\n<p>If you create an example, I would prefer Java.</p>\n', 'ViewCount': '34', 'Title': 'What is an reflective tower?', 'LastActivityDate': '2014-03-18T18:05:06.900', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2914', 'Tags': '<type-theory><reflection>', 'CreationDate': '2014-03-18T16:00:15.037', 'Id': '22760'}}