311_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given an array of size n that holds ones and zeros I need to find an index of a  <code>1</code> cell that has <code>0</code> to his right (in then next cell) there could be more than one pair in a given array, any one of them is fine. The array is not sorted, but we do know that the first element is <code>1</code> and the last element is <code>0</code>.</p>\n\n<p>The search should be in $O(\\log n)$ time. I'm thinking that a binary search variation is the answer but I'm not sure how. </p>\n", 'ViewCount': '60', 'Title': "Finding a '1' cell with a '0' to its right in a binary array", 'LastEditorUserId': '472', 'LastActivityDate': '2013-02-20T18:15:12.737', 'LastEditDate': '2013-02-20T18:15:12.737', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '9973', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6963', 'Tags': '<algorithms><arrays><search-algorithms><binary-search>', 'CreationDate': '2013-02-20T16:04:03.810', 'Id': '9969'},311_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If we have an array $A$ of length $N$, which is partitioned into $\\sqrt{N}$ adjacent subarrays $A(i)$, each of which is monotonically ordered from $\\min(i)$ to $\\max(i)$ (it is known what places have those bounds in A for each subarray), with the following conditions:</p>\n\n<pre><code>min(i) &lt; min(i+1),\nmax(i) &lt; max(i+1),\nmin(i+1) &lt; max(i),\nIf subarrays A(i) and A(i+1) both have the j-th element, then A(i,j) &lt; A(i+1,j),\nThe number of elements in subarray A(i) is strictly increasing with i\n</code></pre>\n\n<p>Would it be possible to search an element in the array $A$, in time $O((\\log N)^k)$, for a positive $k$?  If yes how?</p>\n\n<p>If not, what kind of minimal additional conditions would allow that?</p>\n\n<p>Edit. The subarrays are not necessarily of equal length.\nThey are strictly increasing. The above stated conditions are always guaranteed.</p>\n\n<p>What I have tried so far is to binary search them separately, but that is obviously going to be very inefficient. </p>\n\n<p>[Note that this question has obviously nothing to do with the search of the min of max value in the array. And I am not interested in sorting the array. Just the mere search.]</p>\n', 'ViewCount': '145', 'Title': 'Searching a value in a "piecewise" ordered array', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-23T10:37:11.463', 'LastEditDate': '2013-08-23T10:37:11.463', 'AnswerCount': '1', 'CommentCount': '15', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '5147', 'Tags': '<algorithms><search-algorithms><arrays><binary-search>', 'CreationDate': '2013-08-18T12:19:35.963', 'FavoriteCount': '2', 'Id': '13801'},311_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was asked to "Compute the average runtime for a binary search, ordered array, and the key is in the array." I\'m not quite sure how to approach this problem. Isn\'t the runtime of binary search O(log n)? And the average would be something like n + n/2 + n/4... etc?</p>\n\n<p>I\'m then asked to "Implement a program performing an empirical test of the binary search (using a fixed number of random arrays for each n), then do a ratio test justifying your analytical answer." How would I go about doing this? Could I perform a basic binary search algorithm on a number of random arrays, counting the basic operations, and compare that to my original analysis from the first question?</p>\n\n<p>I appreciate any help/guidance here.</p>\n', 'ViewCount': '699', 'Title': 'How to analyze/test a binary search algorithm?', 'LastActivityDate': '2013-10-14T02:03:59.603', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '16060', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '10719', 'Tags': '<algorithm-analysis><runtime-analysis><binary-search>', 'CreationDate': '2013-10-13T22:58:49.533', 'Id': '16057'},311_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm studying for my CS final and I can't seem to get the anywhere with one of the questions.</p>\n\n<p>This is the question:</p>\n\n<p>Prove that if a node in a BST has a successor, but has no right child, then its successor must be an ancestor. (We will consider only BSTs with distinct elements.)</p>\n\n<p>I know that a successor is the node that replaces the deleted node, and that we only need to worry about this case when the node being deleted has two children, but I can't seem to start this proof.</p>\n\n<p>Any help?</p>\n", 'ViewCount': '51', 'Title': 'BST Successor Proof', 'LastActivityDate': '2013-12-02T17:27:33.667', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '10424', 'Tags': '<proof-techniques><binary-trees><binary-search>', 'CreationDate': '2013-12-01T22:36:10.517', 'FavoriteCount': '1', 'Id': '18512'},311_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider an unknown function $f(x,y)$, where $x$ and $y$ are just two scalar numbers in $[0,1]$. $f(x,y)$ is an increasing function of $y$ and is between $0$ and $1$ but is unknown.</p>\n\n<p>At each time I pick a value $y$ and process a value in a stream of $x$ numbers $x_i$, $i=1, 2, ...$ and need to find the minimum $y$ such that $f(x,y)&gt;0.8$.</p>\n\n<p>Is there any principled way to optimize the choices of $y$ assuming $x_i$s does not change fast?</p>\n\n<p>It may be related more to the control theory, but I thought a solution similar to binary search may work:</p>\n\n<p>Increase $y$ if $f(x,y)&lt;0.8$ and decrease it if $f(x,y)&gt;0.8$ using a step size.\nNow to ensure fast convergence double the step size if $f(A,B)$ does not change status and halve it if it passes $0.8$.\nThe difference with <a href="http://www8.cs.umu.se/kurser/TDBAfl/VT06/algorithms/BOOK/BOOK2/NODE55.HTM" rel="nofollow">one-sided binary search</a> is that binary search will always halve the step after it passes the bound once, but here we don\'t do that as the $x$ values might change.</p>\n', 'ViewCount': '35', 'Title': 'Binary search transition point of a function on stream', 'LastActivityDate': '2014-01-21T00:06:05.153', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7133', 'Tags': '<streaming-algorithm><binary-search>', 'CreationDate': '2014-01-21T00:06:05.153', 'Id': '19858'},311_5:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Please can anyone explain me the worst ,average and best case running time for the Unifrom binary search .. Also how can the lookup table be explained?</p>\n', 'ViewCount': '19', 'ClosedDate': '2014-04-01T07:40:45.420', 'Title': 'Uniform Binary Search explanation and lookup table', 'LastEditorUserId': '16347', 'LastActivityDate': '2014-04-01T08:37:14.043', 'LastEditDate': '2014-04-01T08:37:14.043', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16347', 'Tags': '<algorithms><algorithm-analysis><search-algorithms><binary-search>', 'CreationDate': '2014-04-01T06:48:15.420', 'Id': '23313'},311_6:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How would one search for a string of digits in a large digit sequence? For example, I'd like to search for <code>351814</code> in Euler's number. I'm not too keen on computer science, I'm a pure math major, so I don't really know how to begin. I also wouldn't know how to run said code.   </p>\n\n<p><strong>Any help would be greatly appreciated.</strong></p>\n", 'ViewCount': '85', 'ClosedDate': '2014-04-27T11:41:19.013', 'Title': 'Searching for a string of numbers in a large digit sequence', 'LastEditorUserId': '17106', 'LastActivityDate': '2014-04-27T11:41:04.027', 'LastEditDate': '2014-04-27T05:40:11.397', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16971', 'Tags': '<algorithms><search-algorithms><strings><binary-search>', 'CreationDate': '2014-04-22T00:40:36.540', 'Id': '24009'}