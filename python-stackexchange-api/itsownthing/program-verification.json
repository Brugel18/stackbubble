202_0:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to understand Hoare logic presented at Wikipedia,\n<a href="http://en.wikipedia.org/wiki/Hoare_logic" rel="nofollow">Hoare logic at Wikipedia</a>\nApparently, if I  understand correctly, a Hoare triple $$\\{P\\}~ C ~\\{Q\\}$$ means</p>\n\n<blockquote>\n  <p>if P just before C, then Q holds immediately after C, as long as C terminates. (A)</p>\n</blockquote>\n\n<p>However, the assignment axiom schema seems to be interpreted in a different way:</p>\n\n<p>$$\\frac{}{\\{P[x/E]\\} ~~x:=E~~   \\{P\\}}$$</p>\n\n<p>The wikipedia says:</p>\n\n<p>The assignment axiom means that the truth of $\\{P[x/E]\\}$ is equivalent to the after-assignment truth of $\\{P\\}$. Thus were $\\{P[x/E]\\}$ true prior to the assignment, by the assignment axiom, then $\\{P\\}$ would be true subsequent to which. Conversely, were $\\{P[x/E]\\}$ false prior to the assignment statement, $\\{P\\}$ must then be false consequently.</p>\n\n<p>I think the Hoare triple only affirms that if P[x/E] before x:=E, then P(x) holds after x:=E. It DOES NOT affirm, by its definition, that if P(x) holds after x:=E, then P[x/E] holds before x:=E. </p>\n\n<p>My naive question is, how can $\\{P[x/E]\\}$ before the assignment can be equivalent to $\\{P\\}$ after the assignment? Does this contradict with point (A) at the beginning of my post?</p>\n', 'ViewCount': '245', 'Title': 'Hoare triple for assignment P{x/E} x:=E {P}', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-16T21:09:01.143', 'LastEditDate': '2012-05-16T21:09:01.143', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '1867', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '694', 'Tags': '<logic><programming-languages><semantics><hoare-logic><program-verification>', 'CreationDate': '2012-05-16T09:09:24.887', 'Id': '1864'},202_1:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '501', 'Title': 'How do you check if two algorithms return the same result for any input?', 'LastEditDate': '2012-05-25T20:16:22.707', 'AnswerCount': '4', 'Score': '9', 'OwnerDisplayName': 'Andres Riofrio', 'PostTypeId': '1', 'OwnerUserId': '1638', 'FavoriteCount': '2', 'Body': u'<p>How do you check if two algorithms (say, Merge sort and Na\xefve sort) return the same result for any input, when the set of all inputs is infinite?</p>\n\n<p><strong>Update:</strong> Thank you <a href="http://cs.stackexchange.com/a/2062/1638">Ben</a> for describing how this is impossible to do algorithmically in the general case. <a href="http://cs.stackexchange.com/a/2063/1638">Dave\'s answer</a> is a great summary of both algorithmic and manual (subject to human wit and metaphor) methods that don\'t always work, but are quite effective.</p>\n', 'Tags': '<computability><formal-methods><software-engineering><software-verification><program-verification>', 'LastEditorUserId': '1638', 'LastActivityDate': '2012-05-25T20:16:22.707', 'CommentCount': '8', 'CreationDate': '2012-05-25T00:03:21.817', 'Id': '2059'},202_2:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I apologies if my title is vague, I'm trying to apply CTL/LTL model-checking on some system written in java, however, I still don't understand how to reach a result using either of the approaches mentioned. Do I model my LTS/write specification and use a tool like SPIN to validate that or? I'm mainly looking for a point at a direction that will help me in making a start.</p>\n\n<p>Again sorry but I made this thread after so much frustration searching for an explanation to my problem.</p>\n\n<p>Thank you</p>\n", 'ViewCount': '59', 'Title': 'applying CTL/LTL model-checking on some system', 'LastActivityDate': '2013-02-25T21:50:44.457', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10104', 'Score': '0', 'OwnerDisplayName': 'Meldar', 'PostTypeId': '1', 'OwnerUserId': '7069', 'Tags': '<model-checking><concurrency><program-verification>', 'CreationDate': '2013-02-21T13:21:01.257', 'Id': '10103'},202_3:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to cobble together a survey of different techniques used in formal verification of software. I need a classification and brief description of various methods. It could be chronological, by application domain, by mathematical model, by process or whatever.</p>\n\n<p>For example, the following paper considers only fully automated techniques that are in vogue:</p>\n\n<p>A survey of automated techniques for formal software verification\n<a href="http://www.eecs.berkeley.edu/~alanmi/publications/other/softver_tutorial.pdf" rel="nofollow">http://www.eecs.berkeley.edu/~alanmi/publications/other/softver_tutorial.pdf</a></p>\n\n<p>I want something a little more comprehensive. A short description of each approach or differences between approaches would also help. It is a little confusing because different authors seem to use different terms/classifications. Sometimes static analysis is taken to include model checking, and deductive verification does not find mention.</p>\n\n<p>EDIT: So far I have model checking, deductive verification, static analysis and program derivation as four broad categories. Could someone explain the main principle of these techniques/differences between them? Or if there are some techniques that are left out by the above classification. I would also like to further divide these categories into sub-categories</p>\n', 'ViewCount': '93', 'ClosedDate': '2013-11-02T22:00:31.233', 'Title': 'Taxonomy of formal methods of program verification', 'LastEditorUserId': '10708', 'LastActivityDate': '2013-10-29T15:09:58.083', 'LastEditDate': '2013-10-29T15:09:58.083', 'AnswerCount': '0', 'CommentCount': '8', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10708', 'Tags': '<formal-methods><software-verification><program-verification>', 'CreationDate': '2013-10-13T15:57:36.033', 'Id': '16040'},202_4:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Why does Program Synthesis seem to be defined in relation to program verification? Given a correct specification, why can't a program be synthesized (without reference to verification)?</p>\n\n<p>This question is specific to context of reactive program synthesis. For example, some explain that they perform model checking first, then synthesis.</p>\n", 'ViewCount': '23', 'ClosedDate': '2014-05-01T02:42:58.537', 'Title': 'Relation of program synthesis and verification', 'LastEditorUserId': '98', 'LastActivityDate': '2014-05-02T22:08:56.160', 'LastEditDate': '2014-05-02T22:08:56.160', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7579', 'Tags': '<reference-request><formal-methods><program-verification>', 'CreationDate': '2014-05-01T01:24:47.047', 'Id': '24283'}