{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a problem that can be viewed in two different ways:</p>\n\n<ol>\n<li><p>Compute an $n$-dimensional integral, numerical context. The domain of integration is an $n$-dimensional hyper-cube of side $L$.</p></li>\n<li><p>Count (just count) the roots of an $n$-dimensional function (not a polynomial).</p></li>\n</ol>\n\n<p>Solving just one of them is sufficient for solving the original problem.\nI know that simple algorithms for numerical integration would take $O(L^n)$, taking linear time per dimension. But I am not sure if there an asymptotically faster algorithms for (1). </p>\n\n<p>For (2), I am aware of algorithms that can find roots (Newton and Bisection), but I am not sure about the best algorithms just for counting how many roots are in a non-polynomial $n$-dimensional function.</p>\n\n<p>What are the best algorithms for (2)? Are they better than the fastest of (1)?</p>\n', 'ViewCount': '79', 'Title': 'numerical integral vs counting roots', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-14T19:29:09.583', 'LastEditDate': '2013-04-08T21:53:00.623', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2588', 'Tags': '<algorithms><numerical-analysis><counting>', 'CreationDate': '2013-04-08T21:02:35.247', 'Id': '11147'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to implement a bitonic counting network as a shared memory structure. \nI read through <a href="http://www.cs.yale.edu/homes/aspnes/papers/ahs.pdf" rel="nofollow">this paper</a> and understand how it works in principle and that we have the step property. Thus, we have n output variables/shared memory variables that count the arriving tokens. Whenever a token arrives, this value is incremented (by 1 or by n?). </p>\n\n<p>How do I get the current count of this network, without issuing another token? Getting the maximum of n shared variables (the outputs) doesn\'t seem like a good solution (not lock and wait free!)</p>\n', 'ViewCount': '52', 'Title': '(Bitonic) counting network: how to get the current count?', 'LastActivityDate': '2013-05-13T09:28:00.990', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6658', 'Tags': '<shared-memory><counting>', 'CreationDate': '2013-05-13T09:28:00.990', 'Id': '11986'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '102', 'Title': 'Preventing oversell, allocation of limited resources with overlapping properties', 'LastEditDate': '2013-05-29T12:21:39.890', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8380', 'FavoriteCount': '1', 'Body': '<p>I am trying to solve problem of preventing oversell of limited resources.</p>\n\n<p>Consider resources (people) who are described by set of properties where each property belongs to different category (example properties from four categories:  male, age 25-30, 2 children, interested in games).</p>\n\n<p>Buyers want to allocate access to resources. Buyers can specify subset of categories and one property from each category (example: allocate 1000 males, age 25-30 or allocate 100 females, age 25-30, interested in music).</p>\n\n<p>In my real life example I have 6m+ possible set of properties (profiles) where for each set of properties I know how many profiles exists.</p>\n\n<p>My initial approach was to build a graph like one below:</p>\n\n<p><img src="http://i.imgur.com/gQsXfWB.png" alt="alt text"></p>\n\n<p>and then traverse using edge weights, for instance validating if demand for 100 females, age2 can be satisfied:</p>\n\n<ol>\n<li>check if size(female, age2) &lt; 100</li>\n<li>for each parent:\n<ol>\n<li>check if size(parent) &lt; 100 and go to 2.</li>\n</ol></li>\n<li>for each child:\n<ol>\n<li>check if size(child) &lt; 100 * weight(edge(node, child)) go to 1.</li>\n</ol></li>\n</ol>\n\n<p>(above algorithm is simplified as does not prevent visiting same node multiple times)</p>\n\n<p>It all works fine when graph is small, however when number of nodes and edges (dependencies) between nodes (profile universe groups) grows it does not scale very well.</p>\n\n<p>Consider example:</p>\n\n<ul>\n<li>large graph, 6m nodes, 20m+ edges</li>\n<li>buyer wants to allocate 1000 males (and there are only males and females in gender category)</li>\n</ul>\n\n<p>algorithm would start with top-level \'male\' node which probably has 10m+ outgoing edges and 10m+ checks would be required (and probably each of those 10m outgoing edges has incoming edges which need to be checked as well).</p>\n\n<p>I was trying to find different approach but failed. I was trying to google out existing solutions but seems like I am unable to even name problem properly. Any reference to what is this problem similar to would be good for me as a starting point.</p>\n\n<p>Thanks for comments/help.</p>\n\n<p>Two more graphs to present exponential growth of the graph:\n3 categories\n<img src="http://i.imgur.com/gLg6Y6i.png" alt="alt text"></p>\n\n<p>4 categories\n<img src="http://i.imgur.com/0TM4mSy.png" alt="alt text"></p>\n\n<p><strong>Update</strong></p>\n\n<p>Regarding size, assuming 8 categories of properties where each category has: 2, 6, 6, 6, 6, 8, 1140, 150 values respectively then estimated number of profiles: 2*6^4*8*1140*150 ~= 3.5 * 10^9. Number of nodes in graph: at least 7 * 10^9, number of edges in graph: at least 140 * 10^9.</p>\n\n<p><strong>Update #2</strong></p>\n\n<p>Formula for number of nodes is:</p>\n\n<p>$\\sum_{i&lt;n}\\prod_{k&lt;i \\atop j_1, j_2, ..., j_k &lt; n} s_{j_{1}} ... s_{j_{n}}$</p>\n\n<p>where $n$ is number of categories and $s_x$ is size of category $x$.</p>\n\n<p>So in my example there would be 11\'169\'108\'657 nodes.</p>\n\n<p><strong>Update #3</strong></p>\n\n<p>As per @Raphael advice - I have reduced number of nodes and now formula is:</p>\n\n<p>$\\sum_{i&lt;n-M}\\prod_{k&lt;i \\atop j_1, j_2, ..., j_k &lt; n} s_{j_{1}} ... s_{j_{n}}$</p>\n\n<p>where $M&lt;n$ and assumed that distribution of resources across smallest slices of universe is equal.\nAt the same time removed lot of edges from graph.</p>\n\n<p>Example of sub-graph size reduction:\n<img src="http://i.stack.imgur.com/SSSU8.png" alt="Example of sub-graph size reduction"></p>\n', 'Tags': '<algorithms><databases><counting>', 'LastEditorUserId': '8380', 'LastActivityDate': '2013-05-29T12:21:39.890', 'CommentCount': '6', 'AcceptedAnswerId': '12327', 'CreationDate': '2013-05-27T10:45:05.100', 'Id': '12304'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I was wondering how many binary trees we have with height of $h$ with $n$ nodes(another question is how many binary trees we have with height $ \\lfloor{lg (n)}\\rfloor$).</p>\n\n<p>Edit: I forgot to add the number of nodes.</p>\n', 'ViewCount': '96', 'Title': 'Number of binary trees with given height', 'LastEditorUserId': '9909', 'LastActivityDate': '2013-08-31T09:32:48.273', 'LastEditDate': '2013-08-31T09:32:48.273', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '14049', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9909', 'Tags': '<data-structures><counting>', 'CreationDate': '2013-08-30T20:25:56.387', 'Id': '14043'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have a $n\\times n$ matrix called $M$, and two integers $k_\\min$ and $k_\\max$. \nEach row and each column of M is sorted in the increasing order. </p>\n\n<p>I would like to know if there is way I can count the number of its elements which are inside $[k_\\min, k_\\max]$, using a $O(n)$ algorithm.</p>\n', 'ViewCount': '95', 'Title': 'Count elements of a sorted matrix that fall into a given interval', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-17T17:14:17.943', 'LastEditDate': '2013-09-17T12:07:52.697', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'user10182', 'PostTypeId': '1', 'Tags': '<algorithms><search-algorithms><matrices><counting>', 'CreationDate': '2013-09-17T09:55:03.567', 'FavoriteCount': '1', 'Id': '14376'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $\\Sigma$ be the alphabet $\\{a, b, c, d\\}$ and let $R$ be the following relation on $\\Sigma^*$: $R(x, y)$ is true if every letter in string $x$ also occurs in $y$, and every letter in string $y$ also occurs in $x$.  (For example, $R(abba, babbb)$ is true and $R(abcb, cbbcb)$ is false.)  How many (non-empty) sets are in the partition of $\\Sigma^*$ corresponding to $R$?  (That is, how many equivalence classes does R have?)</p>\n\n<p>Any help will help.</p>\n', 'ViewCount': '38', 'Title': 'Counting involving equivalence classes and languages', 'LastEditorUserId': '204', 'LastActivityDate': '2013-10-21T14:37:08.860', 'LastEditDate': '2013-10-21T14:37:08.860', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'user2833171', 'PostTypeId': '1', 'Tags': '<logic><combinatorics><counting>', 'CreationDate': '2013-10-01T01:52:14.287', 'Id': '16282'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am looking for an efficient way to count the number of coprime vectors in a finite and bounded set of integer vectors.</p>\n\n<p>The vectors in my set are $N$-dimensional integer vectors whose components are bounded on the top and bottom by an arbitrary value $K$. Let $x = [x_1,x_2,\\ldots,x_N]$ denote a vector from this set. Then $x$ is <em>coprime</em> if the greatest common denominator of all its elements is 1. That is, $\\gcd(x_1,x_2,...,x_N)=1$.</p>\n\n<p>Some 3-dimensional coprime vectors include: $x = [1,2, 3] , [6, 10, 15] ,[0, 1, 1]$<br>\nSome 3-dimensional non-coprime vectors include: $x = [2,4,6] ,[0, 10, 15] ,[0, 12, 12]$</p>\n\n<p>For fixed $N$ and $K$, my set contains a total of $(2K+1)^N$ distinct integer vectors as each of the $N$ elements can take on integer values from $-K,\\ldots,0,\\ldots,K$. \nA brute-force approach for counting the number of coprime vectors consists of iterating over each of the $(2K+1)^N$ possible vectors and checking to see whether they are coprime (using, for instance, <a href="http://stackoverflow.com/questions/20206152/how-to-quickly-check-if-an-array-is-coprime-using-matlab">this function</a>). Unfortunately, this approach quickly runs into time and memory issues for large values of $N$ and $K$.</p>\n\n<p>I am wondering if anyone can think of a way to smart algorithm to do this. Ideally, I am looking to implement this algorithm as a MATLAB function that can number of coprime pairs given $N$ and $K$ as its input.</p>\n', 'ViewCount': '61', 'Title': 'Counting the number of N-dimensional coprime integer vectors', 'LastActivityDate': '2013-12-03T08:16:42.663', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '18564', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2046', 'Tags': '<discrete-mathematics><counting><primes>', 'CreationDate': '2013-12-03T00:57:34.597', 'Id': '18552'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>(This may be more fitting for CSTheory, I\'m not sure.)</p>\n\n<p>I\'m looking for an practical or theoretical work (that is, academic papers, online jots, pseudocode or code) regarding efficient algorithms for the following problem:</p>\n\n<h2>Unknown-Number-of-Bins Histogram</h2>\n\n<p><strong>Inputs:</strong></p>\n\n<ul>\n<li>An array of integers $a$, of length $n$.</li>\n</ul>\n\n<p><strong>Outputs:</strong> </p>\n\n<ul>\n<li>An array of integers $\\text{bins}$ of length $m &lt;= n$.</li>\n<li>An array of unsigned integers $\\text{counts}$, also of length $m$.</li>\n</ul>\n\n<p><strong>Output Requirements:</strong> </p>\n\n<ul>\n<li><p>For every $i \\in \\{0...m-1\\}$ it must be the case that </p>\n\n<p>$\\bigl|\\bigl\\{ j \\in \\{0...n-1\\} \\mid a_j = \\text{bins}_i \\bigr\\}\\bigr|$\n$ = \\text{counts}_i$</p>\n\n<p>In other words, $\\text{bins}$ and $\\text{counts}$ constitute a histogram of $a$, with one bin for every unique value in $a$.</p></li>\n<li>It is <strong>not</strong> required for $\\text{bins}$ or $\\text{counts}$ to be sorted.</li>\n</ul>\n\n<p><strong>Other Notes:</strong></p>\n\n<ul>\n<li>Complexity is considered as a function of <strong>both $n$ and $m$</strong>. </li>\n<li>Low time complexity is required both asymptotically for relatively low values $m$ - but not for low values of $n$.</li>\n<li>No hiding monstrosities in the $\\mathop{O}(\\cdot)$ constants please!</li>\n<li>A parallel(izable) approach? You are most welcome :-)</li>\n<li>Low space complexity is a benefit.</li>\n<li>Deterministic algorithms preferred, and barring that, go easy on those coin flips.</li>\n</ul>\n\n<p>Clearly, there are many way to go about this, some very straightforward, e.g. "sort the input, then build a sorted histogram in a single pass", in $\\mathop{O}(n \\log{n})$ time. Of course I wanted something better....</p>\n', 'ViewCount': '62', 'Title': 'Computing a histogram with the number of extant values not known in advance', 'LastEditorUserId': '11796', 'LastActivityDate': '2013-12-16T09:13:58.833', 'LastEditDate': '2013-12-16T09:13:58.833', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11796', 'Tags': '<algorithms><combinatorics><integers><counting>', 'CreationDate': '2013-12-14T12:42:42.897', 'Id': '18979'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>This was asked in a recent contest.\nThe question asked to count the number of ways to color an $M \\times N$ matrix with $K$ colours such that no two adjacent cells (sharing an edge) have the same color.\nIn other words, I want to count the number of different graph colorings of a grid graph: the graph of a $N \\times M$ grid. The limits were $1 \\le N,M \\le 8$ and $1 \\le K \\le 1000000000$.</p>\n\n<p>Is it possible to count the number of colors using the inclusion-exclusion principle, and if so, how? I saw <a href="http://cs.stackexchange.com/q/19288/98">another question</a> that solves the special case (where $M=2$) using inclusion-exclusion, so I\'m wondering if that kind of approach can be generalized here.</p>\n', 'ViewCount': '89', 'Title': 'Calculate number of ways to color matrix using inclusion-exclusion principle', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-21T08:14:00.150', 'LastEditDate': '2014-03-21T08:04:40.733', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8655', 'Tags': '<graph-theory><combinatorics><counting><colorings>', 'CreationDate': '2014-01-19T07:03:15.513', 'Id': '19822'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>As a matter of curiosity I've been trying to determine at what point a 64-bit float no longer reflects the addition of 1 as expected; that is, at what point the digits as printed do not correspond to the digits of a 64-bit integer that is incremented in sync.</p>\n\n<p>Around 1e15 I can continually add 1 or subtract 1 and the result seems right. At 1e16 the addition or subtraction of 1 has no effect on the value as printed. However, 1e16 - 2 gives 9.999999999999998e+15 (at least, as printed by go's fmt package).</p>\n\n<p>I wonder whether there are discontinuities in the sequence of sums of n+=1 while n &lt; 1e15. At what point does n+=1 no longer produce a result corresponding to the expected integer?</p>\n", 'ViewCount': '40', 'Title': 'When does the IEEE-754 64-bit float break as a counter', 'LastActivityDate': '2014-02-03T13:40:42.783', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '20228', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '13333', 'Tags': '<floating-point><counting>', 'CreationDate': '2014-02-02T18:12:17.353', 'Id': '20224'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I got a problem related to graph theory - </p>\n\n<p>Consider an undirected graph \u0729 where self-loops are not allowed. The vertex set of G is\n{(i,j):1&lt;=i,j &lt;=12}. There is an edge between (a, b) and (c, d) if |a-c|&lt;=1 and |b-d|&lt;=1\nThe number of edges in this graph is </p>\n\n<p>Answer is given as 506\nbut I am calculating it as 600, please see attachment.</p>\n\n<p>I am unable to get why it is coming as 506 instead of 600.</p>\n\n<p>Thanks<img src="http://i.stack.imgur.com/IKmgx.png" alt="enter image description here"></p>\n', 'ViewCount': '53', 'Title': 'number of edges in a graph', 'LastEditorUserId': '16546', 'LastActivityDate': '2014-04-08T14:01:25.283', 'LastEditDate': '2014-04-08T07:50:57.403', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '23533', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11750', 'Tags': '<graph-theory><graphs><combinatorics><counting>', 'CreationDate': '2014-04-08T06:39:12.977', 'Id': '23532'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am working on acyclic orientations of undirected graphs and have the following questions: </p>\n\n<ol>\n<li>Given connected undirected simple graph $G$, how to find all possible acyclic orientations of $G$ ? </li>\n<li>What is the number of acyclic orientations? \nIt is known (from <a href="http://math.mit.edu/~rstan/pubs/pubfiles/18.pdf">here</a>) to be $(-1)^p\\ \\chi(G,-\\lambda)$ for a graph $G$ with $p$ vertices where $\\chi$ is the chromatic polynomial evaluated at $-\\lambda$; but I wasn\'t successful in understanding how to evaluate $\\chi$ at a negative value ($-\\lambda$).  </li>\n</ol>\n', 'ViewCount': '62', 'Title': 'Algorithm to find all acyclic orientations of a graph', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-28T17:24:29.400', 'LastEditDate': '2014-04-28T03:02:59.220', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4598', 'Tags': '<algorithms><graph-theory><counting>', 'CreationDate': '2014-04-28T02:49:32.510', 'Id': '24171'}},