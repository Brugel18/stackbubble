{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $T = (V, E)$ be a tree with a designated root $r \\in V$. The fact that the tree is rooted allows us to speak of "subtrees of $T$ rooted at some node $x \\in V$". Let\'s say we have a (not necessarily injective) function $c: V \\rightarrow \\mathbb{N}$ that assigns a color to every node. </p>\n\n<p>We want to find for every node $x \\in V$ the number of distinct colors in the subtree rooted at $x$. So if $A(x)$ is the set of children of $x$, we want to find for every node $x$, the cardinality of the set </p>\n\n<p>$S(x) = \\bigcup_{y\\in A(x)} S(y) \\cup \\{c(x)\\}$</p>\n\n<p>There is a rather simple algorithm that solves this problem offline in $O(n \\log^2 n)$:</p>\n\n<ul>\n<li>Process the nodes in depth-first order</li>\n<li>Represent the sets $S(x)$ as a persistent, self-balancing binary search trees</li>\n<li>For every node $x$, let $y \\in A(x)$ be the child of $x$ that maximizes $|S(y)|$.  Now we just merge for every other child $z \\in A(x) \\setminus {y}$ the set $S(z)$ into the set $S(y)$ via insertion. We also insert $c(x)$ and now have $S(x)$ as a binary search tree and can give the answer for node $x$</li>\n</ul>\n\n<p>We can even avoid the persistent trees by mutating the subresult for the heaviest child instead of creating a new set.</p>\n\n<p>The typical argument I have seen to justify the bound is the following:</p>\n\n<blockquote>\n  <p>A "move" consist of taking an element from a set and inserting it in another set.\n  Let\'s prove that there\'s at most $O(n \\log n)$ moves, each move can be done in $O(\\log n)$, the total complexity is $O(n \\log^2 n)$.</p>\n  \n  <p>When you are merging two sets you move all elements from smaller set (assume its size is $k$) to the bigger one, so every element in the smaller set now is in a set with at least size $2k$. In other words every element that has been moved $t$ times is in a set with at least size $2^t$, thus every element will be moved at most $O(\\log n)$ and we have $n$ elements so in total there will be at most $O(n \\log n)$ move operations.</p>\n</blockquote>\n\n<p>(Quote from a <a href="http://codeforces.com/blog/entry/10696" rel="nofollow">Codeforces comment</a>).</p>\n\n<p>While this is a beautiful argument, it\'s not <em>quite</em> correct, because usually we remove duplicates, so sets don\'t in fact grow exponentially (for example if every node has the same color). </p>\n\n<p>I am convinced that the bound holds, because I can prove it using structural induction. What I want to know is the following:</p>\n\n<ul>\n<li>Is there a way to prove the $O(n \\log^2 n)$ bound using an argument similar to the above, by bounding the number of "moves" of the color of a node? In other words, can the proof be "fixed" easily?</li>\n<li>The argument from above would also hold in DAGs, not only in trees. However it seems unlikely that we could achieve a runtime better than $O(n \\cdot m)$ to solve this problem in a DAG, so I guess there is no fix for the proof idea in this case. Am I right? Is there a good intuition for that?</li>\n</ul>\n', 'ViewCount': '36', 'Title': 'Merge-by-weight to solve reachability problems in trees and DAGs', 'LastEditorUserId': '755', 'LastActivityDate': '2014-03-18T06:54:34.033', 'LastEditDate': '2014-03-18T06:54:34.033', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '22744', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '13167', 'Tags': '<graphs><trees><complexity-proof>', 'CreationDate': '2014-03-17T22:31:30.940', 'Id': '22725'}}