{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '315', 'Title': 'How many shortest distances change when adding an edge to a graph?', 'LastEditDate': '2012-04-06T09:55:35.533', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '92', 'FavoriteCount': '2', 'Body': '<p>Let $G=(V,E)$ be some complete, weighted, undirected graph. We construct a second graph $G&#39;=(V, E&#39;)$ by adding edges one by one from $E$ to $E&#39;$. We add $\\Theta(|V|)$ edges to $G&#39;$ in total.</p>\n\n<p>Every time we add one edge $(u,v)$ to $E&#39;$, we consider the shortest distances between all pairs in $(V, E&#39;)$ and $(V, E&#39; \\cup \\{ (u,v) \\})$. We count how many of these shortest distances have changed as a consequence of adding $(u,v)$. Let $C_i$ be the number of shortest distances that change when we add the $i$th edge, and let $n$ be the number of edges we add in total.</p>\n\n<blockquote>\n  <p>How big is $C = \\frac{\\sum_i C_i}{n}$?</p>\n</blockquote>\n\n<p>As $C_i = O(|V|^2)=O(n^2)$, $C=O(n^2)$ as well. Can this bound be improved? Note that I define $C$ to be the average over all edges that were added, so a single round in which a lot of distances change is not that interesting, though it proves that $C = \\Omega(n)$.</p>\n\n<p>I have an algorithm for computing a geometric t-spanner greedily that works in $O(C n \\log n)$ time, so if $C$ is $o(n^2)$, my algorithm is faster than the original greedy algorithm, and if $C$ is really small, potentially faster than the best known algorithm (though I doubt that).</p>\n\n<p>Some problem-specific properties that might help with a good bound: the edge $(u,v)$ that is added always has larger weight than any edge already in the graph (not necessarily strictly larger). Furthermore, its weight is shorter than the shortest path between $u$ and $v$.</p>\n\n<p>You may assume that the vertices correspond to points in a 2d plane and the distances between vertices are the Euclidian distances between these points. That is, every vertex $v$ corresponds to some point $(x,y)$ in the plane, and for an edge $(u,v)=((x_1,y_1),(x_2,y_2))$ its weight is equal to $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2.}$</p>\n', 'Tags': '<algorithms><graphs><graph-theory><shortest-path>', 'LastEditorUserId': '92', 'LastActivityDate': '2014-01-19T02:02:00.257', 'CommentCount': '11', 'AcceptedAnswerId': '1063', 'CreationDate': '2012-04-05T19:15:54.200', 'Id': '1062'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to implement bidirectional search in a graph. I am using two breadth first searches from the start node and the goal node. The states that have been checked are stored in two hash tables (closed lists).\nHow can I get the solution (path from the start to the goal), when I find that a state that is checked by one of the searches is in the closed list of the other?</p>\n\n<p>EDIT </p>\n\n<p>Here are the explanations from the book:\n<em>"Bidirectional search is implemented by having one or both of the searches check each\nnode before it is expanded to see if it is in the fringe of the other search tree; if so, a solution has been found... Checking a node for membership in the other search tree can be done in constant time with a hash table..."</em></p>\n\n<p>Some pages before: \n<em>"A node is a boolkkeeping data structure used to represent the search tree. A state corresponds to a configuration of the world... two different nodes can contain the same world state, if that state is generated via two different search paths."</em> So from that I conclude that if nodes are kept in the hash tables than a node from the BFS started from the start node would not match a node constructed from the other BFS started from the goal node.</p>\n\n<p>And later in general Graph search algorithm the states are stored in the closed list, not the nodes, but it seems to me that even that the states are saved in the hash tables after that the nodes are retrieved from there.</p>\n', 'ViewCount': '546', 'Title': 'How to construct the found path in bidirectional search', 'LastEditorUserId': '770', 'LastActivityDate': '2012-05-01T21:04:41.210', 'LastEditDate': '2012-04-07T21:08:01.660', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '1620', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '770', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2012-04-07T16:12:39.053', 'Id': '1113'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>So I thought this (though somewhat basic) question belonged here:</p>\n\n<p>Say I have a graph of size 100 nodes arrayed in a 10x10 pattern (think chessboard). The graph is undirected, and unweighted. Moving through the graph involves moving three spaces forward and one space to either right or left (similar to how a chess knight moves across a board).</p>\n\n<p>Given a fixed beginning node, how would one find the shortest path to any other node on the board?</p>\n\n<p>I imagined that there would only be an edge between nodes that are viable moves. So, given this information, I would want to find the shortest path from a starting node to an ending node.</p>\n\n<p>My initial thought was that each edge is weighted with weight 1. However, the graph is undirected, so Djikstras would not be an ideal fit. Therefore, I decided to do it using an altered form of a depth first search.</p>\n\n<p>However, I couldn't for the life of me visualize how to get the shortest path using the search.</p>\n\n<p>Another thing I tried was putting the graph in tree form with the starting node as the root, and then selecting the shallowest (lowest row number) result that gave me the desired end node... this worked, but was incredibly inefficient, and thus would not work for a larger graph.</p>\n\n<p>Does anyone have any ideas that might point me in the right direction on this one?</p>\n\n<p>Thank you very much.</p>\n\n<p>(I tried to put in a visualization of the graph, but was unable to due to my low reputation)</p>\n", 'ViewCount': '2595', 'Title': 'Shortest Path on an Undirected Graph?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-05-01T22:38:48.113', 'LastEditDate': '2012-04-18T05:56:13.197', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '1330', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<algorithms><graphs><graph-theory><search-algorithms><shortest-path>', 'CreationDate': '2012-04-18T04:23:36.273', 'Id': '1329'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>So, I'm trying to conceptualize something:</p>\n\n<p>Say we have a weighed graph of size N. A and B are nodes on the graph. You want to find the shortest path from A to B, given a few caveats:</p>\n\n<ol>\n<li><p>movements on the graph are regulated by a circular cycle of length 48, in such a manner that:</p>\n\n<blockquote>\n  <p>cycle{</p>\n\n<pre><code>     0 &lt;= L &lt;= 24  movement IS possible\n\n    25 &lt;= L &lt;= 48 movement IS NOT possible\n</code></pre>\n  \n  <p>}</p>\n</blockquote>\n\n<p>For simplicity's sake, we will call this cycle 'time'.</p></li>\n<li><p>The distance between nodes A and B is equal to:</p>\n\n<blockquote>\n  <p>shortest_distance(A to B) - 1 OR shortest_distance(A to B) + 1</p>\n</blockquote>\n\n<p>Depending on their orientation</p></li>\n<li><p>the weight of the edges represents the 'time' it takes to travel between nodes.</p></li>\n</ol>\n\n<p>I'd like to create an algorithm that will give me the shortest path with these constraints in mind, assuming one is leaving from node A at time(cycle) = 12, traveling towards node B. The shortest path would be defined as the path which takes the least 'time'.</p>\n\n<p>Step one would obviously be to take into account the orientation affecting the shortest distance (i.e. which way are they oriented by above), which would be a simple addition or substraction to the result of djikstra's algorithm</p>\n\n<p>What I'm having trouble figuring out is how to account for the cycle in the algorithm... could it be as simple as just an if statement checking to see if the current cycle time is within the constraints that allow movement?</p>\n\n<p>Would my idea be viable? If not, does anyone h ave any suggestions at different ways I should look at this problem?</p>\n\n<p>I know this question seems really basic, but I just can't wrap my head around it.</p>\n", 'ViewCount': '155', 'Title': "Modified Djikstra's algorithm", 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-18T15:00:39.803', 'LastEditDate': '2012-04-18T05:48:56.107', 'AnswerCount': '1', 'CommentCount': '5', 'AcceptedAnswerId': '1341', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1132', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2012-04-18T05:30:45.100', 'Id': '1332'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I have a "smarter" version of Bellman-Ford here; this version is more clever about choosing the edges to relax.</p>\n\n<pre><code>//Queue Q; source s; vertices u, v; distance to v d(v)\nQ \u2190 s // Q holds vertices whose d(v) values have been updated recently.\nWhile (Q !empty) {\n  u \u2190 Dequeue(Q)\n  for each neighbor v of u {\n    Relax(u, v)\n    if d(v) was updated by Relax and v not in Q\n      Enqueue(v)\n  }\n}\n</code></pre>\n\n<p>But, can anyone explain why this improved version correctly finds the shortest path from $s$ to every other vertex in a directed graph with no negative cycles?</p>\n\n<p>Also, what is the <em>worst-case</em> runtime if every shortest path uses at most $v$ edges?</p>\n', 'ViewCount': '458', 'Title': 'Bellman-Ford variation', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-25T05:17:22.893', 'LastEditDate': '2012-05-24T07:55:34.530', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '1624', 'Tags': '<algorithms><graphs><graph-theory><runtime-analysis><shortest-path>', 'CreationDate': '2012-05-24T01:44:55.237', 'FavoriteCount': '2', 'Id': '2039'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Most books explain the reason the algorithm doesn't work with negative edges as nodes are deleted from the priority queue after the node is arrived at since the algorithm assumes the shortest distance has been found. However since negative edges can reduce the distance, a future shorter distance might be found; but since the node is deleted it cannot be updated.</p>\n\n<p>Wouldn't an obvious solution to this be to <em>not delete the node</em>? Why not keep the node in the queue, so if a future <em>shorter</em> distance is found, it can be updated? If I am misunderstanding the problem, what <em>is</em> preventing the algorithm from being used with negative edges?</p>\n", 'ViewCount': '4441', 'Title': "Using Dijkstra's algorithm with negative edges?", 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-16T02:00:29.480', 'LastEditDate': '2012-06-25T17:22:17.767', 'AnswerCount': '4', 'CommentCount': '9', 'Score': '4', 'OwnerDisplayName': 'user1422', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2012-06-24T03:13:44.967', 'Id': '2482'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Is there an algorithm for finding the shortest path in an undirected weighted graph?</p>\n', 'ViewCount': '1289', 'Title': 'Finding the Shortest path in undirected weighted graph', 'LastEditorUserId': '72', 'LastActivityDate': '2012-09-23T14:05:51.613', 'LastEditDate': '2012-09-23T14:05:51.613', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2890', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2012-09-20T13:36:31.857', 'Id': '4629'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm designing an algorithm for a class that will determine if a directed graph is unique with respect to a vertex $v$ such that for any $u \\ne v$ there is at most one path from $v$ to $u$. I've started by using BFS (breadth-first search) to find the shortest path from v to another vertex u, and then running BFS again to see if an alternate path can be found from v to u. I think this is too time consuming however. Does anyone have any hints as to how the solution can be found with a shorter execution time?</p>\n", 'ViewCount': '221', 'Title': 'Unique path in a directed graph', 'LastEditorUserId': '472', 'LastActivityDate': '2012-12-13T02:10:52.957', 'LastEditDate': '2012-12-13T02:10:52.957', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '4713', 'Score': '6', 'OwnerDisplayName': 'el diablo', 'PostTypeId': '1', 'Tags': '<graph-theory><shortest-path><graph-traversal>', 'CreationDate': '2008-12-08T22:07:40.493', 'Id': '4711'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '852', 'Title': 'Dijkstra to favor solution with smallest number of edges if several paths have same weight', 'LastEditDate': '2012-10-07T06:39:29.413', 'AnswerCount': '1', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2826', 'FavoriteCount': '1', 'Body': "<p>You can modify any graph $G$ so that Dijkstra's finds the solution with the minimal number of edges thusly:</p>\n\n<p>Multiply every edge weight with a number $a$, then add $1$ to the weight to penalize each additional edge in the solution, i.e. </p>\n\n<p>$w'(u,v)=a*w(u,v)+1$</p>\n\n<p>This does not work for all values of $a$; $a$ needs to be at least $x$ for this to work. If $a$ is not this minimum number, it might not choose the shortest path. How do I find this minimum value $x$?</p>\n\n<p>Ps. This was done recreationally, I'm done with homework long ago.</p>\n", 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '2826', 'LastActivityDate': '2012-10-07T22:16:23.373', 'CommentCount': '3', 'AcceptedAnswerId': '4936', 'CreationDate': '2012-10-05T15:07:58.803', 'Id': '4887'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3252', 'Title': "Why can't DFS be used to find shortest paths in unweighted graphs?", 'LastEditDate': '2012-10-07T13:03:05.600', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2826', 'FavoriteCount': '2', 'Body': '<p>I understand that using DFS "as is" will not find a shortest path in an unweighted graph. </p>\n\n<p>But why is tweaking DFS to allow it to find shortest paths in unweighted graphs such a hopeless prospect? All texts on the subject simply state that it cannot be done. I\'m unconvinced (without having tried it myself). </p>\n\n<p>Do you know any modifications that will allow DFS to find the shortest paths in  unweighted graphs? If not, what is it about the algorithm that makes it so difficult?</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T09:21:07.067', 'CommentCount': '2', 'AcceptedAnswerId': '4927', 'CreationDate': '2012-10-07T08:07:18.370', 'Id': '4914'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '963', 'Title': 'Finding paths with smallest maximum edge weight', 'LastEditDate': '2012-10-08T09:00:08.523', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'Jiew Meng', 'PostTypeId': '1', 'OwnerUserId': '3099', 'FavoriteCount': '1', 'Body': '<p>I need to find the easiest cost path between two vertices of a graph. Easiest here means the path with the smallest maximum-weigth edge. </p>\n\n<p><img src="http://i.stack.imgur.com/WWszV.png" alt="enter image description here"></p>\n\n<p>In the above graph, the easiest path from 1 to 2 is: </p>\n\n<pre><code>1 &gt; 3 &gt; 4 &gt; 2\n</code></pre>\n\n<p>Because the maximum edge weight is only 2. On the other hand, the shortest path <code>1 -&gt; 2</code> has maximum weight 4. </p>\n\n<p>So it\'s an MST problem. I am thinking I will use Kruskal\'s algorithm to build the tree, but I\'m not sure how exactly. I will know the edges but how do I "reconstruct" the path? For example, given vertices <code>3</code> and <code>2</code>, how do I know to go left (top) of right in the tree? Or do I try both ways? </p>\n', 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-08T09:00:08.523', 'CommentCount': '3', 'AcceptedAnswerId': '4943', 'CreationDate': '2012-10-08T03:50:33.827', 'Id': '4942'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am currently working on a project where I\'m using an implementation of Hoffman and Pavley\'s "<a href="http://dl.acm.org/citation.cfm?doid=320998.321004" rel="nofollow">Method for the Solution of the Nth Best Path Problem</a>" to find n-th best path through a directed graph. The implementation is based on <a href="http://quickgraph.codeplex.com/wikipage?title=Ranked%20Shortest%20Path" rel="nofollow">QuickGraph\'s Ranked Shortest Path implementation</a>.</p>\n\n<p>I have been trying to determine the complexity of Hoffman and Pavley\'s algorithm as well as QuickGraph\'s implementation, but without any luck -- so basically my question is if someone knows the complexity of the original method proposed by Hoffman and Pavley as well as the complexity of QuickGraph\'s implementation?</p>\n', 'ViewCount': '175', 'Title': "What is the complexity of Hoffman and Pavley's Nth best path algorithm?", 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-02T10:09:43.120', 'LastEditDate': '2012-11-02T10:09:43.120', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4433', 'Tags': '<algorithms><time-complexity><graphs><algorithm-analysis><shortest-path>', 'CreationDate': '2012-11-02T08:43:34.007', 'FavoriteCount': '1', 'Id': '6444'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>For directed graph $(G=(V, E),s,t,{Ce})$ in which we want to maximize max flow. All edge capacities are at least one. Define the capacity of an $s \\to t$ path to be the smallest capacities of constituent edges. The fastest path from $s$ to $t$ is the path with the most capcity.</p>\n\n<p>b) Show that the fastest path from $s$ to $t$ in a graph can be computed by Dijkstra's algorithm.</p>\n\n<p>c) Show that the maximum flow in $G$ is the sum of individual flows along at most $|E|$ paths from $s$ to $t$.</p>\n\n<p>It's one of the questions from my algorithms assignment, and I figured out (a), but can't get these two above.</p>\n", 'ViewCount': '418', 'Title': "Dijskstra's algorithm, maximum flow", 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-11T17:50:53.390', 'LastEditDate': '2012-11-09T22:10:28.233', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '4523', 'Tags': '<algorithms><graphs><optimization><shortest-path><network-flow>', 'CreationDate': '2012-11-09T19:31:05.533', 'Id': '6586'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1199', 'Title': 'Formalization of the shortest path algorithm to a linear program', 'LastEditDate': '2012-12-23T09:32:01.477', 'AnswerCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2329', 'FavoriteCount': '2', 'Body': '<p>I\'m trying to understand a formalization of the shortest path algorithm to a linear programming problem:</p>\n\n<p>For a graph $G=(E,V)$, we defined  $F(v)=\\{e \\in E \\mid t(e)=v \\}$ and $B(v)=\\{ e \\in E \\mid h(e)=v\\}$ where $t(e)$ is a tail of a node, and  $h(e)$ is a head of a node.</p>\n\n<p>Also the solutions for the conditions for the linear problem was defined as $b_v=1$ for every node $v$ except of the root $r$ which from it we find all the shortest paths in the graph where $b_r=-(n-1)$. It is written here "We associate a flow (primal variable) $x_e$ with each arc $e \\in E$.</p>\n\n<p>The main linear program is to minimize $\\sum\\limits_{e\\in E }c_ex_e$, subject to $\\sum\\limits_{e\\in B(v)}x_e-\\sum\\limits_{e\\in F(v)}x_e=b_v$ for all $v \\in V$ and $x_e \\geq 0$ for all $e \\in E$, where $c_e$ is the length of arc $e$.</p>\n\n<p>I\'d really love your help with understanding what does $x_e$ represent. Is it the number of times I use $e$ in order to find all the shortest paths in the graph?</p>\n\n<p>I don\'t understand why does the above condition for this linear program is as at it, why does  $\\sum\\limits_{e\\in B(v)}x_e-\\sum\\limits_{e\\in F(v)}x_e=b_v$ for all $v \\in V$ should  be $1$ for every node and $-(n-1)$ for the all the root? If I think of a $3$ nodes tree for a graph,for  the middle node we get that the condition equals to $1$, which makes me think that I might be misunderstood what $x_e$ stands for.</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path><linear-programming>', 'LastEditorUserId': '3016', 'LastActivityDate': '2012-12-23T12:30:04.713', 'CommentCount': '6', 'AcceptedAnswerId': '7562', 'CreationDate': '2012-11-17T15:59:11.327', 'Id': '6717'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1322', 'Title': 'Finding negative cycles for cycle-canceling algorithm', 'LastEditDate': '2012-11-20T09:31:55.460', 'AnswerCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '4', 'Body': '<p>I am implementing the cycle-canceling algorithm to find an optimal solution for the min-cost flow problem. By finding and removing negative cost cycles in the residual network, the total cost is lowered in each round. To find a negative cycle I am using the bellman-ford algorithm.</p>\n\n<p>My Problem is:\nBellman-ford only finds cycles that are reachable from the source, but I also need to find cycles that are not reachable.</p>\n\n<p>Example: In the following network, we already applied a maximum flow. The edge $(A, B)$ makes it very expensive. In the residual network, we have a negative cost cycle with capacity $1$. Removing it, would give us a cheaper solution using edges $(A, C)$ and $(C, T)$, but we cannot reach it from the source $S$.</p>\n\n<p>Labels: Flow/Capacity, Cost</p>\n\n<p><img src="http://i.stack.imgur.com/jKtUd.png" alt="enter image description here"></p>\n\n<p>Of course, I could run Bellman-ford repeatedly with each node as source, but that does not sound like a good solution. I\'m a little confused because all the papers I read seem to skip this step.</p>\n\n<p>Can you tell me, how to use bellman-ford to find every negative cycle (reachable or not)?\nAnd if not possible, which other algorithm do you propose?</p>\n', 'Tags': '<algorithms><graph-theory><shortest-path><network-flow>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-20T17:17:58.753', 'CommentCount': '3', 'AcceptedAnswerId': '6789', 'CreationDate': '2012-11-19T20:56:27.043', 'Id': '6773'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1104', 'Title': u"Modifying Dijkstra's algorithm for edge weights drawn from range $[1,\u2026,K]$", 'LastEditDate': '2012-11-21T08:01:32.647', 'AnswerCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '4193', 'FavoriteCount': '2', 'Body': '<p>Suppose I have a directed graph with edge weights drawn from range $[1,\\dots, K]$ where $K$ is constant. If I\'m trying to find the shortest path using <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a>, how can I modify the algorithm / data structure and improve the time complexity to $O(|V|+|E|)$?</p>\n', 'Tags': '<algorithms><data-structures><shortest-path><weighted-graphs>', 'LastEditorUserId': '2205', 'LastActivityDate': '2012-11-21T20:43:49.977', 'CommentCount': '6', 'AcceptedAnswerId': '6820', 'CreationDate': '2012-11-21T03:08:52.193', 'Id': '6797'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>The <a href="http://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman-Ford algorithm</a> determines the shortest path from a source $s$ to all other vertices. Initially the distance between $s$ and all other vertices is set to $\\infty$. Then the shortest path from $s$ to each vertex is computed; this goes on for  $|V|-1$ iterations. My questions are:</p>\n\n<ul>\n<li>Why does there need to be $|V|-1$ iterations?</li>\n<li>Would it matter if I checked the edges in a different order?<br>\nSay, if I first check edges 1,2,3, but then on the second iteration I check 2,3,1. </li>\n</ul>\n\n<p>MIT  Prof. Eric said the order didn\'t matter, but this confuses me: wouldn\'t the algorithm incorrectly update a node based on edge $x_2$ if its value was dependent on the edge $x_1$ but $x_1$ is updated after $x_2$?</p>\n', 'ViewCount': '510', 'Title': 'Bellman-Ford algorithm - Why can edges be updated out of order?', 'LastEditorUserId': '4304', 'LastActivityDate': '2013-08-01T05:40:27.860', 'LastEditDate': '2012-11-25T21:17:42.783', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '6914', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4193', 'Tags': '<algorithms><shortest-path>', 'CreationDate': '2012-11-25T19:11:25.800', 'Id': '6894'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3522', 'Title': 'Getting negative cycle using Bellman Ford', 'LastEditDate': '2012-11-26T15:11:04.630', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4298', 'FavoriteCount': '2', 'Body': '<p>I have to find a negative cycle in a directed weighted graph. I know how the Bellman Ford algorithm works, and that it tells me if there is a reachable negative cycle. But it does not explicitly name it.</p>\n\n<p>How can I get the actual path $v1, v2, \\ldots vk, v1$ of the cycle?</p>\n\n<p>After applying the standard algorithm we already did $n-1$ iterations and no further improvement should be possible. If we can still lower the distance to a node, a negative cycle exists.</p>\n\n<p>My idea is: Since we know the edge that can still improve the path and we know the predecessor of each node, we can trace our way back from that edge until we meet it again. Now we should have our cycle.</p>\n\n<p>Sadly, I did not find any paper that tells me if this is correct. So, does it actually work like that?</p>\n\n<p><strong>Edit:</strong> This example proofs that my idea is wrong.\nGiven the following graph, we run Bellman-Ford from node $1$.</p>\n\n<p><img src="http://i.stack.imgur.com/pNLTw.png" alt="enter image description here"></p>\n\n<p>We process edges in the order $a, b, c, d$. After $n-1$ iterations we get <strong>node distances:</strong><br>\n$1: -5$<br>\n$2: -30$<br>\n$3: -15$</p>\n\n<p>and <strong>parent table:</strong><br>\n$1$ has parent $3$<br>\n$2$ has parent $3$<br>\n$3$ has parent $2$<br></p>\n\n<p>Now, doing the $n$th iteration we see that the distance of node $1$ can still be improved using edge $a$. So we know that a negative cycle exists and $a$ is part of it.</p>\n\n<p>But, by tracing our way back through the parent table, we get stuck in another negative cycle $c, d$ and never meet $a$ again.</p>\n\n<p>How can we solve this problem?</p>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '4298', 'LastActivityDate': '2013-05-22T22:30:41.320', 'CommentCount': '0', 'AcceptedAnswerId': '6921', 'CreationDate': '2012-11-26T14:27:26.067', 'Id': '6919'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '904', 'Title': 'Retrieving the shortest path of a dynamic graph', 'LastEditDate': '2012-12-10T15:45:53.627', 'AnswerCount': '3', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '4916', 'FavoriteCount': '3', 'Body': "<p>I'm studying shortest paths in directed graphs currently. There are many efficient algorithms for finding the shortest path in a network, like dijkstra's or bellman-ford's. But what if the graph is dynamic? By saying dynamic I mean that we can insert or remove vertices during the execution of the program. I'm trying to find an efficient algorithm for updating the shortest paths from a vertex $v$ to every other vertex $u$, after inserting an edge $e$, without needing to run the shortest path algorithm in the new graph again. How can I do this? Thanks in advance.</p>\n\n<ul>\n<li><em>Note:</em> the changes can be done after the first iteration of the algorithm</li>\n<li><em>Note[2]:</em> two nodes are given, $s$ the source and $t$ the target. I need to find the shortest path between these nodes. When the graph is updated I only have to update $\\pi(s,t)$, which is the shortest path between $s$ and $t$.</li>\n<li><em>Note[3]:</em> I'm only interested in the edge insertion case.</li>\n</ul>\n\n<blockquote>\n  <p><strong>A formal definition</strong>: Given a graph $G = (V,E)$. Define an <em>update operation</em> as 1) an insertion of an edge $e$ to $E$ or 2) a a deletion of an edge $e$ from $E$. The objective is to find efficiently the cost of all pairs shortest paths after an update operation. By efficiently, we mean at least better than executing an All-Pairs-Shortest-Path algorithm, such as Bellman-Ford algorithm, after each update operation.</p>\n</blockquote>\n\n<hr>\n\n<p><strong>Edit:</strong> Below there is a simplified version of the problem:</p>\n\n<blockquote>\n  <p>A weighted graph $G(V,E)$ is given, consisting of unidirectional edges, and two critical vertices $s$ and $t$. A set $C$ of candidate <em>bidirectional</em> edges is also given. I have to build an edge $(u,v) \\in C$ to minimize the distance from $s$ to $t$.</p>\n</blockquote>\n", 'Tags': '<algorithms><data-structures><graphs><efficiency><shortest-path>', 'LastEditorUserId': '4916', 'LastActivityDate': '2013-06-12T10:15:55.483', 'CommentCount': '7', 'AcceptedAnswerId': '7260', 'CreationDate': '2012-12-08T11:22:28.103', 'Id': '7250'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>my assumption:<br/>\n- we have an undirected graph with only positive edges<br/>\n- the edges are sorted alphabetically: <br/>\n&nbsp;&nbsp;&nbsp;&nbsp;e.g A-B, A-C, B-D <br/>\n&nbsp;&nbsp;&nbsp;&nbsp;and e.g not C-A, D-B, A-B </p>\n\n<p>I do not understand, why we need the first loop (line 1) here.\nI executed the algorithm on paper on 3-4 different undirected graphs.\nAnd everytime the first iteration of line1 ends, the algorithms finishes to find the shortest path and the remaining iterations are doing just garbage check.</p>\n\n<p>Can anyone give a concrete graph example where we need the first loop?\nDoes the first loop to do something with the negative edges or edge direction perhaps ?</p>\n\n<pre><code>1 for i=1 to vertices.length-1\n2    foreach e in edges\n3        if e.v2.cost &gt; e.v1.cost + e.weight\n4            e.v2.cost := e.v1.cost + e.weight\n5            e.v2.pre := e.v1  \n</code></pre>\n', 'ViewCount': '169', 'Title': 'Bellman-Ford: shortest path', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-29T00:42:39.700', 'LastEditDate': '2012-12-29T00:42:39.700', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7631', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2012-12-28T15:48:15.470', 'Id': '7628'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1495', 'Title': 'What is the fastest algorithm for finding all shortest paths in a sparse graph?', 'LastEditDate': '2013-05-24T03:12:57.407', 'AnswerCount': '4', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '5233', 'FavoriteCount': '2', 'Body': '<p>In an unweighted, undirected graph with $V$ vertices and $E$ edges such that $2V \\gt E$, what is the fastest way to find all shortest paths in a graph? Can it be done in faster than Floyd-Warshall which is $O(V^3)$ but very fast per iteration?</p>\n\n<p>How about if the graph is weighted?</p>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '472', 'LastActivityDate': '2014-05-01T00:54:19.510', 'CommentCount': '0', 'AcceptedAnswerId': '7646', 'CreationDate': '2012-12-29T17:41:54.350', 'Id': '7644'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>INPUT: "an undirected, weighted graph (negative weights allowed)"</p>\n\n<p>Could someone give an example for an undirected graph with negative edges where Dijkstra\'s algorithm doesn\'t work?\nAs far as i understood it only fails by directed graphs in case of negative edges.<br/>\nAm i right ?</p>\n', 'ViewCount': '1876', 'Title': "Dijkstra's algorithm for undirected graphs with negative edges", 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-01T16:12:50.547', 'LastEditDate': '2012-12-30T15:13:01.697', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '7657', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<graphs><shortest-path>', 'CreationDate': '2012-12-30T06:44:36.953', 'Id': '7649'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Can someone tell me why almost in every book/website/paper authors use the following:</p>\n\n<pre><code>foreach vertex v in Adjacent(u)\n    relax(u,v)\n</code></pre>\n\n<p>when relaxing the edges, instead of:</p>\n\n<pre><code>foreach vertex v in Adjacent(u)\n    if (v is in Q)\n        relax(u,v)\n</code></pre>\n\n<p>This is extremely confusing for someone when learning the algorithm. Is there any reason why the people are omitting the IF ?</p>\n\n<p>Anyway I wrote a semi-Javascript (I changed it here to a readable syntax) implementation of Dijkstra and I wanted to be sure if it is correct because of this IF case. Here is my code excluding the initialising:</p>\n\n<pre><code>while (queue.length != 0)\n    min = queue.getMinAndRemoveItFromQ()\n    foreach v in min.adjacentVertices\n        // inspect edge from "min" to "v"\n        if ( queue.contains(v) AND min.priority + weight(min,v) &lt; v.priority )\n            v.priority = min.priority + weight(min,v)\n            v.pre = min\n</code></pre>\n\n<p>Is this implementation correct or am I missing something ?</p>\n', 'ViewCount': '204', 'Title': "Why not relax only edges in Q in Dijkstra's algorithm?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-25T13:23:47.117', 'LastEditDate': '2013-01-25T11:30:42.873', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '9121', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '5222', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-01-23T22:07:29.570', 'Id': '9120'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Do we need to use BFS or DFS algorithm to find the k shortest loopless paths in a graph between any two nodes? \nIf so where can it be useful?</p>\n', 'ViewCount': '148', 'Title': 'BFS in K shortest paths', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-28T13:31:19.390', 'LastEditDate': '2013-01-28T10:05:21.847', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '5328', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal>', 'CreationDate': '2013-01-27T16:54:04.673', 'FavoriteCount': '1', 'Id': '9208'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<blockquote>\n  <p><strong>Problem:</strong> Consider a graph $G = (V, E)$ on $n$ vertices and $m &gt; n$ edges, $u$ and $v$ are two vertices of $G$.</p>\n  \n  <p>What is the asymptotic complexity to calculate the shortest path from $u$ to $v$ with Dijkstra\'s algorithm using <a href="http://en.wikipedia.org/wiki/Binary_heap" rel="nofollow">Binary Heap</a> ?</p>\n</blockquote>\n\n<p>To clarify, Dijkstra\'s algorithm is run from the source and allowed to terminate when it reaches the target. Knowing that the target is a neighbor of the source, what is the time complexity of the algorithm?</p>\n\n<p><strong>My idea:</strong></p>\n\n<p>Dijkstra\'s algorithm in this case makes $O(n)$ <strong>inserts</strong> ( $n$ if the graph is complete) and 1 <strong>extract min</strong> in the binary heap, before calculate the shortest path from $u$ to $v$.</p>\n\n<p>In a binary heap insert costs $O(\\log n)$ and extract min $O(\\log n)$ too.</p>\n\n<p>So the cost in my opinion is $O(n \\cdot \\log n + \\log n) = O(n \\log n)$</p>\n\n<p>But the answer is $\\Theta(n)$, so there is something wrong in my thinking.</p>\n\n<p>Where is my mistake?</p>\n', 'ViewCount': '793', 'Title': "What's the complexity of calculating the shortest path from $u$ to $v$ with Dijkstra's algorithm using binary heap?", 'LastEditorUserId': '3011', 'LastActivityDate': '2013-01-30T17:46:35.080', 'LastEditDate': '2013-01-30T17:41:32.873', 'AnswerCount': '1', 'CommentCount': '8', 'AcceptedAnswerId': '9319', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4765', 'Tags': '<algorithms><graphs><algorithm-analysis><runtime-analysis><shortest-path>', 'CreationDate': '2013-01-30T16:17:56.463', 'Id': '9314'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have the following problem:</p>\n\n<blockquote>\n  <p>Given an edge-colored DAG $G = (V,A)$, vertices $s$ and $t$, a set of colors $C$ and $k \\in \\mathbb{N}$,<br>\n   does there exist a path from $s$ to $t$ using exactly $k$ distinct colors?</p>\n</blockquote>\n\n<p>Can anyone provide pointers to the complexity of this problem?  More specific, is it $\\mathsf{NP}$-complete or in $\\mathsf{P}$?</p>\n', 'ViewCount': '84', 'Title': 'Path on an edge-colored DAG using exactly $k$ colors', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-02-05T10:28:30.163', 'LastEditDate': '2013-02-05T10:28:30.163', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'user547616', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-02-01T07:27:24.787', 'Id': '9490'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>The Floyd-Warshall algorithm is defined as follows:</p>\n\n<pre><code>   for k from 1 to |V|\n      for i from 1 to |V|\n         for j from 1 to |V|\n            if dist[i][k] + dist[k][j] &lt; dist[i][j] then\n               dist[i][j] \u2190 dist[i][k] + dist[k][j]\n</code></pre>\n\n<p>Why doesn't it work if I simply use</p>\n\n<pre><code>for i from 1 to |V|\n  for j from 1 to |V|\n     for k from 1 to |V|\n        if dist[i][k] + dist[k][j] &lt; dist[i][j] then\n           dist[i][j] \u2190 dist[i][k] + dist[k][j]\n</code></pre>\n\n<p>In this case, the intermediate node k is iterated in the innermost loop. I expect it will make the same comparisons, but maybe different order. Why is the result different and incorrect?</p>\n", 'ViewCount': '265', 'Title': "Why doesn't the Floyd-Warshall algorithm work if I put k in the innermost loop", 'LastEditorUserId': '31', 'LastActivityDate': '2013-02-10T20:15:19.823', 'LastEditDate': '2013-02-10T15:11:05.887', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6805', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-02-10T12:07:12.883', 'Id': '9636'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1436', 'Title': "Is Dijkstra's algorithm just BFS with a priority queue?", 'LastEditDate': '2013-02-24T16:18:24.030', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'Barry Fruitman', 'PostTypeId': '1', 'OwnerUserId': '7007', 'Body': '<p>According to <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=graphsDataStrucs3" rel="nofollow">this page</a>, Dijkstra\'s algorithm is just BFS with a priority queue. Is it really that simple? I think not.</p>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-24T16:18:24.030', 'CommentCount': '3', 'AcceptedAnswerId': '10048', 'CreationDate': '2013-02-24T07:46:57.263', 'Id': '10047'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>If I had a  Dijkstra graph with the number shortest paths from Node A to O being 1,\nwould it be correct to say: <strong>the equal number of shortest paths from A to O is 1 and not 0</strong>, because that node is included as an \'equal shortest path\'? I am really confused.</p>\n\n<p>Here is an image to illustrate my question:</p>\n\n<p><img src="http://i.stack.imgur.com/29PIi.png" alt="automaton"></p>\n', 'ViewCount': '188', 'Title': 'Dijkstra algorithm: equal number of shortest paths', 'LastEditorUserId': '39', 'LastActivityDate': '2013-12-20T18:59:30.713', 'LastEditDate': '2013-12-20T18:59:30.713', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '10336', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '7173', 'Tags': '<algorithms><shortest-path>', 'CreationDate': '2013-03-06T20:01:48.040', 'Id': '10333'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>A graph $G$ is <em><a href="http://en.wikipedia.org/wiki/Chordal_graph">chordal</a></em> if it doesn\'t have induced cycles of length 4 or more. Chordal graphs are precisely the class of graphs that admit a <em>clique tree</em> representation. A clique tree $T$ of $G$ is a tree in which the vertices of the tree are the maximal cliques of $G$. An edge in $T$ corresponds to a <em><a href="http://en.wikipedia.org/wiki/Chordal_graph#Minimal_separators">minimal separator</a></em>. In general, $G$ can have more than one clique tree representing it. A graph is said to be <em>geodetic</em> if the shortest path between any pair of vertices is unique.</p>\n\n<p>Consider a chordal graph $G$ in which every minimal separator is a singleton set. I can prove such a graph is geodetic, but this property doesn\'t hold once minimal separators get larger. For example, consider a graph with a minimal separator $S = \\{2,3\\}$ of size 2 below. It already has 2 shortest paths between the vertices 1 and 4. </p>\n\n<p><img src="http://i.stack.imgur.com/QXNrB.png" alt="A chordal graph in which the minimal separator is of size 2."></p>\n\n<p>In fact, consider two adjacent vertices in a clique tree of a chordal graph. Let $S$ be the minimal separator corresponding to the edge between them. Now consider two distinct vertices $u$ and $v$ in these adjacent cliques such that $u,v \\notin S$. The number of shortest paths from $u$ to $v$ is the size of the minimal separator between them. This is because, roughly speaking, it takes one step to move from any vertex in a clique to a separator, and likewise any vertex in a clique can be reached with one step from the separator.</p>\n\n<p>Finally, consider an example like below. The graph has 3 maximal cliques, and the minimal separators are $\\{ 4,5 \\}$ and $\\{ 2,3 \\}$. Now the number of shortest paths from 1 to 6 is $2 \\times 2 = 4$.</p>\n\n<p><img src="http://i.stack.imgur.com/HcoSr.png" alt="enter image description here"></p>\n\n<blockquote>\n  <p>Given a connected chordal graph $G$ (with no loops nor parallel edges), what is the maximum number of shortest paths there can exist between any pair of vertices? How can it be bounded (in terms of $n$ and $m$)?</p>\n</blockquote>\n', 'ViewCount': '240', 'Title': 'What is the maximum number of shortest paths between any pair of vertices in a chordal graph?', 'LastActivityDate': '2013-03-10T23:20:18.047', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10439', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<graph-theory><combinatorics><shortest-path><discrete-mathematics>', 'CreationDate': '2013-03-10T22:13:48.403', 'FavoriteCount': '1', 'Id': '10438'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '623', 'Title': 'Destination-based vs source-based routing', 'LastEditDate': '2013-03-23T19:42:08.950', 'AnswerCount': '1', 'Score': '2', 'OwnerDisplayName': 'user1796218', 'PostTypeId': '1', 'OwnerUserId': '7414', 'FavoriteCount': '0', 'Body': '<p>I understand that destination-based routing builds the "route" from the destination backwards to the source (e.g. if using a spanning tree, then the tree is routed at the destination). With source-based routing the opposite is true: the route is build from the source onwards towards the destination.</p>\n\n<p>However I don\'t understand the practical difference. How does it make a difference if I base my decision on the source or on the destination. Say, a shortest path algorithm such as Dijkstra\'s should give the same result regardless?</p>\n\n<p>Could someone explain?</p>\n', 'Tags': '<algorithms><distributed-systems><shortest-path><routing>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-03-25T16:40:32.177', 'CommentCount': '2', 'AcceptedAnswerId': '10779', 'CreationDate': '2013-03-22T19:34:10.097', 'Id': '10718'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I need help with the following problem:</p>\n\n<blockquote>\n  <p><strong>Input:</strong>  An undirected, unweighted graph $G = (V,E)$ and a set of vertices $F \\subseteq V$.</p>\n  \n  <p><strong>Question:</strong>\n  Find a vertex $v$ of $V$ such that the distance from each vertex of $F$ to $v$ is the same and all the distances are minimized?  Return <code>None</code> if there is no such $v$.</p>\n</blockquote>\n\n<p>The runtime should be $O(|V| + |E|)$.</p>\n\n<p>My thoughts were to do a breadth-first search for each vertex in $F$, so for each vertex in $F$, you store all vertices with their distances, then find the intersection of all these.</p>\n\n<p>Is there a better way?</p>\n', 'ViewCount': '234', 'Title': 'Find a vertex that is equidistant to a set of vertices?', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-03-31T10:13:00.143', 'LastEditDate': '2013-03-31T10:13:00.143', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '7168', 'Tags': '<algorithms><graph-theory><search-algorithms><shortest-path>', 'CreationDate': '2013-03-26T05:51:11.470', 'Id': '10794'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Counting all possible paths, or all possible paths with a given length, between a couple of nodes in a directed or undirected graph is a classical problem. Attention should be given to what <em>all</em> means, due to the possibles cycles.</p>\n\n<p>This question is slightly different, or at least I think.</p>\n\n<p><strong>INPUT:</strong>  Be <strong>G</strong> a directed graph. <strong>G</strong> can have cycles and also selfconnected nodes. Let <strong>A(G)</strong> be the adjacency matrix of <strong>G</strong> (with a 1 in <strong>G</strong><sub>i,j</sub> if there's a link going from i to j and a 0 otherwise). Define <strong>T</strong> and <strong>B</strong> two subset of nodes of <strong>G</strong>, possibly with void intersection.</p>\n\n<p><strong>OUTCOME:</strong> A list of all paths of length <em>at most</em> k going from one node in <strong>T</strong> to one node in <strong>B</strong>. Paths can contain multiple time the same edges, as long as they go from the source node to the target node in strictly less than k+1 steps.</p>\n\n<p><strong>QUESTION:</strong> I would like to know which algorithm perform best in this task. I'm trying to develop a possible answer based on the fact that the n-th power of the adjacency matrix, if computed symbolically (with a different variable for each entry instead of a 1), keep traks of all this paths (and it reduces to the counting of paths if computed numerically with 1 in the entries). But I really don't know if this is the fastest way of doing the task (probably not).</p>\n\n<p><strong>CAVEAT:</strong> I'm not asking for the counting problem, nor for the shortest paths, the length of a path is defined as the number of edges used (counting the repetition). I'm using R, but if you prefer think about it in any other language! I'm really sorry if the question was already posed and solved. Thank you for the kind help!</p>\n\n<p><strong>additional info:</strong> I tried a matrix power series approach (A^3 gives all the 3 long path, ...) and dfs / bfs. I think the latter two are far from optimality as they don' take into account that I'm working on sets of sources and targets, and hence do a lot of redundant work...</p>\n", 'ViewCount': '793', 'Title': 'All paths of less than a given length in a directed graph between couple of nodes', 'LastActivityDate': '2013-04-01T16:54:58.877', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '10954', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '7521', 'Tags': '<algorithms><graphs><search-algorithms><shortest-path>', 'CreationDate': '2013-03-31T21:50:11.637', 'FavoriteCount': '1', 'Id': '10949'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I mean Dijkstra's algorithm for the shortest path.</p>\n\n<p>In all descriptions that I saw (including wikipedia),\non every step,\nit always selects the nearest neighbor based on examining their weights.</p>\n\n<p>Imagine that we have following paths from source A to destination B\n(I will list weights of different paths, not full graph - for brevity):</p>\n\n<h1>1: $$A {19\\atop\\longrightarrow} A_1 {2\\atop \\longrightarrow} A_2{2\\atop \\longrightarrow} A_3{10\\atop \\longrightarrow} B$$</h1>\n\n<h1>2: $$A {5\\atop\\longrightarrow} A_4 {10\\atop \\longrightarrow} A_5{10\\atop \\longrightarrow} A_6{5\\atop \\longrightarrow} B$$</h1>\n\n<h1>3: $$A {2\\atop\\longrightarrow} A_7 {15\\atop \\longrightarrow} A_8{15\\atop \\longrightarrow} A_9{10\\atop \\longrightarrow} A_{10} {10\\atop \\longrightarrow} B$$</h1>\n\n<p>If Dijkstra always select the neighbor with smallest weight,\nit will always go for #3 - although it is the heaviest path!</p>\n\n<p>Where am I wrong?\nDoes anybody has a 'working' pseudo-code for Dijkstra algorithm?</p>\n", 'ViewCount': '117', 'Title': 'WP pseudocode for Dijkstra does not work', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-05T14:30:34.853', 'LastEditDate': '2013-04-05T13:56:24.997', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '7598', 'Tags': '<algorithms><shortest-path>', 'CreationDate': '2013-04-05T12:58:27.407', 'Id': '11055'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '3059', 'Title': 'Finding shortest and longest paths between two vertices in a DAG', 'LastEditDate': '2013-04-14T16:59:17.863', 'AnswerCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '7715', 'FavoriteCount': '3', 'Body': '<p>Given an unweighted DAG (directed acyclic graph) $D = (V,A)$ and two vertices $s$ and $t$, is it possible to find the shortest and longest path from $s$ to $t$ in polynomial time?  Path lengths are measured by the number of edges.</p>\n\n<p>I am interested in finding the range of possible path lengths in polynomial time.</p>\n\n<p>Ps., this question is a duplicate of the StackOverflow question <a href="http://stackoverflow.com/questions/10712495/longest-path-in-a-dag">Longest path in a DAG</a>.</p>\n', 'Tags': '<algorithms><graphs><shortest-path><polynomial-time>', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-04-15T00:36:10.273', 'CommentCount': '0', 'AcceptedAnswerId': '11296', 'CreationDate': '2013-04-14T00:02:56.393', 'Id': '11295'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>This problem is about finding a route on a square grid.\nThe starting point is $(1,1)$ and the target point $(n,m)$.\nI can move each step from my current point $(x,y)$ either to $(x+y,y)$ or $(x,y+x)$.\nNow I need to determine if there is a path from $(1,1)$ to $(n,m)$, and if so to return the shortest one.</p>\n\n<p>Now I believe that if I trace back my steps from the input point $(n,m)$ I can always know which move I made out of the two possible ones since if $n=m$ then there is no route, this means I'm always take the smaller coordinate and subtract it from the bigger one.\nBut that means I have at most only one possible route to $(n,m)$ so why was  I asked to return the shortest one?</p>\n\n<p>Am I missing anything ?</p>\n", 'ViewCount': '188', 'Title': u'Route on a square grid with only (x,y) \u2192 (x,x+y) and (x,y) \u2192 (x+y,y) moves', 'LastEditorUserId': '39', 'LastActivityDate': '2013-04-20T23:28:40.130', 'LastEditDate': '2013-04-20T23:28:40.130', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6632', 'Tags': '<algorithms><graph-theory><shortest-path><square-grid>', 'CreationDate': '2013-04-20T13:56:24.683', 'Id': '11427'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>First of all, let me preface by saying that this question is not completly new but the original question hasn\'t been answered. More important, this is only basic question on understanding the proof itself.</p>\n\n<p>So after some search in the site I found the following question : <a href="http://cs.stackexchange.com/questions/7565/bellman-ford-algorthm-and-negative-cycle-proof">Bellman-Ford algorthm and negative cycle proof</a>.</p>\n\n<p>The guy is trying to understand how to prove <em>that a cycle in parent pointer is necessarily a negative cycle</em>.</p>\n\n<p>My question is very basic and isn\'t duplicate, I just couldn\'t find anything in the document on the related question which answers my question.</p>\n\n<p>What does it mean a cycle in the parent pointer? I mean I could a graph whereas the cycle in the parent pointer isn\'t a negative cycle... I don\'t understand why It must be a negative cycle.</p>\n\n<p>See an example of a graph I have in mind :</p>\n\n<p><img src="http://i.stack.imgur.com/DSlY3.jpg" alt="enter image description here"></p>\n\n<p>Now suppose the first node we start with is (a) and suppose the we travling the edges in the following order: ab,bc,cd.</p>\n\n<p>and here we goes, we have a cycle in the parent pointer, and as far as I understand that is (c) becuase it is the parent of (d) and yet the cycle isn\'t negative cycle.</p>\n', 'ViewCount': '154', 'Title': 'Bellman-Ford parent pointer (?) negative cycle', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-23T14:01:36.147', 'LastEditDate': '2013-04-21T14:16:44.637', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '11482', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4514', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-04-20T14:15:41.437', 'Id': '11428'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to solve a system of inequalities in the following form:\n$\\ x_i - x_j \\leq w $</p>\n\n<p>I know these inequalities can be solved using <code>Bellman-Ford</code> algorithm. But there is also another condition. I want to find the solution that maximizes $\\ x_n - x_1$</p>\n\n<p>As far as I know the default <code>Bellman-Ford</code> algorithm minimizes it. How do I do that?</p>\n', 'ViewCount': '405', 'Title': 'Solving system of linear inequalities', 'LastActivityDate': '2013-08-26T17:37:29.993', 'AnswerCount': '4', 'CommentCount': '1', 'Score': '4', 'OwnerDisplayName': 'Kia.celever', 'PostTypeId': '1', 'Tags': '<algorithms><linear-algebra><linear-programming><shortest-path>', 'CreationDate': '2013-04-19T09:14:20.977', 'Id': '11445'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>From Skiena's book:</p>\n\n<p>Let $G = (V,E,w)$ be a directed weighted graph such that all the weights are positive. Let $v$ and $u$ be two vertices in $G$ and $k \\leq |V|$ be an integer. Design an algorithm to find the shortest path from $v$ to $u$ that contains exactly $k$ edges. Note that the path need not be simple.</p>\n\n<p>This is <strong>not homework</strong>, its me preparing for an interview. I have no clue how to approach this.</p>\n", 'ViewCount': '614', 'Title': 'Shortest path with exactly $k$ edges', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-05-23T14:44:05.013', 'LastEditDate': '2013-05-23T14:44:05.013', 'AnswerCount': '1', 'CommentCount': '7', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7807', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-04-22T23:22:16.367', 'FavoriteCount': '1', 'Id': '11503'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Let $G = (V,E)$ be a directed graph  with a weight function $w$ such that there are no negative-weight cycles, and let $v \\in V$ be a vertex such that there is a path from $v$ to every other vertex. Let $f : V \\to \\mathbb R$ be a given function. Describe an algorithm that runs in $O(|V| + |E|)$ time that answers yes/no to the question: is it true that for all $u \\in V, f(u) = \\delta(v,u)$, where $\\delta(v,u)$ is the weight of the shortest path from $v$ to $u$?</p>\n\n<p>Obviously what comes to mind is Bellman-Ford algorithm, but it doesn't satisfy the time requirement. I don't really see how having the candidate $f$ function helps us in this regard.</p>\n", 'ViewCount': '194', 'Title': 'Shortest paths candidate', 'LastActivityDate': '2013-06-05T15:32:06.230', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12126', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8247', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-05-18T19:19:11.787', 'Id': '12120'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '1483', 'Title': 'Finding the path of a negative weight cycle using Bellman-Ford', 'CommunityOwnedDate': '2013-05-21T19:50:47.733', 'LastEditDate': '2013-05-22T15:08:01.357', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8248', 'Body': '<p>I wrote a program which implements Bellman-Ford, and identifies when negative weight cycles are present in a graph. However what I\'m actually interested in, is given some starting vertex and a graph, which path do I actually trace to get to the original vertex having traveled a negative amount. </p>\n\n<p>So to be clear say I have a graph with vertexes, a, b, c, and d and there is a negative cycle between a, b, and d, then when I check for negative weight cycles </p>\n\n<pre><code>// Step 1: initialize graph\n   for each vertex v in vertices:\n       if v is source then distance[v] := 0\n       else distance[v] := infinity\n       predecessor[v] := null\n\n   // Step 2: relax edges repeatedly\n   for i from 1 to size(vertices)-1:\n       for each edge (u, v) with weight w in edges:\n           if distance[u] + w &lt; distance[v]:\n               distance[v] := distance[u] + w\n               predecessor[v] := u\n\n   // Step 3: check for negative-weight cycles\n   for each edge (u, v) with weight w in edges:\n       if distance[u] + w &lt; distance[v]:\n           "Graph contains a negative-weight cycle"\n</code></pre>\n\n<p>Instead of it just telling me that a negative cycle is there, I would like it to tell me, go from <code>a -&gt; b -&gt; d -&gt; a</code>.  After the relaxing step what do I have to change in my check for negative weight cycles to get it to output this information? </p>\n\n<ul>\n<li><p><a href="http://blog.alirabiee.com/?p=576" rel="nofollow">Here</a> is the best information I\'ve been able to find, but I\'m still having trouble making sense of it.  </p></li>\n<li><p>Also <a href="http://www.cs.ucdavis.edu/~amenta/f05/hw5.pdf" rel="nofollow">this</a> which suggests that I need to run breadth first search on the predecessor array to find the information, but I\'m not exactly sure where to start (what do I queue first?) </p></li>\n<li><p><a href="http://stackoverflow.com/questions/2282427/interesting-problem-currency-arbitrage">Here</a> is a stack overflow question which shows how to find one of the nodes in the path.</p></li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '8248', 'LastActivityDate': '2013-05-22T15:08:01.357', 'CommentCount': '3', 'AcceptedAnswerId': '12206', 'CreationDate': '2013-05-19T04:41:17.347', 'Id': '12129'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let G be a directed graph with non-negative weights. We call a path between two vertices an "odd path" if its weight is odd.</p>\n\n<p>We are looking for an algorithm for finding the weight of the shortest odd path between any two vertices in the graph.</p>\n\n<p>If possible, describe one algorithm that is reduction-based (that is, make some modification to the graph so that application of Floyd-Warshall, or any other "known" algorithm, and then deciphering the answer will give the result, see <a href="http://en.wikipedia.org/wiki/Reduction_(complexity)" rel="nofollow">http://en.wikipedia.org/wiki/Reduction_(complexity)</a>) and one that is "direct" (that is, make some modification to Floyd-Warshall in order for it to solve this problem).</p>\n', 'ViewCount': '301', 'Title': 'Shortest path with odd weight', 'LastActivityDate': '2013-05-22T07:57:41.470', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '12155', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8247', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-05-20T11:52:45.343', 'Id': '12154'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given a weighted digraph, I can check whether a given vertex belongs to a negative cycle in $O(|V|\\cdot|E|)$ using Bellman-Ford. But what if I need to find all vertices on negative cycles? Is there a way to do it faster than Floyd-Warshall's $O(|V|^3)$?</p>\n", 'ViewCount': '102', 'Title': 'Finding all vertices on negative cycles', 'LastActivityDate': '2013-12-12T18:42:02.590', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18933', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '8329', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-05-24T03:25:43.543', 'Id': '12243'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Find the weight of the lightest path from u to v the goes through node a or/and b.</p>\n\n<p>Do you have a suggestion on how it can be done?</p>\n', 'ViewCount': '94', 'LastEditorDisplayName': 'user742', 'Title': 'Find the weight of the lightest path from u to v', 'LastActivityDate': '2013-09-20T09:34:09.967', 'LastEditDate': '2013-09-20T09:34:09.967', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '-2', 'PostTypeId': '1', 'OwnerUserId': '8361', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-05-26T07:55:17.363', 'FavoriteCount': '0', 'Id': '12291'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Apparently, if we use Djikstra's algorithm to find the shortest path between the root node and all other nodes in a weighted graph with no negative cycles, we are done after updating the distance of each node $|V| - 1$ times.</p>\n\n<p>This puzzles me because I think that a single round of breadth first search is enough. Why must we do $|V| - 1$ of these searches?</p>\n", 'ViewCount': '59', 'Title': "For Djikstra's algorithm, why are we surely done if we update all edges $|V|-1$ times?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T09:44:37.167', 'LastEditDate': '2013-06-10T09:44:37.167', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12572', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<algorithms><graphs><shortest-path><correctness-proof>', 'CreationDate': '2013-06-09T09:20:18.353', 'Id': '12558'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have n commodities with each a unique source and sink node. Each source-sink pair is connected in some manner on a directed acyclic graph. All arc weights are non-negative. The goal is to find the shortest paths to transport the commodities between their respective source-sink pairs.</p>\n\n<p>Is there any algorithm that can solve this kind of problem rapidly, possibly using topological sorting first? How is this affected if there is unlimited/limited capacity on the arcs?</p>\n\n<p>Many thanks!</p>\n', 'ViewCount': '52', 'Title': 'Multicommodity shortest path problem on a directed acyclic graph', 'LastActivityDate': '2013-06-11T10:46:16.073', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8620', 'Tags': '<shortest-path><weighted-graphs>', 'CreationDate': '2013-06-11T10:46:16.073', 'Id': '12616'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>This is a cross-post of <a href="http://stackoverflow.com/questions/17538933/route-planning-in-public-transport-application">this StackOverflow question</a>, (I\'m not aware of linking questions between StackExchange sites). You can ignore the part about programming.</p>\n\n<p>I\'m making a journey planner (or a general timetable application) for all the public transport in my country (bus/train/air).</p>\n\n<p>The state of the project is at midpoint, now I\'m having a bit of a hard time getting the more difficult part of the application done.</p>\n\n<p>Currently, I have all the stops, routes and departure/arrival times.</p>\n\n<p>When there are direct connections between two points, all is fine, I can get the trips for a chosen day. The hard part is getting a complete journey when there are no direct lines.</p>\n\n<p>Say the user wants to travel from <code>city A</code> to <code>city D</code>, but because there are no direct lines between those cities, he needs to pass through <code>city B</code> and <code>city C</code>.</p>\n\n<p>How can I get the optimized routes and <em>transfers</em> for this situation?</p>\n\n<p>My ideas so far a gravitating towards using a graph, but in that case I need a <strong>Time-Dependant Directed Weighted Multigraph</strong>, and I really have no idea at the moment how to implement the <strong>Time-Dependant</strong> part.</p>\n\n<p>Getting just the route can be done by using <code>Dijkstra</code>, <code>A*</code> or <code>Floyd\u2013Warshall</code> algorithms , but because there are departures at different times, I\'m not sure how will this be implemented, to get the optimal solution. I need to take into consideration the duration of a segment (A to B, B to C), waiting time for the transfer, maybe the distance too.</p>\n\n<p>Just to clarify, I don\'t need a single result. I want to get a daily list of all departures from <code>city A</code> that can get the user to <code>city D</code>, with transfers if needed.</p>\n\n<p>Basically, what I\'m trying to get is something like this (taken from Bulgarian Railways, or for that matter, whichever railway site), a list of all departures for a chosen day going from <code>Sofia</code> to <code>Kystendil</code> making transfer in <code>Radomir</code> if needed:</p>\n\n<p><img src="http://i.stack.imgur.com/Yrron.jpg" alt="Sample Result"></p>\n\n<p>If I\'m not clear enough, please ask.</p>\n\n<p>I know that this is done so many times (almost any train website has the solution), but I don\'t know by which terms to even search.</p>\n\n<p><strong>So, my question is: can someone give me guidance how this type of problem is solved?</strong></p>\n\n<p><strong>Or at least by which terms should I search for ideas and how should it be done.</strong></p>\n\n<p>Maybe some suggestions for other sites in the StackExchange network.</p>\n', 'ViewCount': '210', 'Title': 'Route planning in public transport application', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-10T07:46:09.137', 'LastEditDate': '2013-07-10T07:46:09.137', 'AnswerCount': '0', 'CommentCount': '9', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9100', 'Tags': '<algorithms><graphs><dynamic-programming><shortest-path>', 'CreationDate': '2013-07-09T21:26:13.667', 'FavoriteCount': '1', 'Id': '13189'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Given an undirected simple graph $G$ and two nodes $s$ and $t$, the question asks for an algorithm to find the shortest simple cycle (no edge or vertex reuse) that contains the two. As far as I know, the problem is NP-complete if the two constraint were changed to arbitrary, but what if the number is given?</p>\n', 'ViewCount': '272', 'Title': 'Can the shortest simple cycle between two given nodes be found in polynomial time?', 'LastEditorUserId': '472', 'LastActivityDate': '2013-07-22T09:45:28.230', 'LastEditDate': '2013-07-22T09:45:28.230', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9106', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-07-10T06:11:43.530', 'Id': '13194'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>There is a river which can be considered as an infinitely long straight line with width W.</p>\n\n<p>There are A piles on the river, and B types of wooden disks are available.\nThe location of the $i$-th pile is $(X_i, Y_i)$.</p>\n\n<p>The $i$-th type of wooden disks has radius $R_i$, and its price is $C_i$ per disk.</p>\n\n<p>Disks can be placed on the river such that for each wooden disk, its center must be one of the locations $(X_i, Y_i)$ of piles. We can only move on the wooden disks.</p>\n\n<p>How to find the minimum cost such that we can cross the river.I am unable to approach questions like these. What would be the best method to approach this one?</p>\n\n<p>I have come to realize that we can use Dijkstra's algorithm here. We treat this as a graph, with piles as the nodes. Start point can be $y=0$. and $y=W$ as the end point. But i am having implementation problems. There are multiple disks which can be used in going from on state to another. How to handle this?</p>\n", 'ViewCount': '156', 'LastEditorDisplayName': 'user742', 'Title': 'Finding path with minimum weight', 'LastActivityDate': '2013-09-20T09:27:54.150', 'LastEditDate': '2013-09-20T09:27:54.150', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '9184', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-07-14T23:16:01.920', 'Id': '13273'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>In the <em>edge-disjoint paths problem</em> (EDP), we are given a (possibly directed) graph $G=(V,E)$, and a set of distinct source-sink pairs $\\{ (s_i,t_i) \\mid 1 \\leq i \\leq k \\}$, and we want to maximize the number of pairs that can be simultaneously connected in an edge-disjoint manner. When we add the constraint that the paths need to be <em>shortest paths</em>, we get the <em>edge-disjoint shortest paths</em> (EDSP) problem.</p>\n\n<p>According to [1], the EDSP problem is hard for a graph with unit edge lengths, even when the graph is planar. Furthermore, it claims this is so for both directed and undirected graphs.</p>\n\n<blockquote>\n  <p>What is known about the approximability of the EDSP problem?</p>\n</blockquote>\n\n<p>I\'m especially interested in results for undirected graphs. In [2], the authors seem to only consider variants of the EDP problem, but not the EDSP problem. Further following the references, it seems like the EDP problem has been studied extensively.</p>\n\n<hr>\n\n<p>[1] <a href="http://www.sciencedirect.com/science/article/pii/S0166218X97001212" rel="nofollow">Eilam-Tzoreff, Tali. "The disjoint shortest paths problem." Discrete applied mathematics 85.2 (1998): 113-138.</a></p>\n\n<p>[2] <a href="http://www.sciencedirect.com/science/article/pii/S0022000003000667" rel="nofollow">Guruswami, Venkatesan, et al. "Near-optimal hardness results and approximation algorithms for edge-disjoint paths and related problems." Journal of Computer and System Sciences 67.3 (2003): 473-496.</a></p>\n', 'ViewCount': '131', 'Title': 'Approximability of the edge-disjoint shortest paths problem', 'LastEditorUserId': '472', 'LastActivityDate': '2013-09-01T11:44:40.417', 'LastEditDate': '2013-09-01T11:44:40.417', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<algorithms><reference-request><shortest-path><approximation>', 'CreationDate': '2013-08-29T16:50:41.277', 'Id': '14023'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I am trying to modify the Floyd-Warshall algorithm to find all-pairs minimax paths in a graph. (That is, the shortest length paths such that the maximum edge weight along a path is minimized.)</p>\n\n<p>Floyd-Warshall algorithm contains the following loop to enhance the distance (<code>ds</code>) and the next vertex (<code>ns</code>) matrices at each iteration.</p>\n\n<pre><code>for (int k = 0; k &lt; n; k++)\n    for (int i = 0; i &lt; n; i++)\n        for (int j = 0; j &lt; n; j++)\n            if (ds[i][k] != inf &amp;&amp; ds[k][j] != inf) {\n                final int d = ds[i][k] + ds[k][j];\n                if (d &lt; ds[i][j]) {\n                    ds[i][j] = d;\n                    ns[i][j] = k;\n                }\n            }\n</code></pre>\n\n<p>I replaced <code>ds</code> with two new matrices: <code>ws</code> (weights) and <code>ls</code> (lengths). Further, updated the iteration step as follows:</p>\n\n<pre><code>for (int k = 0; k &lt; n; k++)\n    for (int i = 0; i &lt; n; i++)\n        for (int j = 0; j &lt; n; j++)\n            if (ws[i][k] != inf &amp;&amp; ws[k][j] != inf) {\n                final int w = Math.max(ws[i][k], ws[k][j]);\n                final int l = ls[i][k] + ls[k][j];\n                if (w &lt; ws[i][j] || (w == ws[i][j] &amp;&amp; l &lt; ls[i][j])) {\n                    ws[i][j] = w;\n                    ls[i][j] = l;\n                    ns[i][j] = k;\n                }\n            }\n</code></pre>\n\n<p>However, the modified algorithm finds paths with loops, that is, paths such as 1-<strong>3-2-3</strong>-4. While the maximum edge weight of the paths 1-3-2-3-4 and 1-3-4 are identical, the latter has a shorter path length and supposed to be returned by the enhanced Floyd-Warshall. Any ideas?</p>\n\n<p>A working Java version of both algorithms and a test case which produces a path with loop can be found <a href="https://gist.github.com/vy/6580214" rel="nofollow">here</a>.</p>\n\n<p><strong>Edit:</strong> Since no solutions were presented yet, I implemented my own shortest minimax path algorithm using incremental link removal method. Java sources to the solutions can be accessed from the <a href="https://gist.github.com/vy/6580214" rel="nofollow">above link</a>. </p>\n', 'ViewCount': '683', 'LastEditorDisplayName': 'user742', 'Title': 'Shortest Minimax Path via Floyd-Warshall', 'LastActivityDate': '2013-10-20T10:59:54.067', 'LastEditDate': '2013-09-20T09:26:04.407', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10167', 'Tags': '<algorithms><graph-theory><optimization><shortest-path>', 'CreationDate': '2013-09-16T12:50:56.260', 'Id': '14353'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<hr>\n\n<p>Is there an incremental directed graph data structure that has the following properties:</p>\n\n<ul>\n<li>Keeps an internal graph structure as a DAG, and the graph is accessible (notwithstanding other helper data-structures)</li>\n<li>The accessible DAG is kept as a transitive reduction (notwithstanding other helper data-structures)</li>\n<li>It should be optimized for a sparse graph (adjacency lists)</li>\n<li>It should condense cycles as they are introduced, keeps a mapping between equivalent vertices that are all replaced with one "representative" vertex</li>\n<li>Ability to quickly answer quickly ancestor/descendant/transitive/relationship queries (in $\\mathcal{O}(1)$ or $\\sim\\mathcal{O}\\left(\\log \\left|V\\right|\\right)$ time)</li>\n<li>Should support vertex, edge insertion, deletion would be nice too</li>\n<li>Mutable operations  (such as insertion) should be as output-sensitive as possible; in other words, the complexity should depend as much as possible on how much the operation must change the graph</li>\n<li>Ability to record changes over an operation, if requested. Obviously this might necessarily increase the complexity, but the increase should be output-sensitive. Examples:\n<ul>\n<li>set of deleted vertices (due to condensation)</li>\n<li>set of deleted edges (due to reduction)</li>\n<li>set of new decendent relationships from $u$ ( example: $insert(G,u,v) \\rightarrow \\left\\{t ~|~ path(u,t)\\in G\'\\wedge path(u,t)\\not\\in G\\right\\}$ )</li>\n<li>set of new ancestor relationships from $v$ ( example: $insert(G,u,v) \\rightarrow \\left\\{t ~|~ path(t,v)\\in G\'\\wedge path(t,v)\\not\\in G\\right\\}$ )</li>\n</ul></li>\n</ul>\n\n<p>The closest I can find is <a href="http://code-o-matic.blogspot.com/2010/07/graph-reachability-transitive-closures.html" rel="nofollow">here</a>, <a href="http://code.google.com/p/transitivity-utils" rel="nofollow">implementation</a>. I think you can build on this to do have most of the properties I list, but I am wondering if there is anything better/well known, or perhaps if there is a name for this problem.</p>\n\n<hr>\n\n<p><strong>EDIT:</strong></p>\n\n<h3>Related:</h3>\n\n<ul>\n<li><a href="http://cstheory.stackexchange.com/q/14343/3377">What is the fastest deterministic algorithm for dynamic digraph reachability with no edge deletion?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/18787/3377">What is the fastest deterministic algorithm for incremental DAG reachability?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/5176/3377">Does an algorithm exist to efficiently maintain connectedness information for a DAG in presence of inserts/deletes?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/2548/3377">Is there an online-algorithm to keep track of components in a changing undirected graph?</a></li>\n<li><a href="http://cstheory.stackexchange.com/q/17135/3377">Dynamic shortest path data structure for DAG</a></li>\n</ul>\n', 'ViewCount': '150', 'Title': 'An incrementally-condensed transitive-reduction of a DAG, with efficient reachability queries', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-10-04T05:16:35.877', 'LastEditDate': '2013-10-04T04:51:04.030', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><data-structures><graphs><shortest-path><online-algorithms>', 'CreationDate': '2013-10-03T21:12:35.287', 'FavoriteCount': '1', 'Id': '14798'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '621', 'Title': 'Running Floyd-Warshall algorithm on graph with negative cost cycle', 'LastEditDate': '2013-10-06T13:05:25.863', 'AnswerCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '10519', 'FavoriteCount': '1', 'Body': u"<p>I am trying to find the answer to the following question for the Floyd-Warshall algorithm. Suppose Floyd-Warshall algorithm is run on a directed graph G in which every edge's length is either -1, 0, or 1. Suppose that G is strongly connected, with at least one u-v path for every pair u,v of vertices, and that G may have a negative-cost cycle. How large can the final entries A[i,j,n] be, in absolute value (n denotes number of vertices). Choose the smallest number that is guaranteed to be a valid upper bound?\nThere is the following answers:</p>\n\n<ol>\n<li>+\u221e</li>\n<li>n^2</li>\n<li>n - 1</li>\n<li>2^n</li>\n</ol>\n\n<p>I have ruled out 3. (n-1) and 1. (+\u221e) since if a graph has a negative cost cycle, the absolute final value of a path including a negative cycle can be increased further than n-1. The answer also cannot be +\u221e since the algorithm stops after a finite number of steps. But I am having trouble between answers 2. and 4. I am more inclined to 4. since I have run some test cases, and final values seemed to comply to an exponential growth. But I cannot find a proof for it. </p>\n", 'Tags': '<algorithms><graph-theory><shortest-path>', 'LastEditorUserId': '10519', 'LastActivityDate': '2013-10-06T20:41:36.453', 'CommentCount': '7', 'AcceptedAnswerId': '14861', 'CreationDate': '2013-10-05T22:22:47.837', 'Id': '14839'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am trying to find an efficient solution to my problem. Let's assume that I have positive weighted graph <code>G</code> containing 100 nodes(each node is numbered) and it is an acyclic graph. So there cannot be any edge like 2,2 or 2,1. I have got a list of nodes let's say 10 from graph <code>G</code>. Let's say each of these nodes are also in an array. I am looking for a way to find the shortest path's total weight from node 1 to 100 that passes through at least some particular(let's say 5) of those nodes from that list.</p>\n\n<p>To simplify it, consider graph with 6 nodes, 0...5, now node 1 and 4 are marked as points where we could specify to pass. Let's say existing paths are 0-1-2-5, 0-3-4-5, and 1-4. Now let's say all edges are weighted as 5 except 3 to 4 is weighted as 1. If we run a shortest path algorithm this would basically find the path 0-3-4-5 as it is weighted 11. However if we run an algorithm specifying minimum amount of specified points and try the amount 2. Then the algorithm should be running on 0-1-4-5 which is weighted as 15.</p>\n\n<p>I have written this way</p>\n\n<pre><code>    shortestPath(destinationNode, minAmount) \n\n        if(destinationNode == srcNode &amp;&amp; minAmount &lt; 1) \n            return 0\n\n        else if(destinationNode == srcNode &amp;&amp; minAmount &gt; 1) \n            return INFINITY\n\n        int destNo = destinationNode get number\n        int cost = INFINITY\n        for (int i = 0; i &lt; destNo; i++)\n            if (d[i][destNo] != null) \n                int minimumAmountCount = minAmount;\n                for (int j = 0; j &lt; marked.length(); j++) \n                    if (marked[j] == i) \n                        minimumAmountCount = minimumAmountCount - 1;\n\n                cost = MIN(cost, shortestPath(Node(i), minimumAmountCount);\n\n        return cost;\n</code></pre>\n\n<p>Basically we call this algorithm by using the our destination node and minimum amount of nodes from that list. Firstly we want to make sure that this is a recursive function and it should have a stopping point, which would be when passed destination is equal to source node(which is essentially node #0). The second case we need to check is whether we visited enough amount, so if it is less than 1(0 or negative number) then we visited enough points and return 0 as distance from node #0 to node #0 would be 0. If we did not visit enough amount then we return infinity so that algorithm would consider other paths.</p>\n\n<p>So in order for the returning part to work, we have to define the destination node's number(if we consider that we have 100 nodes it would be node #99 at the initial start) and initialise cost as infinity.</p>\n\n<p>Then we run a for loop that starts from 0(essentially node #0) till our current node number, this is because there are no backwards edges on the graph. By using node number we check from the matrix whether there is an existing weight for those nodes. If it exist then we initialise a variable for our current minimum amount and then run a loop and check if source to the current destination is in the list of marked nodes. If it is marked then we simply decrement the minimum amount.</p>\n\n<p>For the final step we run the function again by changing destination as the current source and with the current minimum amount.</p>\n\n<p>But it seems very expensive, considering the fact that the worst case complexity of  nested loop takes O(|Node|^2) and total recurrence would take O(|Node|^2 * |Edges|). So is there any other efficient solution for this problem?</p>\n", 'ViewCount': '799', 'Title': 'Shortest path that passes through specific node(s)', 'LastEditorUserId': '8849', 'LastActivityDate': '2013-10-11T03:40:33.580', 'LastEditDate': '2013-10-10T23:46:31.867', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8849', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T06:29:19.223', 'FavoriteCount': '0', 'Id': '14977'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have written an A* algorithm to find the shortest path through a directed cyclic graph.  I am trying to modify it to find the longest path through the same graph.</p>\n\n<p>My attempt was to write it so that all I change is [1] the weights per edge (making them negative instead of positive) and [2] the heuristic function.</p>\n\n<p>I seem to be having trouble getting it to do this. It is pretty good at finding the longest path sometimes, but it is not guaranteed.  </p>\n\n<p>It seems that the problem lies with [2] the heuristic -- for shortest path an L2 norm is a good optimistic way to get it to head towards the goal, but for longest path I want the heuristic to point it at paths that are further from the goal to continue to increase total length. </p>\n\n<p>If I set the heuristic to return 0 so that it's a Dijkstra's search, it's less predictable as there's no incentive to search from nodes further away (using [1] negative weights per edge).</p>\n\n<p>I think if I keep the weights positive and try to maximize the score instead of minimize it may work, but I was attempting to do this without changing the algorithm, only the edge weights and the heurstic.</p>\n\n<p>I have found similar posts on stackExchange but they don't answer my specific questions:</p>\n\n<p>Q1) Can this be done with A*</p>\n\n<p>Q2) Is setting the weights negative the right thing to do</p>\n\n<p>Q3) Is the only way to do this is to set the heuristic to zero and keep the weights positive and try to maximize the score instead of minimize it?</p>\n", 'ViewCount': '1136', 'Title': 'A* to find the longest path in a directed cyclic graph', 'LastActivityDate': '2013-10-10T22:54:53.123', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14996', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10643', 'Tags': '<graph-theory><graphs><shortest-path><weighted-graphs>', 'CreationDate': '2013-10-10T18:39:05.643', 'Id': '14991'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '708', 'Title': 'Shortest non intersecting path for a graph embedded in a euclidean plane (2D)', 'LastEditDate': '2013-12-10T03:44:41.487', 'AnswerCount': '2', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '2755', 'FavoriteCount': '7', 'Body': '<p>What algorithm would you use to find the shortest path of a graph, which is embedded in an euclidean plane, such that the path should not contain any self-intersections (in the embedding)?</p>\n\n<p>For example, in the graph below, you want to go from $(0,0) \\rightarrow (-3,2)$. Normally, an algorithm like Dijkstra\'s algorithm would produce a sequence like:</p>\n\n<p>$$\\left[ (0,0) \\stackrel {3}{\\rightarrow} (0,3) \\stackrel{\\sqrt{2}}{\\rightarrow} (1,2) \\stackrel{4}{\\rightarrow} (-3,2) \\right] = 7+\\sqrt{2}.$$</p>\n\n<p>Full graph:</p>\n\n<p><img src="http://i.stack.imgur.com/l3OkDm.jpg" alt="enter image description here"></p>\n\n<p>Shortest path:</p>\n\n<p><img src="http://i.stack.imgur.com/HwDQtm.jpg" alt="enter image description here"></p>\n\n<p>Shortest non-intersecting path:</p>\n\n<p><img src="http://i.stack.imgur.com/sIj1wm.jpg" alt="enter image description here"></p>\n\n<p>However, this path intersects itself on the euclidean plane, therefore I <em>want</em> an algorithm that would give me the shortest non-intersecting sequence, in this case:</p>\n\n<p>$$\\left[(0,0) \\stackrel{3}{\\rightarrow} (0,3) \\stackrel{3}{\\rightarrow} (0,6) \\stackrel{5}{\\rightarrow} (-3,2) \\right] = 11.$$</p>\n\n<p>This path is longer than the shortest path, but it is the shortest non-intersecting path.</p>\n\n<p><strong>Is there an (efficient) algorithm that can do this?</strong></p>\n\n<h2>TikZ sources</h2>\n\n<ul>\n<li><a href="https://www.writelatex.com/read/jzkhmqgmqcnj" rel="nofollow">Full graph</a>.</li>\n<li><a href="https://www.writelatex.com/read/kwpwzzcfyjcy" rel="nofollow">Shortest path</a>.</li>\n<li><a href="https://www.writelatex.com/read/qzrbvwxgpbtp" rel="nofollow">Shortest non-intersecting path</a>.</li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal><weighted-graphs>', 'LastEditorUserId': '2755', 'LastActivityDate': '2013-12-10T03:44:41.487', 'CommentCount': '20', 'AcceptedAnswerId': '16281', 'CreationDate': '2013-10-20T23:27:17.370', 'Id': '16269'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Let $G$ be a graph, and let $s$ and $t$ be two vertices of $G$. Can we efficiently sample a shortest $s$-$t$ path uniformly and independently at random from the set of all shortest paths between $s$ and $t$? For simplicity, we can assume $G$ is simple, undirected and unweighted.</p>\n\n<p>Even in many restricted graphs, the number of shortest paths between $s$ and $t$ can be exponential in the size of $G$. Therefore, we would naturally like avoid actually computing all the shortest $s$-$t$ paths. I don't know about the general case, but it seems to me that we can achieve this for some special graph classes.</p>\n\n<p>This feels like something someone must have considered before. Is there any existing research into this, or is this in fact simple to do even for general graphs?</p>\n", 'ViewCount': '187', 'Title': 'Efficiently sampling shortest $s$-$t$ paths uniformly and independently at random', 'LastActivityDate': '2013-11-12T15:18:07.457', 'AnswerCount': '2', 'CommentCount': '14', 'AcceptedAnswerId': '17929', 'Score': '10', 'PostTypeId': '1', 'OwnerUserId': '472', 'Tags': '<graph-theory><reference-request><shortest-path><sampling>', 'CreationDate': '2013-11-11T14:36:27.297', 'FavoriteCount': '4', 'Id': '17917'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u'<p>I will be given some kind of this graph as in the picture below. I\'ve searched some algorithms but it seams as if it is something impossible for me to figure them out. In fact using <a href="http://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm" rel="nofollow">Floyd\u2013Warshall algorithm</a> it is kinda of possible, but unfortunately I\'m only allowed to use stacks (instead of matrices). I also looked for <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a> but I could not get the relationship with my problem.<img src="http://i.stack.imgur.com/z6bfG.png" alt="picture"></p>\n\n<p>Clearly my aim is to get all <strong>shortest paths</strong> from one point to another one. As I mentioned I will just output the solution from my <strong>stack</strong> in a vector string. I guess I have to visit each node and what I am most afraid is of getting stacked in a loop or even loosing the track during the search.\nAlso note that this is <strong>not a directed graph</strong>. If  Dijkstra\'s algorithm is applicable here I would be very grateful if anyone of you would guide me and I would really appreciate any help, suggestion, idea or even a vision for not getting stacked in a loop or loosing the track while searching.</p>\n\n<p>Thanks in advance.</p>\n', 'ViewCount': '81', 'Title': 'Finding Shortest Paths of weighted graph using stacks', 'LastActivityDate': '2013-11-16T11:28:27.430', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11406', 'Tags': '<algorithms><graph-theory><graphs><shortest-path>', 'CreationDate': '2013-11-16T11:28:27.430', 'Id': '18071'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Motivated by <a href="http://cs.stackexchange.com/q/17917/2755">Efficiently sampling shortest s-t paths uniformly and independently at random</a>,</p>\n\n<p>The answers give methods of randomly sampling shortest $s\\text{-}t$ paths. However, they use a lot of seemingly unnecessary random bits.</p>\n\n<p>My question is:</p>\n\n<blockquote>\n  <p>Can the solution be improved to use a single random number in interval $[0,w(t))$, where $w(t)$ is the total number of shortest paths from $s\\text{-}t$.</p>\n  \n  <p>Alternatively, can the solution be improved to use $\\left\\lceil \\log_2 w(t)\\right\\rceil $ random bits?</p>\n</blockquote>\n', 'ViewCount': '74', 'Title': 'Uniformly random efficient sampling of shortest s-t paths, with optimal random bits', 'LastActivityDate': '2013-11-17T19:21:56.460', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '18091', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<graph-theory><shortest-path><sampling><random>', 'CreationDate': '2013-11-17T01:51:40.173', 'FavoriteCount': '1', 'Id': '18089'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>According to CLRS, each iteration of the outermost loop (on $k$) makes a new copy of the adjacency matrix. Is it safe not to copy the matrix on every iteration?</p>\n\n<p>What I mean is, according to CLRS:</p>\n\n<p>$d_{ij}^K = \\min(d_{ij}^{K-1}, d_{ik}^{K-1} + d_{kj}^{K-1})$</p>\n\n<p>Is the following possible?</p>\n\n<p>$d_{ij} = \\min(d_{ij}, d_{ik} + d_{kj})$</p>\n\n<p>I have tried not copying the matrix, and got the same result before as the one which makes a copy after each iteration, but did I just get lucky?</p>\n', 'ViewCount': '82', 'Title': 'Can Floyd-Warshall be used to solve an APSP problem without copying the matrix?', 'LastEditorUserId': '11637', 'LastActivityDate': '2013-11-26T18:09:21.957', 'LastEditDate': '2013-11-26T16:10:04.703', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '18392', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11637', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-11-26T15:49:45.417', 'Id': '18389'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Let $ G=(V,E) $ be a directed graph with a real weight function $w$ defined on the edges and $ a,b \\in V$. Let $\\alpha$ denote the minimal weight of all paths from $a$ to $b$ and $\\beta$ denote the minimal weight of all paths from $b$ to $a$. How do you find two paths $l_1,l_2$  such that:</p>\n\n<ol>\n<li>$l_1=(a,v_1,..,v_n,b)$</li>\n<li>$l_2=(b,u_1,..,u_m,a)$</li>\n<li>$w(l_1) + w(l_2)\\leq 1.1(\\alpha + \\beta)$</li>\n<li>From all the paths holding the above, bring to minimum the sum of weights on the edges $e=(u,v)\\in l_1$ such that $(v,u)\\in l_2$</li>\n</ol>\n\n<p>Less formally, I want to find a path starting at $a$ ending with $b$ and returning to $a$ such that the path is not too long (at most 10% longer than the optimal solution) and tries to use as much as different roads as possible (if it used some road $(x,y)$ when going from $a$ to $b$ , it would try to avoid the road $(y,x)$ when going back to $a$)</p>\n', 'ViewCount': '88', 'Title': 'Path finding under constraints', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T19:10:15.007', 'LastEditDate': '2014-01-07T10:00:27.157', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '7706', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-12-07T22:12:38.000', 'Id': '18725'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>What is the difference between minimum spanning tree algorithm and a shortest path algorithm?</p>\n\n<p>In my data structures class we covered two minimum spanning tree algorithms (Prim's and Kruskal's) and one shortest path algorithm (Dijkstra's). </p>\n\n<p>Minimum spanning tree is a tree in a graph that spans all the vertices and total weight of a tree is minimal. Shortest path is quite obvious, it is a shortest path from one vertex to another. </p>\n\n<p>What I don't understand is since minimum spanning tree has a minimal total weight, wouldn't the paths in the tree be the shortest paths? Can anybody explain what I'm missing?</p>\n\n<p>Any help is appreciated.</p>\n", 'ViewCount': '530', 'Title': 'Minimum spanning tree vs Shortest path', 'LastActivityDate': '2013-12-10T10:12:43.997', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10511', 'Tags': '<shortest-path><spanning-trees>', 'CreationDate': '2013-12-09T22:57:57.720', 'Id': '18797'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Given a weighted digraph $G=V,E$, and a weight function, $d(u,v)$, one can normally use Dijkstra's algorithm to obtain the shortest path. What I am interested in, is how to obtain the $2^{nd}$-shortest path, the $3^{rd}$-shortest, and so on.</p>\n\n<p>Questions:</p>\n\n<blockquote>\n  <p>Is there an efficient algorithm to get the i-th-most-shortest-path between two nodes in a weighted graph?</p>\n  \n  <p>Is there an efficient algorithm to get the k-most-shortest-paths between two nodes in a weighted graph?</p>\n</blockquote>\n\n<p>An answer to either one is OK, though I wonder if an answer to the second question can be done more efficiently than $k$ calls to an answer to the first question.</p>\n", 'ViewCount': '67', 'Title': 'k-shortest paths', 'LastActivityDate': '2013-12-11T00:25:44.833', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2755', 'Tags': '<algorithms><graphs><shortest-path><graph-traversal>', 'CreationDate': '2013-12-11T00:25:44.833', 'FavoriteCount': '1', 'Id': '18849'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I am working on a special case of the longest path problem. For a cyclic directed graph $G=(V, E)$, where the edge-weights are probability values (i.e., $P(\\_) = w(s, q)$ with $s,q \\in V$), my aim is to find the least 'probable' path between two vertices. </p>\n\n<p>My initial approach is to generate an graph $G'$ where the weights are the complementary probabilities $1- w(s, q)$ (with strictly positive values), and compute Dijkstra's shortest path on $G'$. Is this reasoning sound? Or am I getting myself into an NP-hard disaster?</p>\n", 'ViewCount': '141', 'Title': 'Find least probable path in graph', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-19T02:10:13.287', 'LastEditDate': '2014-01-19T02:10:13.287', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '19217', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12300', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2013-12-23T12:08:42.880', 'Id': '19207'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Suppose I want to run Dijkstra's algorithm on a graph whose edge weights are integers in the\nrange 0, ..., W, where W is a relatively small number.\nHow can I modify that algorithm so that it takes time just O((|V| + |E|) logW) and relatively easy implement that in C/C++?</p>\n", 'ViewCount': '259', 'Title': "Dijkstra's algorithm for edge weights in range 0, ..., W", 'LastActivityDate': '2013-12-25T17:06:47.797', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12351', 'Tags': '<algorithms><algorithm-analysis><data-structures><shortest-path><weighted-graphs>', 'CreationDate': '2013-12-24T16:15:19.157', 'Id': '19252'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm trying to come up with a good algorithm for the following decision problem:</p>\n\n<p>Let $G=(V,A)$ be a directed graph and let $s,t \\in V$. Are there at-least 2 non-intersecting paths from $s$ to $t$?</p>\n\n<p>By non-intersecting I mean that if $P_1$ and $P_2$ are non-intersecting paths from $s$ to $t$ then $\\forall e\\in P_1\\in A, e\\notin P_2$ (can share vertices but not edges).</p>\n\n<p>I thought of the following algorithm:</p>\n\n<ol>\n<li>Find the shortest path $P\\in A$ in $G$ from $s$ to $t$. if no such path exist, return false;</li>\n<li>Find the shortest path $P'\\in A-P$ in $G$ from $s$ to $t$. if no such path exists, return false; else return true.</li>\n</ol>\n\n<p>I didn't find a contradicting example but so far I was unable to prove its correctness.</p>\n\n<p>Ideas about proof approaches for this algorithm or suggesting other algorithms is welcome.</p>\n", 'ViewCount': '69', 'Title': 'Non intersecting paths in a graph', 'LastEditorUserId': '10438', 'LastActivityDate': '2014-01-01T16:49:59.463', 'LastEditDate': '2013-12-31T16:24:44.257', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '19418', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10438', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2013-12-31T16:06:10.790', 'Id': '19413'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I\'m trying to apply <a href="http://en.wikipedia.org/wiki/Dijkstra%27s_algorithm" rel="nofollow">Dijkstra\'s algorithm</a> to the <a href="http://projecteuler.net/problem=83" rel="nofollow">Problem 83</a> on projecteuler.net. The problem reads:</p>\n\n<blockquote>\n  <p>In the 5 by 5 matrix below, the minimal path sum from the top left to\n  the bottom right, by moving left, right, up, and down, is indicated in\n  bold red and is equal to 2297.</p>\n\n<pre><code>131   673   234   103    18\n201    96   342   965   150\n630   803   746   422   111\n537   699   497   121   956\n805   732   524    37   331\n</code></pre>\n  \n  <p>Find the minimal path sum, in matrix.txt (right click and \'Save\n  Link/Target As...\'), a 31K text file containing a 80 by 80 matrix,\n  from the top left to the bottom right by moving left, right, up, and\n  down.</p>\n</blockquote>\n\n<p>I wonder if the original algorithm can be simplified due to the fact that the graph is represented as a matrix?</p>\n\n<p>In particular, I\'ve noticed that every edge in the graph is only relaxed once (i.e. the node\'s distance is changed only once from infinity to some value). Can I rely on this fact in my code?</p>\n', 'ViewCount': '247', 'Title': "How to optimize Dijkstra's algorithm for a grid graph?", 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-06T11:39:11.420', 'LastEditDate': '2014-01-06T11:39:11.420', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '0', 'OwnerDisplayName': 'user12525', 'PostTypeId': '1', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2014-01-02T02:19:25.053', 'Id': '19446'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': u"<p>I have the following problem:</p>\n\n<blockquote>\n  <p>In a 2D space with polygonal obstacles, find the shortest path between two given point.</p>\n</blockquote>\n\n<p>Without additional constraints, we can reduce it to a graph problem by constructing a visibility graph and then solve it by searching.</p>\n\n<p>If the following constraints are added, how can we solve it?</p>\n\n<p>Let's define a path as a set of line segments.</p>\n\n<ol>\n<li>Each segment must be longer than a given value.</li>\n<li>Each segment must be horizontal or vertical. (simplified version)<br/>\nEach segment must be parallel or perpendicular to other segments. (general version)</li>\n</ol>\n\n<p><strong>Clarification</strong></p>\n\n<ul>\n<li>The problem is in continuous 2D space.</li>\n<li>To simply the problem, the direction of the first and the last segments is given.</li>\n</ul>\n\n<p><strong>Application</strong></p>\n\n<p>This can be considered as a routing problem. I am going to use the algorithm for MEP services routing (e.g. duct, pipe, cable tray).</p>\n\n<p>We need a connector to connect two services when the direction is changed.</p>\n\n<ul>\n<li>As the connector consumes some space, we have constraint (1).</li>\n<li>As we only have limited choices of the connector (90\xb0, 60\xb0, 45\xb0, 30\xb0), we have constraint (2). To simplified the problem, I only use connector for right angle.</li>\n</ul>\n", 'ViewCount': '99', 'Title': 'Any algorithm for finding Euclidean shortest path with specific constraints in 2D?', 'LastEditorUserId': '12662', 'LastActivityDate': '2014-01-09T01:47:04.127', 'LastEditDate': '2014-01-09T01:47:04.127', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12662', 'Tags': '<algorithms><computational-geometry><shortest-path>', 'CreationDate': '2014-01-08T06:21:37.013', 'Id': '19573'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have to generate all possible paths in a directed, acyclic weighted graph with edge costs. I also have to sort them in order of shortest path. </p>\n\n<p>The simplest way that comes to mind is to do a depth-first search (DFS) for all paths, accumulating their edge costs as I traverse the paths, and then doing an NlogN sort on the result. </p>\n\n<p>But I wondering if there is a better way to do this task. Are there any algorithms that could optimize this problem (combining DFS and a shortest path algorithm such as Dijkstra's maybe?). </p>\n", 'ViewCount': '261', 'Title': 'Optimal algorithm to traverse all paths in the order of shortest path', 'LastEditorUserId': '10519', 'LastActivityDate': '2014-01-19T16:10:53.177', 'LastEditDate': '2014-01-16T17:08:00.273', 'AnswerCount': '1', 'CommentCount': '13', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '10519', 'Tags': '<algorithms><graphs><shortest-path><search-algorithms>', 'CreationDate': '2014-01-16T01:40:27.343', 'FavoriteCount': '1', 'Id': '19761'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '331', 'Title': "Why does Dijkstra's algorithm fail on a negative weighted graphs?", 'LastEditDate': '2014-01-16T22:51:53.690', 'AnswerCount': '1', 'Score': '12', 'PostTypeId': '1', 'OwnerUserId': '11972', 'FavoriteCount': '1', 'Body': '<p>I know this is probably very basic, I just can\'t wrap my head around it.<br>\nWe recently studied about Dijkstra\'s algorithm for finding the shortest path between two vertices on a weighted graph.<br>\nMy professor said this algorithm will not work on a graph with negative edges, so I tried to figure out what could be wrong with shifting all the edges weights by a positive number, so that they all be positive, when the input graph has negative edges in it.<br>\nFor example, let\'s consider the following input graph:<br>\n<img src="http://i.stack.imgur.com/GlrNb.png" alt="input graph"><br>\nNow if I\'ll add 3 to all edges, it\'s obvious that the shortest path (between $s$ and $t$) has changed:\n<img src="http://i.stack.imgur.com/NgPpM.png" alt="graph after adding 3"><br>\nThus this kind of operation might result in wrong output. \nAnd this, basically, what I don\'t get. Why does this happen? Why is shifting the values has such a dramatic effect on the shortest path? This is totally counter-intuitive, at least for me.<br>\nIn probability, when you have some (discrete) distribution probability given by some random variable $X$, and you want to calculate the variance, then for every constant $c$, it holds that $Var(X+c)=Var(X)$, and this happens, of-course, because shifting the distribution values left or right does not effect how $X$ spreads.<br>\nNow, I\'m well aware that these are two different things here, and finding the shortest path is not exactly the same as calculating the variance of a random distribution function, but I\'m just saying that this is why to me it seems so counter-intuitive.</p>\n\n<p>Your thoughts?</p>\n', 'Tags': '<algorithms><graphs><shortest-path><weighted-graphs>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-16T22:51:53.690', 'CommentCount': '3', 'AcceptedAnswerId': '19775', 'CreationDate': '2014-01-16T18:47:20.783', 'Id': '19771'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I have a directed graph with $N$ vertices. Every pair of vertices is connected by two edges (one in each direction), and each of these edges has a weight which may be negative.</p>\n\n<p>On various occasions 'edge update' operations occur, where the weight of an edge is modified (although the edge is never deleted, and no new edges or vertices are added). After each of these operations I wish to know the length of the shortest path between one 'root' vertex and every other vertex in the graph. I don't care what the path is, and I already know it must exist. I don't mind how negative weight cycles are handled.</p>\n\n<p>I care about optimizing the running time of the single update operation and the $N$ queries that follow.</p>\n\n<p>The obvious approach would be Bellman-Ford, which would take $O(|V||E|)$ which is $O(n^3)$.</p>\n\n<p>Is there a faster way to do it?</p>\n", 'ViewCount': '37', 'Title': 'Update SSSPP solution on complete digraph on weight changes', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T13:06:42.687', 'LastEditDate': '2014-01-30T13:06:42.687', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6986', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-01-29T23:13:29.900', 'FavoriteCount': '2', 'Id': '20089'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>I have been reading about Dijkstra\'s algorithm and I think I understand it. I followed the algorithm in pseudo-code from Wikipedia, and now I wonder:</p>\n\n<ol>\n<li><p>If my graph is bi-directional and I add each edge to my graph <em>twice</em> (once "forwards", once "backwards"), will the "standard" Dijkstra\'s algorithm work?</p></li>\n<li><p>Is it ok that some of my edges are zero cost? (the rest are all positive - none are negative)</p></li>\n</ol>\n\n<p>And finally, what is a Dijkstra "heap" algorithm? Is it the same as Dijkstra\'s algorithm using a PriorityQueue?</p>\n', 'ViewCount': '106', 'Title': 'Does "standard" Dijkstra\'s algorithm work with bi-directional edges and zero cost edges?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-04T10:06:37.453', 'LastEditDate': '2014-02-04T10:06:37.453', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '21281', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14379', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-02-04T07:55:47.223', 'Id': '21280'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '64', 'Title': 'Finding all paths with lengths in a fixed interval in sparse graphs', 'LastEditDate': '2014-02-06T16:31:43.573', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Andrew S.', 'PostTypeId': '1', 'OwnerUserId': '13327', 'Body': '<p>What is the most efficient way to find all paths of length M to N in a large sparse graph?</p>\n\n<p>Some general information:</p>\n\n<ul>\n<li>Graph has 30,000 to 50,000 nodes</li>\n<li>Average number of edges per node ~ 10</li>\n<li>M=4, N=7</li>\n<li>Graph has cycles</li>\n</ul>\n', 'Tags': '<algorithms><graphs><shortest-path>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T19:11:38.457', 'CommentCount': '2', 'AcceptedAnswerId': '21382', 'CreationDate': '2014-02-01T17:56:44.383', 'Id': '21381'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>Here is my problem: I have a directed weighted graph with a substantial amount of vertices (few thousands), no cycles, in fact, it includes a starting node, a final node and an $m \\times n$ grid between them, where edges can be directed from the left to the right only. The weights of the edges depend on the path in which they are included (for example, if the path includes v.15, then the weights of several edges change).</p>\n\n<p>I tried to get all possible paths and then calculate their final sum post factum, but that turned out to be very inefficient method due to the number of paths. Is there an effective method which allows to find shortest paths in these kind of graphs?</p>\n', 'ViewCount': '74', 'Title': 'Finding shortest path in a graph when edge weights depend on the chosen vertices', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T09:41:29.690', 'LastEditDate': '2014-02-19T09:41:29.690', 'AnswerCount': '0', 'CommentCount': '13', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14837', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-02-19T09:31:23.923', 'Id': '21807'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>Suppose I have a source node $S$, destination node $D$ and a set $A$ of intermediate nodes $P_1, P_2, \\dots$ in an edge-weighted undirected graph. I want to find the vertex $P_i\\in A$ that minimizes $\\mathrm{dist}(S, P_i) + \\mathrm{dist}(D, P_i)$?  In addition, the overall path from $S$ to $D$ should contain only one node from the set $A$.  What is an efficient algorithm for this? I don't want to go with brute-force approach.</p>\n", 'ViewCount': '114', 'Title': 'Minimum path between two vertices passing through a given set exactly once', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T19:05:53.140', 'LastEditDate': '2014-04-09T13:09:03.500', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16563', 'Tags': '<algorithms><graphs><shortest-path>', 'CreationDate': '2014-04-08T18:26:55.787', 'FavoriteCount': '1', 'Id': '23558'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'ViewCount': '57', 'Title': 'Shortest directed path connecting given subset of vertices', 'LastEditDate': '2014-04-14T18:27:40.627', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6615', 'FavoriteCount': '1', 'Body': '<p>Given</p>\n\n<ul>\n<li>weighted directed graph $G = (V,E,w)$, where $w : E \\to \\mathbb R^+$</li>\n<li>source vertex $v \\in V$</li>\n<li>vertex subset $U \\subset V$</li>\n</ul>\n\n<p>how to find a shortest directed path from $v$ containing all vertices from $U$? Note that such path may contain vertices that are not in $U$.</p>\n\n<ol>\n<li>Does such problem have a name?</li>\n<li>How to find a solution?</li>\n</ol>\n', 'Tags': '<graph-theory><terminology><shortest-path><weighted-graphs>', 'LastEditorUserId': '6615', 'LastActivityDate': '2014-04-14T18:27:40.627', 'CommentCount': '2', 'AcceptedAnswerId': '23789', 'CreationDate': '2014-04-14T14:52:04.890', 'Id': '23784'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I'm given a graph and two weight functions, $w_1$ and $w_2$, such that there doesn't exist a negative loop in the graph in $w_1$ and $w_2$. I'm also given two vertices, $s$ and $t$, and am asked to find the lightest path from $s$ to $t$ in relation to $w_1$, out of all the lightest paths from $s$ to $t$ in relation to $w_2$.</p>\n\n<p>I get that this question begs for me to modify Dijkstra somehow, but I just can't seem to find the intuition to do so. Any guidance would be appreciated!</p>\n", 'ViewCount': '35', 'Title': 'Using Dijkstra to find shortest path in relation to two weight functions?', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-20T20:26:30.380', 'LastEditDate': '2014-04-20T20:26:30.380', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16769', 'Tags': '<shortest-path><weighted-graphs>', 'CreationDate': '2014-04-19T18:02:17.503', 'Id': '23938'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': '<p>A multi-constrained path problem MCP(G,s,t,w1,w2,c1,c2) is defined as</p>\n\n<p><img src="http://i.stack.imgur.com/CAsC0.png" alt="enter image description here"></p>\n', 'ViewCount': '11', 'ClosedDate': '2014-04-29T10:03:20.073', 'Title': 'Multi constrained Path', 'LastActivityDate': '2014-04-29T05:30:54.950', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '17167', 'Tags': '<shortest-path>', 'CreationDate': '2014-04-29T05:30:54.950', 'Id': '24212'}},{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,{'Body': "<p>I want to develop one algorithm which can predict shortest time to be taken to go to a destination from a source in a road network based on traffic congestion data. \nConsider that I have a server which gives me real time traffic congestion data for all the path segments in a road network. Now I want to develop such an algorithm which can predict time to be taken based on these data. So in short: </p>\n\n<p>time_to_be_taken_from_source_to_destination = function ( traffic_congestion_data ). And 'time_to_be_taken_from_source_to_destination' is proportional to 'traffic_congestion_data' as time increases when traffic_congestion increases.</p>\n\n<p>Are there any such algorithm alraedy developed? Any idea? reference to any algorithm or theory will be appreciated. </p>\n", 'ViewCount': '10', 'Title': 'shortest time based on traffic congestion data', 'LastActivityDate': '2014-05-03T22:11:25.087', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16563', 'Tags': '<algorithms><graph-theory><shortest-path>', 'CreationDate': '2014-05-03T05:47:16.070', 'Id': '24341'}},