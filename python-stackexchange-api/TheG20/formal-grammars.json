200:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1377', 'Title': 'What is the significance of context-sensitive (Type 1) languages?', 'LastEditDate': '2012-03-07T16:09:28.450', 'AnswerCount': '9', 'Score': '23', 'PostTypeId': '1', 'OwnerUserId': '26', 'FavoriteCount': '1', 'Body': '<p>Seeing that in the <a href="http://en.wikipedia.org/wiki/Chomsky_hierarchy">Chomsky Hierarchy</a> Type 3 languages can be recognised by a state machine with no external memory (i.e., a finite automaton), Type 2 by a state machine with a <em>single</em> stack (i.e. a push-down automaton) and Type 0 by a state machine with <em>two</em> stacks (or, equivalently, a tape, as is the case for Turing Machines), how do Type 1 languages fit into this picture? And what advantages does it bring to determine that a language is not only Type 0 but Type 1?</p>\n', 'Tags': '<formal-languages><applied-theory><computability><automata><formal-grammars>', 'LastEditorUserId': '69', 'LastActivityDate': '2012-03-08T02:30:13.020', 'CommentCount': '9', 'AcceptedAnswerId': '31', 'CreationDate': '2012-03-06T20:06:29.977', 'Id': '14'},201:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3821', 'Title': 'Language theoretic comparison of LL and LR grammars', 'LastEditDate': '2013-06-06T14:05:27.163', 'AnswerCount': '1', 'Score': '24', 'PostTypeId': '1', 'OwnerUserId': '98', 'FavoriteCount': '13', 'Body': '<p>People often say that <a href="https://en.wikipedia.org/wiki/LR_parser">LR(k)</a> parsers are more powerful than <a href="https://en.wikipedia.org/wiki/LL_parser">LL(k)</a> parsers. These statements are vague most of the time; in particular, should we compare the classes for a fixed $k$ or the union over all $k$? So how is the situation really? In particular, I am interested in how LL(*) fits in.</p>\n\n<p>As far as I know, the respective sets of grammars LL and LR parsers accept are orthogonal, so let us talk about the languages generated by the respective sets of grammars. Let $LR(k)$ denote the class of languages generated by grammars that can be parsed by an $LR(k)$ parser, and similar for other classes.</p>\n\n<p>I am interested in the following relations:</p>\n\n<ul>\n<li>$LL(k) \\overset{?}{\\subseteq} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{\\subseteq} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n<li>$\\bigcup_{i=1}^{\\infty} LL(k) \\overset{?}{=} LL(*)$</li>\n<li>$LL(*) \\overset{?}{\\circ} \\bigcup_{i=1}^{\\infty} LR(k)$</li>\n</ul>\n\n<p>Some of these are probably easy; my goal is to collect a "complete" comparison. References are appreciated.</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><reference-question>', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T14:05:27.163', 'CommentCount': '2', 'AcceptedAnswerId': '48', 'CreationDate': '2012-03-07T00:32:31.947', 'Id': '43'},202:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>EPAL, the language of even palindromes, is defined as the language generated by the following unambiguous context-free grammar:</p>\n\n<blockquote>\n  <p>$S \\rightarrow a a$</p>\n  \n  <p>$S \\rightarrow b b$</p>\n  \n  <p>$S \\rightarrow a S a$</p>\n  \n  <p>$S \\rightarrow b S b$</p>\n</blockquote>\n\n<p>EPAL is the 'bane' of many parsing algorithms: I have yet to encounter any parsing algorithm for unambiguous CFGs that can parse any grammar describing the language. It is often used to show that there are unambiguous CFGs that cannot be parsed by a particular parser. This inspired my question:</p>\n\n<blockquote>\n  <p>Is there some parsing algorithm accepting only unambiguous CFGs that works on EPAL?</p>\n</blockquote>\n\n<p>Of course, one can design an ad-hoc two-pass parser for the grammar that parses the language in linear time. I'm interested in parsing methods that have not been designed specifically with EPAL in mind.</p>\n", 'ViewCount': '150', 'Title': 'Is there any nongeneral CFG parsing algorithm that recognises EPAL?', 'LastActivityDate': '2013-01-24T01:25:28.517', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '141', 'Score': '15', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<formal-languages><formal-grammars><parsers>', 'CreationDate': '2012-03-07T16:56:52.460', 'FavoriteCount': '0', 'Id': '102'},203:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1455', 'Title': 'Are there inherently ambiguous and deterministic context-free languages?', 'LastEditDate': '2012-03-15T11:35:41.913', 'AnswerCount': '1', 'Score': '18', 'PostTypeId': '1', 'OwnerUserId': '69', 'FavoriteCount': '1', 'Body': '<p>Let us call a context-free language deterministic if and only if it can be accepted by a deterministic push-down automaton, and nondeterministic otherwise.</p>\n\n<p>Let us call a context-free language inherently ambiguous if and only if all context-free grammars which generate the language are ambiguous, and unambiguous otherwise.</p>\n\n<p>An example of a deterministic, unambiguous language is the language: $$\\{a^{n}b^{n} \\in \\{a, b\\}^{*} | n \\ge 0\\}$$\nAn example of a nondeterministic, unambiguous language is the language: \n$$\\{w \\in \\{a, b\\}^{*} | w = w^{R}\\}$$</p>\n\n<p>From <a href="http://en.wikipedia.org/wiki/Ambiguous_grammar#Inherently_ambiguous_languages">Wikipedia</a>, an example of an inherently ambiguous context-free language is the following union of context-free languages, which must also be context-free: \n$$L = \\{a^{n}b^{m}c^{m}d^{n} \\in \\{a, b, c, d\\}^{*} | n, m \\ge 0\\} \\cup \\{a^{n}b^{n}c^{m}d^{m} \\in \\{a, b, c, d\\}^{*} | n, m \\ge 0\\}$$</p>\n\n<p>Now for the questions:</p>\n\n<ol>\n<li>Is it known whether there exists a deterministic, inherently ambiguous context-free language? If so, is there an (easy) example?</li>\n<li>Is it known whether there exists a nondeterministic, inherently ambiguous context-free language? If so, is there an (easy) example?</li>\n</ol>\n\n<p>Clearly, since an inherently ambiguous context-free language exists ($L$ is an example), the answer to one of these questions is easy, if it is known whether $L$ is deterministic or nondeterministic. I also assume that it\'s true that if there\'s a deterministic one, there\'s bound to be a nondeterministic one as well... but I\'ve been surprised before. References are appreciated, and apologies in advance if this is a well-known, celebrated result (in which case, I\'m completely unaware of it).</p>\n', 'Tags': '<formal-languages><automata><formal-grammars><pushdown-automata>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-03-15T11:35:41.913', 'CommentCount': '0', 'AcceptedAnswerId': '111', 'CreationDate': '2012-03-07T20:56:08.960', 'Id': '109'},204:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '336', 'Title': 'Decidable non-context-sensitive languages', 'LastEditDate': '2012-03-13T02:01:32.497', 'AnswerCount': '2', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '95', 'FavoriteCount': '1', 'Body': '<p>It is arguable that most languages created to describe everyday problems are context-sensitives. In the other hand, it is possible and not hard to find some languages that are not recursive or even not recursively-enumerable.</p>\n\n<p>Between these two types are the recursive non-context-sensitive languages. Wikipedia gives one example <a href="http://en.wikipedia.org/wiki/Context-sensitive_language">here</a>:</p>\n\n<blockquote>An example of recursive language that is not context-sensitive is any recursive language whose decision is an EXPSPACE-hard problem, say, the set of pairs of equivalent regular expressions with exponentiation.</blockquote>\n\n<p>So the question: What others problems exists that are decidable but yet non-context-sensitive? Is this class of problems the same as decidable EXPSPACE-hard?</p>\n', 'Tags': '<formal-languages><complexity-theory><formal-grammars>', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-13T03:17:33.480', 'CommentCount': '1', 'AcceptedAnswerId': '280', 'CreationDate': '2012-03-13T01:19:52.050', 'Id': '273'},205:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Let $\\Sigma$ be the set of terminal and $N$ the set of non-terminal symbols of some context-free grammar $G$.</p>\n\n<p>Say I have a string $a \\in (\\Sigma \\cup N)^+$ such that $x a y \\in \\mathcal{S}(G)$ where $x,y\\in (\\Sigma \\cup N)^*$ and $\\mathcal{S}(G)$ are the sentential forms of $G$.</p>\n\n<p>Given $G$, I'd like to determine a set $C = \\{ b \\mid wabz \\in \\mathcal{S}(G), b \\in \\Sigma \\cup N \\}$. </p>\n\n<p>To clarify, in this case, $w, x, y, z, a, b$ are strings of terminals and non-terminals and $b$ is of length one.</p>\n\n<p>I can see how to do this if $a$ is also of length one; each $b$ is a member of the follow set of $a$ (including non-terminals).</p>\n\n<p>However, I am curious if it's possible for a sequence of characters. For my application, the string $a$ is not much longer than the right hand side of the productions in $G$.</p>\n\n<p>The distinction between terminals and non-terminals is somewhat mute in my application because I am using a generative grammar; and I believe that this won't lead to much trouble since $b$ is of length one.</p>\n", 'ViewCount': '285', 'Title': 'Given a string and a CFG, what characters can follow the string (in the sentential forms of the CFG)?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T03:04:17.907', 'LastEditDate': '2012-03-27T03:04:17.907', 'AnswerCount': '1', 'CommentCount': '12', 'AcceptedAnswerId': '556', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '237', 'Tags': '<algorithms><context-free><formal-grammars><compilers>', 'CreationDate': '2012-03-20T22:55:17.150', 'Id': '555'},206:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Can every <a href="http://en.wikipedia.org/wiki/Linear_grammar" rel="nofollow">linear grammar</a> be converted to a linear <a href="http://en.wikipedia.org/wiki/Greibach_normal_form" rel="nofollow">Greibach normal form</a>, a form in which all productions look like $A \\rightarrow ax$ where $a \\in T$ and $x \\in V \\cup \\{\\lambda\\}$?</p>\n\n<p>($T$ is the set of terminals, $V$ is the set of non-terminals, $\\lambda$ is the empty sequence.)</p>\n', 'ViewCount': '230', 'Title': 'Can every linear grammar be converted to Greibach form?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-03-27T03:09:38.617', 'LastEditDate': '2012-03-27T03:09:38.617', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '591', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '51', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-03-21T07:15:34.200', 'Id': '588'},207:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following language</p>\n\n<p>$\\qquad \\{0^i 1^j 2^k \\mid 0 \\leq i \\leq j \\leq k\\}$</p>\n\n<p>I am trying to determine which Chomsky language class it fits into. I can see how it could be made using a context-sensitive grammar so I know it is atleast context-sensitive. It seems like it wouldn't be possible to make with a context-free grammar, but I'm having a problem proving that.</p>\n\n<p>It seems to pass the fork-pumping lemma because if $uvwxy$ is all placed in the third part of any word (the section with all of the $2$s). It could pump the $v$ and $x$ as many times as you want and it would stay in the language. If I'm wrong could you tell me why, if I'm right, I still think this language is not context-free, so how could I prove that?</p>\n", 'ViewCount': '951', 'Title': 'How can I prove this language is not context-free?', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-03-20T20:06:21.393', 'LastEditDate': '2013-03-20T20:06:21.393', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '596', 'Tags': '<formal-languages><context-free><formal-grammars><pumping-lemma>', 'CreationDate': '2012-03-21T18:21:10.833', 'Id': '619'},208:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $G$ be a context-free grammar. A string of terminals and nonterminals of $G$ is said to be a <em>sentential form</em> of $G$ if you can obtain it by applying productions of $G$ zero or more times to the start symbol of $S$. Let $\\operatorname{SF}(G)$ be the set of sentential forms of $G$.</p>\n\n<p>Let $\\alpha \\in \\operatorname{SF}(G)$ and let $\\beta$ be a substring of $\\alpha$ - we call $\\beta$ a <em>fragment</em> of $\\operatorname{SF}(G)$. Now let </p>\n\n<p>$\\operatorname{Before}(\\beta) = \\{ \\gamma \\ |\\ \\exists \\delta . \\gamma \\beta \\delta \\in \\operatorname{SF}(G) \\}$ </p>\n\n<p>and </p>\n\n<p>$\\operatorname{After}(\\beta) = \\{ \\delta \\ |\\ \\exists \\gamma . \\gamma \\beta \\delta \\in \\operatorname{SF}(G) \\}$.</p>\n\n<blockquote>\n  <p>Are $\\operatorname{Before}(\\beta)$ and $\\operatorname{After}(\\beta)$ context-free languages? What if $G$ is unambiguous? If $G$ is unambiguous, are $\\operatorname{Before}(\\beta)$ and $\\operatorname{After}(\\beta)$ also describable by an unambiguous context-free language?</p>\n</blockquote>\n\n<p>This is a followup to <a href="http://cs.stackexchange.com/questions/666/is-there-a-string-stack-data-structure-that-supports-these-string-operations">my earlier question</a>, after <a href="http://cs.stackexchange.com/questions/757/does-every-large-enough-string-have-repeats">an earlier attempt</a> to make my question easier to answer failed. A negative answer will make the encompassing question I\'m working on very hard to answer.</p>\n', 'ViewCount': '305', 'Title': 'Are the Before and After sets for context-free grammars always context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-25T16:53:00.780', 'LastEditDate': '2014-01-25T16:53:00.780', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '804', 'Score': '11', 'PostTypeId': '1', 'OwnerUserId': '92', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties>', 'CreationDate': '2012-03-26T17:48:12.210', 'Id': '802'},209:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '388', 'Title': 'Are there other ways to describe formal languages other than grammars?', 'LastEditDate': '2012-03-27T12:11:18.230', 'AnswerCount': '4', 'Score': '15', 'OwnerDisplayName': 'mtanti', 'PostTypeId': '1', 'OwnerUserId': '832', 'FavoriteCount': '2', 'Body': "<p>I'm looking for mathematical theories that deal with describing formal languages (set of strings) in general and not just grammar hierarchies.</p>\n", 'Tags': '<formal-languages><formal-grammars>', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-27T13:25:40.327', 'CommentCount': '1', 'AcceptedAnswerId': '821', 'CreationDate': '2012-03-26T19:23:50.510', 'Id': '813'},2010:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have to write a grammar for Pascal, and there is just one thing that is causing problems. </p>\n\n<p>Lets say we have operators (sorted by priority from low to high):</p>\n\n<ol>\n<li><em>Postfix <code>^</code></em>.</li>\n<li><em>Prefix <code>^</code></em>.</li>\n<li><em><code>[ ]</code></em>, and <code>.</code>, (same priority and left associative).</li>\n<li>The only terminal is <code>id</code>, which is any lowercase letter.</li>\n</ol>\n\n<p>Now let's say that an expression is:</p>\n\n<ol>\n<li>Any id.</li>\n<li>Any expression with the <em>Postfix <code>^</code></em> operator.</li>\n<li>Any expression with the <em>Prefix <code>^</code></em> operator.</li>\n<li>Any expression with <code>.</code> followed by <code>id</code>.</li>\n<li>Any expression with <code>[</code> and another expression and <code>]</code>.</li>\n</ol>\n\n<p>Now I would like to know how can I make a LALR grammar without shift-reduce and reduce-reduce conflicts, OR if that can't be done how can I prove that it can't be done.</p>\n\n<p>Some examples:</p>\n\n<pre><code>good:\na.b.c.d               \na.b^.c\n^a.b^\na.b^^[c]^^.d.e        \n^^a.b^.d.e^[]\n\nbad:\na.^b.c\n</code></pre>\n\n<p>Without the prefix <code>^</code>, this problem is easy to solve, but the prefix sign keeps getting me. Can anyone help? My solutions so far:</p>\n\n<pre><code>// this works without the prefix but it does not produce a.b^.c which is wrong.\nA ::= B | A ^ ;\nB ::= C | ^ B ;\nC ::= id | C [ A ] | C . id;\n</code></pre>\n\n<p>So I thought that the prefix can only occur before the first dot, and between dots, there can only be a postfix <code>^</code> and brackets. So I came up with this:</p>\n\n<pre><code>A ::= B | A ^ ;\nB ::= C | ^ B ;\nC ::= id | C [ A ] |id D;\nD ::= id E;\nF ::= E | F ^;\nE ::= id | F . id;\n</code></pre>\n\n<p>But this causes 3 conflicts.</p>\n", 'ViewCount': '367', 'Title': 'reduce reduce and shift reduce error in LALR grammar', 'LastEditorUserId': '12', 'LastActivityDate': '2012-04-05T07:15:43.883', 'LastEditDate': '2012-04-05T04:28:13.693', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'zidarsk8', 'PostTypeId': '1', 'OwnerUserId': '936', 'Tags': '<programming-languages><parsers><formal-grammars>', 'CreationDate': '2012-04-04T08:40:53.177', 'Id': '1029'},2011:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'd love your help with the following question:</p>\n\n<blockquote>\n  <p>Let $G$ be context free grammar in the <strong>Chomksy normal form</strong> with $k$\n  variables.</p>\n  \n  <p>Is the language $B = \\{ w \\in L(G) : |w| &gt;2^k \\}$ regular ?</p>\n</blockquote>\n\n<p>What is it about the amount of variables and the Chomsky normal form that is supposed to help me solve this question? I tried to look it up on the web, but besides information about the special form itself, I didn't find an answer to my question.</p>\n\n<p>The answer for the question is that $B$ might be regular.</p>\n", 'ViewCount': '275', 'Title': 'Chomsky normal form and regular languages', 'LastEditorUserId': '98', 'LastActivityDate': '2012-04-27T15:37:47.150', 'LastEditDate': '2012-04-27T15:37:47.150', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '1532', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'CreationDate': '2012-04-27T12:13:32.993', 'Id': '1525'},2012:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I prove that the language that the operator $A$ defines for regular language $L$ is a context free language.</p>\n\n<p>$A(L)= \\{ w_1w_2: |w_1|=|w_2|$ and $w_1, w_2^R \\in L \\}$, where $x^R$ is the reversed form of $x$. </p>\n\n<p>I understand that since $L$ is regular so does $L^R$.also on my way for a CFG I can reach $w_1$ by the CFG of $L$ concatenation with the one of $L^R$ for making $w_2$. so far I have a CFG, but what promises me that $|w_1|=|w_2|$? how can I generate a grammar that will also keep that in addition to the other conditions?</p>\n', 'ViewCount': '253', 'Title': 'Why does $A(L)= \\{ w_1w_2: |w_1|=|w_2|$ and $w_1, w_2^R \\in L \\}$ generate a context free language for regular $L$?', 'LastEditorUserId': '1183', 'LastActivityDate': '2012-05-03T07:50:41.343', 'LastEditDate': '2012-05-01T08:07:29.893', 'AnswerCount': '4', 'CommentCount': '0', 'AcceptedAnswerId': '1593', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1183', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'CreationDate': '2012-04-30T16:31:10.080', 'Id': '1592'},2013:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '727', 'Title': 'Relation between simple and regular grammars', 'LastEditDate': '2012-05-20T21:41:35.507', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1563', 'FavoriteCount': '1', 'Body': '<p>I am reading "An Introduction to Formal Languages and Automata" written by Peter Linz and after reading the first five chapters I face below problem with\nsimple and regular (especially right linear) grammars which are very similar to each other.</p>\n\n<p>What relation exists between these? What is the difference?\nCan you create (non-deterministic) finite automata for simple grammars (obviously without using a stack)?</p>\n', 'Tags': '<regular-languages><automata><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-21T21:29:04.513', 'CommentCount': '1', 'AcceptedAnswerId': '1968', 'CreationDate': '2012-05-20T21:03:35.607', 'Id': '1958'},2014:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the set of LL(*) grammars the same as the set of context-free grammars?</p>\n', 'ViewCount': '69', 'Title': 'Is the set of LL(*) grammars the same as the set of CFG grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-22T20:08:48.947', 'LastEditDate': '2012-05-22T19:17:30.513', 'AnswerCount': '2', 'CommentCount': '4', 'Score': '3', 'OwnerDisplayName': 'ninjagecko', 'PostTypeId': '1', 'OwnerUserId': '1030', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-04-10T04:04:27.197', 'Id': '2002'},2015:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '336', 'Title': 'Is there a context free, non-regular language $L$, for which $L^*$ is regular?', 'LastEditDate': '2012-05-25T21:02:11.603', 'AnswerCount': '1', 'Score': '6', 'OwnerDisplayName': 'ybz', 'PostTypeId': '1', 'OwnerUserId': '4832', 'Body': '<p>I know that there are non-regular languages, so that $L^*$ is regular, but all examples I can find are context-sensitive but not context free.</p>\n\n<p>In case there are none how do you prove it?</p>\n', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars>', 'LastEditorUserId': '31', 'LastActivityDate': '2012-05-25T21:02:11.603', 'CommentCount': '1', 'AcceptedAnswerId': '2083', 'CreationDate': '2012-01-08T15:33:04.230', 'Id': '2081'},2016:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My problem is how can I transform a <em>regular</em> grammar into a <em>linear</em> grammar?</p>\n\n<p>I know that a linear grammar has the form</p>\n\n<p>$\\begin{align} A &amp;\\to w_1Bw_2 \\\\ \n               A &amp;\\to w \\end{align}$</p>\n\n<p>where $A,B \\in N$ and $w,w_1,w_2 \\in \\Sigma^*$.</p>\n', 'ViewCount': '181', 'Title': 'Transform regular grammar in linear grammar', 'LastEditorUserId': '1594', 'LastActivityDate': '2012-05-30T07:27:09.727', 'LastEditDate': '2012-05-28T11:25:13.767', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1594', 'Tags': '<terminology><formal-grammars>', 'CreationDate': '2012-05-28T10:33:42.503', 'Id': '2123'},2017:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1182', 'Title': 'Context-free grammar for $\\{ a^n b^m a^{n+m} \\}$', 'LastEditDate': '2012-05-28T12:21:03.760', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '1', 'Body': "<p>I've got a problem with this task. I should declare a context-free grammar for this language:</p>\n\n<p>$\\qquad \\displaystyle L := \\{\\, a^nb^ma^{n+m} : n,m \\in \\mathbb{N}\\,\\}$</p>\n\n<p>My idea is: We need a start symbol, for example $S$. I know that I can generate the first $a$ and the last $a$ by $S \\to a a$. I don't know what is the next idea to solve this task.</p>\n", 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-05-28T15:46:56.970', 'CommentCount': '5', 'AcceptedAnswerId': '2129', 'CreationDate': '2012-05-28T11:53:46.383', 'Id': '2127'},2018:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>i have the following regular grammar :\n$$S \\rightarrow aS | cS | bQ_1$$\n$$Q_1 \\rightarrow bQ_2$$\n$$Q_2 \\rightarrow aQ_3 | cQ_3 | bQ_1$$\n$$Q_3 \\rightarrow aQ_4 | cQ_4$$ \n$$Q_4 \\rightarrow \\varepsilon$$</p>\n\n<p>The question is to transform that into a linear grammar with less nonterminals than the regular grammar and my idea was:\n$$S \\rightarrow aSa | cSc | aSc | cSa | bQ_1a | bQ_1c$$\n$$Q_1 \\rightarrow b$$</p>\n\n<p>and the rest i don't know. Could you help me to solve this problem?</p>\n", 'ViewCount': '60', 'Title': 'Transform in linear grammar', 'LastEditorUserId': '769', 'LastActivityDate': '2012-05-30T07:38:58.070', 'LastEditDate': '2012-05-29T23:07:50.047', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '2167', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1594', 'Tags': '<formal-grammars>', 'CreationDate': '2012-05-29T22:35:32.507', 'Id': '2164'},2019:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '110', 'Title': 'generation of linear grammar', 'LastEditDate': '2012-05-29T23:39:47.980', 'AnswerCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '1594', 'FavoriteCount': '1', 'Body': '<p>We have the following linear grammar:\n$$E \\rightarrow aO | bO | bbE | bb$$\n$$O \\rightarrow aE | bE | abaE | aba$$\nDoes the linear grammar generate a regular language, if yes why ?\nOur alphabet is $\\Sigma$ = {a,b} and our nonterminals are E and O. We begin by E.</p>\n', 'Tags': '<formal-languages><formal-grammars>', 'LastEditorUserId': '769', 'LastActivityDate': '2012-05-31T03:10:12.657', 'CommentCount': '6', 'AcceptedAnswerId': '2180', 'CreationDate': '2012-05-29T23:06:52.830', 'Id': '2166'},2020:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Given a <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar" rel="nofollow">parsing expression grammar</a> (PEG) grammar and the name of the start production, I would like to label each node with the set of characters that can follow it.  I would be happy with a good approximation that is conservative -- if a character can follow a node then it must appear in the follower set.</p>\n\n<p>The grammar is represented as a tree of named productions whose bodies contain nodes representing</p>\n\n<ol>\n<li>Character</li>\n<li>Concatenation</li>\n<li>Union</li>\n<li>Non-terminal references</li>\n</ol>\n\n<p>So given a grammar in ABNF style syntax:</p>\n\n<pre><code>A := B (\'a\' | \'b\');\nB := (\'c\' | \'d\') (B | ());\n</code></pre>\n\n<p>where adjacent nodes are concatenated, <code>|</code> indicates union, single quoted characters match the character they represent, and upper case names are non-terminals.</p>\n\n<p>If the grammar\'s start production is <code>A</code>, the annotated version might look like</p>\n\n<pre><code>A := \n  (\n    (B /* [ab] */)\n    (\n      (\'a\' /* eof */)\n    | \n      (\'b\' /* eof */)\n    /* eof */\n    )\n  /* eof */\n  );\n\nB :=\n  (\n    (\n      (\'c\' /* [abcd] */)\n      |\n      (\'d\' /* [abcd] */)\n    /* [abcd] */\n    )\n    (\n      (B /* [ab] */)\n      |\n      ( /* [ab] */)\n    /* [ab] */\n    )\n  );\n</code></pre>\n\n<p>I want this so that I can do some simplification on a PEG grammar.  Since order is important in unions in PEG grammars, I want to partition the members of unions based on which ones could accept the same character so that I can ignore order between partition elements.</p>\n\n<p>I\'m using OMeta\'s grow-the-seed scheme for handling direct left-recursion in PEG grammars, so I need something that handles that.  I expect that any scheme for handling scannerless CF grammars with order-independent unions that is conservative or correct would be conservative for my purposes.</p>\n\n<p>Pointers to algorithms or source code would be much appreciated.</p>\n', 'ViewCount': '87', 'Title': 'Computing follow sets conservatively for a PEG grammar', 'LastEditorUserId': '41', 'LastActivityDate': '2012-06-16T18:02:43.013', 'LastEditDate': '2012-06-09T18:04:51.030', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '2297', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '1298', 'Tags': '<formal-languages><reference-request><formal-grammars><parsers>', 'CreationDate': '2012-06-08T21:42:44.733', 'Id': '2292'},2021:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I look for information about grammars which can be described by a non-linear equation such as a quadratic equation:</p>\n\n<p>$\\qquad \\displaystyle G \\to G G a \\mid b$</p>\n\n<p>or</p>\n\n<p>$\\qquad \\displaystyle G \\to G G \\mid y G z \\mid z G y \\mid \\varepsilon$</p>\n\n<p>While there is lots of material about linear grammars, their connection with regular languages etc. "quadratic grammars" ( a term, which doesn\'t even seem to exist ) are only mentioned when an author presents some counterexamples for a parsing algorithm in order to show its limitations. </p>\n\n<p>Is there an autonomous treatment of grammars which can be described by general polynomial equations?</p>\n', 'ViewCount': '230', 'Title': 'Non-linear grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-07T19:01:19.597', 'LastEditDate': '2012-06-10T10:55:35.600', 'AnswerCount': '1', 'CommentCount': '9', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1811', 'Tags': '<reference-request><formal-grammars>', 'CreationDate': '2012-06-09T21:52:20.670', 'Id': '2303'},2022:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>My problem is how can I prove that a grammar is unambiguous?\nI have the following grammar:\n$$S\n\u2192 statement\n\u2223 \\mbox{if } expression \\mbox{ then } S\n\u2223 \\mbox{if } expression \\mbox{ then } S \\mbox{ else } S$$</p>\n\n<p>and make this to an unambiguous grammar, I think its correct:</p>\n\n<ul>\n<li><p>$ S \u2192 S_1 \u2223 S_2 $</p></li>\n<li><p>$S_1\n\u2192 \\mbox{if } expression \\mbox{ then } S\n\u2223 \\mbox{if } expression \\mbox{ then } S_2 \\mbox{ else } S_1$</p></li>\n<li><p>$S_2\n\u2192 \\mbox{if } expression \\mbox{ then } S_2 \\mbox{ else } S_2\n\u2223 statement$</p></li>\n</ul>\n\n<p>I know that a unambiguous grammar has one parse tree for every term.</p>\n', 'ViewCount': '3778', 'Title': 'How to prove that a grammar is unambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-09T13:50:57.277', 'LastEditDate': '2013-02-09T13:50:57.277', 'AnswerCount': '3', 'CommentCount': '0', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '1594', 'Tags': '<context-free><formal-grammars><proof-techniques><ambiguity>', 'CreationDate': '2012-06-10T17:15:32.787', 'FavoriteCount': '4', 'Id': '2320'},2023:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>In the following grammar that is used for math expressions(and other grammars) how do I know where should I place action symbols(@add, @mul, @pushID)? Is there a algorithm for it?</p>\n\n<pre>\nE -> TE`\nE'-> +T @add E'|\u03f5\nT -> FT`\nT'-> xF @mul T'|\u03f5\nF -> (E)|@pushID id\n</pre>\n\n<p>For example why @add is between <code>+T</code> and <code>E'</code> and not after <code>E'</code>?\nI searched for it's algorithm but didn't find anything useful.</p>\n", 'ViewCount': '81', 'Title': 'Where should we place action symbols in a grammar?', 'LastActivityDate': '2014-04-03T19:35:40.680', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '1820', 'Tags': '<formal-grammars><compilers>', 'CreationDate': '2012-06-10T19:12:23.783', 'Id': '2321'},2024:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In my class we used a Pushdown Automata to Context Free Grammar conversion algorithm that produces a lot extraneous states.</p>\n\n<p>For example, for two transitions, I am getting the following productions</p>\n\n<blockquote>\n  <p>$$\\begin{gather*}\n  \\delta(q_0,1,Z) = (q_0,XZ) \\\\\n  {}[q_0,Z,q_0] \\to 1[q_0,X,q_0][q_0,Z,q_0] \\\\\n  {}[q_0,Z,q_0] \\to 1[q_0,X,q_1][q_1,Z,q_0] \\\\\n  {}[q_0,Z,q_1] \\to 1[q_0,X,q_0][q_0,Z,q_1] \\\\\n  {}[q_0,Z,q_1] \\to 1[q_0,X,q_1][q_1,Z,q_1] \\\\\n\\end{gather*}$$</p>\n  \n  <p>$$ \\begin{gather*}\n  \\delta(q_1,0,Z) = (q_0,Z) \\\\\n  {}[q_1,Z,q_0 ] \\to 0[q_0,Z,q_0] \\\\\n  {}[q_1,Z,q_1 ] \\to 0[q_0,Z,q_1] \\\\\n\\end{gather*}$$</p>\n</blockquote>\n\n<p>How do I decide which state makes it into final production, and which one will be excluded ?</p>\n', 'ViewCount': '304', 'Title': 'Eliminating useless productions resulting from PDA to CFG converison', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-01T18:57:35.320', 'LastEditDate': '2012-06-27T12:51:15.767', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4834', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '1758', 'Tags': '<automata><formal-grammars><context-free><pushdown-automata>', 'CreationDate': '2012-06-26T20:28:39.280', 'Id': '2503'},2025:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '3538', 'Title': 'Left recursion and left factoring -- which one goes first?', 'LastEditDate': '2014-01-23T17:17:37.047', 'AnswerCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '2', 'Body': '<p>if I have a grammar having a production that contains both left recursion and left factoring like </p>\n\n<p>$\\qquad \\displaystyle F \\to FBa \\mid cDS \\mid c$ </p>\n\n<p>which one has priority, left recursion or left factoring?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:37.047', 'CommentCount': '3', 'AcceptedAnswerId': '2720', 'CreationDate': '2012-07-11T16:32:10.717', 'Id': '2696'},2026:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '880', 'Title': 'Are regular expressions $LR(k)$?', 'LastEditDate': '2012-07-18T00:50:56.043', 'AnswerCount': '2', 'Score': '10', 'OwnerDisplayName': 'Andrea Tucci', 'PostTypeId': '1', 'OwnerUserId': '2139', 'FavoriteCount': '1', 'Body': '<p>If I have a Type 3 Grammar, it can be represented on a pushdown automaton (without doing any operation on the stack) so I can represent regular expressions by using context free languages. But can I know if a type 3 grammar is $LR(1)$, $LL(1)$, $SLR(1)$, etc. without constructing any parse tables?</p>\n', 'Tags': '<formal-languages><regular-languages><formal-grammars><parsers><regular-expressions>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-18T00:50:56.043', 'CommentCount': '0', 'AcceptedAnswerId': '2715', 'CreationDate': '2012-07-11T12:26:59.840', 'Id': '2713'},2027:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '903', 'Title': 'Context-free grammar to a pushdown automaton', 'LastEditDate': '2012-07-29T14:15:47.920', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2125', 'FavoriteCount': '1', 'Body': "<p>I'm trying to convert a context free grammar to a pushdown automaton (PDA); I'm not sure how I'm gonna get an answer or show you my progress as it's a diagram... Anyway this is the last problem I have on a homework that's due later today, so I'd appreciate some kind of help, even if it's just an explanation of the correct answers diagram. I need a PDA corresponding to this CFG:</p>\n\n<p>$$S \\rightarrow aSa | bSb | B$$\n$$B \\rightarrow bB | \\epsilon$$</p>\n\n<p>I know it will have to push X every time 'a' is read before a 'b', and pop X every time 'a' is read after a 'b'. But I'm not sure how to arrange the PDA in order to tell which a's came after b's. Also, I'm unsure of how to deal with the b's in terms of the stack, as there can be as many in the middle of the string as you want. Help appreciated.</p>\n\n<p>Thanks, Pachun</p>\n", 'Tags': '<formal-grammars><context-free><pushdown-automata>', 'LastEditorUserId': '472', 'LastActivityDate': '2012-07-29T14:15:47.920', 'CommentCount': '2', 'AcceptedAnswerId': '2736', 'CreationDate': '2012-07-13T18:08:44.950', 'Id': '2735'},2028:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Please note that I am aware the undecidability of the conversion of context-free grammer to regular grammer. But given the non-embedding property of the input context-free grammer, is there any algorithm to convert it to regular grammer, or DFA directly?</p>\n', 'ViewCount': '216', 'Title': 'How to convert a non-embedding context free grammer to regular grammer?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-15T07:28:33.087', 'LastEditDate': '2012-07-18T01:57:35.887', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2775', 'Score': '2', 'OwnerDisplayName': 'dalibocai', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><context-free>', 'CreationDate': '2012-01-20T15:38:28.743', 'Id': '2774'},2029:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/LR_parser#LR_and_Other_Kinds_of_Parsers">the Wikipedia article</a>, the L in $LR(k)$ means "left-to-right scan", and the "R" means "rightmost derivation."  However, in <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf">Knuth\'s original paper on $LR(k)$ grammars</a>, he defines $LR(k)$ (on page 610) as a language that is "translatable from left to right with bound $k$."</p>\n\n<p>I am guessing that this new terminology was chosen to complement $LL(k)$ parsing\'s "left-to-right scan, leftmost derivation."  That said, I don\'t know when the terminology changed meaning.</p>\n\n<p>Does anyone know where the newer acronym for $LR(k)$ comes from?</p>\n', 'ViewCount': '115', 'Title': 'When did $LR(k)$ acquire the meaning "left-to-right scan, rightmost derivation?"', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-17T22:09:46.040', 'LastEditDate': '2012-07-17T22:09:46.040', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><reference-request><terminology><formal-grammars><parsers>', 'CreationDate': '2012-07-17T19:10:32.620', 'FavoriteCount': '1', 'Id': '2791'},2030:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1273', 'Title': 'Removing Left Recursion from Context-Free Grammars - Ordering of nonterminals', 'LastEditDate': '2014-01-23T17:17:28.390', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': 'clebert', 'PostTypeId': '1', 'FavoriteCount': '1', 'Body': u'<p>I have recently implemented the Paull\'s algorithm for removing left-recursion from context-free grammars:</p>\n\n<blockquote>\n  <p>Assign an ordering $A_1, \\dots, A_n$ to the nonterminals of the grammar.</p>\n  \n  <p>for $i := 1$ to $n$ do begin<br>\n  $\\quad$ for $j:=1$ to $i-1$ do begin<br>\n  $\\quad\\quad$ for each production of the form $A_i \\to A_j\\alpha$ do begin<br>\n  $\\quad\\quad\\quad$ remove $A_i \\to A_j\\alpha$ from the grammar<br>\n  $\\quad\\quad\\quad$ for each production of the form $A_j \\to \\beta$ do begin<br>\n  $\\quad\\quad\\quad\\quad$ add $A_i \\to \\beta\\alpha$ to the grammar<br>\n  $\\quad\\quad\\quad$ end<br>\n  $\\quad\\quad$ end<br>\n  $\\quad$ end<br>\n  $\\quad$ transform the $A_i$-productions to eliminate direct left recursion<br>\n  end</p>\n</blockquote>\n\n<p>According to <a href="http://research.microsoft.com/pubs/68869/naacl2k-proc-rev.pdf" rel="nofollow" title="Removing Left Recursion from Context-Free Grammars">this document</a>, the efficiency of the algorithm crucially depends on the ordering of the nonterminals chosen in the beginning; the paper discusses this issue in detail and suggest optimisations.</p>\n\n<p>Some notation:</p>\n\n<blockquote>\n  <p>We will say that a symbol $X$ is a <em>direct left corner</em> of\n  a nonterminal $A$, if there is an $A$-production with $X$ as the left-most symbol on the right-hand side. We define the <em>left-corner relation</em> to be the reflexive transitive closure of the direct-left-corner relation, and we define the <em>proper-left-corner relation</em> to be the transitive closure of\n  the direct-left-corner relation. A nonterminal is <em>left recursive</em> if it is a proper left corner of itself; a nonterminal is <em>directly left recursive</em> if it is a direct left corner of itself; and a nonterminal is <em>indirectly left recursive</em> if it is left recursive, but not directly left recursive.</p>\n</blockquote>\n\n<p>Here is what the authors propose:</p>\n\n<blockquote>\n  <p>In the inner loop of Paull\u2019s algorithm, for nonterminals $A_i$ and $A_j$, such that $i &gt; j$ and $A_j$ is a direct left corner of $A_i$, we replace all occurrences of $A_j$ as a direct left corner of $A_i$ with all possible expansions of $A_j$.</p>\n  \n  <p>This only contributes to elimination of left recursion from the grammar if $A_i$ is a left-recursive nonterminal, and $A_j$ lies on a path that makes $A_i$ left recursive; that is, if $A_i$ is a left corner of $A_j$ (in addition to $A_j$ being a left corner of $A_i$).</p>\n  \n  <p>We could eliminate replacements that are useless in removing left recursion if we could order the nonterminals of the grammar so that, if $i &gt; j$ and $A_j$ is a direct left corner of $A_i$, then $A_i$ is also a left corner of $A_j$.</p>\n  \n  <p>We can achieve this by ordering the nonterminals in decreasing order of the number of distinct left corners they have.</p>\n  \n  <p>Since the left-corner relation is transitive, if C is a direct left corner of B, every left corner of C is also a left corner of B.</p>\n  \n  <p>In addition, since we defined the left-corner relation to be reflexive, B is a left corner of itself.</p>\n  \n  <p>Hence, if C is a direct left corner of B, it must follow B in decreasing order of number of distinct left corners, unless B is a left corner of C.</p>\n</blockquote>\n\n<p>All I want is to know how to order the nonterminals in the beginning, but I don\'t get it from the paper. Can someone explain it in a simpler way? Pseudocode would help me to understand it better.</p>\n', 'Tags': '<algorithms><context-free><formal-grammars><efficiency><left-recursion>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:28.390', 'CommentCount': '0', 'AcceptedAnswerId': '2793', 'CreationDate': '2012-05-23T12:50:45.647', 'Id': '2792'},2031:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the grammar: </p>\n\n<p>$\\qquad \\begin{align}\n S &amp;\\to S = P \\mid S \\neq P \\mid P  \\\\\n P &amp;\\to NUM\n\\end{align}$</p>\n\n<p>This grammar suffers from left recursion. To eliminate left recursion, I got: </p>\n\n<p>$\\qquad \\begin{align}\n S &amp;\\to PS' \\\\\n S' &amp;\\to\\, = PS' \\mid\\, \\neq PS' \\mid \\varepsilon \\\\\n P &amp;\\to NUM\n\\end{align}$</p>\n\n<p>However when constructing the LL(1) parsing table, it turns out the grammar is ambiguous. Is there a way to disambiguate the grammar without changing the generated language, or did I make a mistake somewhere?</p>\n\n<p>This is my work so far: </p>\n\n<pre><code>Non-terminal Nullable First            Follow\nS            False    NUM              $\n    S'           True     !=, ==, epsilon  $\nP            False    NUM              $, ==, !=\n\nParse Table\n     !=       ==    NUM      $\nS                   -&gt;PS'\nS'  -&gt;!=PS'  -&gt;==PS'        -&gt;epsilon\nP                   -&gt;NUM\n</code></pre>\n", 'ViewCount': '270', 'Title': 'Is this grammar ambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-16T22:57:05.150', 'LastEditDate': '2012-07-17T22:44:58.257', 'AnswerCount': '1', 'CommentCount': '8', 'Score': '0', 'OwnerDisplayName': 'barq', 'PostTypeId': '1', 'Tags': '<formal-grammars><parsers><ambiguity>', 'CreationDate': '2012-05-17T22:56:12.917', 'Id': '2794'},2032:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How would you prove that the following language is not context-free?</p>\n\n<p>$$ L= \\{a^n b^m |\\, gcd(n,m)=1 \\}$$</p>\n\n<p>I suspect the solution uses the pumping lemma, but I'm not sure how to apply it.</p>\n", 'ViewCount': '500', 'Title': 'Proof that a language involving $gcd$ is not context-free', 'LastEditorUserId': '41', 'LastActivityDate': '2012-07-18T10:15:27.367', 'LastEditDate': '2012-07-17T22:06:59.037', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'OwnerDisplayName': 'Eren Bellisoy', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-04-05T19:17:28.377', 'Id': '2795'},2033:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I had written a <a href="https://github.com/shabbyX/shCompiler" rel="nofollow">compiler compiler</a> a few years ago and I\'m now cleaning it up, improving it, and turning it into C.</p>\n\n<p>I came across a terminology problem however that I remember in the past I couldn\'t solve it either.</p>\n\n<p>Imagine an LL(k) stack. In this stack, you may have terminals, that are expected to be matched with the next token, or non-terminals that would expand based on the next token. In either case, there is a string in the stack.</p>\n\n<p>The word I am looking for, is a term that means either a terminal or non-terminal. <a href="http://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols" rel="nofollow">Wikipedia</a> was of no help.</p>\n\n<p>To clarify a bit more, imagine a grammar with $t = \\{a \\mid a \\text{ terminal}\\}$ and $T = \\{A \\mid A \\text{ non-terminal}\\}$. If you have a set $X = \\{x | x \\in t \\vee x \\in T\\}$, how would you refer to an element of $X$? "Grammar symbol"? "Grammar element"? "Terminal or non-terminal symbol"?</p>\n\n<p>I am in particular looking for a name as short and to the point as possible, since this will end up becoming a variable name!</p>\n', 'ViewCount': '153', 'Title': 'How to call something that can be either a terminal or a nonterminal?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-07-23T09:10:30.030', 'LastEditDate': '2012-07-23T09:06:22.513', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '2870', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '944', 'Tags': '<terminology><formal-grammars><compilers>', 'CreationDate': '2012-07-23T08:50:15.063', 'Id': '2868'},2034:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In <a href="http://classes.engr.oregonstate.edu/eecs/winter2012/cs480/assignments/Knuth-1965-TranslationofLanguages.pdf" rel="nofollow">Knuth\'s original paper on $LR(k)$ grammars</a>, he proved that the decision problem "Given a CFG $G$, is there a $k$ such that $G$ is an $LR(k)$ grammar?" is undecidable.</p>\n\n<p>Is there a similar result showing that it is undecidable whether a given CFG is an $LL(k)$ grammar for some choice of $k$?  Or is this problem known to be decidable?</p>\n', 'ViewCount': '175', 'Title': 'Determining whether a CFG is $LL(k)$ for any $k$?', 'LastEditorUserId': '2131', 'LastActivityDate': '2012-12-10T22:55:35.893', 'LastEditDate': '2012-12-10T22:55:35.893', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '4928', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<formal-languages><computability><formal-grammars><context-free><parsing>', 'CreationDate': '2012-07-23T23:15:59.023', 'Id': '2889'},2035:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider the context free grammar:</p>\n\n<p>$\\qquad \\begin{align}\n    \\mathrm{bill} &amp;\\to \\mathrm{items}\\ \\mathrm{total}\\ \\mathrm{vat} \\\\\n    \\mathrm{items} &amp;\\to \\mathrm{item} \\mid \\mathrm{item}\\ \\mathrm{items} \\\\\n    \\mathrm{item} &amp;\\to name\\ \\mathrm{price} \\mid name\\ \\mathrm{quantity}\\ \\mathrm{price} \\\\\n    \\mathrm{quantity} &amp;\\to integer \\\\\n    \\mathrm{price} &amp;\\to integer \\\\\n    \\mathrm{total} &amp;\\to integer \\mid TOTAL\\ \\mathrm{price}  \\\\\n    \\mathrm{vat} &amp;\\to VAT\\ \\mathrm{price}  \n\\end{align}$</p>\n\n<p>How do I factor the grammar?</p>\n\n<p>This was asked in a past exam, and I don't know how to get started.</p>\n\n<p>Also, if you have any links that could help me understand this more it would be much appreciated!</p>\n", 'ViewCount': '126', 'Title': 'Factor a grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-06T11:26:18.517', 'LastEditDate': '2012-08-01T22:11:53.953', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'OwnerDisplayName': 'jamie jenkins', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><context-free>', 'CreationDate': '2012-08-01T20:13:21.343', 'FavoriteCount': '1', 'Id': '2989'},2036:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In the article <a href="http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm" rel="nofollow">Parsing Expressions by Recursive Descent by Theodore Norvell (1999)</a> the author starts with the following grammar for arithmetic expressions:</p>\n\n<pre><code>E --&gt; E "+" E | E "-" E | "-" E | E "*" E | E "/" E | E "^" E | "(" E ")" | v\n</code></pre>\n\n<p>which is quite bad, because it\'s ambiguous and left-recursive. So he starts from removing the left recursion from it, and his result is as such:</p>\n\n<pre><code>E --&gt; P {B P}\nP --&gt; v | "(" E ")" | U P\nB --&gt; "+" | "-" | "*" | "/" | "^"\nU --&gt; "-"\n</code></pre>\n\n<p>But I can\'t figure out how did he get to this result. When I try to remove the left recursion myself, I\'m doing it the following way:</p>\n\n<ol>\n<li><p>Firs, I group together the productions which doesn\'t have left recursion in one group, and other (left-recursive) in another group:</p>\n\n<pre><code>E --> E "+" E | E "-" E | E "*" E | E "/" E | E "^" E     // L-recursive\nE --> v | "(" E ")" | "-" E</code></pre></li>\n<li><p>Next, I name them and factor for easier manipulations:</p>\n\n<pre><code>E --> E B E  // L-recursive; B stands for "Binary operator"\nE --> P  // not L-recursive; P stands for "Primary Expression"\nP --> v | "(" E ")" | U E   // U stands for "Unary operator"\nB --> "+" | "-" | "*" | "/" | "^"\nP --> "-"</code></pre>\n\n<p>Now I need to deal only with the first two productions, which are now easier to deal with.</p></li>\n<li><p>I rewrite those first two productions by starting from the non-L-recursive production (which is simply <code>P</code>, the Primary expression) and following it by the optional Tail <code>T</code>, which I define as the rest of the original production less the first left-recursive nonterminal (that is, just <code>B E</code>) followed by the Tail <code>T</code>, <strong>or</strong> which could be empty:</p>\n\n<pre><code>E --> P T\nT --> B E T |</code></pre>\n\n<p>(note the empty alternative for the tail).</p></li>\n<li><p>These two productions I can now rewrite in EBNF like this:</p>\n\n<pre><code>E --> P {B E}</code></pre>\n\n<p>which is nearly what the author get, but I have <code>E</code> instead of <code>P</code> there inside the zero-or-more repetition pattern (the Tail). The other productions I get quite the same as he have got:</p>\n\n<p><pre><code>P --> v | "(" E ")" | U E\nB -> "+" | "-" | "*" | "/" | "^"\nU -> "-"</pre></code></p>\n\n<p>but here too I have <code>E</code> instead of <code>P</code> in the first production for <code>P</code>.</p></li>\n</ol>\n\n<p>So, my question is: What am I missing? What algebraic transformation on the syntax I need to proceed now to get the same exact form as the autor gets? I tried substitutions for <code>E</code>, but it only leads me into loops. I suspect that I need somehow to substitute <code>P</code> for <code>E</code>, but I don\'t know any legal transformation to justify it. Maybe you know what\'s the last missing step?</p>\n', 'ViewCount': '343', 'Title': 'Arithmetic expressions grammar transformation', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:22:47.697', 'LastEditDate': '2014-01-23T17:22:47.697', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '7', 'OwnerDisplayName': 'SasQ', 'PostTypeId': '1', 'OwnerUserId': '2381', 'Tags': '<formal-languages><context-free><formal-grammars><left-recursion>', 'CreationDate': '2012-08-05T20:59:01.593', 'Id': '3053'},2037:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<pre><code>S --&gt; Ta | b | Sc\nT --&gt; Tc | \u03bb\n</code></pre>\n\n<p>This isn't an LL grammar but I need it to be so I can do a parse table. The problem is that no matter how much I try I never manage to do make it an LL grammar. Can someone please help by making it a LL grammar? It isn't that big and I'm very confused.</p>\n", 'ViewCount': '88', 'Title': "What's wrong with this LL grammar? (very short)", 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-07T18:46:26.553', 'LastEditDate': '2012-08-14T14:07:17.107', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '1', 'OwnerDisplayName': 'Pablo Miranda', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing>', 'CreationDate': '2012-08-14T05:23:10.337', 'Id': '3172'},2038:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have been taking a compiler course of Stanford on coursera. I have a slight misunderstanding on the parsing table of the following grammar:</p>\n\n<p>S -> Sa | b</p>\n\n<p>According to the professor parsing table looks like this:</p>\n\n<ul>\n<li><p>If the leftmost nonterminal is S and the input is 'a', the production is nothing.</p></li>\n<li><p>If the leftmost nonterminal is S and the input is 'b', the production is both <code>Sa</code> and <code>b</code>.</p></li>\n</ul>\n\n<p>So if input is just <code>b</code>, then it is correct, it will go directly to production <code>b</code>.\nBut how will it go to production <code>Sa</code> for input <code>b</code>?</p>\n", 'ViewCount': '321', 'Title': 'LL(1) parsing table of left-recursive grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:11.390', 'LastEditDate': '2014-01-23T17:17:11.390', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'Batman', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars><parsing><left-recursion>', 'CreationDate': '2012-08-14T07:11:18.640', 'Id': '3173'},2039:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Intuitively, every derivation in a context-free grammar corresponds to a parse-tree and vise versa. </p>\n\n<p>Is this intuition correct? If so how can I formalize and prove such a thing?</p>\n', 'ViewCount': '179', 'Title': 'Proof of equivalence of parse-trees and derivations', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-01T19:06:31.240', 'LastEditDate': '2012-10-01T19:06:31.240', 'AnswerCount': '1', 'CommentCount': '9', 'AcceptedAnswerId': '4833', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2499', 'Tags': '<formal-grammars><context-free>', 'CreationDate': '2012-08-18T15:38:57.743', 'Id': '3250'},2040:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I got one grammar:</p>\n\n<pre><code>re2: re1 $\n\nre1: expr == expr | expr != expr | expr &lt; expr | expr &lt;= expr | expr &gt;= expr | expr &gt; expr | expr\n\nexpr: expr + term | expr - term | term\n\nterm: term * factor | term / factor | factor\n\nfactor: (expr) | num | id\n\nnum: (0|1|2|3|4|5|6|7|8|9)num | \u03b5\n\nid: (a|b|....|z|A|B|....|Z|)id | \u03b5\n\nHere are the FOLLOW sets:\n\nFOLLOW(r2) = {}\nFOLLOW(r1) = {$}\nFOLLOW(expr) = {=,!,&lt;,&gt;,+,-,)}\nFOLLOW(term) = FOLLOW(factor) = FOLLOW (id) = FOLLOW (num) = {=,!,&lt;,&gt;,+,-,),*,/}\n</code></pre>\n\n<p>Now this grammar clearly got reduce-reduce conflict from\nnum: \u03b5 and id: \u03b5 because FOLLOW(num) \u2229 FOLLOW(id) != empty set</p>\n\n<p>Now let's say I fix the grammar by  doing the following (I assume it is mistake in the grammar because (\u03b5 == \u03b5) makes no sense):</p>\n\n<pre><code>num: (0|1|2|3|4|5|6|7|8|9)num | (0|1|2|3|4|5|6|7|8|9)\nid: (a|b|....|z|A|B|....|Z|)id | (a|b|....|z|A|B|....|Z|) \n</code></pre>\n\n<p>Now my question is, is this grammar SLR i.e can it be parsed by SLR parser? I know by building the parser I can find out but on exam I can not make the whole parser and then determine (I would lose lot of time).</p>\n", 'ViewCount': '344', 'Title': 'Ambiguous grammar? Could the grammar be parsed by SLR parser?', 'LastEditorUserId': '41', 'LastActivityDate': '2012-10-05T22:08:40.713', 'LastEditDate': '2012-08-25T04:03:25.147', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'OwnerDisplayName': 'user1377320', 'PostTypeId': '1', 'OwnerUserId': '2634', 'Tags': '<formal-languages><formal-grammars><compilers><parsing>', 'CreationDate': '2012-08-24T22:55:28.367', 'Id': '3325'},2041:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I tried to find a simple example for a language that is not parseable with an LL(1) parser. I finally found this language.</p>\n\n<p>$$L=\\{a^nb^m|n,m\\in\\mathbb N\\land n\\ge m\\}$$</p>\n\n<p>Is my hypothesis true or is this language parseable with an LL(1) parser?</p>\n\n<p>One can use this simple grammar to describe $L$ (of course it is isn't LL(1) parseable):</p>\n\n<pre><code>S -&gt; \u03b5\nS -&gt; A\nA -&gt; aA\nA -&gt; aAb\nA -&gt; a\nA -&gt; ab\n</code></pre>\n", 'ViewCount': '604', 'Title': 'Is this language LL(1) parseable?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-08-29T09:51:17.570', 'LastEditDate': '2012-08-28T23:14:02.987', 'AnswerCount': '3', 'CommentCount': '2', 'AcceptedAnswerId': '3359', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<formal-languages><formal-grammars><context-free><parsers>', 'CreationDate': '2012-08-28T12:40:52.453', 'Id': '3350'},2042:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>This is homework and I'm looking for a push in the right direction. Proofs were never something I was properly taught, so now they're kind of a weak point.</p>\n\n<p>Here's the problem:</p>\n\n<blockquote>\n  <p>The following grammar generates numbers in binary notation ($C$ is the\n  start symbol):</p>\n  \n  <p>$\\qquad \\begin{align}C &amp;\\to C 0 \\mid A 1 \\mid 0 \\\\\n                       A &amp;\\to B 0 \\mid C 1 \\mid 1 \\\\\n                       B &amp;\\to A 0 \\mid B 1\n          \\end{align}$</p>\n  \n  <ol>\n  <li><p>Prove that the alternating sums of the digits of the generated\n  numbers are multiples of $3$. The alternating sum of $w=w_0\\dots w_n$ is defined as $\\sum_{i=0}^n (-1)^i \\cdot w_i$. As an example, $C$\n  generates $1001$ via $C \\Rightarrow A1 \\Rightarrow B01 \\Rightarrow A001 \\Rightarrow 1001$ with alternating sum of $0$;\n  clearly, $0$ is a multiple of $3$.</p></li>\n  <li><p>Prove that all such numbers (i.e.,\n  numbers whose alternating sum is a multiple of 3) are generated by the\n  grammar.</p></li>\n  </ol>\n</blockquote>\n\n<p>I'm thinking I need to show that the grammar can only generate strings which are made up of repeated subsequences of digits which always add up to 0, 3, or -3. But I'm not sure how to show that it can only generate those three subsequences.</p>\n\n<p>I also have worked out these thoughts:</p>\n\n<ul>\n<li><p>Consider that any even number of consecutive 1s is irrelevant, as they cancel each other out.</p></li>\n<li><p>Consider that all zeros are in of themselves irrelevant, as they add nothing.</p></li>\n<li><p>Consider then that the only relevant pattern is that of alternating 1s and zeros, and where this pattern starts and ends.</p></li>\n</ul>\n", 'ViewCount': '795', 'Title': 'Proving a grammar only generates words whose alternating digit sums is are multiples of three', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-03T11:59:01.517', 'LastEditDate': '2012-09-03T07:35:35.117', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2716', 'Tags': '<formal-languages><regular-languages><formal-grammars><proof-techniques>', 'CreationDate': '2012-09-02T20:45:42.667', 'Id': '3406'},2043:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I just started reading "Parsing Techniques, A Practical Guide", Second Edition, by Dick Grune and Ceriel J.H. Jacobs. </p>\n\n<p>On page 12, the authors start describing a set of rules that can be used to generate the set of all enumerations of names of the type "tom, dick and harry": the rules allow single names (e.g. "tom") as well as repetitions ("tom, harry, dick, dick and harry"); multiple names in an enumeration are separated by commas except the last two names which are separated by "and", so the following aren\'t valid: ("tom, harry, dick") or ("harry and tom and dick"). </p>\n\n<p>A few pages later, and after having defined some more terms and formalisms, the authors come up with the following replacement rules (parse structure grammar) to generate the sentences of the desired type:</p>\n\n<pre><code>0. Name -&gt; tom | dick | harry\n1. Sentence-&gt; Name | List End\n2. List -&gt; Name | Name, List\n3. , Name End -&gt; and Name\n</code></pre>\n\n<p>In the above, <strong>Sentence</strong> is the start symbol.</p>\n\n<p>However it seems to me that these rules can generate incorrect sentences: if we replace <strong>Sentence</strong> by <strong>List End</strong> and <strong>List</strong> by <strong>Name</strong> we end up with <strong>Name End</strong> for which no replacement rule is defined.</p>\n\n<p>It seems to me that the 2nd line in the rules above, if replaced by</p>\n\n<pre><code>Sentence -&gt; Name | Name, List End\n</code></pre>\n\n<p>would fix this problem. </p>\n\n<p>Am I correct that the authors have made an oversight, and is my modification correct? Or have I misunderstood something?</p>\n\n<p>I don\'t have a CS background and this is the first time I\'m reading about parsing, so please keep that in consideration in your replies. Thanks!</p>\n', 'ViewCount': '254', 'Title': 'Is this phrase structure grammar from my textbook correct?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-05T12:46:51.640', 'LastEditDate': '2012-09-05T07:47:54.720', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '3428', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2736', 'Tags': '<formal-languages><formal-grammars><parsing>', 'CreationDate': '2012-09-05T03:34:36.257', 'Id': '3427'},2044:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Lets say I have given following grammar which generates arithmetic expressions in reverse polish notation:</p>\n\n<p>$G=({E},{a,+,*},P,E)$<br>\n$P={ E \\rightarrow EE+ | EE* | a }$  </p>\n\n<p>I know this grammar is unambiguous. </p>\n\n<p>What I do not understand is how I can prove this.</p>\n\n<p>I already searched a lot to in google, etc. but everyone only says, that reverse polish notation are unambiguous, but not WHY.</p>\n\n<p>Can you give me any hints?</p>\n', 'ViewCount': '239', 'Title': 'Unambiguity of Reverse Polish Notation', 'LastActivityDate': '2012-09-07T05:27:26.807', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '3459', 'Score': '1', 'OwnerDisplayName': 'xaedes', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-06-26T16:04:04.717', 'FavoriteCount': '2', 'Id': '3458'},2045:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I try to teach myself the usage of bison. The manpage bison(1) says about bison:</p>\n\n<blockquote>\n  <p>Generate a deterministic LR or generalized LR (GLR) parser employing LALR(1), IELR(1), or canonical LR(1) parser tables.</p>\n</blockquote>\n\n<p>What is an IELR-parser? All relevant articles I found on the world wide web are paywalled.</p>\n', 'ViewCount': '372', 'Title': 'What is an IELR(1)-parser?', 'LastEditorUserId': '3094', 'LastActivityDate': '2013-06-27T08:08:03.550', 'LastEditDate': '2012-12-05T12:26:17.283', 'AnswerCount': '1', 'CommentCount': '5', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<formal-languages><terminology><formal-grammars><parsers>', 'CreationDate': '2012-09-07T15:07:37.423', 'FavoriteCount': '1', 'Id': '3461'},2046:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Say I have an LR grammar <em>G</em> and a string <em>w</em>. I know that I can check if <em>w</em> is in the language of <em>G</em> in linear time. But what if <em>w</em> itself is not in the language of <em>G</em>, but I want to find all substrings of <em>w</em> that are in the language of <em>G</em>? And can I get parse trees for those substrings? What would be the time complexity for these things?</p>\n', 'ViewCount': '91', 'Title': 'Given an LR grammar G and a string w, is it possible to quickly find all substrings in w that are in L(G)?', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-22T18:34:46.167', 'LastEditDate': '2012-09-12T12:15:54.237', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'OwnerDisplayName': 'oskarkv', 'PostTypeId': '1', 'Tags': '<formal-grammars><parsing><substrings>', 'CreationDate': '2012-08-08T15:52:55.883', 'Id': '3512'},2047:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m currently in a class on Computability and we just finished looking at formal grammars before moving onto finite automata. We were given an several examples of a formal grammar, and one stuck out in particular:</p>\n\n<pre><code>V: { S, A, B, C }\nT: { a, b, c }\nP: {\n    S -&gt; aA | \u03bb | ASA\n   AA -&gt; aA | a\n}\n</code></pre>\n\n<p>My professor described the result as "any number of <code>a</code>s". This makes sense if you never use the first <code>S</code> or <code>AA</code> rule; you can simply replace <code>S</code> with <code>ASA</code> as many times as you like, then replace each <code>S</code> with <code>\u03bb</code> (getting some even-length string of <code>A</code>s); you can then replace all <code>AA</code>s with <code>a</code>s.</p>\n\n<p>But what if I picked the first rule? So, I start with <code>S</code>, then replace <code>S</code> with <code>aA</code>. I now have a string that contains neither <code>S</code>, nor <code>AA</code>, so the final terminal string should be <code>aA</code>. (This could also be done with <code>S -&gt; ASA -&gt; AA -&gt; aA</code>.)</p>\n\n<p>Is this allowed? If so, what is the result called? Since it still contains a variable, is this just a rejected/invalid result?</p>\n\n<p><em>NB: I did ask my professor about this. He explicitly said to "ignore the first rules of each \'S\' and \'AA\'", and could not give me any further explanation on why to do this.</em></p>\n', 'ViewCount': '127', 'Title': 'What if a formal grammar cannot be terminated?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-09-15T14:15:46.140', 'LastEditDate': '2012-09-15T14:15:46.140', 'AnswerCount': '2', 'CommentCount': '4', 'AcceptedAnswerId': '3543', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '2827', 'Tags': '<formal-grammars>', 'CreationDate': '2012-09-14T18:15:25.383', 'Id': '3542'},2048:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Are there any grammar classes which are true subsets of Chomsky level 2 but not equal to level 1?</p>\n', 'ViewCount': '166', 'Title': 'Are there grammar classes between Chomsky level 1 and 2?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-28T22:32:01.063', 'LastEditDate': '2012-09-18T22:05:21.370', 'AnswerCount': '1', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'crudolf', 'PostTypeId': '1', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-09-17T08:03:56.280', 'Id': '4607'},2049:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In helping someone understand phrase generators for use with testing grammars, think compiler test cases, I noted that I have never found a phrase generator that is knowledgeable of the grammar, and is deterministic. The phrase generators I am talking about rely on the grammar of the language as input so that the user does not have to recreate the rules for the grammar into a format acceptable for the tool. The tool must accept a BNF grammar; I don\'t mind if the grammar has to be factored some for the tool before input. Tools that rely on a seed or generate a random seed are what I want to avoid.</p>\n\n<p>I am aware that one can use PROLOG to generate a parser and then run a query that outputs a set of results that are phrases used for testing. I also know that it is not uncommon for these result sets to have 10**15 answers for basic cases of a grammar like C++.</p>\n\n<p>Does anyone know of such tools? They can be commercial or open-source as I don\'t plan on using it, I have my own, I just want to verify my knowledge. </p>\n\n<p>EDIT</p>\n\n<p>The tool must encompass sematic knowledge of the compiler. In other words the phrases must be able to be compiled by a compiler, not just pass the syntactic rules.</p>\n\n<p>EDIT</p>\n\n<p>I agree that the comments and answers regarding deterministic are correct and I my use of the word here is not correct.</p>\n\n<p>What I am looking for is a tool that not only takes in a BNF grammar and can use it "as is" which would mean for a grammar like C++ a basic result sets with 10**30 items. That is not an accurate number but a realistic one based on a phrase generator I have that can report the number of results before generating the results. Since that size of a result set is impractical, I have given the tool the ability to enhance the grammar with constraints, thinking tree pruning. This allows one to generate phrases for one particular branch of the grammar, and also prune and limit the sub-braches and number of recursion over those branches. Even with the constraints each result item is a valid C++ file for use as input to a C++ compiler.</p>\n\n<p>I have a proof of concept of this already, but the difference between a proof of concept and useful tool is a lot of work. So while a seed can be reused and create deterministic results, it does not allow the user to determine the conditions.</p>\n', 'ViewCount': '113', 'Title': "Phrase generators for use with testing grammars that don't use a seed", 'LastEditorUserId': '268', 'LastActivityDate': '2012-09-24T13:14:33.833', 'LastEditDate': '2012-09-24T13:14:33.833', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '4698', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '268', 'Tags': '<reference-request><formal-grammars><context-free><parsing><software-testing>', 'CreationDate': '2012-09-23T13:37:55.380', 'Id': '4692'},2050:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '2372', 'Title': 'Understanding LEADING and TRAILING operations of an operator precedence grammar', 'LastEditDate': '2012-09-24T18:30:27.660', 'AnswerCount': '2', 'Score': '3', 'OwnerDisplayName': 'Likhit', 'PostTypeId': '1', 'OwnerUserId': '2961', 'FavoriteCount': '2', 'Body': "<p>I want to understand what the <code>LEADING</code> and <code>TRAILING</code> of non-terminal in an operator precedence grammar physically mean.</p>\n\n<p>I am confused by the various definitions I have read on them. <br>\nI understand that the <code>LEADING</code> of a non-terminal is the first terminal which can be present in it's derivation. <br>\nOn the other hand, the <code>TRAILING</code> of a non-terminal is the last terminal which can be present in it's derivation. <br><br>\nIn the following example: <br></p>\n\n<pre><code>E   -&gt;  E   +   T      -- I\nE   -&gt;  T              -- II\nT   -&gt;  T   *   F      -- III\nT   -&gt;  F              -- IV\nF   -&gt;  (   E   )      -- V\nF   -&gt;  id             -- VI\n</code></pre>\n\n<p>By my understanding,</p>\n\n<pre><code>LEADING(E) = { +, *, (, id }\nLEADING(T) = { *, (, id }\nLEADING(F) = { (, id }\n</code></pre>\n\n<p>This turns out fine, but my problem is in the TRAILING.</p>\n\n<pre><code>TRAILING(F) = { id, ) }\nTRAILING(T) = TRAILING(F) = { id, ) }          -- (1)\nTRAILING(E) = TRAILING(T) = { id, ) }          -- (2)\n</code></pre>\n\n<p>Reason for <code>(2)</code> is that according to productions <code>I</code> and <code>II</code>, the last terminal of the derivation of <code>E</code> will be last terminals in the derivation of <code>T</code>.\nHence, <code>TRAILING(E) = TRAILING(T)</code>.<br>\nSimilarly, <code>TRAILING(T) = TRAILING(F)</code>.<br><br>\nUnfortunately the solution to this problem states:</p>\n\n<pre><code>TRAILING(F) = { id, ) }\nTRAILING(T) = TRAILING(F) `union` { * } = { *, id, ) }\nTRAILING(E) = TRAILING(T) `union` { + } = { +, *, id, ) }\n</code></pre>\n\n<p>I don't see how <code>*</code> or <code>+</code> can be the last terminals in the derivation of <code>E</code>. Any derivation of <code>E</code> will always end with either an <code>id</code> or <code>)</code>. Similarly, case for <code>T</code>.</p>\n", 'Tags': '<terminology><formal-grammars><parsing>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-12-27T03:12:52.417', 'CommentCount': '6', 'AcceptedAnswerId': '7223', 'CreationDate': '2012-09-24T12:40:55.317', 'Id': '4716'},2051:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I have a homework assignment where I need to convert a grammar into LL(1). I've already removed the left recursion, but I'm having trouble doing left-factoring. All of the examples I've found are simple, and look something like this:</p>\n\n<p><code>A -&gt; aX | aY</code><br>\nbecomes:<br>\n<code>A -&gt; aZ</code><br>\n<code>Z -&gt; X | Y</code></p>\n\n<p>I understand that. However, my grammar looks more like this:</p>\n\n<pre><code>X -&gt; aE | IXE | (X)E\nE -&gt; IE | BXE | \u03f5\nI -&gt; ++ | --\nB -&gt; + | - | \u03f5\n</code></pre>\n\n<p>I'm not sure how to apply the simpler example to this. I've been trying for at least a couple of hours and I've lost track of all of the things I've tried. Generally, my attempts have looked something like this:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nE  -&gt; IE | BIX'E | BX'E | \u03f5\n</code></pre>\n\n<p>And I then try to convert the E rules into ones having only one production starting with + or -:</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; IE | B'IX'E | IX'E | B'X'E | X'E | \u03f5\n</code></pre>\n\n<p>And then...</p>\n\n<pre><code>X  -&gt; X' | IXE\nX' -&gt; aE | (X)E\nB' -&gt; + | -\nE  -&gt; +P | -M | \u03f5\nP  -&gt; +E | IX'E | +X'E | X'E\nM  -&gt; -E | IX'E | -X'E | X'E\n</code></pre>\n\n<p>And so on. But I continually end up with a lot of extra nonterminals, and some very long productions / chains of productions, without actually having left-factored it. I'm not sure how to approach this - I can't seem to eliminate <i>some</i> nonterminal having multiple productions starting with a + and with a -.</p>\n", 'ViewCount': '2109', 'Title': 'Left-Factoring a grammar into LL(1)', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:21:31.690', 'LastEditDate': '2014-01-23T17:21:31.690', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '4873', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '3049', 'Tags': '<formal-languages><formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-10-03T19:44:14.687', 'Id': '4862'},2052:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '923', 'Title': 'Is there any way to distinguish between LL(k) and LR(k) grammar?', 'LastEditDate': '2012-10-05T19:53:15.253', 'AnswerCount': '2', 'Score': '8', 'OwnerDisplayName': 'Deb', 'PostTypeId': '1', 'OwnerUserId': '3075', 'FavoriteCount': '2', 'Body': '<p>I am recently studying about Compilers designing. I came to know about two types of grammar one is LL grammar and other is LR grammar.</p>\n\n<p>We also know the facts that every LL grammar is LR that is LL grammar is a proper subset of LR grammar. First one is used in top-down parsing and the second one is used in bottom-up parsing.  </p>\n\n<p>But is there any way to so that we can say that a given grammar is LL or LR?</p>\n', 'Tags': '<formal-grammars><compilers><parsing>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-06T03:43:28.817', 'CommentCount': '3', 'AcceptedAnswerId': '4897', 'CreationDate': '2012-10-05T14:27:41.813', 'Id': '4888'},2053:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p><sup>(edit: the question was ambiguous. The following is it's non-trivial interpretation) </sup></p>\n\n<p>I need to <code>Find a regular grammar that generates the set of all real numbers in C (programming Language)</code></p>\n\n<ol>\n<li>How do I know how the C programming language defines a real number?</li>\n<li>How can I find a <em>regular</em> grammar for such numbers?</li>\n</ol>\n", 'ViewCount': '587', 'ClosedDate': '2012-10-10T20:09:06.560', 'Title': 'Find a regular grammar that generates the set of all real numbers in C', 'LastEditorUserId': '157', 'LastActivityDate': '2012-10-19T17:26:29.650', 'LastEditDate': '2012-10-09T07:14:53.170', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '3095', 'Tags': '<regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2012-10-08T03:12:37.733', 'Id': '4939'},2054:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '257', 'Title': 'Are all context-sensitive languages decidable?', 'LastEditDate': '2012-10-16T12:12:02.693', 'AnswerCount': '1', 'Score': '8', 'PostTypeId': '1', 'OwnerUserId': '2137', 'FavoriteCount': '2', 'Body': '<p>I was going through the <a href="http://en.wikipedia.org/wiki/Context-sensitive_language">Wikipedia definition of <em>context-sensitive language</em></a> and I found this:</p>\n\n<blockquote>\n  <p>Each category of languages is a proper subset of the category directly above it. Any automaton and any grammar in each category has an equivalent automaton or grammar in the category directly above it.</p>\n</blockquote>\n\n<p>I could see that linear-bounded automaton is directly below decider in the article\'s ordering. If this is the case, then that means every computation on a LBA will halt at some point (since every LBA would be a decider). But I feel that there may be some computation which can run on a LBA at the same time never to halt. For example we can write a computation on LBA which would</p>\n\n<ol>\n<li>read the first symbol on the tape and move right;</li>\n<li>read the next symbol and move back left.</li>\n</ol>\n\n<p>This (useless) computation (which is obviously a LB computation) would run indefinitely oscillating left and right and never halt and hence cannot be a decider. Where am I thinking wrong?</p>\n', 'Tags': '<formal-grammars><turing-machines><undecidability><context-sensitive>', 'LastEditorUserId': '39', 'LastActivityDate': '2012-10-17T06:19:22.953', 'CommentCount': '1', 'AcceptedAnswerId': '6109', 'CreationDate': '2012-10-16T11:57:26.330', 'Id': '6108'},2055:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to find CFG's that generate a regular language over the alphabet {a b}</p>\n\n<p>I believe I got this one right: All strings that end in b and have an <strong>even</strong> number of b's in total:</p>\n\n<p>$\\qquad S \\to SS \\\\\n\\qquad S \\to YbYb \\mid \\varepsilon \\\\\n\\qquad Y \\to aY \\mid \\varepsilon$</p>\n\n<p>However, Im not sure how to accomplish this with an odd number of <em>b</em>'s.</p>\n\n<p>So for example, how could I find a CFG that generates all strings that end in b and have an <strong>odd</strong> number of b's in total: So far I have this,</p>\n\n<p>$\\qquad S \\to SS \\\\\n \\qquad S \\to YYb \\mid \\varepsilon \\\\\n \\qquad Y \\to abY \\mid baY \\mid \\varepsilon$</p>\n\n<p>But this can generate abababb so it's incorrect and Im stumped at this point. </p>\n", 'ViewCount': '286', 'Title': 'Context Free Grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2012-10-22T13:47:53.540', 'LastEditDate': '2012-10-22T13:45:18.583', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '6164', 'Score': '1', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<regular-languages><formal-grammars><context-free>', 'CreationDate': '2012-10-19T06:49:34.393', 'Id': '6163'},2056:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '160', 'Title': 'What precisely is infinite ambiguity in a grammar?', 'LastEditDate': '2012-10-28T13:39:38.737', 'AnswerCount': '1', 'Score': '4', 'OwnerDisplayName': u'Jakub L\xe9dl', 'PostTypeId': '1', 'OwnerUserId': '4383', 'Body': "<p>From what I've read, an example of infinite ambiguity is usually given in a form of a loop:</p>\n\n<p>$S \\rightarrow aA \\\\\nA \\rightarrow B \\\\\nB \\rightarrow A \\\\\nB \\rightarrow b$</p>\n\n<p>But a grammar is called <em>ambiguous</em> if there's more than 1 way to derive the input string &omega;. What if I then take this well-known ambiguous grammar:</p>\n\n<p>$S \\rightarrow SSS \\\\\nS \\rightarrow SS \\\\\nS \\rightarrow b$</p>\n\n<p>and extend it with $S \\rightarrow \\epsilon$\nso that for any member of $\\left\\{ b^n \\middle| n \\geq 0\\right\\}$ there's infinitely many ways to derive it? Does this make the grammar <em>infinitely</em> ambiguous?</p>\n", 'Tags': '<terminology><formal-grammars><ambiguity>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T10:22:03.010', 'CommentCount': '1', 'AcceptedAnswerId': '9228', 'CreationDate': '2012-10-27T22:17:07.123', 'Id': '6357'},2057:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>One can compress data with straight-line grammars. An algorithm that employs this technique is called <em>Sequitur</em>. If I understood correctly, Sequitur basically starts with one rule representing the input and then does these three steps till the grammar does not change anymore:</p>\n\n<ol>\n<li>For each rule, try to find any sequences of symbols in any other rule that match the rule's right hand side and replace these sequences by the rules left hand side.</li>\n<li>For each pair of adjacent symbols in any right hand side, find all non-overlapping other pairs of adjacent symbols that are equal to the original pair. If there are any other pairs, add a new nonterminal, replace all occurrences of these pairs by the new nonterminal and add a new rule that defines the nonterminal.</li>\n<li>For each nonterminal that appears exactly once on all right-hand sides of all rules, replace its occurrence by its definition, remove the nonterminal and the rule that defines it.</li>\n</ol>\n\n<p>For each (non-empty) input, can one guarantee that the above algorithm terminates?</p>\n", 'ViewCount': '251', 'Title': 'Will this algorithm terminate on any input?', 'LastEditorUserId': '2280', 'LastActivityDate': '2013-01-28T22:04:37.830', 'LastEditDate': '2012-10-29T06:14:04.147', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2280', 'Tags': '<algorithms><algorithm-analysis><formal-grammars><data-compression><correctness-proof>', 'CreationDate': '2012-10-28T21:15:53.433', 'FavoriteCount': '1', 'Id': '6360'},2058:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '310', 'Title': 'Context Free Grammar for language', 'LastEditDate': '2012-11-02T07:05:25.063', 'AnswerCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '4365', 'FavoriteCount': '1', 'Body': "<p>The language is $L = \\{a^{i} b^{j} c^{k} \\;|\\; k \\neq 2j\\}$. I'm trying to write a grammar for this language, what I have so far is:</p>\n\n<p>$S \\rightarrow AT_{1} \\;|\\; AT_{2} \\;|\\; AT_{3} \\;|\\; AB \\;|\\; AC$</p>\n\n<p>$A \\rightarrow aA \\;|\\; \\varepsilon$ </p>\n\n<p>$B \\rightarrow bB \\;|\\; \\varepsilon$</p>\n\n<p>$C \\rightarrow cC \\;|\\; \\varepsilon$</p>\n\n<p>$T_{1} \\rightarrow bbB'T_{1}c \\;|\\; \\varepsilon $   (for $2j &gt; k$)(1)</p>\n\n<p>$B' \\rightarrow bB' \\;|\\; b$</p>\n\n<p>$T_{2} \\rightarrow bT_{2}ccC'\\;|\\; \\varepsilon$ (for $2j &lt; k$)</p>\n\n<p>$C' \\rightarrow cC' \\;|\\; c$</p>\n\n<p>$T_{3} \\rightarrow bT_{3}c \\;|\\; \\varepsilon$ (for $j = k$)</p>\n\n<p>the problem that I am having is, the string $bbccc$  can't be generated although valid, in that case $j = 2$ and $k = 3$  so $2\\times 2 &gt; 3$  corresponding to production rule (1), how can I fix this?</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-15T11:05:27.533', 'CommentCount': '4', 'AcceptedAnswerId': '6439', 'CreationDate': '2012-11-01T04:09:50.207', 'Id': '6415'},2059:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>A <a href="http://en.wikipedia.org/wiki/Formal_grammar" rel="nofollow">grammar</a> is <em><a href="http://en.wikipedia.org/wiki/Ambiguous_grammar" rel="nofollow">ambiguous</a></em> if at least one of the words in the\nlanguage it defines can be parsed in more than one way. A simple example of an ambiguous grammar\n$$\n   E \\rightarrow E+E \\ |\\ E*E \\ |\\ 0 \\ |\\ 1 \\ |\\ ...\n$$\nbecause the string 1+2*3 can be parsed as (1+2)*3 and 1+(2*3).  For\ncontext free grammars (CFGs) ambiguity is not decidable [1, 2]. This implies that non-ambiguity is also not decidable. Moreover, at least one of ambiguity and\nnon-ambiguity cannot even be recursively enumerable, for otherwise\nambiguity of a given CFG $G$ could be decided by running the\nenumeration of ambiguity and non-ambiguity together and seeing which\none contains $G$ (and one of them must).</p>\n\n<p>So which problem is harder in this sense? Ambiguity or non-ambiguity?</p>\n\n<ol>\n<li><p>D. G. Cantor, On The Ambiguity Problem of Backus Systems.</p></li>\n<li><p>R. W. Floyd, On ambiguity in phrase structure languages.</p></li>\n</ol>\n', 'ViewCount': '127', 'Title': 'Hardness of ambiguity/non-ambiguity for context-free grammars', 'LastEditorUserId': '2887', 'LastActivityDate': '2012-11-03T16:47:16.880', 'LastEditDate': '2012-11-03T16:47:16.880', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6464', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '2887', 'Tags': '<computability><formal-grammars><context-free><undecidability><ambiguity>', 'CreationDate': '2012-11-03T14:29:51.043', 'Id': '6463'},2060:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>According to <a href="http://en.wikipedia.org/wiki/Unrestricted_grammar">this Wikipedia article</a>, unrestricted grammars are equivalent to Turing machines. The article notes that I can convert any Turing machine into an unrestricted grammar, but it only shows how to convert a grammar to a Turing machine.</p>\n\n<p>How do I indeed do that and convert the Turing machine the recognizes language $L$ into an unrestricted grammar? I have tried replacing transition rules with grammar rules, but a Turing machine can have many different configurations of states as well...</p>\n', 'ViewCount': '395', 'Title': 'How can I convert the Turing machine the recognizes language $L$ into an unrestricted grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-06T11:12:41.060', 'LastEditDate': '2012-11-06T10:45:20.903', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6510', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4414', 'Tags': '<formal-grammars><turing-machines><simulation>', 'CreationDate': '2012-11-06T08:24:48.120', 'Id': '6504'},2061:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '550', 'Title': 'Inherent ambiguity of the language $L_2 = \\{a^nb^mc^m \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^m \\;|\\; m,n \\geq 1\\}$', 'LastEditDate': '2012-11-09T06:57:09.207', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4422', 'FavoriteCount': '0', 'Body': "<p>I went through a question asking me to choose the inherently ambiguous language among a set of options.</p>\n\n<p>$$L_1 = \\{a^nb^mc^md^n \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^md^m \\;|\\; m,n \\geq 1\\}$$\n$$and$$\n$$L_2 = \\{a^nb^mc^m \\;|\\; m,n \\geq 1\\}\\cup \\{a^nb^nc^m \\;|\\; m,n \\geq 1\\}$$</p>\n\n<p>The solution said that $L_1$ is ambiguous while $L_2$ isn't. It generated the following grammar for $L_1$</p>\n\n<p>$S \\rightarrow S_1\\;|\\;S_2$</p>\n\n<p>$S_1 \\rightarrow AB$</p>\n\n<p>$A \\rightarrow aAb\\;|\\;ab$</p>\n\n<p>$B \\rightarrow cBd\\;|\\;cd$</p>\n\n<p>$S_2 \\rightarrow aS_2d\\;|\\;aCd$</p>\n\n<p>$C \\rightarrow bCc\\;|\\;bc$</p>\n\n<p>Now for the string <code>abcd</code>, it will generate two parse trees; so it is ambiguous.</p>\n\n<p>But a similar grammar can be created for $L_2$ too</p>\n\n<p>$S \\rightarrow S_1|S_2$</p>\n\n<p>$S_1 \\rightarrow Ac$</p>\n\n<p>$A \\rightarrow aAb\\;|\\;\\epsilon$</p>\n\n<p>$S_2 \\rightarrow aB$</p>\n\n<p>$B \\rightarrow bBc\\;|\\;\\epsilon$</p>\n\n<p>And it will also generate two parse trees for <code>abc</code>. Why isn't it ambiguous then?</p>\n\n<p>If you need,\n$L_2$ can be written as $\\{a^nb^pc^m\\;|\\; n=p \\;\\; or \\;\\; m=p\\}$</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free><ambiguity>', 'LastEditorUserId': '4422', 'LastActivityDate': '2012-11-09T06:57:09.207', 'CommentCount': '4', 'AcceptedAnswerId': '6573', 'CreationDate': '2012-11-09T04:40:14.713', 'Id': '6568'},2062:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there any algorithm that tells us how to modify semantic actions associated with a left-recursive grammar? For example, we have the following grammar, and its associated semantic actions:</p>\n\n<p>$ S \\rightarrow id = expr $  { S.s = expr.size }</p>\n\n<p>S $\\rightarrow$ if expr then $S_1$ else $S_2$ { $S_1.t = S.t + 2; $\n$S_2.t = S.t + 2;$ $S.s = expr.size + S_1.size + S_2.size + 2;$ }</p>\n\n<p>S $\\rightarrow$ while expr do $S_1$ { $S_1.t = S.t + 4;$ $S.s = expr.size + S_1.s + 1;$ }</p>\n\n<p>S $\\rightarrow$ $S_1$ ; $S_2$  {$S_1.t = S_2.t = S.t;$ $S.s = S_1.s + S_2.s; $ }</p>\n\n<p>Clearly the non-recursive version of the grammer is:</p>\n\n<p>S $\\rightarrow$ id = expr T </p>\n\n<p>S $\\rightarrow$ if expr then $S_1$ else $S_2$ T</p>\n\n<p>S $\\rightarrow$ while expr do $S_1$ T</p>\n\n<p>T $\\rightarrow$ ; $S_2$ T</p>\n\n<p>T $\\rightarrow$ $\\epsilon$</p>\n\n<p>But we also need to change the semantic actions accordingly. Any ideas how this can be done?</p>\n', 'ViewCount': '78', 'Title': 'How to modify semantic actions when removing left-recursion from a grammer', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:17:48.393', 'LastEditDate': '2014-01-23T17:17:48.393', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '7739', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2596', 'Tags': '<formal-grammars><compilers><semantics><left-recursion>', 'CreationDate': '2012-11-10T16:11:44.337', 'Id': '6604'},2063:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I gotta make a CFG and PDA for the grammar that has perfectly nested parentheses and brackets.</p>\n\n<p>$\\qquad\\begin{align}\n S &amp;\\to [S] \\\\\n S &amp;\\to (S) \\\\\n S &amp;\\to SS \\\\\n S &amp;\\to \\varepsilon\n\\end{align}$</p>\n\n<p>Not sure if this is correct, or how to make the PDA from it?</p>\n', 'ViewCount': '219', 'Title': 'CFG and PDA for the grammar that has perfectly nested parentheses and brackets', 'LastEditorUserId': '98', 'LastActivityDate': '2012-11-19T18:12:47.330', 'LastEditDate': '2012-11-19T18:12:47.330', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4632', 'Tags': '<formal-languages><automata><formal-grammars><context-free><pushdown-automata>', 'CreationDate': '2012-11-17T18:39:11.147', 'Id': '6719'},2064:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1826', 'Title': 'How is this grammar LL(1)?', 'LastEditDate': '2012-11-19T18:22:36.037', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '135', 'FavoriteCount': '1', 'Body': '<p>This is a question from the Dragon Book. This is the grammar:</p>\n\n<blockquote>\n  <p>$S \\to  AaAb \\mid BbBa $<br>\n  $A \\to \\varepsilon$<br>\n  $B \\to \\varepsilon$  </p>\n</blockquote>\n\n<p>The question asks how to show that it is LL(1) but not SLR(1). </p>\n\n<p>To prove that it is LL(1), I tried constructing its parsing table, but I am getting multiple productions in a cell, which is contradiction.</p>\n\n<p>Please tell how is this LL(1), and how to prove it?</p>\n', 'Tags': '<formal-grammars><compilers><parsers>', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-03T22:23:27.980', 'CommentCount': '2', 'AcceptedAnswerId': '6774', 'CreationDate': '2012-11-19T14:30:09.487', 'Id': '6768'},2065:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am having diffuculties understanding the principle of lookahead in LR(1) - items. How do I compute the lookahead sets ? </p>\n\n<p>Say for an example that I have the following grammar:</p>\n\n<p>S -> AB\nA -> aAb | b\nB -> d</p>\n\n<p>Then the first state will look like this:</p>\n\n<pre><code>S -&gt; .AB , {look ahead}\nA -&gt; .aAb, {look ahead}\nA -&gt; .b, {look ahead}\n</code></pre>\n\n<p>I now what look aheads are, but I don't know how to compute them. I have googled for answers but there isn't any webpage that explains this in a simple manner.</p>\n\n<p>Thanks in advance </p>\n", 'ViewCount': '500', 'Title': 'LR(1) - Items, Look Ahead', 'LastActivityDate': '2014-01-28T11:28:50.617', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6772', 'Score': '2', 'OwnerDisplayName': 'mrjasmin', 'PostTypeId': '1', 'OwnerUserId': '4658', 'Tags': '<formal-languages><formal-grammars><context-free><parsing>', 'CreationDate': '2012-11-19T18:00:06.743', 'Id': '6771'},2066:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Why LL(k) and LL(\u221e) are incompatible with left-recursion? I understand that a LL(k) language can support left-recursivity provided that with k-overahead tokens can be resolved any ambiguity. But, with a LL(\u221e) grammar, which type of ambiguities can't be solved?</p>\n", 'ViewCount': '101', 'Title': 'LL grammars and left-recursiviity', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T17:19:48.497', 'LastEditDate': '2014-01-23T17:19:48.497', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '6824', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4675', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2012-11-21T11:41:00.150', 'Id': '6809'},2067:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider the following language over the alphabet $\\mathcal{A} = \\{a,b,c\\}$:\n$$L = \\left\\{w \\in \\mathcal{A}^* \\mid \\text{\\(|w|\\) is odd and the middle character in \\(w\\) occurs nowhere else in \\(w\\)} \\right\\}$$</p>\n\n<p>I am trying to come up with a grammar for $L$, but I'm getting nowhere. I came up with some sample strings from the language which would be accepted: <code>b</code>, <code>abcab</code>, <code>accbcaa</code> \nI understand the length of the string has to be odd, and the middle character cannot be repeated anywhere in the string.</p>\n\n<p>Therefore, the above three strings are accepted. However, something like <code>aabbb</code> will not accepted, because even though the length is odd, the middle character is repeated.</p>\n\n<p>Can someone help with a grammar for $L$?</p>\n", 'ViewCount': '135', 'Title': 'Grammar for a language: odd length, middle character not repeated', 'LastEditorUserId': '39', 'LastActivityDate': '2012-11-29T20:59:19.760', 'LastEditDate': '2012-11-29T20:59:19.760', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4767', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2012-11-29T17:30:13.993', 'Id': '7019'},2068:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Deterministic context-free languages are commonly defined using an <em>automaton</em> concept, the (restricted, deterministic) pushdown automaton. To some that is confusing, as the name <em>context-free</em> refers to a grammar type.</p>\n\n<p>I seem to remember there exists a characterization of the DCF languages using grammars. In my recollection it used a complicated equivalence on non-terminals. Can anyone provide a pointer to that work?</p>\n', 'ViewCount': '180', 'Title': 'Grammatical characterization of deterministic context-free languages', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-05T09:56:58.627', 'LastEditDate': '2012-11-30T12:42:38.430', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7047', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '4287', 'Tags': '<reference-request><formal-grammars><context-free>', 'CreationDate': '2012-11-30T00:33:24.183', 'Id': '7031'},2069:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Using this grammar, over the alphabet $\\Sigma=\\{a\\}$\n$$\nS \\rightarrow a \\\\\nS\\rightarrow CD \\\\\nC\\rightarrow ACB \\\\\nC\\rightarrow AB \\\\\nAB\\rightarrow aBA \\\\\nAa\\rightarrow aA \\\\\nBa\\rightarrow aB \\\\\nAD\\rightarrow Da \\\\\nBD\\rightarrow Ea \\\\\nBE\\rightarrow Ea \\\\\nE\\rightarrow a \\\\\n$$\nIm trying to show that the working string $aaaaaaaaaBBBAAAD$ or $a^{n^2} B^nA^nD$ generates the word $a^{(n+1)^2}$</p>\n', 'ViewCount': '113', 'Title': 'Generate the word using this grammar', 'LastEditorUserId': '198', 'LastActivityDate': '2012-12-12T12:17:29.700', 'LastEditDate': '2012-12-12T12:17:29.700', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7142', 'Score': '1', 'OwnerDisplayName': 'user3115', 'PostTypeId': '1', 'Tags': '<formal-grammars><context-free>', 'CreationDate': '2012-12-04T00:56:13.803', 'Id': '7141'},2070:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the family of grammars $G_n,~n\\geq2$.\n$$S \\rightarrow A_ib_i~,~for~~1\\leq i \\leq n$$\n$$A_i \\rightarrow a_jA_i~|~a_j~,~for~~1 \\leq i,j \\leq n~~and~~i \\neq j$$</p>\n\n<p>where multiple alternative right sides result from different values of $i,j$\nwhile the terminal symbols $a_i$ and $b_i$ are not necessarily different from each other.</p>\n\n<ol>\n<li><p>Show that $G_n$ has exactly $n*2^{n-1}+n^2+1$ sets of LR(0) items.</p></li>\n<li><p>Examine if $G_n$ is LR(k) for some k.</p></li>\n</ol>\n\n<p>The above exercise is similar to Exercise 4.6.7 (page 258) from the "Compilers: Principles, Techniques &amp; Tools", 2nd Edition (a.k.a.Dragonbook) by Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman.</p>\n\n<p>I gave it much thought and also read chapter 4 of the book that is about Syntax Analysis but I still can\'t figure out how to prove this. Especially for question 2. I have no clue how to draw a conclusion about if this family of grammars can be parsed by an LR(k) parser.</p>\n\n<p>For part 1., I think it could be suitable to use induction to prove that this is the exact number of states for any $n \\geq 2$. At first, you have to construct the LR(0) states for $G_2,~n = 2$ and prove that the states correspond to the formula we have to prove. And it happens that way, as there are 9 LR(0) states which means that $\\Rightarrow n*2^{n-1}+n^2+1=2*2^{2-1}+2^2+1=4+4+1=9$. If it is helpful, I could post the state diagram for $n=2$.\nAlso, I don\'t know if this would help, but I proved that the productions for any $n$ is exactly $2n^2-n$.</p>\n', 'ViewCount': '251', 'Title': 'Parsing family of grammars, determine if LR(k)', 'LastEditorUserId': '4854', 'LastActivityDate': '2012-12-15T23:49:18.337', 'LastEditDate': '2012-12-15T23:49:18.337', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '4854', 'Tags': '<formal-grammars><parsing>', 'CreationDate': '2012-12-05T23:45:46.217', 'Id': '7201'},2071:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '101', 'Title': 'Present syntax rules in a more succinct way', 'LastEditDate': '2013-01-03T13:47:19.787', 'AnswerCount': '2', 'Score': '2', 'OwnerDisplayName': 'SoftTimur', 'PostTypeId': '1', 'OwnerUserId': '5008', 'Body': '<p>I am resuming syntax rules for a small language:</p>\n\n<p>\\begin{eqnarray*}\ne_C &amp;::=&amp; \\epsilon \\mid constant \\\\\n\\textit{prefix-op} &amp;::=&amp; - \\\\\n\\textit{infix-op} &amp;::=&amp; + \\mid - \\mid * \\\\\ne_E &amp;::=&amp; e_C \\mid \\textit{prefix-op} \\; e_E \\mid e_E \\; \\textit{infix-op} \\; e_E \\mid \\textit{function}_E (e_{E,0}, e_{E,1},\\ldots) \\mid \\textit{specialE} \\\\\ne_V &amp;::=&amp; e_C \\mid \\textit{prefix-op} \\; e_V \\mid e_V \\; \\textit{infix-op} \\; e_V \\mid \\textit{function}_V (e_{V,0}, e_{V,1}, \\ldots) \\mid \\textit{specialV}\n\\end{eqnarray*}</p>\n\n<p>The expressions $e_E$ and $e_V$ have something common: $e_C$. Some of their operators look same: $\\textit{prefix-op}$ and  $\\textit{infix-op}$. Their functions $\\textit{function}_E$ and $\\textit{function}_V$ are 2 different sets, and $\\textit{specialE}$ and $\\textit{specialV}$ are totally different.</p>\n\n<p>I am wondering if it is still possible to present this syntax more succinct, more compact in a conventional way... Could anyone help?</p>\n', 'Tags': '<formal-languages><formal-grammars><semantics>', 'LastEditorUserId': '5008', 'LastActivityDate': '2013-01-03T13:47:19.787', 'CommentCount': '0', 'AcceptedAnswerId': '7303', 'CreationDate': '2012-12-10T09:33:16.420', 'Id': '7300'},2072:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Say I have a context-free grammar defined by the following rule.</p>\n\n<p>$$\n\\langle EXPR\\rangle \\rightarrow \\langle EXPR\\rangle + \\langle EXPR\\rangle~|~\\langle EXPR\\rangle \\times \\langle EXPR\\rangle~|~(\\langle EXPR \\rangle)~|~x\n$$</p>\n\n<p>This grammar is ambiguous since, for instance, I can generate the string $x + x \\times x$ via more than 1 leftmost derivation.</p>\n\n<p>How could I make this grammar unambiguous? Should I make sure that no $\\langle EXPR\\rangle + \\langle EXPR\\rangle$ is evaluated after a $\\langle EXPR\\rangle \\times \\langle EXPR\\rangle$ as such:</p>\n\n<p>$$\n\\langle EXPR\\rangle \\rightarrow \\langle EXPR\\rangle + \\langle EXPR\\rangle~|~\\langle MUL\\_EXPR\\rangle \\times \\langle MUL\\_EXPR\\rangle~|~(\\langle EXPR \\rangle)~|~x \\\\\n\\langle MUL\\_EXPR \\rangle \\rightarrow \\langle EXPR\\rangle \\times \\langle EXPR\\rangle~|~(\\langle EXPR \\rangle)~|~x \\\\\n$$</p>\n', 'ViewCount': '427', 'Title': 'In general, how does one make a context-free grammar unambiguous?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-16T10:51:37.453', 'LastEditDate': '2013-01-16T10:19:57.650', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2860', 'Tags': '<formal-grammars><context-free><ambiguity>', 'CreationDate': '2012-12-16T18:45:58.600', 'FavoriteCount': '0', 'Id': '7443'},2073:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I went through a question asking me to categorize the following grammar.</p>\n\n<p>$$S \u2192 AA, S \u2192 AB, A \u2192 a, A\u2192BB, B \u2192 b, B \u2192 e$$</p>\n\n<p>From the production rules, clearly it is Context-Free. But it accepts a finite set of strings.\n$\\{e, a, aa, ab, abb, ba, bba, b, bb, bbb, bbbb\\}$\nwhich is regular language.</p>\n\n<p>So, is the above grammar regular? Though it does not follow from the rules.</p>\n\n<p>Basically my question is: <strong>Is the grammar $\\{S \u2192 AA, A \u2192 a\\}$ regular?.</strong></p>\n', 'ViewCount': '134', 'Title': 'Is this a regular grammar?', 'LastActivityDate': '2012-12-18T16:26:54.387', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '7487', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '4422', 'Tags': '<regular-languages><formal-grammars><context-free>', 'CreationDate': '2012-12-18T11:07:06.653', 'Id': '7486'},2074:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Given following grammar:</p>\n\n<p>$$\n\\begin{align}\nS \\rightarrow &amp;A1B \\\\\nA \\rightarrow &amp; 0A \\mid \\varepsilon \\\\\nB \\rightarrow &amp; 0B \\mid 1B \\mid \\varepsilon \\\\\n\\end{align}\n$$</p>\n\n<p>How can I show that this grammar is unambiguous? I need to find a grammar for the same language that is ambiguous, and demonstrate it.</p>\n\n<p>I know if I was asked to prove that the language is ambigious then I should find two different parse trees for same string, but I don't know what to do.</p>\n", 'ViewCount': '848', 'Title': 'How to show that given language is unambiguous', 'LastEditorUserId': '98', 'LastActivityDate': '2012-12-30T18:31:28.237', 'LastEditDate': '2012-12-22T07:00:56.657', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7519', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5137', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><ambiguity>', 'CreationDate': '2012-12-20T00:20:48.643', 'Id': '7518'},2075:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '186', 'Title': 'Is this grammar really LL(1) while not being LR(1)?', 'LastEditDate': '2012-12-23T11:32:28.010', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4383', 'FavoriteCount': '0', 'Body': "<p>$S \\rightarrow S$, $L(G) = \\{\\}$</p>\n\n<p><strong>LL(1) analysis:</strong></p>\n\n<p>We estabilish $FIRST(S)$ to be empty and $FOLLOW(S)$ to be $\\{\\$\\}$.\n$FIRST(S)$ doesn't contain &epsilon;, so the parse table looks like this:</p>\n\n<pre><code>+---+---+\n|   | $ |\n+---+---+\n| S |   |\n+---+---+\n</code></pre>\n\n<p>and correctly rejects any input including &epsilon;.</p>\n\n<p><strong>LR(1) analysis:</strong></p>\n\n<p>We start with the initial state 0:</p>\n\n<p>$S' \\rightarrow \\bullet S [\\$]$</p>\n\n<p>calculate its closure:</p>\n\n<p>$S' \\rightarrow \\bullet S [\\$]$</p>\n\n<p>$S \\rightarrow \\bullet S [\\$]$</p>\n\n<p>and the only transition, which leads to state 1 on S:</p>\n\n<p>$S' \\rightarrow S \\bullet [\\$]$</p>\n\n<p>$S \\rightarrow S \\bullet [\\$]$</p>\n\n<p>State 1 has a reduce/reduce conflict.</p>\n\n<p>Now, obviously there must be something I'm missing, since LL(k) grammars are a proper subset of LR(k) grammars. Would anyone care to point out the error?</p>\n", 'Tags': '<formal-grammars><context-free><parsers>', 'LastEditorUserId': '4383', 'LastActivityDate': '2012-12-24T19:41:08.793', 'CommentCount': '2', 'AcceptedAnswerId': '7581', 'CreationDate': '2012-12-23T10:56:44.823', 'Id': '7560'},2076:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>How can someone find what type of grammar for a given programming language?</p>\n\n<p>Formerly I'm looking for a grammar type for most popular programming languages: C, C++, C#, Java, List, OCaml, Haskell etc.</p>\n", 'ViewCount': '789', 'Title': 'Finding the grammar type of the programming language', 'LastActivityDate': '2013-01-01T14:06:33.447', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '7669', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '3016', 'Tags': '<formal-grammars><programming-languages>', 'CreationDate': '2012-12-23T18:04:02.737', 'Id': '7566'},2077:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '535', 'Title': 'Can someone give a simple but non-toy example of a context-sensitive grammar?', 'LastEditDate': '2013-01-03T14:56:30.403', 'AnswerCount': '3', 'Score': '7', 'OwnerDisplayName': 'BlueBomber', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Body': "<p>I'm trying to understand context-sensitive grammars.</p>\n\n<p>I understand why languages like</p>\n\n<blockquote>\n  <ol>\n  <li>$\\{ww \\mid w \\in A^*\\}$</li>\n  <li>$\\{a^n b^n c^n \\mid n\\in\\mathbb{N}\\}$</li>\n  </ol>\n</blockquote>\n\n<p>are not context free, but what I'd like to know if a language similar to the untyped lambda calculus is context sensitive.</p>\n\n<p>I'd like to see an example of a simple, but non-toy (I consider the above toy examples), example of a context-sensitive grammar that can, for some production rule, e.g., tell whether or not some string of symbols is in scope currently (e.g. when producing the body of a function).</p>\n\n<p>Are context sensitive grammars powerful enough to make undefined/undeclared/unbound variables a syntactic (rather than semantic) error?</p>\n", 'Tags': '<formal-grammars><programming-languages><lambda-calculus><context-sensitive>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-09T16:31:26.590', 'CommentCount': '0', 'AcceptedAnswerId': '7718', 'CreationDate': '2013-01-01T07:51:23.580', 'Id': '7716'},2078:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm trying to understand the equivalence in expressive power of formal grammars whose rules take the form:</p>\n\n<p>$$ \\alpha \\rightarrow \\beta $$ where $ |\\alpha| \\leq |\\beta| $ (called a <em>monotonic</em> grammar), and grammars whose rules take the form:</p>\n\n<p>$$ \\alpha B \\gamma \\rightarrow \\alpha C \\gamma  $$</p>\n\n<p>where $\\alpha $ and $\\gamma$ are strings of terminals &amp; non-terminals or possibly empty, and $B$ and $C$ are single non-terminals. I understand that grammars of the second kind are already, by definition, grammars of the first kind, but I'd like to understand how to derive a grammar of the second kind, given one of the first kind (a monotonic grammar). Can anyone suggest a good reference for this? Many thanks in advance.</p>\n", 'ViewCount': '100', 'Title': 'Demonstrating that for every monotonic grammar there is an equivalent context-sensitive grammar', 'LastActivityDate': '2013-01-03T18:51:00.423', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '7735', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '5291', 'Tags': '<formal-grammars><context-sensitive>', 'CreationDate': '2013-01-03T16:39:35.637', 'Id': '7734'},2079:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '166', 'Title': 'Pumping lemma for Context-Free Languages', 'LastEditDate': '2013-01-03T22:12:16.170', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '4658', 'FavoriteCount': '2', 'Body': "<p>I have a question about a specific pumping lemma problem for Context-Free Languages.</p>\n\n<p>Suppose we have the following Language:</p>\n\n<blockquote>\n  <p>$L = \\{a^{i}b^{j}c^{k}d^{l} \\mid 0 &lt; i &lt; k \\wedge j &gt; l &gt; 0 \\}$</p>\n</blockquote>\n\n<p>Here is my attemp to prove that the language is not context-free:</p>\n\n<p>Assume $L$ is context-free. Let $n&gt;0$ be the pumping length given by the lemma.</p>\n\n<p>Let $z = a^{n}b^{n+1}c^{n+1}d^{n}$, then $z \\in L$. </p>\n\n<p>Than according to the lemma, $z$ can be written as $z = uvwxy$ where the following properties hold:</p>\n\n<ol>\n<li>$|vx| \\geq 1$</li>\n<li>$|vwx| \\leq n$</li>\n<li>for every $i \\geq 0$, $uv^{i}wx^{i}y \\in L$.</li>\n</ol>\n\n<p>We have 6 different possibilities for $vwx$:</p>\n\n<ol>\n<li>$vwx = a^{i}$ where $i \\leq n$</li>\n<li>$vwx = a^{i}{b^j}$ where $i+j \\leq n$</li>\n<li>$vwx = b^i$ and $i \\leq n$</li>\n<li>$vwx = b^{i}c^{j}$ and $i+j \\leq n$</li>\n<li>$vwx = c^{i}$ with $i \\leq n$</li>\n<li>$vwx = c^{i}d^{j}$ and $i+j \\leq n$ </li>\n</ol>\n\n<p>Is this right so far? The thing that I'm unsure of is if my different cases for $vwx$ are right. </p>\n\n<p>How do I choose the pumping length for case 2? If I choose $i$ = 2, what if $i$ is zero ? Then I don't have any contradiction.</p>\n\n<p>Thanks in advance</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free><pumping-lemma>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-01-03T22:51:38.927', 'CommentCount': '2', 'AcceptedAnswerId': '7741', 'CreationDate': '2013-01-03T21:26:59.443', 'Id': '7740'},2080:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>An ambiguous Language is a formal language for which there exists a string that can have more than one meaning (several possible meanings or interpretations). Multiple synthesis structures for a string. </p>\n\n<p><strong>[Question]</strong><br>\nAre <a href="https://en.wikipedia.org/wiki/Roman_numerals" rel="nofollow">Roman numbers</a> an example of an ambiguous language?  </p>\n\n<p>Because there can be more then one representation for some number such as 1999, which \ncan be written as <code>MDCCCCLXXXXVIIII</code>, <code>MCMXCIX</code>, or <code>MIM</code>.    </p>\n\n<p>I am confused. Sometimes I feel not, some time yes!    </p>\n\n<p><strong>EDIT</strong><br>\n[ANSWER]</p>\n\n<p>Although there can be more than one representation of same magnitude in Roman Number System. That is basically Non-Positional Number System. But its possible to write <a href="http://compilers.iecc.com/comparch/article/07-03-118" rel="nofollow"><strong>Unambiguous Grammar for that can generate all possible/valid pattern in Roman Number System</strong></a>.   </p>\n\n<p><a href="http://www.boost.org/doc/libs/1_48_0/libs/spirit/doc/html/spirit/qi/tutorials/roman_numerals.html" rel="nofollow"><strong>Here is again a beautiful link</strong></a> that describe <code>symbol table</code>, <code>rule</code>  , <code>Grammar</code> for Roman number.  </p>\n\n<p>I am not sure about this but some authors says that: "<em>Roman numbers can be recognized by a regular expression, so you don\'t really need a context-free grammar.</em>" and a regular language can\'t be ambiguous. </p>\n', 'ViewCount': '823', 'Title': 'Is the language of Roman numerals ambiguous?', 'LastEditorUserId': '917', 'LastActivityDate': '2014-02-14T23:21:53.167', 'LastEditDate': '2013-12-09T11:57:11.067', 'AnswerCount': '5', 'CommentCount': '3', 'Score': '3', 'OwnerDisplayName': 'Grijesh Chauhan', 'PostTypeId': '1', 'OwnerUserId': '5000', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-01-05T05:42:55.883', 'Id': '7777'},2081:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Anyone knows if there is an algorithm for directly write the context-free grammar that generates a given regular expression?</p>\n', 'ViewCount': '1870', 'Title': 'Regular Expression to Context-Free Grammar', 'LastActivityDate': '2013-01-22T11:07:21.357', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '9057', 'Score': '1', 'OwnerDisplayName': 'Marco L.', 'PostTypeId': '1', 'OwnerUserId': '4311', 'Tags': '<formal-grammars><regular-expressions><context-free>', 'CreationDate': '2013-01-19T15:07:19.573', 'FavoriteCount': '1', 'Id': '9050'},2082:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '126', 'Title': 'Show how a sentence can be produced from a grammar (Dragon book 2.1)', 'LastEditDate': '2013-01-23T19:28:54.647', 'AnswerCount': '1', 'Score': '0', 'OwnerDisplayName': 'dan', 'PostTypeId': '1', 'OwnerUserId': '6520', 'Body': u"<p>In the Dragon book (Aho, Sethi, Ullmann) there is one exercise I don't get.</p>\n\n<blockquote>\n  <p>Chapter 2, Exercies: 2.1<br>\n  Given the context-free grammar\n  $$S \\to S S + \\mid S S * \\mid a$$\n  Task: Show how the signs aa+a* can be produced from this grammar.</p>\n</blockquote>\n\n<p>I understand the grammar, $S$ can have the form $S S +$\u2026 and so on. But I don't know what I'm supposed to do in this task. Sadly I can't find any solutions on the web.</p>\n", 'Tags': '<formal-grammars><context-free>', 'LastEditorUserId': '39', 'LastActivityDate': '2013-01-23T19:30:31.350', 'CommentCount': '0', 'AcceptedAnswerId': '9110', 'CreationDate': '2013-01-23T14:54:22.350', 'Id': '9109'},2083:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '44', 'Title': 'How i can use Mathematical induction to prove CFG production?', 'LastEditDate': '2013-01-28T10:23:01.200', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'M.B', 'PostTypeId': '1', 'OwnerUserId': '6594', 'Body': '<p>If I have production $G_n$</p>\n\n<blockquote>\n  <p>$S \\rightarrow A_i b_i \\quad$ for $1 \\le i \\le n$</p>\n  \n  <p>$A_i \\rightarrow a_j A_i \\mid a_j\\quad$   for $1 \\le i$ and $i \\ne j$</p>\n</blockquote>\n\n<ol>\n<li>Prove $G_n$ is sub-productions from $2n^2 - n$</li>\n<li>Prove $G_n$ is $LR(0)$ production from $2^n + n^2 + n$</li>\n</ol>\n', 'ClosedDate': '2013-04-14T19:11:20.580', 'Tags': '<formal-languages><formal-grammars><context-free><proof-techniques><induction>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-01-28T10:23:01.200', 'CommentCount': '5', 'CreationDate': '2013-01-27T17:06:45.810', 'Id': '9230'},2084:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have seen a few years back a nice and simple algorithm that, given a (finite) set of words in some alphabet, builds a context-free grammar for a language including these words and in some sense "natural" (e.g., the grammar doesn\'t produce all words in the alphabet). The algorithm is very simple,  it has something like 3--4 rules for grammar transformation attempted on each new word. Any help in finding it would be appreciated.</p>\n', 'ViewCount': '181', 'Title': 'Construct a context-free grammar for a given set of words', 'LastEditorUserId': '6591', 'LastActivityDate': '2013-12-10T07:31:05.390', 'LastEditDate': '2013-01-28T15:39:42.217', 'AnswerCount': '2', 'CommentCount': '9', 'AcceptedAnswerId': '9268', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6591', 'Tags': '<algorithms><formal-languages><reference-request><formal-grammars><machine-learning>', 'CreationDate': '2013-01-28T10:01:35.720', 'Id': '9246'},2085:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm looking for the name (or <em>a</em> name if there isn't one already) of this relation between $G_1=\\left&lt;\\Sigma_1,\\mathcal{N}_1,\\mathcal{R}_1,S_1\\right&gt;$ and $G_2=\\left&lt;\\Sigma_2,\\mathcal{N}_2,\\mathcal{R}_2,S_2\\right&gt;$:\n$$\\exists f_\\Sigma\\in\\Sigma_1\\times\\Sigma_2,f_\\mathcal{N}\\in\\mathcal{N_1}\\times\\mathcal{N}_2 \\text{ surjective functions s.t. }\\\\ \\mathcal{R}_2=\\left\\{f_\\mathcal{N}(N)\\rightarrow f(\\alpha)\\mid N\\rightarrow\\alpha\\in R_1\\right\\}\\text{ and } S_2=f_\\mathcal{N}(S_1) $$\nwhere $f$ is the extension of $f_\\Sigma$ and $f_\\mathcal{N}$ to words ($f\\in(\\Sigma_1\\cup\\mathcal{N}_1)^*\\times(\\Sigma_2\\cup\\mathcal{N}_2)^*$).</p>\n\n<p>In other words, you can map $G_1$ to $G_2$ (but not necessarily $G_2$ to $G_1$).</p>\n\n<p>If the mapping function were bijective, this would be an isomorphism, but they're not.</p>\n\n<p>What about if only $f_\\mathcal{N}$ is  surjective, i.e. $f_\\Sigma$ is bijective, or even the identity function?</p>\n", 'ViewCount': '40', 'Title': 'Is there a name for this relation on CFGs?', 'LastEditorUserId': '31', 'LastActivityDate': '2013-01-28T15:28:18.950', 'LastEditDate': '2013-01-28T15:16:34.997', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '9252', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '5366', 'Tags': '<terminology><formal-grammars><context-free>', 'CreationDate': '2013-01-28T14:36:24.383', 'Id': '9250'},2086:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '144', 'Title': 'Give a grammar to show whether a language is regular or context-free', 'LastEditDate': '2013-02-02T14:17:23.077', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '6680', 'FavoriteCount': '0', 'Body': "<p>I have to generate a grammar for the language $L = \\{ w \\in \\{ a, b\\}^* \\mid |w| \\in 2\\mathbb{N},  w \\neq w^R\\}$ and give the type of the language.</p>\n\n<p>I've generated the grammar</p>\n\n<p>$\\qquad \\begin{align}\n  S &amp;\\to aSa \\mid bSb \\mid aAb \\mid bAa \\\\\n  A &amp;\\to abA \\mid baA \\mid aaA \\mid bbA \\mid \\varepsilon\n\\end{align}$</p>\n\n<p>This grammar is a context free grammar. I now can say that $L$ is a context free language. But how can I say for sure that this language isn't regular ?</p>\n", 'Tags': '<formal-languages><formal-grammars><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-02T14:17:23.077', 'CommentCount': '1', 'AcceptedAnswerId': '9422', 'CreationDate': '2013-02-02T10:40:02.157', 'Id': '9418'},2087:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '226', 'Title': 'Can a CFG end have a non-terminal symbol in the middle of it?', 'LastEditDate': '2013-02-05T10:16:50.780', 'AnswerCount': '2', 'Score': '1', 'OwnerDisplayName': 'Badger Girl', 'PostTypeId': '1', 'OwnerUserId': '6707', 'Body': "<p>What is the correct way to write a CFG?</p>\n\n<pre><code>A -&gt; B C' E\nC' -&gt; C\nC' -&gt; null\n</code></pre>\n\n<p>or</p>\n\n<pre><code>A -&gt; B C'\nC' -&gt; C E\nC' -&gt; E\n</code></pre>\n", 'Tags': '<terminology><formal-grammars><context-free>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-05T10:16:50.780', 'CommentCount': '1', 'AcceptedAnswerId': '9496', 'CreationDate': '2013-02-04T20:47:59.420', 'Id': '9495'},2088:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider the context free grammar:</p>\n\n<p>$$S \\rightarrow aSb \\mid aSa \\mid bSa \\mid bSb \\mid \\varepsilon$$</p>\n\n<p>It could generate regular language, which means it can be converted to a right linear grammar. Is there a general rule to convert CFG into a RLG? If there is no general rule, could you please show me how to convert this CFG to a RLG?</p>\n', 'ViewCount': '792', 'Title': 'How to convert a context free grammar (could generate regular language) to a right-linear grammar', 'LastEditorUserId': '472', 'LastActivityDate': '2013-05-24T03:16:35.967', 'LastEditDate': '2013-05-24T03:15:42.197', 'AnswerCount': '3', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6576', 'Tags': '<regular-languages><context-free><formal-grammars>', 'CreationDate': '2013-02-06T13:40:06.713', 'Id': '9542'},2089:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there an algorithm which decides whether a regular tree grammar $G$ is ambiguous, i.g. there exists a tree $t\\in L(G)$ which can be parsed by the grammar in more than one ways, using only leftmost derivations?</p>\n\n<p>Is there a proof available about the decidability, or a cite to a paper which proposes such an algorithm?</p>\n', 'ViewCount': '241', 'Title': 'Is the ambiguity of a regular tree grammar decidable?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-14T06:40:05.507', 'LastEditDate': '2013-02-14T06:40:05.507', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6866', 'Tags': '<formal-languages><computability><formal-grammars><ambiguity><tree-grammars>', 'CreationDate': '2013-02-13T15:29:34.530', 'Id': '9745'},2090:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '696', 'Title': 'Context Free Grammar for language $L=\\{a^ib^j \\mid i,j \\ge 0; i \\ne 2j\\}$', 'LastEditDate': '2013-02-16T14:40:19.113', 'AnswerCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6885', 'FavoriteCount': '0', 'Body': "<p>Can someone help with this:  </p>\n\n<p>$L=\\{a^ib^j \\mid i,j \\ge 0 \\text{ and } i \\ne 2j\\}$  </p>\n\n<p>I'm trying to write a grammar for this language?\nI don't know how to do this.\nI tried this:<br>\n$S \\rightarrow aaAb \\mid aA \\\\\nA \\rightarrow aA \\mid a$</p>\n", 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-16T14:40:19.113', 'CommentCount': '3', 'AcceptedAnswerId': '9811', 'CreationDate': '2013-02-15T11:14:40.920', 'Id': '9804'},2091:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Can someone help with this:</p>\n\n<p>$L=\\{a^ib^j \\mid i,j \\ge 1 \\text{ and } i \\ne j \\text{ and } i&lt;2j\\}$</p>\n\n<p>I'm trying to write a grammar for this language?\nI tried this:</p>\n\n<p>$S \\to S_1 \\mid S_2 \\\\\nS_1 \\to aXb \\\\\nX \\to aXb \\mid aaXb \\mid aab \\\\\nS_2 \\to aYb \\\\\nY \\to aYb \\mid Yb \\mid b \\\\\n$</p>\n\n<p>What do you think?</p>\n", 'ViewCount': '308', 'Title': 'Context Free Grammar for language L', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-14T21:09:44.067', 'LastEditDate': '2013-04-06T18:56:00.993', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '6885', 'Tags': '<formal-languages><context-free><formal-grammars><check-my-answer>', 'CreationDate': '2013-02-16T11:00:00.360', 'Id': '9831'},2092:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I am trying to define a non terminal symbol in a LALR(1) grammar (with CUP parser). It is requested that </p>\n\n<pre><code>the &lt;code&gt; token must appear exactly twice, \nwhile the &lt;hour&gt; token must appear at least once.\n</code></pre>\n\n<p>In the end I came up with this definition:</p>\n\n<pre><code>section     ::= hour_l CODE SC hour_l CODE SC hour_l ;\nhour_l      ::= /* epsilon */ \n            | hour_l HOUR SC ;\n</code></pre>\n\n<p>where <code>SC</code> is a separator (semicolon) between tokens and <code>hour_l</code> is the non terminal symbol for hour's list.\nThis solution has a problem: <code>HOUR</code> can be absent, because <code>epsilon</code> can be reduced from <code>hour_l</code>.\nIs there a clever solution other than specifying all possibilities or using the semantic capabilities of CUP (ie. putting a counter of how many times <code>HOUR</code> is present in <code>section</code>)? I'd prefer not to use semantics in order to achieve this; in fact, it seems to me this is syntax related.</p>\n\n<p>Thanks</p>\n", 'ViewCount': '33', 'Title': 'How to define at least one occurrence of a string between two tokens in bottom up LALR(1) parser grammar', 'LastEditorUserId': '3011', 'LastActivityDate': '2013-02-22T11:22:49.337', 'LastEditDate': '2013-02-22T11:09:22.340', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10021', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '6961', 'Tags': '<formal-grammars><parsing>', 'CreationDate': '2013-02-20T09:09:56.133', 'Id': '9961'},2093:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In compiler design, why should left recursion be eliminated in grammars? I am reading that it is because it can cause an infinite recursion, but is it not true for a right recursive grammar as well?</p>\n', 'ViewCount': '1414', 'Title': 'Why is left recursion bad?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T02:23:37.270', 'LastEditDate': '2014-01-23T17:17:55.627', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '9', 'OwnerDisplayName': 'user56833', 'PostTypeId': '1', 'Tags': '<formal-grammars><compilers><left-recursion>', 'CreationDate': '2013-02-20T10:06:01.963', 'Id': '9963'},2094:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is the grammar</p>\n\n<p>$\\qquad S \\to 1A0A \\mid 0A \\mid \\varepsilon$</p>\n\n<p>a right-linear grammar? $A$ is a nonterminal here, $0$ and $1$ are terminals.</p>\n\n<p>I know $0A$ is right-linear but what about $1A0A$?</p>\n\n<p>Trying to construct a right-linear grammar for language $10(0+1)^*10$.</p>\n', 'ViewCount': '155', 'Title': 'Constructing right-linear grammar', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-02-27T12:56:06.467', 'LastEditDate': '2013-02-27T12:56:06.467', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '10075', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<regular-languages><formal-grammars>', 'CreationDate': '2013-02-25T02:21:38.463', 'Id': '10074'},2095:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Are there languages generated by linear grammer which aren't regular?</p>\n", 'ViewCount': '114', 'Title': "Are there languages generated by linear grammar which aren't regular?", 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-25T13:57:55.043', 'LastEditDate': '2013-02-25T13:56:10.727', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10080', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<formal-languages><formal-grammars><context-free>', 'CreationDate': '2013-02-25T12:46:21.063', 'Id': '10079'},2096:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'ve recently came across a <a href="http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/FSF-ciaa06.pdf">paper</a> describing the parsing technique\nmentioned in the title. Unfortunately, the terminology used in said paper\nis somewhat beyond my comprehension, so I\'ve been attempting to grasp the\nconstruction algorithm more intuitively. I believe I succeeded (<a href="http://www.docstoc.com/docs/79482088/Approximating-Context-Free-Grammars-for-Parsing-and-Verification">this\npresentation</a> was the source of the ah-ha moment), but a verification of\ncorrectness from someone either familiar with the technique or the terminology\ncontained therein would be greatly appreciated.</p>\n\n<p>I\'m going to describe my take on the solution (if it\'s correct, I believe it\ncould be of help to other people attempting to understand the technique) and\nask additional questions afterwards. To ensure there\'s no misunderstanding,\nI\'m going to use the following standard notation: $a, b, c, ... \\in T$, $A, B,\nC, ... \\in N$, $... X, Y, Z \\in N \\cup T$, $\\alpha, \\beta, \\gamma, ... \\in \\{N\n\\cup T\\}^*$ and, as in the paper, $A \\xrightarrow{i} \\omega$ to denote rule number $i$. However, I\'ll probably use different names for concepts than\nthe original paper.</p>\n\n<p>Also, throughout the description, the equivalence relation $\\kappa_0$ is used.</p>\n\n<h3>Construction</h3>\n\n<p>There are two kinds of items inside the parsing automaton: simple LR(0) items\nof the form $A \\xrightarrow{i} \\alpha \\bullet \\beta$ which I call <em>shift items</em>\nand items of the form $A \\xrightarrow{i} \\alpha \\bullet \\beta, m, n$ which I\ncall <em>resolve items</em>; these tell the parser to push $n$ symbols back the\ninput stream and then reduce by rule number $m$ upon the first symbol of $\\beta$.</p>\n\n<p>The grammar is augmented with the rule $S\' \\xrightarrow{0} S \\$$ and the construction starts with the shift item $S\' \\xrightarrow{0} \\bullet S \\$ $ in the initial state.</p>\n\n<p>Now, to construct the automaton, decide between these alternatives for each item in a state $q$:</p>\n\n<ol>\n<li><p>If the item is a shift item $A \\xrightarrow{i} \\alpha \\bullet \\beta$,\nthere will be a transition $q \\xrightarrow{X} q\'$ in the automaton, where\n$X$ is the first symbol of $\\beta$.</p></li>\n<li><p>If the item is a finished shift item $A \\xrightarrow{i} \\omega \\bullet$,\nadd a resolve item $B \\xrightarrow{j} \\alpha A \\bullet \\beta, i, 0$ for each rule $B \\xrightarrow{j} \\alpha A \\beta$.</p></li>\n<li><p>If the item is a resolve item $A \\xrightarrow{i} \\alpha \\bullet \\beta, m, n$, let $X$ be the first symbol of $\\beta$. If $X \\in N$, add a shift item $X \\xrightarrow{j} \\bullet \\omega$ for each rule $X \\xrightarrow{j} \\omega$. If other items than $A \\xrightarrow{i} \\alpha \\bullet \\beta, m, n$ have $X$ as their dot lookahead, add a transition $q \\xrightarrow{X} q\'$ to the automaton.\nEvery resolve item $C \\xrightarrow{i} \\alpha \\bullet X \\beta, m, n$ in $q$ will result in a resolve item $C \\xrightarrow{i} \\alpha X \\bullet \\beta, m, n + 1$ in $q\'$.</p></li>\n<li><p>If the item is a resolve item $A \\xrightarrow{i} \\omega \\bullet, m, n$ it\nwon\'t contribute any lookahead information and can be discarded, but first add a resolve item $B \\xrightarrow{j} \\alpha A \\bullet \\beta, m, n$ for each rule\n$B \\xrightarrow{j} \\alpha A \\beta$.</p></li>\n</ol>\n\n<p>This is, of course, just a sketch; actually, a closure of the state must be calculated first and only then can we deal with transitions/shifts and resolutions.</p>\n\n<p>Transforming the automaton into a shift-resolve parsing table is trivial afterwards; just, as a minor variation, the authors of the paper interpret a resolution $r_{0,0}$ as the accept action. Given the resulting automaton, I found it handier to simply treat a shift of $\\$$ as the accept action.</p>\n\n<h3>Questions</h3>\n\n<p>The first one is, obviously, whether the process described above is correct.</p>\n\n<p>The second one is about the equivalence relations. I can only guess that the equivalence relation $\\kappa$ is what\'s responsible for deciding which resolve items are brought in when a finished shift item has been seen. $\\kappa_0$ seems to result in lookahead strikingly similar to the $FOLLOW_{LM}$ sets of LSLR parsers. The paper describes a "finer equivalence relation" on page 11; is there a way to interpret this relation in intuitive terms? Are there other relations known?</p>\n\n<p>And the final one is about conflict resolution. The paper describes well what constitutes an inadequacy in a shift-resolve automaton; is there a way of resolving these inadequacies, similar to ways of resolving conflicts in a traditional LR parser? Could something like <em>yacc</em>-style conflict resolution via precedence and associativity be implemented in a ShRe parser generator?</p>\n\n<p>Thanks if you read all this and any answers will be greatly appreciated :)</p>\n', 'ViewCount': '165', 'Title': 'Shift-resolve parsing - questions', 'LastEditorUserId': '4383', 'LastActivityDate': '2013-02-28T19:09:45.330', 'LastEditDate': '2013-02-26T20:28:26.713', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '4383', 'Tags': '<algorithms><formal-grammars><context-free><parsing>', 'CreationDate': '2013-02-26T16:10:49.380', 'FavoriteCount': '2', 'Id': '10123'},2097:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Turing machines and unrestricted grammars are two different formalisms that define the RE languages.  Some RE languages are decidable, but not all are.</p>\n\n<p>We can define the decidable languages with Turing machines by saying that a language is decidable iff there is a TM for the language that halts and accepts all strings in the language and halts and rejects all strings not in the language.  My question is this: <em>is there an analogous definition of decidable languages based on unrestricted grammars rather than Turing machines?</em></p>\n', 'ViewCount': '215', 'Title': 'Decidable languages and unrestricted grammars?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-02-27T11:29:06.683', 'LastEditDate': '2013-02-27T11:19:06.537', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '7', 'PostTypeId': '1', 'OwnerUserId': '2131', 'Tags': '<computability><turing-machines><formal-grammars>', 'CreationDate': '2013-02-26T17:07:14.603', 'Id': '10124'},2098:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '84', 'Title': 'Priority in formal grammar', 'LastEditDate': '2013-02-28T11:20:49.453', 'AnswerCount': '2', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '4409', 'FavoriteCount': '1', 'Body': '<p>From my recitation class, I have the following exercise:</p>\n\n<blockquote>\n  <p>$\\mathrm{EXP} = 0 \\mid 1 \\mid b \\mathrm{EXP} \\mid \\mathrm{EXP} a \\mid \\mathrm{EXP} m \\mathrm{EXP}$</p>\n  \n  <p>The above grammar is ambiguous.</p>\n  \n  <p>Make an unambiguous grammar which produce same language as the above.</p>\n  \n  <p>In the new grammar, $a$ has priority over $b$ and $b$ has priority over $m$.\n  Also $m$ is associative.</p>\n</blockquote>\n\n<p>Can you explain what the phrases</p>\n\n<ul>\n<li>"has priority over" and</li>\n<li>"$m$ is associative"</li>\n</ul>\n\n<p>mean?</p>\n', 'Tags': '<formal-languages><formal-grammars><parsing><ambiguity>', 'LastEditorUserId': '4409', 'LastActivityDate': '2013-02-28T14:58:59.373', 'CommentCount': '1', 'AcceptedAnswerId': '10151', 'CreationDate': '2013-02-27T19:11:49.933', 'Id': '10142'},2099:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How do we determine minimum $k$ such that $G$ is a strong $LL(k)$ Grammar</p>\n\n<p>Like for grammar $G$ with the following rules\n$S\\rightarrow aAcaa \\mid bAbcc,A\\rightarrow a \\mid ab \\mid \\epsilon$</p>\n', 'ViewCount': '85', 'Title': 'Lookahead set: Determining minimum $k$ such that $G$ is a strong $LL(k)$ grammar', 'LastEditorUserId': '6980', 'LastActivityDate': '2013-03-06T13:15:18.180', 'LastEditDate': '2013-03-05T12:02:22.250', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '10271', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6980', 'Tags': '<context-free><formal-grammars><parsing>', 'CreationDate': '2013-03-03T21:14:35.493', 'Id': '10245'},20100:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '511', 'Title': 'What is the exact relation between programming languages and Turing machines?', 'LastEditDate': '2013-03-11T07:22:24.840', 'AnswerCount': '4', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2529', 'FavoriteCount': '1', 'Body': '<p>I don\'t know much about yacc, bison, flex or lex and please correct me if I\'m wrong but a programming language is also a Turing machine and a Turing machine is defined as the tuple $(Q, \\Gamma, b, \\Sigma, \\delta, q_0, F)$ where $Q$, $\\Gamma$, $b \\in \\Gamma$, $\\Sigma \\subseteq \\Gamma \\smallsetminus \\{ b \\}$ as input, $\\delta: Q \\times \\Gamma \\rightarrow Q \\times \\Gamma \\times \\{ L, R, N \\}$ as transition function where $L$ = number of steps to the left, $R$ = number of steps to the right, $N$ = "standby", $q_0 \\in Q$ is the initial state and $F \\subseteq Q$ is the set of end states.</p>\n\n<p>How similar is implementing a programming language to implementing a Turing machine? Can it be said that what is done when a programming language is implemented is that a Turing machine like the above is defined? If yes, how come we can\'t just use a model that looks like the definition of a Turing machine when a programming language is defined? Instead something else like BNF seems to be the standard.</p>\n', 'Tags': '<turing-machines><formal-grammars><programming-languages><computation-models>', 'LastEditorUserId': '2980', 'LastActivityDate': '2013-03-11T07:22:24.840', 'CommentCount': '5', 'AcceptedAnswerId': '10344', 'CreationDate': '2013-03-06T23:06:28.763', 'Id': '10338'},20101:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I need to find a context-free grammar for the above expression, $a^{m}b^{n}$ for the set $L = \\left\\{{a, b}\\right\\}$, but I am having difficulty accounting for the condition $m \\neq n$.</p>\n\n<p>This is what I have so far, but it clearly doesn't satisfy the above condition:</p>\n\n<p>$\\begin{align}\n   &amp;S \\rightarrow aAb &amp;\\\\\n   &amp;S \\rightarrow a &amp;\\\\\n   &amp;S \\rightarrow b &amp;\\\\\n   &amp;A \\rightarrow aA &amp;\\\\\n   &amp;A \\rightarrow bA &amp;\\\\\n   &amp;A \\rightarrow \\lambda \\\\\n\\end{align}$</p>\n\n<p>I have spent about an hour on this, and haven't found a solution. Any ideas?</p>\n", 'ViewCount': '56', 'ClosedDate': '2013-03-08T20:41:37.427', 'Title': 'CFG using the set $L =\\left\\{{a,b}\\right\\}$ for the expression $a^{m}b^{n}$, where $m \\neq n$', 'LastActivityDate': '2013-03-08T18:47:40.567', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7195', 'Tags': '<formal-grammars><context-free>', 'CreationDate': '2013-03-08T18:16:51.703', 'Id': '10387'},20102:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve read this part like 3-4 times and I\'m not understanding what is going on. </p>\n\n<p>Let G6 be the following CFG and convert it to Chomsky normal form by using the conversion procedure just given. The series of grammars presented illustrates the steps in the conversion. Rules show in bold have just been added. Rules shown in gray have just been removed.</p>\n\n<p>Specific steps/instructions from the book</p>\n\n<p>1.The original CFG G6 is shown on the left. The result of applying the first step to make a new start variable appears on the right.</p>\n\n<pre><code>S\u2192ASA|aB         S0\u2192S\nA\u2192B|S             S\u2192ASA|aB\nB\u2192b|\u03b5             A\u2192B|S\n                  B\u2192b|\u03b5\n</code></pre>\n\n<p>2.  Remove \u03b5 rules B\u2192\u03b5, shown on the left, and A\u2192\u03b5, shown on the right.</p>\n\n<pre><code>S0\u2192S              S0\u2192S\n S\u2192ASA|aB|**a**        S\u2192ASA|aB|a|**SA|AS|S** from?\n A\u2192B|S|**\u03b5**           A\u2192B|S|\u03b5 \n B\u2192b|**\u03b5**             B\u2192b\n</code></pre>\n\n<p>3a. Remove unit rules S\u2192S, shown on the left, and S0\u2192S, shown on the right.</p>\n\n<pre><code>S0\u2192S                  S0\u2192S|**ASA|aB|a|SA|AS**\n S\u2192ASA|aB|a|SA|AS|S    S\u2192ASA|aB|a|SA|AS \n A\u2192B|S                 A\u2192B|S\n B\u2192b                   B\u2192b\n</code></pre>\n\n<p>3b. Remove unit rules A\u2192B and A\u2192S</p>\n\n<pre><code>S0\u2192ASA|aB|a|SA|AS     S0\u2192ASA|aB|a|SA|AS\n S\u2192ASA|aB|a|SA|AS      S\u2192ASA|aB|a|SA|AS\n A\u2192B|S|**b**           A\u2192S|b|**ASA|aB|a|SA|AS**\n B\u2192b                   B\u2192b\n</code></pre>\n\n<p>4. Convert the remaining rules into the proper form by adding additional variables and rules. The final grammar in Chomsky normal form is equivalent to G6, which follows. (Actually the procedure given in Theorem 2.9 produces several variables Ui, along with several rules Ui\u2192a. We simplified the resulting grammar by using a single variable U and U\u2192a.)</p>\n\n<pre><code>S0\u2192AA1|UB|a|SA|AS\n S\u2192AA1|UB|a|SA|AS\n A\u2192b|AA1|UB|a|SA|AS\nA1\u2192SA\n U\u2192a\n B\u2192b  \n</code></pre>\n\n<p>I don\'t understand why they added the "bold" (** **) items. I also don\'t understand 4. Can someone please explain this to me. Thank you!</p>\n', 'ViewCount': '1417', 'Title': 'CFG to Chomsky normal form', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-11T15:17:49.370', 'LastEditDate': '2013-03-11T15:17:49.370', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'juice', 'PostTypeId': '1', 'Tags': '<formal-grammars><context-free><normal-forms>', 'CreationDate': '2013-03-08T06:48:33.127', 'Id': '10450'},20103:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '74', 'Title': 'Is the following language context free?', 'LastEditDate': '2013-03-12T05:01:27.690', 'AnswerCount': '1', 'Score': '1', 'OwnerDisplayName': 'user979616', 'PostTypeId': '1', 'OwnerUserId': '7151', 'Body': "<p>Is $L = \\{ a^nb^nc^j \\mid n \\le j\\}$ a context-free language? I'm getting really stuck generating a grammar for it. Any help would be appreciated.  </p>\n", 'Tags': '<formal-languages><formal-grammars><context-free>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-03-12T10:50:47.000', 'CommentCount': '1', 'AcceptedAnswerId': '10466', 'CreationDate': '2013-03-11T17:03:44.577', 'Id': '10465'},20104:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '942', 'Title': 'The importance of normal forms like Chomsky normal form for CFGs', 'LastEditDate': '2013-03-12T11:20:21.347', 'AnswerCount': '3', 'Score': '4', 'PostTypeId': '1', 'OwnerUserId': '947', 'FavoriteCount': '0', 'Body': '<p>I understand that context-free grammars can be used to represent context-free languages.It might have ambiguities. We also have normal forms like <a href="https://de.wikipedia.org/wiki/Chomsky-Normalform" rel="nofollow">Chomsky</a> and <a href="https://de.wikipedia.org/wiki/Greibach-Normalform" rel="nofollow">Greibach</a> normal form. I couldn\'t understand the need of that. </p>\n\n<p>Why they are important in the theory of languages? All the textbooks I referred to tell about these normal forms but not telling anything about their importance. </p>\n', 'Tags': '<formal-languages><context-free><formal-grammars><normal-forms>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-29T19:33:05.130', 'CommentCount': '1', 'AcceptedAnswerId': '10478', 'CreationDate': '2013-03-12T06:32:28.983', 'Id': '10468'},20105:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I wrote the following LL(1) grammar to describe the set of boolean expressions involving <code>AND</code> ,<code>OR</code>  an <code>NOT</code> only. This, as can be seen, also reflects the precedence of the operators (ie., 'AND' is done before 'OR', etc).</p>\n\n<p>Is it correct? </p>\n\n<pre><code>    1.  E   ::=  T E\u2019\n    2.  E\u2019  ::= OR T E\u2019\n    3.  E\u2019  ::=  \u03b5\n    4.  T   ::=  F T\u2019\n    5.  T\u2019  ::= AND F T\u2019\n    6.  T\u2019  ::= \u03b5\n    7.  F   ::= NF'\n    8.  N   ::= NOT\n    9.  N   ::= \u03b5\n   10.  F'  ::= (E)\n   11.  F'  ::= id\n</code></pre>\n", 'ViewCount': '1035', 'Title': 'Grammar for describing boolean expressions with AND, OR and NOT', 'LastEditorUserId': '6447', 'LastActivityDate': '2013-04-18T19:07:17.890', 'LastEditDate': '2013-03-19T02:05:26.163', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'OwnerDisplayName': 'user14170', 'PostTypeId': '1', 'Tags': '<formal-grammars><context-free>', 'CreationDate': '2013-03-13T05:00:04.140', 'Id': '10558'},20106:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>This is a question from the Dragon book (I apologize for translation mistakes, I don\xb4t have the English version on hand):</p>\n\n<blockquote>\n  <p>What language is generated by this grammar?</p>\n  \n  <p>$S \\rightarrow a S b S \\mid b S a S  \\mid \\epsilon$</p>\n</blockquote>\n\n<p>I don\'t know what I\'m supposed to do here. The definition in the book about languages says this (and that\'s pretty much it in the chapter): </p>\n\n<blockquote>\n  <p>a language is the set of all words that can be produced by any parse\n  tree.</p>\n</blockquote>\n\n<p>So, if I want to make "any" parse tree out of this grammar, I can recursively keep building it, using just the first two rules. I searched a bit and got the impression that every rule has to be used once, but I\'m not sure. It would be very helpful if someone were able to provide some tips on solving these sorts of problems.</p>\n', 'ViewCount': '1096', 'Title': 'Finding the language generated by a context-free grammar', 'LastEditorUserId': '31', 'LastActivityDate': '2013-03-19T12:05:36.463', 'LastEditDate': '2013-03-19T12:05:36.463', 'AnswerCount': '2', 'CommentCount': '7', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '6520', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-03-18T21:49:48.777', 'Id': '10605'},20107:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am supposed to write a Context free grammar that generates the language:</p>\n\n<p>$\\qquad L(G) = \\{0^{3n}1^{2n}0^{m}1^{m} : n \\ge 1, m \\ge 1\\}$</p>\n\n<p>I have the rules:</p>\n\n<p>$$S \\rightarrow 000S$$\n$$S \\rightarrow S11T$$\n$$T \\rightarrow 0T$$\n$$T \\rightarrow T1$$</p>\n\n<p>This looks correct in terms of the structure of the grammar but I am not sure how to denote how to tell the grammar to terminate at the correct time given the conditions $n \\geq 1$ and $m \\geq 1$.</p>\n', 'ViewCount': '110', 'Title': 'How to write Context Free Grammar with numerical restrictions', 'LastEditorUserId': '98', 'LastActivityDate': '2013-03-28T10:07:30.730', 'LastEditDate': '2013-03-28T10:07:30.730', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7172', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2013-03-27T18:56:54.803', 'Id': '10846'},20108:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>My problem with CFG is, I am to generally create ones that don't have requirements such as:</p>\n\n<p>$\\qquad \\{a^m b^n \\mid m \\le n \\le 2m \\}$</p>\n\n<p>I have no clue where to begin, and how to approach it. I was wondering if you can provide some hints for such daunting problems, along with how to solve that problem.</p>\n\n<p>This is not homework, this is merely me trying to learn it. I solved many problems that did not have such requirements, but those problem are the ones where I am forced to look at the solution.</p>\n", 'ViewCount': '116', 'Title': 'Context free grammar construction', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-02T07:53:53.193', 'LastEditDate': '2013-04-02T07:53:53.193', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '3', 'OwnerDisplayName': 'CSTHEORY', 'PostTypeId': '1', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-03-31T00:16:38.500', 'Id': '10928'},20109:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm a bit confused as to how to represent the Chomsky form for the language L that generates all strings with the alphabet {a}</p>\n\n<p>My approach was</p>\n\n<pre><code>S -&gt; AB | e\nA -&gt; a\n</code></pre>\n\n<p>Now here's the part I'm confused, how do I represent B? If B -> a then I get only even strings, if B -> e then it's not in normal form. :| Any help would be appreciated. </p>\n", 'ViewCount': '30', 'Title': 'Chomsky form for language of single alphabet member', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T11:19:25.227', 'LastEditDate': '2013-04-07T11:19:25.227', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11062', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '7600', 'Tags': '<formal-languages><regular-languages><formal-grammars><normal-forms>', 'CreationDate': '2013-04-05T16:11:19.500', 'Id': '11061'},20110:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '181', 'Title': 'CFG for $\\{a^i b^j : 2 i<j\\}$', 'LastEditDate': '2013-04-06T18:48:36.090', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7613', 'Body': '<p>So I have a question:</p>\n\n<p>Give a CFG for $\\{a^i b^j : 2 i&lt;j\\}$</p>\n\n<p>And this is my approach:</p>\n\n<p>$S\\to AB$</p>\n\n<p>$A\\to aAb\\mid \\varepsilon$</p>\n\n<p>$B\\to b \\mid bB$</p>\n\n<p>A confirmation, or correction, along with how you tested(and tips for testing future of my problems) will be greatly appreciated thanks.</p>\n', 'ClosedDate': '2013-04-06T20:35:05.590', 'Tags': '<context-free><formal-grammars><check-my-answer>', 'LastEditorUserId': '157', 'LastActivityDate': '2013-04-06T20:09:40.777', 'CommentCount': '6', 'AcceptedAnswerId': '11079', 'CreationDate': '2013-04-06T17:55:39.617', 'Id': '11076'},20111:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Some sets of ordered binary trees can be represented as a CFG with rules of the form</p>\n\n<pre><code>A -&gt; aBC\nA -&gt; b\n</code></pre>\n\n<p>Where <code>A,B,C</code> are nonterminals and <code>a</code> and <code>b</code> are terminals representing internal nodes and leaf nodes respectively. The tree can be recovered from any word in the language by a preorder traversal.</p>\n\n<p>The set of all such grammars forms a class of languages which is a subset of context free languages but isomorphic to a superset of regular languages (by unary encoding the alphabet and adding a dummy terminal for the second nonterminal in every production). It is obviously closed under union as you can simply concatenate the lists of productions to get a new tree grammar.</p>\n\n<p>My question is whether this class is closed under intersection. I have been unable to prove that is either closed or not closed, and I figured I should see if anyone else can see how to do this. </p>\n', 'ViewCount': '166', 'Title': 'Closure under intersection of context free binary trees', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-07T22:23:35.630', 'LastEditDate': '2013-04-07T22:05:19.403', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '11115', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '2511', 'Tags': '<context-free><formal-grammars><closure-properties>', 'CreationDate': '2013-04-07T21:12:07.577', 'Id': '11114'},20112:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Considering this FSM:\n<img src="http://i.stack.imgur.com/aIh8C.jpg" alt="finite state machine"></p>\n\n<p>Can someone explain me why the grammar is not:</p>\n\n<ol>\n<li>$S \\rightarrow aA$</li>\n<li>$A \\rightarrow aA \\mid bB \\mid \\varepsilon$</li>\n<li>$B \\rightarrow bB \\mid \\varepsilon$</li>\n</ol>\n\n<p>Why does A not have a transition to $\\varepsilon$?</p>\n', 'ViewCount': '86', 'Title': 'Simple FSM question', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-04-10T11:08:20.773', 'LastEditDate': '2013-04-09T18:35:08.000', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '11167', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1626', 'Tags': '<formal-grammars><finite-automata>', 'CreationDate': '2013-04-09T18:07:59.410', 'Id': '11166'},20113:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '1883', 'Title': 'Convert CFG to PDA', 'LastEditDate': '2013-04-10T08:39:30.413', 'AnswerCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '7405', 'FavoriteCount': '2', 'Body': '<p>Is there any set of rules or methods to convert any context free grammar to a push down automata? </p>\n\n<p>I already found <a href="http://infolab.stanford.edu/~ullman/ialc/spr10/slides/pda2.pdf" rel="nofollow">some slides online</a> but I wasn\'t able to understand them.</p>\n\n<p>In slide 10 he speaks about some rules could anyone explain that?</p>\n', 'Tags': '<context-free><formal-grammars><pushdown-automata><simulation>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-10T08:39:30.413', 'CommentCount': '2', 'AcceptedAnswerId': '11186', 'CreationDate': '2013-04-10T03:00:30.087', 'Id': '11182'},20114:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Is there a formal definition for a size of a context-free grammar? The only definition I have seen so far is on this <a href="http://en.wikipedia.org/wiki/CYK_algorithm#Parsing_non-CNF_context-free_grammars" rel="nofollow">wiki page</a>:</p>\n\n<blockquote>\n  <p>The size of a grammar is the sum of the sizes of its production rules, where the size of a rule is one plus the length of its right-hand side. </p>\n</blockquote>\n\n<p>So, how does one define the size of a production rule\'s RHS? </p>\n\n<p>For example, if I define my CFG as:</p>\n\n<pre><code>S : A\nA : \'a\' B | A\nB : \'b\'\n</code></pre>\n\n<p>What is the size of the production rule A?</p>\n', 'ViewCount': '125', 'Title': 'Size of a context-free grammar', 'LastEditorUserId': '39', 'LastActivityDate': '2013-04-10T20:42:30.067', 'LastEditDate': '2013-04-10T20:42:30.067', 'AnswerCount': '1', 'CommentCount': '10', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7673', 'Tags': '<terminology><formal-grammars>', 'CreationDate': '2013-04-10T16:49:09.827', 'Id': '11195'},20115:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Specifying formal languages by giving formal grammars is a frequent task: we need grammars not only to describe languages, but also to parse them, or even <a href="http://scholar.google.com/scholar?q=secondary%20structure%20prediction%20stochastic%20grammars" rel="nofollow">do proper science</a>. In all cases, it is important that the grammar at hand is <em>correct</em>, that is generates exactly the desired words.</p>\n\n<p>We can often argue on a high-level why the grammar is an adequate representation of the desired language, omitting a formal proof. But what if we are in doubt or need a formal proof for some reason? What are techniques we can apply?</p>\n\n<p><sup>This is supposed to become a <a href="http://meta.cs.stackexchange.com/questions/599/reference-questions">reference question</a>. Therefore, please take care to give general, didactically presented answers that are illustrated by at least one example but nonetheless cover many situations. Thanks!</sup></p>\n', 'ViewCount': '417', 'Title': 'How to show that L = L(G)?', 'LastEditorUserId': '6716', 'LastActivityDate': '2013-06-06T13:55:49.570', 'LastEditDate': '2013-06-06T13:55:49.570', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '98', 'Tags': '<formal-languages><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-04-14T19:02:14.270', 'Id': '11315'},20116:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider such a rule in grammar for an LR-family parsing generator (e.g YACC, BISON, etc.):</p>\n\n<p><code>Nonterminal : [ lookahead not in {Terminal1, ..., TerminalN} ] Rule ;</code></p>\n\n<p>It's an ordinary rule, except that it has a restriction: a phrase produced with this rule cannot begin with <code>Terminal1, ..., TerminalN</code>. (Surely, this rule can be replaced with a set of usual rules, but it will result in a bigger grammar). This can be useful for resolving conflicts.</p>\n\n<p>The question is, is there a modification of LR table construction algorithm that accepts such restrictions? It seems to me that such a modification is possible (like precedence relations).</p>\n\n<p>Surely, it can be checked in runtime, but I mean compile-time check (a check which is performed while building parsing table, like <code>%prec</code>, <code>%left</code>, <code>%right</code> and <code>%nonassoc</code> directives in yacc-compartible generators.)</p>\n", 'ViewCount': '68', 'Title': 'Negative lookahead in LR parsing algorithm', 'LastActivityDate': '2013-04-20T18:43:21.803', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6564', 'Tags': '<formal-grammars><parsers>', 'CreationDate': '2013-04-20T18:43:21.803', 'Id': '11437'},20117:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following CFG,</p>\n\n<p>$S \\rightarrow CB$<br>\n$C \\rightarrow aCa \\text{ }|\\text{ } bCb \\text{ }|\\text{ } \\text{#}B$<br>\n$B \\rightarrow AB \\text{ }|\\text{ } \\varepsilon$<br>\n$A \\rightarrow a\\text{ }|\\text{ }b$</p>\n\n<p>This is the CFG for the following language:</p>\n\n<p>$$L= \\left\\{w \\text{#} x\\mid w^R \\text{ is a substring of }\\ x \\text{, where }  x,w\\in \\{a, b\\}^*\\right \\}$$</p>\n\n<p>I have a problem with constructing PDA for this CFG.</p>\n\n<p><strong>My attempt</strong></p>\n\n<p>My idea was to store characters in stack until "#" character, then as soon as the sequence of reversed characters go, pop from the stack. If at the end of input stack is empty, then we are done.</p>\n\n<p>The problem is that for the following string, for example:</p>\n\n<p>abbaa#aabbbbbbb(aabba)bbbbbb</p>\n\n<p>when we read characters after "#", PDA will pop 4 characters, the it will see that the sequence is not valid and proceed with input. How can I return these 4 characters back so that I can check sequence again because I need full stack to proceed with accepted reversed substring that I have showed in brackets?</p>\n', 'ViewCount': '406', 'Title': 'Converting CFG to PDA', 'LastEditorUserId': '98', 'LastActivityDate': '2013-04-21T14:39:44.393', 'LastEditDate': '2013-04-21T14:39:44.393', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '11447', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7809', 'Tags': '<context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2013-04-20T20:26:38.457', 'Id': '11441'},20118:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When I see a problem like "Write a grammar for a language $L$ if $L = \\{..\\}$" for me is a matter of "instinct" the way that one can define productions. For example given the following exercise:</p>\n\n<blockquote>\n  <p>Let $L$ a language which alphabet is $\\{x,y,z\\}$ and accepts strings\n  $w$ where there aren\'t consecutive $x$\'s nor consecutive $y$\'s nor\n  consecutive $z$\'s.</p>\n</blockquote>\n\n<p>My first aproaching was to stablish that $x$, $y$ and $z$ each one are in $L$, that is:</p>\n\n<p>$$S \\rightarrow x \\mid y \\mid z$$</p>\n\n<p>If the string has an $x$, there can be a consecutive $y$ or $z$, similarly for the other symbols. I assume that there are productions $A$, $B$ and $C$ that make the work, so the start production is:</p>\n\n<p>$$S \\rightarrow xA\\mid yB\\mid zC\\mid x\\mid y\\mid z$$</p>\n\n<p>Therefore $S$ can be splitted to define $A$, $B$ and $C$:</p>\n\n<p>$\\begin{eqnarray*}S &amp;\\rightarrow&amp; A \\mid  B \\mid  C \\\\A &amp;\\rightarrow&amp;  yB \\mid  zC \\mid  y \\mid  z \\\\ B &amp;\\rightarrow&amp;  xA \\mid  zC \\mid  x \\mid  z\\\\ C &amp;\\rightarrow&amp;  xA \\mid  yB \\mid  x \\mid  y \\end{eqnarray*}$</p>\n\n<p>But as you all can see this is just my version, I started with base strings accepted by $L$ and then I followed my own thought of how to build the grammar. Is there a easy way to do this? or some advice for similar languages? (like those which have different number of symbols).</p>\n', 'ViewCount': '169', 'Title': 'Easiest way to write a grammar?', 'LastEditorUserId': '31', 'LastActivityDate': '2013-05-05T23:08:41.513', 'LastEditDate': '2013-05-05T18:59:00.350', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '11812', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7492', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2013-05-05T18:39:32.883', 'Id': '11810'},20119:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>So, I have a book here, which has an example for context sensitive grammar, and the grammar is the famous $0^n1^n2^n$ , and it has:</p>\n\n<p>$$ \\begin{align}\nS  &amp;\\rightarrow 0BS2 \\mid 012 \\\\\nB0 &amp;\\rightarrow 0B \\\\\nB1 &amp;\\rightarrow 11 \\\\\n\\end{align} $$</p>\n\n<p>I agree that the above works, but what is wrong with just saying:\n$S\\rightarrow 0S12 |\\epsilon$</p>\n\n<p>The above also generators the same number of $0$s as $1$s and $2$s.</p>\n', 'ViewCount': '60', 'Title': 'Can this grammar be simplified?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-05-19T14:56:16.890', 'LastEditDate': '2013-05-19T14:56:16.890', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8104', 'Tags': '<formal-languages><formal-grammars><context-sensitive>', 'CreationDate': '2013-05-17T18:13:47.270', 'Id': '12090'},20120:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Exactly as stated in the subject. I look for grammar which use letters $a, b ,c$ that numbers of letters $c$ is greater than number of letters $b$.</p>\n\n<p>Example: $acbccba$ is generated by the grammar.</p>\n\n<p>I thought about:</p>\n\n<p>$S \\rightarrow aS \\mid bS \\mid SCS$</p>\n\n<p>$ C \\rightarrow cb \\mid ca$</p>\n\n<p>but not sure if it works. Could you help me, please.</p>\n', 'ViewCount': '207', 'Title': 'Grammar that numbers of letters `c` is greater than number of letters `b`', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-12-07T12:49:27.610', 'LastEditDate': '2013-05-21T13:10:00.820', 'AnswerCount': '5', 'CommentCount': '8', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8277', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-05-21T08:30:31.687', 'FavoriteCount': '0', 'Id': '12179'},20121:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '25', 'Title': 'Grammar that contains letters a,b,c and number of letters $c$ is greater than number of letters $b$', 'LastEditDate': '2013-05-21T16:36:19.717', 'AnswerCount': '0', 'Score': '0', 'OwnerDisplayName': 'Robert Kilar', 'PostTypeId': '1', 'OwnerUserId': '8277', 'FavoriteCount': '0', 'Body': '<p>I look for grammar which use letters $a,b,c$ that numbers of letters $c$ is greater than number of letters $b$.</p>\n\n<p>Example: $acbccba$</p>\n\n<p>I thought about:</p>\n\n<p>$$S \\rightarrow aS \\mid bS \\mid SCS$$\n$$C \\rightarrow cb \\mid ca$$</p>\n\n<p>but not sure if it work. Could you help me, please.</p>\n', 'ClosedDate': '2013-05-21T17:21:00.393', 'Tags': '<formal-grammars>', 'LastEditorUserId': '7492', 'LastActivityDate': '2013-05-21T16:36:19.717', 'CommentCount': '0', 'CreationDate': '2013-05-21T08:07:41.857', 'Id': '12186'},20122:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How can I deal with recursive terminals in CFG when converting it to CNF? For example,</p>\n\n<p>S -> MN</p>\n\n<p>M -> AM | A</p>\n\n<p>N -> BN | B</p>\n\n<p>A -> a</p>\n\n<p>B -> b</p>\n\n<p>How can I reduce terminals M and N?</p>\n', 'ViewCount': '95', 'Title': 'CNF: Recursion in CFG', 'LastActivityDate': '2013-05-23T11:33:44.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7809', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-05-22T23:30:34.303', 'Id': '12221'},20123:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>It's a school assignment:\nThe problem is:\nWrite a BN grammar for +67.</p>\n\n<p>The given solution I have been given is following:</p>\n\n<pre><code>&lt;digit&gt;  ::= 6 | 7\n&lt;number&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;number&gt;\n&lt;+67&gt;    ::= + &lt;number&gt;\n</code></pre>\n\n<p>My question is, when given this simple task, could it be derived like this?</p>\n\n<pre><code>&lt;digit&gt;  ::= 6 | 7\n&lt;number&gt; ::= &lt;digit&gt; &lt;digit&gt; \n&lt;+67&gt;    ::= + &lt;number&gt;\n</code></pre>\n\n<p>More precisely, can I use same non-terminal twice in same rule?</p>\n", 'ViewCount': '52', 'Title': 'Is it legal to use non-terminal twice in Backus-Naur grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-02T22:57:12.397', 'LastEditDate': '2013-06-02T22:57:12.397', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '12419', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8479', 'Tags': '<terminology><formal-grammars>', 'CreationDate': '2013-06-01T19:59:00.613', 'Id': '12418'},20124:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '171', 'Title': 'What does the R superscript notation mean in regular/formal languages?', 'LastEditDate': '2013-06-02T03:05:54.667', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8482', 'FavoriteCount': '1', 'Body': "<p>What does the capital R superscript notation mean in regular languages?  I am working on a homework assignment and don't recall my professor mentioning what the what the R superscript means.  For example in this syntax:</p>\n\n<p>$L = \\{ww^R\\mid w \\in \\Sigma^{\\ast} \\}$</p>\n", 'Tags': '<formal-languages><regular-languages><formal-grammars><notation>', 'LastEditorUserId': '1636', 'LastActivityDate': '2013-06-02T03:05:54.667', 'CommentCount': '0', 'AcceptedAnswerId': '12422', 'CreationDate': '2013-06-02T02:11:28.330', 'Id': '12421'},20125:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I want to prove that grammar\n$$\n\\begin{cases}\nS'\\rightarrow S\\\\\nS\\rightarrow aSb ~|~ A\\\\\nA\\rightarrow bA~|~b\n\\end{cases}\n$$\nisn't $LR(1)$. I've constructed parser table and got Shift-Reduce conflict.</p>\n\n<p>I want to prove that without parser table, using another $LR(1)$ definition.</p>\n\n<p>Here's definition:\nGrammar is $LR(1)$, if from</p>\n\n<ol>\n<li>$S' \\Rightarrow^*_r uAw \\Rightarrow_r uvw$</li>\n<li>$S' \\Rightarrow^*_r zBx \\Rightarrow_r uvy$</li>\n<li>$FIRST(w) = FIRST(y)$</li>\n</ol>\n\n<p>$\\Rightarrow uAy=zBx.$</p>\n\n<p>So how can prove that?</p>\n", 'ViewCount': '138', 'Title': "How to prove formally that grammar isn't LR(1)", 'LastActivityDate': '2013-06-05T15:25:57.933', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '12472', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8530', 'Tags': '<formal-grammars><parsers>', 'CreationDate': '2013-06-05T12:01:44.743', 'Id': '12470'},20126:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>This is a question from <a href="http://cs.anu.edu.au/courses/COMP3630/comp3630exams.pdf" rel="nofollow">a 2007 exam paper for a course I\'m studying</a>, question 2 on page 2.</p>\n\n<blockquote>\n  <p>Theorem: Let $L$ be a context-free language. Let $L_{even}$ be the subset of $L$ consisting of all the strings in $L$ that have even length. Then $L_{even}$ is context-free.</p>\n</blockquote>\n\n<p>The question is to prove this theorem using two of three different methods: using grammars, PDAs, or a theorem about language intersections.</p>\n\n<p>I can very easily find a proof using PDAs (maintain your current odd/even status using the stack), and intersections (intersect with $\\Sigma^*_{even}$, which is regular) - but I can\'t think of how to do it using properties of grammars. I suspect either Chomsky or Greibach Normal Forms comes in handy here but I\'m not sure how.</p>\n', 'ViewCount': '89', 'Title': 'Proving that CFLs are closed under even-ness using grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2013-06-10T10:36:08.340', 'LastEditDate': '2013-06-10T10:33:55.813', 'AnswerCount': '2', 'CommentCount': '6', 'AcceptedAnswerId': '12557', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8591', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties>', 'CreationDate': '2013-06-09T02:53:21.853', 'Id': '12554'},20127:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following formal grammar: $$G= (\\{S,A,B\\},\\{a,b\\},R,S)$$ $$R=\\{S \\rightarrow A\\ |B, A \\rightarrow \\varepsilon\\ | aA\\ |bA, B \\rightarrow \\varepsilon\\ |Bb\\ | b\\}$$</p>\n\n<p>Now, we see, the production rules $A \\rightarrow \\varepsilon$ and  $B \\rightarrow \\varepsilon$ implies that this grammar is not context-sensitiv ($CSG$). But on the other hand, we see this grammar satisfies the conditions for a context-free ($CFG$) grammar, because every production rule has just one NON-terminal on the left side.</p>\n\n<p>We know, according to the Chomsky hierarchy, a contest-free grammar imples a contest-sensitive grammar: $CFG \\implies CSG$</p>\n\n<p>Now i am confused, is my grammar context-free or it is not, even if it satisfies the conditions? Can it be $CFG$ without being $CSG$?</p>\n', 'ViewCount': '291', 'Title': 'Is this formal grammar context-free (CFG) but not context-sensitive (CSG)?', 'LastActivityDate': '2013-06-11T19:48:57.843', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '12627', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '6828', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-06-11T13:48:24.840', 'Id': '12620'},20128:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m looking for an algorithm to construct a grammar which, given a set of words which can have multiple identical symbols, represents a compressed version of this set, that is, I can generate only the words of the set but the grammar will take less memory than the set himself.</p>\n\n<p>Besides, I\'m looking for an algorithm which can update the grammar when I want to remove a word of the set.</p>\n\n<p>What type of algorithm is able to do that ?</p>\n\n<p>I give a concrete example:</p>\n\n<p>Consider a string S="abcdefghij", and then consider the finite set of words "cdhij", acdef", "fghi", "bcfgij", "defi".</p>\n\n<p>I would like to construct a grammar which generates only this set of words (words which can be viewed as concatenation of various substrings of any length from the original string S).</p>\n\n<p>Finally I would like to remove a word in the set and update subsequently the grammar.</p>\n\n<p>Thank you.</p>\n', 'ViewCount': '62', 'Title': "I'm lookin for a method to construct a particular grammar?", 'LastEditorUserId': '8767', 'LastActivityDate': '2013-07-21T22:29:26.490', 'LastEditDate': '2013-06-21T08:44:21.090', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8767', 'Tags': '<context-free><formal-grammars><tree-grammars>', 'CreationDate': '2013-06-20T08:04:48.473', 'Id': '12782'},20129:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am not entirely sure if the title is the correct way to phrase what is occurring. There is a recurring process which I decided to attempt to model using production rules similar to those used in a context-free grammar.</p>\n\n<p>The real world process is a production line. It takes 1 unit, after 2 weeks, produces 1 unit, after 4 weeks, that unit will produce another unit - and also 2 of the starting units. After 4 weeks the "another unit" will produce "that unit" - and also 3 of the starting units. This continues semi indefinitely, but the range I am looking at is roughly 52 weeks.</p>\n\n<p>I came up with this model of production rules</p>\n\n<p>$S\\rightarrow A$</p>\n\n<p>$A\\rightarrow S^2B$</p>\n\n<p>$B\\rightarrow S^3A$</p>\n\n<p>I attempted to expand this so that I could formulate a generating function and solve for n=52 (52 being the 1 year mark).</p>\n\n<p>$S$,$A$,$S^2B$,$S^5A$,$S^7B$, ...</p>\n\n<p>However, I was unable to determine if I was taking the correct approach to solving this situation. I believe that an error here lies in the fact that the duration of time is ignored. Namely that from $S\\rightarrow A$ 2 weeks elapse, from $A\\rightarrow S^2B$ 4 weeks elapse, and from $B\\rightarrow S^3A$ 4 weeks elapse.</p>\n\n<p>In order to better understand this situation, I decided to code an example so I could at least see the totals. However, it did not lend itself to producing a summation function.</p>\n\n<p>So, given all this, how is it possible to come up with a summation function instead of having to manually iterate through it like this c# approach does? Or, is there a similar/alternate approach to modeling this which will allow an easier summation process?</p>\n\n<p>Please feel free to correct any misunderstandings I may have.</p>\n\n<p><strong>edits</strong></p>\n\n<p>For example:</p>\n\n<p>Week 1: We have 1 unit (S). It sits for 2 weeks until it is ready to become 1 of the next type(A).</p>\n\n<p>Week 3: The first unit is now here. It sits for 4 weeks until it is ready to become 1 of the next type(A). At that time, it also becomes 2 of the first type(S).</p>\n\n<p>Week 7: The unit from Week 3 has now become 2 of the first type of unit(S). It also created 1 of the second type(A). The 2 units of type S will now sit for 2 weeks until they make 2 units of type A. The 1 unit of type A will now sit for 4 weeks until it makes 1 unit of type B and 2 units of type S.</p>\n\n<p>Week 9: The 2 units of type S from week 7 have now sat for 2 weeks. Now they have become 2 units of type A. These two units of type A will sit for 4 weeks and produce 4 units of type S and 2 units of type B.</p>\n\n<p>Week 11: The 1 unit of type A from week 7 has now sat for 4 weeks and has now made 1 unit of type B and 2 units of type S. The 1 unit of type B will sit for 4 weeks and then make 1 unit of type A and 3 units of type S. The 2 units of type S will now sit for 2 weeks and make 2 units of type A.</p>\n\n<p>Also, the 2 units of type S from week 9 have now sat for 2 weeks and become 2 units of type A. These two units will sit for 4 weeks and become 2 units of type B and will also become 6 units of type S.</p>\n\n<p>etc.</p>\n\n<p>This can perhaps be represented by a series of recurring relations</p>\n\n<p>$s(n) = a(n) + b(n) + c(n)$</p>\n\n<p>$a(n) = 2*b(n-4) + 3*c(n-4)$</p>\n\n<p>$b(n) = a(n-2) + c(n-4)$</p>\n\n<p>$c(n) = b(n-4)$</p>\n\n<p>where</p>\n\n<p>$s(n) = a(n) = b(n) = c(n) = 0$ for $n &lt; 1$</p>\n\n<p>$a(1) = 1$</p>\n', 'ViewCount': '86', 'Title': 'How can I produce a summation function from this set of production rules for a grammar?', 'LastEditorUserId': '9118', 'LastActivityDate': '2013-07-30T13:33:51.537', 'LastEditDate': '2013-07-11T18:54:36.783', 'AnswerCount': '3', 'CommentCount': '0', 'AcceptedAnswerId': '13216', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9118', 'Tags': '<context-free><formal-grammars><combinatorics>', 'CreationDate': '2013-07-10T19:39:52.290', 'Id': '13213'},20130:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I just not sure does empty set have a context-free grammar in Chomsky normal form?</p>\n\n<p>That is, for $B=\\emptyset$, then a context-free grammar is $S \\to S$, I think which doesn't have a Chomsky normal form. I am not sure. Can some one explain?</p>\n", 'ViewCount': '227', 'Title': 'Does the empty language have a CFG in CNF?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-12T10:58:36.480', 'LastEditDate': '2013-07-12T10:52:16.447', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'OwnerDisplayName': 'user67584', 'PostTypeId': '1', 'OwnerUserId': '8601', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-07-10T03:51:41.247', 'Id': '13235'},20131:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'m looking for a context-sensitive grammar that describes the following language: \n$L = \\{ ww \\mid w \u2208 \\{a,b\\}^{\\ast}, |w| \u2265 1\\}$ .</p>\n\n<p>I\'ve got problems with the fact that no rules such as $X \\to \\varepsilon$ are allowed and therefore I can\'t place any nonterminal indicating the "middle" of the word. Is there any trick to the problem? </p>\n', 'ViewCount': '147', 'Title': 'Context-sensitive grammar for the language of words concatenated with themselves', 'LastEditorUserId': '98', 'LastActivityDate': '2013-07-31T11:23:29.890', 'LastEditDate': '2013-07-19T10:47:36.873', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '9231', 'Tags': '<formal-languages><formal-grammars><context-sensitive>', 'CreationDate': '2013-07-18T06:25:58.770', 'FavoriteCount': '1', 'Id': '13327'},20132:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>I\'ve written a recursive-descent parser generator, and I\'m trying to classify it (call me a cowboy coder if you must). According to wikipedia, <code>S \u2192 0S0 | 1S1 | \u03b5</code>, which checks for an even-length palindrome, is a non-deterministic grammar. My parser generator can handle this grammar. Does that mean my parser is non-deterministic?</p>\n\n<p>To be honest, I\'m not even sure that it\'s proper to try to classify it like this. It doesn\'t really match the description of a pushdown automata, since it passes data up and down through the stack (parameters, passed by reference, which may be modified). If anyone would be interested in taking a closer look at it, I\'d be most grateful. It handles left recursion and ambiguous grammars in (I believe) polynomial time and space. <a href="https://github.com/coder0xff/parlex" rel="nofollow">https://github.com/coder0xff/parlex</a></p>\n', 'ViewCount': '177', 'Title': 'If a parser can parse a non-deterministic grammar, is the parser non-deterministic?', 'LastActivityDate': '2013-07-22T18:51:39.117', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '13395', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8233', 'Tags': '<formal-grammars><pushdown-automata><parsers>', 'CreationDate': '2013-07-22T17:38:48.407', 'Id': '13393'},20133:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm reading the book: <em>Formal Syntax and Semantics of Programming Languages</em>. I don't understand this exercise:</p>\n\n<blockquote>\n  <p>Consider the following two grammars, each of which generates strings of correctly balanced parentheses and brackets. Determine if either or both is ambiguous. The Greek letter \u03b5 represents an empty string.</p>\n\n<pre><code>&lt;string&gt; ::= &lt;string&gt; &lt;string&gt; | ( &lt;string&gt; ) | [ &lt;string&gt; ] | \u03b5\n&lt;string&gt; ::= ( &lt;string&gt; ) &lt;string&gt; | [ &lt;string&gt; ] &lt;string&gt; | \u03b5\n</code></pre>\n</blockquote>\n", 'ViewCount': '135', 'Title': 'Determine if two grammars for the same language are ambiguous', 'LastEditorUserId': '4249', 'LastActivityDate': '2013-08-12T08:46:36.553', 'LastEditDate': '2013-08-11T19:28:59.790', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '13718', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9615', 'Tags': '<context-free><formal-grammars><ambiguity>', 'CreationDate': '2013-08-11T19:12:20.367', 'Id': '13711'},20134:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Considering a grammar that includes a dictionary or list with an optional terminal separator - e.g.: </p>\n\n<p>$$ \n\\begin{align} \nobj \\to    &amp; dict  \\\\   \n           &amp;\\mid OTHER  \\\\ \ndict \\to   &amp; \\{ \\quad \\}  \\\\ \n           &amp; \\mid \\{ \\quad pairs \\quad \\} \\\\ \npairs \\to  &amp; pair \\quad ,?  \\\\\n           &amp; \\mid pair \\quad , \\quad pairs  \\\\ \npair \\to   &amp; PAIR\n\\end{align}\n$$</p>\n\n<p>My understanding is that the above is <strong>not</strong> an LL(1) grammar because there are productions with FIRST() sets\ncrossing over.</p>\n\n<p>But what if we convert it to the following:</p>\n\n<p>$$ \n\\begin{align} \nobj \\to    &amp; dict  \\\\   \n           &amp;\\mid OTHER  \\\\ \ndict \\to     &amp; \\{ \\quad dictrest \\\\\ndictrest \\to &amp; \\}  \\\\    \n             &amp; \\mid pair \\quad pairseq \\quad ,? \\quad \\}  \\\\\npairseq \\to  &amp; \\varepsilon \\\\\n             &amp; \\mid , \\quad pair \\quad pairseq \\\\\npair \\to   &amp; PAIR\n\\end{align}\n$$</p>\n\n<p>Is this latter version LL(1)?</p>\n', 'ViewCount': '64', 'Title': 'Representing grammar for list/dictionary with optional end separator as LL(1)', 'LastActivityDate': '2013-08-13T14:40:27.497', 'AnswerCount': '1', 'CommentCount': '3', 'AcceptedAnswerId': '13735', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '9637', 'Tags': '<formal-grammars><parsers>', 'CreationDate': '2013-08-13T13:52:57.563', 'Id': '13733'},20135:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Having:</p>\n\n<p>$\\qquad \\begin{align}\n    S &amp;\\to aT \\\\\n    T &amp;\\to a \\mid UTV \\\\\n    U &amp;\\to ab \\mid ba \\\\\n    V &amp;\\to ac \\mid ca\n\\end{align}$</p>\n\n<p>What language would be generated by this? </p>\n\n<p>How can I obtain an $LL(1)$ grammar using factorisation?</p>\n\n<p>I've tried a number of combinations but do not get how to represent the UTV part:</p>\n\n<p>Something like a|ab|ba|ac|ca|aa|a(ab|ba)^n a(ac|ca)^n</p>\n", 'ViewCount': '68', 'Title': 'Grammar to Language', 'LastEditorUserId': '39', 'LastActivityDate': '2013-08-26T05:26:24.020', 'LastEditDate': '2013-08-24T08:32:35.643', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9801', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2013-08-23T15:57:02.367', 'Id': '13890'},20136:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am reading <a href="http://gnuu.org/2009/09/18/writing-your-own-toy-compiler/3/" rel="nofollow">this</a> article about compiler. I am facing some problem in understanding the content of the token file. Specifically, what is the meaning of the following lines: </p>\n\n<pre><code>    [ \\t\\n]                 ;\n    [a-zA-Z_][a-zA-Z0-9_]*  SAVE_TOKEN; return TIDENTIFIER;\n    [0-9]+\\.[0-9]*          SAVE_TOKEN; return TDOUBLE;\n    [0-9]+                  SAVE_TOKEN; return TINTEGER;\n</code></pre>\n\n<p>What is * and + at the end of the expressions ?</p>\n\n<p>Thanks in advance for explaining me.  </p>\n', 'ViewCount': '66', 'Title': 'Trying to understand a token file for lexical analysis', 'LastEditorUserId': '98', 'LastActivityDate': '2013-08-26T08:24:05.363', 'LastEditDate': '2013-08-26T08:06:35.300', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '6466', 'Tags': '<terminology><formal-grammars><compilers>', 'CreationDate': '2013-08-24T14:25:23.360', 'Id': '13909'},20137:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Definitions:</p>\n\n<ul>\n<li><em>Alphabet</em> $\u03a3$: finite, non-empty set</li>\n<li><em>Language</em>: subset of $\u03a3^*$</li>\n<li><em>Grammar</em>: <a href="http://en.wikipedia.org/wiki/Unrestricted_grammar" rel="nofollow">Unrestricted grammar (Chomsky Type 0)</a></li>\n<li><em>Language of a grammar</em>: all words that can be produced by applying $P$ multiple times, starting from $S$</li>\n</ul>\n\n<p>Grammars are finite, therefore there are only countable infinite of them. But there are uncountably infinite many languages. Each grammar can only describe one language. Therefore, there are <strong>languages without grammars</strong>.</p>\n\n<p>Can you give an <strong>example</strong> for such a language without grammar?</p>\n\n<p>I searched the internet, but strangely, I could not even find the question in context of formal language.</p>\n', 'ViewCount': '136', 'Title': 'Formal language without grammar', 'LastEditorUserId': '9827', 'LastActivityDate': '2013-08-26T20:09:51.233', 'LastEditDate': '2013-08-26T20:09:51.233', 'AnswerCount': '3', 'CommentCount': '4', 'AcceptedAnswerId': '13936', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9827', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-08-25T16:39:41.640', 'Id': '13923'},20138:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is a question that I encountered in one of my exams:</p>\n\n<blockquote>\n  <p>Find one context-free grammar that recognizes the language:\n  $\\qquad L = \\{a^n(b^mc^m)^pd^n \\mid m, n, p \\geq 0\\} $</p>\n</blockquote>\n\n<p>Can you find such a grammar? I even doubt its existence, but I have not been able to prove that. </p>\n', 'ViewCount': '208', 'Title': 'Does this language have a context-free grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-09-16T08:07:16.830', 'LastEditDate': '2013-09-16T08:06:35.013', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10135', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-09-14T12:32:22.343', 'Id': '14305'},20139:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>What are the common ways to check if a given language is regular, context free, or context sensitive?</p>\n\n<p>Any surveys or notes would also be helpful. There's no need to describe your suggestions. \neg. it is sufficient to say a language is regular if it can be recognized by a DFA.</p>\n", 'ViewCount': '77', 'ClosedDate': '2013-09-20T15:23:50.653', 'Title': 'Class of a Language', 'LastActivityDate': '2013-09-19T07:26:47.073', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10214', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-09-19T01:51:19.630', 'Id': '14428'},20140:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>If a language is decidable, we can write a method that always halts and returns <code>true</code> for each string that is an element of the language and <code>false</code> otherwise.</p>\n\n<p>If a language is undecidable, what does that mean? Does it mean:</p>\n\n<p>a.) We cannot write a method; we cannot even conceive of a method.</p>\n\n<p>b.) We can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely.</p>\n\n<p>c.) Other (what?)</p>\n', 'ViewCount': '111', 'Title': 'Can a method be written if the language is undecidable?', 'LastActivityDate': '2013-09-21T17:08:19.787', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '14501', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<formal-grammars><undecidability><decision-problem><halting-problem><turing-completeness>', 'CreationDate': '2013-09-21T16:43:09.593', 'Id': '14499'},20141:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>A type-0 grammar generates a recursively enumerable (RE) language. </p>\n\n<p>A RE language is also known as a semi-decidable language. </p>\n\n<p>A semi-decidable language is a particular kind of undecidable language: If a language is semi-decidable, we can write a method that returns <code>true</code> for each string that is an element of the language; for strings that are not an element of the language, the method may return <code>false</code> or it may loop indefinitely. </p>\n\n<p>Problem: Provide an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>Answer (I think): The following grammar generates this language: </p>\n\n<pre><code>(a+b+) union (infinite a's)\n</code></pre>\n\n<p>Here is the grammar:</p>\n\n<pre>\nS &rarr; aA | bE\nA &rarr; aA | bB\nB &rarr; bB | &epsilon; | aE\nbE &rarr; aE \nE &rarr; aE\n</pre>\n\n<p>A method for recognizing strings in the language generated by this grammar would return true for strings that are an element of a+b+ and would run indefinitely for strings that are not an element of a+b+</p>\n\n<p>I think that this is an example of a type-0 grammar which generates a language that is not context-sensitive (i.e., not decidable). </p>\n\n<p>If I am incorrect, would you provide an example please?</p>\n", 'ViewCount': '73', 'Title': 'Is this an example of a type-0 grammar that is not context-sensitive?', 'LastActivityDate': '2013-09-21T20:01:25.747', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '9907', 'Tags': '<computability><turing-machines><formal-grammars><undecidability><linear-bounded-automata>', 'CreationDate': '2013-09-21T20:01:25.747', 'FavoriteCount': '1', 'Id': '14503'},20142:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<ul>\n<li>Given any <em>Context-Free-Grammar, $G$</em>, and another in <em>Chomsky Normal Form, $G_c$</em>, how can we check if both $G$ and $G_c$ generate the same language?</li>\n</ul>\n\n<p>One of the trivial ways I know of is to convert $G$ into a CNF form. which motivates my second question,</p>\n\n<ul>\n<li>Can two different <em>Context-Free-Grammars</em> in CNF, $G_c$ and $G_c^\\prime$, generate the same language? (I would appreciate a proof of it)</li>\n</ul>\n', 'ViewCount': '77', 'Title': 'Equivalence of Context-Free-Grammar and Context-Free-Grammar in CNF', 'LastActivityDate': '2013-09-22T11:13:46.963', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '9736', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-09-22T09:22:18.547', 'FavoriteCount': '1', 'Id': '14513'},20143:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '165', 'Title': 'How is non-ambuiguity different from determinism?', 'LastEditDate': '2013-09-26T09:15:33.267', 'AnswerCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10314', 'FavoriteCount': '1', 'Body': '<p>I am trying to understand what is meant by "deterministic" in expressions such as "deterministic context-free grammar". (There are more deterministic "things" in this field). I would appreciate an example more then the most elaborate explanation! If possible.</p>\n\n<p>My primary source of confusion is from not being able to tell how this property of a grammar is different from (non-)ambiguity.</p>\n\n<p>The closest I got to finding what it means is this quote from the paper by D. Knuth <em>On the Translation of Languages from Left to Right</em>:</p>\n\n<blockquote>\n  <p>Ginsburg and Greibach (1965) have defined the notion of a\n  deterministic language; we show in Section V that these are precisely\n  the languages for which there exists an L R ( k ) grammar</p>\n</blockquote>\n\n<p>which becomes circular as soon you get to the <code>Section V</code>, because there it says that what LR(k) parser can parse is the deterministic language...</p>\n\n<hr>\n\n<p>Below is an example that I could find to help me understand what "ambigous" means, please take a look:</p>\n\n<pre><code>onewartwoearewe\n</code></pre>\n\n<p>Which can be parsed as <code>one war two ear ewe</code> or <code>o new art woe are we</code> - if a grammar allows that (say it has all the words I just listed).</p>\n\n<p>What would I need to do to make this example language (non-)deterministic? (I could, for example, remove the word <code>o</code> from the grammar, to make the grammar not ambiguous).</p>\n\n<p>Is the above language deterministic?</p>\n\n<p><em>PS. The example is from the book Godel, Esher, Bach: Eternal Golden Braid.</em></p>\n\n<hr>\n\n<p>Let\'s say, we define the grammar for the example language like so:</p>\n\n<pre><code>S -&gt; A \'we\' | A \'ewe\'\nA -&gt; B | BA\nB -&gt; \'o\' | \'new\' | \'art\' | \'woe\' | \'are\' | \'one\' | \'war\' | \'two\' | \'ear\'\n</code></pre>\n\n<p>By the argument about having to parse the whole string, does this grammar make the language non-deterministic?</p>\n\n<hr>\n\n\n\n<pre><code>let explode s =\n  let rec exp i l =\n    if i &lt; 0 then l else exp (i - 1) (s.[i] :: l) in\n  exp (String.length s - 1) [];;\n\nlet rec woe_parser s =\n  match s with\n  | \'w\' :: \'e\' :: [] -&gt; true\n  | \'e\' :: \'w\' :: \'e\' :: [] -&gt; true\n  | \'o\' :: x -&gt; woe_parser x\n  | \'n\' :: \'e\' :: \'w\' :: x -&gt; woe_parser x\n  | \'a\' :: \'r\' :: \'t\' :: x -&gt; woe_parser x\n  | \'w\' :: \'o\' :: \'e\' :: x -&gt; woe_parser x\n  | \'a\' :: \'r\' :: \'e\' :: x -&gt; woe_parser x\n  (* this line will trigger an error, because it creates \n     ambiguous grammar *)\n  | \'o\' :: \'n\' :: \'e\' :: x -&gt; woe_parser x\n  | \'w\' :: \'a\' :: \'r\' :: x -&gt; woe_parser x\n  | \'t\' :: \'w\' :: \'o\' :: x -&gt; woe_parser x\n  | \'e\' :: \'a\' :: \'r\' :: x -&gt; woe_parser x\n  | _ -&gt; false;;\n\nwoe_parser (explode "onewartwoearewe");;\n- : bool = true\n</code></pre>\n\n<hr>\n\n<pre><code>| Label   | Pattern      |\n|---------+--------------|\n| rule-01 | S -&gt; A \'we\'  |\n| rule-02 | S -&gt; A \'ewe\' |\n| rule-03 | A -&gt; B       |\n| rule-04 | A -&gt; BA      |\n| rule-05 | B -&gt; \'o\'     |\n| rule-06 | B -&gt; \'new\'   |\n| rule-07 | B -&gt; \'art\'   |\n| rule-08 | B -&gt; \'woe\'   |\n| rule-09 | B -&gt; \'are\'   |\n| rule-10 | B -&gt; \'one\'   |\n| rule-11 | B -&gt; \'war\'   |\n| rule-12 | B -&gt; \'two\'   |\n| rule-13 | B -&gt; \'ear\'   |\n#+TBLFM: @2$1..@&gt;$1=\'(format "rule-%02d" (1- @#));L\n\nGenerating =onewartwoearewe=\n\nFirst way to generate:\n\n| Input             | Rule    | Product           |\n|-------------------+---------+-------------------|\n| \'\'                | rule-01 | A\'we\'             |\n| A\'we\'             | rule-04 | BA\'we\'            |\n| BA\'we\'            | rule-05 | \'o\'A\'we\'          |\n| \'o\'A\'we\'          | rule-04 | \'o\'BA\'we\'         |\n| \'o\'BA\'we\'         | rule-06 | \'onew\'A\'we\'       |\n| \'onew\'A\'we\'       | rule-04 | \'onew\'BA\'we\'      |\n| \'onew\'BA\'we\'      | rule-07 | \'onewart\'A\'we\'    |\n| \'onewart\'A\'we\'    | rule-04 | \'onewart\'BA\'we\'   |\n| \'onewart\'BA\'we\'   | rule-08 | \'onewartwoe\'A\'we\' |\n| \'onewartwoe\'A\'we\' | rule-03 | \'onewartwoe\'B\'we\' |\n| \'onewartwoe\'B\'we\' | rule-09 | \'onewartwoearewe\' |\n|-------------------+---------+-------------------|\n|                   |         | \'onewartwoearewe\' |\n\nSecond way to generate:\n\n| Input             | Rule    | Product           |\n|-------------------+---------+-------------------|\n| \'\'                | rule-02 | A\'ewe\'            |\n| A\'ewe\'            | rule-04 | BA\'ewe\'           |\n| BA\'ewe\'           | rule-10 | \'one\'A\'ewe\'       |\n| \'one\'A\'ewe\'       | rule-04 | \'one\'BA\'ewe\'      |\n| \'one\'BA\'ewe\'      | rule-11 | \'onewar\'A\'ewe\'    |\n| \'onewar\'A\'ewe\'    | rule-04 | \'onewar\'BA\'ewe\'   |\n| \'onewar\'BA\'ewe\'   | rule-12 | \'onewartwo\'A\'ewe\' |\n| \'onewartwo\'A\'ewe\' | rule-03 | \'onewartwo\'B\'ewe\' |\n| \'onewartwo\'B\'ewe\' | rule-13 | \'onewartwoearewe\' |\n|-------------------+---------+-------------------|\n|                   |         | \'onewartwoearewe\' |\n</code></pre>\n', 'Tags': '<context-free><formal-grammars><parsers>', 'LastEditorUserId': '10314', 'LastActivityDate': '2013-09-26T09:15:33.267', 'CommentCount': '14', 'AcceptedAnswerId': '14585', 'CreationDate': '2013-09-24T20:35:01.163', 'Id': '14583'},20144:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I\'m trying to make a regular grammar for this language:</p>\n\n<p><img src="http://i.stack.imgur.com/obVZM.gif" alt="enter image description here"></p>\n\n<p>Where the alphabet is $ \\Sigma $ = $\\{a,b,c\\}$</p>\n\n<p>It seemed like it would go well with a right-linear grammar.  This may be disastrously wrong, but here\'s how I started:</p>\n\n<p>$S \\to aA$</p>\n\n<p>$A \\to aA | cB $</p>\n\n<p>$B \\to bC | C $</p>\n\n<p>$C \\to cD |$ $\\lambda$</p>\n\n<p>$D \\to cC$</p>\n\n<p>EDIT:\nCorrected for errors. Added $D$ for regular grammar.</p>\n', 'ViewCount': '71', 'Title': 'Making a regular grammar for this language', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-05T21:58:33.130', 'LastEditDate': '2013-10-05T21:58:33.130', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14836', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><regular-languages><formal-grammars>', 'CreationDate': '2013-10-05T19:10:54.813', 'Id': '14832'},20145:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '57', 'Title': 'Regular Expression as basis for creating this grammar', 'LastEditDate': '2013-10-06T03:50:49.073', 'AnswerCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8396', 'FavoriteCount': '1', 'Body': u"<p>I made a right-linear grammar from a regular expression:</p>\n\n<p>The alphabet is:</p>\n\n<p>$\u03a3 = \\{a, b, c\\} $</p>\n\n<p>Regular expression:</p>\n\n<p>$r = cc^{*}(ba)^{*}bb$</p>\n\n<p>My solution, it seems a little too short like I'm leaving something out. Maybe someone can see where I went wrong on the right-linearity:</p>\n\n<p>$ S \\to cA $</p>\n\n<p>$ A \\to b a A | B | cA $</p>\n\n<p>$ B \\to bb $</p>\n", 'Tags': '<formal-languages><automata><formal-grammars><regular-expressions>', 'LastEditorUserId': '8396', 'LastActivityDate': '2013-10-06T03:50:49.073', 'CommentCount': '2', 'AcceptedAnswerId': '14850', 'CreationDate': '2013-10-06T03:27:41.210', 'Id': '14849'},20146:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I used this generalized transition graph with 3 states and got an equivalent generalized\ntransition graph with 2 states:</p>\n\n<p>GTG:</p>\n\n<p><img src="http://i.stack.imgur.com/LSUfs.jpg" alt="enter image description here"></p>\n\n<p>Equivalent with 2 states:</p>\n\n<p><img src="http://i.stack.imgur.com/nenwS.jpg" alt="enter image description here"></p>\n\n<p>I\'m not sure about the regular expressions linking the nodes $q0$ and $q2$, if someone can clarify where I may have gone wrong here.</p>\n', 'ViewCount': '44', 'Title': 'Reducing states of a GTG', 'LastActivityDate': '2013-10-06T09:56:23.350', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14856', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '8396', 'Tags': '<formal-languages><graphs><automata><formal-grammars>', 'CreationDate': '2013-10-06T04:19:51.400', 'Id': '14852'},20147:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am having challenges (in two phases) with creating a CFG.</p>\n\n<ol>\n<li>Derive the CFG for the following language </li>\n<li>Show parse trees for the strings <em>cacab</em> and <em>aacabbb</em> obtained from the grammar designed above.</li>\n</ol>\n\n<p>I am getting a bit mixed up by the exercise especially because my CFG appears not to produce a parse tree.</p>\n\n<p>Here is the language:</p>\n\n<p>$$\n    L = \\{a^n (ca)^m b^{n+1} \\mid m \\ge 0 , n \\ge 0 \\}\n$$</p>\n\n<p>So far my grammar looks as follows:</p>\n\n<p>$$ \\begin{align}\n    S &amp;\\to Ab \\mid Bb \\mid Cb \\mid b \\\\\n    A &amp;\\to aA \\mid \\epsilon \\\\\n    B &amp;\\to caB \\mid \\epsilon \\\\\n    C &amp;\\to bC \\mid \\epsilon \\\\\n\\end{align} $$</p>\n', 'ViewCount': '158', 'Title': 'Derive a Context Free Grammar from a language', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-08T11:10:34.703', 'LastEditDate': '2013-10-08T11:10:34.703', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '14903', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10569', 'Tags': '<context-free><formal-grammars><tree-grammars>', 'CreationDate': '2013-10-08T09:15:40.340', 'Id': '14900'},20148:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<blockquote>\n  <p>Give a context free grammar for the following language over $\\Sigma = \\{0,1\\}$:<br>\n  $ L = L_1^* $\n  where $ L_1 = \\{0^n1^n : n \\geq 0\\}$.</p>\n</blockquote>\n\n<p>Not really sure where to start with this one. Any help is appreciated</p>\n', 'ViewCount': '156', 'Title': 'Context Free Grammar for $\\{0^n1^n \\mid n \\geq 0\\}^*$', 'LastEditorUserId': '69', 'LastActivityDate': '2013-10-11T17:28:48.707', 'LastEditDate': '2013-10-11T17:28:48.707', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10625', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2013-10-10T00:18:24.160', 'Id': '14968'},20149:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I wanted to know the pros and cons of Chomsky normal form and Greibach normal form.</p>\n', 'ViewCount': '291', 'Title': 'What is the advantage of Greibach Normal Form over Chomsky Normal Form?', 'LastActivityDate': '2013-10-21T17:48:52.627', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10849', 'Tags': '<formal-grammars>', 'CreationDate': '2013-10-19T07:43:51.897', 'Id': '16222'},20150:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I'm interested in finite state automata which have the capacity to require repetition.  That is, the machine may be in a state in which the next character may be any character from set $S$, but, whatever character there is, it must be repeated 3 times.  Or it may be in a different state, which requires a character from set $T$ repeated twice.</p>\n\n<p>I could in theory make a different state for each character in set S, and for each character in set T.  But that overcomplicates things and obscures the pattern - it can be any character in set S, but the same character must be repeated.</p>\n\n<p>Is there any standard approach to this? I'm interested both in terminology and in practical code.</p>\n\n<hr>\n\n<p>Motivation: I do not know the full makeup of the set $S$ or $T$.  I'd like to be able to communicate effectively about the FSM, draw state diagrams, and do implementation, without having to define $S$ or $T$.  In fact, $S$ and $T$ change based on the scenario.  (Now, given a character, it's trivial to tell if it's part of $S$ or $T$ \u2014 but, a priori, it's impossible to enumerate them.)</p>\n\n<p>At the least, I'd like a good way to draw a state diagram for these types of machines.  Perhaps I should use a standard FSM with some type of annotation? Could state charts help with this?</p>\n", 'ViewCount': '85', 'Title': 'Recognizing finite state machines with repetition', 'LastEditorUserId': '39', 'LastActivityDate': '2013-10-24T19:06:19.023', 'LastEditDate': '2013-10-23T04:04:41.797', 'AnswerCount': '2', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10923', 'Tags': '<algorithms><regular-languages><formal-grammars><finite-automata>', 'CreationDate': '2013-10-22T23:13:36.837', 'Id': '16343'},20151:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Construct a context-sensitive grammar that generates L:</p>\n\n<pre><code>L = {a^n b^m c^k|k&gt;n, k&gt;m}\n</code></pre>\n\n<p>I believe my productions should go along this lines:</p>\n\n<pre><code>S-&gt; ABCC\nA-&gt; a|aBC|BC\nB-&gt; b|bBC\nC-&gt; c|Cc\nCB-&gt;BC\n</code></pre>\n\n<p>The idea is to start with 2 c and keep always one more c, and then with C->c|Cc ad as much c as i want. \nHow can my production for C remember the numbers of m and n.</p>\n', 'ViewCount': '56', 'Title': 'Grammar generating specific language', 'LastEditorUserId': '7955', 'LastActivityDate': '2013-12-27T15:40:00.330', 'LastEditDate': '2013-10-26T17:47:10.667', 'AnswerCount': '2', 'CommentCount': '0', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '7955', 'Tags': '<context-free><formal-grammars><context-sensitive>', 'CreationDate': '2013-10-26T17:09:58.687', 'Id': '16448'},20152:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>After asking this question <a href="http://stackoverflow.com/questions/19649183/are-there-generalized-mathematical-operators-in-cs">on stackoverflow</a>, it has changed slightly.  Is there a way to represent a grammar as a basis for a vector space and represent a program as an object that lives in that vector space?</p>\n\n<p>I\'m interested in the parallels between mathematical operators (like the Hamiltonian, ladder operators, momentum operators, etc) and programming languages.  The operators that I\'m talking about can be thought of as transformation matrices that act on (potentially) infinite vectors.  It seems like a good place to start might be a tree algebra?</p>\n\n<p>An alternative would be to force the program into some sort of allowed bitwise representation, and then perform transforms on it.  Is such a thing possible?</p>\n', 'ViewCount': '50', 'Title': 'Generalized operators for programming languages', 'LastActivityDate': '2013-10-29T15:32:44.927', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '16550', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11027', 'Tags': '<formal-grammars><linear-algebra><category-theory>', 'CreationDate': '2013-10-29T04:41:02.697', 'FavoriteCount': '0', 'Id': '16529'},20153:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The question is to design a CFG for the language of words that have as many c's as the difference of numbers of a's and b's, that is</p>\n\n<p>$\\qquad\\displaystyle L = \\{(a^l)(b^m)(c^n) \\mid l, m \\in \\mathbb{N}; n = |l-m|\\}$.</p>\n\n<p>I have so far go to create the cfg for $(a^l)(b^m)$ but don't know how to do the one for $(c^n)$. It looks complicated as to find the value of n, we need to take the abs value for the difference between l and m. Can someone help?</p>\n\n<p>And, here is the cfg I got so far for $(a^l)(b^m)$.</p>\n\n<p>$S \\to aS \\mid bT|\\epsilon $</p>\n\n<p>$T \\to bT \\mid \\epsilon$</p>\n\n<p>I hope this is correct.</p>\n", 'ViewCount': '127', 'Title': "Designing a CFG that produces as many c's as the difference of numbers of a's and b's", 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-02T10:03:20.963', 'LastEditDate': '2013-11-02T09:57:25.863', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '16624', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11110', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-10-31T22:27:49.183', 'Id': '16608'},20154:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have the following grammar G:\n$$\n\\begin{align*}\n&amp;S \\to aB|bA \\\\\n&amp;A \\to a|aS|bAA \\\\\n&amp;B \\to b|bS|aBB\n\\end{align*}\n$$</p>\n\n<p>I am going to prove that this language L(G) consists of words with the same number of a's and b's by strong induction.</p>\n\n<p><strong>Inductive hypothesis</strong>: $S$ produces $m$ $a$'s and $m$ $b$'s, $A$ produces $m+1$ $a$'s and $m$ $b$'s, $B$ produces $m$ $a$'s and $m+1$ $b$'s for some integer $m$. </p>\n\n<p><strong>Base</strong>: The smallest string produced by $S$ is $ab$ or $ba$. The smallest string produced by $A$ and $B$ is $a$ and $b$ respectively. All three satisfy the IH. </p>\n\n<p><strong>Induction</strong>: Assume the inductive hypothesis is satisfied for all strings of length $k$ or less. </p>\n\n<p>For strings of length $k+1$:</p>\n\n<p><strong>(1)</strong>. $A\\to aS$; then $S$ inductively derived a string of length $k-1$ with same number of $a$'s as $b$'s. Since $A$ is initiated by $S\\to bA$, we concatenate that $b$ plus the $a$ in $aS$ and we get a string of length $k+1$ with same number of $a$'s as $b$'s.</p>\n\n<p><strong>(2)</strong>. $A\\to bAA$; then each $A$ on the right hand side has one more $a$ than $b$. Since $A$ is initiated by $S\\to bA$, we concatenate that $b$ plus the $b$ in $bAA$ and we get a string of length $k+1$ with the same number of $a$'s as $b$'s.  </p>\n\n<p>Can I continue for $B\\to bS$ and $B\\to aBB$? Am I totally wrong here? </p>\n", 'ViewCount': '104', 'Title': "Is my proof for a context free language correct? Same number of a's as b's", 'LastEditorUserId': '11155', 'LastActivityDate': '2013-11-07T05:05:43.043', 'LastEditDate': '2013-11-07T05:05:43.043', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11155', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques>', 'CreationDate': '2013-11-07T02:26:03.960', 'Id': '16787'},20155:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>My task is to convert the following grammar to CNF: $S \\to SS \\mid (S) \\mid \\lambda$</p>\n\n<p>after removing lambda productions: $S\\to SS,  S\\to (S),  S\\to(), S\\to S$</p>\n\n<p>after removing unit productions: $S\\to SS, S\\to (S), S\\to()$</p>\n\n<p>I got upto this point. Do not know how this grammar will be in CNF coz I am not sure if using () makes the grammar illegal. Need help how to proceed and make this grammar in CNF?</p>\n', 'ViewCount': '66', 'Title': 'conversion of this grammar to CNF', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T15:22:10.437', 'LastEditDate': '2013-11-09T15:22:10.437', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11169', 'Tags': '<context-free><formal-grammars><normal-forms>', 'CreationDate': '2013-11-09T12:03:41.860', 'Id': '16843'},20156:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>I missed a question about a CFG on an assignment, but the grader wouldn't explain what was wrong with my answer and instead provided me the answer from the book.</p>\n\n<p>Here is the language: </p>\n\n<p>$\\qquad\\displaystyle L = \\{a^n b^m c^k : n = m \\lor m \\neq k\\}$</p>\n\n<p>And my CFG. </p>\n\n<pre><code>S \u2192 AB|CD|CE\nA \u2192 aAb|\u03bb\nB \u2192 Bc|\u03bb\nC \u2192 aC|\u03bb\nD \u2192 bDc|Dc|c\nE \u2192 bEc|bE|b\n</code></pre>\n\n<p>Can somebody explain why this grammar doesn't work for the given language?</p>\n", 'ViewCount': '55', 'Title': 'Does this CFG produce this language?', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-09T20:33:53.077', 'LastEditDate': '2013-11-09T19:58:29.333', 'AnswerCount': '0', 'CommentCount': '6', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11285', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-11-09T19:08:29.113', 'Id': '17853'},20157:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>When we are trying to learn a new language without any help from native speakers, the first thing we need is something/someone to correct our grammatical mistakes/improper word selection.</p>\n\n<p>So is there any research done on building tools to help critique our spoken language? I often hear people saying that the more you try to speak, the better you get, so I'm wondering if automated tools could help provide feedback on our attempts at speaking in the new language.</p>\n", 'ViewCount': '66', 'Title': 'Automatic speech correction', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-16T02:16:48.197', 'LastEditDate': '2013-11-16T02:16:48.197', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '11367', 'Tags': '<formal-grammars><software-engineering><language>', 'CreationDate': '2013-11-14T04:07:07.853', 'Id': '18003'},20158:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm writing a context-free grammar that I hope will be in Chomsky Normal Form, and I have two questions:</p>\n\n<ol>\n<li><p>Can I use a single variable (a non-terminal) on the left-hand side of multiple rules?</p></li>\n<li><p>Can I use a single variable (a non-terminal) twice on the right-hand side of a single rule?</p></li>\n</ol>\n\n<p>For instance, is the following grammar properly in Chomsky Normal Form?  Is it OK that I have two rules with $S$ on the left-hand side?  Is it OK that I have $X$ twice on the right-hand side of the second rule?</p>\n\n<p>$$S_0 \\to S$$\n$$S \\to XX$$\n$$S \\to XZ$$\n$$\\vdots$$</p>\n", 'ViewCount': '105', 'Title': 'Rules regarding Chomsky Normal Form (CNF) grammars', 'LastEditorUserId': '755', 'LastActivityDate': '2013-11-16T06:50:35.410', 'LastEditDate': '2013-11-15T22:18:02.883', 'AnswerCount': '1', 'CommentCount': '7', 'AcceptedAnswerId': '18064', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '2778', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2013-11-15T16:15:10.703', 'Id': '18052'},20159:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '186', 'Title': 'CFG for $\\{a^ib^jc^k \\mid i \\neq j+k\\}$', 'LastEditDate': '2013-11-18T21:33:21.273', 'AnswerCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11155', 'FavoriteCount': '1', 'Body': "<p>I am trying to design a context-free grammar for the language $L = \\{a^ib^jc^k \\mid i\\neq j+k\\}$ over the alphabet $\\Sigma = \\{a,b,c\\}$.</p>\n\n<p>I know that I can split this up into the union of two cfg's $S_1$ and $S_2$,\n<br>where $S_1$ is the case where $\\#_a \\lt \\#_b + \\#_c$, \n<br>and $S_2$ is the case where $\\#_a \\gt \\#_b + \\#_c$.</p>\n\n<p>I keep producing the grammar that generates this language <strong>but</strong> not in the correct order, that is I am having a hard time keeping the $a$'s on the left, $b$'s in the middle, and $c$'s to the right. Is this even context free?</p>\n", 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2013-11-18T21:40:01.583', 'CommentCount': '1', 'AcceptedAnswerId': '18129', 'CreationDate': '2013-11-18T20:40:51.630', 'Id': '18126'},20160:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im having some problems with a qeuestion regarding converting a context free grammar to chomsky normal form.</p>\n\n<p>I have \n        S -> abC | babS | de\n        C -> aCa |b</p>\n\n<p>I know what to do with the case of aCa and de and b but im not sure how to handle the abC case or the babS case. I believe that chomsky normal form is supposed to have outputs of only 2 characters. so with something like aCa you make and output aa and have A->a and create another nonterminal? X -> SA but I dont know how im supposed to handle the abC case or the babS case.</p>\n', 'ViewCount': '48', 'Title': 'Converting to Chomsky normal form', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T10:37:55.103', 'LastEditDate': '2014-03-24T10:37:55.103', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11470', 'Tags': '<context-free><formal-grammars><normal-forms>', 'CreationDate': '2013-11-25T03:37:11.367', 'FavoriteCount': '1', 'Id': '18316'},20161:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$L$ is a regular language and $w$ is any word, not necessarily in $L$. We define the set as</p>\n\n<p>$$L/w = \\{x \\in \\Sigma ^* \\mid xw \\in L\\}.$$</p>\n\n<p>Show that $L/w$ is regular.</p>\n\n<p>I'm really struggling with this one. I know its going to come on my final next week.</p>\n", 'ViewCount': '60', 'Title': 'L is a regular language and w is any word, not necessarily in L. Show that L is regular', 'LastEditorUserId': '2205', 'LastActivityDate': '2013-12-26T12:35:35.627', 'LastEditDate': '2013-11-26T09:54:13.487', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11632', 'Tags': '<regular-languages><formal-grammars>', 'CreationDate': '2013-11-26T09:43:52.243', 'Id': '18369'},20162:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>So I've been given the following language on an assignment.  It is the only question I have left of 10, and I've been racking my brains out trying to solve it for hours.  </p>\n\n<p>$$L=\\{w:w\\in(a+b+c)^*, n_a(w) &gt; n_b(w)&gt;n_c(w)\\}$$</p>\n\n<p>where $n_x(w)$ represents the number of character $x$ found in $w$.  The problem statement is: <strong>prove or disprove that the language is context-free</strong>.  Context-free grammars or pushdown automata are acceptable proofs.  Use pumping lemma to disprove.</p>\n\n<p>I've extensively explored both possibilities and I'm fairly certain that it is context-free.  </p>\n\n<p>The approach I've taken in finding a context-free grammar for the language involves using rules which preserve the constraint $n_a(w) &gt; n_b(w) &gt; n_c(w)$ (ie. whenever a $b$ is added, add an $a$; whenever a $c$ is added, add a $b$).  Then, I've attempted to enforce that there are at least two $a$s and at least one $b$ (base case for the constraint).</p>\n\n<p>The grammar I've used is:</p>\n\n<p>$S\\implies XaXaXbX | XaXbXaX | XbXaXaX$</p>\n\n<p>$X \\implies XX| A | B | C | \\lambda$</p>\n\n<p>$A \\implies a$</p>\n\n<p>$B \\implies ab | ba$</p>\n\n<p>$C \\implies abc | acb | bac | bca | cab | cba$</p>\n\n<p>(where $\\lambda$ is the empty string)</p>\n\n<p>My grammar fails for strings like $cccaaaaabbbb$.</p>\n\n<p>I'm confused as to where to go from here.  </p>\n\n<p><strong>I would really like a push in the right direction, not an answer.</strong>\n Any help is greatly appreciated!</p>\n", 'ViewCount': '87', 'Title': 'Is $\\{w:w\\in(a+b+c)^*, n_a(w) > n_b(w)>n_c(w)\\}$ context-free?', 'LastEditorUserId': '9612', 'LastActivityDate': '2014-01-29T22:37:10.603', 'LastEditDate': '2013-12-30T11:42:33.360', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '10400', 'Tags': '<context-free><formal-grammars><pumping-lemma><pushdown-automata>', 'CreationDate': '2013-11-29T17:48:42.330', 'FavoriteCount': '1', 'Id': '18470'},20163:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>How would I find an LL(1) grammar for the language:</p>\n\n<blockquote>\n  <p>L=a<sup>m</sup> b<sup>n</sup> c<sup>m+n</sup></p>\n</blockquote>\n\n<p>Where m and n are elements of the naturals? My context-free grammar is:</p>\n\n<blockquote>\n  <p>S &rarr; aSc | B</p>\n  \n  <p>B &rarr; bBc | A</p>\n  \n  <p>A &rarr; bc</p>\n</blockquote>\n\n<p>Is my grammar LL(1) parsable?</p>\n', 'ViewCount': '99', 'ClosedDate': '2014-02-02T11:19:15.587', 'Title': 'Finding an LL(1) grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T16:06:25.357', 'LastEditDate': '2013-12-02T12:09:50.653', 'AnswerCount': '3', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '11752', 'Tags': '<formal-languages><context-free><formal-grammars><parsers>', 'CreationDate': '2013-12-02T03:37:45.623', 'Id': '18523'},20164:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>There are <a href="http://cs.stackexchange.com/q/265/755">many techniques</a> to prove that a language is <em>not</em> context-free, but how do I prove that a language <em>is</em> context-free?</p>\n\n<p>What techniques are there to prove this?  Obviously, one way is to exhibit a context-free grammar for the language.  Are there any systematic techniques to find a context-free grammar for a given language?</p>\n\n<p>For regular languages, there <em>are</em> <a href="http://cs.stackexchange.com/q/1331/755">systematic ways</a> to derive a regular grammar / finite-state automaton: for instance, the Myhill-Nerode theorem provides one way.  Is there any corresponding technique for context-free languages?</p>\n\n<hr>\n\n<p>My motivation here is to (hopefully) build up a reference question that contains a list of techniques that are often helpful, when trying to prove that a given language is context-free.  Since we have many questions here that are special cases of this, it would be nice if we could document the general approach or general techniques that one can use when facing this sort of problem.</p>\n', 'ViewCount': '156', 'Title': 'How to prove that a language is context-free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-18T19:22:09.170', 'LastEditDate': '2014-01-17T22:55:11.557', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '5', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><reference-question>', 'CreationDate': '2013-12-02T04:18:45.460', 'FavoriteCount': '1', 'Id': '18524'},20165:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>The intersection of a context free language L with a regular language M, is said  to be always context free. I understood the cross product construction proof, but I still don't get why it is context free but not regular.</p>\n\n<p>The language generated by such an intersection has strings that are accepted both by a PDA <em>and</em> a DFA. Since it is accepted by a DFA, shouldn't it be a regular language? Plus, if the intersection is regular, it also implies context free, since all regular languages are also context free.</p>\n\n<p>Can someone explain to me why the language obtained by such an intersection is not regular?</p>\n\n<p>Thanks.</p>\n", 'ViewCount': '273', 'Title': 'Intersection of context free with regular languages', 'LastActivityDate': '2013-12-05T15:20:51.903', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '18645', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<context-free><finite-automata><formal-grammars>', 'CreationDate': '2013-12-05T14:24:39.063', 'FavoriteCount': '2', 'Id': '18642'},20166:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Others have studied the following question: given a set of words $w_1,w_2,\\dots \\in \\Sigma^*$, find a regular grammar (or a context-free grammar) that generates all of those words, is "natural" in some sense, and is as small as possible.  In the special case where we have a single word $w \\in \\Sigma^*$, if the grammar generates exactly the word $w$, we can think of this as a compression algorithm that compresses the word $w$ to the grammar produced by this inference algorithm.  Of course, each word is a one-dimensional sequence of symbols.</p>\n\n<p>Now consider a two-dimensional array of symbols, say an array $A[1\\ldots m, 1\\ldots n]$ where each $A[i,j] \\in \\Sigma$.  Is there any corresponding algorithm that could be used to find a grammar of some sort that generates $A$?  Could this be used as a compression algorithm for compressing images, i.e., one that compresses a two-dimensional image to its corresponding grammar?</p>\n\n<p>I\'m not even sure what kind of grammar would be suitable.  Is there an analog of regular or context-free grammars that generates a two-dimensional output instead of a one-dimensional output?  I\'ve done some searching, and haven\'t found anything obvious.</p>\n\n<ul>\n<li><p>Of course we could linearize the image, by concatenating the rows of the array, to get a one-dimensional sequence, and then apply any of the above techniques -- but this does not preserve locality.  In other words, elements that are vertically adjacent will no longer be near each other after this transformation.  So this transformation does not seem useful.</p></li>\n<li><p>Perhaps we could build a quad-tree over the array and then consider tree automata over that quad-tree?  Is there a grammar inference algorithm for such tree automata over quad-trees?</p></li>\n<li><p>Alternatively, it seems like there might be a natural extension of context-free grammars to two-dimensional output: just make the right-hand side of each rule be a two-dimensional array of terminals and non-terminals of arbitrary size, and then apply the obvious generation algorithm.  Do such grammars have a standard name?  Is there a grammar inference algorithm for such grammars?</p></li>\n</ul>\n', 'ViewCount': '42', 'Title': '"Grammar inference" for 2-D images', 'LastActivityDate': '2014-04-08T09:34:06.440', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '755', 'Tags': '<formal-languages><formal-grammars><tree-grammars>', 'CreationDate': '2013-12-10T07:46:27.600', 'Id': '18823'},20167:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Given a standard grammar describing the boolean expression with <code>AND</code>, <code>OR</code> and <code>NOT</code> operators:</p>\n\n<pre><code>exp\u2192term {OR term};\nterm\u2192factor {AND factor};\nfactor\u2192id;\nfactor\u2192NOT factor;\nfactor\u2192LPAREN exp RPAREN;\n</code></pre>\n\n<p>I would like to translate the strings of the corresponding language in the Product Of Sums form:</p>\n\n<pre><code>P\u2192S|S AND P\nS\u2192LPAREN Ls RPAREN | NOT LPAREN Ls RPAREN\nLs\u2192I|I OR Ls\nI\u2192id|Not id\n</code></pre>\n\n<p>I would like to associate each of the former rule to a rule of the latter oen, so as to easly implement it with <code>Bison</code>/<code>Yacc</code>.</p>\n\n<p>I'm not constrained to those two grammars, I can rewrite them as long as the express the same languages.</p>\n\n<p>Could you suggest me how to preoceed?</p>\n", 'ViewCount': '35', 'Title': 'Write grammars rule to translate general boolean expressions in Prodocut Of Sums', 'LastActivityDate': '2013-12-17T12:36:54.670', 'AnswerCount': '0', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '1228', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-12-17T12:36:54.670', 'Id': '19063'},20168:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Define the language $L$ as $L = \\{a, b\\}^* - \\{ww\\mid w \\in \\{a, b\\}^*\\}$.  In other words, $L$ contains the words that cannot be expressed as some word repeated twice.  Is $L$ context-free or not?</p>\n\n<p>I've tried to intersect $L$ with $a^*b^*a^*b^*$, but I still can't prove anything. I also looked at Parikh's theorem, but it doesn't help.</p>\n", 'ViewCount': '220', 'Title': 'Is $\\{a, b\\}^* \\setminus \\{ww \\mid w \\in \\{a,b\\}^*\\}$ context-free?', 'LastEditorUserId': '683', 'LastActivityDate': '2013-12-23T09:37:00.473', 'LastEditDate': '2013-12-23T09:37:00.473', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '12256', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-12-20T10:32:51.057', 'Id': '19151'},20169:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have the following CFG which I suspect cannot be rewritten to one which is LL(1):</p>\n\n<p>$S \\rightarrow \\epsilon\\ |\\ aSbS\\ |\\ bSaS\\ |\\ cSdS\\ |\\ dScS$</p>\n\n<p>I\'ve thought about it for a while, and can\'t seem to make any progress. I know that <a href="http://stackoverflow.com/questions/15161636/making-a-grammar-ll1">the simpler grammar here</a> can be rewritten into LL(1), but it seems like there is something different about the above grammar which prevents a rewriting in a similar style. Is it possible? If not, is there an easy way to prove that this is the case?</p>\n', 'ViewCount': '109', 'Title': 'Can this CFG be written into an equivalent LL(1) grammar?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-06T10:56:54.060', 'LastEditDate': '2014-01-06T09:24:40.650', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12290', 'Tags': '<formal-languages><context-free><formal-grammars><parsing>', 'CreationDate': '2013-12-21T19:21:26.410', 'Id': '19178'},20170:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>can someone give me the step-by-step approach to obtaining a context free grammar for a language? example: obtain a grammar to generate string consisting of at least 2 a's my answer was this: S-->aA A-->aB B-->aB|$(epsilon) the text book answer : S-->aa S-->aS can there be more than one answer? obtain a grammar to generate string consisting of at least 2 a's please reply asap as i have a test in 2 days!!</p>\n", 'ViewCount': '14', 'ClosedDate': '2013-12-26T09:38:53.160', 'Title': 'step-by-step approach context free grammar', 'LastActivityDate': '2013-12-25T16:08:49.773', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12371', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2013-12-25T16:08:49.773', 'Id': '19279'},20171:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am working on CFG grammars, LL grammars in particular and I encountered the following theorem in the slides of presentations written by my professor:</p>\n\n<blockquote>\n  <p>A CFG grammar cannot be left-factored if all elements in the FIRST-set of one factorizable rule belong to the FIRST-set of the alternative rule. </p>\n</blockquote>\n\n<p>Mathematically speaking:</p>\n\n<p>$$\nA \\rightarrow \\alpha\\beta_1 | \\alpha\\beta_2 , \\forall x \\in \\text{FIRST}(\\alpha\\beta_1)\n\\wedge x \\in \\text{FIRST}(\\alpha\\beta_2) \\implies \\text{Cannot left-factorize}\n$$</p>\n\n<p>Is it correct? I think it is not!</p>\n\n<p>Consider grammar rules $A \\rightarrow aB | a C$ This thing can be left-factorized in: $A \\rightarrow aD; D \\rightarrow B|C$. But considering the theorem such a grammar is not supposed to be left-factorizable because $\\text{FIRST}(aB) =\\text{FIRST}(aC) = {a}$.</p>\n\n<p>Which one is the correct version of this theorem? Thankyou</p>\n', 'ViewCount': '32', 'Title': 'Is this theorem about left-factored grammars correct?', 'LastActivityDate': '2013-12-31T18:41:05.803', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12499', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2013-12-31T18:41:05.803', 'Id': '19417'},20172:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Every nontrivial property of the recursively enumerable languages is undecidable.</p>\n\n<p>What exactly is nontrivial property?</p>\n', 'ViewCount': '260', 'ClosedDate': '2014-01-07T07:58:15.090', 'Title': 'Rice Theorem - What is non-trivial property?', 'LastActivityDate': '2014-01-06T18:03:53.550', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19538', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '12629', 'Tags': '<turing-machines><formal-grammars>', 'CreationDate': '2014-01-06T14:44:41.333', 'Id': '19536'},20173:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The question is really confusing me. I know every context sensitive grammar is monotonic but not vice versa. e.g. AB--->BA is monotonic but not context sensitive. Can someone explain to me in simple terms why this is?</p>\n', 'ViewCount': '56', 'Title': "Why isn't every monotonic grammar context sensitive free?", 'LastEditorUserId': '9550', 'LastActivityDate': '2014-01-10T21:38:53.880', 'LastEditDate': '2014-01-10T15:15:30.257', 'AnswerCount': '3', 'CommentCount': '6', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12719', 'Tags': '<formal-grammars><context-sensitive>', 'CreationDate': '2014-01-10T00:15:55.083', 'Id': '19609'},20174:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>i am new to compiler design, currently studying Ullmans book on this.He says:</p>\n\n<p>Problem with predictive parsing (both recursive and non recursive) is that Left recursive productions can go infinite loop.Thus, to make grammar suitable for predictive parsing we need to eliminate the left recursion by immediately or indirectly.</p>\n\n<pre><code> E -&gt; E+T|t\n</code></pre>\n\n<p>My problem is, same can happen with right recursion also.What is the solution for it?</p>\n\n<pre><code> T -&gt; E+T|t\n</code></pre>\n\n<p>Please correct me if i am wrong! thanks.</p>\n', 'ViewCount': '52', 'Title': 'Need solution for infinite right recursive grammar in Predictive parsing?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-12T19:25:29.983', 'LastEditDate': '2014-04-12T17:48:36.483', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '10564', 'Tags': '<formal-grammars><parsing><left-recursion>', 'CreationDate': '2014-01-11T12:16:06.933', 'Id': '19654'},20175:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>In a recent test, I was asked to recognize if the below language is context  free:</p>\n\n<p>$\\qquad\\displaystyle L = \\{0^{n+m}1^{n+m}0^m \\mid n,m \\geq 0\\}$ </p>\n\n<p>I think it is context free, and can be accepted by below context free grammar, where $S$ is the start symbol and $Y$ is a non-terminal:</p>\n\n<p>$\\qquad S \\to S0 \\mid Y$</p>\n\n<p>$\\qquad Y \\to 0Y1 \\mid \\epsilon$</p>\n\n<p>However, my answer was considered wrong and that the language $L$  is not context free.</p>\n\n<p>I'm confident about my answer, but the response has got me confused. Is my understanding correct? Please let me know if I've missed something.</p>\n", 'ViewCount': '131', 'Title': 'Is this language context free?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T01:19:12.187', 'LastEditDate': '2014-01-13T13:03:19.593', 'AnswerCount': '1', 'CommentCount': '4', 'AcceptedAnswerId': '19906', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-01-13T12:22:13.227', 'Id': '19690'},20176:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm following the algorithm for left recursion elimination from a grammar. It says remove the epsilon production if there is any.</p>\n\n<p>I have the grammar</p>\n\n<p>$\\qquad S \\to Aa \\mid b$<br>\n$\\qquad A \\to Ac \\mid Sd \\mid \\varepsilon$</p>\n\n<p>I can see after removing the epsilon productions the grammer becomes</p>\n\n<p>$\\qquad S \\to Aa \\mid a \\mid b$<br>\n$\\qquad A \\to Ac \\mid Sd \\mid c \\mid d$ </p>\n\n<p>I'm confused where the $a \\mid b$ for $S$ and $c \\mid d$ for $A$ come from.\nCan someone explain this?</p>\n", 'ViewCount': '38', 'Title': 'Eliminating $\\varepsilon$-productions during elimination of left recursion', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-23T20:51:58.290', 'LastEditDate': '2014-01-23T17:14:14.097', 'AnswerCount': '1', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<context-free><formal-grammars><compilers><left-recursion>', 'CreationDate': '2014-01-23T15:28:15.480', 'Id': '19913'},20177:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm studying for my Computing languages test and there's one idea I'm having problems wrapping my head around, as far as I know for any Context Free Grammar (CFG), we can design a 2-state Pushdown Automaton (PDA). I am however a little bit confused that why this is possible.</p>\n", 'ViewCount': '165', 'Title': 'How to get 2-state PDA for CFG?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T14:37:05.360', 'LastEditDate': '2014-01-26T14:37:05.360', 'AnswerCount': '2', 'CommentCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '13108', 'Tags': '<formal-languages><context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2014-01-24T18:53:40.317', 'FavoriteCount': '4', 'Id': '19946'},20178:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am a little bit confused on one idea regarding <a href="http://en.wikipedia.org/wiki/Indexed_language" rel="nofollow">indexed languages</a>.</p>\n\n<blockquote>\n  <p>$\\{ww \\mid w \\in \\{a,b,c\\}^* \\}$ is a linear indexed language, but </p>\n  \n  <p>$\\{www \\mid w \\in \\{a,b,c\\}^* \\}$ is not a linear indexed language.</p>\n</blockquote>\n\n<p>What is the difference? As far as I know, indexed languages can be recognized by stack automatons, but I am a little confused on this.</p>\n', 'ViewCount': '164', 'Title': 'Why is ww a linear indexed language while www is not?', 'LastEditorUserId': '472', 'LastActivityDate': '2014-01-26T14:28:25.127', 'LastEditDate': '2014-01-26T14:28:25.127', 'AnswerCount': '1', 'CommentCount': '6', 'Score': '6', 'PostTypeId': '1', 'OwnerUserId': '13110', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-01-24T19:26:33.487', 'FavoriteCount': '2', 'Id': '19948'},20179:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<blockquote>\n  <p>Describe the language generated by the following grammar</p>\n\n<pre><code>&lt;A&gt; ::= &lt;A&gt;&lt;A&gt; '+' | &lt;A&gt;&lt;A&gt; '*' | 'a'\n</code></pre>\n</blockquote>\n\n<p>So it's not too hard to see <code>aa + a*</code> can be generated by this grammar. But I fail to see a general rule for the output. It seems like the language is any math expression containing the operands <code>{a, aa}</code> with the operator <code>*</code>, <code>+</code>. Am I correct?</p>\n", 'ViewCount': '45', 'Title': 'Is this a grammar for arithmetic expressions?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-26T04:57:35.713', 'LastEditDate': '2014-01-26T04:57:35.713', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13138', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-01-26T04:30:23.137', 'Id': '19981'},20180:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '101', 'Title': 'Is this grammar LR(1)', 'LastEditDate': '2014-01-29T17:12:56.117', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11750', 'FavoriteCount': '1', 'Body': "<p>I am reading parser chapter from dragon book and I found a grammar over there - </p>\n\n<p>$ S \\rightarrow L=R $</p>\n\n<p>$ S \\rightarrow R $</p>\n\n<p>$L \\rightarrow *R $</p>\n\n<p>$L \\rightarrow id $</p>\n\n<p>$R \\rightarrow L $</p>\n\n<p>Now I have created some of its items, not sure if they are correct - </p>\n\n<p>$ I_{0} $</p>\n\n<p>$S' \\rightarrow .S  ; \\$ $</p>\n\n<p>$S \\rightarrow .L=R ; \\$ $</p>\n\n<p>$S \\rightarrow .R ; \\$ $</p>\n\n<p>$ L \\rightarrow .*R; \\$/= $</p>\n\n<p>$ L \\rightarrow .id; \\$/= $</p>\n\n<p>$ R \\rightarrow .L; \\$ $</p>\n\n<p>$ I_{1} $</p>\n\n<p>$ S' \\rightarrow S.; \\$ $</p>\n\n<p>$ I_{2} $</p>\n\n<p>$S \\rightarrow L.=R ; \\$ $</p>\n\n<p>$ R \\rightarrow L.; \\$ $</p>\n\n<p>Now I2 contains Shift reduce conflict but the lookahead symbol that is appearing is creating doubt I mean how $ can be lookahead symbol to shift <code>=</code> sign? </p>\n", 'Tags': '<formal-grammars><compilers><parsers>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-03T22:55:58.517', 'CommentCount': '0', 'AcceptedAnswerId': '20232', 'CreationDate': '2014-01-29T15:42:30.253', 'Id': '20068'},20181:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Im trying to draw an annotated parse tree for <code>3*5+4n</code>, the text book shows the following:</p>\n\n<p><img src="http://i.stack.imgur.com/TilDt.png" alt="enter image description here"><br>\n<sup>[<em>Compilers - Principles, techniques and tools (Dragon Book) by Aho, p308</em>]</sup></p>\n\n<p>I have a few questions regarding this</p>\n\n<ol>\n<li><p>Why is <code>3*5+4</code> considered as a single string? Can\'t I draw a parse tree something like \nfor the same string ie:with operator at the node <img src="http://i.stack.imgur.com/PRd1R.jpg" alt="enter image description here"> </p></li>\n<li><p>What is the need for giving <code>T.VAL=3</code> and then giving another child <code>F.VAL=3</code>. (I understand that the integer attribute for digit needs to be supplied by the lexical analyzer)</p></li>\n</ol>\n', 'ViewCount': '226', 'ClosedDate': '2014-02-03T00:27:50.477', 'Title': 'Drawing Annotated Parse Tree for Syntax Directed Definition', 'LastEditorUserId': '98', 'LastActivityDate': '2014-01-30T11:40:12.120', 'LastEditDate': '2014-01-30T11:13:37.357', 'AnswerCount': '2', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '12993', 'Tags': '<formal-grammars><compilers><parsing><syntax-trees>', 'CreationDate': '2014-01-30T08:37:50.427', 'Id': '20098'},20182:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Considering programming languages with significant whitespace for indentation, such as Python or Haskell. How does this whitespace fit into the grand schemes of programming language grammars.</p>\n\n<p>I can see that a "preprocessor" can convert indent changes into tokens which are then handled in grammars, yet can one also perform the parsing based upon a single grammar without changing the intrinsic complexity of the 2nd grammer?</p>\n', 'ViewCount': '29', 'Title': 'Indentation based Grammars', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-01T15:40:14.350', 'LastEditDate': '2014-02-01T15:34:28.963', 'AnswerCount': '1', 'CommentCount': '1', 'AcceptedAnswerId': '20188', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '8028', 'Tags': '<formal-grammars><compilers><parsers>', 'CreationDate': '2014-02-01T10:34:48.470', 'Id': '20181'},20183:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was reading through Context Free Grammar, and I came across ambiguous grammar. If the language produced by CFG has more then 1 parse tree, then CFG is an ambiguous grammar. Is there any way by which I can find out or prove that the grammar is Unambiguous. In general I can test some language produced by CFG and check whether more than 1 parse tree is generated from that language, to show that grammar is ambiguous. But how do I check or prove that give CFG is unambiguous?</p>\n', 'ViewCount': '13', 'ClosedDate': '2014-02-02T13:21:21.190', 'Title': 'Unambiguous Context free Grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:21:32.037', 'LastEditDate': '2014-02-02T13:21:32.037', 'AnswerCount': '0', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13042', 'Tags': '<formal-languages><context-free><formal-grammars><ambiguity>', 'CreationDate': '2014-02-02T08:51:12.323', 'Id': '20205'},20184:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have to find the language generated by the grammar:</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to SA \\mid a \\\\\n  A &amp;\\to aAa \\mid bA \\mid \\varepsilon\n\\end{align*}$</p>\n\n<p>where $\\varepsilon$ is the empty string).</p>\n\n<p>The only way is to apply the productions rules an try to recognize the language, or can be used a general approach to find it?</p>\n\n<p>For example I can say that for Arden Rule $L(S) = aL(A)^*$ (right?), and then try to find $L(A)$, but one more time I have the same problem explained before. </p>\n', 'ViewCount': '39', 'Title': 'Find the language generated by a grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-02T13:48:49.657', 'LastEditDate': '2014-02-02T13:48:49.657', 'AnswerCount': '0', 'CommentCount': '2', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13325', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-02-02T12:58:17.527', 'Id': '20213'},20185:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Language:</p>\n\n<p>$ L = a^{n+m}b^{n}c^{m} $</p>\n\n<p>As per a recent test I gave, this language is not context free.</p>\n\n<p>However, I think it is.</p>\n\n<p><strong>Corresponding Grammar:</strong></p>\n\n<p>$ X \\rightarrow aXY \\space |\\space \\epsilon $</p>\n\n<p>$ Y \\rightarrow b \\space | \\space c $</p>\n\n<p><strong>Pushdown Automata:</strong></p>\n\n<p>Keeping pushing all $a$ to the stack, until a $b$ is scanned. Keeping popping  $a$ from stack for each character scanned, until end of input.</p>\n\n<p>If, after the end of input the stack is empty accept the string. Else, go to non-accepting state.</p>\n\n<p>Please let me know if I'm thinking along the right lines or if I've missed something..</p>\n", 'ViewCount': '78', 'Title': 'Is $a^{n+m}b^{n}c^{m}$ context free?', 'LastActivityDate': '2014-02-03T16:18:44.520', 'AnswerCount': '2', 'CommentCount': '5', 'AcceptedAnswerId': '20252', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11837', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-02-03T14:28:28.637', 'FavoriteCount': '1', 'Id': '20249'},20186:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>CFG can specify structure of sentences but Regular grammar can only specify strings sequentially. Is it because DFA has only one bit memory?</p>\n', 'ViewCount': '63', 'ClosedDate': '2014-02-05T08:02:49.107', 'Title': 'Why CFG can specify structure of sentence but Regular grammar cannot?', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-06T16:05:53.983', 'LastEditDate': '2014-03-06T16:05:53.983', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '947', 'Tags': '<regular-languages><context-free><formal-grammars><strings>', 'CreationDate': '2014-02-05T01:52:36.737', 'Id': '21306'},20187:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Consider following grammar:</p>\n\n<p>$$X\\to Yc|ZY$$</p>\n\n<p>$$Y\\to ab|cX$$</p>\n\n<p>$$Z\\to d|\\epsilon$$</p>\n\n<p>Can this be converted to LL(1)?</p>\n\n<p>Cleary, its not LL(1) because of First/First conflict at first production. Can anyone suggest something to make it LL1?</p>\n', 'ViewCount': '67', 'Title': 'Is this grammar LL(1)?', 'LastEditorUserId': '14403', 'LastActivityDate': '2014-02-06T08:44:11.353', 'LastEditDate': '2014-02-05T19:50:39.943', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14403', 'Tags': '<formal-languages><formal-grammars><compilers>', 'CreationDate': '2014-02-05T10:30:12.203', 'Id': '21315'},20188:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '107', 'Title': 'Determining if a context-free grammar produces even-length strings', 'LastEditDate': '2014-02-06T21:11:48.003', 'AnswerCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14447', 'Body': '<p>Given a context-free grammar, is there an algorithm to determine if the CFG will ever produce an even length string? Or is this undecidable?</p>\n', 'ClosedDate': '2014-02-15T04:33:24.287', 'Tags': '<computability><context-free><formal-grammars><undecidability>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-06T21:11:48.003', 'CommentCount': '1', 'AcceptedAnswerId': '21396', 'CreationDate': '2014-02-06T17:46:33.243', 'Id': '21390'},20189:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have this grammar and I have to remove direct left recursion and common prefixes. This is the grammar:</p>\n\n<p>$\\qquad\\displaystyle S \\to SSA  \\mid SSB   \\mid SSC   \\mid AS   \\mid A$</p>\n\n<p>this is what I did:</p>\n\n<p>Removing common prefixes: (I think that in English you call this left factoring, right?)</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to SSS' \\mid AS'' \\\\\n  S' &amp;\\to A \\mid B \\mid C  \\\\  \n  S'' &amp;\\to S \\mid E \n\\end{align*}$</p>\n\n<p>Removing direct left recursion:</p>\n\n<p>$\\qquad\\begin{align*}\n S &amp;\\to AS''S'''   \\\\\n S''' &amp;\\to S'''S'S''' \\mid E  \\\\\n S''' &amp;\\to S'''' \\\\\n S'''' &amp;\\to E \\mid S'S'''S''''\n\\end{align*}$</p>\n\n<p>Is this correct?</p>\n\n<p>My doubts are specifically about the removing of the direct left recursion. If I have for example:</p>\n\n<p>$\\qquad\\displaystyle S \\to SSa \\mid b$</p>\n\n<p>and I apply the formula to remove direct left recursion, which of the two solutions is the correct one?</p>\n\n<p>This:</p>\n\n<p>$\\qquad\\begin{align*} \n S &amp;\\to bS' \\\\\n S' &amp;\\to S'aS'\n\\end{align*}$</p>\n\n<p>or this:</p>\n\n<p>$\\qquad\\begin{align*}\n  S &amp;\\to bS' \\\\\n  S' &amp;\\to SaS'\n\\end{align*} \\qquad$?</p>\n", 'ViewCount': '65', 'Title': 'Remove direct left recursion and common prefixes', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-07T09:21:14.103', 'LastEditDate': '2014-02-07T09:21:14.103', 'AnswerCount': '0', 'CommentCount': '5', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14463', 'Tags': '<formal-grammars><left-recursion>', 'CreationDate': '2014-02-07T05:17:35.727', 'Id': '21421'},20190:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am learning Compiler Design. Can somebody explain what type of Grammar this is? The answer given is $LL(1)$ but there exists a left recursion in the grammar so it cannot be $LL(1)$. I derived the parse table it had conflicts. Am I doing some thing wrong or is the answer given wrong? </p>\n\n<p>My texbook defines:</p>\n\n<blockquote>\n  <p>For LL(1) Grammar if there is left recursion or left factoring then that grammar is not LL(1) grammar if this applies to this grammar then it is not a LL(1) grammar</p>\n</blockquote>\n\n<p>$E \\to E+T \\mid E$</p>\n\n<p>$T \\to T$#$F \\mid F$</p>\n\n<p>$F \\to (E) \\mid i$</p>\n\n<p>I also have one more question: "Is there a Grammar which can be LL(1) but not LALR(1)"</p>\n', 'ViewCount': '49', 'Title': 'Which Type of Grammar is this?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-11T22:46:43.857', 'LastEditDate': '2014-02-11T07:24:00.183', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '21543', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14497', 'Tags': '<formal-grammars><compilers><parsing>', 'CreationDate': '2014-02-11T05:20:18.990', 'Id': '21520'},20191:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Is there a way to figure out what the following CFG accepts?</p>\n\n<p>$\\qquad\\begin{align}\n  S &amp;\\to S \\vee T \\mid T \\\\\n  T &amp;\\to T \\wedge F \\mid F \\\\ \n  F &amp;\\to p \\mid\\; \\thicksim p\n\\end{align}$</p>\n\n<p>I'm confused by the boolean algebra symbols. I know the first is S or T, the second is T and F and the third is not p but I'm not sure how they affect the grammar itself.</p>\n", 'ViewCount': '113', 'Title': 'What Do Logical Operators In a Grammar Mean?', 'LastEditorUserId': '13257', 'LastActivityDate': '2014-02-13T22:57:53.400', 'LastEditDate': '2014-02-12T21:58:19.707', 'AnswerCount': '2', 'CommentCount': '3', 'AcceptedAnswerId': '21540', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '13257', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2014-02-11T21:42:08.620', 'Id': '21539'},20192:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need help constructing a Left Linear grammar for the language</p>\n\n<p>$L = \\{ a^n b^m c^p \\mid n\\geq 2, m\\geq 3, p\\geq 4 \\}$</p>\n\n<p>Here is what I have so far, I know :</p>\n\n<p>$N = \\{S\\}$</p>\n\n<p>$T = \\{ a, b, c \\}$</p>\n\n<p>$P = \\{$</p>\n\n<p>$S \\rightarrow Pcccc$</p>\n\n<p>$P \\rightarrow Pc$</p>\n\n<p>$P \\rightarrow M$</p>\n\n<p>$M \\rightarrow Mbbb$</p>\n\n<p>$M \\rightarrow Mb$</p>\n\n<p>$M \\rightarrow N$</p>\n\n<p>$N \\rightarrow Naa$</p>\n\n<p>$N\\rightarrow a$</p>\n\n<p>$\\}$</p>\n\n<p>I need help figuring out the productions. I am not sure if I am doing it right.</p>\n', 'ViewCount': '40', 'Title': 'Left Linear Grammar: How to construct?', 'LastEditorUserId': '1636', 'LastActivityDate': '2014-02-17T07:07:05.667', 'LastEditDate': '2014-02-17T06:41:17.703', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '14744', 'Tags': '<formal-languages><regular-languages><formal-grammars>', 'CreationDate': '2014-02-17T05:23:46.860', 'Id': '21722'},20193:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I was trying to rule out whether this was LL(1) by checking for left-recursion in the following grammar:</p>\n\n<p>$\\qquad  A \\to 0 A 1 \\mid 0 1$</p>\n\n<p>Which produces:</p>\n\n<p>$\\qquad 0 A 1 \\Rightarrow 0 0 A 1 1 \\Rightarrow \\dots$</p>\n\n<p>But I am unsure what type of recursion this is called, since it sorta stays in the middle.</p>\n\n<p>If this is not left-recursive, would you agree that this is not LL(1) because non-terminal A has 0 appear twice in FIRST(A)?</p>\n', 'ViewCount': '51', 'Title': 'What type of recursion is this?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-02-19T00:04:23.193', 'LastEditDate': '2014-02-18T08:18:31.617', 'AnswerCount': '2', 'CommentCount': '0', 'AcceptedAnswerId': '21756', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<formal-grammars><parsers><left-recursion>', 'CreationDate': '2014-02-18T06:31:22.527', 'Id': '21753'},20194:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Here is a context-free grammar with a single nonterminal symbol S and three terminal symbols +, *, and s:</p>\n\n<p>S -> + S S | * S S| s</p>\n\n<p>My purpose is to build the <a href="http://en.wikipedia.org/wiki/LR_parser#LR_Generator_Analysis" rel="nofollow">LR state machine</a> for this grammar.  My attempt:</p>\n\n<pre><code>[State 0]      -&gt;     [State 1]       -&gt;       [State 2]\nS -&gt; . + S S   (+)    S -&gt; + . S S    (*)      S -&gt; * . S S\nS -&gt; . * S S          S -&gt; . * S S             S -&gt; . + S S //leads to loop\nS -&gt; .s               S -&gt; .s\n</code></pre>\n\n<p>When I get to state 2, I see that an infinite loop begins to form. I think I am missing/misunderstanding part of the algorithm to form the machine. Can you ignore a production if it already exists somewhere else?</p>\n', 'ViewCount': '73', 'Title': 'How to generate the LR(0) finite state machine for a grammar', 'LastEditorUserId': '885', 'LastActivityDate': '2014-03-20T21:49:21.737', 'LastEditDate': '2014-02-18T21:26:56.030', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '11616', 'Tags': '<automata><formal-grammars>', 'CreationDate': '2014-02-18T16:12:22.957', 'Id': '21774'},20195:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Context-free grammars, as well as other types of grammars, can naturally\nassociate structure with the strings of the defined language, for\nexample tree structures in the case of context-free language.</p>\n\n<p>What kind of structural features can be thus described by regular grammars,\nand associated with the strings of the language.</p>\n\n<p>One answer is of course that it can associate a non-terminals with\neach prefix (or suffix) of the string. That sorts the prefixes (or\nsuffixes) into sets that may intersect, depending on the grammar.\nBut what else would you see?</p>\n\n<p>related question : <a href="http://cs.stackexchange.com/questions/21306">Why CFG can specify structure of sentence but Regular grammar cannot?</a></p>\n', 'ViewCount': '38', 'Title': 'What kind of structural features of strings can be described by regular grammars?', 'LastActivityDate': '2014-02-20T16:22:49.207', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '8321', 'Tags': '<formal-languages><regular-languages><context-free><formal-grammars><syntax-trees>', 'CreationDate': '2014-02-20T16:22:49.207', 'Id': '21852'},20196:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Recently i was studying removal of useless symbols in productions given in Ullman Hopcroft.</p>\n\n<p>The grammar goes as follows</p>\n\n<p>S-> aAa | aBC</p>\n\n<p>A -> aS | bD</p>\n\n<p>B - > aBa | b</p>\n\n<p>C-> abb | DD</p>\n\n<p>D -> aDa</p>\n\n<p>In the explanation that follows, we eliminate D obviously, but the removal of C still baffles me. As D is non generating, but C is both generating and reachable. So why delete C?</p>\n\n<p>The resultant grammar is shown as </p>\n\n<p>S->aAa</p>\n\n<p>A->aS</p>\n\n<p>B->aBa | b</p>\n\n<p>Here is the link to the photo of the page in the book just in case</p>\n\n<p>Page 240: </p>\n\n<p><a href="http://tinypic.com/r/17wcw4/8" rel="nofollow">http://tinypic.com/r/17wcw4/8</a></p>\n\n<p>Page 241:</p>\n\n<p><a href="http://tinypic.com/r/29w1i82/8" rel="nofollow">http://tinypic.com/r/29w1i82/8</a></p>\n', 'ViewCount': '108', 'Title': 'Simplification of CFG', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-23T13:59:00.583', 'LastEditDate': '2014-02-22T09:45:25.000', 'AnswerCount': '1', 'CommentCount': '15', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '11927', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2014-02-22T01:18:48.460', 'Id': '21913'},20197:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I've a set of grammar rules like this:</p>\n\n<p>$$\n\\begin{align*}\n&amp;S \\to AbB \\\\\n&amp;A \\to aA|\\epsilon \\\\\n&amp;B \\to aB|bB|\\epsilon\n\\end{align*}\n$$</p>\n\n<p>The grammar generates the following words:\n$$\n\\begin{gather*}\nAbB \\to a^2AB \\to a^3AB \\to \\cdots \\to a^nAB \\to a^nB \\to \\\\\n\\to a^nB \\to a^nbB \\to a^nb^2B \\to \\cdots \\to a^nb^mB \\to a^nb^m,\n\\end{gather*}\n$$\nso if I did things right, $L(G) = a^n b^m$.\nI think that $G$ is a type 1 grammar.</p>\n\n<p>Now I need to design a more restrictive type of grammar that generates the same expression, and I'm stuck. Any help is much appreciated.</p>\n\n<p>My attempt according to the collapsar's answer: </p>\n\n<p>$$\n\\begin{align*}\n&amp;S \\to aSA|b \\\\\n&amp;A \\to a|b \\\\\n&amp;\n\\end{align*}\n$$</p>\n", 'ViewCount': '44', 'ClosedDate': '2014-03-19T17:24:10.183', 'Title': 'Designing a different grammer that generates same expression', 'LastEditorUserId': '15795', 'LastActivityDate': '2014-03-19T15:03:49.400', 'LastEditDate': '2014-03-19T15:03:49.400', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15795', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-03-17T21:35:41.273', 'Id': '22723'},20198:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '85', 'Title': 'Defining a context-free grammar for $\\{w \\in \\{0, 1\\}^* : \\#_0(w) = \\#_1(w)\\}$', 'LastEditDate': '2014-03-18T08:14:27.077', 'AnswerCount': '2', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '15798', 'FavoriteCount': '1', 'Body': "<p>I have a language where each string in the language has even amount of $0$'s as $1$'s (e.g., $0101$, $1010$, $1100$, $0011$, $10$ are all in the language). I was hoping to define a context-free grammar that describes this language. After defining a context-free grammar I want to formally prove that this context-free grammar describes this language.</p>\n\n<p>I've came up with the context-free grammar production rules:\n$$\n\\begin{align*}\n&amp;S\\to0S1S \\\\\n&amp;S\\to1S0S \\\\\n&amp;S\\to\\epsilon\n\\end{align*}\n$$\nIs this the correct context free grammar to define this language?</p>\n\n<p>Im kind of stumped for the proving part. I'm guessing I will need some sort of induction?</p>\n", 'ClosedDate': '2014-03-18T08:16:09.753', 'Tags': '<formal-languages><context-free><formal-grammars>', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-18T08:14:27.077', 'CommentCount': '1', 'AcceptedAnswerId': '22730', 'CreationDate': '2014-03-17T22:42:45.907', 'Id': '22729'},20199:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>If I have a DCFG G for some language over {0,1}* and a DCFG H for its complement, with disjoint non-terminals, and a (perhaps partially reduced) string, can they both have a handle for the string? So the right hand sides of these rules would consist of only terminals and one would be a (maybe proper) prefix of the other. I think it's possible but I'm not certain and can't quite show it. </p>\n", 'ViewCount': '37', 'Title': 'Complement DCFGs and handles', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-19T00:03:39.367', 'LastEditDate': '2014-03-19T00:03:39.367', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22778', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2014-03-18T15:33:08.417', 'Id': '22759'},20200:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have been starting to learn about CFGs and PDAs and have gotten familiar with the simple stuff. I have been able to construct CFGs for simple languages but this question is more specific:</p>\n\n<p>$\\lbrace 0^a1^b2^c3^d4^e5^f |a,b,c,d,e,f \\geq 0$ and $a+b=d+e\\rbrace$.</p>\n\n<p>My thought process has only gone so far. I see that if you add a 0 you must add a 3 or 4, the same is if you add a 1. And for adding a 3 or 4 the case is very similar. My biggest troubles are due to the characters that lay between the pairs of 0s,1s,3s and 4s. I haven't been able to produce a serious attempt yet, but will post it as an edit if I do. Any help would be appreciated.</p>\n\n<p><strong>Edit:</strong> Here is a possible solution I have come to:</p>\n\n<p>$S\\rightarrow AB$</p>\n\n<p>$A\\rightarrow 0A4|C|D$</p>\n\n<p>$B\\rightarrow B5|\\epsilon $</p>\n\n<p>$C\\rightarrow 0C3|E$</p>\n\n<p>$D\\rightarrow 1D4|E$</p>\n\n<p>$E\\rightarrow 1E3|F$</p>\n\n<p>$F\\rightarrow 2F|\\epsilon$.</p>\n", 'ViewCount': '25', 'Title': 'Construct context free grammar from language', 'LastEditorUserId': '15512', 'LastActivityDate': '2014-03-20T00:55:54.307', 'LastEditDate': '2014-03-20T00:55:54.307', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22833', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '15512', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-03-20T00:04:23.550', 'Id': '22832'},20201:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p><img src="http://i.stack.imgur.com/V79cK.png" alt="enter image description here"></p>\n\n<p>for this problem, it asks to prove that A and B are context free, however the CFL pumping lemma doesn\'t prove that. It proves when languages are not context free. Would the easiest way to prove these are context free is by coming up with a grammar for each one?</p>\n', 'ViewCount': '33', 'ClosedDate': '2014-03-20T22:42:30.083', 'Title': 'Prove a language is context-free', 'LastActivityDate': '2014-03-20T18:17:03.567', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<context-free><formal-grammars>', 'CreationDate': '2014-03-20T18:17:03.567', 'FavoriteCount': '1', 'Id': '22875'},20202:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>from Sipster's definition: Any language that can be generated by some context-free grammar (call it $G$) is called a context-free language (CFL). However, can $G$ generate strings that are not in the the language that recognizes $G$?</p>\n", 'ViewCount': '49', 'Title': 'Can a context free grammar for $L$, generate a string not in $L$?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-21T08:37:28.153', 'LastEditDate': '2014-03-21T08:37:28.153', 'AnswerCount': '1', 'CommentCount': '0', 'AcceptedAnswerId': '22883', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14864', 'Tags': '<terminology><context-free><formal-grammars>', 'CreationDate': '2014-03-20T20:49:23.283', 'Id': '22880'},20203:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>When converting a CFG to a PDA I know that you get three main states, Qstart, Qloop and Qaccept. But Qloops will need a various amount of states, and my question is how many? Is there a way to find out the "worst case scenario" of how many states there can potentially be? I don\'t mean for one particular CFG, but in general. I\'m having difficulties trying to figure out how I can calculate this... </p>\n', 'ViewCount': '62', 'Title': 'How many states when converting CFG to PDA', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-24T14:40:54.410', 'LastEditDate': '2014-03-24T10:49:04.057', 'AnswerCount': '2', 'CommentCount': '2', 'AcceptedAnswerId': '22994', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14436', 'Tags': '<context-free><automata><formal-grammars><pushdown-automata><simulation>', 'CreationDate': '2014-03-24T09:24:37.833', 'Id': '22992'},20204:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I need to find a context-free grammar for the following language which uses the alphabet $\\{a, b\\}$\n$$L=\\{a^nb^m\\mid 2n&lt;m&lt;3n\\}$$</p>\n', 'ViewCount': '115', 'ClosedDate': '2014-03-28T13:28:44.503', 'Title': 'Find a context-free grammar for the language $L=\\{a^nb^m\\mid 2n<m<3n\\}$', 'LastEditorUserId': '8321', 'LastActivityDate': '2014-03-28T13:26:47.350', 'LastEditDate': '2014-03-28T13:17:52.803', 'AnswerCount': '2', 'CommentCount': '9', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16233', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-03-28T13:00:10.153', 'Id': '23174'},20205:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>For example,</p>\n\n<p>Let the Grammar be:</p>\n\n<pre><code>S-&gt;Sa|B\n</code></pre>\n\n<p>Thus, <code>S-&gt;Sa-&gt;Saa-&gt;...-&gt;Saa...aaa-&gt;Baa...aaa</code></p>\n\n<p>What's wrong with this?</p>\n\n<p>Why is right recursion a solution to the problem?</p>\n\n<pre><code>S-&gt;BS'\nS-&gt;aS'|e\n</code></pre>\n", 'ViewCount': '35', 'ClosedDate': '2014-03-29T11:54:23.990', 'Title': 'Why does left recursion have to be eliminated?', 'LastEditorUserId': '98', 'LastActivityDate': '2014-03-29T11:54:13.160', 'LastEditDate': '2014-03-29T11:54:13.160', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '11684', 'Tags': '<context-free><formal-grammars><compilers><parsing><left-recursion>', 'CreationDate': '2014-03-29T05:06:57.450', 'Id': '23210'},20206:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>Let $P$ be a deterministic PDA recognizing a deterministic CFL with a binary alphabet. Modify $P$ to identify its <em>reading states</em> (denote this subset of states by $R$) in accordance with the construction in Theorem 2.42 in Sipser (3$^{rd}$ edition only) for complementing DPDA. The final states of $P$ are $F\\subset R$, and $\\overline{P}$ recognizing the complement language is given by the same DPDA, but with final states $R-F$. </p>\n\n<p>Combine this with the construction in Lemma 2.59 showing that every DPDA recognizing an end-marked language has an equivalent DCFG. Modify $P$ to have a new accept state $q_\\mbox{accept}$. If $P$ enters a state in $F$ after reading the endmarker, it empties its stack and goes to $q_\\mbox{accept}$. Now do the same with $R-F$ and a new sink state $q_\\mbox{reject}$. </p>\n\n<p>In the grammar $G$ we have a start variable $A_{q_0q_\\mbox{accept}}$ which generates every string that takes $P$ from $q_0$ to $q_\\mbox{accept}$ with empty stack. Let $\\overline{G}$ be a copy of $G$, without renaming the variables, but replace the start state with $A_{q_0q_\\mbox{reject}}$. Then these grammars are both deterministic, and generate complement languages with respect to the portion of the string preceding the endmarker.</p>\n\n<p>Why do this? I think we can show DCFLs with binary alphabets are closed under substitution with an endmarked language and its complement using such a grammar. I think this is not in general the case as otherwise the resulting grammar with substitutions may have a forced handle in the production rules of both substituted grammars. Consider for example the language $\\{w\\mid w\\in\\{0,1\\}^*,\\#_0(w)=\\#_1(w)\\}$. Every string in this language can be extended to one in the complement and vice versa, so there must be strings for which both grammars would be able to match a handle based on just some initial portion of the string. Using the grammar construction described above, there will never be more than one forced handle, and every string will resolve to one of the start symbols. </p>\n\n<p>If this is a legitimate way to construct the complementary grammars, the very restricted closure result follows easily from the determinism of the grammars involved. Can anyone poke some holes in this?   </p>\n', 'ViewCount': '35', 'Title': 'A construction to show a very restricted substitution closure result for DCFLs', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-01T07:42:25.793', 'LastEditDate': '2014-04-01T07:42:25.793', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '15486', 'Tags': '<formal-languages><context-free><formal-grammars><closure-properties><pushdown-automata>', 'CreationDate': '2014-03-31T08:17:43.793', 'Id': '23288'},20207:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have this context-free grammar and I want to find out whether its language is finite or infinite.</p>\n\n<pre><code>S -&gt; XY|bb  Step 1\nX -&gt; XY|SS  Step 2\nY -&gt; XY|SS  Step 3\n</code></pre>\n\n<p>So I would do</p>\n\n<pre><code>S -&gt; XY            From step 1\nS -&gt; YYY           From step 2\nS -&gt; SSYY          From step 3\nS -&gt; SSSSY         From step 3\nS -&gt; SSSSSS        From step 3\nS -&gt; bbSSSSS       From step 1\nS -&gt; bbbbSSS       From step 1\nS -&gt; bbbbbbSSS     From step 1\nS -&gt; bbbbbbbbSS    From step 1\nS -&gt; bbbbbbbbbbS   From step 1\nS -&gt; bbbbbbbbbbbb  From step 1\n\nbbbbbbbbbbbb \n</code></pre>\n\n<p>So I know how to generate words like this but how to find out whether the language is finite or infinite?</p>\n', 'ViewCount': '159', 'Title': "How to find whether a grammar's language is finite or infinite?", 'LastEditorUserId': '8321', 'LastActivityDate': '2014-04-03T14:05:21.387', 'LastEditDate': '2014-04-03T09:22:59.747', 'AnswerCount': '3', 'CommentCount': '1', 'AcceptedAnswerId': '23368', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<formal-languages><context-free><formal-grammars><proof-techniques><induction>', 'CreationDate': '2014-04-02T20:30:27.960', 'Id': '23367'},20208:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>Consider two sets: the set of validities of propositional logic and the set of validities of monadic predicate logic. Call the first set $VP$ and the second set $VQM$. Both of these sets are decidable, so there are Turing machines that recognize both them and their complements. </p>\n\n<p>I'm interested in how the decidability of these two sets translates into grammars for them, along the lines of the Chomsky hierarchy. I have three questions:</p>\n\n<p>(1) Are there context-sensitive grammars that generate $VP$ and $VQM$? The answer would be yes if the Turing machines that recognized these sets were linearly bounded, but I don't think they are. </p>\n\n<p>(2) If these languages <em>aren't</em> context-sensitive, can <em>anything</em> be said about a grammar that generates them? </p>\n\n<p>I would have a better grasp of the second question if I understood something about grammars <em>between</em> the top two levels of the Chomsky hierarchy, context-sensitive and unrestricted. </p>\n\n<p>(3) There is a natural class of automata between linear-bounded Turing machines and unrestricted Turing machines: polynomially bounded TMs, exponentially bounded TMs, etc. Do these classes of TM track anything on the grammar side of the Chomsky hierarchy? If not, is there <em>any</em> structure to the gap between context-sensitive grammars and full-on unrestricted grammars?</p>\n\n<p>(Just to be clear: I'm <em>not</em> talking about a grammar for propositional logic, but a grammar for its validities.) </p>\n\n<p>EDIT: I thought I'd add a comment about why I'm interested in these questions. I know there is an unrestricted grammar that generates the (recursively enumerable but not recursive) set of validities of (full-on, polyadic) predicate logic. But since $VP$ and $VQM$ are not just recursively enumerable but recursive, I was wondering if the grammars that generate them might have more structure, in the Chomsky-hierarchy sense, than the grammar that generates the validities of all of predicate logic. <strong>In other words, I'm wondering if there is a <em>grammatical</em> way of detecting the difference between sets of validities that are recursive (as in the case of propositional and monadic predicate logic) and sets of validities that are merely recursively enumerable.</strong> What can be said about grammars of recursive but not recursively enumerable languages? Most references on the Chomsky hierarchy say nothing about this gap, but I don't know if that means there's nothing to be said.</p>\n", 'ViewCount': '35', 'Title': 'grammatical complexity of propositional and monadic predicate validities? (and grammars for recursive but not context-sensitive languages?)', 'LastEditorUserId': '16445', 'LastActivityDate': '2014-04-04T22:33:44.240', 'LastEditDate': '2014-04-04T22:33:44.240', 'AnswerCount': '1', 'CommentCount': '1', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '16445', 'Tags': '<complexity-theory><formal-languages><formal-grammars><logic>', 'CreationDate': '2014-04-04T14:53:25.143', 'FavoriteCount': '1', 'Id': '23423'},20209:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I'm working with compression algorithms that use context-free grammars (e.g. RE-PAIR and SEQUITUR). These grammars look for frequently occurring digrams (pairs of adjacent symbols) in an input string and use recursive substitution with non-terminal symbols to achieve compression. </p>\n\n<p>What I'm wondering is whether there are classes of grammar and inference methods that are able to exploit sequential patterns that are based on non-adjacent co occurrence. </p>\n\n<p>Take the following input sequence:</p>\n\n<blockquote>\n  <p>XaXbXcYaYbYcZaZbZc</p>\n</blockquote>\n\n<p>No two adjacent symbols co-occur more than once anywhere here, so the sequential compression techniques I mention will not compress this string any further, however there is a clear pattern to the sequence and it must be compressible. How is it possible to do so?</p>\n", 'ViewCount': '74', 'Title': 'Compression of non-adjacent structure using grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-08T21:52:35.873', 'LastEditDate': '2014-04-08T09:05:33.517', 'AnswerCount': '3', 'CommentCount': '5', 'AcceptedAnswerId': '23548', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '12876', 'Tags': '<formal-languages><formal-grammars><data-compression>', 'CreationDate': '2014-04-08T07:49:56.070', 'Id': '23534'},20210:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u'<p>Does anyone know any good introductions to Formal Language theory and Formal Grammar, that cover the mathematical basis of Syntax and things like context free grammars and pushdown automata. In particular, I\'d like to be able to understand:</p>\n\n<p>-Parikh\u2019s theorem</p>\n\n<p>-Pentus\' proof that Lambek-calculus grammars define only context-free stringsets</p>\n\n<p>-the theorem of Chandra, Kozen and Stockmeyer</p>\n\n<p>-B\xfbchi\u2019s theorem and Doner\u2019s theorem</p>\n\n<p>Geoffrey Pullum\'s review <a href="http://www.lel.ed.ac.uk/~gpullum/Rev_Kracht.pdf" rel="nofollow">http://www.lel.ed.ac.uk/~gpullum/Rev_Kracht.pdf</a> has put me off reading a book called "The Mathematics of Language" by Markus Kracht, since I am not sure I have the required level of mathematical maturity. He writes:</p>\n\n<p>"Readers of The Mathematical Intelligencer will probably get on with it well enough, but others should be warned that Kracht assumes a lot of mathematical sophistication: graduate students whose first degree is in humanities or social science may experience symbol shock. Kracht does not pamper those who crave intuitive presentations. He will not explain that a finite automaton accepts exactly those strings on which there is a run beginning in the start state and ending in a final state; he will expect you to see that immediately when he tells you (on p.96) that $L(A) = \\{x \\colon~ \\delta(\\{i_0\\},x)\\cap F \\neq \\emptyset\\}$."</p>\n\n<p>The review has also put me off several other introductions:</p>\n\n<p>"W. J. M. Levelt\u2019s truly excellent 3-volume 1974 textbook [6] had remarkably wide coverage (Lev- elt\u2019s psycholinguistic interests lead him to cover work on \u2018learnability\u2019, also known as grammar induction, which Kracht does not touch on), but sadly has long been out of print. And the standard text by Partee, ter Meulen and Wall [9] is now more than fifteen years behind the leading edge of research, especially with respect to grammars and automata. (Though it was published in 1990, the Partee el al. volume reports as open the question of whether the complement of a context-sensitive stringset is always context-sensitive, which was settled in the affirmative in 1987, at Partee\u2019s insti- tution!) Though strong on formal semantics, it completely misses important topics in other areas (parsing and computational complexity, for example), and it looks positively fusty beside Kracht\u2019s much more up-to-date and considerably more mathematical book."</p>\n\n<p>So I\'d be grateful to hear if there are any introductions to this field which people can recommend.</p>\n', 'ViewCount': '62', 'Title': 'Good introductions to Formal Language Theory and Formal Grammars', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-08T23:10:13.477', 'LastEditDate': '2014-04-08T23:10:13.477', 'AnswerCount': '0', 'CommentCount': '4', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '16562', 'Tags': '<formal-languages><context-free><formal-grammars><pushdown-automata>', 'CreationDate': '2014-04-08T18:09:27.717', 'Id': '23557'},20211:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I saw the answer in one of the solutions and I cannot figure out how they got the answer. The question is asked if the word is in the language or not for CNF...</p>\n\n<p>How did they get the answer so that ab is in the language and aaaa is not in the language here ?</p>\n\n<pre><code>S -&gt; aSb |ab\n\nab     Yes\naaaa   No\naabb   Yes\n</code></pre>\n\n<p>edit:\nis <code>aaaa No</code> because it has b in <code>aSb</code> and <code>ab</code> is yes because obviously <code>ab</code> is there in <code>aSb |ab</code></p>\n\n<p>also <code>aabb</code> is in the language because of <code>aSb</code> cause you would add same amount of <code>a's</code> and <code>b's</code> to both sides</p>\n", 'ViewCount': '223', 'Title': 'Proving that a word is *not* generated by a context-free grammar', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-09T23:06:13.337', 'LastEditDate': '2014-04-09T22:54:02.310', 'AnswerCount': '2', 'CommentCount': '6', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '14495', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-04-09T21:55:24.510', 'Id': '23609'},20212:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I am trying to use the pumping lemma to show this language is not context free:\n$L = a^nb^{n+1}c^{2n} : n \\ge 0$</p>\n\n<p>So I took $z = a^mb^{m+1}c^{2m}$ where $|z| = 4m+1 &gt; m$. We can decompose $z = a^mb^{m+1}c^{2m}$ to $z = uvwxy$ for $|vwx| \\le m$ and $|vx| \\ge 1$.</p>\n\n<p>I am confused about what cases to consider to show this is not context free? </p>\n', 'ViewCount': '38', 'Title': 'Show L is not context free using the CFL pumping lemma', 'LastActivityDate': '2014-04-10T04:42:57.707', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '-1', 'PostTypeId': '1', 'OwnerUserId': '16610', 'Tags': '<context-free><formal-grammars><pumping-lemma>', 'CreationDate': '2014-04-10T01:51:42.690', 'Id': '23618'},20213:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>In an assignment I\'ve been asked to find a CFG for $a^x b^y a^z b^w$, where, $x,y,z,w \\in \\mathbb{N}^+$, $y &gt; x$, $z &gt; w$, and $x+z = y+w$. A hint was given, think of the language as $(a^p b^p)(b^q a^q)(a^r b^r)$.</p>\n\n<p>I\'ve had a go at it, and have come up with </p>\n\n<ul>\n<li>S -> A </li>\n<li>A -> aAbB | ab  </li>\n<li>B -> bBaC | ba </li>\n<li>C -> aCb | ab</li>\n</ul>\n\n<p>This language will give me equal $a$\'s and $b$\'s. The reason I\'ve chained the productions together is that since $x,y,z,w$ can\'t be 0, when one production is done, the others must be done as well (that was my thinking). However, I can\'t help but be worried about order. Even the smallest production won\'t come out as in the order "abab". Is it possible to construct a CFG that imposes order and memory? Or do I have to go to a PDA then CFG? Or is it irrelevant?</p>\n', 'ViewCount': '54', 'Title': 'Find a CFG for a language', 'LastEditorUserId': '13022', 'LastActivityDate': '2014-04-10T11:44:40.630', 'LastEditDate': '2014-04-10T11:09:17.643', 'AnswerCount': '2', 'CommentCount': '1', 'AcceptedAnswerId': '23632', 'Score': '0', 'PostTypeId': '1', 'OwnerUserId': '16625', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-04-10T09:38:39.543', 'Id': '23631'},20214:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': u"<p>Giving the following Grammar:<br></p>\n\n<pre><code>S \u2192 ^ | SaSMSM |  SMSaSM | SMSMSa   \nM \u2192 b | c\n</code></pre>\n\n<p><br>\n^ means eopsilon.</p>\n\n<p>How can i check whether its ambgious or not?\nMy intuition is that its not: every time you derive,the a is placed in different places between the M's.</p>\n\n<p>Can you give me a clue to get a better prove? Or give an example for its ambiguity?<br>\n<br>\nIn other words,Can i have to different derevation trees for a same string in this grammar?\n<br>\nThank you.</p>\n", 'ViewCount': '39', 'Title': 'How to check ambiguity of a specific grammar', 'LastEditorUserId': '16678', 'LastActivityDate': '2014-04-11T11:27:38.387', 'LastEditDate': '2014-04-11T11:01:26.010', 'AnswerCount': '1', 'CommentCount': '6', 'AcceptedAnswerId': '23670', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16678', 'Tags': '<formal-languages><context-free><formal-grammars>', 'CreationDate': '2014-04-11T10:49:03.413', 'Id': '23669'},20215:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>mexp ::= (&lt; mexp >) | &lt; mexp >&lt; mathlowop >&lt; mexp > | &lt; mulexp > | &lt; float > | &lt; var ></p>\n\n<p>mulexp ::= &lt; mexp >&lt; mathhighop >&lt; mexp ></p>\n\n<p>mathlowop ::= + | -</p>\n\n<p>mathhighop ::= / | *</p>\n\n<p>That's the BNF I've come up with for parsing simple mathematical expressions where the operands can only be floats or variables. I've looked at a number of resources in books and on the web and for the same type of problem, they usually have a slightly longer, more complex bnf. Is my BNF incorrect in some way? Or is it correct but there is a significant advantage in doing it another way?</p>\n", 'ViewCount': '34', 'Title': 'Grammar for parsing simple mathematical expression', 'LastActivityDate': '2014-04-14T00:35:20.040', 'AnswerCount': '2', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16739', 'Tags': '<formal-grammars>', 'CreationDate': '2014-04-13T13:58:15.127', 'Id': '23738'},20216:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>$L = \\{a^i b^j c^i d^j | i, j \\geq 1\\}$ ,\nit has two loops that are the same , I tried alot finding the proper grammar but I got confused and tired\nWhat's the Grammar?\nCan anyone help please???</p>\n", 'ViewCount': '27', 'ClosedDate': '2014-04-20T20:27:11.837', 'Title': 'Phrase Structure Grammar without rules', 'LastEditorUserId': '5167', 'LastActivityDate': '2014-04-19T19:11:20.033', 'LastEditDate': '2014-04-19T19:11:20.033', 'AnswerCount': '0', 'CommentCount': '3', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '16916', 'Tags': '<formal-grammars>', 'CreationDate': '2014-04-19T18:14:58.373', 'Id': '23940'},20217:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': "<p>I have pretty simple question, but still can't find an answer just googling it.</p>\n\n<p>I'm trying to understand Chomsky Normal Form (CNF). There are three production rules:</p>\n\n<ol>\n<li>$A \\to BC$</li>\n<li>$A \\to \\alpha$</li>\n<li>$S \\to \\epsilon$</li>\n</ol>\n\n<p>First two I understand. But last one $\\epsilon$ doesn't makes sense for me. Why do we need this rule? What is use of having this?</p>\n", 'ViewCount': '36', 'Title': 'Chomsky normal form: epsilon rule', 'LastActivityDate': '2014-04-22T02:25:37.930', 'AnswerCount': '1', 'CommentCount': '2', 'AcceptedAnswerId': '24014', 'Score': '2', 'OwnerDisplayName': 'Igor Konoplyanko', 'PostTypeId': '1', 'OwnerUserId': '16976', 'Tags': '<formal-grammars><context-free>', 'CreationDate': '2014-04-21T23:11:20.297', 'Id': '24012'},20218:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>I have a VHDL elaboration engine/simulator. As I understand it, the language syntax allows for ambiguities at syntax level. That is, an assignment</p>\n\n<pre><code>pin_value &lt;= bus(5)\n</code></pre>\n\n<p>can be interpreted as picking a child of the bus by index. Here the bus is a signal (an object). However, it can also be that paranthis are applied to a type</p>\n\n<pre><code>int_signal &lt;= integer(1.1)\n</code></pre>\n\n<p>which should be interpreted as type conversion.</p>\n\n<p>I wonder. The elaborator should take the parse tree, instantiate objects and tie them together resolving the names. However, the parser has no idea if the prefix at the parensis is a type or array. So, it treats all parensis as indexed objects.</p>\n\n<pre><code>simple_assignment ::= target &lt;= value_expression { , value_expression } \nvalue_expression ::= name | literal | function_call | type_conversion \nname ::= simple_name | indexed_name \nindexed_name ::= prefix ( expression { , expression } ) // example: REG_ARRAY(5)    \ntype_conversion ::= type_mark ( expression )\n</code></pre>\n\n<p>I do not see how can I distinguish between value_expression and type_conversion at syntactic level. My parser parses both as indexed_name and name resolution, when fails to find array object, falls back into type conversion. I am asking if such case analysis it the only way to handle the problem or more strighnforward approach exists that I am missing?</p>\n', 'ViewCount': '49', 'Title': 'parsing at semantic level due to ambiguities', 'LastEditorUserId': '98', 'LastActivityDate': '2014-04-22T22:10:45.090', 'LastEditDate': '2014-04-22T22:10:45.090', 'AnswerCount': '1', 'CommentCount': '2', 'Score': '2', 'PostTypeId': '1', 'OwnerUserId': '2879', 'Tags': '<formal-grammars><parsers><ambiguity>', 'CreationDate': '2014-04-22T20:11:35.043', 'Id': '24032'},20219:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'Body': '<p>The exercise says </p>\n\n<p>"Show that the grammar $G = \\langle\\{S\\}, \\{a, b\\}, S, \\{S \\to \\lambda, S \\to aSb\\}\\rangle$ \ngenerates the language $L = \\{a^i b^i \\mid i = 0, 1, 2, \\ldots\\}$."</p>\n\n<p>Now, I\'m new to this subject although I\'m familiar with the theory of Turing machines and automata. I\'m teaching myself (not in a class, completely independently) from scratch. Please go easy on me.</p>\n\n<p>Now, two questions:</p>\n\n<p>(1) I suspect the way to do this proof is by induction on $i$, which is to say induction on the iterations of letters in the alphabet or the length of the word formed by iterations of $a, b$. <strong><em>Is this assumption correct?</em></strong></p>\n\n<p>(2) If the assumption in (1) is not correct, what <strong><em>is</em></strong> the correct strategy?</p>\n', 'ViewCount': '81', 'Title': 'A Question from Introduction to Formal Languages by Gyorgy E. Revesz; Exercise 1.1', 'LastEditorUserId': '683', 'LastActivityDate': '2014-04-28T03:02:00.173', 'LastEditDate': '2014-04-28T03:00:51.613', 'AnswerCount': '1', 'CommentCount': '0', 'Score': '3', 'PostTypeId': '1', 'OwnerUserId': '17107', 'Tags': '<formal-languages><formal-grammars>', 'CreationDate': '2014-04-28T02:42:37.180', 'FavoriteCount': '1', 'Id': '24170'},20220:{'color':getRandomColor(),'shape':'dot','label':'Strings', 'size': 60, 'isExploded':false, "precedence": 2,'ViewCount': '28', 'Title': 'Constructing an unrestricted grammar for a^n b^m c^n d^m', 'LastEditDate': '2014-05-02T23:52:33.843', 'AnswerCount': '1', 'Score': '1', 'PostTypeId': '1', 'OwnerUserId': '17197', 'Body': "<p>I've been trying to construct an unrestricted grammar which has the language:</p>\n\n<p><code>L = {a^n b^m c^n d^m | n&gt;0, m&gt;0}</code></p>\n\n<p>But I can't seem to figure it out without making the derivations run an unreasonably long amount of time.  Can anyone help me devise an elegant way to create this grammar?</p>\n\n<p>Edit: In order to clarify, I was trying to find an Unrestricted Grammar that would run in <code>O(n^2)</code> time or better.  As it stood, all of my solutions were exponential, which made parsing very long strings prohibitively costly.</p>\n", 'ClosedDate': '2014-04-30T17:24:56.633', 'Tags': '<formal-languages><formal-grammars>', 'LastEditorUserId': '17197', 'LastActivityDate': '2014-05-02T23:52:33.843', 'CommentCount': '2', 'AcceptedAnswerId': '24244', 'CreationDate': '2014-04-29T23:39:58.147', 'Id': '24243'}